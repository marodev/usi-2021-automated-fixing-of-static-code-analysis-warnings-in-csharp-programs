Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Peachpie.Runtime
    #1 Path: D:\a\1\s\src\Peachpie.Runtime\Comparison.cs, Line: 227, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #2 Path: D:\a\1\s\src\Peachpie.Runtime\Context.cs, Line: 248, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #3 Path: D:\a\1\s\src\Peachpie.Runtime\Context.cs, Line: 753, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #4 Path: D:\a\1\s\src\Peachpie.Runtime\Conversions.cs, Line: 308, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #5 Path: D:\a\1\s\src\Peachpie.Runtime\Conversions.cs, Line: 374, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\src\Peachpie.Runtime\Conversions.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #7 Path: D:\a\1\s\src\Peachpie.Runtime\Reflection\PhpStackTrace.cs, Line: 435, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #8 Path: D:\a\1\s\src\Peachpie.Runtime\Reflection\ReflectionUtils.cs, Line: 226, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Peachpie.Library
    #9 Path: D:\a\1\s\src\Peachpie.Library\DateTime\DateTime.cs, Line: 414, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\src\Peachpie.Library\DateTime\DateTime.cs, Line: 473, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #11 Path: D:\a\1\s\src\Peachpie.Library\DateTime\DateTimeFunctions.cs, Line: 1577, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #12 Path: D:\a\1\s\src\Peachpie.Library\DateTime\DateTimeFunctions.cs, Line: 1579, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #13 Path: D:\a\1\s\src\Peachpie.Library\DateTime\DateTimeFunctions.cs, Line: 1581, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #14 Path: D:\a\1\s\src\Peachpie.Library\DateTime\DateTimeFunctions.cs, Line: 1583, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #15 Path: D:\a\1\s\src\Peachpie.Library\LibXml.cs, Line: 52, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #16 Path: D:\a\1\s\src\Peachpie.Library\LibXml.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\src\Peachpie.Library\Mail.cs, Line: 672, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #18 Path: D:\a\1\s\src\Peachpie.Library\Mail.cs, Line: 726, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #19 Path: D:\a\1\s\src\Peachpie.Library\Mail.cs, Line: 732, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #20 Path: D:\a\1\s\src\Peachpie.Library\Options.cs, Line: 461, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #21 Path: D:\a\1\s\src\Peachpie.Library\Parsers\GPPG.cs, Line: 595, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #22 Path: D:\a\1\s\src\Peachpie.Library\Phar\PharExtensions.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\Peachpie.Library\Phar\PharExtensions.cs, Line: 189, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #24 Path: D:\a\1\s\src\Peachpie.Library\Reflection\ReflectionMethod.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\src\Peachpie.Library\Serialization.cs, Line: 1137, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #26 Path: D:\a\1\s\src\Peachpie.Library\Serialization.Json.cs, Line: 504, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #27 Path: D:\a\1\s\src\Peachpie.Library\Session.cs, Line: 700, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #28 Path: D:\a\1\s\src\Peachpie.Library\SPL\Datastructures.cs, Line: 333, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #29 Path: D:\a\1\s\src\Peachpie.Library\Streams\NativeStream.cs, Line: 42, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #30 Path: D:\a\1\s\src\Peachpie.Library\Streams\PhpStream.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\src\Peachpie.Library\Streams\StreamContext.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\Peachpie.Library\Streams\Streams.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\src\Peachpie.Library\Variables.cs, Line: 220, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\src\Peachpie.Library\Variables.cs, Line: 227, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\src\Peachpie.Library\zip.cs, Line: 52, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #36 Path: D:\a\1\s\src\Peachpie.Library\zlib.cs, Line: 122, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: D:\a\1\s\src\Peachpie.Library\zlib.cs, Line: 312, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\src\Peachpie.Library\zlib.cs, Line: 368, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Peachpie.CodeAnalysis
    #39 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.cs, Line: 115, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #40 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs, Line: 1405, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #41 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs, Line: 32, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #42 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs, Line: 3486, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #43 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundEdge.cs, Line: 1124, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #44 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs, Line: 3034, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #45 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs, Line: 3051, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #46 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceTypeSymbol.cs, Line: 427, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Compilation\PhpCompilation.Types.cs, Line: 629, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #48 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\DocumentationComments\CommentIdResolver.cs, Line: 16, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #49 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\DocumentationComments\CommentIdResolver.cs, Line: 17, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #50 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\DocumentationComments\CommentIdResolver.cs, Line: 18, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #51 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\DocumentationComments\CommentIdResolver.cs, Line: 33, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #52 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\DocumentationComments\DocumentationCommentCompiler.cs, Line: 293, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #53 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Emitter\Model\PEModuleBuilder.cs, Line: 793, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisWalker.cs, Line: 176, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #55 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisWalker.cs, Line: 186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #56 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisWalker.cs, Line: 191, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #57 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisWalker.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #58 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs, Line: 2359, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #59 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\PHPDoc.cs, Line: 187, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Model\GlobalSymbolProvider.cs, Line: 391, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #61 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #62 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #63 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 1191, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #64 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 12, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #65 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 13, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #66 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 40, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #67 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 514, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #68 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 515, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #69 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 516, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #70 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 530, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #71 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 531, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #72 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 532, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #73 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 533, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #74 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 534, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #75 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 535, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #76 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 536, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #77 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 537, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #78 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 538, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #79 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 539, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #80 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 540, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #81 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 542, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #82 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 543, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #83 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 544, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #84 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 545, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #85 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 546, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #86 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 547, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #87 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 548, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #88 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #89 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 606, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #90 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 611, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #91 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 794, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #92 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #93 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\SemanticsBinder.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #94 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\TypeRefExtension.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #95 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\CustomModifier.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\CustomModifier.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\PE\PENamedTypeSymbol.cs, Line: 110, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #98 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\PE\PENamedTypeSymbol.cs, Line: 1267, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #99 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs, Line: 118, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #100 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs, Line: 22, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #101 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #102 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 109, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #103 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 115, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #104 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 21, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #105 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 66, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #106 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 72, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #107 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 87, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #108 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpTypeSymbolExtensions.cs, Line: 93, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #109 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Source\SourceFunctionSymbol.cs, Line: 137, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #110 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Source\SourceTypeSymbol.cs, Line: 1182, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #111 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Source\SourceTypeSymbol.cs, Line: 1208, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #112 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Source\SourceTypeSymbol.cs, Line: 1225, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #113 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\SpecialParameterSymbol.cs, Line: 111, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #114 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\SpecialParameterSymbol.cs, Line: 118, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #115 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\SpecialParameterSymbol.cs, Line: 80, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #116 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Synthesized\SynthesizedCtorSymbol.cs, Line: 337, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #117 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\TypedConstantExtensions.cs, Line: 166, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #118 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\TypedConstantExtensions.cs, Line: 93, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #119 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\TypeSymbolExtensions.cs, Line: 49, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #120 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs, Line: 250, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #121 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ExceptionUtilities.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #122 Path: D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\NameUtils.cs, Line: 35, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Peachpie.Library.MySql
    #123 Path: D:\a\1\s\src\Peachpie.Library.MySql\MySql.Functions.cs, Line: 569, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #124 Path: D:\a\1\s\src\Peachpie.Library.MySql\MySqli\mysqli.cs, Line: 397, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Peachpie.Library.MsSql
    #125 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbProcedure.cs, Line: 50, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #126 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 104, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #127 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 109, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #128 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 114, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #129 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 119, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #130 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 126, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #131 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 132, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #132 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 138, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #133 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 144, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #134 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 150, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #135 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 157, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #136 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 163, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #137 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 169, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #138 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 175, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #139 Path: D:\a\1\s\src\Peachpie.Library.MsSql\PhpSqlDbResult.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Peachpie.NET.Sdk
    #140 Path: D:\a\1\s\src\Peachpie.NET.Sdk\SimpleJSON\SimpleJSON.cs, Line: 1046, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #141 Path: D:\a\1\s\src\Peachpie.NET.Sdk\SimpleJSON\SimpleJSON.cs, Line: 1131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #142 Path: D:\a\1\s\src\Peachpie.NET.Sdk\SimpleJSON\SimpleJSON.cs, Line: 1134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #143 Path: D:\a\1\s\src\Peachpie.NET.Sdk\SimpleJSON\SimpleJSON.cs, Line: 1205, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #144 Path: D:\a\1\s\src\Peachpie.NET.Sdk\SimpleJSON\SimpleJSON.cs, Line: 697, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #145 Path: D:\a\1\s\src\Peachpie.NET.Sdk\SimpleJSON\SimpleJSON.cs, Line: 713, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Peachpie.Library.Graphics
    #146 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 133, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #147 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 174, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #148 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 180, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #149 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 193, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #150 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 199, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #151 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 205, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #152 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 211, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #153 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 217, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #154 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 223, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #155 Path: D:\a\1\s\src\Peachpie.Library.Graphics\Exif.cs, Line: 229, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #156 Path: D:\a\1\s\src\Peachpie.Library.Graphics\PhpGdImageResource.cs, Line: 127, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #157 Path: D:\a\1\s\src\Peachpie.Library.Graphics\PhpImage.cs, Line: 1317, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Peachpie.Library.XmlDom
    #158 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\DOMXPath.cs, Line: 187, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\DOMXPath.cs, Line: 249, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\SimpleXml.cs, Line: 1322, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 452, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 456, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 471, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #164 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 502, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #165 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 506, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 536, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\src\Peachpie.Library.XmlDom\XsltProcessor.cs, Line: 540, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Peachpie.Library.Network
    #168 Path: D:\a\1\s\src\Peachpie.Library.Network\CURLConstants.cs, Line: 557, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #169 Path: D:\a\1\s\src\Peachpie.Library.Network\CURLFunctions.cs, Line: 170, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #170 Path: D:\a\1\s\src\Peachpie.Library.Network\CURLFunctions.cs, Line: 531, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #171 Path: D:\a\1\s\src\Peachpie.Library.Network\CURLFunctions.cs, Line: 544, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Peachpie.RequestHandler
    #172 Path: D:\a\1\s\src\Peachpie.RequestHandler\Session\AspNetSessionHelpers.cs, Line: 35, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #173 Path: D:\a\1\s\src\Peachpie.RequestHandler\Session\AspNetSessionHelpers.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



--- Rules Summary ---
R5: 75
R8: 31
R9: 19
R4: 19
R2: 16
R7: 12
R6: 1

--- Summary ---
Fixed ReSharper issues: 157
Fixed SonarQube issues: 95
Total fixed issues: 173

Finished in: 39 s

######################################################################
Nr: 1 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Peachpie.Runtime\Operators.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Pchp.Core.Reflection;
using Pchp.Core.Resources;

namespace Pchp.Core
{
    [DebuggerNonUserCode, DebuggerStepThrough]
    public static class Operators
    {
        #region Numeric

        /// <summary>
        /// Bit mask corresponding to the sign in <see cref="long"/> value.
        /// </summary>
        internal const long LONG_SIGN_MASK = (1L << (8 * sizeof(long) - 1));

        /// <summary>
        /// Performs bitwise and operation.
        /// </summary>
        internal static PhpValue BitAnd(in PhpValue x, in PhpValue y)
        {
            var bx = x.ToBytesOrNull();
            if (bx != null)
            {
                var by = y.ToBytesOrNull();
                if (by != null)
                {
                    return PhpValue.Create(BitAnd(bx, by));
                }
            }

            //
            return PhpValue.Create(x.ToLong() & y.ToLong());
        }

        /// <summary>
        /// Performs bitwise or operation.
        /// </summary>
        internal static PhpValue BitOr(in PhpValue x, in PhpValue y)
        {
            var bx = x.ToBytesOrNull();
            if (bx != null)
            {
                var by = y.ToBytesOrNull();
                if (by != null)
                {
                    return PhpValue.Create(BitOr(bx, by));
                }
            }

            //
            return PhpValue.Create(x.ToLong() | y.ToLong());
        }

        /// <summary>
        /// Performs exclusive or operation.
        /// </summary>
        internal static PhpValue BitXor(in PhpValue x, in PhpValue y)
        {
            var bx = x.ToBytesOrNull();
            if (bx != null)
            {
                var by = y.ToBytesOrNull();
                if (by != null)
                {
                    return PhpValue.Create(BitXor(bx, by));
                }
            }

            //
            return PhpValue.Create(x.ToLong() ^ y.ToLong());
        }

        static byte[] BitAnd(byte[] bx, byte[] by)
        {
            int length = Math.Min(bx.Length, by.Length);
            if (length == 0)
            {
                return Array.Empty<byte>();
            }

            byte[] result = new byte[length];

            for (int i = 0; i < result.Length; i++)
            {
                result[i] = (byte)(bx[i] & by[i]);
            }

            return result;
        }

        static byte[] BitOr(byte[] bx, byte[] by)
        {
            if (bx.Length == 0 && by.Length == 0)
            {
                return Array.Empty<byte>();
            }

            byte[] result, or;
            if (bx.Length > by.Length)
            {
                result = (byte[])bx.Clone();
                or = by;
            }
            else
            {
                result = (byte[])by.Clone();
                or = bx;
            }

            for (int i = 0; i < or.Length; i++)
            {
                result[i] |= or[i];
            }

            return result;
        }

        static byte[] BitXor(byte[] bx, byte[] by)
        {
            int length = Math.Min(bx.Length, by.Length);
            byte[] result = new byte[length];

            return BitXor(result, bx, by);
        }

        /// <summary>
        /// Performs specified binary operation on arrays of bytes.
        /// </summary>
        /// <param name="result">An array where to store the result. Data previously stored here will be overwritten.</param>
        /// <param name="x">The first operand.</param>
        /// <param name="y">The second operand</param>
        /// <returns>The reference to the the <paramref name="result"/> array.</returns>
        static byte[] BitXor(byte[]/*!*/ result, byte[]/*!*/ x, byte[]/*!*/ y)
        {
            Debug.Assert(result != null && x != null && y != null && result.Length <= x.Length && result.Length <= y.Length);

            for (int i = 0; i < result.Length; i++)
            {
                result[i] = unchecked((byte)(x[i] ^ y[i]));
            }

            // remaining bytes are ignored //
            return result;
        }

        /// <summary>
        /// Performs bitwise negation.
        /// </summary>
        internal static PhpValue BitNot(in PhpValue x)
        {
            switch (x.TypeCode)
            {
                case PhpTypeCode.Long: return PhpValue.Create(~x.Long);

                case PhpTypeCode.Alias: return ~x.Alias.Value;

                case PhpTypeCode.String:
                case PhpTypeCode.MutableString:
                    throw new NotImplementedException();    // bitwise negation of each character in string

                case PhpTypeCode.Object:
                    if (x.Object == null)
                    {
                        return PhpValue.Null;
                    }
                    goto default;

                default:
                    // TODO: Err UnsupportedOperandTypes
                    return PhpValue.Null;
            }
        }

        /// <summary>
        /// Performs division according to PHP semantics.
        /// </summary>
        /// <remarks>The division operator ("/") returns a float value unless the two operands are integers
        /// (or strings that get converted to integers) and the numbers are evenly divisible,
        /// in which case an integer value will be returned.</remarks>
        internal static PhpNumber Div(in PhpValue x, in PhpValue y)
        {
            var info = x.ToNumber(out var nx) | y.ToNumber(out var ny);

            if ((info & Convert.NumberInfo.IsPhpArray) != 0)
            {
                throw PhpException.ErrorException(ErrResources.unsupported_operand_types);
            }

            // TODO: // division by zero:
            //if (y == 0)
            //{
            //    PhpException.Throw(PhpError.Warning, CoreResources.GetString("division_by_zero"));
            //    return false;
            //}

            return nx / ny;
        }

        #endregion

        #region Assignment

        /// <summary>
        /// Assigns a PHP value by value according to the PHP semantics.
        /// </summary>
        /// <param name="target">Target of the assignment.</param>
        /// <param name="value">Value to be assigned.</param>
        public static void SetValue(ref PhpValue target, PhpValue value)
        {
            Debug.Assert(!value.IsAlias);
            if (target.Object is PhpAlias alias)
            {
                alias.Value = value;
            }
            else
            {
                target = value;
            }
        }

        /// <summary>
        /// Assigns a PHP value to an aliased place.
        /// </summary>
        /// <param name="target">Target of the assignment.</param>
        /// <param name="value">Value to be assigned.</param>
        public static void SetValue(PhpAlias/*!*/target, PhpValue value)
        {
            Debug.Assert(target != null);
            Debug.Assert(!value.IsAlias);
            target.Value = value;
        }

        /// <summary>
        /// "unset" operator.
        /// </summary>
        public static void UnsetValue(ref PhpValue target)
        {
            if (target.Object is PhpAlias alias)
            {
                alias.ReleaseRef();
            }

            target = default;
        }

        /// <summary>
        /// "unset" operator.
        /// </summary>
        public static void UnsetValue(ref PhpAlias target)
        {
            if (target != null)
            {
                target.ReleaseRef();
                target = PhpAlias.Create(default);
            }
        }

        #endregion

        #region Ensure

        /// <summary>
        /// Ensures given variable is not <c>null</c>.
        /// </summary>
        public static object EnsureObject(ref object obj) => obj ?? (obj = new stdClass());

        /// <summary>
        /// Ensures given variable is not <c>null</c>.
        /// </summary>
        public static PhpArray EnsureArray(ref PhpArray arr) => arr ?? (arr = new PhpArray());

        /// <summary>
        /// Ensures given variable is not <c>null</c>.
        /// </summary>
        public static IPhpArray EnsureArray(ref IPhpArray arr) => arr ?? (arr = new PhpArray());

        /// <summary>
        /// Ensures the value is <see cref="PhpString"/> and gets mutable access to the value (non-shared).
        /// </summary>
        /// <returns>Object on which edit operations can be performed. Cannot be <c>null</c>.</returns>
        public static PhpString.Blob EnsureWritableString(ref PhpValue value)
        {
            PhpString.Blob blob;

            switch (value.TypeCode)
            {
                case PhpTypeCode.MutableString:
                    if ((blob = value.MutableStringBlob).IsShared)
                    {
                        value = new PhpValue(blob = value.MutableStringBlob.ReleaseOne());
                    }
                    break;

                case PhpTypeCode.Null:
                    blob = new PhpString.Blob();
                    value = new PhpValue(blob);
                    break;

                case PhpTypeCode.String:
                    blob = new PhpString.Blob(value.String);
                    value = new PhpValue(blob);
                    break;

                case PhpTypeCode.Alias:
                    blob = value.Alias.EnsureWritableString();
                    break;

                default:
                    blob = new PhpString.Blob(value.ToStringUtf8());
                    value = new PhpValue(blob);
                    break;
            }

            return blob;
        }

        #endregion

        #region IsSet, IsEmpty

        /// <summary>
        /// Implementation of PHP <c>isset</c> operator.
        /// </summary>
        /// <remarks>Value (eventualy dereferenced value) is not <c>NULL</c>.</remarks>
        public static bool IsSet(PhpValue value) => !value.IsNull;

        /// <summary>
        /// Implements <c>empty</c> operator.
        /// </summary>
        public static bool IsEmpty(PhpValue value) => value.IsEmpty;

        /// <summary>
        /// Implements <c>empty</c> operator on objects.
        /// </summary>
        public static bool IsEmpty(object value) => ReferenceEquals(value, null);

        #endregion

        #region Array Access

        /// <summary>
        /// Provides <see cref="IPhpArray"/> interface for <see cref="ArrayAccess"/> instance.
        /// </summary>
        sealed class ArrayAccessAsPhpArray : IPhpArray
        {
            readonly ArrayAccess _array;

            public ArrayAccessAsPhpArray(ArrayAccess array)
            {
                Debug.Assert(array != null);
                _array = array;
            }

            public int Count
            {
                get
                {
                    throw new NotSupportedException();
                }
            }

            public void AddValue(PhpValue value) => SetItemValue(PhpValue.Null, value);

            public PhpAlias EnsureItemAlias(IntStringKey key)
            {
                var item = _array.offsetGet(key);
                return PhpValue.EnsureAlias(ref item);
            }

            public IPhpArray EnsureItemArray(IntStringKey key)
            {
                var item = _array.offsetGet(key);
                return PhpValue.EnsureArray(ref item);
            }

            public object EnsureItemObject(IntStringKey key)
            {
                var item = _array.offsetGet(key);
                return PhpValue.EnsureObject(ref item);
            }

            public PhpValue GetItemValue(IntStringKey key) => _array.offsetGet(PhpValue.Create(key));

            public PhpValue GetItemValue(PhpValue index) => _array.offsetGet(index);

            public void RemoveKey(IntStringKey key) => _array.offsetUnset(PhpValue.Create(key));

            public void RemoveKey(PhpValue index) => _array.offsetUnset(index);

            public void SetItemAlias(IntStringKey key, PhpAlias alias) => _array.offsetSet(PhpValue.Create(key), PhpValue.Create(alias));

            public void SetItemAlias(PhpValue index, PhpAlias alias) => _array.offsetSet(index, PhpValue.Create(alias));

            public void SetItemValue(IntStringKey key, PhpValue value) => _array.offsetSet(PhpValue.Create(key), value);

            public void SetItemValue(PhpValue index, PhpValue value) => _array.offsetSet(index, value);
        }

        sealed class ListAsPhpArray : IPhpArray
        {
            readonly IList _array;

            public ListAsPhpArray(IList array)
            {
                Debug.Assert(array != null);
                _array = array;
            }

            object ToObject(PhpValue value) => value.ToClr();    // TODO, type conversion

            public int Count => _array.Count;

            public void AddValue(PhpValue value)
            {
                _array.Add(ToObject(value));
            }

            public PhpAlias EnsureItemAlias(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureAlias(ref item);
            }

            public IPhpArray EnsureItemArray(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureArray(ref item);
            }

            public object EnsureItemObject(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureObject(ref item);
            }

            public PhpValue GetItemValue(IntStringKey key)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    return PhpValue.FromClr(_array[unchecked((int)key.Integer)]);
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public PhpValue GetItemValue(PhpValue index) => GetItemValue(index.ToIntStringKey());

            public void RemoveKey(IntStringKey key)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    _array.RemoveAt(unchecked((int)key.Integer));
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public void RemoveKey(PhpValue index) => RemoveKey(index.ToIntStringKey());

            public void SetItemAlias(IntStringKey key, PhpAlias alias)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    _array[unchecked((int)key.Integer)] = ToObject(alias.Value);
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public void SetItemAlias(PhpValue index, PhpAlias alias) => SetItemAlias(index.ToIntStringKey(), alias);

            public void SetItemValue(IntStringKey key, PhpValue value)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    _array[unchecked((int)key.Integer)] = ToObject(value);
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public void SetItemValue(PhpValue index, PhpValue value) => SetItemValue(index.ToIntStringKey(), value);
        }

        /// <summary>
        /// Helper class representing array access for classes with CLR "get_Item" / "set_Item" indexer method.
        /// </summary>
        sealed class GetSetItemAsPhpArray : IPhpArray
        {
            readonly object/*!*/_instance;

            public GetSetItemAsPhpArray(object/*!*/instance)
            {
                _instance = instance ?? throw new ArgumentNullException(nameof(instance));
            }

            public int Count => throw new NotSupportedException();

            public void AddValue(PhpValue value) => throw new NotSupportedException();

            public PhpAlias EnsureItemAlias(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureAlias(ref item);
            }

            public IPhpArray EnsureItemArray(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureArray(ref item);
            }

            public object EnsureItemObject(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureObject(ref item);
            }

            public PhpValue GetItemValue(IntStringKey key) => GetItemValue((PhpValue)key);

            public PhpValue GetItemValue(PhpValue index)
            {
                var getter = _instance.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.get_item];
                if (getter != null)
                {
                    // TODO: Context is null, should no be used but ...
                    return getter.Invoke(null, _instance, index);
                }
                else
                {
                    throw new NotSupportedException();
                }
            }

            public void RemoveKey(IntStringKey key) => RemoveKey((PhpValue)key);

            public void RemoveKey(PhpValue index) => throw new NotSupportedException();

            public void SetItemAlias(IntStringKey key, PhpAlias alias) => SetItemAlias((PhpValue)key, alias);

            public void SetItemAlias(PhpValue index, PhpAlias alias)
            {
                throw new NotImplementedException();
            }

            public void SetItemValue(IntStringKey key, PhpValue value) => SetItemValue((PhpValue)key, value);

            public void SetItemValue(PhpValue index, PhpValue value)
            {
                var setter = _instance.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.set_item];
                if (setter != null)
                {
                    // TODO: Context is null, should no be used but ...
                    setter.Invoke(null, _instance, index, value);
                }
                else
                {
                    throw new NotSupportedException();
                }
            }
        }

        public static IPhpArray EnsureArray(ArrayAccess obj)
        {
            Debug.Assert(obj != null);
            return new ArrayAccessAsPhpArray(obj);
        }

        public static IPhpArray EnsureArray(object obj)
        {
            // IPhpArray
            if (obj is IPhpArray) return (IPhpArray)obj;

            // ArrayAccess
            if (obj is ArrayAccess) return EnsureArray((ArrayAccess)obj);

            // IList
            if (obj is IList) return new ListAsPhpArray((IList)obj);


            // get_Item
            if (obj.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.get_item] != null)
            {
                // IDictionary,
                // and item getters in general:
                return new GetSetItemAsPhpArray(obj);
            }

            // Fatal error: Uncaught Error: Cannot use object of type {0} as array
            PhpException.Throw(PhpError.Error, Resources.ErrResources.object_used_as_array, obj.GetPhpTypeInfo().Name);
            throw new ArgumentException(nameof(obj));
        }

        /// <summary>
        /// Gets <see cref="IPhpArray"/> instance providing access to the value with array operators.
        /// Returns <c>null</c> if underlaying value does provide array access.
        /// </summary>
        public static IPhpArray GetArrayAccess(ref PhpValue value) => value.TypeCode switch
        {
            // TODO // CONSIDER: what is this?

            PhpTypeCode.PhpArray => value.Array,
            PhpTypeCode.String => PhpValue.EnsureArray(ref value),
            PhpTypeCode.MutableString => value.MutableStringBlob,
            PhpTypeCode.Object => EnsureArray(value.Object),
            PhpTypeCode.Alias => value.Alias.EnsureArray(),
            _ => null,
        };

        /// <summary>
        /// Gets <see cref="IPhpArray"/> to be used as R-value of <c>list</c> expression.
        /// </summary>
        public static IPhpArray GetListAccess(PhpValue value)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.PhpArray: return value.Array;
                case PhpTypeCode.Object: return EnsureArray(value.Object);
                case PhpTypeCode.Alias: return GetListAccess(value.Alias.Value);
                default:
                    // TODO: some kind of debug log would be nice, PHP does not do that
                    return PhpArray.Empty;
            }
        }

        /// <summary>
        /// Gets <see cref="IPhpArray"/> to be used as R-value of <c>list</c> expression.
        /// </summary>
        public static IPhpArray GetListAccess(object value) => EnsureArray(value);

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/>.
        /// </summary>
        /// <param name="value">String to be accessed as array.</param>
        /// <param name="index">Index.</param>
        /// <returns>Character on index or empty string if index is our of range.</returns>
        public static string GetItemValue(string value, long index)
        {
            return (value != null && index >= 0 && index < value.Length)
                ? value[unchecked((int)index)].ToString()
                : string.Empty; // TODO: quiet ?
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/>.
        /// </summary>
        public static string GetItemValue(string value, IntStringKey key)
        {
            var index = key.IsInteger
                ? key.Integer
                : Convert.StringToLongInteger(key.String);

            return GetItemValue(value, index);
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/> with <c>isset</c> semantics.
        /// </summary>
        public static string GetItemValueOrNull(string value, IntStringKey key)
        {
            var index = key.IsInteger
                ? key.Integer
                : Convert.StringToLongInteger(key.String);

            return (value != null && index >= 0 && index < value.Length)
                ? value[unchecked((int)index)].ToString()
                : null;
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/>.
        /// </summary>
        public static string GetItemValue(string value, PhpValue index, bool quiet)
        {
            if (value != null && index.TryToIntStringKey(out var key))
            {
                long i;

                if (key.IsInteger)
                {
                    i = key.Integer;
                }
                else
                {
                    if (quiet) return null;

                    i = Convert.StringToLongInteger(key.String);
                }

                if (i >= 0 && i < value.Length)
                {
                    return value[(int)i].ToString();
                }
            }

            //
            if (quiet)
            {
                // used by isset() and empty()
                return null;
            }
            else
            {
                PhpException.Throw(PhpError.Warning, Resources.ErrResources.illegal_string_offset, index.ToString());
                return string.Empty;
            }
        }

        /// <summary>
        /// Shortcut for calling <c>ord($s[$i])</c> on a <see cref="PhpValue"/>
        /// without any extra allocation.
        /// </summary>
        public static long GetItemOrdValue(PhpValue value, long index)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.String:
                    return GetItemOrdValue(value.String, index);

                case PhpTypeCode.MutableString:
                    return GetItemOrdValue(value.MutableString, index);

                case PhpTypeCode.Alias:
                    return GetItemOrdValue(value.Alias.Value, index);

                default:
                    var item = value.GetArrayItem(index);
                    if (item.IsMutableString(out var itemPhpString))
                    {
                        return itemPhpString.IsEmpty ? 0 : itemPhpString[0];
                    }
                    else
                    {
                        var str = item.ToStringUtf8();
                        return string.IsNullOrEmpty(str) ? 0 : str[0];
                    }
            }
        }

        /// <summary>
        /// Shortcut for calling <c>ord($s[$i])</c> on a <see cref="string"/>
        /// without any extra allocation.
        /// </summary>
        public static long GetItemOrdValue(string value, long index)
        {
            if (value != null && index >= 0 && index < value.Length)
            {
                return value[(int)index];
            }

            //
            PhpException.Throw(PhpError.Warning, Resources.ErrResources.illegal_string_offset, index.ToString());
            return 0;
        }

        /// <summary>
        /// Shortcut for calling <c>ord($s[$i])</c> on a <see cref="PhpString"/>
        /// without any extra allocation.
        /// </summary>
        public static long GetItemOrdValue(PhpString value, long index)
        {
            if (index >= 0 && index < value.Length)
            {
                return value[(int)index];
            }

            PhpException.Throw(PhpError.Warning, Resources.ErrResources.illegal_string_offset, index.ToString());
            return 0;
        }

        public static object EnsureItemObject(this IPhpArray array, PhpValue index)
        {
            if (index.TryToIntStringKey(out var key))
            {
                return array.EnsureItemObject(key);
            }
            else
            {
                throw PhpException.TypeErrorException(Resources.ErrResources.illegal_offset_type);
            }
        }

        public static IPhpArray EnsureItemArray(this IPhpArray array, PhpValue index)
        {
            if (index.TryToIntStringKey(out var key))
            {
                return array.EnsureItemArray(key);
            }
            else
            {
                throw PhpException.TypeErrorException(Resources.ErrResources.illegal_offset_type);
            }
        }

        public static PhpAlias EnsureItemAlias(this IPhpArray array, PhpValue index, bool quiet)
        {
            if (index.TryToIntStringKey(out var key))
            {
                return array.EnsureItemAlias(key);
            }
            else
            {
                if (!quiet)
                {
                    PhpException.IllegalOffsetType();
                }

                return PhpAlias.Create(PhpValue.Null);
            }
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="PhpValue"/>.
        /// </summary>
        public static PhpValue GetItemValue(PhpValue value, PhpValue index, bool quiet = false)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.PhpArray:
                    return value.Array.GetItemValue(index); // , quiet);

                case PhpTypeCode.String:
                    var item = GetItemValue(value.String, index, quiet);
                    if (quiet && string.IsNullOrEmpty(item))
                    {
                        return PhpValue.Null;
                    }
                    return item;

                case PhpTypeCode.MutableString:
                    return value.MutableStringBlob.GetItemValue(index); // quiet);

                case PhpTypeCode.Object:
                    return Operators.GetItemValue(value.Object, index, quiet);

                case PhpTypeCode.Alias:
                    return value.Alias.Value.GetArrayItem(index, quiet);

                default:
                    // TODO: warning
                    return PhpValue.Null;
            }
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="PhpValue"/>.
        /// </summary>
        public static PhpValue GetItemValue(object obj, PhpValue index, bool quiet = false)
        {
            // IPhpArray.GetItemValue
            if (obj is IPhpArray arr)
            {
                return arr.GetItemValue(index); // , quiet);
            }

            // ArrayAccess.offsetGet()
            if (obj is ArrayAccess arracces)
            {
                return arracces.offsetGet(index);
            }

            // IList[]
            if (obj is IList list)
            {
                if (index.TryToIntStringKey(out var key) && key.IsInteger)
                {
                    if (key.Integer >= 0 && key.Integer < list.Count)
                    {
                        return PhpValue.FromClr(list[(int)key.Integer]);
                    }
                    else if (!quiet)
                    {
                        PhpException.UndefinedOffset(key);
                    }
                }
                else if (!quiet)
                {
                    PhpException.IllegalOffsetType();
                }

                return PhpValue.Null;
            }


            // get_Item
            if (obj != null)
            {
                // IDictionary
                // and item getter in general:

                var getter = obj.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.get_item];
                if (getter != null)
                {
                    return getter.Invoke(null, obj, index);
                }
            }

            //
            if (!quiet)
            {
                PhpException.ObjectUsedAsArray(PhpVariable.GetClassName(obj));
            }

            //
            return PhpValue.Null;
        }

        public static bool TryGetItemValue(this PhpArray value, string index, out PhpValue item)
        {
            if (value != null && value.TryGetValue(index, out item) && IsSet(item))
            {
                return true;
            }
            else
            {
                item = default;
                return false;
            }
        }

        public static bool TryGetItemValue(this PhpArray value, PhpValue index, out PhpValue item)
        {
            if (value != null && index.TryToIntStringKey(out var key) && value.TryGetValue(key, out item) && IsSet(item))
            {
                return true;
            }
            else
            {
                item = default;
                return false;
            }
        }

        public static bool TryGetItemValue(this PhpValue value, PhpValue index, out PhpValue item)
        {
            if (value.IsPhpArray(out var array))
            {
                // Specialized call for array
                return TryGetItemValue(array, index, out item);
            }
            else
            {
                // Otherwise use the original semantics of isset($x[$y]) ? $x[$y] : ...;
                if (offsetExists(value, index))
                {
                    item = GetItemValue(value, index);
                    return true;
                }
                else
                {
                    item = default;
                    return false;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static PhpAlias EnsureItemAlias_Old(PhpValue value, PhpValue index, bool quiet = false)
        {
            Debug.WriteLineIf(value.IsNull, "NULL value won't be changed to array!");

            return EnsureItemAlias(ref value, index, quiet);
        }

        /// <summary>
        /// Implements <c>&amp;[]</c> operator on <see cref="PhpValue"/>.
        /// Ensures the value is an array and item at given <paramref name="index"/> is an alias.
        /// </summary>
        public static PhpAlias EnsureItemAlias(ref PhpValue value, PhpValue index, bool quiet = false)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.Null:
                    // TODO: Err: Warning: Creating default object from empty value
                    var arr = new PhpArray();
                    value = PhpValue.Create(arr);
                    return arr.EnsureItemAlias(index, quiet);

                case PhpTypeCode.PhpArray:
                    return value.Array.EnsureItemAlias(index, quiet);

                case PhpTypeCode.String:
                    throw new NotImplementedException();

                case PhpTypeCode.MutableString:
                    throw new NotImplementedException();

                case PhpTypeCode.Object:
                    if (value.Object is IPhpArray array)
                    {
                        return EnsureItemAlias(array, index, quiet);
                    }

                    if (!quiet) // NOTE: PHP does not report this error (?)
                    {
                        PhpException.Throw(PhpError.Error, Resources.ErrResources.object_used_as_array, value.Object.GetPhpTypeInfo().Name);
                    }

                    break;

                case PhpTypeCode.Alias:
                    return value.Alias.EnsureItemAlias(index, quiet);
            }

            // TODO: Warning
            return PhpAlias.Create(PhpValue.Null);
        }

        public static bool offsetExists(this PhpArray value, long index) =>
            value != null &&
            value.TryGetValue((int)index, out var x) &&
            IsSet(x);

        public static bool offsetExists(this PhpArray value, string index) =>
            value != null &&
            value.TryGetValue(index, out var x) &&
            IsSet(x);

        public static bool offsetExists(this PhpArray value, PhpValue index) =>
            value != null &&
            index.TryToIntStringKey(out var key) &&
            value.TryGetValue(key, out var x) &&
            IsSet(x);

        public static bool offsetExists(this string value, PhpValue index)
        {
            return index.TryToIntStringKey(out var key) && key.IsInteger && offsetExists(value, key.Integer);
        }

        public static bool offsetExists(this string value, long index)
        {
            return value != null && index >= 0 && index < value.Length;
        }

        public static bool offsetExists(this PhpString value, long index)
        {
            return index >= 0 && index < value.Length;
        }

        public static bool offsetExists(object obj, PhpValue index)
        {
            return obj switch
            {
                // PHP ArrayAccess
                ArrayAccess arrrayAccess => arrrayAccess.offsetExists(index),

                // object implementing PeachPie's IPhpArray
                IPhpArray arr => IsSet(arr.GetItemValue(index)),

                // IList, checks the integer key is in range
                IList list => index.TryToIntStringKey(out var key) && key.IsInteger && key.Integer >= 0 && key.Integer < list.Count,

                // IDictionary
                IDictionary dict => offsetExists(dict, index),

                // TODO: generic get_Item() getter
                _ => false,
            };
        }

        public static bool offsetExists(IDictionary obj, PhpValue index)
        {
            if (obj != null)
            {
                // return obj.Contains(index.ToClr()); // <-- cannot be used, index might need to be converted to specific Dictionary's TKey type

                var getter = obj.GetPhpTypeInfo().RuntimeMethods[/*nameof(IDictionary<,>.ContainsKey)*/"ContainsKey"];
                if (getter != null)
                {
                    return getter.Invoke(null, obj, index).ToBoolean();
                }

                // fallback to generic behavior,
                // might get false if index is of a wrong type
                return obj.Contains(index.ToClr());
            }

            return false;
        }

        public static bool offsetExists(PhpAlias alias, PhpValue index) => offsetExists(alias.Value, index);

        public static bool offsetExists(this PhpValue value, PhpValue index)
        {
            if (value.Object is PhpArray array)
            {
                return offsetExists(array, index);
            }
            else if (value.Object is string str)
            {
                return offsetExists(str, index);
            }
            else if (value.Object is PhpString.Blob blob)
            {
                return index.TryToIntStringKey(out var key) && key.IsInteger && key.Integer >= 0 && key.Integer < blob.Length;
            }
            else if (value.Object is PhpAlias alias)
            {
                return offsetExists(alias.Value, index);
            }
            else if (value.Object != null)
            {
                // class instance
                return offsetExists(value.Object, index);
            }

            // scalar or NULL
            return false;
        }

        #endregion

        #region Object

        public static bool PropertyExists(RuntimeTypeHandle caller, object instance, PhpValue prop)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. runtime property

            // 3. __isset

            // false

            throw new NotImplementedException();
        }

        public static PhpValue PropertyGetValue(RuntimeTypeHandle caller, object instance, PhpValue propertyName)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. runtime property

            // 3. __get

            // error

            throw new NotImplementedException();
        }

        public static void PropertySetValue(RuntimeTypeHandle caller, object instance, PhpValue prop, PhpValue value)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. overwrite runtime property

            // 3. __set ?? runtime property

            // error

            throw new NotImplementedException();
        }

        public static void PropertyUnset(RuntimeTypeHandle caller, object instance, PhpValue prop)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. unset runtime property

            // 3. __unset

            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> from a string or an object instance.
        /// </summary>
        /// <param name="ctx">Current runtime context.</param>
        /// <param name="object">String or object. Other value types cause an exception.</param>
        /// <returns>Corresponding <see cref="PhpTypeInfo"/> descriptor. Cannot be <c>null</c>.</returns>
        public static PhpTypeInfo TypeNameOrObjectToType(Context ctx, PhpValue @object)
        {
            object obj;
            string str;

            if ((obj = (@object.AsObject())) != null)
            {
                return obj.GetType().GetPhpTypeInfo();
            }
            else if ((str = PhpVariable.AsString(@object)) != null)
            {
                return ctx.GetDeclaredType(str, true);
            }
            else
            {
                throw new ArgumentException();
            }
        }

        /// <summary>
        /// Resolves the runtime property by looking into runtime properties and eventually invoking the <c>__get</c> magic method.
        /// </summary>
        public static PhpValue RuntimePropertyGetValue(Context/*!*/ctx, object/*!*/instance, string propertyName, bool quiet)
        {
            return RuntimePropertyGetValue(ctx, instance.GetPhpTypeInfo(), instance, propertyName, quiet);
        }

        /// <summary>
        /// Resolves the runtime property by looking into runtime properties and eventually invoking the <c>__get</c> magic method.
        /// </summary>
        public static PhpValue RuntimePropertyGetValue(Context/*!*/ctx, PhpTypeInfo/*!*/type, object/*!*/instance, string propertyName, bool quiet)
        {
            var runtimeFields = type.GetRuntimeFields(instance);
            if (runtimeFields != null && runtimeFields.TryGetValue(propertyName, out var value))
            {
                return value;
            }

            var __get = type.RuntimeMethods[TypeMethods.MagicMethods.__get];
            if (__get != null)
            {
                // NOTE: magic methods must have public visibility, therefore the visibility check is unnecessary

                // int subkey1 = access.Write() ? 1 : access.Unset() ? 2 : access.Isset() ? 3 : 4;
                int subkey = propertyName.GetHashCode() ^ (1 << 4/*subkey1*/);

                using (var token = new Context.RecursionCheckToken(ctx, instance, subkey))
                {
                    if (!token.IsInRecursion)
                    {
                        return __get.Invoke(ctx, instance, propertyName);
                    }
                }
            }

            //
            if (!quiet)
            {
                PhpException.UndefinedProperty(type.Name, propertyName);
            }

            // empty
            return PhpValue.Null;
        }

        #endregion

        #region self, parent

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of self.
        /// Throws in case of self being used out of class context.
        /// </summary>
        public static PhpTypeInfo GetSelf(RuntimeTypeHandle self)
        {
            if (self.Equals(default(RuntimeTypeHandle)))
            {
                PhpException.ThrowSelfOutOfClass();
            }

            //
            return self.GetPhpTypeInfo();
        }

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of self or <c>null</c>.
        /// </summary>
        public static PhpTypeInfo GetSelfOrNull(RuntimeTypeHandle self) => self.GetPhpTypeInfo();

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of parent.
        /// Throws in case of parent being used out of class context or within a parentless class.
        /// </summary>
        public static PhpTypeInfo GetParent(RuntimeTypeHandle self) => GetParent(self.GetPhpTypeInfo());

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of parent.
        /// Throws in case of parent being used out of class context or within a parentless class.
        /// </summary>
        public static PhpTypeInfo GetParent(PhpTypeInfo self)
        {
            if (self == null)
            {
                PhpException.Throw(PhpError.Error, Resources.ErrResources.parent_used_out_of_class);
            }
            else
            {
                var t = self.BaseType;
                if (t != null)
                {
                    return t;
                }
                else
                {
                    PhpException.Throw(PhpError.Error, Resources.ErrResources.parent_accessed_in_parentless_class);
                }
            }

            //
            throw new ArgumentException(nameof(self));
        }

        #endregion

        #region GetForeachEnumerator

        /// <summary>
        /// Provides the <see cref="IPhpEnumerator"/> interface by wrapping a user-implemeted <see cref="Iterator"/>.
        /// </summary>
        /// <remarks>
        /// Instances of this class are iterated when <c>foreach</c> is used on object of a class
        /// that implements <see cref="Iterator"/> or <see cref="IteratorAggregate"/>.
        /// </remarks>
        [DebuggerNonUserCode, DebuggerStepThrough]
        private sealed class PhpIteratorEnumerator : IPhpEnumerator
        {
            readonly Iterator _iterator;
            bool _hasmoved;

            public PhpIteratorEnumerator(Iterator iterator)
            {
                Debug.Assert(iterator != null);
                _iterator = iterator;
                Reset();
            }

            public bool AtEnd
            {
                get
                {
                    throw new NotImplementedException();
                }
            }

            public KeyValuePair<PhpValue, PhpValue> Current => new KeyValuePair<PhpValue, PhpValue>(CurrentKey, CurrentValue);

            public PhpValue CurrentKey => _iterator.key().DeepCopy();

            public PhpValue CurrentValue => _iterator.current().DeepCopy();

            public PhpAlias CurrentValueAliased
            {
                get
                {
                    var value = _iterator.current();
                    return PhpValue.EnsureAlias(ref value);
                }
            }

            object IEnumerator.Current => Current;

            public void Dispose() { }

            public bool MoveFirst()
            {
                Reset();
                return _iterator.valid();
            }

            public bool MoveLast()
            {
                throw new NotImplementedException();
            }

            public bool MoveNext()
            {
                if (_hasmoved)
                {
                    _iterator.next();
                }
                else
                {
                    _hasmoved = true;
                }

                return _iterator.valid();
            }

            public bool MovePrevious()
            {
                throw new NotImplementedException();
            }

            public void Reset()
            {
                _hasmoved = false;
                _iterator.rewind();
            }
        }

        /// <summary>
        /// Provides <see cref="IPhpEnumerator"/> implementation enumerating class instance fields and runtime fields.
        /// </summary>
        private sealed class PhpFieldsEnumerator : IPhpEnumerator
        {
            readonly IEnumerator<KeyValuePair<IntStringKey, PhpValue>> _enumerator;
            bool _valid;

            public PhpFieldsEnumerator(object obj, RuntimeTypeHandle caller)
            {
                Debug.Assert(obj != null);
                _enumerator = TypeMembersUtils.EnumerateVisibleInstanceFields(obj, caller).GetEnumerator();
                _valid = true;
            }

            public bool AtEnd => !_valid;

            public KeyValuePair<PhpValue, PhpValue> Current
            {
                get
                {
                    var current = _enumerator.Current;
                    return new KeyValuePair<PhpValue, PhpValue>(PhpValue.Create(current.Key), current.Value);
                }
            }

            public PhpValue CurrentKey => PhpValue.Create(_enumerator.Current.Key);

            public PhpValue CurrentValue => _enumerator.Current.Value.GetValue().DeepCopy();

            public PhpAlias CurrentValueAliased
            {
                get
                {
                    var value = _enumerator.Current.Value;
                    return PhpValue.EnsureAlias(ref value);
                }
            }

            object IEnumerator.Current => _enumerator.Current;

            public void Dispose() => _enumerator.Dispose();

            public bool MoveFirst()
            {
                Reset();
                return MoveNext();
            }

            public bool MoveLast()
            {
                throw new NotImplementedException();
            }

            public bool MoveNext()
            {
                return (_valid = _enumerator.MoveNext());
            }

            public bool MovePrevious()
            {
                throw new NotSupportedException();
            }

            public void Reset()
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Implements empty enumeration.
        /// </summary>
        private sealed class PhpEmptyEnumerator : IPhpEnumerator
        {
            public static readonly IPhpEnumerator Instance = new PhpEmptyEnumerator();

            private PhpEmptyEnumerator() { }

            public bool AtEnd => false;

            public KeyValuePair<PhpValue, PhpValue> Current => default(KeyValuePair<PhpValue, PhpValue>);

            public PhpValue CurrentKey => PhpValue.Null;

            public PhpValue CurrentValue => PhpValue.Null;

            public PhpAlias CurrentValueAliased => PhpAlias.Create(PhpValue.Null);

            object IEnumerator.Current => null;

            public void Dispose() { }

            public bool MoveFirst() => false;

            public bool MoveLast() => false;

            public bool MoveNext() => false;

            public bool MovePrevious() => false;

            public void Reset() { }
        }

        #region ClrEnumeratorFactory

        abstract class ClrEnumeratorFactory
        {
            public static IPhpEnumerator CreateEnumerator(IEnumerable enumerable)
            {
                Debug.Assert(enumerable != null);

                // special cases before using reflection
                if (enumerable is IEnumerable<(PhpValue, PhpValue)> valval) return new ValueTupleEnumerator<PhpValue, PhpValue>(valval);
                if (enumerable is IDictionary) return new DictionaryEnumerator(((IDictionary)enumerable).GetEnumerator());
                if (enumerable is IEnumerable<KeyValuePair<object, object>> kv) return new KeyValueEnumerator<object, object>(kv);
                if (enumerable is IEnumerable<object>) return new EnumerableEnumerator(enumerable.GetEnumerator());

                // TODO: cache following for the enumerable type

                // find IEnumerable<>
                foreach (var iface_type in enumerable.GetType().GetInterfaces())
                {
                    if (iface_type.IsGenericType && iface_type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                    {
                        var item_type = iface_type.GenericTypeArguments[0];
                        if (item_type.IsGenericType)
                        {
                            // ValueTuple<A, B>
                            if (item_type.GetGenericTypeDefinition() == typeof(ValueTuple<,>))
                            {
                                return (ClrEnumerator)Activator.CreateInstance(
                                    typeof(ValueTupleEnumerator<,>).MakeGenericType(item_type.GetGenericArguments()),
                                    enumerable);
                            }

                            // KeyValuePair<A, B>
                            if (item_type.GetGenericTypeDefinition() == typeof(KeyValuePair<,>))
                            {
                                return (ClrEnumerator)Activator.CreateInstance(
                                    typeof(KeyValueEnumerator<,>).MakeGenericType(item_type.GetGenericArguments()),
                                    enumerable);
                            }
                        }
                    }
                }

                // generic
                return new EnumerableEnumerator(enumerable.GetEnumerator());
            }

            abstract class ClrEnumerator : IPhpEnumerator
            {
                abstract protected IEnumerator Enumerator { get; }

                /// <summary>
                /// Current key and value.
                /// </summary>
                PhpValue _key, _value;

                abstract protected void FetchCurrent(ref PhpValue key, ref PhpValue value);

                public bool AtEnd => throw new NotSupportedException();

                public PhpValue CurrentValue => _value;

                public PhpAlias CurrentValueAliased => _value.IsAlias ? _value.Alias : throw new InvalidOperationException();

                public PhpValue CurrentKey => _key;

                public KeyValuePair<PhpValue, PhpValue> Current => new KeyValuePair<PhpValue, PhpValue>(CurrentKey, CurrentValue);

                object IEnumerator.Current => Enumerator.Current;

                public void Dispose()
                {
                    _key = _value = PhpValue.Null;
                    (Enumerator as IDisposable)?.Dispose();
                }

                public virtual bool MoveFirst()
                {
                    Enumerator.Reset();
                    return MoveNext();
                }

                public virtual bool MoveLast()
                {
                    throw new NotImplementedException();
                }

                public virtual bool MoveNext()
                {
                    if (Enumerator.MoveNext())
                    {
                        FetchCurrent(ref _key, ref _value);
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

                public virtual bool MovePrevious()
                {
                    throw new NotSupportedException();
                }

                void IEnumerator.Reset() => Enumerator.Reset();
            }

            /// <summary>
            /// Enumerator of <see cref="IEnumerable"/>.
            /// </summary>
            sealed class EnumerableEnumerator : ClrEnumerator
            {
                readonly IEnumerator _enumerator;

                protected override IEnumerator Enumerator => _enumerator;

                long _key;

                public override bool MoveFirst()
                {
                    _key = -1;
                    return base.MoveFirst();
                }

                public override bool MoveNext()
                {
                    _key++;
                    return base.MoveNext();
                }

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    key = _key;
                    value = PhpValue.FromClr(_enumerator.Current);
                }

                public EnumerableEnumerator(IEnumerator enumerator)
                {
                    Debug.Assert(enumerator != null);
                    _enumerator = enumerator;
                    _key = -1;
                }
            }

            /// <summary>
            /// Enumerator of <see cref="IDictionary"/>
            /// </summary>
            sealed class DictionaryEnumerator : ClrEnumerator
            {
                readonly IDictionaryEnumerator _enumerator;
                protected override IEnumerator Enumerator => _enumerator;

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    var entry = _enumerator.Entry;
                    key = PhpValue.FromClr(entry.Key);
                    value = PhpValue.FromClr(entry.Value);
                }

                public DictionaryEnumerator(IDictionaryEnumerator enumerator)
                {
                    Debug.Assert(enumerator != null);
                    _enumerator = enumerator;
                }
            }

            sealed class ValueTupleEnumerator<K, V> : ClrEnumerator
            {
                readonly IEnumerator<(K, V)> _enumerator;
                protected override IEnumerator Enumerator => _enumerator;

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    var entry = _enumerator.Current;
                    key = PhpValue.FromClr(entry.Item1);
                    value = PhpValue.FromClr(entry.Item2);
                }

                public ValueTupleEnumerator(IEnumerable<(K, V)> enumerable)
                {
                    Debug.Assert(enumerable != null);
                    _enumerator = enumerable.GetEnumerator();
                }
            }

            sealed class KeyValueEnumerator<K, V> : ClrEnumerator
            {
                readonly IEnumerator<KeyValuePair<K, V>> _enumerator;
                protected override IEnumerator Enumerator => _enumerator;

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    var entry = _enumerator.Current;
                    key = PhpValue.FromClr(entry.Key);
                    value = PhpValue.FromClr(entry.Value);
                }

                public KeyValueEnumerator(IEnumerable<KeyValuePair<K, V>> enumerable)
                {
                    Debug.Assert(enumerable != null);
                    _enumerator = enumerable.GetEnumerator();
                }
            }
        }

        #endregion

        /// <summary>
        /// Gets <see cref="Iterator"/> object enumerator.
        /// </summary>
        /// <returns>Instance of the enumerator. Cannot be <c>null</c>.</returns>
        public static IPhpEnumerator GetForeachEnumerator(Iterator it)
        {
            Debug.Assert(it != null);
            return new PhpIteratorEnumerator(it);
        }

        /// <summary>
        /// Resolves object enumerator.
        /// </summary>
        /// <exception cref="Exception">Object cannot be enumerated.</exception>
        /// <returns>Instance of the object enumerator. Cannot be <c>null</c>.</returns>
        public static IPhpEnumerator GetForeachEnumerator(object obj, bool aliasedValues, RuntimeTypeHandle caller)
        {
            Debug.Assert(obj != null);

            if (obj is Iterator)
            {
                return GetForeachEnumerator((Iterator)obj);
            }
            else if (obj is IteratorAggregate)
            {
                var last_obj = obj;

                do
                {
                    obj = ((IteratorAggregate)obj).getIterator();
                } while (obj is IteratorAggregate);

                if (obj is Iterator)
                {
                    return GetForeachEnumerator((Iterator)obj);
                }
                else
                {
                    var errmessage = string.Format(Resources.ErrResources.getiterator_must_return_traversable, last_obj.GetType().GetPhpTypeInfo().Name);
                    // throw new (SPL)Exception(ctx, message, 0, null)
                    //Library.SPL.Exception.ThrowSplException(
                    //    _ctx => new Library.SPL.Exception(_ctx, true),
                    //    context,
                    //    string.Format(CoreResources.getiterator_must_return_traversable, last_obj.TypeName), 0, null);
                    throw new ArgumentException(errmessage);
                }
            }
            else if (obj is IPhpEnumerable phpenumerable)
            {
                return phpenumerable.GetForeachEnumerator(aliasedValues, caller);
            }
            else if (obj is IEnumerable enumerable)
            {
                // IDictionaryEnumerator, IEnumerable<ValueTuple>, IEnumerable<KeyValuePair>, IEnumerable, ...
                return GetForeachEnumerator(enumerable);
            }
            else
            {
                // PHP property enumeration
                return new PhpFieldsEnumerator(obj, caller);
            }
        }

        /// <summary>
        /// Gets <see cref="IPhpEnumerator"/> from regular .NET <see cref="IEnumerable"/>.
        /// Enumerator is reflected to properly unwrap <c>key</c> and <c>value</c> of PHP enumeration.
        /// Supported interfaces are <see cref="IDictionaryEnumerator"/>, <see cref="IEnumerable{ValueTuple}"/>, <see cref="IEnumerable{KeyValuePair}"/>, <see cref="IEnumerable"/> etc.
        /// See <see cref="ClrEnumeratorFactory"/> for more details.
        /// </summary>
        internal static IPhpEnumerator GetForeachEnumerator(IEnumerable enumerable) => ClrEnumeratorFactory.CreateEnumerator(enumerable);

        /// <summary>
        /// Gets PHP enumerator of <c>NULL</c> or <b>empty</b> value.
        /// </summary>
        public static IPhpEnumerator GetEmptyForeachEnumerator() => PhpEmptyEnumerator.Instance;

        /// <summary>
        /// Gets enumerator object for given value.
        /// </summary>
        public static IPhpEnumerator GetForeachEnumerator(PhpValue value, bool aliasedValues, RuntimeTypeHandle caller) => value.GetForeachEnumerator(aliasedValues, caller);

        /// <summary>
        /// Gets enumerator of array entries.
        /// This is internal implementation that avoids allocations in common cases.
        /// </summary>
        public static OrderedDictionary.FastEnumerator GetFastEnumerator(PhpArray array, bool aliasedValue)
        {
            Debug.Assert(array != null);

            if (array.Count == 0)
            {
                // follows call to MoveNext() which ends the enumeration
                // keep array as it is, it won't be accessed anyways
            }
            else if (aliasedValue)
            {
                // ensure array is not shared with another variable
                array.EnsureWritable();
            }
            else
            {
                // create lazy copy
                array.table.AddRef();
            }

            return array.GetFastEnumerator();
        }

        #endregion

        #region Copy, Unpack

        /// <summary>
        /// Gets copy of given value.
        /// </summary>
        public static PhpValue DeepCopy(PhpValue value) => value.DeepCopy();

        /// <summary>
        /// Deep copies the value in-place.
        /// Called when this has been passed by value and inplace dereferencing and copying is necessary.
        /// </summary>
        [DebuggerNonUserCode, DebuggerStepThrough]
        public static void PassValue(ref PhpValue value)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.MutableString:
                    // lazy copy
                    value.MutableStringBlob.AddRef();
                    break;
                case PhpTypeCode.PhpArray:
                    // lazy copy
                    value = new PhpValue(value.Array.DeepCopy());
                    break;
                case PhpTypeCode.Alias:
                    // dereference & lazy copy
                    value = value.Alias.Value.DeepCopy();
                    break;
            }
        }

        /// <summary>
        /// Performs <c>clone</c> operation on given object.
        /// </summary>
        public static object Clone(Context ctx, object value)
        {
            if (value is IPhpCloneable cloneable)
            {
                value = cloneable.Clone();
            }
            else if (value != null)
            {
                value = CloneRaw(ctx, value);
            }
            else
            {
                PhpException.Throw(PhpError.Error, Resources.ErrResources.clone_called_on_non_object);
            }

            //

            return value;
        }

        /// <summary>
        /// Performs memberwise clone of the object.
        /// Calling <c>__clone</c> eventually.
        /// </summary>
        public static object CloneRaw(Context ctx, object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            var tinfo = value.GetPhpTypeInfo();

            // memberwise clone
            var newobj = tinfo.CreateUninitializedInstance(ctx);
            if (newobj != null)
            {
                Serialization.MemberwiseClone(tinfo, value, newobj);

                //
                value = newobj;

                // __clone(), only if __clone() is public
                var __clone = tinfo.RuntimeMethods[TypeMethods.MagicMethods.__clone];
                if (__clone != null && __clone.IsPublic())
                {
                    __clone.Invoke(ctx, value);
                }
            }
            else
            {
                PhpException.Throw(PhpError.Error, Resources.ErrResources.class_instantiation_failed, tinfo.Name);
            }

            //
            return value;
        }

        /// <summary>
        /// Every property of type <see cref="PhpValue"/> will be deeply copied inplace, including runtime fields.
        /// Calling <c>__clone</c> eventually.
        /// </summary>
        public static object CloneInPlace(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            var tinfo = value.GetPhpTypeInfo();

            // clone runtime fields:
            if (tinfo.RuntimeFieldsHolder != null)
            {
                var runtimefields = (PhpArray)tinfo.RuntimeFieldsHolder.GetValue(value);
                tinfo.RuntimeFieldsHolder.SetValue(value, runtimefields?.Clone());
            }

            // deep copy instance fields (of type PhpValue)
            foreach (var p in tinfo.DeclaredFields.InstanceProperties.OfType<PhpPropertyInfo.ClrFieldProperty>())
            {
                if (p.Field.FieldType == typeof(PhpValue))
                {
                    var oldvalue = (PhpValue)p.Field.GetValue(value);
                    p.Field.SetValue(value, (object)oldvalue.DeepCopy());
                }
            }

            // __clone(), only if __clone() is public
            var __clone = tinfo.RuntimeMethods[TypeMethods.MagicMethods.__clone];
            if (__clone != null && __clone.IsPublic())
            {
                __clone.Invoke(null, value); // 'ctx' is not needed ... probably
            }

            //
            return value;
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="argument"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="argument">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        public static void Unpack(List<PhpValue> stack, PhpValue argument, ulong byrefs)
        {
            // https://wiki.php.net/rfc/argument_unpacking

            switch (argument.TypeCode)
            {
                case PhpTypeCode.PhpArray:
                    Unpack(stack, argument.Array, byrefs);
                    break;

                case PhpTypeCode.Object:
                    if (argument.Object is Traversable traversable)
                    {
                        Unpack(stack, traversable, byrefs);
                        break;
                    }
                    else if (argument.Object is Array array)
                    {
                        Unpack(stack, array, byrefs);
                        break;
                    }
                    else
                    {
                        goto default;
                    }

                case PhpTypeCode.Alias:
                    Unpack(stack, argument.Alias.Value, byrefs);
                    break;

                default:
                    // TODO: Warning: Only arrays and Traversables can be unpacked
                    // do not add item to the arguments list // stack.Add(argument);
                    break;
            }
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="array"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="array">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        public static void Unpack(List<PhpValue> stack, PhpArray array, ulong byrefs)
        {
            Debug.Assert(array != null);

            var enumerator = array.GetFastEnumerator();
            while (enumerator.MoveNext())
            {
                if (enumerator.CurrentKey.IsString)
                {
                    // TODO: E_RECOVERABLE error
                    break;  // no further arguments will be unpacked
                }

                if ((byrefs & (1ul << stack.Count)) == 0)
                {
                    // pass by value
                    stack.Add(enumerator.CurrentValue);
                }
                else
                {
                    // pass by reference
                    stack.Add(PhpValue.Create(enumerator.CurrentValueAliased));
                }
            }
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="array"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="array">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        static void Unpack(List<PhpValue> stack, Array array, ulong byrefs)
        {
            for (int i = 0; i < array.Length; i++)
            {
                stack.Add(PhpValue.FromClr(array.GetValue(i)));
            }
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="traversable"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="traversable">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        public static void Unpack(List<PhpValue> stack, Traversable traversable, ulong byrefs)
        {
            Debug.Assert(traversable != null);

            if (traversable is IteratorAggregate aggr)
            {
                Unpack(stack, aggr.getIterator(), byrefs);
            }
            else if (traversable is Iterator iterator)
            {
                iterator.rewind();
                while (iterator.valid())
                {
                    Debug.Assert((byrefs & (1ul << stack.Count)) == 0, "Cannot pass by-reference when unpacking a Traversable");
                    //{
                    //    // TODO: Warning: Cannot pass by-reference argument {stack.Count + 1} of {function_name}() by unpacking a Traversable, passing by-value instead
                    //}

                    stack.Add(iterator.current());
                    iterator.next();
                }
            }
            else
            {
                throw new ArgumentException();
            }
        }

        #endregion

        #region ReadConstant

        /// <summary>
        /// Gets constant value, throws <c>notice</c> if constant is not defined.
        /// </summary>
        public static PhpValue ReadConstant(Context ctx, string name, ref int idx)
        {
            Debug.Assert(name != null, nameof(name));

            if (ctx.TryGetConstant(name, out var value, ref idx))
            {
                return value;
            }
            else
            {
                // Warning: undefined constant
                PhpException.Throw(PhpError.Notice, Resources.ErrResources.undefined_constant, name);
                return name;
            }
        }

        /// <summary>
        /// Gets constant value, throws <c>notice</c> if constant is not defined.
        /// </summary>
        public static PhpValue ReadConstant(Context ctx, string name, ref int idx, string fallbackName)
        {
            Debug.Assert(name != null, nameof(name));
            Debug.Assert(fallbackName != null, nameof(fallbackName));

            if (ctx.TryGetConstant(name, out var value, ref idx) ||
                ctx.TryGetConstant(fallbackName, out value))
            {
                return value;
            }
            else
            {
                // Warning: undefined constant
                PhpException.Throw(PhpError.Notice, Resources.ErrResources.undefined_constant, fallbackName);
                return fallbackName;
            }
        }

        /// <summary>
        /// Constant declaration.
        /// </summary>
        public static void DeclareConstant(Context ctx, string name, ref int idx, PhpValue value)
        {
            ctx.DefineConstant(name, value, ref idx, ignorecase: false);
        }

        #endregion

        #region Closure

        public static RoutineInfo AnonymousRoutine(string name, RuntimeMethodHandle handle) => new PhpAnonymousRoutineInfo(name, handle);

        /// <summary>
        /// Create <see cref="Closure"/> with specified anonymous function and used parameters.
        /// </summary>
        public static Closure BuildClosure(Context/*!*/ctx, IPhpCallable routine, object @this, RuntimeTypeHandle scope, PhpTypeInfo statictype, PhpArray/*!*/parameter, PhpArray/*!*/@static)
            => new Closure(ctx, routine, @this, scope, statictype, parameter, @static);

        public static Context Context(this Closure closure) => closure._ctx;

        /// <summary>Resolves late static bound type of closiure. Can be <c>null</c> reference.</summary>
        public static PhpTypeInfo Static(this Closure closure)
        {
            if (closure._this != null)
            {
                // typeof $this
                return closure._this.GetPhpTypeInfo();
            }

            if (closure._statictype != null)
            {
                // static
                return closure._statictype;
            }

            // self or NULL
            return closure._scope.GetPhpTypeInfo();
        }

        public static RuntimeTypeHandle Scope(this Closure closure) => closure._scope;

        public static object This(this Closure closure) => closure._this;

        /// <summary>
        /// Gets internal <see cref="IPhpCallable"/> object invoked by the closure.
        /// </summary>
        public static IPhpCallable Callable(this Closure closure) => closure._callable;

        #endregion

        #region Generator

        /// <summary>
        /// Create <see cref="Generator"/> with specified state machine function and parameters.
        /// </summary>
        public static Generator BuildGenerator(Context ctx, PhpArray locals, PhpArray tmpLocals, GeneratorStateMachineDelegate smmethod, RuntimeMethodHandle ownerhandle) => new Generator(ctx, locals, tmpLocals, smmethod, ownerhandle);

        public static int GetGeneratorState(Generator g) => g._state;

        public static void SetGeneratorState(Generator g, int newState) => g._state = newState;

        /// <summary>
        /// In case generator has an exception, throws it.
        /// The current exception is then nullified.
        /// </summary>
        [DebuggerNonUserCode, DebuggerHidden]
        public static void HandleGeneratorException(Generator g)
        {
            var exception = g._currException;
            g._currException = null;

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>Set yielded value from generator where key is not specified.</summary>
        public static void SetGeneratorCurrent(Generator g, PhpValue value)
        {
            g._currValue = value;
            g._currKey = (PhpValue)(++g._maxNumericalKey);
        }

        /// <summary>
        /// Sets yielded value from generator with key.
        /// This operator does not update auto-incremented Generator key.
        /// </summary>
        public static void SetGeneratorCurrentFrom(Generator g, PhpValue value, PhpValue key)
        {
            g._currValue = value;
            g._currKey = key;
        }

        /// <summary>Set yielded value from generator with key.</summary>
        public static void SetGeneratorCurrent(Generator g, PhpValue value, PhpValue key)
        {
            SetGeneratorCurrentFrom(g, value, key);

            // update the Generator auto-increment key
            if (key.IsLong(out var ikey) && ikey > g._maxNumericalKey)
            {
                g._maxNumericalKey = ikey;
            }
        }

        public static PhpValue GetGeneratorSentItem(Generator g) => g._currSendItem;

        public static void SetGeneratorReturnedValue(Generator g, PhpValue value) => g._returnValue = value;

        public static object GetGeneratorThis(Generator g) => g._this;

        public static Generator SetGeneratorThis(this Generator generator, object @this)
        {
            generator._this = @this;
            return generator;
        }

        /// <summary>
        /// Resolves generator's <c>static</c> type.
        /// </summary>
        /// <returns><see cref="PhpTypeInfo"/> refering to the lazy static bound type. Cannot be <c>null</c>.</returns>
        public static PhpTypeInfo GetGeneratorLazyStatic(this Generator generator)
        {
            return generator._static ?? generator._this?.GetPhpTypeInfo() ?? throw new InvalidOperationException();
        }

        public static Generator SetGeneratorLazyStatic(this Generator generator, PhpTypeInfo @static)
        {
            generator._static = @static;
            return generator;
        }

        public static Context GetGeneratorContext(Generator g) => g._ctx;

        public static GeneratorStateMachineDelegate GetGeneratorMethod(Generator g) => g._stateMachineMethod;

        public static MethodInfo GetGeneratorOwnerMethod(Generator g) => (MethodInfo)MethodBase.GetMethodFromHandle(g._ownerhandle);

        public static Generator SetGeneratorDynamicScope(this Generator g, RuntimeTypeHandle scope)
        {
            g._scope = scope;
            return g;
        }

        public static RuntimeTypeHandle GetGeneratorDynamicScope(this Generator g) => g._scope;

        #endregion

        #region Dynamic

        /// <summary>
        /// Performs dynamic code evaluation in given context.
        /// </summary>
        /// <returns>Evaluated code return value.</returns>
        public static PhpValue Eval(Context ctx, PhpArray locals, object @this, RuntimeTypeHandle self, string code, string currentpath, int line, int column)
        {
            Debug.Assert(ctx != null);
            Debug.Assert(locals != null);

            if (string.IsNullOrEmpty(code))
            {
                return PhpValue.Null;
            }

            var script = Core.Context.DefaultScriptingProvider.CreateScript(
                new Context.ScriptOptions()
                {
                    Context = ctx,
                    Location = new Location(Path.Combine(ctx.RootPath, currentpath), line, column),
                    EmitDebugInformation = Debugger.IsAttached,   // CONSIDER // DOC
                    IsSubmission = true,
                },
                code);

            //
            return script.Evaluate(ctx, locals, @this, self);
        }

        #endregion

        #region Paths

        /// <summary>
        /// Normalizes path's slashes for the current platform.
        /// </summary>
        public static string NormalizePath(string value) => Utilities.CurrentPlatform.NormalizeSlashes(value);

        #endregion

        #region BindTargetToMethod

        /// <summary>
        /// Helper lightweight class to reuse already bound <see cref="PhpInvokable"/> to be used as <see cref="PhpCallable"/>
        /// by calling it on a given target.
        /// </summary>
        sealed class BoundTargetCallable : IPhpCallable
        {
            readonly object _target;
            readonly PhpInvokable _invokable;

            public BoundTargetCallable(object target, PhpInvokable invokable)
            {
                _target = target;
                _invokable = invokable;
            }

            public PhpValue Invoke(Context ctx, params PhpValue[] arguments) => _invokable.Invoke(ctx, _target, arguments);

            public PhpValue ToPhpValue() => PhpValue.Null;
        }

        /// <summary>
        /// Creates an <see cref="IPhpCallable"/> from an instance method, binding the target to call the method on.
        /// </summary>
        public static IPhpCallable BindTargetToMethod(object targetInstance, RoutineInfo routine)
        {
            if (routine is PhpMethodInfo methodInfo)
            {
                return new BoundTargetCallable(targetInstance, methodInfo.PhpInvokable);
            }

            return PhpCallback.CreateInvalid();
        }

        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Pchp.Core.Reflection;
using Pchp.Core.Resources;

namespace Pchp.Core
{
    [DebuggerNonUserCode, DebuggerStepThrough]
    public static class Operators
    {
        #region Numeric

        /// <summary>
        /// Bit mask corresponding to the sign in <see cref="long"/> value.
        /// </summary>
        internal const long LONG_SIGN_MASK = (1L << (8 * sizeof(long) - 1));

        /// <summary>
        /// Performs bitwise and operation.
        /// </summary>
        internal static PhpValue BitAnd(in PhpValue x, in PhpValue y)
        {
            var bx = x.ToBytesOrNull();
            if (bx != null)
            {
                var by = y.ToBytesOrNull();
                if (by != null)
                {
                    return PhpValue.Create(BitAnd(bx, by));
                }
            }

            //
            return PhpValue.Create(x.ToLong() & y.ToLong());
        }

        /// <summary>
        /// Performs bitwise or operation.
        /// </summary>
        internal static PhpValue BitOr(in PhpValue x, in PhpValue y)
        {
            var bx = x.ToBytesOrNull();
            if (bx != null)
            {
                var by = y.ToBytesOrNull();
                if (by != null)
                {
                    return PhpValue.Create(BitOr(bx, by));
                }
            }

            //
            return PhpValue.Create(x.ToLong() | y.ToLong());
        }

        /// <summary>
        /// Performs exclusive or operation.
        /// </summary>
        internal static PhpValue BitXor(in PhpValue x, in PhpValue y)
        {
            var bx = x.ToBytesOrNull();
            if (bx != null)
            {
                var by = y.ToBytesOrNull();
                if (by != null)
                {
                    return PhpValue.Create(BitXor(bx, by));
                }
            }

            //
            return PhpValue.Create(x.ToLong() ^ y.ToLong());
        }

        static byte[] BitAnd(byte[] bx, byte[] by)
        {
            int length = Math.Min(bx.Length, by.Length);
            if (length == 0)
            {
                return Array.Empty<byte>();
            }

            byte[] result = new byte[length];

            for (int i = 0; i < result.Length; i++)
            {
                result[i] = (byte)(bx[i] & by[i]);
            }

            return result;
        }

        static byte[] BitOr(byte[] bx, byte[] by)
        {
            if (bx.Length == 0 && by.Length == 0)
            {
                return Array.Empty<byte>();
            }

            byte[] result, or;
            if (bx.Length > by.Length)
            {
                result = (byte[])bx.Clone();
                or = by;
            }
            else
            {
                result = (byte[])by.Clone();
                or = bx;
            }

            for (int i = 0; i < or.Length; i++)
            {
                result[i] |= or[i];
            }

            return result;
        }

        static byte[] BitXor(byte[] bx, byte[] by)
        {
            int length = Math.Min(bx.Length, by.Length);
            byte[] result = new byte[length];

            return BitXor(result, bx, by);
        }

        /// <summary>
        /// Performs specified binary operation on arrays of bytes.
        /// </summary>
        /// <param name="result">An array where to store the result. Data previously stored here will be overwritten.</param>
        /// <param name="x">The first operand.</param>
        /// <param name="y">The second operand</param>
        /// <returns>The reference to the the <paramref name="result"/> array.</returns>
        static byte[] BitXor(byte[]/*!*/ result, byte[]/*!*/ x, byte[]/*!*/ y)
        {
            Debug.Assert(result != null && x != null && y != null && result.Length <= x.Length && result.Length <= y.Length);

            for (int i = 0; i < result.Length; i++)
            {
                result[i] = unchecked((byte)(x[i] ^ y[i]));
            }

            // remaining bytes are ignored //
            return result;
        }

        /// <summary>
        /// Performs bitwise negation.
        /// </summary>
        internal static PhpValue BitNot(in PhpValue x)
        {
            switch (x.TypeCode)
            {
                case PhpTypeCode.Long: return PhpValue.Create(~x.Long);

                case PhpTypeCode.Alias: return ~x.Alias.Value;

                case PhpTypeCode.String:
                case PhpTypeCode.MutableString:
                    throw new NotImplementedException();    // bitwise negation of each character in string

                case PhpTypeCode.Object:
                    if (x.Object == null)
                    {
                        return PhpValue.Null;
                    }
                    goto default;

                default:
                    // TODO: Err UnsupportedOperandTypes
                    return PhpValue.Null;
            }
        }

        /// <summary>
        /// Performs division according to PHP semantics.
        /// </summary>
        /// <remarks>The division operator ("/") returns a float value unless the two operands are integers
        /// (or strings that get converted to integers) and the numbers are evenly divisible,
        /// in which case an integer value will be returned.</remarks>
        internal static PhpNumber Div(in PhpValue x, in PhpValue y)
        {
            var info = x.ToNumber(out var nx) | y.ToNumber(out var ny);

            if ((info & Convert.NumberInfo.IsPhpArray) != 0)
            {
                throw PhpException.ErrorException(ErrResources.unsupported_operand_types);
            }

            // TODO: // division by zero:
            //if (y == 0)
            //{
            //    PhpException.Throw(PhpError.Warning, CoreResources.GetString("division_by_zero"));
            //    return false;
            //}

            return nx / ny;
        }

        #endregion

        #region Assignment

        /// <summary>
        /// Assigns a PHP value by value according to the PHP semantics.
        /// </summary>
        /// <param name="target">Target of the assignment.</param>
        /// <param name="value">Value to be assigned.</param>
        public static void SetValue(ref PhpValue target, PhpValue value)
        {
            Debug.Assert(!value.IsAlias);
            if (target.Object is PhpAlias alias)
            {
                alias.Value = value;
            }
            else
            {
                target = value;
            }
        }

        /// <summary>
        /// Assigns a PHP value to an aliased place.
        /// </summary>
        /// <param name="target">Target of the assignment.</param>
        /// <param name="value">Value to be assigned.</param>
        public static void SetValue(PhpAlias/*!*/target, PhpValue value)
        {
            Debug.Assert(target != null);
            Debug.Assert(!value.IsAlias);
            target.Value = value;
        }

        /// <summary>
        /// "unset" operator.
        /// </summary>
        public static void UnsetValue(ref PhpValue target)
        {
            if (target.Object is PhpAlias alias)
            {
                alias.ReleaseRef();
            }

            target = default;
        }

        /// <summary>
        /// "unset" operator.
        /// </summary>
        public static void UnsetValue(ref PhpAlias target)
        {
            if (target != null)
            {
                target.ReleaseRef();
                target = PhpAlias.Create(default);
            }
        }

        #endregion

        #region Ensure

        /// <summary>
        /// Ensures given variable is not <c>null</c>.
        /// </summary>
        public static object EnsureObject(ref object obj) => obj ?? (obj = new stdClass());

        /// <summary>
        /// Ensures given variable is not <c>null</c>.
        /// </summary>
        public static PhpArray EnsureArray(ref PhpArray arr) => arr ?? (arr = new PhpArray());

        /// <summary>
        /// Ensures given variable is not <c>null</c>.
        /// </summary>
        public static IPhpArray EnsureArray(ref IPhpArray arr) => arr ?? (arr = new PhpArray());

        /// <summary>
        /// Ensures the value is <see cref="PhpString"/> and gets mutable access to the value (non-shared).
        /// </summary>
        /// <returns>Object on which edit operations can be performed. Cannot be <c>null</c>.</returns>
        public static PhpString.Blob EnsureWritableString(ref PhpValue value)
        {
            PhpString.Blob blob;

            switch (value.TypeCode)
            {
                case PhpTypeCode.MutableString:
                    if ((blob = value.MutableStringBlob).IsShared)
                    {
                        value = new PhpValue(blob = value.MutableStringBlob.ReleaseOne());
                    }
                    break;

                case PhpTypeCode.Null:
                    blob = new PhpString.Blob();
                    value = new PhpValue(blob);
                    break;

                case PhpTypeCode.String:
                    blob = new PhpString.Blob(value.String);
                    value = new PhpValue(blob);
                    break;

                case PhpTypeCode.Alias:
                    blob = value.Alias.EnsureWritableString();
                    break;

                default:
                    blob = new PhpString.Blob(value.ToStringUtf8());
                    value = new PhpValue(blob);
                    break;
            }

            return blob;
        }

        #endregion

        #region IsSet, IsEmpty

        /// <summary>
        /// Implementation of PHP <c>isset</c> operator.
        /// </summary>
        /// <remarks>Value (eventualy dereferenced value) is not <c>NULL</c>.</remarks>
        public static bool IsSet(PhpValue value) => !value.IsNull;

        /// <summary>
        /// Implements <c>empty</c> operator.
        /// </summary>
        public static bool IsEmpty(PhpValue value) => value.IsEmpty;

        /// <summary>
        /// Implements <c>empty</c> operator on objects.
        /// </summary>
        public static bool IsEmpty(object value) => ReferenceEquals(value, null);

        #endregion

        #region Array Access

        /// <summary>
        /// Provides <see cref="IPhpArray"/> interface for <see cref="ArrayAccess"/> instance.
        /// </summary>
        sealed class ArrayAccessAsPhpArray : IPhpArray
        {
            readonly ArrayAccess _array;

            public ArrayAccessAsPhpArray(ArrayAccess array)
            {
                Debug.Assert(array != null);
                _array = array;
            }

            public int Count
            {
                get
                {
                    throw new NotSupportedException();
                }
            }

            public void AddValue(PhpValue value) => SetItemValue(PhpValue.Null, value);

            public PhpAlias EnsureItemAlias(IntStringKey key)
            {
                var item = _array.offsetGet(key);
                return PhpValue.EnsureAlias(ref item);
            }

            public IPhpArray EnsureItemArray(IntStringKey key)
            {
                var item = _array.offsetGet(key);
                return PhpValue.EnsureArray(ref item);
            }

            public object EnsureItemObject(IntStringKey key)
            {
                var item = _array.offsetGet(key);
                return PhpValue.EnsureObject(ref item);
            }

            public PhpValue GetItemValue(IntStringKey key) => _array.offsetGet(PhpValue.Create(key));

            public PhpValue GetItemValue(PhpValue index) => _array.offsetGet(index);

            public void RemoveKey(IntStringKey key) => _array.offsetUnset(PhpValue.Create(key));

            public void RemoveKey(PhpValue index) => _array.offsetUnset(index);

            public void SetItemAlias(IntStringKey key, PhpAlias alias) => _array.offsetSet(PhpValue.Create(key), PhpValue.Create(alias));

            public void SetItemAlias(PhpValue index, PhpAlias alias) => _array.offsetSet(index, PhpValue.Create(alias));

            public void SetItemValue(IntStringKey key, PhpValue value) => _array.offsetSet(PhpValue.Create(key), value);

            public void SetItemValue(PhpValue index, PhpValue value) => _array.offsetSet(index, value);
        }

        sealed class ListAsPhpArray : IPhpArray
        {
            readonly IList _array;

            public ListAsPhpArray(IList array)
            {
                Debug.Assert(array != null);
                _array = array;
            }

            object ToObject(PhpValue value) => value.ToClr();    // TODO, type conversion

            public int Count => _array.Count;

            public void AddValue(PhpValue value)
            {
                _array.Add(ToObject(value));
            }

            public PhpAlias EnsureItemAlias(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureAlias(ref item);
            }

            public IPhpArray EnsureItemArray(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureArray(ref item);
            }

            public object EnsureItemObject(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureObject(ref item);
            }

            public PhpValue GetItemValue(IntStringKey key)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    return PhpValue.FromClr(_array[unchecked((int)key.Integer)]);
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public PhpValue GetItemValue(PhpValue index) => GetItemValue(index.ToIntStringKey());

            public void RemoveKey(IntStringKey key)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    _array.RemoveAt(unchecked((int)key.Integer));
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public void RemoveKey(PhpValue index) => RemoveKey(index.ToIntStringKey());

            public void SetItemAlias(IntStringKey key, PhpAlias alias)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    _array[unchecked((int)key.Integer)] = ToObject(alias.Value);
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public void SetItemAlias(PhpValue index, PhpAlias alias) => SetItemAlias(index.ToIntStringKey(), alias);

            public void SetItemValue(IntStringKey key, PhpValue value)
            {
                if (key.IsInteger && Utilities.NumberUtils.IsInt32(key.Integer))
                {
                    _array[unchecked((int)key.Integer)] = ToObject(value);
                }
                else
                {
                    throw new ArgumentException(nameof(key));
                }
            }

            public void SetItemValue(PhpValue index, PhpValue value) => SetItemValue(index.ToIntStringKey(), value);
        }

        /// <summary>
        /// Helper class representing array access for classes with CLR "get_Item" / "set_Item" indexer method.
        /// </summary>
        sealed class GetSetItemAsPhpArray : IPhpArray
        {
            readonly object/*!*/_instance;

            public GetSetItemAsPhpArray(object/*!*/instance)
            {
                _instance = instance ?? throw new ArgumentNullException(nameof(instance));
            }

            public int Count => throw new NotSupportedException();

            public void AddValue(PhpValue value) => throw new NotSupportedException();

            public PhpAlias EnsureItemAlias(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureAlias(ref item);
            }

            public IPhpArray EnsureItemArray(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureArray(ref item);
            }

            public object EnsureItemObject(IntStringKey key)
            {
                var item = GetItemValue(key);
                return PhpValue.EnsureObject(ref item);
            }

            public PhpValue GetItemValue(IntStringKey key) => GetItemValue((PhpValue)key);

            public PhpValue GetItemValue(PhpValue index)
            {
                var getter = _instance.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.get_item];
                if (getter != null)
                {
                    // TODO: Context is null, should no be used but ...
                    return getter.Invoke(null, _instance, index);
                }
                else
                {
                    throw new NotSupportedException();
                }
            }

            public void RemoveKey(IntStringKey key) => RemoveKey((PhpValue)key);

            public void RemoveKey(PhpValue index) => throw new NotSupportedException();

            public void SetItemAlias(IntStringKey key, PhpAlias alias) => SetItemAlias((PhpValue)key, alias);

            public void SetItemAlias(PhpValue index, PhpAlias alias)
            {
                throw new NotImplementedException();
            }

            public void SetItemValue(IntStringKey key, PhpValue value) => SetItemValue((PhpValue)key, value);

            public void SetItemValue(PhpValue index, PhpValue value)
            {
                var setter = _instance.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.set_item];
                if (setter != null)
                {
                    // TODO: Context is null, should no be used but ...
                    setter.Invoke(null, _instance, index, value);
                }
                else
                {
                    throw new NotSupportedException();
                }
            }
        }

        public static IPhpArray EnsureArray(ArrayAccess obj)
        {
            Debug.Assert(obj != null);
            return new ArrayAccessAsPhpArray(obj);
        }

        public static IPhpArray EnsureArray(object obj)
        {
            // IPhpArray
            if (obj is IPhpArray) return (IPhpArray)obj;

            // ArrayAccess
            if (obj is ArrayAccess arrayAccess) return EnsureArray(arrayAccess);

            // IList
            if (obj is IList iList) return new ListAsPhpArray(iList);


            // get_Item
            if (obj.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.get_item] != null)
            {
                // IDictionary,
                // and item getters in general:
                return new GetSetItemAsPhpArray(obj);
            }

            // Fatal error: Uncaught Error: Cannot use object of type {0} as array
            PhpException.Throw(PhpError.Error, Resources.ErrResources.object_used_as_array, obj.GetPhpTypeInfo().Name);
            throw new ArgumentException(nameof(obj));
        }

        /// <summary>
        /// Gets <see cref="IPhpArray"/> instance providing access to the value with array operators.
        /// Returns <c>null</c> if underlaying value does provide array access.
        /// </summary>
        public static IPhpArray GetArrayAccess(ref PhpValue value) => value.TypeCode switch
        {
            // TODO // CONSIDER: what is this?

            PhpTypeCode.PhpArray => value.Array,
            PhpTypeCode.String => PhpValue.EnsureArray(ref value),
            PhpTypeCode.MutableString => value.MutableStringBlob,
            PhpTypeCode.Object => EnsureArray(value.Object),
            PhpTypeCode.Alias => value.Alias.EnsureArray(),
            _ => null,
        };

        /// <summary>
        /// Gets <see cref="IPhpArray"/> to be used as R-value of <c>list</c> expression.
        /// </summary>
        public static IPhpArray GetListAccess(PhpValue value)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.PhpArray: return value.Array;
                case PhpTypeCode.Object: return EnsureArray(value.Object);
                case PhpTypeCode.Alias: return GetListAccess(value.Alias.Value);
                default:
                    // TODO: some kind of debug log would be nice, PHP does not do that
                    return PhpArray.Empty;
            }
        }

        /// <summary>
        /// Gets <see cref="IPhpArray"/> to be used as R-value of <c>list</c> expression.
        /// </summary>
        public static IPhpArray GetListAccess(object value) => EnsureArray(value);

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/>.
        /// </summary>
        /// <param name="value">String to be accessed as array.</param>
        /// <param name="index">Index.</param>
        /// <returns>Character on index or empty string if index is our of range.</returns>
        public static string GetItemValue(string value, long index)
        {
            return (value != null && index >= 0 && index < value.Length)
                ? value[unchecked((int)index)].ToString()
                : string.Empty; // TODO: quiet ?
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/>.
        /// </summary>
        public static string GetItemValue(string value, IntStringKey key)
        {
            var index = key.IsInteger
                ? key.Integer
                : Convert.StringToLongInteger(key.String);

            return GetItemValue(value, index);
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/> with <c>isset</c> semantics.
        /// </summary>
        public static string GetItemValueOrNull(string value, IntStringKey key)
        {
            var index = key.IsInteger
                ? key.Integer
                : Convert.StringToLongInteger(key.String);

            return (value != null && index >= 0 && index < value.Length)
                ? value[unchecked((int)index)].ToString()
                : null;
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="string"/>.
        /// </summary>
        public static string GetItemValue(string value, PhpValue index, bool quiet)
        {
            if (value != null && index.TryToIntStringKey(out var key))
            {
                long i;

                if (key.IsInteger)
                {
                    i = key.Integer;
                }
                else
                {
                    if (quiet) return null;

                    i = Convert.StringToLongInteger(key.String);
                }

                if (i >= 0 && i < value.Length)
                {
                    return value[(int)i].ToString();
                }
            }

            //
            if (quiet)
            {
                // used by isset() and empty()
                return null;
            }
            else
            {
                PhpException.Throw(PhpError.Warning, Resources.ErrResources.illegal_string_offset, index.ToString());
                return string.Empty;
            }
        }

        /// <summary>
        /// Shortcut for calling <c>ord($s[$i])</c> on a <see cref="PhpValue"/>
        /// without any extra allocation.
        /// </summary>
        public static long GetItemOrdValue(PhpValue value, long index)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.String:
                    return GetItemOrdValue(value.String, index);

                case PhpTypeCode.MutableString:
                    return GetItemOrdValue(value.MutableString, index);

                case PhpTypeCode.Alias:
                    return GetItemOrdValue(value.Alias.Value, index);

                default:
                    var item = value.GetArrayItem(index);
                    if (item.IsMutableString(out var itemPhpString))
                    {
                        return itemPhpString.IsEmpty ? 0 : itemPhpString[0];
                    }
                    else
                    {
                        var str = item.ToStringUtf8();
                        return string.IsNullOrEmpty(str) ? 0 : str[0];
                    }
            }
        }

        /// <summary>
        /// Shortcut for calling <c>ord($s[$i])</c> on a <see cref="string"/>
        /// without any extra allocation.
        /// </summary>
        public static long GetItemOrdValue(string value, long index)
        {
            if (value != null && index >= 0 && index < value.Length)
            {
                return value[(int)index];
            }

            //
            PhpException.Throw(PhpError.Warning, Resources.ErrResources.illegal_string_offset, index.ToString());
            return 0;
        }

        /// <summary>
        /// Shortcut for calling <c>ord($s[$i])</c> on a <see cref="PhpString"/>
        /// without any extra allocation.
        /// </summary>
        public static long GetItemOrdValue(PhpString value, long index)
        {
            if (index >= 0 && index < value.Length)
            {
                return value[(int)index];
            }

            PhpException.Throw(PhpError.Warning, Resources.ErrResources.illegal_string_offset, index.ToString());
            return 0;
        }

        public static object EnsureItemObject(this IPhpArray array, PhpValue index)
        {
            if (index.TryToIntStringKey(out var key))
            {
                return array.EnsureItemObject(key);
            }
            else
            {
                throw PhpException.TypeErrorException(Resources.ErrResources.illegal_offset_type);
            }
        }

        public static IPhpArray EnsureItemArray(this IPhpArray array, PhpValue index)
        {
            if (index.TryToIntStringKey(out var key))
            {
                return array.EnsureItemArray(key);
            }
            else
            {
                throw PhpException.TypeErrorException(Resources.ErrResources.illegal_offset_type);
            }
        }

        public static PhpAlias EnsureItemAlias(this IPhpArray array, PhpValue index, bool quiet)
        {
            if (index.TryToIntStringKey(out var key))
            {
                return array.EnsureItemAlias(key);
            }
            else
            {
                if (!quiet)
                {
                    PhpException.IllegalOffsetType();
                }

                return PhpAlias.Create(PhpValue.Null);
            }
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="PhpValue"/>.
        /// </summary>
        public static PhpValue GetItemValue(PhpValue value, PhpValue index, bool quiet = false)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.PhpArray:
                    return value.Array.GetItemValue(index); // , quiet);

                case PhpTypeCode.String:
                    var item = GetItemValue(value.String, index, quiet);
                    if (quiet && string.IsNullOrEmpty(item))
                    {
                        return PhpValue.Null;
                    }
                    return item;

                case PhpTypeCode.MutableString:
                    return value.MutableStringBlob.GetItemValue(index); // quiet);

                case PhpTypeCode.Object:
                    return Operators.GetItemValue(value.Object, index, quiet);

                case PhpTypeCode.Alias:
                    return value.Alias.Value.GetArrayItem(index, quiet);

                default:
                    // TODO: warning
                    return PhpValue.Null;
            }
        }

        /// <summary>
        /// Implements <c>[]</c> operator on <see cref="PhpValue"/>.
        /// </summary>
        public static PhpValue GetItemValue(object obj, PhpValue index, bool quiet = false)
        {
            // IPhpArray.GetItemValue
            if (obj is IPhpArray arr)
            {
                return arr.GetItemValue(index); // , quiet);
            }

            // ArrayAccess.offsetGet()
            if (obj is ArrayAccess arracces)
            {
                return arracces.offsetGet(index);
            }

            // IList[]
            if (obj is IList list)
            {
                if (index.TryToIntStringKey(out var key) && key.IsInteger)
                {
                    if (key.Integer >= 0 && key.Integer < list.Count)
                    {
                        return PhpValue.FromClr(list[(int)key.Integer]);
                    }
                    else if (!quiet)
                    {
                        PhpException.UndefinedOffset(key);
                    }
                }
                else if (!quiet)
                {
                    PhpException.IllegalOffsetType();
                }

                return PhpValue.Null;
            }


            // get_Item
            if (obj != null)
            {
                // IDictionary
                // and item getter in general:

                var getter = obj.GetPhpTypeInfo().RuntimeMethods[TypeMethods.MagicMethods.get_item];
                if (getter != null)
                {
                    return getter.Invoke(null, obj, index);
                }
            }

            //
            if (!quiet)
            {
                PhpException.ObjectUsedAsArray(PhpVariable.GetClassName(obj));
            }

            //
            return PhpValue.Null;
        }

        public static bool TryGetItemValue(this PhpArray value, string index, out PhpValue item)
        {
            if (value != null && value.TryGetValue(index, out item) && IsSet(item))
            {
                return true;
            }
            else
            {
                item = default;
                return false;
            }
        }

        public static bool TryGetItemValue(this PhpArray value, PhpValue index, out PhpValue item)
        {
            if (value != null && index.TryToIntStringKey(out var key) && value.TryGetValue(key, out item) && IsSet(item))
            {
                return true;
            }
            else
            {
                item = default;
                return false;
            }
        }

        public static bool TryGetItemValue(this PhpValue value, PhpValue index, out PhpValue item)
        {
            if (value.IsPhpArray(out var array))
            {
                // Specialized call for array
                return TryGetItemValue(array, index, out item);
            }
            else
            {
                // Otherwise use the original semantics of isset($x[$y]) ? $x[$y] : ...;
                if (offsetExists(value, index))
                {
                    item = GetItemValue(value, index);
                    return true;
                }
                else
                {
                    item = default;
                    return false;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static PhpAlias EnsureItemAlias_Old(PhpValue value, PhpValue index, bool quiet = false)
        {
            Debug.WriteLineIf(value.IsNull, "NULL value won't be changed to array!");

            return EnsureItemAlias(ref value, index, quiet);
        }

        /// <summary>
        /// Implements <c>&amp;[]</c> operator on <see cref="PhpValue"/>.
        /// Ensures the value is an array and item at given <paramref name="index"/> is an alias.
        /// </summary>
        public static PhpAlias EnsureItemAlias(ref PhpValue value, PhpValue index, bool quiet = false)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.Null:
                    // TODO: Err: Warning: Creating default object from empty value
                    var arr = new PhpArray();
                    value = PhpValue.Create(arr);
                    return arr.EnsureItemAlias(index, quiet);

                case PhpTypeCode.PhpArray:
                    return value.Array.EnsureItemAlias(index, quiet);

                case PhpTypeCode.String:
                    throw new NotImplementedException();

                case PhpTypeCode.MutableString:
                    throw new NotImplementedException();

                case PhpTypeCode.Object:
                    if (value.Object is IPhpArray array)
                    {
                        return EnsureItemAlias(array, index, quiet);
                    }

                    if (!quiet) // NOTE: PHP does not report this error (?)
                    {
                        PhpException.Throw(PhpError.Error, Resources.ErrResources.object_used_as_array, value.Object.GetPhpTypeInfo().Name);
                    }

                    break;

                case PhpTypeCode.Alias:
                    return value.Alias.EnsureItemAlias(index, quiet);
            }

            // TODO: Warning
            return PhpAlias.Create(PhpValue.Null);
        }

        public static bool offsetExists(this PhpArray value, long index) =>
            value != null &&
            value.TryGetValue((int)index, out var x) &&
            IsSet(x);

        public static bool offsetExists(this PhpArray value, string index) =>
            value != null &&
            value.TryGetValue(index, out var x) &&
            IsSet(x);

        public static bool offsetExists(this PhpArray value, PhpValue index) =>
            value != null &&
            index.TryToIntStringKey(out var key) &&
            value.TryGetValue(key, out var x) &&
            IsSet(x);

        public static bool offsetExists(this string value, PhpValue index)
        {
            return index.TryToIntStringKey(out var key) && key.IsInteger && offsetExists(value, key.Integer);
        }

        public static bool offsetExists(this string value, long index)
        {
            return value != null && index >= 0 && index < value.Length;
        }

        public static bool offsetExists(this PhpString value, long index)
        {
            return index >= 0 && index < value.Length;
        }

        public static bool offsetExists(object obj, PhpValue index)
        {
            return obj switch
            {
                // PHP ArrayAccess
                ArrayAccess arrrayAccess => arrrayAccess.offsetExists(index),

                // object implementing PeachPie's IPhpArray
                IPhpArray arr => IsSet(arr.GetItemValue(index)),

                // IList, checks the integer key is in range
                IList list => index.TryToIntStringKey(out var key) && key.IsInteger && key.Integer >= 0 && key.Integer < list.Count,

                // IDictionary
                IDictionary dict => offsetExists(dict, index),

                // TODO: generic get_Item() getter
                _ => false,
            };
        }

        public static bool offsetExists(IDictionary obj, PhpValue index)
        {
            if (obj != null)
            {
                // return obj.Contains(index.ToClr()); // <-- cannot be used, index might need to be converted to specific Dictionary's TKey type

                var getter = obj.GetPhpTypeInfo().RuntimeMethods[/*nameof(IDictionary<,>.ContainsKey)*/"ContainsKey"];
                if (getter != null)
                {
                    return getter.Invoke(null, obj, index).ToBoolean();
                }

                // fallback to generic behavior,
                // might get false if index is of a wrong type
                return obj.Contains(index.ToClr());
            }

            return false;
        }

        public static bool offsetExists(PhpAlias alias, PhpValue index) => offsetExists(alias.Value, index);

        public static bool offsetExists(this PhpValue value, PhpValue index)
        {
            if (value.Object is PhpArray array)
            {
                return offsetExists(array, index);
            }
            else if (value.Object is string str)
            {
                return offsetExists(str, index);
            }
            else if (value.Object is PhpString.Blob blob)
            {
                return index.TryToIntStringKey(out var key) && key.IsInteger && key.Integer >= 0 && key.Integer < blob.Length;
            }
            else if (value.Object is PhpAlias alias)
            {
                return offsetExists(alias.Value, index);
            }
            else if (value.Object != null)
            {
                // class instance
                return offsetExists(value.Object, index);
            }

            // scalar or NULL
            return false;
        }

        #endregion

        #region Object

        public static bool PropertyExists(RuntimeTypeHandle caller, object instance, PhpValue prop)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. runtime property

            // 3. __isset

            // false

            throw new NotImplementedException();
        }

        public static PhpValue PropertyGetValue(RuntimeTypeHandle caller, object instance, PhpValue propertyName)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. runtime property

            // 3. __get

            // error

            throw new NotImplementedException();
        }

        public static void PropertySetValue(RuntimeTypeHandle caller, object instance, PhpValue prop, PhpValue value)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. overwrite runtime property

            // 3. __set ?? runtime property

            // error

            throw new NotImplementedException();
        }

        public static void PropertyUnset(RuntimeTypeHandle caller, object instance, PhpValue prop)
        {
            var tinfo = instance.GetPhpTypeInfo();

            // 1. instance property

            // 2. unset runtime property

            // 3. __unset

            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> from a string or an object instance.
        /// </summary>
        /// <param name="ctx">Current runtime context.</param>
        /// <param name="object">String or object. Other value types cause an exception.</param>
        /// <returns>Corresponding <see cref="PhpTypeInfo"/> descriptor. Cannot be <c>null</c>.</returns>
        public static PhpTypeInfo TypeNameOrObjectToType(Context ctx, PhpValue @object)
        {
            object obj;
            string str;

            if ((obj = (@object.AsObject())) != null)
            {
                return obj.GetType().GetPhpTypeInfo();
            }
            else if ((str = PhpVariable.AsString(@object)) != null)
            {
                return ctx.GetDeclaredType(str, true);
            }
            else
            {
                throw new ArgumentException();
            }
        }

        /// <summary>
        /// Resolves the runtime property by looking into runtime properties and eventually invoking the <c>__get</c> magic method.
        /// </summary>
        public static PhpValue RuntimePropertyGetValue(Context/*!*/ctx, object/*!*/instance, string propertyName, bool quiet)
        {
            return RuntimePropertyGetValue(ctx, instance.GetPhpTypeInfo(), instance, propertyName, quiet);
        }

        /// <summary>
        /// Resolves the runtime property by looking into runtime properties and eventually invoking the <c>__get</c> magic method.
        /// </summary>
        public static PhpValue RuntimePropertyGetValue(Context/*!*/ctx, PhpTypeInfo/*!*/type, object/*!*/instance, string propertyName, bool quiet)
        {
            var runtimeFields = type.GetRuntimeFields(instance);
            if (runtimeFields != null && runtimeFields.TryGetValue(propertyName, out var value))
            {
                return value;
            }

            var __get = type.RuntimeMethods[TypeMethods.MagicMethods.__get];
            if (__get != null)
            {
                // NOTE: magic methods must have public visibility, therefore the visibility check is unnecessary

                // int subkey1 = access.Write() ? 1 : access.Unset() ? 2 : access.Isset() ? 3 : 4;
                int subkey = propertyName.GetHashCode() ^ (1 << 4/*subkey1*/);

                using (var token = new Context.RecursionCheckToken(ctx, instance, subkey))
                {
                    if (!token.IsInRecursion)
                    {
                        return __get.Invoke(ctx, instance, propertyName);
                    }
                }
            }

            //
            if (!quiet)
            {
                PhpException.UndefinedProperty(type.Name, propertyName);
            }

            // empty
            return PhpValue.Null;
        }

        #endregion

        #region self, parent

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of self.
        /// Throws in case of self being used out of class context.
        /// </summary>
        public static PhpTypeInfo GetSelf(RuntimeTypeHandle self)
        {
            if (self.Equals(default(RuntimeTypeHandle)))
            {
                PhpException.ThrowSelfOutOfClass();
            }

            //
            return self.GetPhpTypeInfo();
        }

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of self or <c>null</c>.
        /// </summary>
        public static PhpTypeInfo GetSelfOrNull(RuntimeTypeHandle self) => self.GetPhpTypeInfo();

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of parent.
        /// Throws in case of parent being used out of class context or within a parentless class.
        /// </summary>
        public static PhpTypeInfo GetParent(RuntimeTypeHandle self) => GetParent(self.GetPhpTypeInfo());

        /// <summary>
        /// Gets <see cref="PhpTypeInfo"/> of parent.
        /// Throws in case of parent being used out of class context or within a parentless class.
        /// </summary>
        public static PhpTypeInfo GetParent(PhpTypeInfo self)
        {
            if (self == null)
            {
                PhpException.Throw(PhpError.Error, Resources.ErrResources.parent_used_out_of_class);
            }
            else
            {
                var t = self.BaseType;
                if (t != null)
                {
                    return t;
                }
                else
                {
                    PhpException.Throw(PhpError.Error, Resources.ErrResources.parent_accessed_in_parentless_class);
                }
            }

            //
            throw new ArgumentException(nameof(self));
        }

        #endregion

        #region GetForeachEnumerator

        /// <summary>
        /// Provides the <see cref="IPhpEnumerator"/> interface by wrapping a user-implemeted <see cref="Iterator"/>.
        /// </summary>
        /// <remarks>
        /// Instances of this class are iterated when <c>foreach</c> is used on object of a class
        /// that implements <see cref="Iterator"/> or <see cref="IteratorAggregate"/>.
        /// </remarks>
        [DebuggerNonUserCode, DebuggerStepThrough]
        private sealed class PhpIteratorEnumerator : IPhpEnumerator
        {
            readonly Iterator _iterator;
            bool _hasmoved;

            public PhpIteratorEnumerator(Iterator iterator)
            {
                Debug.Assert(iterator != null);
                _iterator = iterator;
                Reset();
            }

            public bool AtEnd
            {
                get
                {
                    throw new NotImplementedException();
                }
            }

            public KeyValuePair<PhpValue, PhpValue> Current => new KeyValuePair<PhpValue, PhpValue>(CurrentKey, CurrentValue);

            public PhpValue CurrentKey => _iterator.key().DeepCopy();

            public PhpValue CurrentValue => _iterator.current().DeepCopy();

            public PhpAlias CurrentValueAliased
            {
                get
                {
                    var value = _iterator.current();
                    return PhpValue.EnsureAlias(ref value);
                }
            }

            object IEnumerator.Current => Current;

            public void Dispose() { }

            public bool MoveFirst()
            {
                Reset();
                return _iterator.valid();
            }

            public bool MoveLast()
            {
                throw new NotImplementedException();
            }

            public bool MoveNext()
            {
                if (_hasmoved)
                {
                    _iterator.next();
                }
                else
                {
                    _hasmoved = true;
                }

                return _iterator.valid();
            }

            public bool MovePrevious()
            {
                throw new NotImplementedException();
            }

            public void Reset()
            {
                _hasmoved = false;
                _iterator.rewind();
            }
        }

        /// <summary>
        /// Provides <see cref="IPhpEnumerator"/> implementation enumerating class instance fields and runtime fields.
        /// </summary>
        private sealed class PhpFieldsEnumerator : IPhpEnumerator
        {
            readonly IEnumerator<KeyValuePair<IntStringKey, PhpValue>> _enumerator;
            bool _valid;

            public PhpFieldsEnumerator(object obj, RuntimeTypeHandle caller)
            {
                Debug.Assert(obj != null);
                _enumerator = TypeMembersUtils.EnumerateVisibleInstanceFields(obj, caller).GetEnumerator();
                _valid = true;
            }

            public bool AtEnd => !_valid;

            public KeyValuePair<PhpValue, PhpValue> Current
            {
                get
                {
                    var current = _enumerator.Current;
                    return new KeyValuePair<PhpValue, PhpValue>(PhpValue.Create(current.Key), current.Value);
                }
            }

            public PhpValue CurrentKey => PhpValue.Create(_enumerator.Current.Key);

            public PhpValue CurrentValue => _enumerator.Current.Value.GetValue().DeepCopy();

            public PhpAlias CurrentValueAliased
            {
                get
                {
                    var value = _enumerator.Current.Value;
                    return PhpValue.EnsureAlias(ref value);
                }
            }

            object IEnumerator.Current => _enumerator.Current;

            public void Dispose() => _enumerator.Dispose();

            public bool MoveFirst()
            {
                Reset();
                return MoveNext();
            }

            public bool MoveLast()
            {
                throw new NotImplementedException();
            }

            public bool MoveNext()
            {
                return (_valid = _enumerator.MoveNext());
            }

            public bool MovePrevious()
            {
                throw new NotSupportedException();
            }

            public void Reset()
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Implements empty enumeration.
        /// </summary>
        private sealed class PhpEmptyEnumerator : IPhpEnumerator
        {
            public static readonly IPhpEnumerator Instance = new PhpEmptyEnumerator();

            private PhpEmptyEnumerator() { }

            public bool AtEnd => false;

            public KeyValuePair<PhpValue, PhpValue> Current => default(KeyValuePair<PhpValue, PhpValue>);

            public PhpValue CurrentKey => PhpValue.Null;

            public PhpValue CurrentValue => PhpValue.Null;

            public PhpAlias CurrentValueAliased => PhpAlias.Create(PhpValue.Null);

            object IEnumerator.Current => null;

            public void Dispose() { }

            public bool MoveFirst() => false;

            public bool MoveLast() => false;

            public bool MoveNext() => false;

            public bool MovePrevious() => false;

            public void Reset() { }
        }

        #region ClrEnumeratorFactory

        abstract class ClrEnumeratorFactory
        {
            public static IPhpEnumerator CreateEnumerator(IEnumerable enumerable)
            {
                Debug.Assert(enumerable != null);

                // special cases before using reflection
                if (enumerable is IEnumerable<(PhpValue, PhpValue)> valval) return new ValueTupleEnumerator<PhpValue, PhpValue>(valval);
                if (enumerable is IDictionary iDictionary) return new DictionaryEnumerator(iDictionary.GetEnumerator());
                if (enumerable is IEnumerable<KeyValuePair<object, object>> kv) return new KeyValueEnumerator<object, object>(kv);
                if (enumerable is IEnumerable<object>) return new EnumerableEnumerator(enumerable.GetEnumerator());

                // TODO: cache following for the enumerable type

                // find IEnumerable<>
                foreach (var iface_type in enumerable.GetType().GetInterfaces())
                {
                    if (iface_type.IsGenericType && iface_type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                    {
                        var item_type = iface_type.GenericTypeArguments[0];
                        if (item_type.IsGenericType)
                        {
                            // ValueTuple<A, B>
                            if (item_type.GetGenericTypeDefinition() == typeof(ValueTuple<,>))
                            {
                                return (ClrEnumerator)Activator.CreateInstance(
                                    typeof(ValueTupleEnumerator<,>).MakeGenericType(item_type.GetGenericArguments()),
                                    enumerable);
                            }

                            // KeyValuePair<A, B>
                            if (item_type.GetGenericTypeDefinition() == typeof(KeyValuePair<,>))
                            {
                                return (ClrEnumerator)Activator.CreateInstance(
                                    typeof(KeyValueEnumerator<,>).MakeGenericType(item_type.GetGenericArguments()),
                                    enumerable);
                            }
                        }
                    }
                }

                // generic
                return new EnumerableEnumerator(enumerable.GetEnumerator());
            }

            abstract class ClrEnumerator : IPhpEnumerator
            {
                abstract protected IEnumerator Enumerator { get; }

                /// <summary>
                /// Current key and value.
                /// </summary>
                PhpValue _key, _value;

                abstract protected void FetchCurrent(ref PhpValue key, ref PhpValue value);

                public bool AtEnd => throw new NotSupportedException();

                public PhpValue CurrentValue => _value;

                public PhpAlias CurrentValueAliased => _value.IsAlias ? _value.Alias : throw new InvalidOperationException();

                public PhpValue CurrentKey => _key;

                public KeyValuePair<PhpValue, PhpValue> Current => new KeyValuePair<PhpValue, PhpValue>(CurrentKey, CurrentValue);

                object IEnumerator.Current => Enumerator.Current;

                public void Dispose()
                {
                    _key = _value = PhpValue.Null;
                    (Enumerator as IDisposable)?.Dispose();
                }

                public virtual bool MoveFirst()
                {
                    Enumerator.Reset();
                    return MoveNext();
                }

                public virtual bool MoveLast()
                {
                    throw new NotImplementedException();
                }

                public virtual bool MoveNext()
                {
                    if (Enumerator.MoveNext())
                    {
                        FetchCurrent(ref _key, ref _value);
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

                public virtual bool MovePrevious()
                {
                    throw new NotSupportedException();
                }

                void IEnumerator.Reset() => Enumerator.Reset();
            }

            /// <summary>
            /// Enumerator of <see cref="IEnumerable"/>.
            /// </summary>
            sealed class EnumerableEnumerator : ClrEnumerator
            {
                readonly IEnumerator _enumerator;

                protected override IEnumerator Enumerator => _enumerator;

                long _key;

                public override bool MoveFirst()
                {
                    _key = -1;
                    return base.MoveFirst();
                }

                public override bool MoveNext()
                {
                    _key++;
                    return base.MoveNext();
                }

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    key = _key;
                    value = PhpValue.FromClr(_enumerator.Current);
                }

                public EnumerableEnumerator(IEnumerator enumerator)
                {
                    Debug.Assert(enumerator != null);
                    _enumerator = enumerator;
                    _key = -1;
                }
            }

            /// <summary>
            /// Enumerator of <see cref="IDictionary"/>
            /// </summary>
            sealed class DictionaryEnumerator : ClrEnumerator
            {
                readonly IDictionaryEnumerator _enumerator;
                protected override IEnumerator Enumerator => _enumerator;

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    var entry = _enumerator.Entry;
                    key = PhpValue.FromClr(entry.Key);
                    value = PhpValue.FromClr(entry.Value);
                }

                public DictionaryEnumerator(IDictionaryEnumerator enumerator)
                {
                    Debug.Assert(enumerator != null);
                    _enumerator = enumerator;
                }
            }

            sealed class ValueTupleEnumerator<K, V> : ClrEnumerator
            {
                readonly IEnumerator<(K, V)> _enumerator;
                protected override IEnumerator Enumerator => _enumerator;

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    var entry = _enumerator.Current;
                    key = PhpValue.FromClr(entry.Item1);
                    value = PhpValue.FromClr(entry.Item2);
                }

                public ValueTupleEnumerator(IEnumerable<(K, V)> enumerable)
                {
                    Debug.Assert(enumerable != null);
                    _enumerator = enumerable.GetEnumerator();
                }
            }

            sealed class KeyValueEnumerator<K, V> : ClrEnumerator
            {
                readonly IEnumerator<KeyValuePair<K, V>> _enumerator;
                protected override IEnumerator Enumerator => _enumerator;

                protected override void FetchCurrent(ref PhpValue key, ref PhpValue value)
                {
                    var entry = _enumerator.Current;
                    key = PhpValue.FromClr(entry.Key);
                    value = PhpValue.FromClr(entry.Value);
                }

                public KeyValueEnumerator(IEnumerable<KeyValuePair<K, V>> enumerable)
                {
                    Debug.Assert(enumerable != null);
                    _enumerator = enumerable.GetEnumerator();
                }
            }
        }

        #endregion

        /// <summary>
        /// Gets <see cref="Iterator"/> object enumerator.
        /// </summary>
        /// <returns>Instance of the enumerator. Cannot be <c>null</c>.</returns>
        public static IPhpEnumerator GetForeachEnumerator(Iterator it)
        {
            Debug.Assert(it != null);
            return new PhpIteratorEnumerator(it);
        }

        /// <summary>
        /// Resolves object enumerator.
        /// </summary>
        /// <exception cref="Exception">Object cannot be enumerated.</exception>
        /// <returns>Instance of the object enumerator. Cannot be <c>null</c>.</returns>
        public static IPhpEnumerator GetForeachEnumerator(object obj, bool aliasedValues, RuntimeTypeHandle caller)
        {
            Debug.Assert(obj != null);

            if (obj is Iterator iterator)
            {
                return GetForeachEnumerator(iterator);
            }
            else if (obj is IteratorAggregate iteratorAggregate)
            {
                var last_obj = obj;

                do
                {
                    obj = iteratorAggregate.getIterator();
                } while (obj is IteratorAggregate);

                if (obj is Iterator iterator)
                {
                    return GetForeachEnumerator(iterator);
                }
                else
                {
                    var errmessage = string.Format(Resources.ErrResources.getiterator_must_return_traversable, last_obj.GetType().GetPhpTypeInfo().Name);
                    // throw new (SPL)Exception(ctx, message, 0, null)
                    //Library.SPL.Exception.ThrowSplException(
                    //    _ctx => new Library.SPL.Exception(_ctx, true),
                    //    context,
                    //    string.Format(CoreResources.getiterator_must_return_traversable, last_obj.TypeName), 0, null);
                    throw new ArgumentException(errmessage);
                }
            }
            else if (obj is IPhpEnumerable phpenumerable)
            {
                return phpenumerable.GetForeachEnumerator(aliasedValues, caller);
            }
            else if (obj is IEnumerable enumerable)
            {
                // IDictionaryEnumerator, IEnumerable<ValueTuple>, IEnumerable<KeyValuePair>, IEnumerable, ...
                return GetForeachEnumerator(enumerable);
            }
            else
            {
                // PHP property enumeration
                return new PhpFieldsEnumerator(obj, caller);
            }
        }

        /// <summary>
        /// Gets <see cref="IPhpEnumerator"/> from regular .NET <see cref="IEnumerable"/>.
        /// Enumerator is reflected to properly unwrap <c>key</c> and <c>value</c> of PHP enumeration.
        /// Supported interfaces are <see cref="IDictionaryEnumerator"/>, <see cref="IEnumerable{ValueTuple}"/>, <see cref="IEnumerable{KeyValuePair}"/>, <see cref="IEnumerable"/> etc.
        /// See <see cref="ClrEnumeratorFactory"/> for more details.
        /// </summary>
        internal static IPhpEnumerator GetForeachEnumerator(IEnumerable enumerable) => ClrEnumeratorFactory.CreateEnumerator(enumerable);

        /// <summary>
        /// Gets PHP enumerator of <c>NULL</c> or <b>empty</b> value.
        /// </summary>
        public static IPhpEnumerator GetEmptyForeachEnumerator() => PhpEmptyEnumerator.Instance;

        /// <summary>
        /// Gets enumerator object for given value.
        /// </summary>
        public static IPhpEnumerator GetForeachEnumerator(PhpValue value, bool aliasedValues, RuntimeTypeHandle caller) => value.GetForeachEnumerator(aliasedValues, caller);

        /// <summary>
        /// Gets enumerator of array entries.
        /// This is internal implementation that avoids allocations in common cases.
        /// </summary>
        public static OrderedDictionary.FastEnumerator GetFastEnumerator(PhpArray array, bool aliasedValue)
        {
            Debug.Assert(array != null);

            if (array.Count == 0)
            {
                // follows call to MoveNext() which ends the enumeration
                // keep array as it is, it won't be accessed anyways
            }
            else if (aliasedValue)
            {
                // ensure array is not shared with another variable
                array.EnsureWritable();
            }
            else
            {
                // create lazy copy
                array.table.AddRef();
            }

            return array.GetFastEnumerator();
        }

        #endregion

        #region Copy, Unpack

        /// <summary>
        /// Gets copy of given value.
        /// </summary>
        public static PhpValue DeepCopy(PhpValue value) => value.DeepCopy();

        /// <summary>
        /// Deep copies the value in-place.
        /// Called when this has been passed by value and inplace dereferencing and copying is necessary.
        /// </summary>
        [DebuggerNonUserCode, DebuggerStepThrough]
        public static void PassValue(ref PhpValue value)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.MutableString:
                    // lazy copy
                    value.MutableStringBlob.AddRef();
                    break;
                case PhpTypeCode.PhpArray:
                    // lazy copy
                    value = new PhpValue(value.Array.DeepCopy());
                    break;
                case PhpTypeCode.Alias:
                    // dereference & lazy copy
                    value = value.Alias.Value.DeepCopy();
                    break;
            }
        }

        /// <summary>
        /// Performs <c>clone</c> operation on given object.
        /// </summary>
        public static object Clone(Context ctx, object value)
        {
            if (value is IPhpCloneable cloneable)
            {
                value = cloneable.Clone();
            }
            else if (value != null)
            {
                value = CloneRaw(ctx, value);
            }
            else
            {
                PhpException.Throw(PhpError.Error, Resources.ErrResources.clone_called_on_non_object);
            }

            //

            return value;
        }

        /// <summary>
        /// Performs memberwise clone of the object.
        /// Calling <c>__clone</c> eventually.
        /// </summary>
        public static object CloneRaw(Context ctx, object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            var tinfo = value.GetPhpTypeInfo();

            // memberwise clone
            var newobj = tinfo.CreateUninitializedInstance(ctx);
            if (newobj != null)
            {
                Serialization.MemberwiseClone(tinfo, value, newobj);

                //
                value = newobj;

                // __clone(), only if __clone() is public
                var __clone = tinfo.RuntimeMethods[TypeMethods.MagicMethods.__clone];
                if (__clone != null && __clone.IsPublic())
                {
                    __clone.Invoke(ctx, value);
                }
            }
            else
            {
                PhpException.Throw(PhpError.Error, Resources.ErrResources.class_instantiation_failed, tinfo.Name);
            }

            //
            return value;
        }

        /// <summary>
        /// Every property of type <see cref="PhpValue"/> will be deeply copied inplace, including runtime fields.
        /// Calling <c>__clone</c> eventually.
        /// </summary>
        public static object CloneInPlace(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            var tinfo = value.GetPhpTypeInfo();

            // clone runtime fields:
            if (tinfo.RuntimeFieldsHolder != null)
            {
                var runtimefields = (PhpArray)tinfo.RuntimeFieldsHolder.GetValue(value);
                tinfo.RuntimeFieldsHolder.SetValue(value, runtimefields?.Clone());
            }

            // deep copy instance fields (of type PhpValue)
            foreach (var p in tinfo.DeclaredFields.InstanceProperties.OfType<PhpPropertyInfo.ClrFieldProperty>())
            {
                if (p.Field.FieldType == typeof(PhpValue))
                {
                    var oldvalue = (PhpValue)p.Field.GetValue(value);
                    p.Field.SetValue(value, (object)oldvalue.DeepCopy());
                }
            }

            // __clone(), only if __clone() is public
            var __clone = tinfo.RuntimeMethods[TypeMethods.MagicMethods.__clone];
            if (__clone != null && __clone.IsPublic())
            {
                __clone.Invoke(null, value); // 'ctx' is not needed ... probably
            }

            //
            return value;
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="argument"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="argument">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        public static void Unpack(List<PhpValue> stack, PhpValue argument, ulong byrefs)
        {
            // https://wiki.php.net/rfc/argument_unpacking

            switch (argument.TypeCode)
            {
                case PhpTypeCode.PhpArray:
                    Unpack(stack, argument.Array, byrefs);
                    break;

                case PhpTypeCode.Object:
                    if (argument.Object is Traversable traversable)
                    {
                        Unpack(stack, traversable, byrefs);
                        break;
                    }
                    else if (argument.Object is Array array)
                    {
                        Unpack(stack, array, byrefs);
                        break;
                    }
                    else
                    {
                        goto default;
                    }

                case PhpTypeCode.Alias:
                    Unpack(stack, argument.Alias.Value, byrefs);
                    break;

                default:
                    // TODO: Warning: Only arrays and Traversables can be unpacked
                    // do not add item to the arguments list // stack.Add(argument);
                    break;
            }
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="array"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="array">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        public static void Unpack(List<PhpValue> stack, PhpArray array, ulong byrefs)
        {
            Debug.Assert(array != null);

            var enumerator = array.GetFastEnumerator();
            while (enumerator.MoveNext())
            {
                if (enumerator.CurrentKey.IsString)
                {
                    // TODO: E_RECOVERABLE error
                    break;  // no further arguments will be unpacked
                }

                if ((byrefs & (1ul << stack.Count)) == 0)
                {
                    // pass by value
                    stack.Add(enumerator.CurrentValue);
                }
                else
                {
                    // pass by reference
                    stack.Add(PhpValue.Create(enumerator.CurrentValueAliased));
                }
            }
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="array"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="array">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        static void Unpack(List<PhpValue> stack, Array array, ulong byrefs)
        {
            for (int i = 0; i < array.Length; i++)
            {
                stack.Add(PhpValue.FromClr(array.GetValue(i)));
            }
        }

        /// <summary>
        /// The method implements <c>...</c> unpack operator.
        /// Unpacks <paramref name="traversable"/> into <paramref name="stack"/>.
        /// </summary>
        /// <param name="stack">The list with unpacked arguments.</param>
        /// <param name="traversable">Value to be unpacked.</param>
        /// <param name="byrefs">Bit mask of parameters that are passed by reference. Arguments corresponding to <c>1</c>-bit are aliased.</param>
        public static void Unpack(List<PhpValue> stack, Traversable traversable, ulong byrefs)
        {
            Debug.Assert(traversable != null);

            if (traversable is IteratorAggregate aggr)
            {
                Unpack(stack, aggr.getIterator(), byrefs);
            }
            else if (traversable is Iterator iterator)
            {
                iterator.rewind();
                while (iterator.valid())
                {
                    Debug.Assert((byrefs & (1ul << stack.Count)) == 0, "Cannot pass by-reference when unpacking a Traversable");
                    //{
                    //    // TODO: Warning: Cannot pass by-reference argument {stack.Count + 1} of {function_name}() by unpacking a Traversable, passing by-value instead
                    //}

                    stack.Add(iterator.current());
                    iterator.next();
                }
            }
            else
            {
                throw new ArgumentException();
            }
        }

        #endregion

        #region ReadConstant

        /// <summary>
        /// Gets constant value, throws <c>notice</c> if constant is not defined.
        /// </summary>
        public static PhpValue ReadConstant(Context ctx, string name, ref int idx)
        {
            Debug.Assert(name != null, nameof(name));

            if (ctx.TryGetConstant(name, out var value, ref idx))
            {
                return value;
            }
            else
            {
                // Warning: undefined constant
                PhpException.Throw(PhpError.Notice, Resources.ErrResources.undefined_constant, name);
                return name;
            }
        }

        /// <summary>
        /// Gets constant value, throws <c>notice</c> if constant is not defined.
        /// </summary>
        public static PhpValue ReadConstant(Context ctx, string name, ref int idx, string fallbackName)
        {
            Debug.Assert(name != null, nameof(name));
            Debug.Assert(fallbackName != null, nameof(fallbackName));

            if (ctx.TryGetConstant(name, out var value, ref idx) ||
                ctx.TryGetConstant(fallbackName, out value))
            {
                return value;
            }
            else
            {
                // Warning: undefined constant
                PhpException.Throw(PhpError.Notice, Resources.ErrResources.undefined_constant, fallbackName);
                return fallbackName;
            }
        }

        /// <summary>
        /// Constant declaration.
        /// </summary>
        public static void DeclareConstant(Context ctx, string name, ref int idx, PhpValue value)
        {
            ctx.DefineConstant(name, value, ref idx, ignorecase: false);
        }

        #endregion

        #region Closure

        public static RoutineInfo AnonymousRoutine(string name, RuntimeMethodHandle handle) => new PhpAnonymousRoutineInfo(name, handle);

        /// <summary>
        /// Create <see cref="Closure"/> with specified anonymous function and used parameters.
        /// </summary>
        public static Closure BuildClosure(Context/*!*/ctx, IPhpCallable routine, object @this, RuntimeTypeHandle scope, PhpTypeInfo statictype, PhpArray/*!*/parameter, PhpArray/*!*/@static)
            => new Closure(ctx, routine, @this, scope, statictype, parameter, @static);

        public static Context Context(this Closure closure) => closure._ctx;

        /// <summary>Resolves late static bound type of closiure. Can be <c>null</c> reference.</summary>
        public static PhpTypeInfo Static(this Closure closure)
        {
            if (closure._this != null)
            {
                // typeof $this
                return closure._this.GetPhpTypeInfo();
            }

            if (closure._statictype != null)
            {
                // static
                return closure._statictype;
            }

            // self or NULL
            return closure._scope.GetPhpTypeInfo();
        }

        public static RuntimeTypeHandle Scope(this Closure closure) => closure._scope;

        public static object This(this Closure closure) => closure._this;

        /// <summary>
        /// Gets internal <see cref="IPhpCallable"/> object invoked by the closure.
        /// </summary>
        public static IPhpCallable Callable(this Closure closure) => closure._callable;

        #endregion

        #region Generator

        /// <summary>
        /// Create <see cref="Generator"/> with specified state machine function and parameters.
        /// </summary>
        public static Generator BuildGenerator(Context ctx, PhpArray locals, PhpArray tmpLocals, GeneratorStateMachineDelegate smmethod, RuntimeMethodHandle ownerhandle) => new Generator(ctx, locals, tmpLocals, smmethod, ownerhandle);

        public static int GetGeneratorState(Generator g) => g._state;

        public static void SetGeneratorState(Generator g, int newState) => g._state = newState;

        /// <summary>
        /// In case generator has an exception, throws it.
        /// The current exception is then nullified.
        /// </summary>
        [DebuggerNonUserCode, DebuggerHidden]
        public static void HandleGeneratorException(Generator g)
        {
            var exception = g._currException;
            g._currException = null;

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>Set yielded value from generator where key is not specified.</summary>
        public static void SetGeneratorCurrent(Generator g, PhpValue value)
        {
            g._currValue = value;
            g._currKey = (PhpValue)(++g._maxNumericalKey);
        }

        /// <summary>
        /// Sets yielded value from generator with key.
        /// This operator does not update auto-incremented Generator key.
        /// </summary>
        public static void SetGeneratorCurrentFrom(Generator g, PhpValue value, PhpValue key)
        {
            g._currValue = value;
            g._currKey = key;
        }

        /// <summary>Set yielded value from generator with key.</summary>
        public static void SetGeneratorCurrent(Generator g, PhpValue value, PhpValue key)
        {
            SetGeneratorCurrentFrom(g, value, key);

            // update the Generator auto-increment key
            if (key.IsLong(out var ikey) && ikey > g._maxNumericalKey)
            {
                g._maxNumericalKey = ikey;
            }
        }

        public static PhpValue GetGeneratorSentItem(Generator g) => g._currSendItem;

        public static void SetGeneratorReturnedValue(Generator g, PhpValue value) => g._returnValue = value;

        public static object GetGeneratorThis(Generator g) => g._this;

        public static Generator SetGeneratorThis(this Generator generator, object @this)
        {
            generator._this = @this;
            return generator;
        }

        /// <summary>
        /// Resolves generator's <c>static</c> type.
        /// </summary>
        /// <returns><see cref="PhpTypeInfo"/> refering to the lazy static bound type. Cannot be <c>null</c>.</returns>
        public static PhpTypeInfo GetGeneratorLazyStatic(this Generator generator)
        {
            return generator._static ?? generator._this?.GetPhpTypeInfo() ?? throw new InvalidOperationException();
        }

        public static Generator SetGeneratorLazyStatic(this Generator generator, PhpTypeInfo @static)
        {
            generator._static = @static;
            return generator;
        }

        public static Context GetGeneratorContext(Generator g) => g._ctx;

        public static GeneratorStateMachineDelegate GetGeneratorMethod(Generator g) => g._stateMachineMethod;

        public static MethodInfo GetGeneratorOwnerMethod(Generator g) => (MethodInfo)MethodBase.GetMethodFromHandle(g._ownerhandle);

        public static Generator SetGeneratorDynamicScope(this Generator g, RuntimeTypeHandle scope)
        {
            g._scope = scope;
            return g;
        }

        public static RuntimeTypeHandle GetGeneratorDynamicScope(this Generator g) => g._scope;

        #endregion

        #region Dynamic

        /// <summary>
        /// Performs dynamic code evaluation in given context.
        /// </summary>
        /// <returns>Evaluated code return value.</returns>
        public static PhpValue Eval(Context ctx, PhpArray locals, object @this, RuntimeTypeHandle self, string code, string currentpath, int line, int column)
        {
            Debug.Assert(ctx != null);
            Debug.Assert(locals != null);

            if (string.IsNullOrEmpty(code))
            {
                return PhpValue.Null;
            }

            var script = Core.Context.DefaultScriptingProvider.CreateScript(
                new Context.ScriptOptions()
                {
                    Context = ctx,
                    Location = new Location(Path.Combine(ctx.RootPath, currentpath), line, column),
                    EmitDebugInformation = Debugger.IsAttached,   // CONSIDER // DOC
                    IsSubmission = true,
                },
                code);

            //
            return script.Evaluate(ctx, locals, @this, self);
        }

        #endregion

        #region Paths

        /// <summary>
        /// Normalizes path's slashes for the current platform.
        /// </summary>
        public static string NormalizePath(string value) => Utilities.CurrentPlatform.NormalizeSlashes(value);

        #endregion

        #region BindTargetToMethod

        /// <summary>
        /// Helper lightweight class to reuse already bound <see cref="PhpInvokable"/> to be used as <see cref="PhpCallable"/>
        /// by calling it on a given target.
        /// </summary>
        sealed class BoundTargetCallable : IPhpCallable
        {
            readonly object _target;
            readonly PhpInvokable _invokable;

            public BoundTargetCallable(object target, PhpInvokable invokable)
            {
                _target = target;
                _invokable = invokable;
            }

            public PhpValue Invoke(Context ctx, params PhpValue[] arguments) => _invokable.Invoke(ctx, _target, arguments);

            public PhpValue ToPhpValue() => PhpValue.Null;
        }

        /// <summary>
        /// Creates an <see cref="IPhpCallable"/> from an instance method, binding the target to call the method on.
        /// </summary>
        public static IPhpCallable BindTargetToMethod(object targetInstance, RoutineInfo routine)
        {
            if (routine is PhpMethodInfo methodInfo)
            {
                return new BoundTargetCallable(targetInstance, methodInfo.PhpInvokable);
            }

            return PhpCallback.CreateInvalid();
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.Runtime\Operators.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.Runtime\Operators.cs(9,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.Runtime\Operators.cs(1752,37): error CS0136: A local or parameter named 'iterator' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Peachpie.Runtime\Operators.cs(9,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.Runtime\Operators.cs(8,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Pchp.Core;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using Pchp.Core.Reflection;

namespace Pchp.Library.Streams
{
    // TODO: move to Runtime

    #region TextElement

    /// <summary>
    /// Either <see cref="string"/> or <see cref="byte"/>[].
    /// </summary>
    [DebuggerDisplay("{DebugType,nq}: {DebugDisplay}")]
    public struct TextElement
    {
        readonly object _data;

        /// <summary>
        /// Gets debuggable display string.
        /// </summary>
        string DebugDisplay => (_data == null) ? string.Empty : (IsText ? GetText() : Encoding.UTF8.GetString(GetBytes()));
        string DebugType => (_data == null) ? "NULL" : (IsText ? "Unicode" : "Bytes");

        public bool IsNull => _data == null;

        public bool IsBinary => !IsText;

        public bool IsText => _data.GetType() == typeof(string);

        internal string GetText() => (string)_data;

        internal byte[] GetBytes() => (byte[])_data;

        public string AsText(Encoding enc) => IsNull ? string.Empty : IsText ? GetText() : enc.GetString(GetBytes());

        public byte[] AsBytes(Encoding enc) => IsNull ? Core.Utilities.ArrayUtils.EmptyBytes : IsBinary ? GetBytes() : enc.GetBytes(GetText());

        public override string ToString() => IsNull ? string.Empty : IsText ? GetText() : Encoding.UTF8.GetString(GetBytes());

        public PhpString ToPhpString() => IsNull ? default(PhpString) : IsText ? new PhpString(GetText()) : new PhpString(GetBytes());

        /// <summary>
        /// Gets length of the string or byytes array.
        /// </summary>
        public int Length => (_data != null) ? (IsText ? GetText().Length : GetBytes().Length) : 0;

        /// <summary>
        /// An empty byte array.
        /// </summary>
        public static TextElement Empty => new TextElement(Core.Utilities.ArrayUtils.EmptyBytes);

        /// <summary>
        /// Null element (Invalid).
        /// </summary>
        public static TextElement Null => default(TextElement);

        public TextElement(byte[] bytes)
        {
            Debug.Assert(bytes != null);
            _data = bytes;
            Debug.Assert(IsBinary);
        }

        public TextElement(string text)
        {
            Debug.Assert(text != null);
            _data = text;
            Debug.Assert(IsText);
        }

        public TextElement(PhpString str, Encoding encoding)
        {
            _data = str.ContainsBinaryData
                ? (object)str.ToBytes(encoding)
                : str.ToString(encoding);

            Debug.Assert(IsText ^ IsBinary);
        }

        public static TextElement FromValue(Context ctx, PhpValue value)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.Object:
                    if (value.Object is byte[])
                    {
                        return new TextElement((byte[])value.Object);
                    }
                    goto default;

                case PhpTypeCode.MutableString:
                    return new TextElement(value.MutableString, ctx.StringEncoding);

                default:
                    return new TextElement(value.ToStringOrThrow(ctx));
            }
        }
    }

    #endregion

    #region Basic Stream Filters

    /// <summary>
    /// Interface encapsulating the stream filtering functionality.
    /// </summary>
    public interface IFilter
    {
        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        TextElement Filter(IEncodingProvider enc, TextElement input, bool closing);

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        void OnCreate();

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        void OnClose();
    }

    /// <summary>
    /// Stream Filter used to convert \r\n to \n when reading a text file.
    /// </summary>
    public class TextReadFilter : IFilter
    {
        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        public TextElement Filter(IEncodingProvider enc, TextElement input, bool closing)
        {
            string str = input.AsText(enc.StringEncoding);

            if (pending)
            {
                // Both \r\n together make a pair which would consume a pending \r.
                if (str.Length == 0) str = "\r";
                else if (str[0] != '\n') str.Insert(0, "\r");
            }

            // Replace the pair.
            str = str.Replace("\r\n", "\n");
            if (str.Length != 0)
            {
                // Check for pending \r at the end.
                pending = str[str.Length - 1] == '\r';

                // Postpone the resolution of \r\n vs. \r to the next filtering if this is not the last one.
                if (!closing && pending) str.Remove(str.Length - 1, 1);
            }

            //
            return new TextElement(str);
        }

        bool pending = false;

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        public void OnCreate() { }

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        public void OnClose() { }
    }

    /// <summary>
    /// Stream Filter used to convert \n to \r\n when writing to a text file.
    /// </summary>
    public class TextWriteFilter : IFilter
    {
        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        public TextElement Filter(IEncodingProvider enc, TextElement input, bool closing)
        {
            return new TextElement(input.AsText(enc.StringEncoding).Replace("\n", "\r\n"));
        }

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        public void OnCreate() { }

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        public void OnClose() { }
    }

    #endregion

    #region Stream Filter Base Classes

    #region Filter options

    /// <summary>
    /// Indicates whether the filter is to be attached to the
    /// input/ouput filter-chain or both.
    /// </summary>
    [Flags]
    public enum FilterChainOptions
    {
        /// <summary>Insert the filter to the read filter chain of the stream (1).</summary>
        Read = 0x1,
        /// <summary>Insert the filter to the write filter chain of the stream (2).</summary>
        Write = 0x2,
        /// <summary>Insert the filter to both the filter chains of the stream (3).</summary>
        ReadWrite = Read | Write,
        /// <summary>Prepend the filter to the filter-chain (0x10).</summary>
        Head = 0x10,
        /// <summary>Append the filter to the filter-chain (0x20).</summary>
        Tail = 0x20
    }

    #endregion

    /// <summary>
    /// Implementor of this interface provides filter creation.
    /// </summary>
    public interface IFilterFactory
    {
        /// <summary>
        /// Returns the list of filters created by this <see cref="IFilterFactory"/>.
        /// </summary>
        /// <returns>The list of implemented filters.</returns>
        string[] GetImplementedFilterNames(Context ctx);

        /// <summary>
        /// Checks if a filter is being created by this factory and optionally returns a new instance of this filter.
        /// </summary>
        /// <param name="ctx">Runtime context.</param>
        /// <param name="name">The name of the filter (may contain wildcards).</param>
        /// <param name="instantiate"><c>true</c> to fill <paramref name="instance"/> with a new instance of that filter.</param>
        /// <param name="instance">Filled with a new instance of an implemented filter if <paramref name="instantiate"/>.</param>
        /// <param name="parameters">Additional parameters provided to the filter constructor.</param>
        /// <returns><c>true</c> if a filter with the given name was found.</returns>
        bool GetImplementedFilter(Context ctx, string name, bool instantiate, out PhpFilter instance, PhpValue parameters);
    }

    internal class UserFilterFactory : IFilterFactory
    {
        class UserFilters
        {
            /// <summary>
            /// List of {name, filter class}.
            /// The filter class is lazily resolved from <see cref="string"/> to <see cref="Pchp.Core.Reflection.PhpTypeInfo"/>.
            /// </summary>
            readonly List<KeyValuePair<string, object>> _filters = new List<KeyValuePair<string, object>>();

            public bool TryRegisterFilter(string filter, string classname)
            {
                for (int i = 0; i < _filters.Count; i++)
                {
                    if (_filters[i].Key.EqualsOrdinalIgnoreCase(filter))
                    {
                        return false;
                    }
                }

                _filters.Add(new KeyValuePair<string, object>(filter, classname));
                return true;
            }

            public bool GetImplementedFilter(Context ctx, string name, bool instantiate, out PhpFilter instance, PhpValue parameters)
            {
                instance = null;

                for (int i = 0; i < _filters.Count; i++)
                {
                    var pair = _filters[i];

                    // TODO: wildcard
                    if (pair.Key.EqualsOrdinalIgnoreCase(name))
                    {
                        if (instantiate)
                        {
                            var tinfo = pair.Value as PhpTypeInfo;
                            if (tinfo == null)
                            {
                                Debug.Assert(pair.Value is string);
                                tinfo = ctx.GetDeclaredTypeOrThrow((string)pair.Value, autoload: true);

                                if (tinfo != null) // always true
                                {
                                    _filters[i] = new KeyValuePair<string, object>(pair.Key, tinfo);
                                }
                                else
                                {
                                    throw null; // unreachable
                                }
                            }

                            instance = (php_user_filter)tinfo.Creator(ctx);
                        }

                        return true;
                    }
                }

                return false;
            }

            public string[] GetImplementedFilterNames()
            {
                if (_filters.Count == 0)
                {
                    return Array.Empty<string>();
                }

                //

                var arr = new string[_filters.Count];
                for (int i = 0; i < arr.Length; i++)
                {
                    arr[i] = _filters[i].Key;
                }

                return arr;
            }
        }

        public static bool TryRegisterFilter(Context ctx, string filter, string classname)
        {
            return ctx.GetStatic<UserFilters>().TryRegisterFilter(filter, classname);
        }

        public bool GetImplementedFilter(Context ctx, string name, bool instantiate, out PhpFilter instance, PhpValue parameters)
        {
            if (ctx.TryGetStatic<UserFilters>(out var filters))
            {
                return filters.GetImplementedFilter(ctx, name, instantiate, out instance, parameters);
            }

            instance = null;
            return false;
        }

        public string[] GetImplementedFilterNames(Context ctx)
        {
            if (ctx.TryGetStatic<UserFilters>(out var filters))
            {
                return filters.GetImplementedFilterNames();
            }
            else
            {
                return Array.Empty<string>();
            }
        }
    }

    /// <summary>
    /// Base class for PHP stream filters.
    /// </summary>
    public abstract class PhpFilter : IFilter
    {
        /// <summary>
        /// The filter name, same as the name used for creating the filter (see GetFilter).
        /// </summary>
        public string filtername { get; internal set; } = string.Empty;

        /// <summary>
        /// An additional <c>mixed</c> parameter passed at <c>stream_filter_append/prepend</c>.
        /// </summary>
        public PhpValue @params { get; internal set; } = string.Empty;

        #region IFilter Overrides

        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        public abstract TextElement Filter(IEncodingProvider enc, TextElement input, bool closing);

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        public void OnCreate() { }

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        public void OnClose() { }

        #endregion

        #region Stream Filter Chain Access

        /// <summary>
        /// Insert the filter into the filter chains.
        /// </summary>
        /// <param name="ctx">Runtime context.</param>
        /// <param name="stream">Which stream's filter chains.</param>
        /// <param name="filter">What filter.</param>
        /// <param name="where">What position in the chains.</param>
        /// <param name="parameters">Additional parameters for the filter.</param>
        /// <returns>Filters that have been added.</returns>
        internal static (PhpFilter readFilter, PhpFilter writeFilter) AddToStream(Context ctx, PhpStream stream, string filter, FilterChainOptions where, PhpValue parameters)
        {
            if ((stream.Options & StreamAccessOptions.Read) == 0) where &= ~FilterChainOptions.Read;
            if ((stream.Options & StreamAccessOptions.Write) == 0) where &= ~FilterChainOptions.Write;

            PhpFilter readFilter = null, writeFilter = null;

            if ((where & FilterChainOptions.Read) != 0)
            {
                if (GetFilter(ctx, filter, true, out readFilter, parameters))
                {
                    stream.AddFilter(readFilter, where);
                    readFilter.OnCreate();
                    // Add to chain, (filters buffers too).
                }
                else
                {
                    PhpException.Throw(PhpError.Warning, Core.Resources.ErrResources.invalid_filter_name, filter);
                    //return false;
                    throw new ArgumentException(nameof(filter));
                }
            }

            if ((where & FilterChainOptions.Write) != 0)
            {
                if (GetFilter(ctx, filter, true, out writeFilter, parameters))
                {
                    stream.AddFilter(writeFilter, where);
                    writeFilter.OnCreate();
                    // Add to chain.
                }
                else
                {
                    PhpException.Throw(PhpError.Warning, Core.Resources.ErrResources.invalid_filter_name, filter);
                    //return false;
                    throw new ArgumentException(nameof(filter));
                }
            }

            return (readFilter, writeFilter);
        }

        #endregion

        #region Implemented Filters

        /// <summary>
        /// Searches for a filter implementation in the known <see cref="PhpFilter"/> descendants.
        /// </summary>
        /// <param name="ctx">Runtime context.</param>
        /// <param name="filter">The name of the filter (may contain wildcards).</param>
        /// <param name="instantiate"><c>true</c> to fille <paramref name="instance"/> with a new instance of that filter.</param>
        /// <param name="instance">Filled with a new instance of an implemented filter if <paramref name="instantiate"/>.</param>
        /// <param name="parameters">Additional parameters for the filter.</param>
        /// <returns><c>true</c> if a filter with the given name was found.</returns>
        internal static bool GetFilter(Context ctx, string filter, bool instantiate, out PhpFilter instance, PhpValue parameters)
        {
            foreach (var factory in _filterFactories)
            {
                if (factory.GetImplementedFilter(ctx, filter, instantiate, out instance, parameters))
                {
                    if (instance != null)
                    {
                        instance.filtername = filter;
                        instance.@params = parameters.DeepCopy();
                    }

                    return true;
                }
            }

            instance = null;
            return false;
        }

        /// <summary>
        /// Register a built-in stream filter factory.
        /// </summary>
        /// <param name="factory">The filter factory. Must not be <c>null</c>.</param>
        [PhpHidden]
        public static void AddFilterFactory(IFilterFactory factory)
        {
            _filterFactories.Add(factory ?? throw new ArgumentNullException(nameof(factory)));
        }

        /// <summary>
        /// Retrieves the list of registered filters.
        /// </summary>
        /// <returns>A <see cref="PhpArray"/> containing the names of available filters.</returns>
        [PhpHidden]
        public static IEnumerable<string> GetFilterNames(Context ctx)
        {
            var set = new HashSet<string>();

            foreach (var factory in _filterFactories)
            {
                set.UnionWith(factory.GetImplementedFilterNames(ctx));
            }

            return set;
        }

        /// <summary>The list of filters factories.</summary>
		static readonly List<IFilterFactory> _filterFactories = new List<IFilterFactory>()  // NOTE: thread-safety not needed, the list is only being read
        {
            new UserFilterFactory(),
        };

        #endregion
    }

    /// <summary>
    /// User filter base class, the derived classes to be used by <see cref="PhpFilters.stream_filter_register"/>.
    /// </summary>
    [PhpType(PhpTypeAttribute.PhpTypeName.NameOnly), PhpExtension(PhpExtensionAttribute.KnownExtensionNames.Standard)]
    public class php_user_filter : PhpFilter
    {
        /// <summary>
        /// Called when applying the filter.
        /// </summary>
        public virtual long filter(PhpResource @in, PhpResource @out, PhpAlias consumed, bool closing) => 0;

        /// <summary>
        /// Called when creating the filter.
        /// </summary>
        public virtual bool onCreate() => true;

        /// <summary>
        /// Called when closing the filter.
        /// </summary>
        public virtual void onClose() { }

        #region PhpFilter

        [PhpHidden]
        public sealed override TextElement /*PhpFilter.*/Filter(IEncodingProvider enc, TextElement input, bool closing)
        {
            var @in = new UserFilterBucketBrigade() { bucket = input.ToPhpString() };
            var @out = new UserFilterBucketBrigade();
            var consumed = PhpAlias.Create(0L);

            switch ((PhpFilters.FilterStatus)filter(@in, @out, consumed, closing))
            {
                case PhpFilters.FilterStatus.OK:
                    return new TextElement(@out.bucket, enc.StringEncoding);

                case PhpFilters.FilterStatus.MoreData:
                    return TextElement.Empty;

                case PhpFilters.FilterStatus.FatalError:
                default:
                    // silently stop feeding this filter
                    return TextElement.Null;
            }
        }

        #endregion
    }

    public sealed class UserFilterBucketBrigade : PhpResource
    {
        public UserFilterBucketBrigade()
            : base("userfilter.bucket brigade")
        {
        }

        internal PhpString bucket;

        internal long consumed = 0;
    }

    /// <summary>
    /// Object created by <c>stream_bucket_make_writeable</c> and <c>stream_​bucket_​new</c>.
    /// </summary>
    public sealed class UserFilterBucket : stdClass
    {
        // PhpResource bucket{ get; set; }
        public PhpString data;
        public long datalen;
    }

    #endregion
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Pchp.Core;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using Pchp.Core.Reflection;

namespace Pchp.Library.Streams
{
    // TODO: move to Runtime

    #region TextElement

    /// <summary>
    /// Either <see cref="string"/> or <see cref="byte"/>[].
    /// </summary>
    [DebuggerDisplay("{DebugType,nq}: {DebugDisplay}")]
    public struct TextElement
    {
        readonly object _data;

        /// <summary>
        /// Gets debuggable display string.
        /// </summary>
        string DebugDisplay => (_data == null) ? string.Empty : (IsText ? GetText() : Encoding.UTF8.GetString(GetBytes()));
        string DebugType => (_data == null) ? "NULL" : (IsText ? "Unicode" : "Bytes");

        public bool IsNull => _data == null;

        public bool IsBinary => !IsText;

        public bool IsText => _data.GetType() == typeof(string);

        internal string GetText() => (string)_data;

        internal byte[] GetBytes() => (byte[])_data;

        public string AsText(Encoding enc) => IsNull ? string.Empty : IsText ? GetText() : enc.GetString(GetBytes());

        public byte[] AsBytes(Encoding enc) => IsNull ? Core.Utilities.ArrayUtils.EmptyBytes : IsBinary ? GetBytes() : enc.GetBytes(GetText());

        public override string ToString() => IsNull ? string.Empty : IsText ? GetText() : Encoding.UTF8.GetString(GetBytes());

        public PhpString ToPhpString() => IsNull ? default(PhpString) : IsText ? new PhpString(GetText()) : new PhpString(GetBytes());

        /// <summary>
        /// Gets length of the string or byytes array.
        /// </summary>
        public int Length => (_data != null) ? (IsText ? GetText().Length : GetBytes().Length) : 0;

        /// <summary>
        /// An empty byte array.
        /// </summary>
        public static TextElement Empty => new TextElement(Core.Utilities.ArrayUtils.EmptyBytes);

        /// <summary>
        /// Null element (Invalid).
        /// </summary>
        public static TextElement Null => default(TextElement);

        public TextElement(byte[] bytes)
        {
            Debug.Assert(bytes != null);
            _data = bytes;
            Debug.Assert(IsBinary);
        }

        public TextElement(string text)
        {
            Debug.Assert(text != null);
            _data = text;
            Debug.Assert(IsText);
        }

        public TextElement(PhpString str, Encoding encoding)
        {
            _data = str.ContainsBinaryData
                ? (object)str.ToBytes(encoding)
                : str.ToString(encoding);

            Debug.Assert(IsText ^ IsBinary);
        }

        public static TextElement FromValue(Context ctx, PhpValue value)
        {
            switch (value.TypeCode)
            {
                case PhpTypeCode.Object:
                    if (value.Object is byte[])
                    {
                        return new TextElement((byte[])value.Object);
                    }
                    goto default;

                case PhpTypeCode.MutableString:
                    return new TextElement(value.MutableString, ctx.StringEncoding);

                default:
                    return new TextElement(value.ToStringOrThrow(ctx));
            }
        }
    }

    #endregion

    #region Basic Stream Filters

    /// <summary>
    /// Interface encapsulating the stream filtering functionality.
    /// </summary>
    public interface IFilter
    {
        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        TextElement Filter(IEncodingProvider enc, TextElement input, bool closing);

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        void OnCreate();

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        void OnClose();
    }

    /// <summary>
    /// Stream Filter used to convert \r\n to \n when reading a text file.
    /// </summary>
    public class TextReadFilter : IFilter
    {
        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        public TextElement Filter(IEncodingProvider enc, TextElement input, bool closing)
        {
            string str = input.AsText(enc.StringEncoding);

            if (pending)
            {
                // Both \r\n together make a pair which would consume a pending \r.
                if (str.Length == 0) str = "\r";
                else if (str[0] != '\n') str.Insert(0, "\r");
            }

            // Replace the pair.
            str = str.Replace("\r\n", "\n");
            if (str.Length != 0)
            {
                // Check for pending \r at the end.
                pending = str[str.Length - 1] == '\r';

                // Postpone the resolution of \r\n vs. \r to the next filtering if this is not the last one.
                if (!closing && pending) str.Remove(str.Length - 1, 1);
            }

            //
            return new TextElement(str);
        }

        bool pending = false;

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        public void OnCreate() { }

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        public void OnClose() { }
    }

    /// <summary>
    /// Stream Filter used to convert \n to \r\n when writing to a text file.
    /// </summary>
    public class TextWriteFilter : IFilter
    {
        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        public TextElement Filter(IEncodingProvider enc, TextElement input, bool closing)
        {
            return new TextElement(input.AsText(enc.StringEncoding).Replace("\n", "\r\n"));
        }

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        public void OnCreate() { }

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        public void OnClose() { }
    }

    #endregion

    #region Stream Filter Base Classes

    #region Filter options

    /// <summary>
    /// Indicates whether the filter is to be attached to the
    /// input/ouput filter-chain or both.
    /// </summary>
    [Flags]
    public enum FilterChainOptions
    {
        /// <summary>Insert the filter to the read filter chain of the stream (1).</summary>
        Read = 0x1,
        /// <summary>Insert the filter to the write filter chain of the stream (2).</summary>
        Write = 0x2,
        /// <summary>Insert the filter to both the filter chains of the stream (3).</summary>
        ReadWrite = Read | Write,
        /// <summary>Prepend the filter to the filter-chain (0x10).</summary>
        Head = 0x10,
        /// <summary>Append the filter to the filter-chain (0x20).</summary>
        Tail = 0x20
    }

    #endregion

    /// <summary>
    /// Implementor of this interface provides filter creation.
    /// </summary>
    public interface IFilterFactory
    {
        /// <summary>
        /// Returns the list of filters created by this <see cref="IFilterFactory"/>.
        /// </summary>
        /// <returns>The list of implemented filters.</returns>
        string[] GetImplementedFilterNames(Context ctx);

        /// <summary>
        /// Checks if a filter is being created by this factory and optionally returns a new instance of this filter.
        /// </summary>
        /// <param name="ctx">Runtime context.</param>
        /// <param name="name">The name of the filter (may contain wildcards).</param>
        /// <param name="instantiate"><c>true</c> to fill <paramref name="instance"/> with a new instance of that filter.</param>
        /// <param name="instance">Filled with a new instance of an implemented filter if <paramref name="instantiate"/>.</param>
        /// <param name="parameters">Additional parameters provided to the filter constructor.</param>
        /// <returns><c>true</c> if a filter with the given name was found.</returns>
        bool GetImplementedFilter(Context ctx, string name, bool instantiate, out PhpFilter instance, PhpValue parameters);
    }

    internal class UserFilterFactory : IFilterFactory
    {
        class UserFilters
        {
            /// <summary>
            /// List of {name, filter class}.
            /// The filter class is lazily resolved from <see cref="string"/> to <see cref="Pchp.Core.Reflection.PhpTypeInfo"/>.
            /// </summary>
            readonly List<KeyValuePair<string, object>> _filters = new List<KeyValuePair<string, object>>();

            public bool TryRegisterFilter(string filter, string classname)
            {
                for (int i = 0; i < _filters.Count; i++)
                {
                    if (_filters[i].Key.EqualsOrdinalIgnoreCase(filter))
                    {
                        return false;
                    }
                }

                _filters.Add(new KeyValuePair<string, object>(filter, classname));
                return true;
            }

            public bool GetImplementedFilter(Context ctx, string name, bool instantiate, out PhpFilter instance, PhpValue parameters)
            {
                instance = null;

                for (int i = 0; i < _filters.Count; i++)
                {
                    var pair = _filters[i];

                    // TODO: wildcard
                    if (pair.Key.EqualsOrdinalIgnoreCase(name))
                    {
                        if (instantiate)
                        {
                            if (tinfo == null)
                            {
                                Debug.Assert(pair.Value is string);
                                tinfo = ctx.GetDeclaredTypeOrThrow((string)pair.Value, autoload: true);

                                if (pair.Value is PhpTypeInfo tinfo) // always true
                                {
                                    _filters[i] = new KeyValuePair<string, object>(pair.Key, tinfo);
                                }
                                else
                                {
                                    throw null; // unreachable
                                }
                            }

                            instance = (php_user_filter)tinfo.Creator(ctx);
                        }

                        return true;
                    }
                }

                return false;
            }

            public string[] GetImplementedFilterNames()
            {
                if (_filters.Count == 0)
                {
                    return Array.Empty<string>();
                }

                //

                var arr = new string[_filters.Count];
                for (int i = 0; i < arr.Length; i++)
                {
                    arr[i] = _filters[i].Key;
                }

                return arr;
            }
        }

        public static bool TryRegisterFilter(Context ctx, string filter, string classname)
        {
            return ctx.GetStatic<UserFilters>().TryRegisterFilter(filter, classname);
        }

        public bool GetImplementedFilter(Context ctx, string name, bool instantiate, out PhpFilter instance, PhpValue parameters)
        {
            if (ctx.TryGetStatic<UserFilters>(out var filters))
            {
                return filters.GetImplementedFilter(ctx, name, instantiate, out instance, parameters);
            }

            instance = null;
            return false;
        }

        public string[] GetImplementedFilterNames(Context ctx)
        {
            if (ctx.TryGetStatic<UserFilters>(out var filters))
            {
                return filters.GetImplementedFilterNames();
            }
            else
            {
                return Array.Empty<string>();
            }
        }
    }

    /// <summary>
    /// Base class for PHP stream filters.
    /// </summary>
    public abstract class PhpFilter : IFilter
    {
        /// <summary>
        /// The filter name, same as the name used for creating the filter (see GetFilter).
        /// </summary>
        public string filtername { get; internal set; } = string.Empty;

        /// <summary>
        /// An additional <c>mixed</c> parameter passed at <c>stream_filter_append/prepend</c>.
        /// </summary>
        public PhpValue @params { get; internal set; } = string.Empty;

        #region IFilter Overrides

        /// <summary>
        /// Processes the <paramref name="input"/> (either of type <see cref="string"/> or <see cref="byte"/>[]) 
        /// data and returns the filtered data in one of the formats above or <c>null</c>.
        /// </summary>
        public abstract TextElement Filter(IEncodingProvider enc, TextElement input, bool closing);

        /// <summary>
        /// Called when the filter is attached to a stream.
        /// </summary>
        public void OnCreate() { }

        /// <summary>
        /// Called when the containig stream is being closed.
        /// </summary>
        public void OnClose() { }

        #endregion

        #region Stream Filter Chain Access

        /// <summary>
        /// Insert the filter into the filter chains.
        /// </summary>
        /// <param name="ctx">Runtime context.</param>
        /// <param name="stream">Which stream's filter chains.</param>
        /// <param name="filter">What filter.</param>
        /// <param name="where">What position in the chains.</param>
        /// <param name="parameters">Additional parameters for the filter.</param>
        /// <returns>Filters that have been added.</returns>
        internal static (PhpFilter readFilter, PhpFilter writeFilter) AddToStream(Context ctx, PhpStream stream, string filter, FilterChainOptions where, PhpValue parameters)
        {
            if ((stream.Options & StreamAccessOptions.Read) == 0) where &= ~FilterChainOptions.Read;
            if ((stream.Options & StreamAccessOptions.Write) == 0) where &= ~FilterChainOptions.Write;

            PhpFilter readFilter = null, writeFilter = null;

            if ((where & FilterChainOptions.Read) != 0)
            {
                if (GetFilter(ctx, filter, true, out readFilter, parameters))
                {
                    stream.AddFilter(readFilter, where);
                    readFilter.OnCreate();
                    // Add to chain, (filters buffers too).
                }
                else
                {
                    PhpException.Throw(PhpError.Warning, Core.Resources.ErrResources.invalid_filter_name, filter);
                    //return false;
                    throw new ArgumentException(nameof(filter));
                }
            }

            if ((where & FilterChainOptions.Write) != 0)
            {
                if (GetFilter(ctx, filter, true, out writeFilter, parameters))
                {
                    stream.AddFilter(writeFilter, where);
                    writeFilter.OnCreate();
                    // Add to chain.
                }
                else
                {
                    PhpException.Throw(PhpError.Warning, Core.Resources.ErrResources.invalid_filter_name, filter);
                    //return false;
                    throw new ArgumentException(nameof(filter));
                }
            }

            return (readFilter, writeFilter);
        }

        #endregion

        #region Implemented Filters

        /// <summary>
        /// Searches for a filter implementation in the known <see cref="PhpFilter"/> descendants.
        /// </summary>
        /// <param name="ctx">Runtime context.</param>
        /// <param name="filter">The name of the filter (may contain wildcards).</param>
        /// <param name="instantiate"><c>true</c> to fille <paramref name="instance"/> with a new instance of that filter.</param>
        /// <param name="instance">Filled with a new instance of an implemented filter if <paramref name="instantiate"/>.</param>
        /// <param name="parameters">Additional parameters for the filter.</param>
        /// <returns><c>true</c> if a filter with the given name was found.</returns>
        internal static bool GetFilter(Context ctx, string filter, bool instantiate, out PhpFilter instance, PhpValue parameters)
        {
            foreach (var factory in _filterFactories)
            {
                if (factory.GetImplementedFilter(ctx, filter, instantiate, out instance, parameters))
                {
                    if (instance != null)
                    {
                        instance.filtername = filter;
                        instance.@params = parameters.DeepCopy();
                    }

                    return true;
                }
            }

            instance = null;
            return false;
        }

        /// <summary>
        /// Register a built-in stream filter factory.
        /// </summary>
        /// <param name="factory">The filter factory. Must not be <c>null</c>.</param>
        [PhpHidden]
        public static void AddFilterFactory(IFilterFactory factory)
        {
            _filterFactories.Add(factory ?? throw new ArgumentNullException(nameof(factory)));
        }

        /// <summary>
        /// Retrieves the list of registered filters.
        /// </summary>
        /// <returns>A <see cref="PhpArray"/> containing the names of available filters.</returns>
        [PhpHidden]
        public static IEnumerable<string> GetFilterNames(Context ctx)
        {
            var set = new HashSet<string>();

            foreach (var factory in _filterFactories)
            {
                set.UnionWith(factory.GetImplementedFilterNames(ctx));
            }

            return set;
        }

        /// <summary>The list of filters factories.</summary>
		static readonly List<IFilterFactory> _filterFactories = new List<IFilterFactory>()  // NOTE: thread-safety not needed, the list is only being read
        {
            new UserFilterFactory(),
        };

        #endregion
    }

    /// <summary>
    /// User filter base class, the derived classes to be used by <see cref="PhpFilters.stream_filter_register"/>.
    /// </summary>
    [PhpType(PhpTypeAttribute.PhpTypeName.NameOnly), PhpExtension(PhpExtensionAttribute.KnownExtensionNames.Standard)]
    public class php_user_filter : PhpFilter
    {
        /// <summary>
        /// Called when applying the filter.
        /// </summary>
        public virtual long filter(PhpResource @in, PhpResource @out, PhpAlias consumed, bool closing) => 0;

        /// <summary>
        /// Called when creating the filter.
        /// </summary>
        public virtual bool onCreate() => true;

        /// <summary>
        /// Called when closing the filter.
        /// </summary>
        public virtual void onClose() { }

        #region PhpFilter

        [PhpHidden]
        public sealed override TextElement /*PhpFilter.*/Filter(IEncodingProvider enc, TextElement input, bool closing)
        {
            var @in = new UserFilterBucketBrigade() { bucket = input.ToPhpString() };
            var @out = new UserFilterBucketBrigade();
            var consumed = PhpAlias.Create(0L);

            switch ((PhpFilters.FilterStatus)filter(@in, @out, consumed, closing))
            {
                case PhpFilters.FilterStatus.OK:
                    return new TextElement(@out.bucket, enc.StringEncoding);

                case PhpFilters.FilterStatus.MoreData:
                    return TextElement.Empty;

                case PhpFilters.FilterStatus.FatalError:
                default:
                    // silently stop feeding this filter
                    return TextElement.Null;
            }
        }

        #endregion
    }

    public sealed class UserFilterBucketBrigade : PhpResource
    {
        public UserFilterBucketBrigade()
            : base("userfilter.bucket brigade")
        {
        }

        internal PhpString bucket;

        internal long consumed = 0;
    }

    /// <summary>
    /// Object created by <c>stream_bucket_make_writeable</c> and <c>stream_​bucket_​new</c>.
    /// </summary>
    public sealed class UserFilterBucket : stdClass
    {
        // PhpResource bucket{ get; set; }
        public PhpString data;
        public long datalen;
    }

    #endregion
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(7,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(3,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(4,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(293,33): error CS0103: The name 'tinfo' does not exist in the current context,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(296,33): error CS0841: Cannot use local variable 'tinfo' before it is declared,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(308,57): error CS0103: The name 'tinfo' does not exist in the current context,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(7,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(4,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.Library\Streams\Filters.cs(3,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Devsense.PHP.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeGen;
using Microsoft.CodeAnalysis.Emit;
using Pchp.CodeAnalysis.Emit;
using Pchp.CodeAnalysis.Errors;
using Pchp.CodeAnalysis.FlowAnalysis;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using Pchp.CodeAnalysis.Symbols;
using Peachpie.CodeAnalysis.Errors;
using Peachpie.CodeAnalysis.Symbols;
using Peachpie.CodeAnalysis.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;

namespace Pchp.CodeAnalysis.CodeGen
{
    partial class CodeGenerator
    {
        /// <summary>
        /// Emits <c>context</c> onto the evaluation stack.
        /// </summary>
        public TypeSymbol EmitLoadContext()
        {
            if (_contextPlace == null)
                throw new InvalidOperationException("Context is not available.");

            return _contextPlace.EmitLoad(_il);
        }

        /// <summary>
        /// Gets <see cref="IPlace"/> of current <c>Context</c>.
        /// </summary>
        public IPlace ContextPlaceOpt => _contextPlace;

        /// <summary>
        /// Emits <c>RuntimeTypeHandle</c> of current class context.
        /// </summary>
        public TypeSymbol EmitCallerTypeHandle()
        {
            var caller = this.CallerType;
            if (caller != null)
            {
                // RuntimeTypeHandle
                EmitLoadToken(caller, null);
            }
            else
            {
                var place = RuntimeCallerTypePlace;
                if (place != null)
                {
                    place.EmitLoad(_il).Expect(CoreTypes.RuntimeTypeHandle);
                }
                else
                {
                    // default(RuntimeTypeHandle)
                    EmitLoadDefaultOfValueType(this.CoreTypes.RuntimeTypeHandle);
                }
            }

            //
            return CoreTypes.RuntimeTypeHandle;
        }

        /// <summary>
        /// In case current routine has a caller context provided in runtime,
        /// gets its <see cref="IPlace"/>.
        /// </summary>
        public IPlace RuntimeCallerTypePlace
        {
            get
            {
                if (_callerTypePlace == null)
                {
                    if (GeneratorStateMachineMethod != null)
                    {
                        if (this.Routine is SourceLambdaSymbol)
                        {
                            // Operator.GetGeneratorDynamicScope(g)
                            _callerTypePlace = new OperatorPlace(
                                CoreTypes.Operators.Method("GetGeneratorDynamicScope", CoreTypes.Generator),
                                new ParamPlace(GeneratorStateMachineMethod.GeneratorParameter));
                        }
                        // otherwise the caller type is resolve statically already
                    }
                    else if (this.Routine is SourceGlobalMethodSymbol global)
                    {
                        _callerTypePlace = new ParamPlace(global.SelfParameter);
                    }
                    else if (this.Routine is SourceLambdaSymbol lambda)
                    {
                        _callerTypePlace = lambda.GetCallerTypePlace();
                    }
                }

                return _callerTypePlace;
            }
            set
            {
                _callerTypePlace = value;
            }
        }

        /// <summary>
        /// Gets place referring to array of unoptimized local variables.
        /// Always valid in context of global scope.
        /// </summary>
        public IPlace LocalsPlaceOpt => _localsPlaceOpt;

        /// <summary>
        /// Gets place referring to compiler generated temporal variables.
        /// </summary>
        /// <remarks>
        /// Must not be null for methods that contain any synthesized variables.
        /// </remarks>
        public IPlace TemporalLocalsPlace => _tmpLocalsPlace;

        /// <summary>
        /// Gets value indicating the routine uses unoptimized locals access.
        /// This means, all the local variables are stored within an associative array instead of local slots.
        /// This value implicates, <see cref="LocalsPlaceOpt"/> is not <c>null</c>.
        /// </summary>
        public bool HasUnoptimizedLocals => LocalsPlaceOpt != null;

        /// <summary>
        /// Gets value indicating the routine has locals already inicialized. 
        /// </summary>
        public bool InitializedLocals => _localsInitialized;

        /// <summary>
        /// Emits reference to <c>this</c>.
        /// </summary>
        /// <returns>Type of <c>this</c> in current context, pushed on top of the evaluation stack.</returns>
        public TypeSymbol EmitThis()
        {
            Contract.ThrowIfNull(_thisPlace);
            return EmitThisOrNull();
        }

        public TypeSymbol EmitThisOrNull()
        {
            if (_thisPlace == null)
            {
                _il.EmitNullConstant();
                return CoreTypes.Object;
            }
            else
            {
                return _thisPlace.EmitLoad(_il);
            }
        }

        /// <summary>
        /// Emits value of <c>$this</c>.
        /// Available only within source routines.
        /// In case no $this is available, nothing is emitted and function returns <c>null</c> reference.
        /// </summary>
        TypeSymbol EmitPhpThis()
        {
            if (GeneratorStateMachineMethod != null)
            {
                return GeneratorStateMachineMethod.ThisParameter.EmitLoad(_il);
            }

            if (Routine != null)
            {
                if (Routine.IsGeneratorMethod())
                {
                    // but GeneratorStateMachineMethod == null; We're not emitting SM yet
                    Debug.Fail("$this not resolved");
                }

                //
                var thisplace = Routine.GetPhpThisVariablePlace(this.Module);
                if (thisplace != null)
                {
                    return thisplace.EmitLoad(_il);
                }
            }

            //
            return null;
        }

        /// <summary>
        /// Emits value of <c>$this</c>.
        /// Available only within source routines.
        /// In case no $this is available, <c>NULL</c> is loaded on stack instead.
        /// </summary>
        public TypeSymbol EmitPhpThisOrNull()
        {
            var t = EmitPhpThis();
            if (t == null)
            {
                _il.EmitNullConstant();
                t = CoreTypes.Object;
            }

            return t;
        }

        public TypeSymbol EmitGeneratorInstance()
        {
            Contract.ThrowIfNull(this.GeneratorStateMachineMethod);
            // .ldarg <generator>
            return this.GeneratorStateMachineMethod.GeneratorParameter.EmitLoad(_il);
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps most specific type from give variable without a runtime type check.
        /// </summary>
        internal TypeSymbol TryEmitVariableSpecialize(BoundExpression expr)
        {
            Debug.Assert(expr.Access.IsRead);

            if (!expr.Access.IsEnsure && !expr.TypeRefMask.IsAnyType && !expr.TypeRefMask.IsRef)
            {
                // avoiding of load of full value if not necessary
                return TryEmitVariableSpecialize(PlaceOrNull(expr), expr.TypeRefMask);
            }
            else
            {
                // we have to call expr.Emit() to generate ensureness correctly (Ensure Object, Ensure Array, Read Alias)
                return null;
            }
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps most specific type from give variable without a runtime type check.
        /// </summary>
        internal TypeSymbol TryEmitVariableSpecialize(IPlace place, TypeRefMask tmask)
        {
            if (place != null && tmask.IsSingleType && !tmask.IsRef)
            {
                //if (tmask.IsSingleType && TypeRefContext.IsNull(tmask))
                //{
                //    // NULL
                //    _il.EmitNullConstant();
                //    return;
                //}

                if (place.HasAddress)
                {
                    if (place.Type == CoreTypes.PhpNumber)
                    {
                        // access directly without type checking
                        if (IsDoubleOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpNumber.get_Double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (IsLongOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpNumber.get_Long)
                                .Expect(SpecialType.System_Int64);
                        }
                    }
                    else if (place.Type == CoreTypes.PhpValue)
                    {
                        // access directly without type checking
                        if (IsDoubleOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Double.Getter)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (IsLongOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Long.Getter)
                                .Expect(SpecialType.System_Int64);
                        }
                        else if (IsBooleanOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Boolean.Getter)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (IsReadonlyStringOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.String.Getter)
                                .Expect(SpecialType.System_String);
                        }
                        //else if (IsArrayOnly(tmask))
                        //{
                        //    place.EmitLoadAddress(_il);
                        //    return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.get_Array)    NOTE!! PhpValue.Array is PhpArray
                        //        .Expect(CoreTypes.IPhpArray);
                        //}
                        else if (IsClassOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Object.Getter)
                                .Expect(SpecialType.System_Object);

                            if (tmask.IsSingleType)
                            {
                                var tref = this.TypeRefContext.GetTypes(tmask).FirstOrDefault();
                                var clrtype = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);
                                if (clrtype.IsValidType() && !clrtype.IsObjectType())
                                {
                                    this.EmitCastClass(clrtype);
                                    return clrtype;
                                }
                            }

                            return this.CoreTypes.Object;
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps more specific type from a value currently on stack without a runtime type check.
        /// </summary>
        /// <returns>New type on top of evaluation stack.</returns>
        internal TypeSymbol EmitSpecialize(BoundExpression expr)
        {
            // load resulting value directly if resolved:
            if (expr.ConstantValue.HasValue && !expr.Access.IsEnsure)
            {
                if (expr.Access.IsNone)
                {
                    return expr.ResultType = CoreTypes.Void;
                }

                if (expr.Access.IsRead)
                {
                    return expr.ResultType = EmitLoadConstant(expr.ConstantValue.Value, expr.Access.TargetType);
                }
            }

            //
            if (expr.Access.IsNone) // no need for specializing, the value won't be read anyway
            {
                return (expr.ResultType = expr.Emit(this));
            }
            else
            {
                Debug.Assert(expr.Access.IsRead);

                return expr.ResultType = (TryEmitVariableSpecialize(expr) ?? EmitSpecialize(expr.Emit(this), expr.TypeRefMask));
            }
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps more specific type from a value currently on stack without a runtime type check.
        /// </summary>
        /// <param name="stack">Type of value currently on top of evaluationb stack.</param>
        /// <param name="tmask">Result of analysis what type will be there in runtime.</param>
        /// <returns>New type on top of evaluation stack.</returns>
        internal TypeSymbol EmitSpecialize(TypeSymbol stack, TypeRefMask tmask)
        {
            Debug.Assert(!stack.IsUnreachable);

            // specialize type if possible
            if (tmask.IsSingleType && !tmask.IsRef)
            {
                if (stack == this.CoreTypes.PhpNumber)
                {
                    if (IsDoubleOnly(tmask))
                    {
                        EmitPhpNumberAddr();
                        return EmitCall(ILOpCode.Call, this.CoreMethods.PhpNumber.get_Double)
                            .Expect(SpecialType.System_Double);
                    }
                    else if (IsLongOnly(tmask))
                    {
                        EmitPhpNumberAddr();
                        return EmitCall(ILOpCode.Call, this.CoreMethods.PhpNumber.get_Long)
                            .Expect(SpecialType.System_Int64);
                    }
                }
                else if (stack == CoreTypes.PhpValue)
                {
                    // access directly without type checking
                    if (IsDoubleOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Double.Getter)
                            .Expect(SpecialType.System_Double);
                    }
                    else if (IsLongOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Long.Getter)
                            .Expect(SpecialType.System_Int64);
                    }
                    else if (IsBooleanOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Boolean.Getter)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (IsReadonlyStringOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.String.Getter)
                            .Expect(SpecialType.System_String);
                    }
                }
                else if (stack.Is_PhpArray() || stack.IsStringType())
                {
                    // already specialied reference types
                }
                else if (stack.IsReferenceType && !stack.IsSealed && this.Routine != null)
                {
                    var tref = this.TypeRefContext.GetTypes(tmask).FirstOrDefault();
                    if (tref.IsObject)
                    {
                        // naive IL beutifier,
                        // that casts a reference type to its actual type that we determined in type analysis

                        var t = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);
                        if (t == stack)
                        {
                            return stack;
                        }

                        if (t.IsValidType())
                        {
                            if (stack.IsTypeParameter() || t.IsOfType(stack))
                            {
                                EmitCastClass(t);
                                return t;
                            }
                        }
                        else
                        {
                            // TODO: class aliasing
                            Debug.WriteLine($"'{tref}' is {(t is AmbiguousErrorTypeSymbol ? "ambiguous" : "unknown")}!");
                        }
                    }
                }
            }

            //
            return stack;
        }

        public void EmitOpCode(ILOpCode code) => _il.EmitOpCode(code);

        public void EmitPop(TypeSymbol type)
        {
            Contract.ThrowIfNull(type);

            if (type.SpecialType != SpecialType.System_Void)
            {
                _il.EmitOpCode(ILOpCode.Pop, -1);
            }
        }

        public TypeSymbol Emit(BoundExpression expr)
        {
            Contract.ThrowIfNull(expr);

            var t = EmitSpecialize(expr);
            if (t == null)
            {
                throw ExceptionUtilities.UnexpectedValue(null);
            }

            return t;
        }

        /// <summary>
        /// Loads <see cref="RuntimeTypeHandle"/> of given type.
        /// </summary>
        public TypeSymbol EmitLoadToken(TypeSymbol type, SyntaxNode syntaxNodeOpt)
        {
            if (type.IsValidType())
            {
                _il.EmitLoadToken(_moduleBuilder, _diagnostics, type, syntaxNodeOpt);
            }
            else
            {
                EmitLoadDefaultOfValueType(this.CoreTypes.RuntimeTypeHandle);
            }

            return this.CoreTypes.RuntimeTypeHandle;
        }

        /// <summary>
        /// Loads <see cref="RuntimeMethodHandle"/> of given method.
        /// </summary>
        public TypeSymbol EmitLoadToken(MethodSymbol method, SyntaxNode syntaxNodeOpt)
        {
            _il.EmitLoadToken(_moduleBuilder, _diagnostics, method, syntaxNodeOpt);

            return this.CoreTypes.RuntimeMethodHandle;
        }

        public void EmitBox(TypeSymbol valuetype)
        {
            Contract.ThrowIfNull(valuetype);

            if (valuetype.IsValueType)
            {
                _il.EmitOpCode(ILOpCode.Box);
                EmitSymbolToken(valuetype, null);
            }
        }

        /// <summary>
        /// Emits "!= 0" operation. This method expects I4 value on top of evaluation stack.
        /// </summary>
        public void EmitLogicNegation()
        {
            _il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
            _il.EmitOpCode(ILOpCode.Ceq);
        }

        /// <summary>
        /// Emits check if type on top of the stack is null.
        /// Results in boolean (<c>i4</c>) with value of <c>0</c> or <c>1</c> on top of the stack.
        /// </summary>
        public void EmitNotNull(TypeSymbol t, TypeRefMask tmask)
        {
            Debug.Assert(!t.IsUnreachable);
            // CanBeNull(tmask)
            // CanBeNull(t)

            // t != null
            if (t.IsReferenceType)
            {
                // != null
                _il.EmitNullConstant();
                _il.EmitOpCode(ILOpCode.Cgt_un);
                return;
            }

            // PhpAlias.Value
            if (t == CoreTypes.PhpAlias)
            {
                // dereference
                t = Emit_PhpAlias_GetValue();
                // continue ->
            }

            // IsSet(PhpValue) ~ !IsNull
            if (t == CoreTypes.PhpValue)
            {
                EmitCall(ILOpCode.Call, CoreMethods.Operators.IsSet_PhpValue);
                return;
            }

            // cannot be null:
            Debug.Assert(!CanBeNull(t));
            EmitPop(t);
            _il.EmitBoolConstant(false);
        }

        /// <summary>
        /// Loads field address on top of evaluation stack.
        /// </summary>
        public void EmitFieldAddress(FieldSymbol fld)
        {
            Debug.Assert(fld != null);

            _il.EmitOpCode(fld.IsStatic ? ILOpCode.Ldsflda : ILOpCode.Ldflda);
            EmitSymbolToken(fld, null);
        }

        internal void EmitSymbolToken(TypeSymbol symbol, SyntaxNode syntaxNode)
        {
            _il.EmitSymbolToken(_moduleBuilder, _diagnostics, symbol, syntaxNode);
        }

        internal void EmitSymbolToken(FieldSymbol symbol, SyntaxNode syntaxNode)
        {
            _il.EmitSymbolToken(_moduleBuilder, _diagnostics, symbol, syntaxNode);
        }

        internal void EmitSymbolToken(MethodSymbol method, SyntaxNode syntaxNode)
        {
            _il.EmitSymbolToken(_moduleBuilder, _diagnostics, method, syntaxNode);
        }

        /// <summary>
        /// Emits <c>typeof(symbol) : System.Type</c>.
        /// </summary>
        internal TypeSymbol EmitSystemType(TypeSymbol symbol)
        {
            // ldtoken !!T
            EmitLoadToken(symbol, null);

            // call class System.Type System.Type::GetTypeFromHandle(valuetype System.RuntimeTypeHandle)
            return EmitCall(ILOpCode.Call, (MethodSymbol)DeclaringCompilation.GetWellKnownTypeMember(WellKnownMember.System_Type__GetTypeFromHandle));
        }

        internal void EmitHiddenSequencePoint()
        {
            if (EmitPdbSequencePoints)
            {
                _il.DefineHiddenSequencePoint();
            }
        }

        internal void EmitSequencePoint(LangElement element)
        {
            if (element != null)
            {
                EmitSequencePoint(element.Span);
            }
        }
        internal void EmitSequencePoint(Span span)
        {
            if (EmitPdbSequencePoints && span.IsValid && !span.IsEmpty)
            {
                EmitSequencePoint(span.ToTextSpan());
            }
        }

        internal void EmitSequencePoint(Microsoft.CodeAnalysis.Text.TextSpan span)
        {
            if (EmitPdbSequencePoints && span.Length > 0)
            {
                _il.DefineSequencePoint(ContainingFile.SyntaxTree, span);
                _il.EmitOpCode(ILOpCode.Nop);
            }
        }

        public TypeSymbol EmitDereference(TypeSymbol t)
        {
            if (t == CoreTypes.PhpAlias)
            {
                // Template: <alias>.Value
                return this.Emit_PhpAlias_GetValue();
            }
            else if (t == CoreTypes.PhpValue)
            {
                // Template: <value>.GetValue()
                this.EmitPhpValueAddr();
                return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.GetValue);
            }
            else
            {
                // value already dereferenced
                return t;
            }
        }

        /// <summary>
        /// GetPhpTypeInfo&lt;T&gt;() : PhpTypeInfo
        /// </summary>
        public TypeSymbol EmitLoadPhpTypeInfo(ITypeSymbol t)
        {
            Contract.ThrowIfNull(t);

            // CALL GetPhpTypeInfo<T>()
            return EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_T.Symbol.Construct(t));
        }

        /// <summary>
        /// Emits <c>PhpTypeInfo</c> of late static bound type.
        /// </summary>
        /// <returns>
        /// Type symbol of <c>PhpTypeInfo</c>.
        /// </returns>
        public TypeSymbol EmitLoadStaticPhpTypeInfo()
        {
            if (Routine != null)
            {
                if (GeneratorStateMachineMethod != null)
                {
                    this.EmitGeneratorInstance(); // LOAD Generator
                    return this.EmitCall(ILOpCode.Call, CoreMethods.Operators.GetGeneratorLazyStatic_Generator)
                        .Expect(CoreTypes.PhpTypeInfo);
                }

                if (Routine is SourceLambdaSymbol lambda)
                {
                    // Handle lambda since $this can be null (unbound)
                    // Template: CLOSURE.Static();
                    lambda.ClosureParameter.EmitLoad(Builder);
                    return EmitCall(ILOpCode.Call, CoreMethods.Operators.Static_Closure)
                        .Expect(CoreTypes.PhpTypeInfo);
                }

                var thisVariablePlace = Routine.GetPhpThisVariablePlace(Module);
                if (thisVariablePlace != null)
                {
                    // Template: GetPhpTypeInfo(this)
                    thisVariablePlace.EmitLoad(Builder);
                    return EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_Object);
                }

                var lateStaticParameter = Routine.LateStaticParameter();
                if (lateStaticParameter != null)
                {
                    // Template: LOAD @static   // ~ @static parameter passed by caller
                    return lateStaticParameter
                        .EmitLoad(Builder)
                        .Expect(CoreTypes.PhpTypeInfo);
                }

                var caller = CallerType;
                if (caller is SourceTypeSymbol srct && srct.IsSealed)
                {
                    // `static` == `self` <=> self is sealed
                    // Template: GetPhpTypeInfo<CallerType>()
                    return EmitLoadPhpTypeInfo(caller);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Loads <c>PhpTypeInfo</c> of <c>self</c>.
        /// </summary>
        /// <param name="throwOnError">Whether to expect only valid scope.</param>
        /// <returns>Type symbol of PhpTypeInfo.</returns>
        public TypeSymbol EmitLoadSelf(bool throwOnError = false)
        {
            var caller = CallerType;
            if (caller != null)
            {
                // current scope is resolved in compile-time:
                // Template: GetPhpTypeInfo<CallerType>()
                return EmitLoadPhpTypeInfo(caller);
            }
            else
            {
                // Template: Operators.GetSelf( {caller type handle} )
                EmitCallerTypeHandle();
                return EmitCall(ILOpCode.Call, throwOnError
                    ? CoreMethods.Operators.GetSelf_RuntimeTypeHandle
                    : CoreMethods.Operators.GetSelfOrNull_RuntimeTypeHandle);
            }
        }

        /// <summary>
        /// Loads <c>PhpTypeInfo</c> of current scope's <c>parent</c> class;
        /// </summary>
        /// <returns>
        /// Type symbol of <c>PhpTypeInfo</c>.
        /// </returns>
        public TypeSymbol EmitLoadParent()
        {
            var caller = CallerType;
            if (caller != null)
            {
                // current scope is resolved in compile-time:
                // Template: Operators.GetParent( GetPhpTypeInfo<CallerType>() )
                EmitLoadPhpTypeInfo(caller);
                return EmitCall(ILOpCode.Call, CoreMethods.Operators.GetParent_PhpTypeInfo);
            }
            else
            {
                // Template: Operators.GetParent( {caller type handle} )
                EmitCallerTypeHandle();
                return EmitCall(ILOpCode.Call, CoreMethods.Operators.GetParent_RuntimeTypeHandle);
            }
        }

        /// <summary>
        /// Emits load of <c>PhpAlias.Value</c>,
        /// expecting <c>PhpAlias</c> on top of evaluation stack,
        /// pushing <c>PhpValue</c> on top of the stack.
        /// </summary>
        public TypeSymbol Emit_PhpAlias_GetValue()
        {
            // CALL <stack>.get_Value()
            return EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.Value.Getter);
        }

        /// <summary>
        /// Emits store to <c>PhpAlias.Value</c>,
        /// expecting <c>PhpAlias</c> and <c>PhpValue</c> on top of evaluation stack.
        /// </summary>
        public void Emit_PhpAlias_SetValue()
        {
            // <stack_1>.Value = <stack_2>
            EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.Value.Setter);
        }

        /// <summary>
        /// Emits <c>new PhpAlias</c>, expecting <c>PhpValue</c> on top of the evaluation stack.
        /// </summary>
        public TypeSymbol Emit_PhpValue_MakeAlias()
        {
            //// new PhpAlias(<STACK>, 1)
            //_il.EmitIntConstant(1);
            //return EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpAlias_PhpValue_int);

            // PhpAlias.Create( <STACK> )
            return EmitCall(ILOpCode.Call, CoreMethods.PhpAlias.Create_PhpValue);
        }

        /// <summary>
        /// Emits load of PhpValue representing void.
        /// </summary>
        public TypeSymbol Emit_PhpValue_Void() => Emit_PhpValue_Null();

        /// <summary>
        /// Emits load of PhpValue representing null.
        /// </summary>
        public TypeSymbol Emit_PhpValue_Null()
        {
            _il.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpValue.Null, null);
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Emits load of PhpValue representing true.
        /// </summary>
        public TypeSymbol Emit_PhpValue_True()
        {
            _il.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpValue.True, null);
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Emits load of PhpValue representing false.
        /// </summary>
        public TypeSymbol Emit_PhpValue_False()
        {
            _il.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpValue.False, null);
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Creates new empty <c>PhpArray</c> where modifications are not expected.
        /// </summary>
        public TypeSymbol Emit_PhpArray_NewEmpty()
        {
            // PhpArray.NewEmpty()
            var t = CoreTypes.PhpArray.Symbol;
            return EmitCall(ILOpCode.Call, (MethodSymbol)t.GetMembers("NewEmpty").Single());
        }

        /// <summary>
        /// Emits LOAD of <c>PhpArray.Empty</c> fields.
        /// The loaded value must not be modified, use only in read-only context.
        /// </summary>
        public TypeSymbol Emit_PhpArray_Empty()
        {
            // PhpArray.Empty
            Builder.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpArray.Empty, null);

            return CoreMethods.PhpArray.Empty.Symbol.Type
                .Expect(CoreTypes.PhpArray);
        }

        public void Emit_NewArray(TypeSymbol elementType, ImmutableArray<BoundArgument> values) => Emit_NewArray(elementType, values, a => Emit(a.Value));
        public void Emit_NewArray(TypeSymbol elementType, ImmutableArray<BoundExpression> values) => Emit_NewArray(elementType, values, a => Emit(a));

        public TypeSymbol Emit_NewArray<T>(TypeSymbol elementType, ImmutableArray<T> values, Func<T, TypeSymbol> emitter)
        {
            if (values.IsDefaultOrEmpty == false)
            {
                // new []
                _il.EmitIntConstant(values.Length);
                _il.EmitOpCode(ILOpCode.Newarr);
                EmitSymbolToken(elementType, null);

                // { argI, ..., argN }
                for (int i = 0; i < values.Length; i++)
                {
                    _il.EmitOpCode(ILOpCode.Dup);   // <array>
                    _il.EmitIntConstant(i);         // [i]
                    EmitConvert(emitter(values[i]), 0, elementType);
                    _il.EmitOpCode(ILOpCode.Stelem);
                    EmitSymbolToken(elementType, null);
                }

                // T[]
                return ArrayTypeSymbol.CreateSZArray(this.DeclaringCompilation.SourceAssembly, elementType);
            }
            else
            {
                // empty array
                return Emit_EmptyArray(elementType);
            }
        }

        /// <summary>Template: <code>Array.Empty&lt;elementType&gt;()</code></summary>
        /// <param name="elementType"></param>
        /// <returns></returns>
        internal TypeSymbol Emit_EmptyArray(TypeSymbol elementType)
        {
            // Array.Empty<elementType>()
            var array_empty_T = ((MethodSymbol)this.DeclaringCompilation.GetWellKnownTypeMember(WellKnownMember.System_Array__Empty))
                .Construct(elementType);

            return EmitCall(ILOpCode.Call, array_empty_T);
        }

        /// <summary>
        /// Emits array of <paramref name="elementType"/> containing all current routine PHP arguments value.
        /// </summary>
        internal TypeSymbol Emit_ArgsArray(TypeSymbol elementType)
        {
            var routine = this.Routine ?? throw this.NotImplementedException(nameof(Routine));

            if (routine.IsGlobalScope)
            {
                // NOTE: this produces warning: Called from the global scope - no function context
                _il.EmitNullConstant();
                return ArrayTypeSymbol.CreateSZArray(DeclaringCompilation.SourceAssembly, CoreTypes.PhpValue);
            }

            if (routine.IsGeneratorMethod())
            {
                Debug.Assert(LocalsPlaceOpt != null);
                Debug.Assert(LocalsPlaceOpt.Type == CoreTypes.PhpArray);

                // TODO: this is not correct for varargs
                // <locals> does not contain all the parameters,
                // also it contains all the default values which should not be in listed here
                Debug.Fail("varargs in Generator has an incorrect behavior");

                // args = <locals>.GetValues();
                LocalsPlaceOpt.EmitLoad(_il);
                return EmitCall(ILOpCode.Call, CoreTypes.PhpHashtable.Method("GetValues"));
            }

            TypeSymbol arrtype;

            // [implicit] [use parameters, source parameters] [... varargs]

            var variadic = routine.GetParamsParameter();  // optional params
            var variadic_element = (variadic?.Type as ArrayTypeSymbol)?.ElementType;
            var variadic_place = variadic != null ? new ParamPlace(variadic) : null;

            // get used source parameters:
            var ps = routine.SourceParameters
                .Skip(routine is SourceLambdaSymbol lambda ? lambda.UseParams.Count : 0)    // without lambda use parameters
                .TakeWhile(x => variadic != null ? x.Ordinal < variadic.Ordinal : true)     // up to the params parameter (handled separately)
                .ToArray();

            if (ps.Length == 0 && variadic == null)
            {
                // empty array
                return Emit_EmptyArray(elementType);
            }
            else if (ps.Length == 0 && variadic_element == elementType)
            {
                // == params
                arrtype = variadic_place.EmitLoad(_il);
            }
            else
            {
                arrtype = ArrayTypeSymbol.CreateSZArray(this.DeclaringCompilation.SourceAssembly, elementType);

                // COUNT: (N + params.Length)
                _il.EmitIntConstant(ps.Length);

                if (variadic_place != null)
                {
                    // + params.Length
                    variadic_place.EmitLoad(_il);
                    EmitArrayLength();
                    _il.EmitOpCode(ILOpCode.Add);
                }

                // new [<COUNT>]
                _il.EmitOpCode(ILOpCode.Newarr);
                EmitSymbolToken(elementType, null);

                // tmparr = <array>
                var tmparr = this.GetTemporaryLocal(arrtype);
                _il.EmitLocalStore(tmparr);

                // { p1, .., pN }
                for (int i = 0; i < ps.Length; i++)
                {
                    _il.EmitLocalLoad(tmparr);      // <array>
                    _il.EmitIntConstant(i);         // [i]
                    EmitConvert(ps[i].EmitLoad(_il), 0, elementType);
                    _il.EmitOpCode(ILOpCode.Stelem);
                    EmitSymbolToken(elementType, null);
                }

                if (variadic != null)
                {
                    // { params[0, .., paramsN] }

                    // Template: for (i = 0; i < params.Length; i++) <array>[i + N] = params[i]

                    var lbl_block = new object();
                    var lbl_cond = new object();

                    // i = 0
                    var tmpi = GetTemporaryLocal(CoreTypes.Int32);
                    _il.EmitIntConstant(0);
                    _il.EmitLocalStore(tmpi);
                    _il.EmitBranch(ILOpCode.Br, lbl_cond);

                    // {body}
                    _il.MarkLabel(lbl_block);

                    // <array>[i+N] = (T)params[i]
                    _il.EmitLocalLoad(tmparr);   // <array>
                    _il.EmitIntConstant(ps.Length);
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitOpCode(ILOpCode.Add);

                    variadic_place.EmitLoad(_il);
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitOpCode(ILOpCode.Ldelem);
                    EmitSymbolToken(variadic_element, null);
                    EmitConvert(variadic_element, 0, elementType);

                    _il.EmitOpCode(ILOpCode.Stelem);
                    EmitSymbolToken(elementType, null);

                    // i++
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitIntConstant(1);
                    _il.EmitOpCode(ILOpCode.Add);
                    _il.EmitLocalStore(tmpi);

                    // i < params.Length
                    _il.MarkLabel(lbl_cond);
                    _il.EmitLocalLoad(tmpi);
                    variadic_place.EmitLoad(_il);
                    EmitArrayLength();
                    _il.EmitOpCode(ILOpCode.Clt);
                    _il.EmitBranch(ILOpCode.Brtrue, lbl_block);

                    //
                    ReturnTemporaryLocal(tmpi);
                }

                // <array>
                _il.EmitLocalLoad(tmparr);   // <array>

                //
                ReturnTemporaryLocal(tmparr);
                tmparr = null;
            }

            //
            return arrtype;
        }

        /// <summary>
        /// Emits <c>PhpValue[]</c> containing given <paramref name="args"/>.
        /// Argument unpacking is taken into account and flatterned.
        /// </summary>
        internal void Emit_ArgumentsIntoArray(ImmutableArray<BoundArgument> args, PhpSignatureMask byrefargs)
        {
            if (args.Length == 0)
            {
                Emit_EmptyArray(CoreTypes.PhpValue);
            }
            else if (args.Last().IsUnpacking)   // => handle unpacking   // last argument must be unpacking otherwise unpacking is not allowed anywhere else
            {
                UnpackArgumentsIntoArray(args, byrefargs);
            }
            else
            {
                Emit_NewArray(CoreTypes.PhpValue, args);
            }
        }

        /// <summary>
        /// Emits <c>PhpValue[]</c> containing given <paramref name="args"/>.
        /// Argument unpacking is taken into account and flatterned.
        /// </summary>
        /// <param name="args">Arguments to be flatterned into a single dimensional array.</param>
        /// <param name="byrefargs">Mask of arguments that must be passed by reference.</param>
        /// <remarks>The method assumes the arguments list contains a variable unpacking. Otherwise this method is not well performance optimized.</remarks>
        /// <returns>Type symbol corresponding to <c>PhpValue[]</c></returns>
        internal TypeSymbol UnpackArgumentsIntoArray(ImmutableArray<BoundArgument> args, PhpSignatureMask byrefargs)
        {
            if (args.IsDefaultOrEmpty)
            {
                // Array.Empty<PhpValue>()
                return Emit_EmptyArray(this.CoreTypes.PhpValue);
            }

            // assuming the arguments list contains a variable unpacking,
            // otherwise we could do this much more efficiently
            Debug.Assert(args.Any(a => a.IsUnpacking));

            // TODO: args.Length == 1 => unpack directly to an array // Template: Unpack(args[0]) => args[0].CopyTo(new PhpValue[args[0].Count])

            // Symbol: List<PhpValue>
            var list_phpvalue = DeclaringCompilation.GetWellKnownType(WellKnownType.System_Collections_Generic_List_T).Construct(CoreTypes.PhpValue);
            var list_ctor_int = list_phpvalue.InstanceConstructors.Single(m => m.ParameterCount == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Int32);
            var list_add_PhpValue = list_phpvalue.GetMembers(WellKnownMemberNames.CollectionInitializerAddMethodName).OfType<MethodSymbol>().SingleOrDefault(m => m.ParameterCount == 1 && !m.IsStatic);
            var list_toarray = (MethodSymbol)list_phpvalue.GetMembers("ToArray").Single();

            // Symbol: Operators.Unpack
            var unpack_methods = CoreTypes.Operators.Symbol.GetMembers("Unpack").OfType<MethodSymbol>();
            var unpack_list_value_ulong = unpack_methods.Single(m => m.Parameters[1].Type == CoreTypes.PhpValue);
            var unpack_list_array_ulong = unpack_methods.Single(m => m.Parameters[1].Type == CoreTypes.PhpArray);

            // 1. create temporary List<PhpValue>

            // Template: new List<PhpValue>(COUNT)
            _il.EmitIntConstant(args.Length + 8);   // estimate unpackged arguments count
            EmitCall(ILOpCode.Newobj, list_ctor_int)
                .Expect(list_phpvalue);

            // 2. evaluate arguments and unpack them to the List<PhpValue> (on <STACK>)
            for (int i = 0; i < args.Length; i++)
            {
                _il.EmitOpCode(ILOpCode.Dup);   // .dup <STACK>

                if (args[i].IsUnpacking)
                {
                    // Template: Unpack(<STACK>, args[i], byrefs)
                    var t = Emit(args[i].Value);
                    if (t == CoreTypes.PhpArray)
                    {
                        _il.EmitLongConstant((long)(ulong)byrefargs);    // byref args
                        EmitCall(ILOpCode.Call, unpack_list_array_ulong)
                            .Expect(SpecialType.System_Void);
                    }
                    else
                    {
                        EmitConvert(t, args[i].Value.TypeRefMask, CoreTypes.PhpValue);
                        _il.EmitLongConstant((long)(ulong)byrefargs);    // byref args
                        EmitCall(ILOpCode.Call, unpack_list_value_ulong)
                            .Expect(SpecialType.System_Void);
                    }
                }
                else
                {
                    // Template: <STACK>.Add((PhpValue)args[i])
                    EmitConvert(args[i].Value, CoreTypes.PhpValue);
                    EmitCall(ILOpCode.Call, list_add_PhpValue)
                        .Expect(SpecialType.System_Void);
                }
            }

            // 3. copy the list into PhpValue[]
            // Template: List<PhpValue>.ToArray()
            return EmitCall(ILOpCode.Call, list_toarray);
        }

        /// <summary>
        /// Builds <c>PhpArray</c> out from <c>System.Array</c>.
        /// </summary>
        public TypeSymbol ArrayToPhpArray(IPlace arrplace, bool deepcopy = false, int startindex = 0)
        {
            var phparr = GetTemporaryLocal(CoreTypes.PhpArray);

            // Template: tmparr = new PhpArray(arrplace.Length)
            arrplace.EmitLoad(_il);
            EmitArrayLength();  // array size hint
            EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpArray_int);
            _il.EmitLocalStore(phparr);

            // enumeration body:
            EmitEnumerateArray(arrplace, startindex, (srcindex, element_loader) =>
            {
                // Template: <tmparr>.Add((T)arrplace[i])
                _il.EmitLocalLoad(phparr);   // <array>
                var t = element_loader();   // arrplace[i]
                t = (deepcopy) ? EmitDeepCopy(t, true) : t;
                EmitConvert(t, 0, CoreTypes.PhpValue);    // (PhpValue)arrplace[i]
                EmitPop(EmitCall(ILOpCode.Call, CoreMethods.PhpArray.Add_PhpValue));    // <array>.Add( value )
            });

            _il.EmitLocalLoad(phparr);

            ReturnTemporaryLocal(phparr);

            //
            return (TypeSymbol)phparr.Type;
        }

        /// <summary>
        /// Creates array from source array.
        /// </summary>
        /// <param name="srcarray">Source array.</param>
        /// <param name="srcfrom">First element to be copied.</param>
        /// <param name="targetArrElement">Target array element type.</param>
        /// <returns>Type of target array which is left on top of stack.</returns>
        public TypeSymbol ArrayToNewArray(IPlace srcarray, int srcfrom, TypeSymbol targetArrElement)
        {
            // Template: <tmplength> = srcarray.Length - srcfrom
            srcarray.EmitLoad(_il);
            EmitArrayLength();
            _il.EmitIntConstant(srcfrom);
            _il.EmitOpCode(ILOpCode.Sub);
            var tmplength = GetTemporaryLocal(CoreTypes.Int32);
            _il.EmitLocalStore(tmplength);

            // Template: if (tmplength > 0) ... else { Array.Empty<T>(); }

            var lblempty = new object();
            var lblend = new object();

            _il.EmitLocalLoad(tmplength);
            _il.EmitIntConstant(0);
            _il.EmitBranch(ILOpCode.Ble, lblempty); // length <= 0 : goto lblempty;

            // <tmparr> = new T[tmplength]
            _il.EmitLocalLoad(tmplength);
            _il.EmitOpCode(ILOpCode.Newarr);
            EmitSymbolToken(targetArrElement, null);
            var tmparr = GetTemporaryLocal(ArrayTypeSymbol.CreateSZArray(this.DeclaringCompilation.SourceAssembly, targetArrElement));
            _il.EmitLocalStore(tmparr);

            ReturnTemporaryLocal(tmplength);

            // enumerator body:
            EmitEnumerateArray(srcarray, srcfrom, (srcindex, element_loader) =>
            {
                // Template: tmparr[srcindex - srcfrom] = (T)element_loader();
                _il.EmitLocalLoad(tmparr);

                _il.EmitLocalLoad(srcindex);    // srcindex
                _il.EmitIntConstant(srcfrom);   // srcfrom
                _il.EmitOpCode(ILOpCode.Sub);   // -

                EmitConvert(element_loader(), 0, targetArrElement);  // (T) LOAD source element

                _il.EmitOpCode(ILOpCode.Stelem);    // STORE
                EmitSymbolToken(targetArrElement, null);
            });

            _il.EmitLocalLoad(tmparr);  // LOAD tmparr
            _il.EmitBranch(ILOpCode.Br, lblend);    // goto end;

            // lblempty:
            _il.MarkLabel(lblempty);
            Emit_EmptyArray(targetArrElement);

            // lblend:
            _il.MarkLabel(lblend);

            //
            ReturnTemporaryLocal(tmparr);
            return (TypeSymbol)tmparr.Type;
        }

        /// <summary>
        /// Emits for-loop of elements in given array provided through <paramref name="arrplace"/>.
        /// </summary>
        /// <param name="arrplace">Place representing source array.</param>
        /// <param name="startindex">First element index to enumerato from.</param>
        /// <param name="bodyemit">Action used to emit the body of the enumeration.
        /// Gets source element index and delegate that emits the LOAD of source element.</param>
        public void EmitEnumerateArray(IPlace arrplace, int startindex, Action<LocalDefinition, Func<TypeSymbol>> bodyemit)
        {
            if (arrplace == null) throw new ArgumentNullException(nameof(arrplace));

            Debug.Assert(arrplace.Type.IsSZArray());

            var arr_element = ((ArrayTypeSymbol)arrplace.Type).ElementType;

            // Template: for (i = 0; i < params.Length; i++) <phparr>.Add(arrplace[i])

            var lbl_block = new object();
            var lbl_cond = new object();

            // i = <startindex>
            var tmpi = GetTemporaryLocal(CoreTypes.Int32);
            _il.EmitIntConstant(startindex);
            _il.EmitLocalStore(tmpi);
            _il.EmitBranch(ILOpCode.Br, lbl_cond);

            // {body}
            _il.MarkLabel(lbl_block);

            bodyemit(tmpi, () =>
                {
                    // LOAD arrplace[i]
                    arrplace.EmitLoad(_il);
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitOpCode(ILOpCode.Ldelem);
                    EmitSymbolToken(arr_element, null);
                    return arr_element;
                });

            // i++
            _il.EmitLocalLoad(tmpi);
            _il.EmitIntConstant(1);
            _il.EmitOpCode(ILOpCode.Add);
            _il.EmitLocalStore(tmpi);

            // i < params.Length
            _il.MarkLabel(lbl_cond);
            _il.EmitLocalLoad(tmpi);
            arrplace.EmitLoad(_il);
            EmitArrayLength();
            _il.EmitOpCode(ILOpCode.Clt);
            _il.EmitBranch(ILOpCode.Brtrue, lbl_block);

            //
            ReturnTemporaryLocal(tmpi);
        }

        /// <summary>
        /// Emits <c>Array.Length</c> call expecting an array instance on top of the stack, returning <c>int</c>.
        /// </summary>
        internal void EmitArrayLength()
        {
            EmitOpCode(ILOpCode.Ldlen);
            EmitOpCode(ILOpCode.Conv_i4);
        }

        /// <summary>
        /// Emits call to given method.
        /// </summary>
        /// <param name="code">Call op code, Call, Callvirt, Calli.</param>
        /// <param name="method">Method reference.</param>
        /// <returns>Method return type.</returns>
        internal TypeSymbol EmitCall(ILOpCode code, MethodSymbol method)
        {
            return _il.EmitCall(_moduleBuilder, _diagnostics, code, method);
        }

        /// <summary>
        /// Emits <paramref name="thisExpr"/> to be used as target instance of method call, field or property.
        /// </summary>
        internal TypeSymbol LoadTargetInstance(BoundExpression thisExpr, MethodSymbol method)
        {
            NamedTypeSymbol targetType = method.HasThis ? method.ContainingType : CoreTypes.Void;

            if (thisExpr != null)
            {
                if (targetType.SpecialType != SpecialType.System_Void)
                {
                    //var lhs = default(LhsStack);
                    //lhs = VariableReferenceExtensions.EmitReceiver(this, ref lhs, method, thisExpr);

                    var receiverPlace = PlaceOrNull(thisExpr);
                    if (receiverPlace != null && targetType.IsValueType)
                    {
                        // load addr of the receiver:
                        var lhs = VariableReferenceExtensions.EmitReceiver(this, receiverPlace);

                        if (lhs.Stack == null || lhs.Stack.IsVoid())
                        {
                            throw this.NotImplementedException();
                        }
                    }
                    else
                    {
                        // <thisExpr> -> <TObject>
                        EmitConvert(thisExpr, targetType);

                        if (targetType.IsValueType)
                        {
                            EmitStructAddr(targetType);   // value -> valueaddr
                        }
                    }

                    //
                    return targetType;
                }
                else
                {
                    // POP <thisExpr>
                    EmitPop(Emit(thisExpr));

                    return null;
                }
            }
            else
            {
                if (targetType.SpecialType != SpecialType.System_Void)
                {
                    if (ThisPlaceOpt != null && ThisPlaceOpt.Type != null &&
                        ThisPlaceOpt.Type.IsOfType(targetType))
                    {
                        // implicit $this instance
                        return EmitThis();
                    }
                    else
                    {
                        // $this is undefined
                        // PHP would throw a notice when undefined $this is used

                        if (targetType.IsValueType)
                        {
                            // Template: ADDR default(VALUE_TYPE)
                            Builder.EmitValueDefaultAddr(this.Module, this.Diagnostics, this.GetTemporaryLocal(targetType, true));
                        }
                        else
                        {
                            // create dummy instance
                            // TODO: when $this is accessed from PHP code, throw error
                            // NOTE: we can't just pass NULL since the instance holds reference to Context that is needed by emitted code

                            var dummyctor =
                                (MethodSymbol)(targetType as IPhpTypeSymbol)?.InstanceConstructorFieldsOnly ??    // .ctor that only initializes fields with default values
                                targetType.InstanceConstructors.FirstOrDefault(m => !m.IsPhpHidden && m.Parameters.All(p => p.IsImplicitlyDeclared));   // implicit ctor

                            if (dummyctor != null)
                            {
                                // new T(Context)
                                EmitCall(ILOpCode.Newobj, dummyctor, null, ImmutableArray<BoundArgument>.Empty, null)
                                    .Expect(targetType);
                            }
                            else
                            {
                                // TODO: empty struct addr
                                throw this.NotImplementedException();
                            }
                        }

                        //
                        return targetType;
                    }
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Loads "self" class onto the stack.
        /// </summary>
        /// <param name="astype">Type to be used to represent "self" - PhpTypeInfo, string, RuntimeTypeHandle.</param>
        /// <returns></returns>
        TypeSymbol EmitLoadCurrentClassContext(TypeSymbol astype)
        {
            if (astype == CoreTypes.PhpTypeInfo)
            {
                if (this.CallerType == null && this.RuntimeCallerTypePlace == null)
                {
                    // null
                    _il.EmitNullConstant();
                }
                else
                {
                    EmitLoadSelf(throwOnError: false);
                }
            }
            else if (astype.SpecialType == SpecialType.System_String)
            {
                if (this.CallerType == null && this.RuntimeCallerTypePlace == null)
                {
                    // null
                    Builder.EmitNullConstant();
                }
                else if (this.CallerType is IPhpTypeSymbol phpt)
                {
                    // type known in compile-time:
                    Builder.EmitStringConstant(phpt.FullName.ToString());
                }
                else
                {
                    // {LOAD PhpTypeInfo}?.Name
                    EmitLoadSelf(throwOnError: false);
                    EmitNullCoalescing(
                        () => EmitCall(ILOpCode.Call, CoreMethods.Operators.GetName_PhpTypeInfo.Getter).Expect(SpecialType.System_String),
                        () => Builder.EmitNullConstant());
                }
            }
            else if (astype == CoreTypes.RuntimeTypeHandle)
            {
                // LOAD <RuntimeTypeHandle>
                return EmitCallerTypeHandle();
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(astype);
            }

            return astype;
        }

        TypeSymbol LoadMethodSpecialArgument(ParameterSymbol p, BoundTypeRef staticType, ITypeSymbol selfType)
        {
            // Context
            if (SpecialParameterSymbol.IsContextParameter(p))
            {
                Debug.Assert(p.Type == CoreTypes.Context);
                return EmitLoadContext();
            }
            // ImportValueAttribute( ValueSpec )
            else if (SpecialParameterSymbol.IsImportValueParameter(p, out var value))
            {
                switch (value)
                {
                    case ImportValueAttributeData.ValueSpec.CallerScript:
                        Debug.Assert(ContainingFile != null);
                        Debug.Assert(p.Type == CoreTypes.RuntimeTypeHandle);
                        return EmitLoadToken(ContainingFile, null);    // RuntimeTypeHandle

                    case ImportValueAttributeData.ValueSpec.CallerArgs:
                        //Debug.Assert(p.Type.IsSZArray() && ((ArrayTypeSymbol)p.Type).ElementType.Is_PhpValue()); // PhpValue[]
                        //return Emit_ArgsArray(CoreTypes.PhpValue);     // PhpValue[]
                        if ((Symbol)FunctionArgsArray?.Type == p.Type)
                        {
                            _il.EmitLocalLoad(FunctionArgsArray);
                            return p.Type;
                        }
                        else
                        {
                            throw this.NotImplementedException(
                                "cannot pass caller arguments, " +
                                FunctionArgsArray == null ? "arguments not fetched" : "parameter type does not match");
                        }

                    case ImportValueAttributeData.ValueSpec.Locals:
                        Debug.Assert(p.Type.Is_PhpArray());
                        if (!HasUnoptimizedLocals) throw new InvalidOperationException();
                        return LocalsPlaceOpt.EmitLoad(Builder).Expect(CoreTypes.PhpArray);    // PhpArray

                    case ImportValueAttributeData.ValueSpec.This:
                        Debug.Assert(p.Type.IsObjectType());
                        return this.EmitPhpThisOrNull();           // object

                    case ImportValueAttributeData.ValueSpec.CallerStaticClass:
                        // current "static"
                        if (p.Type == CoreTypes.PhpTypeInfo)
                        {
                            return EmitLoadStaticPhpTypeInfo();
                        }
                        throw ExceptionUtilities.UnexpectedValue(p.Type);

                    case ImportValueAttributeData.ValueSpec.CallerClass:
                        // current class context (self)
                        // note, can be obtain dynamically (global code, closure)
                        return EmitLoadCurrentClassContext(p.Type);

                    case ImportValueAttributeData.ValueSpec.LocalVariable:
                        // load local variable with the name {p.Name}
                        if (this.Routine.LocalsTable.TryGetVariable(new VariableName(p.Name), out var variable))
                        {
                            var lhs = default(LhsStack);
                            // TODO: get alias without increasing reference count
                            EmitConvert(variable.EmitLoadValue(this, ref lhs, p.Type.Is_PhpAlias() ? BoundAccess.ReadRef : BoundAccess.Read), 0, p.Type);
                            return p.Type;
                        }
                        else if (p.Type.IsReferenceType) // PhpAlias
                        {
                            this.Builder.EmitNullConstant();
                            return p.Type;
                        }
                        else
                        {
                            return EmitLoadDefault(p.Type);
                        }

                    default:
                        throw ExceptionUtilities.UnexpectedValue(value);
                }
            }
            // class context
            else if (SpecialParameterSymbol.IsSelfParameter(p))
            {
                return EmitLoadCurrentClassContext(p.Type);
            }
            // late static
            else if (SpecialParameterSymbol.IsLateStaticParameter(p))
            {
                // PhpTypeInfo
                if (staticType != null)
                {
                    if (staticType.IsSelf() || staticType.IsParent())
                    {
                        return EmitLoadStaticPhpTypeInfo();
                    }
                    else
                    {
                        // LOAD <statictype>
                        return (TypeSymbol)staticType.EmitLoadTypeInfo(this);
                    }
                }
                else if (selfType != null && selfType.Is_PhpValue() == false && selfType.Is_PhpAlias() == false)
                {
                    // late static bound type is self:
                    return this.EmitLoadPhpTypeInfo(selfType);
                }
                else
                {
                    throw ExceptionUtilities.Unreachable;
                }
            }
            // dummy parameter for ctors
            else if (SpecialParameterSymbol.IsDummyFieldsOnlyCtorParameter(p))
            {
                return EmitLoadDefaultOfValueType(p.Type);  // default()
            }
            // unhandled
            else
            {
                throw ExceptionUtilities.UnexpectedValue(p.Type);
            }
        }

        /// <summary>
        /// Emits known method call if arguments have to be unpacked before the call.
        /// </summary>
        internal TypeSymbol EmitCall_UnpackingArgs(ILOpCode code, MethodSymbol method, BoundExpression thisExpr, ImmutableArray<BoundArgument> packedarguments, BoundTypeRef staticType = null)
        {
            Contract.ThrowIfNull(method);
            Debug.Assert(packedarguments.Any(a => a.IsUnpacking));

            // {this}
            var thisType = (code != ILOpCode.Newobj) ? LoadTargetInstance(thisExpr, method) : null;

            // .callvirt -> .call
            if (code == ILOpCode.Callvirt && (!method.HasThis || !method.IsMetadataVirtual()))
            {
                // ignores null check in method call
                code = ILOpCode.Call;
            }

            // arguments
            var parameters = method.Parameters;
            int arg_index = 0;      // next argument to be emitted from <arguments>
            var param_index = 0;    // loaded parameters
            var writebacks = new List<WriteBackInfo>();

            // unpack arguments (after $this was evaluated)
            // Template: PhpValue[] <tmpargs> = UNPACK <arguments>
            var tmpargs = GetTemporaryLocal(UnpackArgumentsIntoArray(packedarguments, method.GetByRefArguments()));
            _il.EmitLocalStore(tmpargs);
            var tmpargs_place = new LocalPlace(tmpargs);

            //
            for (; param_index < parameters.Length; param_index++)
            {
                var p = parameters[param_index];

                // special implicit parameters
                if (arg_index == 0 &&           // no source parameter were loaded yet
                    p.IsImplicitlyDeclared &&   // implicitly declared parameter
                    !p.IsParams)
                {
                    LoadMethodSpecialArgument(p, staticType, thisType ?? method.ContainingType);
                    continue;
                }

                // pass argument:
                if (p.IsParams)
                {
                    Debug.Assert(p.Type.IsArray());

                    if (((ArrayTypeSymbol)p.Type).ElementType == CoreTypes.PhpValue && arg_index == 0)
                    {
                        // just pass argsarray as it is
                        tmpargs_place.EmitLoad(_il);
                    }
                    else
                    {
                        // create new array and copy&convert values from argsarray

                        ArrayToNewArray(tmpargs_place, arg_index, ((ArrayTypeSymbol)p.Type).ElementType);
                    }

                    break;  // p is last one
                }
                else
                {
                    // Template: (index < tmpargs.Length) ? tmpargs[index] : default
                    var lbldefault = new object();
                    var lblend = new object();

                    _il.EmitIntConstant(arg_index);                 // LOAD index
                    _il.EmitLocalLoad(tmpargs); EmitArrayLength();  // LOAD <tmpargs>.Length
                    _il.EmitBranch(ILOpCode.Bge, lbldefault);       // .bge (lbldefault)
                    EmitLoadArgument(p, tmpargs_place, arg_index,
                        writebacks);                                // LOAD tmpargs[index]
                    _il.EmitBranch(ILOpCode.Br, lblend);            // goto lblend;
                    _il.MarkLabel(lbldefault);                      // lbldefault:
                    EmitParameterDefaultValue(p);                   // default(p)
                    _il.MarkLabel(lblend);                          // lblend:

                    //
                    arg_index++;
                }
            }

            // return <tmpargs> asap
            ReturnTemporaryLocal(tmpargs);
            tmpargs = null;

            // call the method
            var result = EmitCall(code, method);

            // write ref parameters back if necessary
            WriteBackInfo.WriteBackAndFree(this, writebacks);

            //
            return result;
        }

        internal TypeSymbol EmitCall(ILOpCode code, MethodSymbol method, BoundExpression thisExpr, ImmutableArray<BoundArgument> arguments, BoundTypeRef staticType = null)
        {
            Contract.ThrowIfNull(method);

            // {this}
            var thisType = (code != ILOpCode.Newobj) ? LoadTargetInstance(thisExpr, method) : null;

            // .callvirt -> .call
            if (code == ILOpCode.Callvirt && (!method.HasThis || !method.IsMetadataVirtual()))
            {
                // ignores null check in method call
                code = ILOpCode.Call;
            }

            // arguments
            var parameters = method.Parameters;
            int arg_index = 0;      // next argument to be emitted from <arguments>
            var param_index = 0;    // loaded parameters
            var writebacks = new List<WriteBackInfo>();

            int arg_params_index = (arguments.Length != 0 && arguments[arguments.Length - 1].IsUnpacking) ? arguments.Length - 1 : -1; // index of params argument, otherwise -1
            int arg_params_consumed = 0; // count of items consumed from arg_params if any

            Debug.Assert(arg_params_index < 0 || (arguments[arg_params_index].Value is BoundVariableRef v && v.Variable.Type.IsSZArray()), $"Argument for params is expected to be a variable of type array, at {method.ContainingType.PhpName()}::{method.Name}().");

            for (; param_index < parameters.Length; param_index++)
            {
                var p = parameters[param_index];

                // special implicit parameters
                if (arg_index == 0 &&           // no source parameter were loaded yet
                    p.IsImplicitlyDeclared &&   // implicitly declared parameter
                    !p.IsParams)
                {
                    LoadMethodSpecialArgument(p, staticType, thisType ?? method.ContainingType);
                    continue;
                }

                // load arguments

                if (arg_index == arg_params_index) // arg is params
                {
                    #region LOAD params T[]

                    //
                    // treat argument as "params T[]"
                    //

                    var arg_type = (ArrayTypeSymbol)arguments[arg_index].Value.Emit(this); // {args}

                    // {args} on STACK:

                    if (p.IsParams)
                    {
                        // Template: {args}
                        if (arg_type != p.Type || arg_params_consumed > 0)  // we need to create new array from args
                        {
                            // T[] arrtmp = {arrtmp};
                            var arrtmp = GetTemporaryLocal(arg_type, false);
                            _il.EmitLocalStore(arrtmp);

                            // {args}.Skip({arg_params_consumed}) -> new T[]
                            this.ArrayToNewArray(new LocalPlace(arrtmp), arg_params_consumed, ((ArrayTypeSymbol)p.Type).ElementType);

                            //
                            ReturnTemporaryLocal(arrtmp);
                        }
                    }
                    else
                    {
                        // Template: {args}.Length <= {arg_params_consumed} ? default(T) : (T)args[arg_params_consumed]

                        if (p.RefKind != RefKind.None)
                        {
                            throw this.NotImplementedException($"p.RefKind == {p.RefKind}", thisExpr);
                        }

                        var lbldefault = new object();
                        var lblend = new object();

                        this.EmitArrayLength();                     // .Length
                        _il.EmitIntConstant(arg_params_consumed);   // {arg_params_consumed}
                        _il.EmitBranch(ILOpCode.Ble, lbldefault);

                        arguments[arg_index].Value.Emit(this);      // <args>
                        _il.EmitIntConstant(arg_params_consumed);   // <i>

                        if (p.Type.Is_PhpAlias() && arg_type.ElementType.Is_PhpValue())
                        {
                            // {args}[i].EnsureAlias()
                            _il.EmitOpCode(ILOpCode.Ldelema);               // ref args[i]
                            EmitSymbolToken(arg_type.ElementType, null);    // PhpValue
                            EmitCall(ILOpCode.Call, CoreMethods.Operators.EnsureAlias_PhpValueRef);
                        }
                        else
                        {
                            // (T)args[i]
                            _il.EmitOpCode(ILOpCode.Ldelem); // args[i]
                            EmitSymbolToken(arg_type.ElementType, null);
                            EmitConvert(arg_type.ElementType, 0, p.Type);
                        }

                        _il.EmitBranch(ILOpCode.Br, lblend);

                        // default(T)
                        _il.MarkLabel(lbldefault);
                        EmitParameterDefaultValue(p);

                        //
                        _il.MarkLabel(lblend);

                        //
                        arg_params_consumed++;
                    }

                    #endregion

                    continue;
                }

                if (p.IsParams)
                {
                    Debug.Assert(parameters.Length == param_index + 1, $"params should be the last parameter, at {method.ContainingType.PhpName()}::{method.Name}()."); // p is last one
                    Debug.Assert(p.Type.IsArray(), $"params should be of type array, at {method.ContainingType.PhpName()}::{method.Name}().");

                    var p_element = ((ArrayTypeSymbol)p.Type).ElementType;

                    if (arg_params_index >= 0)
                    {
                        // we have to load remaining arguments into an array and unroll the arg_params
                        // { arg_i, ..., arg_params[] }

                        #region LOAD new Array( ..., ...params )

                        /*
                         * Template:
                         * params = new PhpValue[ {arguments.Length - arg_index - 1} +  {arguments[arg_params_index]}.Length ]
                         * params[0] = arg_i
                         * params[1] = ..
                         * Array.Copy( params, arguments[arg_params_index] )
                         */

                        int arr_size1 = arguments.Length - arg_index - 1; // remaining arguments without arg_params
                        var arg_params = arguments[arg_params_index].Value as BoundVariableRef;
                        Debug.Assert(arg_params != null, $"Argument for params is expected to be a variable reference expression, at {method.ContainingType.PhpName()}::{method.Name}().");

                        // <params> = new [arr_size1 + arg_params.Length]

                        _il.EmitIntConstant(arr_size1);
                        arguments[arg_params_index].Value.Emit(this); // {args}
                        EmitArrayLength();
                        _il.EmitOpCode(ILOpCode.Add);

                        _il.EmitOpCode(ILOpCode.Newarr);
                        EmitSymbolToken(p_element, null);

                        var params_loc = GetTemporaryLocal(p.Type, false);
                        _il.EmitLocalStore(params_loc);

                        // { arg_i, ..., arg_(n-1) }
                        for (int i = 0; i < arr_size1; i++)
                        {
                            _il.EmitLocalLoad(params_loc);  // <params>
                            _il.EmitIntConstant(i);         // [i]
                            EmitConvert(arguments[arg_index + i].Value, p_element);
                            _il.EmitOpCode(ILOpCode.Stelem);
                            EmitSymbolToken(p_element, null);
                        }

                        // { ... arg_params } // TODO: use Array.Copy() if element types match
                        EmitEnumerateArray(arg_params.Place(), 0, (loc_i, loader) =>
                        {
                            _il.EmitLocalLoad(params_loc);  // <params>

                            _il.EmitIntConstant(arr_size1);         // arr_size1
                            _il.EmitLocalLoad(loc_i);               // {i}
                            _il.EmitOpCode(ILOpCode.Add);           // +

                            EmitConvert(loader(), 0, p_element);
                            _il.EmitOpCode(ILOpCode.Stelem);
                            EmitSymbolToken(p_element, null);
                        });

                        // params : PhpValue[]
                        _il.EmitLocalLoad(params_loc);
                        ReturnTemporaryLocal(params_loc);

                        arg_index = arguments.Length;

                        #endregion
                    }
                    else
                    {
                        // easy case,
                        // wrap remaining arguments to array
                        var values = (arg_index < arguments.Length) ? arguments.Skip(arg_index).AsImmutable() : ImmutableArray<BoundArgument>.Empty;
                        arg_index += values.Length;
                        Emit_NewArray(p_element, values);
                    }

                    break;  // p is last one
                }

                if (arg_index < arguments.Length)
                {
                    EmitLoadArgument(p, arguments[arg_index++].Value, writebacks);
                }
                else
                {
                    EmitParameterDefaultValue(p);
                }
            }

            // emit remaining not used arguments
            for (; arg_index < arguments.Length && arg_index != arg_params_index; arg_index++)
            {
                EmitPop(Emit(arguments[arg_index].Value));
            }

            // call the method
            var result = EmitCall(code, method);

            // write ref parameters back if necessary
            WriteBackInfo.WriteBackAndFree(this, writebacks);

            //
            return result;
        }

        /// <summary>
        /// Emits .call to <paramref name="target"/> with the same arguments the caller method parameters (<paramref name="thismethod"/>) including reference to <c>this</c>.
        /// </summary>
        /// <param name="target">Method to be called.</param>
        /// <param name="thismethod">Current method.</param>
        /// <param name="thisPlaceExplicit">Optionaly specified place of object instance to call the method on.</param>
        /// <param name="callvirt">Whether to call the method virtually through <c>.callvirt</c>.</param>
        /// <returns>Return of <paramref name="target"/>.</returns>
        internal TypeSymbol EmitForwardCall(MethodSymbol target, MethodSymbol thismethod, IPlace thisPlaceExplicit = null, bool callvirt = false)
        {
            if (target == null)
            {
                return CoreTypes.Void;
            }
            // bind "this" expression if needed
            BoundExpression thisExpr;

            if (target.HasThis)
            {
                thisExpr = new BoundVariableRef(new BoundVariableName(VariableName.ThisVariableName))
                {
                    Variable = PlaceReference.Create(thisPlaceExplicit ?? this.ThisPlaceOpt),
                    Access = BoundAccess.Read
                };
            }
            else
            {
                thisExpr = null;
            }

            // bind arguments
            var givenps = thismethod.Parameters;
            var arguments = new List<BoundArgument>(givenps.Length);
            BoundTypeRef staticTypeRef = null;

            for (int i = 0; i < givenps.Length; i++)
            {
                var p = givenps[i];
                if (arguments.Count == 0 && p.IsImplicitlyDeclared && !p.IsParams)
                {
                    if (SpecialParameterSymbol.IsLateStaticParameter(p))
                    {
                        staticTypeRef = BoundTypeRefFactory.CreateFromPlace(new ParamPlace(p));
                    }

                    continue;
                }

                var expr = new BoundVariableRef(new BoundVariableName(new VariableName(p.MetadataName)))
                {
                    Variable = new PlaceReference(new ParamPlace(p)), // new ParameterReference(p, Routine),
                    Access = BoundAccess.Read
                };

                var arg = p.IsParams
                    ? BoundArgument.CreateUnpacking(expr)   // treated as "params PhpArray[]" by EmitCall
                    : BoundArgument.Create(expr);           // treated as ordinary parameter

                arguments.Add(arg);
            }

            //
            ILOpCode opcode = callvirt ? ILOpCode.Callvirt : ILOpCode.Call;

            // emit call of target
            return EmitCall(opcode, target, thisExpr, arguments.AsImmutableOrEmpty(), staticTypeRef);
        }

        /// <summary>
        /// Emits necessary conversion and copying of value returned from a method call.
        /// </summary>
        /// <param name="stack">Result value type on stack.</param>
        /// <param name="method">Called method. Can be <c>null</c> for indirect method calls.</param>
        /// <param name="access">Expression access.</param>
        /// <returns>New type on stack.</returns>
        internal TypeSymbol EmitMethodAccess(TypeSymbol stack, MethodSymbol method, BoundAccess access)
        {
            // cast negative number or null to false (CastToFalse)
            // and copy the value on stack if necessary
            if (access.IsRead)
            {
                if (method != null && method.CastToFalse)
                {
                    // casts to false and copy the value
                    //if (stack.IsNullableType())
                    //{
                    //    // unpack Nullable<T>
                    //    stack = EmitNullableCastToFalse(stack, access.IsReadValueCopy);
                    //} else

                    //
                    stack = EmitCastToFalse(stack, access.TargetType);
                }

                if (access.EnsureArray)
                {
                    // GetArrayAccess

                    if (stack == CoreTypes.PhpAlias)
                    {
                        // <stack>.EnsureArray()
                        return EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.EnsureArray);
                    }

                    if (stack == CoreTypes.PhpValue)
                    {
                        // <stack>.GetArrayAccess()
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.Operators.GetArrayAccess_PhpValueRef);
                    }

                    if (stack.IsReferenceType)
                    {
                        if (stack.ImplementsInterface(CoreTypes.IPhpArray))
                        {
                            // IPhpArray
                            return stack;
                        }

                        // Operators.EnsureArray(<stack>)
                        return EmitCall(ILOpCode.Call, CoreMethods.Operators.EnsureArray_Object);
                    }
                }
                else if (access.EnsureObject)
                {
                    // AsObject

                    if (stack == CoreTypes.PhpAlias)
                    {
                        // <stack>.EnsureObject()
                        return EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.EnsureObject);
                    }

                    if (stack == CoreTypes.PhpValue)
                    {
                        // <stack>.AsObject()
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.AsObject);
                    }
                }
                else if (access.IsReadRef)
                {
                    if (stack != CoreTypes.PhpAlias)
                    {
                        EmitConvertToPhpValue(stack, 0);
                        stack = Emit_PhpValue_MakeAlias();
                    }
                }
                else
                {
                    // routines returning aliased value but
                    // read by value must dereference:
                    // BoundCopyValue is not bound
                    EmitPhpAliasDereference(ref stack);
                    // TODO: DeepCopy if being assigned ?
                }
            }

            //
            return stack;
        }

        /// <summary>
        /// Converts <b>negative</b> number or <c>null</c> to <c>FALSE</c>.
        /// </summary>
        /// <param name="stack">Type of value on stack.</param>
        /// <param name="targetType">Optional hint, the expected conversion of the resulting value.</param>
        /// <returns>New type of value on stack.</returns>
        internal TypeSymbol EmitCastToFalse(TypeSymbol stack, TypeSymbol targetType = null)
        {
            if (stack.SpecialType == SpecialType.System_Boolean)
            {
                return stack;
            }

            if (targetType != null && targetType.SpecialType == SpecialType.System_Boolean)
            {
                // will be converting to bool anyways
                if (stack.SpecialType == SpecialType.System_Int32)
                {
                    _il.EmitIntConstant(0);     // > 0
                    _il.EmitOpCode(ILOpCode.Cgt);
                    return CoreTypes.Boolean;
                }
                else if (stack.SpecialType == SpecialType.System_Int64)
                {
                    _il.EmitLongConstant(0);    // > 0L
                    _il.EmitOpCode(ILOpCode.Cgt);
                    return CoreTypes.Boolean;
                }
                else if (stack.SpecialType == SpecialType.System_Double)
                {
                    _il.EmitDoubleConstant(0.0);    // > 0.0
                    _il.EmitOpCode(ILOpCode.Cgt);
                    return CoreTypes.Boolean;
                }
                else if (stack.SpecialType == SpecialType.System_String)
                {
                    // Convert.ToBoolean({stack})
                    return EmitCall(ILOpCode.Call, CoreMethods.Operators.ToBoolean_String);
                }
                else if (stack.Is_PhpString())
                {
                    // Convert.ToBoolean({stack})
                    return EmitCall(ILOpCode.Call, CoreMethods.Operators.ToBoolean_PhpString);
                }
                else if (stack.IsReferenceType)
                {
                    // TODO: {stack} != null && Convert.ToBoolean({stack})
                }
            }

            // Template: <stack> ?? FALSE

            var lblfalse = new NamedLabel("CastToFalse:FALSE");
            var lblend = new NamedLabel("CastToFalse:end");

            _il.EmitOpCode(ILOpCode.Dup);   // <stack>

            // emit branching to lblfalse
            if (stack.SpecialType == SpecialType.System_Int32)
            {
                _il.EmitIntConstant(0);     // < 0
                _il.EmitBranch(ILOpCode.Blt, lblfalse);
            }
            else if (stack.SpecialType == SpecialType.System_Int64)
            {
                _il.EmitLongConstant(0);    // < 0L
                _il.EmitBranch(ILOpCode.Blt, lblfalse);
            }
            else if (stack.SpecialType == SpecialType.System_Double)
            {
                _il.EmitDoubleConstant(0.0);    // < 0.0
                _il.EmitBranch(ILOpCode.Blt, lblfalse);
            }
            else if (stack == CoreTypes.PhpString)
            {
                EmitCall(ILOpCode.Call, CoreMethods.PhpString.IsNull_PhpString);    // PhpString.IsDefault
                _il.EmitBranch(ILOpCode.Brtrue, lblfalse);
            }
            else if (stack.IsReferenceType)
            {
                _il.EmitNullConstant(); // == null
                _il.EmitBranch(ILOpCode.Beq, lblfalse);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(stack);
            }

            // test(<stack>) ? POP,FALSE : (PhpValue)<stack>

            // (PhpValue)<stack>
            EmitConvertToPhpValue(stack, 0);
            _il.EmitBranch(ILOpCode.Br, lblend);

            // POP, PhpValue.False
            _il.MarkLabel(lblfalse);
            EmitPop(stack);
            Emit_PhpValue_False();

            //
            _il.MarkLabel(lblend);

            //
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Converts <b>Nullable</b> without a value to <c>NULL</c>.
        /// </summary>
        /// <param name="stack">Type of Nullable&lt;T&gt; value on stack.</param>
        /// <param name="deepcopy">Whether to deep copy returned non-FALSE value.</param>
        /// <returns>New type of value on stack.</returns>
        internal TypeSymbol EmitNullableCastToNull(TypeSymbol stack, bool deepcopy)
        {
            Debug.Assert(stack.IsNullableType());

            // Template:
            // tmp = stack;
            // tmp.HasValue ? tmp.Value : NULL

            var t = ((NamedTypeSymbol)stack).TypeArguments[0];

            var lbltrue = new NamedLabel("has value");
            var lblend = new NamedLabel("end");

            var tmp = GetTemporaryLocal(stack, immediateReturn: true);
            _il.EmitLocalStore(tmp);

            // Template: tmp.HasValue ??
            _il.EmitLocalAddress(tmp);
            EmitCall(ILOpCode.Call, stack.LookupMember<PropertySymbol>("HasValue").GetMethod)
                .Expect(SpecialType.System_Boolean);

            _il.EmitBranch(ILOpCode.Brtrue, lbltrue);

            // Template: PhpValue.Null
            Emit_PhpValue_Null();

            _il.EmitBranch(ILOpCode.Br, lblend);

            // Template: (PhpValue)tmp.Value
            _il.MarkLabel(lbltrue);
            _il.EmitLocalAddress(tmp);
            EmitCall(ILOpCode.Call, stack.LookupMember<MethodSymbol>("GetValueOrDefault", m => m.ParameterCount == 0))
                .Expect(t);

            if (deepcopy)
            {
                // DeepCopy(<stack>)
                t = EmitDeepCopy(t, false);
            }
            // (PhpValue)<stack>
            EmitConvertToPhpValue(t, 0);

            //
            _il.MarkLabel(lblend);

            //
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Emits <c>??</c> operation against the value on top of the evaluation stack.
        /// </summary>
        /// <param name="nullemitter">Routine that emits the FALSE branch of the operator.</param>
        internal void EmitNullCoalescing(Action<CodeGenerator> nullemitter)
        {
            Debug.Assert(nullemitter != null);

            var lbl_notnull = new NamedLabel("NotNull");
            _il.EmitOpCode(ILOpCode.Dup);
            _il.EmitBranch(ILOpCode.Brtrue, lbl_notnull);

            _il.EmitOpCode(ILOpCode.Pop);
            nullemitter(this);

            _il.MarkLabel(lbl_notnull);
        }

        /// <summary>
        /// Emits <c>?:</c> operation against the value on top of the evaluation stack.
        /// </summary>
        internal void EmitNullCoalescing(Action notnullemitter, Action nullemitter)
        {
            var lbl_notnull = new NamedLabel("NotNull");
            var lbl_end = new object();

            _il.EmitOpCode(ILOpCode.Dup);
            _il.EmitBranch(ILOpCode.Brtrue, lbl_notnull);

            _il.EmitOpCode(ILOpCode.Pop);
            nullemitter();
            _il.EmitBranch(ILOpCode.Br, lbl_end);

            _il.MarkLabel(lbl_notnull);
            notnullemitter();

            _il.MarkLabel(lbl_end);
        }

        /// <summary>
        /// Initializes place with a default value.
        /// This applies to structs without default ctor that won't work properly when uninitialized.
        /// </summary>
        internal void EmitInitializePlace(IPlace place)
        {
            Contract.ThrowIfNull(place);
            var t = place.Type;
            Contract.ThrowIfNull(t);

            switch (t.SpecialType)
            {
                // we don't have to initialize those:
                case SpecialType.System_Boolean:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                case SpecialType.System_Double:
                case SpecialType.System_Object:
                    break;

                default:
                    // uninitialized:
                    if (t == CoreTypes.PhpString ||
                        t == CoreTypes.PhpValue)
                    {
                        Debug.Assert(t.IsValueType);
                        break;
                    }

                    // PhpNumber, PhpAlias:
                    if (t.IsValueType || t == CoreTypes.PhpAlias)
                    {
                        // fld = default(T)
                        place.EmitStorePrepare(_il);
                        EmitLoadDefault(t, 0);
                        place.EmitStore(_il);
                    }
                    break;
            }
        }

        /// <summary>
        /// Temporary data used to call routines that expect ref or out parameters when given variable can't be passed by ref.
        /// </summary>
        class WriteBackInfo
        {
            class WriteBackInfo_ArgsArray : WriteBackInfo
            {
                public IPlace arrplace;
                public int argindex;

                TypeSymbol arr_element => ((ArrayTypeSymbol)arrplace.Type).ElementType;

                protected override void EmitLoadTarget(CodeGenerator cg, TypeSymbol type)
                {
                    // Template: (type)arr[argindex] 

                    Debug.Assert(arr_element == cg.CoreTypes.PhpValue);

                    arrplace.EmitLoad(cg.Builder);
                    cg.Builder.EmitIntConstant(argindex);
                    cg.Builder.EmitOpCode(ILOpCode.Ldelem);
                    cg.EmitSymbolToken(arr_element, null);
                    cg.EmitConvert(arr_element, 0, type);
                }

                protected override void WriteBackAndFree(CodeGenerator cg)
                {
                    // Template: Operators.SetValue(ref arr[argindex], <TmpLocal>)

                    var arr_element = ((ArrayTypeSymbol)arrplace.Type).ElementType;
                    Debug.Assert(arr_element == cg.CoreTypes.PhpValue);

                    // ref arr[argindex] : &PhpValue
                    arrplace.EmitLoad(cg.Builder);
                    cg.Builder.EmitIntConstant(argindex);
                    cg.Builder.EmitOpCode(ILOpCode.Ldelema);
                    cg.EmitSymbolToken(arr_element, null);

                    // (PhpValue)TmpLocal : PhpValue
                    cg.Builder.EmitLocalLoad(TmpLocal);
                    cg.EmitConvert((TypeSymbol)TmpLocal.Type, 0, arr_element);

                    // CALL SetValue
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetValue_PhpValueRef_PhpValue);

                    //
                    Dispose(cg);
                }
            }

            /// <summary>
            /// The temporary local passed by reference to a function call.
            /// After the call, it's value has to be written back to <see cref="Target"/>.
            /// </summary>
            public LocalDefinition TmpLocal;

            /// <summary>
            /// Original variable passed to the function call.
            /// Target of the write-back routine.
            /// </summary>
            public BoundReferenceExpression Target;

            /// <summary>
            /// Loads temporary local variable as an argument to <paramref name="targetp"/>.
            /// </summary>
            /// <param name="cg"></param>
            /// <param name="targetp">Target parameter.</param>
            /// <param name="expr">Value to be passed as its argument.</param>
            /// <returns><see cref="WriteBackInfo"/> which has to be finalized with <see cref="WriteBackAndFree(CodeGenerator)"/> once the routine call ends.</returns>
            public static WriteBackInfo CreateAndLoad(CodeGenerator cg, ParameterSymbol targetp, BoundReferenceExpression expr)
            {
                var writeback = new WriteBackInfo()
                {
                    TmpLocal = cg.GetTemporaryLocal(targetp.Type),
                    Target = expr,
                };

                //
                writeback.EmitLoadArgument(cg, targetp);

                //
                return writeback;
            }

            public static WriteBackInfo CreateAndLoad(CodeGenerator cg, ParameterSymbol targetp, IPlace arrplace, int argindex)
            {
                var writeback = new WriteBackInfo_ArgsArray()
                {
                    TmpLocal = cg.GetTemporaryLocal(targetp.Type),
                    arrplace = arrplace,
                    argindex = argindex,
                };

                //
                writeback.EmitLoadArgument(cg, targetp);

                //
                return writeback;
            }

            void EmitLoadArgument(CodeGenerator cg, ParameterSymbol targetp)
            {
                Debug.Assert(TmpLocal != null);
                Debug.Assert(targetp.Type == (Symbol)TmpLocal.Type);

                if (targetp.RefKind != RefKind.Out)
                {
                    // copy Target to TmpLocal
                    // Template: TmpLocal = Target;
                    EmitLoadTarget(cg, (TypeSymbol)TmpLocal.Type);
                    cg.Builder.EmitLocalStore(TmpLocal);
                }

                if (targetp.RefKind != RefKind.None)
                {
                    // LOAD_REF TmpLocal
                    cg.Builder.EmitLocalAddress(TmpLocal);
                }
                else
                {
                    // unreachable
                    // LOAD TmpLocal
                    cg.Builder.EmitLocalLoad(TmpLocal);
                }
            }

            protected virtual void EmitLoadTarget(CodeGenerator cg, TypeSymbol type)
            {
                cg.EmitConvert(Target, type); // TODO: DetermineConversionKind(targetp)
            }

            /// <summary>
            /// Writes the value back to <see cref="Target"/> and free resources.
            /// </summary>
            protected virtual void WriteBackAndFree(CodeGenerator cg)
            {
                // Template: <Target> = <TmpLocal>;
                Target.BindPlace(cg).EmitStore(cg, TmpLocal, BoundAccess.Write);

                //
                Dispose(cg);
            }

            public static void WriteBackAndFree(CodeGenerator cg, IList<WriteBackInfo> writebacks)
            {
                if (writebacks != null && writebacks.Count != 0)
                {
                    foreach (var w in writebacks)
                    {
                        w.WriteBackAndFree(cg);
                    }
                }
            }

            protected void Dispose(CodeGenerator cg)
            {
                // free <TmpLocal>
                cg.ReturnTemporaryLocal(TmpLocal);
                TmpLocal = null;
            }
        }

        static ConversionKind DetermineConversionKind(ParameterSymbol targetp)
        {
            var t = targetp.ContainingType;
            if (t.IsPhpSourceFile() || t.IsPhpUserType())
            {
                // TODO: strict mode on file level?
                // var f = cg.ContainingFile;                    

                return ConversionKind.Strict;
            }
            else
            {
                // a library function
                return ConversionKind.Implicit;
            }
        }

        /// <summary>
        /// Loads argument from bound expression.
        /// </summary>
        void EmitLoadArgument(ParameterSymbol targetp, BoundExpression expr, List<WriteBackInfo> writebacks)
        {
            if (targetp.RefKind == RefKind.None)
            {
                // load argument
                EmitConvert(expr, targetp.Type,
                    conversion: DetermineConversionKind(targetp),
                    notNull: targetp.HasNotNull);
            }
            else
            {
                if (expr is BoundReferenceExpression refexpr)
                {
                    var place = refexpr.Place();
                    if (place != null && place.HasAddress && place.Type == targetp.Type)
                    {
                        // ref place directly
                        place.EmitLoadAddress(_il);
                        return;
                    }

                    // write-back
                    writebacks.Add(WriteBackInfo.CreateAndLoad(this, targetp, refexpr));
                    return;
                }
                else
                {
                    // TODO: report as a diagnostic before this happens!
                    throw this.NotImplementedException("Argument must be passed as a variable.");
                }
            }
        }

        /// <summary>
        /// Loads argument from arguments array.
        /// </summary>
        void EmitLoadArgument(ParameterSymbol targetp, IPlace arrplace, int argindex, List<WriteBackInfo> writebacks)
        {
            // assert arrplace is of type PhpValue[]
            Debug.Assert(arrplace != null);
            Debug.Assert(arrplace.Type.IsSZArray());

            var arr_element = ((ArrayTypeSymbol)arrplace.Type).ElementType;
            Debug.Assert(arr_element == CoreTypes.PhpValue);

            //
            if (targetp.RefKind == RefKind.None)
            {
                // Template: (T)arrplace[argindex]
                arrplace.EmitLoad(_il);
                _il.EmitIntConstant(argindex);
                _il.EmitOpCode(ILOpCode.Ldelem);
                EmitSymbolToken(arr_element, null);
                EmitConvert(CoreTypes.PhpValue, 0, targetp.Type);
            }
            else
            {
                // write-back
                writebacks.Add(WriteBackInfo.CreateAndLoad(this, targetp, arrplace, argindex));
            }
        }

        /// <summary>
        /// Emits default value of given parameter.
        /// Puts value of target parameter's type.
        /// </summary>
        /// <param name="targetp">Parameter to emit its default value.</param>
        internal void EmitParameterDefaultValue(ParameterSymbol targetp)
        {
            Contract.ThrowIfNull(targetp);

            //
            TypeSymbol ptype; // emitted type to be eventually converted to target parameter type

            // emit targetp default value:
            ConstantValue cvalue;
            BoundExpression boundinitializer;
            FieldSymbol defaultvaluefield;

            if ((cvalue = targetp.ExplicitDefaultConstantValue) != null)
            {
                ptype = EmitLoadConstant(cvalue.Value, targetp.Type);
            }
            else if ((defaultvaluefield = targetp.DefaultValueField) != null)
            {
                Debug.Assert(defaultvaluefield.IsStatic);
                ptype = defaultvaluefield.EmitLoad(this);

                if (ptype.Is_Func_Context_PhpValue())
                {
                    this.EmitLoadContext();

                    // .Invoke( ctx )
                    ptype = this.Builder.EmitCall(Module, Diagnostics, ILOpCode.Callvirt, ptype.DelegateInvokeMethod());
                }
            }
            else if ((boundinitializer = (targetp as IPhpValue)?.Initializer) != null)
            {
                // DEPRECATED AND NOT USED ANYMORE:

                var cg = this;

                if (targetp.OriginalDefinition is SourceParameterSymbol)
                {
                    // emit using correct TypeRefContext:

                    // TODO: use `boundinitializer.Parent` instead of following
                    // magically determine the source routine corresponding to the initializer expression:
                    SourceRoutineSymbol srcr = null;
                    for (var r = targetp.ContainingSymbol;
                         srcr == null && r != null; // we still don't have to original SourceRoutineSymbol, but we have "r"
                         r = (r as SynthesizedMethodSymbol)?.ForwardedCall?.OriginalDefinition) // dig in and find original SourceRoutineSymbol wrapped by this synthesized stub
                    {
                        srcr = r as SourceRoutineSymbol;
                    }

                    Debug.Assert(srcr != null, "!srcr");

                    if (srcr != null)
                    {
                        cg = new CodeGenerator(this, srcr);
                    }
                }

                //
                cg.EmitConvert(boundinitializer, ptype = targetp.Type);
            }
            else if (targetp.IsParams)
            {
                // Template: System.Array.Empty<T>()
                Emit_EmptyArray(((ArrayTypeSymbol)targetp.Type).ElementType);
                return;
            }
            else
            {
                ptype = EmitLoadDefault(targetp.Type, 0);
            }

            // eventually convert emitted value to target parameter type
            EmitConvert(ptype, 0, targetp.Type);

            // ref, out
            if (targetp.RefKind == RefKind.Ref || targetp.RefKind == RefKind.Out) // this usually won't happen, ref parameters are not optional
            {
                // T tmp = <DEFAULT>
                var tmp = GetTemporaryLocal(targetp.Type, true); // TODO: should not be returned immediatelly, remember tmp and return it postcall
                Builder.EmitLocalStore(tmp);

                // ref tmp, 
                Builder.EmitLocalAddress(tmp);
                return;
            }
        }

        internal TypeSymbol EmitGetProperty(IPlace holder, PropertySymbol prop)
        {
            Debug.Assert(prop.IsStatic || holder != null);
            Debug.Assert(prop.GetMethod != null);
            Debug.Assert(prop.GetMethod.ParameterCount == 0);

            return prop.EmitLoadValue(this, holder);
        }

        internal TypeSymbol EmitCastClass(TypeSymbol from, TypeSymbol to)
        {
            Debug.Assert(!from.IsUnreachable);
            Debug.Assert(!to.IsUnreachable);

            if (from.IsOfType(to))
            {
                return from;
            }
            else
            {
                EmitCastClass(to);
                return to;
            }
        }

        internal void EmitCastClass(TypeSymbol type)
        {
            Debug.Assert(!type.IsUnreachable);

            // (T)
            _il.EmitOpCode(ILOpCode.Castclass);
            EmitSymbolToken(type, null);
        }

        /// <summary>
        /// Emits <c>PhpString.Blob.Append</c> expecting <c>PhpString.Blob</c> on top of evaluation stack.
        /// </summary>
        /// <param name="value">The expression to be appended.</param>
        /// <param name="expandConcat">Whether to skip evaluation of <c>concat</c> expression and directly append its arguments.</param>
        internal void Emit_PhpStringBlob_Append(BoundExpression value, bool expandConcat = true)
        {
            if (value is BoundConcatEx concat && expandConcat)
            {
                var args = concat.ArgumentsInSourceOrder;
                for (int i = 0; i < args.Length; i++)
                {
                    if (i < args.Length - 1)
                    {
                        _il.EmitOpCode(ILOpCode.Dup);   // PhpString.Blob
                    }

                    Emit_PhpStringBlob_Append(args[i].Value);
                }
            }
            else
            {
                if (!IsDebug && value.IsConstant() && ExpressionsExtension.IsEmptyStringValue(value.ConstantValue.Value))
                {
                    _il.EmitOpCode(ILOpCode.Pop);
                }
                else
                {
                    Emit_PhpStringBlob_Append(Emit(value));
                }
            }
        }

        /// <summary>
        /// Emits <c>PhpString.Blob.Append</c> expecting <c>PhpString.Blob</c> and <paramref name="ytype"/> on top of evaluation stack.
        /// </summary>
        /// <param name="ytype">Type of argument loaded on stack.</param>
        void Emit_PhpStringBlob_Append(TypeSymbol ytype)
        {
            if (ytype == CoreTypes.PhpAlias)
            {
                ytype = Emit_PhpAlias_GetValue();
            }

            if (ytype.SpecialType == SpecialType.System_Void)
            {
                _il.EmitOpCode(ILOpCode.Pop);
            }
            else if (ytype == CoreTypes.PhpString)
            {
                // Append(PhpString)
                EmitCall(ILOpCode.Callvirt, CoreMethods.PhpStringBlob.Add_PhpString);
            }
            else if (ytype == CoreTypes.PhpValue)
            {
                // Append(PhpValue, Context)
                EmitLoadContext();
                EmitCall(ILOpCode.Callvirt, CoreMethods.PhpStringBlob.Add_PhpValue_Context);
            }
            else
            {
                // Append(string)
                EmitConvertToString(ytype, 0);
                EmitCall(ILOpCode.Callvirt, CoreMethods.PhpStringBlob.Add_String);
            }
        }

        public void EmitEcho(BoundExpression expr)
        {
            Contract.ThrowIfNull(expr);
            Debug.Assert(expr.Access.IsRead);

            if (_optimizations.IsRelease())
            {
                // check if the value won't be an empty string:
                if (expr.ConstantValue.HasValue && ExpressionsExtension.IsEmptyStringValue(expr.ConstantValue.Value))
                {
                    return;
                }

                // avoid concatenation if possible:
                if (expr is BoundConcatEx concat)
                {
                    // Check if arguments can be echo'ed separately without concatenating them,
                    // this is only possible if the arguments won't have side effects:
                    var issafe = true;
                    var concat_args = concat.ArgumentsInSourceOrder;
                    for (int i = 1; i < concat_args.Length; i++)
                    {
                        issafe &=
                            // TODO: add more expressions that are safe to echo
                            concat_args[i].Value.IsConstant() ||
                            concat_args[i].Value is BoundGlobalConst ||
                            concat_args[i].Value is BoundPseudoConst ||
                            concat_args[i].Value is BoundPseudoClassConst ||
                            concat_args[i].Value is BoundVariableRef;
                    }

                    if (issafe)
                    {
                        for (int i = 0; i < concat_args.Length; i++)
                        {
                            EmitEcho(concat_args[i].Value);
                        }
                        return;
                    }
                }
            }

            // Template: <ctx>.Echo(expr);

            this.EmitLoadContext();
            var type = EmitSpecialize(expr);

            //
            MethodSymbol method = null;

            switch (type.SpecialType)
            {
                case SpecialType.System_Void:
                    EmitPop(this.CoreTypes.Context);
                    return;
                case SpecialType.System_String:
                    method = CoreMethods.Operators.Echo_String.Symbol;
                    break;
                case SpecialType.System_Double:
                    method = CoreMethods.Operators.Echo_Double.Symbol;
                    break;
                case SpecialType.System_Int32:
                    method = CoreMethods.Operators.Echo_Int32.Symbol;
                    break;
                case SpecialType.System_Int64:
                    method = CoreMethods.Operators.Echo_Long.Symbol;
                    break;
                case SpecialType.System_Boolean:
                    method = CoreMethods.Operators.Echo_Bool.Symbol;
                    break;
                default:
                    if (type == CoreTypes.PhpString)
                    {
                        method = CoreMethods.Operators.Echo_PhpString.Symbol;
                    }
                    else if (type == CoreTypes.PhpNumber)
                    {
                        method = CoreMethods.Operators.Echo_PhpNumber.Symbol;
                    }
                    else if (type == CoreTypes.PhpValue)
                    {
                        method = CoreMethods.Operators.Echo_PhpValue.Symbol;
                    }
                    else if (type == CoreTypes.PhpAlias)
                    {
                        Emit_PhpAlias_GetValue();
                        method = CoreMethods.Operators.Echo_PhpValue.Symbol;
                    }
                    else
                    {
                        // TODO: check expr.TypeRefMask if it is only NULL
                        EmitBox(type);
                        method = CoreMethods.Operators.Echo_Object.Symbol;
                    }
                    break;
            }

            //
            Debug.Assert(method != null);
            EmitCall(ILOpCode.Call, method);
        }

        /// <summary>
        /// Emits the expression decorated with error reporting disabling routine.
        /// </summary>
        public TypeSymbol EmitWithDisabledErrorReporting(BoundExpression expr)
        {
            //		context.DisableErrorReporting();
            //		<expr>
            //		context.EnableErrorReporting();

            EmitLoadContext();
            EmitCall(ILOpCode.Callvirt, CoreMethods.Context.DisableErrorReporting)
                .Expect(SpecialType.System_Void);

            var t = Emit(expr);

            EmitLoadContext();
            EmitCall(ILOpCode.Callvirt, CoreMethods.Context.EnableErrorReporting)
                .Expect(SpecialType.System_Void);

            //
            return t;
        }

        public void EmitIntStringKey(long key)
        {
            _il.EmitLongConstant(key);
            EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.IntStringKey_long);
        }

        public void EmitIntStringKey(string key)
        {
            // try convert string to integer as it is in PHP:
            if (TryConvertToIntKey(key, out var ikey))
            {
                EmitIntStringKey(ikey);
            }
            else
            {
                // lookup common keys:
                var key_fields = CoreTypes.CommonPhpArrayKeys.Symbol.GetMembers(key);   // 0 or 1, FieldSymbol
                var key_field = key_fields.IsDefaultOrEmpty ? null : (FieldSymbol)key_fields[0];
                if (key_field != null)
                {
                    Debug.Assert(key_field.IsStatic, "!key_field.IsStatic");
                    Debug.Assert(key_field.Type == CoreTypes.IntStringKey, "key_field.Type != IntStringKey");

                    // Template: .ldsfld key_field
                    key_field.EmitLoad(this);
                    return;
                }

                // Template: new IntStringKey( <key> )
                _il.EmitStringConstant(key);
                EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.IntStringKey_string);
            }
        }

        static bool TryConvertToIntKey(string key, out long ikey)
        {
            ikey = default;

            if (string.IsNullOrEmpty(key))
            {
                return false;
            }

            // See Pchp.Core.Convert.StringToArrayKey:

            if (key.Length > 1)
            {
                // following are treated as string keys:
                // "-0..."
                // "-0"
                // "0..."
                if (key[0] == '0') return false;
                if (key[0] == '-' && key[1] == '0') return false;
            }


            return long.TryParse(key, out ikey);
        }

        public void EmitIntStringKey(BoundExpression expr)
        {
            Contract.ThrowIfNull(expr);

            var constant = expr.ConstantValue;
            if (constant.HasValue)
            {
                if (constant.Value == null)
                {
                    EmitIntStringKey(string.Empty);
                }
                else if (constant.Value is string s)
                {
                    EmitIntStringKey(s);
                }
                else if (constant.Value is long l)
                {
                    EmitIntStringKey(l);
                }
                else if (constant.Value is int i)
                {
                    EmitIntStringKey(i);
                }
                else if (constant.Value is double d)
                {
                    EmitIntStringKey((long)d);
                }
                else if (constant.Value is bool b)
                {
                    EmitIntStringKey(b ? 1 : 0);
                }
                else
                {
                    throw new NotSupportedException();
                }

                return;
            }

            //
            this.EmitImplicitConversion(Emit(expr), this.CoreTypes.IntStringKey); // TODO: ConvertToArrayKey
        }

        /// <summary>
        /// Emits declaring function into the context.
        /// </summary>
        public void EmitDeclareFunction(SourceFunctionSymbol f)
        {
            Debug.Assert(f != null);
            Debug.Assert(!f.IsUnreachable);

            this.EmitSequencePoint(((FunctionDecl)f.Syntax).HeadingSpan);

            // <ctx>.DeclareFunction(RoutineInfo)
            EmitLoadContext();
            f.EmitLoadRoutineInfo(this);

            EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareFunction_RoutineInfo);
        }

        /// <summary>
        /// Emits type declaration into the context.
        /// </summary>
        public void EmitDeclareType(SourceTypeSymbol t)
        {
            Contract.ThrowIfNull(t);
            Debug.Assert(!t.IsErrorType(), "Cannot declare an error type.");

            // 
            this.EmitSequencePoint(t.Syntax.HeadingSpan);

            // autoload base types or throw an error
            var versions = t.HasVersions ? t.AllReachableVersions() : default;
            if (!versions.IsDefault && versions.Length > 1)
            {
                // emit declaration of type that has ambiguous versions
                EmitVersionedTypeDeclaration(versions);
            }
            else
            {
                // Ensure to emit only reachable type
                if (t.HasVersions)
                {
                    // TODO: Error when all the ancestors have been eliminated
                    Debug.Assert(versions.Length == 1);
                    t = versions[0];
                }
                Debug.Assert(!t.IsUnreachable);

                var dependent = t.GetDependentSourceTypeSymbols();

                // ensure all types are loaded into context,
                // autoloads if necessary
                dependent.ForEach(EmitExpectTypeDeclared);

                if (t.Arity == 0)
                {
                    // <ctx>.DeclareType<T>()
                    EmitLoadContext();
                    EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareType_T.Symbol.Construct(t));
                }
                else
                {
                    // <ctx>.DeclareType( PhpTypeInfo, Name )
                    EmitLoadContext();
                    EmitLoadToken(t.AsUnboundGenericType(), null);
                    EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_RuntimeTypeHandle);
                    Builder.EmitStringConstant(t.FullName.ToString());
                    EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareType_PhpTypeInfo_String);
                }
            }

            //
            Debug.Assert(_il.IsStackEmpty);
        }

        /// <summary>
        /// If necessary, emits autoload and check the given type is loaded into context.
        /// </summary>
        public void EmitExpectTypeDeclared(ITypeSymbol d)
        {
            Debug.Assert(((TypeSymbol)d).IsValidType());
            Debug.Assert(!((TypeSymbol)d).IsUnreachable);

            if (d is NamedTypeSymbol ntype)
            {
                if (ntype.IsAnonymousType || !ntype.IsPhpUserType())
                {
                    // anonymous classes are not declared
                    // regular CLR types declared in app context
                    return;
                }

                // TODO: type has been checked already in current branch -> skip

                if (ntype.OriginalDefinition is SourceTypeSymbol srct && ReferenceEquals(srct.ContainingFile, this.ContainingFile) && !srct.Syntax.IsConditional)
                {
                    // declared in same file unconditionally,
                    // we don't have to check anything
                    return;
                }

                if (ntype.OriginalDefinition is IPhpTypeSymbol phpt && phpt.AutoloadFlag == 2)
                {
                    // type is autoloaded without side effects
                    return;
                }

                if (this.CallerType != null && this.CallerType.IsOfType(ntype))
                {
                    // the type is a sub-type of current class context, so it must be declared for sure
                    // e.g. self, parent
                    return;
                }

                if (ntype.Arity == 0)
                {
                    // Template: ctx.ExpectTypeDeclared<d>
                    EmitLoadContext();
                    EmitCall(ILOpCode.Call, CoreMethods.Context.ExpectTypeDeclared_T.Symbol.Construct(ntype));
                }
                else
                {
                    // workaround for traits - constructed traits do not match the declaration in Context
                    if (ntype.IsTraitType())
                    {
                        // Template: ctx.ExpectTypeDeclared(GetPhpTypeInfo(RuntimeTypeHandle(T<>)))
                        EmitLoadContext();

                        EmitLoadToken(ntype.AsUnboundGenericType(), null);
                        EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_RuntimeTypeHandle);

                        EmitCall(ILOpCode.Call, CoreMethods.Context.ExpectTypeDeclared_PhpTypeInfo);
                    }
                    else
                    {
                        // should not happen,
                        // user types cannot be generic types
                        Debug.Fail($"Unexpected: a user type '{ntype.Name}' has type arguments.");
                    }
                }
            }
        }

        /// <summary>
        /// Emit declaration of one of given versions (of the same source type) based on actually declared types that versions depend on.
        /// </summary>
        /// <param name="versions">Array of multiple versions of a source type declaration.</param>
        void EmitVersionedTypeDeclaration(ImmutableArray<SourceTypeSymbol> versions)
        {
            Debug.Assert(versions.Length > 1);

            // ensure all types are loaded into context and resolve version to declare

            // collect dependent types [name x symbols]
            var dependent = new Dictionary<QualifiedName, HashSet<NamedTypeSymbol>>();
            foreach (var v in versions)
            {
                Debug.Assert(!v.IsUnreachable);

                var deps = v.GetDependentSourceTypeSymbols(); // TODO: error when the type version reports it depends on a user type which will never be declared because of a library type
                foreach (var d in deps.OfType<IPhpTypeSymbol>())
                {
                    if (!dependent.TryGetValue(d.FullName, out var set))
                    {
                        dependent[d.FullName] = set = new HashSet<NamedTypeSymbol>();
                    }

                    set.Add((NamedTypeSymbol)d);
                }
            }

            //
            var dependent_handles = new Dictionary<QualifiedName, LocalDefinition>();

            // resolve dependent types:
            foreach (var d in dependent)
            {
                var first = d.Value.First();

                if (d.Value.Count == 1)
                {
                    EmitExpectTypeDeclared(first);
                }
                else
                {
                    var tname = ((IPhpTypeSymbol)first).FullName;

                    // Template: tmp_d = ctx.GetDeclaredTypeOrThrow(d_name, autoload: true).TypeHandle
                    EmitLoadContext();
                    _il.EmitStringConstant(tname.ToString());
                    _il.EmitBoolConstant(true);
                    EmitCall(ILOpCode.Call, CoreMethods.Context.GetDeclaredTypeOrThrow_string_bool);
                    var thandle = EmitCall(ILOpCode.Call, CoreMethods.Operators.GetTypeHandle_PhpTypeInfo.Getter);

                    var tmp_handle = GetTemporaryLocal(thandle);
                    _il.EmitLocalStore(tmp_handle);

                    //
                    dependent_handles.Add(tname, tmp_handle);
                }
            }

            Debug.Assert(dependent_handles.Count != 0, "the type declaration is not versioned in result, there should be a single version");

            // At this point, all dependant types are loaded, otherwise runtime would throw an exception

            // find out version to declare:
            var lblFail = new NamedLabel("declare_fail");
            var lblDone = new NamedLabel("declare_done");
            EmitDeclareTypeByDependencies(versions, dependent_handles.ToArray(), 0, dependent, lblDone, lblFail);

            // Template: throw new Exception("Cannot declare {T}");
            // TODO: compile type dynamically (eval of type declaration with actual base types)
            _il.MarkLabel(lblFail);
            EmitThrowException(string.Format(ErrorStrings.ERR_UnknownTypeDependencies, versions[0].FullName));

            _il.MarkLabel(lblDone);

            // return tmp variables
            dependent_handles.Values.ForEach(ReturnTemporaryLocal);
        }

        /// <summary>
        /// Emits decision tree.
        /// </summary>
        /// <param name="versions">Versions to decide of.</param>
        /// <param name="dependency_handle">Map of dependant types and associated local variable holding resolved real type handle.</param>
        /// <param name="index">Index to <paramref name="dependency_handle"/> where to decide from.</param>
        /// <param name="dependencies">Map of type names and possible real types.</param>
        /// <param name="lblDone">Label where to jump upon decision is done.</param>
        /// <param name="lblFail">Label where to jump when dependy does not match.</param>
        void EmitDeclareTypeByDependencies(
            ImmutableArray<SourceTypeSymbol> versions,
            KeyValuePair<QualifiedName, LocalDefinition>[] dependency_handle, int index,
            Dictionary<QualifiedName, HashSet<NamedTypeSymbol>> dependencies,
            NamedLabel lblDone, NamedLabel lblFail)
        {
            if (index == dependency_handle.Length || versions.Length == 1)
            {
                Debug.Assert(versions.Length == 1);
                Debug.Assert(versions[0].Arity == 0);   // declare as unbound generic type, see EmitDeclareType
                // <ctx>.DeclareType<T>();
                // goto DONE;
                EmitLoadContext();
                EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareType_T.Symbol.Construct(versions[0]));
                _il.EmitBranch(ILOpCode.Br, lblDone);
                return;
            }

            var thandle = dependency_handle[index];
            var types = dependencies[thandle.Key];
            Debug.Assert(types.Count > 1);

            /* [A, B]:
             * if (A == A1) {
             *   if (B == B1) Declare(X11); goto Done;
             *   if (B == B2) Declare(X12); goto Done;
             *   goto Fail;
             * }
             * if (A == A2) {
             *   if (B == B1) Declare(X21); goto Done;
             *   if (B == B2) Declare(X22); goto Done;
             *   goto Fail;
             * }
             * Fail: throw;
             * Done:
             */

            object lblElse = null;

            foreach (var h in types)
            {
                Debug.Assert(!h.IsUnreachable);

                if (lblElse != null) _il.MarkLabel(lblElse);

                // Template: if (thandle.Equals(h)) { ... } else goto lblElse;
                _il.EmitLocalAddress(thandle.Value);
                EmitLoadToken(h, null);
                EmitCall(ILOpCode.Call, CoreTypes.RuntimeTypeHandle.Method("Equals", CoreTypes.RuntimeTypeHandle));
                _il.EmitBranch(ILOpCode.Brfalse, lblElse = new object());

                // Template: *recursion*
                // h == thandle: filter versions depending on thandle
                var filtered_versions = versions.Where(v => v.GetDependentSourceTypeSymbols().Contains(h));
                EmitDeclareTypeByDependencies(filtered_versions.AsImmutable(), dependency_handle, index + 1, dependencies, lblDone, lblFail);
            }
            _il.MarkLabel(lblElse);
            _il.EmitBranch(ILOpCode.Br, lblFail);
        }

        /// <summary>
        /// Emits <code>throw new Exception(message)</code>
        /// </summary>
        public void EmitThrowException(string message)
        {
            var exception_ctor = CoreTypes.Exception.Ctor(CoreTypes.String);
            _il.EmitStringConstant(message);
            EmitCall(ILOpCode.Newobj, exception_ctor);
            _il.EmitThrow(false);
        }

        /// <summary>
        /// Emits call to main method.
        /// </summary>
        /// <param name="mainmethod">Static Main method representing the script global code.</param>
        /// <returns>Main method result value type.</returns>
        public TypeSymbol EmitCallMain(MethodSymbol mainmethod)
        {
            Contract.ThrowIfNull(mainmethod);
            Debug.Assert(mainmethod.IsStatic);
            Debug.Assert(mainmethod.Name == WellKnownPchpNames.GlobalRoutineName);

            foreach (var p in mainmethod.Parameters)
            {
                switch (p.Name)
                {
                    case SpecialParameterSymbol.ContextName:
                        EmitLoadContext();
                        break;
                    case SpecialParameterSymbol.LocalsName:
                        Debug.Assert(LocalsPlaceOpt != null);
                        LocalsPlaceOpt.EmitLoad(_il);
                        break;
                    case SpecialParameterSymbol.ThisName:
                        EmitThisOrNull();
                        break;
                    case SpecialParameterSymbol.SelfName:
                        this.EmitCallerTypeHandle();
                        break;
                    default:
                        throw ExceptionUtilities.UnexpectedValue(p.Name);
                }
            }

            //
            return EmitCall(ILOpCode.Call, mainmethod);
        }

        public TypeSymbol EmitLoadConstant(object value, TypeSymbol targetOpt = null, bool notNull = false)
        {
            if (value == null)
            {
                if (notNull)
                {
                    // should be reported already
                    // Diagnostics.Add( ... )
                    Debug.Fail("value cannot be null");
                }

                if (targetOpt != null && targetOpt.IsValueType)
                {
                    return EmitLoadDefaultOfValueType(targetOpt);
                }
                else // reference type
                {
                    if (targetOpt == CoreTypes.PhpAlias)
                    {
                        // new PhpAlias(PhpValue.Null)
                        Emit_PhpValue_Null();
                        return Emit_PhpValue_MakeAlias();
                    }
                    else
                    {
                        Builder.EmitNullConstant();
                        return targetOpt ?? CoreTypes.Object;
                    }
                }
            }
            else if (value is int i)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(i != 0);
                        return targetOpt;
                    case SpecialType.System_Int64:
                        _il.EmitLongConstant(i);
                        return targetOpt;
                    case SpecialType.System_Double:
                        _il.EmitDoubleConstant(i);
                        return targetOpt;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(i.ToString());
                        return targetOpt;
                }

                Builder.EmitIntConstant((int)value);
                return CoreTypes.Int32;
            }
            else if (value is long l)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(l != 0);
                        return targetOpt;
                    case SpecialType.System_Int32:
                        _il.EmitIntConstant((int)l);
                        return targetOpt;
                    case SpecialType.System_Double:
                        _il.EmitDoubleConstant(l);
                        return targetOpt;
                    case SpecialType.System_Single:
                        _il.EmitSingleConstant(l);
                        return targetOpt;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(l.ToString());
                        return targetOpt;
                    default:
                        break;
                }

                Builder.EmitLongConstant(l);
                return CoreTypes.Long;
            }
            else if (value is string str)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Char:
                        if (str != null && str.Length == 1)
                        {
                            Builder.EmitCharConstant(str[0]);
                            return targetOpt;
                        }
                        break;
                    case SpecialType.System_Int32:
                        if (int.TryParse(str, out i))
                        {
                            Builder.EmitIntConstant(i);
                            return targetOpt;
                        }
                        break;
                    case SpecialType.System_Int64:
                        if (long.TryParse(str, out l))
                        {
                            Builder.EmitLongConstant(l);
                            return targetOpt;
                        }
                        break;
                    case SpecialType.System_Double:
                        if (double.TryParse(str, out var d))
                        {
                            Builder.EmitDoubleConstant(d);
                            return targetOpt;
                        }
                        break;
                }

                Builder.EmitStringConstant(str);
                return CoreTypes.String;
            }
            else if (value is bool b)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        break;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(b ? "1" : "");
                        return targetOpt;
                    default:
                        if (targetOpt == CoreTypes.PhpValue)
                        {
                            return b ? Emit_PhpValue_True() : Emit_PhpValue_False();
                        }
                        break;
                }

                // template: LOAD bool
                Builder.EmitBoolConstant(b);
                return CoreTypes.Boolean;
            }
            else if (value is double d)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(d != 0.0);
                        return targetOpt;
                    case SpecialType.System_Int64:
                        _il.EmitLongConstant((long)d);
                        return targetOpt;
                }

                Builder.EmitDoubleConstant(d);
                return CoreTypes.Double;
            }
            else if (value is float f)
            {
                Builder.EmitSingleConstant(f);
                return DeclaringCompilation.GetSpecialType(SpecialType.System_Single);
            }
            else if (value is uint)
            {
                Builder.EmitIntConstant(unchecked((int)(uint)value));
                return DeclaringCompilation.GetSpecialType(SpecialType.System_UInt32);
            }
            else if (value is ulong ul)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(ul != 0.0);
                        return targetOpt;
                    case SpecialType.System_Int64:
                        _il.EmitLongConstant((long)ul);
                        return targetOpt;
                    case SpecialType.System_Double:
                        _il.EmitDoubleConstant((double)ul);
                        return targetOpt;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(ul.ToString());
                        return targetOpt;
                }

                _il.EmitLongConstant(unchecked((long)ul));
                return DeclaringCompilation.GetSpecialType(SpecialType.System_UInt64);
            }
            else if (value is char c)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_String:
                        Builder.EmitStringConstant(value.ToString());
                        return targetOpt;
                }

                Builder.EmitCharConstant(c);
                return DeclaringCompilation.GetSpecialType(SpecialType.System_Char);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(value);
            }
        }

        public TypeSymbol EmitLoadDefault(TypeSymbol type, TypeRefMask typemask = default)
        {
            Debug.Assert(type != null);

            switch (type.SpecialType)
            {
                case SpecialType.System_Void:
                    break;
                case SpecialType.System_Double:
                    _il.EmitDoubleConstant(0.0);
                    break;
                case SpecialType.System_Int32:
                    _il.EmitIntConstant(0);
                    break;
                case SpecialType.System_Int64:
                    _il.EmitLongConstant(0);
                    break;
                case SpecialType.System_Boolean:
                    _il.EmitBoolConstant(false);
                    break;
                case SpecialType.System_Char:
                    _il.EmitCharConstant('\0');
                    break;
                default:
                    if (type == CoreTypes.PhpAlias)
                    {
                        // new PhpAlias(void, 1);
                        Emit_PhpValue_Void();
                        Emit_PhpValue_MakeAlias();
                    }
                    //else if (CoreTypes.PhpArray.Symbol.IsOfType(type))
                    //{
                    //    EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpArray);
                    //}
                    //else if (type == CoreTypes.PhpString)
                    //{
                    //    EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpString);
                    //}
                    else if (type.IsReferenceType)
                    {
                        _il.EmitNullConstant();
                    }
                    else
                    {
                        if (type == CoreTypes.PhpValue)
                        {
                            if (typemask.IsSingleType && this.Routine != null)
                            {
                                var typectx = this.TypeRefContext;

                                if (typectx.IsBoolean(typemask))
                                {
                                    Emit_PhpValue_False();
                                    break;
                                }
                                else if (typectx.IsLong(typemask))
                                {
                                    _il.EmitLongConstant(0);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_Long);
                                    break;
                                }
                                else if (typectx.IsDouble(typemask))
                                {
                                    _il.EmitDoubleConstant(0.0);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_Double);
                                    break;
                                }
                                else if (typectx.IsAString(typemask))
                                {
                                    // return ""
                                    _il.EmitStringConstant(string.Empty);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_String);
                                    break;
                                }
                                else if (typectx.IsArray(typemask))
                                {
                                    EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpArray);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_PhpArray);
                                    break;
                                }
                            }
                        }

                        //
                        EmitLoadDefaultOfValueType(type);
                    }
                    break;
            }

            return type;
        }

        /// <summary>
        /// Emits <c>default(valuetype)</c>.
        /// Handles special types with a default ctor.
        /// </summary>
        public TypeSymbol EmitLoadDefaultOfValueType(TypeSymbol valuetype)
        {
            Debug.Assert(valuetype != null && valuetype.IsValueType);

            if (valuetype == CoreTypes.PhpNumber)
            {
                // PhpNumber.Default ~ 0L
                _il.EmitOpCode(ILOpCode.Ldsfld);
                EmitSymbolToken(CoreMethods.PhpNumber.Default, null);
            }
            else if (valuetype == CoreTypes.PhpValue)
            {
                // PhpValue.Null
                Emit_PhpValue_Null();
            }
            else
            {
                // default(T)
                _il.EmitValueDefault(this.Module, this.Diagnostics, this.GetTemporaryLocal(valuetype, true));
            }

            //
            return valuetype;
        }

        public void EmitRetDefault()
        {
            // return default(RETURN_TYPE);

            var return_type = this.Routine.ReturnType;

            EmitLoadDefault(return_type, this.Routine.ResultTypeMask);
            EmitRet(return_type);
        }

        /// <summary>
        /// Emits .ret instruction with sequence point at closing brace.
        /// Eventually emits branching to closing block.
        /// </summary>
        public void EmitRet(TypeSymbol stack, bool yielding = false)
        {
            // sequence point
            var body = AstUtils.BodySpanOrInvalid(Routine?.Syntax);
            if (body.IsValid && EmitPdbSequencePoints)
            {
                EmitSequencePoint(new Span(body.End - 1, 1));
            }

            //
            if (_il.InExceptionHandler || (ExtraFinallyBlock != null && !yielding))
            {
                this.ExitBlock.EmitTmpRet(this, stack, yielding);
            }
            else
            {
                _il.EmitRet(stack.SpecialType == SpecialType.System_Void);
            }
        }

        /// <summary>
        /// Emits <c>place != null</c> expression.
        /// </summary>
        public void EmitNotNull(IPlace place)
        {
            Debug.Assert(place != null);
            Debug.Assert(place.Type.IsReferenceType);

            // {place} != null : boolean
            place.EmitLoad(_il);
            _il.EmitNullConstant();
            _il.EmitOpCode(ILOpCode.Cgt_un);
        }

        /// <summary>
        /// Emits <c>Debug.Assert([<paramref name="place"/>]) in debug compile mode.</c>
        /// </summary>
        /// <param name="place">The variable to emit assertion for.</param>
        /// <param name="messageOpt">Optional second argument for assert.</param>
        public void EmitDebugAssertNotNull(IPlace place, string messageOpt = null)
        {
            if (IsDebug)
            {
                //EmitNotNull(place);
                //EmitDebugAssert(messageOpt);
            }
        }

        /// <summary>
        /// Emits <c>Debug.Assert([stack]).</c>
        /// </summary>
        /// <param name="messageOpt">Optional second argument for assert.</param>
        public void EmitDebugAssert(string messageOpt = null)
        {
            //var dt = this.DeclaringCompilation.GetTypeByMetadataName("System.Diagnostics.Debug"); // System.dll
            //dt.GetMember("Assert")
            throw new NotImplementedException();
        }

        public TypeSymbol EmitDeepCopy(TypeSymbol t, bool nullcheck)
        {
            if (IsCopiable(t))
            {
                object lblnull = null;
                if (nullcheck && t.IsReferenceType)
                {
                    // ?.
                    var lbltrue = new object();
                    lblnull = new object();

                    _il.EmitOpCode(ILOpCode.Dup);
                    _il.EmitBranch(ILOpCode.Brtrue, lbltrue);
                    _il.EmitOpCode(ILOpCode.Pop);
                    _il.EmitNullConstant();
                    _il.EmitBranch(ILOpCode.Br, lblnull);
                    _il.MarkLabel(lbltrue);
                }

                if (t == CoreTypes.PhpValue)
                {
                    EmitPhpValueAddr();
                    t = EmitCall(ILOpCode.Call, CoreMethods.PhpValue.DeepCopy);
                }
                else if (t == CoreTypes.PhpString)
                {
                    Debug.Assert(t.IsStructType());
                    // Template: new PhpString( <STACK> )
                    t = EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpString_PhpString);
                }
                else if (t == CoreTypes.PhpArray)
                {
                    t = EmitCall(ILOpCode.Callvirt, CoreMethods.PhpArray.DeepCopy);
                }
                else
                {
                    throw this.NotImplementedException("copy " + t.Name);
                }

                //
                if (lblnull != null)
                {
                    _il.MarkLabel(lblnull);
                }
            }

            return t;
        }

        /// <summary>
        /// Emits copy of value from top of the stack if necessary.
        /// </summary>
        public TypeSymbol EmitDeepCopy(TypeSymbol t, TypeRefMask thint = default(TypeRefMask))
        {
            if (IsCopiable(thint))
            {
                return EmitDeepCopy(t, thint.IsAnyType || this.TypeRefContext.IsNullOrVoid(thint));
            }
            else
            {
                return t;
            }
        }
    }

    internal static class ILBuilderExtension
    {
        public static void EmitLoadToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, TypeSymbol type, SyntaxNode syntaxNodeOpt)
        {
            il.EmitOpCode(ILOpCode.Ldtoken);
            EmitSymbolToken(il, module, diagnostics, type, syntaxNodeOpt);
        }

        public static void EmitLoadToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, MethodSymbol method, SyntaxNode syntaxNodeOpt)
        {
            il.EmitOpCode(ILOpCode.Ldtoken);
            EmitSymbolToken(il, module, diagnostics, method, syntaxNodeOpt);
        }

        public static void EmitSymbolToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, TypeSymbol symbol, SyntaxNode syntaxNode)
        {
            il.EmitToken(module.Translate(symbol, syntaxNode, diagnostics), syntaxNode, diagnostics);
        }

        public static void EmitSymbolToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, MethodSymbol symbol, SyntaxNode syntaxNode)
        {
            il.EmitToken(module.Translate(symbol, syntaxNode, diagnostics, needDeclaration: false), syntaxNode, diagnostics);
        }

        public static void EmitSymbolToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, FieldSymbol symbol, SyntaxNode syntaxNode)
        {
            il.EmitToken(module.Translate(symbol, syntaxNode, diagnostics), syntaxNode, diagnostics);
        }

        public static void EmitValueDefault(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, LocalDefinition tmp)
        {
            Debug.Assert(tmp.Type.IsValueType);
            il.EmitLocalAddress(tmp);
            il.EmitOpCode(ILOpCode.Initobj);
            il.EmitSymbolToken(module, diagnostics, (TypeSymbol)tmp.Type, null);
            // ldloc <loc>
            il.EmitLocalLoad(tmp);
        }

        /// <summary>
        /// Gets addr of a default value. Used to call a method on default value.
        /// </summary>
        public static void EmitValueDefaultAddr(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, LocalDefinition tmp)
        {
            Debug.Assert(tmp.Type.IsValueType);
            il.EmitLocalAddress(tmp);
            il.EmitOpCode(ILOpCode.Initobj);
            il.EmitSymbolToken(module, diagnostics, (TypeSymbol)tmp.Type, null);
            // ldloca <loc>
            il.EmitLocalAddress(tmp);
        }

        /// <summary>
        /// Gets or create a local variable and returns it back to pool.
        /// </summary>
        public static LocalDefinition GetTemporaryLocalAndReturn(this ILBuilder il, TypeSymbol t)
        {
            var definition = il.LocalSlotManager.AllocateSlot((Microsoft.Cci.ITypeReference)t, LocalSlotConstraints.None);

            il.LocalSlotManager.FreeSlot(definition);

            return definition;
        }

        /// <summary>
        /// Copies a value type from the top of evaluation stack into a temporary variable and loads its address.
        /// </summary>
        public static void EmitStructAddr(this ILBuilder il, TypeSymbol t)
        {
            Debug.Assert(t.IsStructType());

            var tmp = GetTemporaryLocalAndReturn(il, t);
            il.EmitLocalStore(tmp);
            il.EmitLocalAddress(tmp);
        }

        /// <summary>
        /// Emits call to given method.
        /// </summary>
        /// <returns>Method return type.</returns>
        public static TypeSymbol EmitCall(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, ILOpCode code, MethodSymbol method)
        {
            Contract.ThrowIfNull(method);
            Debug.Assert(code == ILOpCode.Call || code == ILOpCode.Calli || code == ILOpCode.Callvirt || code == ILOpCode.Newobj);
            Debug.Assert(!method.IsErrorMethodOrNull());

            var stack = method.GetCallStackBehavior();

            if (code == ILOpCode.Newobj)
            {
                stack += 1 + 1;    // there is no <this>, + it pushes <newinst> on stack
            }

            if (code == ILOpCode.Callvirt && !method.IsAbstract && (!method.IsVirtual || method.IsSealed || method.ContainingType.IsSealed))
            {
                code = ILOpCode.Call; // virtual dispatch is unnecessary
            }

            il.EmitOpCode(code, stack);
            il.EmitToken(module.Translate(method, diagnostics, false), null, diagnostics);
            return (code == ILOpCode.Newobj) ? method.ContainingType : method.ReturnType;
        }

        public static void EmitCharConstant(this ILBuilder il, char value)
        {
            il.EmitIntConstant(unchecked((int)value));
        }

        public static TypeSymbol EmitLoad(this ParameterSymbol p, ILBuilder il)
        {
            Debug.Assert(p != null, nameof(p));

            var index = p.Ordinal;
            var hasthis = ((MethodSymbol)p.ContainingSymbol).HasThis ? 1 : 0;

            il.EmitLoadArgumentOpcode(index + hasthis);
            return p.Type;
        }

        public static TypeSymbol EmitLoad(this FieldSymbol f, CodeGenerator cg, IPlace holder = null)
        {
            Debug.Assert(f != null, nameof(f));

            if (!f.IsStatic)
            {
                // {holder}
                Debug.Assert(holder != null);
                VariableReferenceExtensions.EmitReceiver(cg.Builder, holder);
            }

            // .ldfld/.ldsfld {f}
            cg.Builder.EmitOpCode(f.IsStatic ? ILOpCode.Ldsfld : ILOpCode.Ldfld);
            cg.Builder.EmitToken(cg.Module.Translate(f, null, DiagnosticBag.GetInstance()), null, DiagnosticBag.GetInstance());

            //
            return f.Type;
        }
    }
}

---- Transformed Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Devsense.PHP.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeGen;
using Microsoft.CodeAnalysis.Emit;
using Pchp.CodeAnalysis.Emit;
using Pchp.CodeAnalysis.Errors;
using Pchp.CodeAnalysis.FlowAnalysis;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using Pchp.CodeAnalysis.Symbols;
using Peachpie.CodeAnalysis.Errors;
using Peachpie.CodeAnalysis.Symbols;
using Peachpie.CodeAnalysis.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;

namespace Pchp.CodeAnalysis.CodeGen
{
    partial class CodeGenerator
    {
        /// <summary>
        /// Emits <c>context</c> onto the evaluation stack.
        /// </summary>
        public TypeSymbol EmitLoadContext()
        {
            if (_contextPlace == null)
                throw new InvalidOperationException("Context is not available.");

            return _contextPlace.EmitLoad(_il);
        }

        /// <summary>
        /// Gets <see cref="IPlace"/> of current <c>Context</c>.
        /// </summary>
        public IPlace ContextPlaceOpt => _contextPlace;

        /// <summary>
        /// Emits <c>RuntimeTypeHandle</c> of current class context.
        /// </summary>
        public TypeSymbol EmitCallerTypeHandle()
        {
            var caller = this.CallerType;
            if (caller != null)
            {
                // RuntimeTypeHandle
                EmitLoadToken(caller, null);
            }
            else
            {
                var place = RuntimeCallerTypePlace;
                if (place != null)
                {
                    place.EmitLoad(_il).Expect(CoreTypes.RuntimeTypeHandle);
                }
                else
                {
                    // default(RuntimeTypeHandle)
                    EmitLoadDefaultOfValueType(this.CoreTypes.RuntimeTypeHandle);
                }
            }

            //
            return CoreTypes.RuntimeTypeHandle;
        }

        /// <summary>
        /// In case current routine has a caller context provided in runtime,
        /// gets its <see cref="IPlace"/>.
        /// </summary>
        public IPlace RuntimeCallerTypePlace
        {
            get
            {
                if (_callerTypePlace == null)
                {
                    if (GeneratorStateMachineMethod != null)
                    {
                        if (this.Routine is SourceLambdaSymbol)
                        {
                            // Operator.GetGeneratorDynamicScope(g)
                            _callerTypePlace = new OperatorPlace(
                                CoreTypes.Operators.Method("GetGeneratorDynamicScope", CoreTypes.Generator),
                                new ParamPlace(GeneratorStateMachineMethod.GeneratorParameter));
                        }
                        // otherwise the caller type is resolve statically already
                    }
                    else if (this.Routine is SourceGlobalMethodSymbol global)
                    {
                        _callerTypePlace = new ParamPlace(global.SelfParameter);
                    }
                    else if (this.Routine is SourceLambdaSymbol lambda)
                    {
                        _callerTypePlace = lambda.GetCallerTypePlace();
                    }
                }

                return _callerTypePlace;
            }
            set
            {
                _callerTypePlace = value;
            }
        }

        /// <summary>
        /// Gets place referring to array of unoptimized local variables.
        /// Always valid in context of global scope.
        /// </summary>
        public IPlace LocalsPlaceOpt => _localsPlaceOpt;

        /// <summary>
        /// Gets place referring to compiler generated temporal variables.
        /// </summary>
        /// <remarks>
        /// Must not be null for methods that contain any synthesized variables.
        /// </remarks>
        public IPlace TemporalLocalsPlace => _tmpLocalsPlace;

        /// <summary>
        /// Gets value indicating the routine uses unoptimized locals access.
        /// This means, all the local variables are stored within an associative array instead of local slots.
        /// This value implicates, <see cref="LocalsPlaceOpt"/> is not <c>null</c>.
        /// </summary>
        public bool HasUnoptimizedLocals => LocalsPlaceOpt != null;

        /// <summary>
        /// Gets value indicating the routine has locals already inicialized. 
        /// </summary>
        public bool InitializedLocals => _localsInitialized;

        /// <summary>
        /// Emits reference to <c>this</c>.
        /// </summary>
        /// <returns>Type of <c>this</c> in current context, pushed on top of the evaluation stack.</returns>
        public TypeSymbol EmitThis()
        {
            Contract.ThrowIfNull(_thisPlace);
            return EmitThisOrNull();
        }

        public TypeSymbol EmitThisOrNull()
        {
            if (_thisPlace == null)
            {
                _il.EmitNullConstant();
                return CoreTypes.Object;
            }
            else
            {
                return _thisPlace.EmitLoad(_il);
            }
        }

        /// <summary>
        /// Emits value of <c>$this</c>.
        /// Available only within source routines.
        /// In case no $this is available, nothing is emitted and function returns <c>null</c> reference.
        /// </summary>
        TypeSymbol EmitPhpThis()
        {
            if (GeneratorStateMachineMethod != null)
            {
                return GeneratorStateMachineMethod.ThisParameter.EmitLoad(_il);
            }

            if (Routine != null)
            {
                if (Routine.IsGeneratorMethod())
                {
                    // but GeneratorStateMachineMethod == null; We're not emitting SM yet
                    Debug.Fail("$this not resolved");
                }

                //
                var thisplace = Routine.GetPhpThisVariablePlace(this.Module);
                if (thisplace != null)
                {
                    return thisplace.EmitLoad(_il);
                }
            }

            //
            return null;
        }

        /// <summary>
        /// Emits value of <c>$this</c>.
        /// Available only within source routines.
        /// In case no $this is available, <c>NULL</c> is loaded on stack instead.
        /// </summary>
        public TypeSymbol EmitPhpThisOrNull()
        {
            var t = EmitPhpThis();
            if (t == null)
            {
                _il.EmitNullConstant();
                t = CoreTypes.Object;
            }

            return t;
        }

        public TypeSymbol EmitGeneratorInstance()
        {
            Contract.ThrowIfNull(this.GeneratorStateMachineMethod);
            // .ldarg <generator>
            return this.GeneratorStateMachineMethod.GeneratorParameter.EmitLoad(_il);
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps most specific type from give variable without a runtime type check.
        /// </summary>
        internal TypeSymbol TryEmitVariableSpecialize(BoundExpression expr)
        {
            Debug.Assert(expr.Access.IsRead);

            if (!expr.Access.IsEnsure && !expr.TypeRefMask.IsAnyType && !expr.TypeRefMask.IsRef)
            {
                // avoiding of load of full value if not necessary
                return TryEmitVariableSpecialize(PlaceOrNull(expr), expr.TypeRefMask);
            }
            else
            {
                // we have to call expr.Emit() to generate ensureness correctly (Ensure Object, Ensure Array, Read Alias)
                return null;
            }
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps most specific type from give variable without a runtime type check.
        /// </summary>
        internal TypeSymbol TryEmitVariableSpecialize(IPlace place, TypeRefMask tmask)
        {
            if (place != null && tmask.IsSingleType && !tmask.IsRef)
            {
                //if (tmask.IsSingleType && TypeRefContext.IsNull(tmask))
                //{
                //    // NULL
                //    _il.EmitNullConstant();
                //    return;
                //}

                if (place.HasAddress)
                {
                    if (place.Type == CoreTypes.PhpNumber)
                    {
                        // access directly without type checking
                        if (IsDoubleOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpNumber.get_Double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (IsLongOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpNumber.get_Long)
                                .Expect(SpecialType.System_Int64);
                        }
                    }
                    else if (place.Type == CoreTypes.PhpValue)
                    {
                        // access directly without type checking
                        if (IsDoubleOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Double.Getter)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (IsLongOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Long.Getter)
                                .Expect(SpecialType.System_Int64);
                        }
                        else if (IsBooleanOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Boolean.Getter)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (IsReadonlyStringOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.String.Getter)
                                .Expect(SpecialType.System_String);
                        }
                        //else if (IsArrayOnly(tmask))
                        //{
                        //    place.EmitLoadAddress(_il);
                        //    return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.get_Array)    NOTE!! PhpValue.Array is PhpArray
                        //        .Expect(CoreTypes.IPhpArray);
                        //}
                        else if (IsClassOnly(tmask))
                        {
                            place.EmitLoadAddress(_il);
                            EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Object.Getter)
                                .Expect(SpecialType.System_Object);

                            if (tmask.IsSingleType)
                            {
                                var tref = this.TypeRefContext.GetTypes(tmask).FirstOrDefault();
                                var clrtype = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);
                                if (clrtype.IsValidType() && !clrtype.IsObjectType())
                                {
                                    this.EmitCastClass(clrtype);
                                    return clrtype;
                                }
                            }

                            return this.CoreTypes.Object;
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps more specific type from a value currently on stack without a runtime type check.
        /// </summary>
        /// <returns>New type on top of evaluation stack.</returns>
        internal TypeSymbol EmitSpecialize(BoundExpression expr)
        {
            // load resulting value directly if resolved:
            if (expr.ConstantValue.HasValue && !expr.Access.IsEnsure)
            {
                if (expr.Access.IsNone)
                {
                    return expr.ResultType = CoreTypes.Void;
                }

                if (expr.Access.IsRead)
                {
                    return expr.ResultType = EmitLoadConstant(expr.ConstantValue.Value, expr.Access.TargetType);
                }
            }

            //
            if (expr.Access.IsNone) // no need for specializing, the value won't be read anyway
            {
                return (expr.ResultType = expr.Emit(this));
            }
            else
            {
                Debug.Assert(expr.Access.IsRead);

                return expr.ResultType = (TryEmitVariableSpecialize(expr) ?? EmitSpecialize(expr.Emit(this), expr.TypeRefMask));
            }
        }

        /// <summary>
        /// If possible, based on type analysis, unwraps more specific type from a value currently on stack without a runtime type check.
        /// </summary>
        /// <param name="stack">Type of value currently on top of evaluationb stack.</param>
        /// <param name="tmask">Result of analysis what type will be there in runtime.</param>
        /// <returns>New type on top of evaluation stack.</returns>
        internal TypeSymbol EmitSpecialize(TypeSymbol stack, TypeRefMask tmask)
        {
            Debug.Assert(!stack.IsUnreachable);

            // specialize type if possible
            if (tmask.IsSingleType && !tmask.IsRef)
            {
                if (stack == this.CoreTypes.PhpNumber)
                {
                    if (IsDoubleOnly(tmask))
                    {
                        EmitPhpNumberAddr();
                        return EmitCall(ILOpCode.Call, this.CoreMethods.PhpNumber.get_Double)
                            .Expect(SpecialType.System_Double);
                    }
                    else if (IsLongOnly(tmask))
                    {
                        EmitPhpNumberAddr();
                        return EmitCall(ILOpCode.Call, this.CoreMethods.PhpNumber.get_Long)
                            .Expect(SpecialType.System_Int64);
                    }
                }
                else if (stack == CoreTypes.PhpValue)
                {
                    // access directly without type checking
                    if (IsDoubleOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Double.Getter)
                            .Expect(SpecialType.System_Double);
                    }
                    else if (IsLongOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Long.Getter)
                            .Expect(SpecialType.System_Int64);
                    }
                    else if (IsBooleanOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Boolean.Getter)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (IsReadonlyStringOnly(tmask))
                    {
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.String.Getter)
                            .Expect(SpecialType.System_String);
                    }
                }
                else if (stack.Is_PhpArray() || stack.IsStringType())
                {
                    // already specialied reference types
                }
                else if (stack.IsReferenceType && !stack.IsSealed && this.Routine != null)
                {
                    var tref = this.TypeRefContext.GetTypes(tmask).FirstOrDefault();
                    if (tref.IsObject)
                    {
                        // naive IL beutifier,
                        // that casts a reference type to its actual type that we determined in type analysis

                        var t = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);
                        if (t == stack)
                        {
                            return stack;
                        }

                        if (t.IsValidType())
                        {
                            if (stack.IsTypeParameter() || t.IsOfType(stack))
                            {
                                EmitCastClass(t);
                                return t;
                            }
                        }
                        else
                        {
                            // TODO: class aliasing
                            Debug.WriteLine($"'{tref}' is {(t is AmbiguousErrorTypeSymbol ? "ambiguous" : "unknown")}!");
                        }
                    }
                }
            }

            //
            return stack;
        }

        public void EmitOpCode(ILOpCode code) => _il.EmitOpCode(code);

        public void EmitPop(TypeSymbol type)
        {
            Contract.ThrowIfNull(type);

            if (type.SpecialType != SpecialType.System_Void)
            {
                _il.EmitOpCode(ILOpCode.Pop, -1);
            }
        }

        public TypeSymbol Emit(BoundExpression expr)
        {
            Contract.ThrowIfNull(expr);

            var t = EmitSpecialize(expr);
            if (t == null)
            {
                throw ExceptionUtilities.UnexpectedValue(null);
            }

            return t;
        }

        /// <summary>
        /// Loads <see cref="RuntimeTypeHandle"/> of given type.
        /// </summary>
        public TypeSymbol EmitLoadToken(TypeSymbol type, SyntaxNode syntaxNodeOpt)
        {
            if (type.IsValidType())
            {
                _il.EmitLoadToken(_moduleBuilder, _diagnostics, type, syntaxNodeOpt);
            }
            else
            {
                EmitLoadDefaultOfValueType(this.CoreTypes.RuntimeTypeHandle);
            }

            return this.CoreTypes.RuntimeTypeHandle;
        }

        /// <summary>
        /// Loads <see cref="RuntimeMethodHandle"/> of given method.
        /// </summary>
        public TypeSymbol EmitLoadToken(MethodSymbol method, SyntaxNode syntaxNodeOpt)
        {
            _il.EmitLoadToken(_moduleBuilder, _diagnostics, method, syntaxNodeOpt);

            return this.CoreTypes.RuntimeMethodHandle;
        }

        public void EmitBox(TypeSymbol valuetype)
        {
            Contract.ThrowIfNull(valuetype);

            if (valuetype.IsValueType)
            {
                _il.EmitOpCode(ILOpCode.Box);
                EmitSymbolToken(valuetype, null);
            }
        }

        /// <summary>
        /// Emits "!= 0" operation. This method expects I4 value on top of evaluation stack.
        /// </summary>
        public void EmitLogicNegation()
        {
            _il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
            _il.EmitOpCode(ILOpCode.Ceq);
        }

        /// <summary>
        /// Emits check if type on top of the stack is null.
        /// Results in boolean (<c>i4</c>) with value of <c>0</c> or <c>1</c> on top of the stack.
        /// </summary>
        public void EmitNotNull(TypeSymbol t, TypeRefMask tmask)
        {
            Debug.Assert(!t.IsUnreachable);
            // CanBeNull(tmask)
            // CanBeNull(t)

            // t != null
            if (t.IsReferenceType)
            {
                // != null
                _il.EmitNullConstant();
                _il.EmitOpCode(ILOpCode.Cgt_un);
                return;
            }

            // PhpAlias.Value
            if (t == CoreTypes.PhpAlias)
            {
                // dereference
                t = Emit_PhpAlias_GetValue();
                // continue ->
            }

            // IsSet(PhpValue) ~ !IsNull
            if (t == CoreTypes.PhpValue)
            {
                EmitCall(ILOpCode.Call, CoreMethods.Operators.IsSet_PhpValue);
                return;
            }

            // cannot be null:
            Debug.Assert(!CanBeNull(t));
            EmitPop(t);
            _il.EmitBoolConstant(false);
        }

        /// <summary>
        /// Loads field address on top of evaluation stack.
        /// </summary>
        public void EmitFieldAddress(FieldSymbol fld)
        {
            Debug.Assert(fld != null);

            _il.EmitOpCode(fld.IsStatic ? ILOpCode.Ldsflda : ILOpCode.Ldflda);
            EmitSymbolToken(fld, null);
        }

        internal void EmitSymbolToken(TypeSymbol symbol, SyntaxNode syntaxNode)
        {
            _il.EmitSymbolToken(_moduleBuilder, _diagnostics, symbol, syntaxNode);
        }

        internal void EmitSymbolToken(FieldSymbol symbol, SyntaxNode syntaxNode)
        {
            _il.EmitSymbolToken(_moduleBuilder, _diagnostics, symbol, syntaxNode);
        }

        internal void EmitSymbolToken(MethodSymbol method, SyntaxNode syntaxNode)
        {
            _il.EmitSymbolToken(_moduleBuilder, _diagnostics, method, syntaxNode);
        }

        /// <summary>
        /// Emits <c>typeof(symbol) : System.Type</c>.
        /// </summary>
        internal TypeSymbol EmitSystemType(TypeSymbol symbol)
        {
            // ldtoken !!T
            EmitLoadToken(symbol, null);

            // call class System.Type System.Type::GetTypeFromHandle(valuetype System.RuntimeTypeHandle)
            return EmitCall(ILOpCode.Call, (MethodSymbol)DeclaringCompilation.GetWellKnownTypeMember(WellKnownMember.System_Type__GetTypeFromHandle));
        }

        internal void EmitHiddenSequencePoint()
        {
            if (EmitPdbSequencePoints)
            {
                _il.DefineHiddenSequencePoint();
            }
        }

        internal void EmitSequencePoint(LangElement element)
        {
            if (element != null)
            {
                EmitSequencePoint(element.Span);
            }
        }
        internal void EmitSequencePoint(Span span)
        {
            if (EmitPdbSequencePoints && span.IsValid && !span.IsEmpty)
            {
                EmitSequencePoint(span.ToTextSpan());
            }
        }

        internal void EmitSequencePoint(Microsoft.CodeAnalysis.Text.TextSpan span)
        {
            if (EmitPdbSequencePoints && span.Length > 0)
            {
                _il.DefineSequencePoint(ContainingFile.SyntaxTree, span);
                _il.EmitOpCode(ILOpCode.Nop);
            }
        }

        public TypeSymbol EmitDereference(TypeSymbol t)
        {
            if (t == CoreTypes.PhpAlias)
            {
                // Template: <alias>.Value
                return this.Emit_PhpAlias_GetValue();
            }
            else if (t == CoreTypes.PhpValue)
            {
                // Template: <value>.GetValue()
                this.EmitPhpValueAddr();
                return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.GetValue);
            }
            else
            {
                // value already dereferenced
                return t;
            }
        }

        /// <summary>
        /// GetPhpTypeInfo&lt;T&gt;() : PhpTypeInfo
        /// </summary>
        public TypeSymbol EmitLoadPhpTypeInfo(ITypeSymbol t)
        {
            Contract.ThrowIfNull(t);

            // CALL GetPhpTypeInfo<T>()
            return EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_T.Symbol.Construct(t));
        }

        /// <summary>
        /// Emits <c>PhpTypeInfo</c> of late static bound type.
        /// </summary>
        /// <returns>
        /// Type symbol of <c>PhpTypeInfo</c>.
        /// </returns>
        public TypeSymbol EmitLoadStaticPhpTypeInfo()
        {
            if (Routine != null)
            {
                if (GeneratorStateMachineMethod != null)
                {
                    this.EmitGeneratorInstance(); // LOAD Generator
                    return this.EmitCall(ILOpCode.Call, CoreMethods.Operators.GetGeneratorLazyStatic_Generator)
                        .Expect(CoreTypes.PhpTypeInfo);
                }

                if (Routine is SourceLambdaSymbol lambda)
                {
                    // Handle lambda since $this can be null (unbound)
                    // Template: CLOSURE.Static();
                    lambda.ClosureParameter.EmitLoad(Builder);
                    return EmitCall(ILOpCode.Call, CoreMethods.Operators.Static_Closure)
                        .Expect(CoreTypes.PhpTypeInfo);
                }

                var thisVariablePlace = Routine.GetPhpThisVariablePlace(Module);
                if (thisVariablePlace != null)
                {
                    // Template: GetPhpTypeInfo(this)
                    thisVariablePlace.EmitLoad(Builder);
                    return EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_Object);
                }

                var lateStaticParameter = Routine.LateStaticParameter();
                if (lateStaticParameter != null)
                {
                    // Template: LOAD @static   // ~ @static parameter passed by caller
                    return lateStaticParameter
                        .EmitLoad(Builder)
                        .Expect(CoreTypes.PhpTypeInfo);
                }

                var caller = CallerType;
                if (caller is SourceTypeSymbol srct && srct.IsSealed)
                {
                    // `static` == `self` <=> self is sealed
                    // Template: GetPhpTypeInfo<CallerType>()
                    return EmitLoadPhpTypeInfo(caller);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Loads <c>PhpTypeInfo</c> of <c>self</c>.
        /// </summary>
        /// <param name="throwOnError">Whether to expect only valid scope.</param>
        /// <returns>Type symbol of PhpTypeInfo.</returns>
        public TypeSymbol EmitLoadSelf(bool throwOnError = false)
        {
            var caller = CallerType;
            if (caller != null)
            {
                // current scope is resolved in compile-time:
                // Template: GetPhpTypeInfo<CallerType>()
                return EmitLoadPhpTypeInfo(caller);
            }
            else
            {
                // Template: Operators.GetSelf( {caller type handle} )
                EmitCallerTypeHandle();
                return EmitCall(ILOpCode.Call, throwOnError
                    ? CoreMethods.Operators.GetSelf_RuntimeTypeHandle
                    : CoreMethods.Operators.GetSelfOrNull_RuntimeTypeHandle);
            }
        }

        /// <summary>
        /// Loads <c>PhpTypeInfo</c> of current scope's <c>parent</c> class;
        /// </summary>
        /// <returns>
        /// Type symbol of <c>PhpTypeInfo</c>.
        /// </returns>
        public TypeSymbol EmitLoadParent()
        {
            var caller = CallerType;
            if (caller != null)
            {
                // current scope is resolved in compile-time:
                // Template: Operators.GetParent( GetPhpTypeInfo<CallerType>() )
                EmitLoadPhpTypeInfo(caller);
                return EmitCall(ILOpCode.Call, CoreMethods.Operators.GetParent_PhpTypeInfo);
            }
            else
            {
                // Template: Operators.GetParent( {caller type handle} )
                EmitCallerTypeHandle();
                return EmitCall(ILOpCode.Call, CoreMethods.Operators.GetParent_RuntimeTypeHandle);
            }
        }

        /// <summary>
        /// Emits load of <c>PhpAlias.Value</c>,
        /// expecting <c>PhpAlias</c> on top of evaluation stack,
        /// pushing <c>PhpValue</c> on top of the stack.
        /// </summary>
        public TypeSymbol Emit_PhpAlias_GetValue()
        {
            // CALL <stack>.get_Value()
            return EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.Value.Getter);
        }

        /// <summary>
        /// Emits store to <c>PhpAlias.Value</c>,
        /// expecting <c>PhpAlias</c> and <c>PhpValue</c> on top of evaluation stack.
        /// </summary>
        public void Emit_PhpAlias_SetValue()
        {
            // <stack_1>.Value = <stack_2>
            EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.Value.Setter);
        }

        /// <summary>
        /// Emits <c>new PhpAlias</c>, expecting <c>PhpValue</c> on top of the evaluation stack.
        /// </summary>
        public TypeSymbol Emit_PhpValue_MakeAlias()
        {
            //// new PhpAlias(<STACK>, 1)
            //_il.EmitIntConstant(1);
            //return EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpAlias_PhpValue_int);

            // PhpAlias.Create( <STACK> )
            return EmitCall(ILOpCode.Call, CoreMethods.PhpAlias.Create_PhpValue);
        }

        /// <summary>
        /// Emits load of PhpValue representing void.
        /// </summary>
        public TypeSymbol Emit_PhpValue_Void() => Emit_PhpValue_Null();

        /// <summary>
        /// Emits load of PhpValue representing null.
        /// </summary>
        public TypeSymbol Emit_PhpValue_Null()
        {
            _il.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpValue.Null, null);
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Emits load of PhpValue representing true.
        /// </summary>
        public TypeSymbol Emit_PhpValue_True()
        {
            _il.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpValue.True, null);
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Emits load of PhpValue representing false.
        /// </summary>
        public TypeSymbol Emit_PhpValue_False()
        {
            _il.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpValue.False, null);
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Creates new empty <c>PhpArray</c> where modifications are not expected.
        /// </summary>
        public TypeSymbol Emit_PhpArray_NewEmpty()
        {
            // PhpArray.NewEmpty()
            var t = CoreTypes.PhpArray.Symbol;
            return EmitCall(ILOpCode.Call, (MethodSymbol)t.GetMembers("NewEmpty").Single());
        }

        /// <summary>
        /// Emits LOAD of <c>PhpArray.Empty</c> fields.
        /// The loaded value must not be modified, use only in read-only context.
        /// </summary>
        public TypeSymbol Emit_PhpArray_Empty()
        {
            // PhpArray.Empty
            Builder.EmitOpCode(ILOpCode.Ldsfld);
            EmitSymbolToken(CoreMethods.PhpArray.Empty, null);

            return CoreMethods.PhpArray.Empty.Symbol.Type
                .Expect(CoreTypes.PhpArray);
        }

        public void Emit_NewArray(TypeSymbol elementType, ImmutableArray<BoundArgument> values) => Emit_NewArray(elementType, values, a => Emit(a.Value));
        public void Emit_NewArray(TypeSymbol elementType, ImmutableArray<BoundExpression> values) => Emit_NewArray(elementType, values, a => Emit(a));

        public TypeSymbol Emit_NewArray<T>(TypeSymbol elementType, ImmutableArray<T> values, Func<T, TypeSymbol> emitter)
        {
            if (values.IsDefaultOrEmpty == false)
            {
                // new []
                _il.EmitIntConstant(values.Length);
                _il.EmitOpCode(ILOpCode.Newarr);
                EmitSymbolToken(elementType, null);

                // { argI, ..., argN }
                for (int i = 0; i < values.Length; i++)
                {
                    _il.EmitOpCode(ILOpCode.Dup);   // <array>
                    _il.EmitIntConstant(i);         // [i]
                    EmitConvert(emitter(values[i]), 0, elementType);
                    _il.EmitOpCode(ILOpCode.Stelem);
                    EmitSymbolToken(elementType, null);
                }

                // T[]
                return ArrayTypeSymbol.CreateSZArray(this.DeclaringCompilation.SourceAssembly, elementType);
            }
            else
            {
                // empty array
                return Emit_EmptyArray(elementType);
            }
        }

        /// <summary>Template: <code>Array.Empty&lt;elementType&gt;()</code></summary>
        /// <param name="elementType"></param>
        /// <returns></returns>
        internal TypeSymbol Emit_EmptyArray(TypeSymbol elementType)
        {
            // Array.Empty<elementType>()
            var array_empty_T = ((MethodSymbol)this.DeclaringCompilation.GetWellKnownTypeMember(WellKnownMember.System_Array__Empty))
                .Construct(elementType);

            return EmitCall(ILOpCode.Call, array_empty_T);
        }

        /// <summary>
        /// Emits array of <paramref name="elementType"/> containing all current routine PHP arguments value.
        /// </summary>
        internal TypeSymbol Emit_ArgsArray(TypeSymbol elementType)
        {
            var routine = this.Routine ?? throw this.NotImplementedException(nameof(Routine));

            if (routine.IsGlobalScope)
            {
                // NOTE: this produces warning: Called from the global scope - no function context
                _il.EmitNullConstant();
                return ArrayTypeSymbol.CreateSZArray(DeclaringCompilation.SourceAssembly, CoreTypes.PhpValue);
            }

            if (routine.IsGeneratorMethod())
            {
                Debug.Assert(LocalsPlaceOpt != null);
                Debug.Assert(LocalsPlaceOpt.Type == CoreTypes.PhpArray);

                // TODO: this is not correct for varargs
                // <locals> does not contain all the parameters,
                // also it contains all the default values which should not be in listed here
                Debug.Fail("varargs in Generator has an incorrect behavior");

                // args = <locals>.GetValues();
                LocalsPlaceOpt.EmitLoad(_il);
                return EmitCall(ILOpCode.Call, CoreTypes.PhpHashtable.Method("GetValues"));
            }

            TypeSymbol arrtype;

            // [implicit] [use parameters, source parameters] [... varargs]

            var variadic = routine.GetParamsParameter();  // optional params
            var variadic_element = (variadic?.Type as ArrayTypeSymbol)?.ElementType;
            var variadic_place = variadic != null ? new ParamPlace(variadic) : null;

            // get used source parameters:
            var ps = routine.SourceParameters
                .Skip(routine is SourceLambdaSymbol lambda ? lambda.UseParams.Count : 0)    // without lambda use parameters
                .TakeWhile(x => variadic != null ? x.Ordinal < variadic.Ordinal : true)     // up to the params parameter (handled separately)
                .ToArray();

            if (ps.Length == 0 && variadic == null)
            {
                // empty array
                return Emit_EmptyArray(elementType);
            }
            else if (ps.Length == 0 && variadic_element == elementType)
            {
                // == params
                arrtype = variadic_place.EmitLoad(_il);
            }
            else
            {
                arrtype = ArrayTypeSymbol.CreateSZArray(this.DeclaringCompilation.SourceAssembly, elementType);

                // COUNT: (N + params.Length)
                _il.EmitIntConstant(ps.Length);

                if (variadic_place != null)
                {
                    // + params.Length
                    variadic_place.EmitLoad(_il);
                    EmitArrayLength();
                    _il.EmitOpCode(ILOpCode.Add);
                }

                // new [<COUNT>]
                _il.EmitOpCode(ILOpCode.Newarr);
                EmitSymbolToken(elementType, null);

                // tmparr = <array>
                var tmparr = this.GetTemporaryLocal(arrtype);
                _il.EmitLocalStore(tmparr);

                // { p1, .., pN }
                for (int i = 0; i < ps.Length; i++)
                {
                    _il.EmitLocalLoad(tmparr);      // <array>
                    _il.EmitIntConstant(i);         // [i]
                    EmitConvert(ps[i].EmitLoad(_il), 0, elementType);
                    _il.EmitOpCode(ILOpCode.Stelem);
                    EmitSymbolToken(elementType, null);
                }

                if (variadic != null)
                {
                    // { params[0, .., paramsN] }

                    // Template: for (i = 0; i < params.Length; i++) <array>[i + N] = params[i]

                    var lbl_block = new object();
                    var lbl_cond = new object();

                    // i = 0
                    var tmpi = GetTemporaryLocal(CoreTypes.Int32);
                    _il.EmitIntConstant(0);
                    _il.EmitLocalStore(tmpi);
                    _il.EmitBranch(ILOpCode.Br, lbl_cond);

                    // {body}
                    _il.MarkLabel(lbl_block);

                    // <array>[i+N] = (T)params[i]
                    _il.EmitLocalLoad(tmparr);   // <array>
                    _il.EmitIntConstant(ps.Length);
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitOpCode(ILOpCode.Add);

                    variadic_place.EmitLoad(_il);
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitOpCode(ILOpCode.Ldelem);
                    EmitSymbolToken(variadic_element, null);
                    EmitConvert(variadic_element, 0, elementType);

                    _il.EmitOpCode(ILOpCode.Stelem);
                    EmitSymbolToken(elementType, null);

                    // i++
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitIntConstant(1);
                    _il.EmitOpCode(ILOpCode.Add);
                    _il.EmitLocalStore(tmpi);

                    // i < params.Length
                    _il.MarkLabel(lbl_cond);
                    _il.EmitLocalLoad(tmpi);
                    variadic_place.EmitLoad(_il);
                    EmitArrayLength();
                    _il.EmitOpCode(ILOpCode.Clt);
                    _il.EmitBranch(ILOpCode.Brtrue, lbl_block);

                    //
                    ReturnTemporaryLocal(tmpi);
                }

                // <array>
                _il.EmitLocalLoad(tmparr);   // <array>

                //
                ReturnTemporaryLocal(tmparr);
                tmparr = null;
            }

            //
            return arrtype;
        }

        /// <summary>
        /// Emits <c>PhpValue[]</c> containing given <paramref name="args"/>.
        /// Argument unpacking is taken into account and flatterned.
        /// </summary>
        internal void Emit_ArgumentsIntoArray(ImmutableArray<BoundArgument> args, PhpSignatureMask byrefargs)
        {
            if (args.Length == 0)
            {
                Emit_EmptyArray(CoreTypes.PhpValue);
            }
            else if (args.Last().IsUnpacking)   // => handle unpacking   // last argument must be unpacking otherwise unpacking is not allowed anywhere else
            {
                UnpackArgumentsIntoArray(args, byrefargs);
            }
            else
            {
                Emit_NewArray(CoreTypes.PhpValue, args);
            }
        }

        /// <summary>
        /// Emits <c>PhpValue[]</c> containing given <paramref name="args"/>.
        /// Argument unpacking is taken into account and flatterned.
        /// </summary>
        /// <param name="args">Arguments to be flatterned into a single dimensional array.</param>
        /// <param name="byrefargs">Mask of arguments that must be passed by reference.</param>
        /// <remarks>The method assumes the arguments list contains a variable unpacking. Otherwise this method is not well performance optimized.</remarks>
        /// <returns>Type symbol corresponding to <c>PhpValue[]</c></returns>
        internal TypeSymbol UnpackArgumentsIntoArray(ImmutableArray<BoundArgument> args, PhpSignatureMask byrefargs)
        {
            if (args.IsDefaultOrEmpty)
            {
                // Array.Empty<PhpValue>()
                return Emit_EmptyArray(this.CoreTypes.PhpValue);
            }

            // assuming the arguments list contains a variable unpacking,
            // otherwise we could do this much more efficiently
            Debug.Assert(args.Any(a => a.IsUnpacking));

            // TODO: args.Length == 1 => unpack directly to an array // Template: Unpack(args[0]) => args[0].CopyTo(new PhpValue[args[0].Count])

            // Symbol: List<PhpValue>
            var list_phpvalue = DeclaringCompilation.GetWellKnownType(WellKnownType.System_Collections_Generic_List_T).Construct(CoreTypes.PhpValue);
            var list_ctor_int = list_phpvalue.InstanceConstructors.Single(m => m.ParameterCount == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Int32);
            var list_add_PhpValue = list_phpvalue.GetMembers(WellKnownMemberNames.CollectionInitializerAddMethodName).OfType<MethodSymbol>().SingleOrDefault(m => m.ParameterCount == 1 && !m.IsStatic);
            var list_toarray = (MethodSymbol)list_phpvalue.GetMembers("ToArray").Single();

            // Symbol: Operators.Unpack
            var unpack_methods = CoreTypes.Operators.Symbol.GetMembers("Unpack").OfType<MethodSymbol>();
            var unpack_list_value_ulong = unpack_methods.Single(m => m.Parameters[1].Type == CoreTypes.PhpValue);
            var unpack_list_array_ulong = unpack_methods.Single(m => m.Parameters[1].Type == CoreTypes.PhpArray);

            // 1. create temporary List<PhpValue>

            // Template: new List<PhpValue>(COUNT)
            _il.EmitIntConstant(args.Length + 8);   // estimate unpackged arguments count
            EmitCall(ILOpCode.Newobj, list_ctor_int)
                .Expect(list_phpvalue);

            // 2. evaluate arguments and unpack them to the List<PhpValue> (on <STACK>)
            for (int i = 0; i < args.Length; i++)
            {
                _il.EmitOpCode(ILOpCode.Dup);   // .dup <STACK>

                if (args[i].IsUnpacking)
                {
                    // Template: Unpack(<STACK>, args[i], byrefs)
                    var t = Emit(args[i].Value);
                    if (t == CoreTypes.PhpArray)
                    {
                        _il.EmitLongConstant((long)(ulong)byrefargs);    // byref args
                        EmitCall(ILOpCode.Call, unpack_list_array_ulong)
                            .Expect(SpecialType.System_Void);
                    }
                    else
                    {
                        EmitConvert(t, args[i].Value.TypeRefMask, CoreTypes.PhpValue);
                        _il.EmitLongConstant((long)(ulong)byrefargs);    // byref args
                        EmitCall(ILOpCode.Call, unpack_list_value_ulong)
                            .Expect(SpecialType.System_Void);
                    }
                }
                else
                {
                    // Template: <STACK>.Add((PhpValue)args[i])
                    EmitConvert(args[i].Value, CoreTypes.PhpValue);
                    EmitCall(ILOpCode.Call, list_add_PhpValue)
                        .Expect(SpecialType.System_Void);
                }
            }

            // 3. copy the list into PhpValue[]
            // Template: List<PhpValue>.ToArray()
            return EmitCall(ILOpCode.Call, list_toarray);
        }

        /// <summary>
        /// Builds <c>PhpArray</c> out from <c>System.Array</c>.
        /// </summary>
        public TypeSymbol ArrayToPhpArray(IPlace arrplace, bool deepcopy = false, int startindex = 0)
        {
            var phparr = GetTemporaryLocal(CoreTypes.PhpArray);

            // Template: tmparr = new PhpArray(arrplace.Length)
            arrplace.EmitLoad(_il);
            EmitArrayLength();  // array size hint
            EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpArray_int);
            _il.EmitLocalStore(phparr);

            // enumeration body:
            EmitEnumerateArray(arrplace, startindex, (srcindex, element_loader) =>
            {
                // Template: <tmparr>.Add((T)arrplace[i])
                _il.EmitLocalLoad(phparr);   // <array>
                var t = element_loader();   // arrplace[i]
                t = (deepcopy) ? EmitDeepCopy(t, true) : t;
                EmitConvert(t, 0, CoreTypes.PhpValue);    // (PhpValue)arrplace[i]
                EmitPop(EmitCall(ILOpCode.Call, CoreMethods.PhpArray.Add_PhpValue));    // <array>.Add( value )
            });

            _il.EmitLocalLoad(phparr);

            ReturnTemporaryLocal(phparr);

            //
            return (TypeSymbol)phparr.Type;
        }

        /// <summary>
        /// Creates array from source array.
        /// </summary>
        /// <param name="srcarray">Source array.</param>
        /// <param name="srcfrom">First element to be copied.</param>
        /// <param name="targetArrElement">Target array element type.</param>
        /// <returns>Type of target array which is left on top of stack.</returns>
        public TypeSymbol ArrayToNewArray(IPlace srcarray, int srcfrom, TypeSymbol targetArrElement)
        {
            // Template: <tmplength> = srcarray.Length - srcfrom
            srcarray.EmitLoad(_il);
            EmitArrayLength();
            _il.EmitIntConstant(srcfrom);
            _il.EmitOpCode(ILOpCode.Sub);
            var tmplength = GetTemporaryLocal(CoreTypes.Int32);
            _il.EmitLocalStore(tmplength);

            // Template: if (tmplength > 0) ... else { Array.Empty<T>(); }

            var lblempty = new object();
            var lblend = new object();

            _il.EmitLocalLoad(tmplength);
            _il.EmitIntConstant(0);
            _il.EmitBranch(ILOpCode.Ble, lblempty); // length <= 0 : goto lblempty;

            // <tmparr> = new T[tmplength]
            _il.EmitLocalLoad(tmplength);
            _il.EmitOpCode(ILOpCode.Newarr);
            EmitSymbolToken(targetArrElement, null);
            var tmparr = GetTemporaryLocal(ArrayTypeSymbol.CreateSZArray(this.DeclaringCompilation.SourceAssembly, targetArrElement));
            _il.EmitLocalStore(tmparr);

            ReturnTemporaryLocal(tmplength);

            // enumerator body:
            EmitEnumerateArray(srcarray, srcfrom, (srcindex, element_loader) =>
            {
                // Template: tmparr[srcindex - srcfrom] = (T)element_loader();
                _il.EmitLocalLoad(tmparr);

                _il.EmitLocalLoad(srcindex);    // srcindex
                _il.EmitIntConstant(srcfrom);   // srcfrom
                _il.EmitOpCode(ILOpCode.Sub);   // -

                EmitConvert(element_loader(), 0, targetArrElement);  // (T) LOAD source element

                _il.EmitOpCode(ILOpCode.Stelem);    // STORE
                EmitSymbolToken(targetArrElement, null);
            });

            _il.EmitLocalLoad(tmparr);  // LOAD tmparr
            _il.EmitBranch(ILOpCode.Br, lblend);    // goto end;

            // lblempty:
            _il.MarkLabel(lblempty);
            Emit_EmptyArray(targetArrElement);

            // lblend:
            _il.MarkLabel(lblend);

            //
            ReturnTemporaryLocal(tmparr);
            return (TypeSymbol)tmparr.Type;
        }

        /// <summary>
        /// Emits for-loop of elements in given array provided through <paramref name="arrplace"/>.
        /// </summary>
        /// <param name="arrplace">Place representing source array.</param>
        /// <param name="startindex">First element index to enumerato from.</param>
        /// <param name="bodyemit">Action used to emit the body of the enumeration.
        /// Gets source element index and delegate that emits the LOAD of source element.</param>
        public void EmitEnumerateArray(IPlace arrplace, int startindex, Action<LocalDefinition, Func<TypeSymbol>> bodyemit)
        {
            if (arrplace == null) throw new ArgumentNullException(nameof(arrplace));

            Debug.Assert(arrplace.Type.IsSZArray());

            var arr_element = ((ArrayTypeSymbol)arrplace.Type).ElementType;

            // Template: for (i = 0; i < params.Length; i++) <phparr>.Add(arrplace[i])

            var lbl_block = new object();
            var lbl_cond = new object();

            // i = <startindex>
            var tmpi = GetTemporaryLocal(CoreTypes.Int32);
            _il.EmitIntConstant(startindex);
            _il.EmitLocalStore(tmpi);
            _il.EmitBranch(ILOpCode.Br, lbl_cond);

            // {body}
            _il.MarkLabel(lbl_block);

            bodyemit(tmpi, () =>
                {
                    // LOAD arrplace[i]
                    arrplace.EmitLoad(_il);
                    _il.EmitLocalLoad(tmpi);
                    _il.EmitOpCode(ILOpCode.Ldelem);
                    EmitSymbolToken(arr_element, null);
                    return arr_element;
                });

            // i++
            _il.EmitLocalLoad(tmpi);
            _il.EmitIntConstant(1);
            _il.EmitOpCode(ILOpCode.Add);
            _il.EmitLocalStore(tmpi);

            // i < params.Length
            _il.MarkLabel(lbl_cond);
            _il.EmitLocalLoad(tmpi);
            arrplace.EmitLoad(_il);
            EmitArrayLength();
            _il.EmitOpCode(ILOpCode.Clt);
            _il.EmitBranch(ILOpCode.Brtrue, lbl_block);

            //
            ReturnTemporaryLocal(tmpi);
        }

        /// <summary>
        /// Emits <c>Array.Length</c> call expecting an array instance on top of the stack, returning <c>int</c>.
        /// </summary>
        internal void EmitArrayLength()
        {
            EmitOpCode(ILOpCode.Ldlen);
            EmitOpCode(ILOpCode.Conv_i4);
        }

        /// <summary>
        /// Emits call to given method.
        /// </summary>
        /// <param name="code">Call op code, Call, Callvirt, Calli.</param>
        /// <param name="method">Method reference.</param>
        /// <returns>Method return type.</returns>
        internal TypeSymbol EmitCall(ILOpCode code, MethodSymbol method)
        {
            return _il.EmitCall(_moduleBuilder, _diagnostics, code, method);
        }

        /// <summary>
        /// Emits <paramref name="thisExpr"/> to be used as target instance of method call, field or property.
        /// </summary>
        internal TypeSymbol LoadTargetInstance(BoundExpression thisExpr, MethodSymbol method)
        {
            NamedTypeSymbol targetType = method.HasThis ? method.ContainingType : CoreTypes.Void;

            if (thisExpr != null)
            {
                if (targetType.SpecialType != SpecialType.System_Void)
                {
                    //var lhs = default(LhsStack);
                    //lhs = VariableReferenceExtensions.EmitReceiver(this, ref lhs, method, thisExpr);

                    var receiverPlace = PlaceOrNull(thisExpr);
                    if (receiverPlace != null && targetType.IsValueType)
                    {
                        // load addr of the receiver:
                        var lhs = VariableReferenceExtensions.EmitReceiver(this, receiverPlace);

                        if (lhs.Stack == null || lhs.Stack.IsVoid())
                        {
                            throw this.NotImplementedException();
                        }
                    }
                    else
                    {
                        // <thisExpr> -> <TObject>
                        EmitConvert(thisExpr, targetType);

                        if (targetType.IsValueType)
                        {
                            EmitStructAddr(targetType);   // value -> valueaddr
                        }
                    }

                    //
                    return targetType;
                }
                else
                {
                    // POP <thisExpr>
                    EmitPop(Emit(thisExpr));

                    return null;
                }
            }
            else
            {
                if (targetType.SpecialType != SpecialType.System_Void)
                {
                    if (ThisPlaceOpt != null && ThisPlaceOpt.Type != null &&
                        ThisPlaceOpt.Type.IsOfType(targetType))
                    {
                        // implicit $this instance
                        return EmitThis();
                    }
                    else
                    {
                        // $this is undefined
                        // PHP would throw a notice when undefined $this is used

                        if (targetType.IsValueType)
                        {
                            // Template: ADDR default(VALUE_TYPE)
                            Builder.EmitValueDefaultAddr(this.Module, this.Diagnostics, this.GetTemporaryLocal(targetType, true));
                        }
                        else
                        {
                            // create dummy instance
                            // TODO: when $this is accessed from PHP code, throw error
                            // NOTE: we can't just pass NULL since the instance holds reference to Context that is needed by emitted code

                            var dummyctor =
                                (MethodSymbol)(targetType as IPhpTypeSymbol)?.InstanceConstructorFieldsOnly ??    // .ctor that only initializes fields with default values
                                targetType.InstanceConstructors.FirstOrDefault(m => !m.IsPhpHidden && m.Parameters.All(p => p.IsImplicitlyDeclared));   // implicit ctor

                            if (dummyctor != null)
                            {
                                // new T(Context)
                                EmitCall(ILOpCode.Newobj, dummyctor, null, ImmutableArray<BoundArgument>.Empty, null)
                                    .Expect(targetType);
                            }
                            else
                            {
                                // TODO: empty struct addr
                                throw this.NotImplementedException();
                            }
                        }

                        //
                        return targetType;
                    }
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Loads "self" class onto the stack.
        /// </summary>
        /// <param name="astype">Type to be used to represent "self" - PhpTypeInfo, string, RuntimeTypeHandle.</param>
        /// <returns></returns>
        TypeSymbol EmitLoadCurrentClassContext(TypeSymbol astype)
        {
            if (astype == CoreTypes.PhpTypeInfo)
            {
                if (this.CallerType == null && this.RuntimeCallerTypePlace == null)
                {
                    // null
                    _il.EmitNullConstant();
                }
                else
                {
                    EmitLoadSelf(throwOnError: false);
                }
            }
            else if (astype.SpecialType == SpecialType.System_String)
            {
                if (this.CallerType == null && this.RuntimeCallerTypePlace == null)
                {
                    // null
                    Builder.EmitNullConstant();
                }
                else if (this.CallerType is IPhpTypeSymbol phpt)
                {
                    // type known in compile-time:
                    Builder.EmitStringConstant(phpt.FullName.ToString());
                }
                else
                {
                    // {LOAD PhpTypeInfo}?.Name
                    EmitLoadSelf(throwOnError: false);
                    EmitNullCoalescing(
                        () => EmitCall(ILOpCode.Call, CoreMethods.Operators.GetName_PhpTypeInfo.Getter).Expect(SpecialType.System_String),
                        () => Builder.EmitNullConstant());
                }
            }
            else if (astype == CoreTypes.RuntimeTypeHandle)
            {
                // LOAD <RuntimeTypeHandle>
                return EmitCallerTypeHandle();
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(astype);
            }

            return astype;
        }

        TypeSymbol LoadMethodSpecialArgument(ParameterSymbol p, BoundTypeRef staticType, ITypeSymbol selfType)
        {
            // Context
            if (SpecialParameterSymbol.IsContextParameter(p))
            {
                Debug.Assert(p.Type == CoreTypes.Context);
                return EmitLoadContext();
            }
            // ImportValueAttribute( ValueSpec )
            else if (SpecialParameterSymbol.IsImportValueParameter(p, out var value))
            {
                switch (value)
                {
                    case ImportValueAttributeData.ValueSpec.CallerScript:
                        Debug.Assert(ContainingFile != null);
                        Debug.Assert(p.Type == CoreTypes.RuntimeTypeHandle);
                        return EmitLoadToken(ContainingFile, null);    // RuntimeTypeHandle

                    case ImportValueAttributeData.ValueSpec.CallerArgs:
                        //Debug.Assert(p.Type.IsSZArray() && ((ArrayTypeSymbol)p.Type).ElementType.Is_PhpValue()); // PhpValue[]
                        //return Emit_ArgsArray(CoreTypes.PhpValue);     // PhpValue[]
                        if ((Symbol)FunctionArgsArray?.Type == p.Type)
                        {
                            _il.EmitLocalLoad(FunctionArgsArray);
                            return p.Type;
                        }
                        else
                        {
                            throw this.NotImplementedException(
                                "cannot pass caller arguments, " +
                                FunctionArgsArray == null ? "arguments not fetched" : "parameter type does not match");
                        }

                    case ImportValueAttributeData.ValueSpec.Locals:
                        Debug.Assert(p.Type.Is_PhpArray());
                        if (!HasUnoptimizedLocals) throw new InvalidOperationException();
                        return LocalsPlaceOpt.EmitLoad(Builder).Expect(CoreTypes.PhpArray);    // PhpArray

                    case ImportValueAttributeData.ValueSpec.This:
                        Debug.Assert(p.Type.IsObjectType());
                        return this.EmitPhpThisOrNull();           // object

                    case ImportValueAttributeData.ValueSpec.CallerStaticClass:
                        // current "static"
                        if (p.Type == CoreTypes.PhpTypeInfo)
                        {
                            return EmitLoadStaticPhpTypeInfo();
                        }
                        throw ExceptionUtilities.UnexpectedValue(p.Type);

                    case ImportValueAttributeData.ValueSpec.CallerClass:
                        // current class context (self)
                        // note, can be obtain dynamically (global code, closure)
                        return EmitLoadCurrentClassContext(p.Type);

                    case ImportValueAttributeData.ValueSpec.LocalVariable:
                        // load local variable with the name {p.Name}
                        if (this.Routine.LocalsTable.TryGetVariable(new VariableName(p.Name), out var variable))
                        {
                            var lhs = default(LhsStack);
                            // TODO: get alias without increasing reference count
                            EmitConvert(variable.EmitLoadValue(this, ref lhs, p.Type.Is_PhpAlias() ? BoundAccess.ReadRef : BoundAccess.Read), 0, p.Type);
                            return p.Type;
                        }
                        else if (p.Type.IsReferenceType) // PhpAlias
                        {
                            this.Builder.EmitNullConstant();
                            return p.Type;
                        }
                        else
                        {
                            return EmitLoadDefault(p.Type);
                        }

                    default:
                        throw ExceptionUtilities.UnexpectedValue(value);
                }
            }
            // class context
            else if (SpecialParameterSymbol.IsSelfParameter(p))
            {
                return EmitLoadCurrentClassContext(p.Type);
            }
            // late static
            else if (SpecialParameterSymbol.IsLateStaticParameter(p))
            {
                // PhpTypeInfo
                if (staticType != null)
                {
                    if (staticType.IsSelf() || staticType.IsParent())
                    {
                        return EmitLoadStaticPhpTypeInfo();
                    }
                    else
                    {
                        // LOAD <statictype>
                        return (TypeSymbol)staticType.EmitLoadTypeInfo(this);
                    }
                }
                else if (selfType != null && selfType.Is_PhpValue() == false && selfType.Is_PhpAlias() == false)
                {
                    // late static bound type is self:
                    return this.EmitLoadPhpTypeInfo(selfType);
                }
                else
                {
                    throw ExceptionUtilities.Unreachable;
                }
            }
            // dummy parameter for ctors
            else if (SpecialParameterSymbol.IsDummyFieldsOnlyCtorParameter(p))
            {
                return EmitLoadDefaultOfValueType(p.Type);  // default()
            }
            // unhandled
            else
            {
                throw ExceptionUtilities.UnexpectedValue(p.Type);
            }
        }

        /// <summary>
        /// Emits known method call if arguments have to be unpacked before the call.
        /// </summary>
        internal TypeSymbol EmitCall_UnpackingArgs(ILOpCode code, MethodSymbol method, BoundExpression thisExpr, ImmutableArray<BoundArgument> packedarguments, BoundTypeRef staticType = null)
        {
            Contract.ThrowIfNull(method);
            Debug.Assert(packedarguments.Any(a => a.IsUnpacking));

            // {this}
            var thisType = (code != ILOpCode.Newobj) ? LoadTargetInstance(thisExpr, method) : null;

            // .callvirt -> .call
            if (code == ILOpCode.Callvirt && (!method.HasThis || !method.IsMetadataVirtual()))
            {
                // ignores null check in method call
                code = ILOpCode.Call;
            }

            // arguments
            var parameters = method.Parameters;
            int arg_index = 0;      // next argument to be emitted from <arguments>
            var param_index = 0;    // loaded parameters
            var writebacks = new List<WriteBackInfo>();

            // unpack arguments (after $this was evaluated)
            // Template: PhpValue[] <tmpargs> = UNPACK <arguments>
            var tmpargs = GetTemporaryLocal(UnpackArgumentsIntoArray(packedarguments, method.GetByRefArguments()));
            _il.EmitLocalStore(tmpargs);
            var tmpargs_place = new LocalPlace(tmpargs);

            //
            for (; param_index < parameters.Length; param_index++)
            {
                var p = parameters[param_index];

                // special implicit parameters
                if (arg_index == 0 &&           // no source parameter were loaded yet
                    p.IsImplicitlyDeclared &&   // implicitly declared parameter
                    !p.IsParams)
                {
                    LoadMethodSpecialArgument(p, staticType, thisType ?? method.ContainingType);
                    continue;
                }

                // pass argument:
                if (p.IsParams)
                {
                    Debug.Assert(p.Type.IsArray());

                    if (((ArrayTypeSymbol)p.Type).ElementType == CoreTypes.PhpValue && arg_index == 0)
                    {
                        // just pass argsarray as it is
                        tmpargs_place.EmitLoad(_il);
                    }
                    else
                    {
                        // create new array and copy&convert values from argsarray

                        ArrayToNewArray(tmpargs_place, arg_index, ((ArrayTypeSymbol)p.Type).ElementType);
                    }

                    break;  // p is last one
                }
                else
                {
                    // Template: (index < tmpargs.Length) ? tmpargs[index] : default
                    var lbldefault = new object();
                    var lblend = new object();

                    _il.EmitIntConstant(arg_index);                 // LOAD index
                    _il.EmitLocalLoad(tmpargs); EmitArrayLength();  // LOAD <tmpargs>.Length
                    _il.EmitBranch(ILOpCode.Bge, lbldefault);       // .bge (lbldefault)
                    EmitLoadArgument(p, tmpargs_place, arg_index,
                        writebacks);                                // LOAD tmpargs[index]
                    _il.EmitBranch(ILOpCode.Br, lblend);            // goto lblend;
                    _il.MarkLabel(lbldefault);                      // lbldefault:
                    EmitParameterDefaultValue(p);                   // default(p)
                    _il.MarkLabel(lblend);                          // lblend:

                    //
                    arg_index++;
                }
            }

            // return <tmpargs> asap
            ReturnTemporaryLocal(tmpargs);
            tmpargs = null;

            // call the method
            var result = EmitCall(code, method);

            // write ref parameters back if necessary
            WriteBackInfo.WriteBackAndFree(this, writebacks);

            //
            return result;
        }

        internal TypeSymbol EmitCall(ILOpCode code, MethodSymbol method, BoundExpression thisExpr, ImmutableArray<BoundArgument> arguments, BoundTypeRef staticType = null)
        {
            Contract.ThrowIfNull(method);

            // {this}
            var thisType = (code != ILOpCode.Newobj) ? LoadTargetInstance(thisExpr, method) : null;

            // .callvirt -> .call
            if (code == ILOpCode.Callvirt && (!method.HasThis || !method.IsMetadataVirtual()))
            {
                // ignores null check in method call
                code = ILOpCode.Call;
            }

            // arguments
            var parameters = method.Parameters;
            int arg_index = 0;      // next argument to be emitted from <arguments>
            var param_index = 0;    // loaded parameters
            var writebacks = new List<WriteBackInfo>();

            int arg_params_index = (arguments.Length != 0 && arguments[arguments.Length - 1].IsUnpacking) ? arguments.Length - 1 : -1; // index of params argument, otherwise -1
            int arg_params_consumed = 0; // count of items consumed from arg_params if any

            Debug.Assert(arg_params_index < 0 || (arguments[arg_params_index].Value is BoundVariableRef v && v.Variable.Type.IsSZArray()), $"Argument for params is expected to be a variable of type array, at {method.ContainingType.PhpName()}::{method.Name}().");

            for (; param_index < parameters.Length; param_index++)
            {
                var p = parameters[param_index];

                // special implicit parameters
                if (arg_index == 0 &&           // no source parameter were loaded yet
                    p.IsImplicitlyDeclared &&   // implicitly declared parameter
                    !p.IsParams)
                {
                    LoadMethodSpecialArgument(p, staticType, thisType ?? method.ContainingType);
                    continue;
                }

                // load arguments

                if (arg_index == arg_params_index) // arg is params
                {
                    #region LOAD params T[]

                    //
                    // treat argument as "params T[]"
                    //

                    var arg_type = (ArrayTypeSymbol)arguments[arg_index].Value.Emit(this); // {args}

                    // {args} on STACK:

                    if (p.IsParams)
                    {
                        // Template: {args}
                        if (arg_type != p.Type || arg_params_consumed > 0)  // we need to create new array from args
                        {
                            // T[] arrtmp = {arrtmp};
                            var arrtmp = GetTemporaryLocal(arg_type, false);
                            _il.EmitLocalStore(arrtmp);

                            // {args}.Skip({arg_params_consumed}) -> new T[]
                            this.ArrayToNewArray(new LocalPlace(arrtmp), arg_params_consumed, ((ArrayTypeSymbol)p.Type).ElementType);

                            //
                            ReturnTemporaryLocal(arrtmp);
                        }
                    }
                    else
                    {
                        // Template: {args}.Length <= {arg_params_consumed} ? default(T) : (T)args[arg_params_consumed]

                        if (p.RefKind != RefKind.None)
                        {
                            throw this.NotImplementedException($"p.RefKind == {p.RefKind}", thisExpr);
                        }

                        var lbldefault = new object();
                        var lblend = new object();

                        this.EmitArrayLength();                     // .Length
                        _il.EmitIntConstant(arg_params_consumed);   // {arg_params_consumed}
                        _il.EmitBranch(ILOpCode.Ble, lbldefault);

                        arguments[arg_index].Value.Emit(this);      // <args>
                        _il.EmitIntConstant(arg_params_consumed);   // <i>

                        if (p.Type.Is_PhpAlias() && arg_type.ElementType.Is_PhpValue())
                        {
                            // {args}[i].EnsureAlias()
                            _il.EmitOpCode(ILOpCode.Ldelema);               // ref args[i]
                            EmitSymbolToken(arg_type.ElementType, null);    // PhpValue
                            EmitCall(ILOpCode.Call, CoreMethods.Operators.EnsureAlias_PhpValueRef);
                        }
                        else
                        {
                            // (T)args[i]
                            _il.EmitOpCode(ILOpCode.Ldelem); // args[i]
                            EmitSymbolToken(arg_type.ElementType, null);
                            EmitConvert(arg_type.ElementType, 0, p.Type);
                        }

                        _il.EmitBranch(ILOpCode.Br, lblend);

                        // default(T)
                        _il.MarkLabel(lbldefault);
                        EmitParameterDefaultValue(p);

                        //
                        _il.MarkLabel(lblend);

                        //
                        arg_params_consumed++;
                    }

                    #endregion

                    continue;
                }

                if (p.IsParams)
                {
                    Debug.Assert(parameters.Length == param_index + 1, $"params should be the last parameter, at {method.ContainingType.PhpName()}::{method.Name}()."); // p is last one
                    Debug.Assert(p.Type.IsArray(), $"params should be of type array, at {method.ContainingType.PhpName()}::{method.Name}().");

                    var p_element = ((ArrayTypeSymbol)p.Type).ElementType;

                    if (arg_params_index >= 0)
                    {
                        // we have to load remaining arguments into an array and unroll the arg_params
                        // { arg_i, ..., arg_params[] }

                        #region LOAD new Array( ..., ...params )

                        /*
                         * Template:
                         * params = new PhpValue[ {arguments.Length - arg_index - 1} +  {arguments[arg_params_index]}.Length ]
                         * params[0] = arg_i
                         * params[1] = ..
                         * Array.Copy( params, arguments[arg_params_index] )
                         */

                        int arr_size1 = arguments.Length - arg_index - 1; // remaining arguments without arg_params
                        Debug.Assert(arguments[arg_params_index].Value is BoundVariableRef arg_params, $"Argument for params is expected to be a variable reference expression, at {method.ContainingType.PhpName()}::{method.Name}().");

                        // <params> = new [arr_size1 + arg_params.Length]

                        _il.EmitIntConstant(arr_size1);
                        arguments[arg_params_index].Value.Emit(this); // {args}
                        EmitArrayLength();
                        _il.EmitOpCode(ILOpCode.Add);

                        _il.EmitOpCode(ILOpCode.Newarr);
                        EmitSymbolToken(p_element, null);

                        var params_loc = GetTemporaryLocal(p.Type, false);
                        _il.EmitLocalStore(params_loc);

                        // { arg_i, ..., arg_(n-1) }
                        for (int i = 0; i < arr_size1; i++)
                        {
                            _il.EmitLocalLoad(params_loc);  // <params>
                            _il.EmitIntConstant(i);         // [i]
                            EmitConvert(arguments[arg_index + i].Value, p_element);
                            _il.EmitOpCode(ILOpCode.Stelem);
                            EmitSymbolToken(p_element, null);
                        }

                        // { ... arg_params } // TODO: use Array.Copy() if element types match
                        EmitEnumerateArray(arg_params.Place(), 0, (loc_i, loader) =>
                        {
                            _il.EmitLocalLoad(params_loc);  // <params>

                            _il.EmitIntConstant(arr_size1);         // arr_size1
                            _il.EmitLocalLoad(loc_i);               // {i}
                            _il.EmitOpCode(ILOpCode.Add);           // +

                            EmitConvert(loader(), 0, p_element);
                            _il.EmitOpCode(ILOpCode.Stelem);
                            EmitSymbolToken(p_element, null);
                        });

                        // params : PhpValue[]
                        _il.EmitLocalLoad(params_loc);
                        ReturnTemporaryLocal(params_loc);

                        arg_index = arguments.Length;

                        #endregion
                    }
                    else
                    {
                        // easy case,
                        // wrap remaining arguments to array
                        var values = (arg_index < arguments.Length) ? arguments.Skip(arg_index).AsImmutable() : ImmutableArray<BoundArgument>.Empty;
                        arg_index += values.Length;
                        Emit_NewArray(p_element, values);
                    }

                    break;  // p is last one
                }

                if (arg_index < arguments.Length)
                {
                    EmitLoadArgument(p, arguments[arg_index++].Value, writebacks);
                }
                else
                {
                    EmitParameterDefaultValue(p);
                }
            }

            // emit remaining not used arguments
            for (; arg_index < arguments.Length && arg_index != arg_params_index; arg_index++)
            {
                EmitPop(Emit(arguments[arg_index].Value));
            }

            // call the method
            var result = EmitCall(code, method);

            // write ref parameters back if necessary
            WriteBackInfo.WriteBackAndFree(this, writebacks);

            //
            return result;
        }

        /// <summary>
        /// Emits .call to <paramref name="target"/> with the same arguments the caller method parameters (<paramref name="thismethod"/>) including reference to <c>this</c>.
        /// </summary>
        /// <param name="target">Method to be called.</param>
        /// <param name="thismethod">Current method.</param>
        /// <param name="thisPlaceExplicit">Optionaly specified place of object instance to call the method on.</param>
        /// <param name="callvirt">Whether to call the method virtually through <c>.callvirt</c>.</param>
        /// <returns>Return of <paramref name="target"/>.</returns>
        internal TypeSymbol EmitForwardCall(MethodSymbol target, MethodSymbol thismethod, IPlace thisPlaceExplicit = null, bool callvirt = false)
        {
            if (target == null)
            {
                return CoreTypes.Void;
            }
            // bind "this" expression if needed
            BoundExpression thisExpr;

            if (target.HasThis)
            {
                thisExpr = new BoundVariableRef(new BoundVariableName(VariableName.ThisVariableName))
                {
                    Variable = PlaceReference.Create(thisPlaceExplicit ?? this.ThisPlaceOpt),
                    Access = BoundAccess.Read
                };
            }
            else
            {
                thisExpr = null;
            }

            // bind arguments
            var givenps = thismethod.Parameters;
            var arguments = new List<BoundArgument>(givenps.Length);
            BoundTypeRef staticTypeRef = null;

            for (int i = 0; i < givenps.Length; i++)
            {
                var p = givenps[i];
                if (arguments.Count == 0 && p.IsImplicitlyDeclared && !p.IsParams)
                {
                    if (SpecialParameterSymbol.IsLateStaticParameter(p))
                    {
                        staticTypeRef = BoundTypeRefFactory.CreateFromPlace(new ParamPlace(p));
                    }

                    continue;
                }

                var expr = new BoundVariableRef(new BoundVariableName(new VariableName(p.MetadataName)))
                {
                    Variable = new PlaceReference(new ParamPlace(p)), // new ParameterReference(p, Routine),
                    Access = BoundAccess.Read
                };

                var arg = p.IsParams
                    ? BoundArgument.CreateUnpacking(expr)   // treated as "params PhpArray[]" by EmitCall
                    : BoundArgument.Create(expr);           // treated as ordinary parameter

                arguments.Add(arg);
            }

            //
            ILOpCode opcode = callvirt ? ILOpCode.Callvirt : ILOpCode.Call;

            // emit call of target
            return EmitCall(opcode, target, thisExpr, arguments.AsImmutableOrEmpty(), staticTypeRef);
        }

        /// <summary>
        /// Emits necessary conversion and copying of value returned from a method call.
        /// </summary>
        /// <param name="stack">Result value type on stack.</param>
        /// <param name="method">Called method. Can be <c>null</c> for indirect method calls.</param>
        /// <param name="access">Expression access.</param>
        /// <returns>New type on stack.</returns>
        internal TypeSymbol EmitMethodAccess(TypeSymbol stack, MethodSymbol method, BoundAccess access)
        {
            // cast negative number or null to false (CastToFalse)
            // and copy the value on stack if necessary
            if (access.IsRead)
            {
                if (method != null && method.CastToFalse)
                {
                    // casts to false and copy the value
                    //if (stack.IsNullableType())
                    //{
                    //    // unpack Nullable<T>
                    //    stack = EmitNullableCastToFalse(stack, access.IsReadValueCopy);
                    //} else

                    //
                    stack = EmitCastToFalse(stack, access.TargetType);
                }

                if (access.EnsureArray)
                {
                    // GetArrayAccess

                    if (stack == CoreTypes.PhpAlias)
                    {
                        // <stack>.EnsureArray()
                        return EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.EnsureArray);
                    }

                    if (stack == CoreTypes.PhpValue)
                    {
                        // <stack>.GetArrayAccess()
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.Operators.GetArrayAccess_PhpValueRef);
                    }

                    if (stack.IsReferenceType)
                    {
                        if (stack.ImplementsInterface(CoreTypes.IPhpArray))
                        {
                            // IPhpArray
                            return stack;
                        }

                        // Operators.EnsureArray(<stack>)
                        return EmitCall(ILOpCode.Call, CoreMethods.Operators.EnsureArray_Object);
                    }
                }
                else if (access.EnsureObject)
                {
                    // AsObject

                    if (stack == CoreTypes.PhpAlias)
                    {
                        // <stack>.EnsureObject()
                        return EmitCall(ILOpCode.Callvirt, CoreMethods.PhpAlias.EnsureObject);
                    }

                    if (stack == CoreTypes.PhpValue)
                    {
                        // <stack>.AsObject()
                        EmitPhpValueAddr();
                        return EmitCall(ILOpCode.Call, CoreMethods.PhpValue.AsObject);
                    }
                }
                else if (access.IsReadRef)
                {
                    if (stack != CoreTypes.PhpAlias)
                    {
                        EmitConvertToPhpValue(stack, 0);
                        stack = Emit_PhpValue_MakeAlias();
                    }
                }
                else
                {
                    // routines returning aliased value but
                    // read by value must dereference:
                    // BoundCopyValue is not bound
                    EmitPhpAliasDereference(ref stack);
                    // TODO: DeepCopy if being assigned ?
                }
            }

            //
            return stack;
        }

        /// <summary>
        /// Converts <b>negative</b> number or <c>null</c> to <c>FALSE</c>.
        /// </summary>
        /// <param name="stack">Type of value on stack.</param>
        /// <param name="targetType">Optional hint, the expected conversion of the resulting value.</param>
        /// <returns>New type of value on stack.</returns>
        internal TypeSymbol EmitCastToFalse(TypeSymbol stack, TypeSymbol targetType = null)
        {
            if (stack.SpecialType == SpecialType.System_Boolean)
            {
                return stack;
            }

            if (targetType != null && targetType.SpecialType == SpecialType.System_Boolean)
            {
                // will be converting to bool anyways
                if (stack.SpecialType == SpecialType.System_Int32)
                {
                    _il.EmitIntConstant(0);     // > 0
                    _il.EmitOpCode(ILOpCode.Cgt);
                    return CoreTypes.Boolean;
                }
                else if (stack.SpecialType == SpecialType.System_Int64)
                {
                    _il.EmitLongConstant(0);    // > 0L
                    _il.EmitOpCode(ILOpCode.Cgt);
                    return CoreTypes.Boolean;
                }
                else if (stack.SpecialType == SpecialType.System_Double)
                {
                    _il.EmitDoubleConstant(0.0);    // > 0.0
                    _il.EmitOpCode(ILOpCode.Cgt);
                    return CoreTypes.Boolean;
                }
                else if (stack.SpecialType == SpecialType.System_String)
                {
                    // Convert.ToBoolean({stack})
                    return EmitCall(ILOpCode.Call, CoreMethods.Operators.ToBoolean_String);
                }
                else if (stack.Is_PhpString())
                {
                    // Convert.ToBoolean({stack})
                    return EmitCall(ILOpCode.Call, CoreMethods.Operators.ToBoolean_PhpString);
                }
                else if (stack.IsReferenceType)
                {
                    // TODO: {stack} != null && Convert.ToBoolean({stack})
                }
            }

            // Template: <stack> ?? FALSE

            var lblfalse = new NamedLabel("CastToFalse:FALSE");
            var lblend = new NamedLabel("CastToFalse:end");

            _il.EmitOpCode(ILOpCode.Dup);   // <stack>

            // emit branching to lblfalse
            if (stack.SpecialType == SpecialType.System_Int32)
            {
                _il.EmitIntConstant(0);     // < 0
                _il.EmitBranch(ILOpCode.Blt, lblfalse);
            }
            else if (stack.SpecialType == SpecialType.System_Int64)
            {
                _il.EmitLongConstant(0);    // < 0L
                _il.EmitBranch(ILOpCode.Blt, lblfalse);
            }
            else if (stack.SpecialType == SpecialType.System_Double)
            {
                _il.EmitDoubleConstant(0.0);    // < 0.0
                _il.EmitBranch(ILOpCode.Blt, lblfalse);
            }
            else if (stack == CoreTypes.PhpString)
            {
                EmitCall(ILOpCode.Call, CoreMethods.PhpString.IsNull_PhpString);    // PhpString.IsDefault
                _il.EmitBranch(ILOpCode.Brtrue, lblfalse);
            }
            else if (stack.IsReferenceType)
            {
                _il.EmitNullConstant(); // == null
                _il.EmitBranch(ILOpCode.Beq, lblfalse);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(stack);
            }

            // test(<stack>) ? POP,FALSE : (PhpValue)<stack>

            // (PhpValue)<stack>
            EmitConvertToPhpValue(stack, 0);
            _il.EmitBranch(ILOpCode.Br, lblend);

            // POP, PhpValue.False
            _il.MarkLabel(lblfalse);
            EmitPop(stack);
            Emit_PhpValue_False();

            //
            _il.MarkLabel(lblend);

            //
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Converts <b>Nullable</b> without a value to <c>NULL</c>.
        /// </summary>
        /// <param name="stack">Type of Nullable&lt;T&gt; value on stack.</param>
        /// <param name="deepcopy">Whether to deep copy returned non-FALSE value.</param>
        /// <returns>New type of value on stack.</returns>
        internal TypeSymbol EmitNullableCastToNull(TypeSymbol stack, bool deepcopy)
        {
            Debug.Assert(stack.IsNullableType());

            // Template:
            // tmp = stack;
            // tmp.HasValue ? tmp.Value : NULL

            var t = ((NamedTypeSymbol)stack).TypeArguments[0];

            var lbltrue = new NamedLabel("has value");
            var lblend = new NamedLabel("end");

            var tmp = GetTemporaryLocal(stack, immediateReturn: true);
            _il.EmitLocalStore(tmp);

            // Template: tmp.HasValue ??
            _il.EmitLocalAddress(tmp);
            EmitCall(ILOpCode.Call, stack.LookupMember<PropertySymbol>("HasValue").GetMethod)
                .Expect(SpecialType.System_Boolean);

            _il.EmitBranch(ILOpCode.Brtrue, lbltrue);

            // Template: PhpValue.Null
            Emit_PhpValue_Null();

            _il.EmitBranch(ILOpCode.Br, lblend);

            // Template: (PhpValue)tmp.Value
            _il.MarkLabel(lbltrue);
            _il.EmitLocalAddress(tmp);
            EmitCall(ILOpCode.Call, stack.LookupMember<MethodSymbol>("GetValueOrDefault", m => m.ParameterCount == 0))
                .Expect(t);

            if (deepcopy)
            {
                // DeepCopy(<stack>)
                t = EmitDeepCopy(t, false);
            }
            // (PhpValue)<stack>
            EmitConvertToPhpValue(t, 0);

            //
            _il.MarkLabel(lblend);

            //
            return CoreTypes.PhpValue;
        }

        /// <summary>
        /// Emits <c>??</c> operation against the value on top of the evaluation stack.
        /// </summary>
        /// <param name="nullemitter">Routine that emits the FALSE branch of the operator.</param>
        internal void EmitNullCoalescing(Action<CodeGenerator> nullemitter)
        {
            Debug.Assert(nullemitter != null);

            var lbl_notnull = new NamedLabel("NotNull");
            _il.EmitOpCode(ILOpCode.Dup);
            _il.EmitBranch(ILOpCode.Brtrue, lbl_notnull);

            _il.EmitOpCode(ILOpCode.Pop);
            nullemitter(this);

            _il.MarkLabel(lbl_notnull);
        }

        /// <summary>
        /// Emits <c>?:</c> operation against the value on top of the evaluation stack.
        /// </summary>
        internal void EmitNullCoalescing(Action notnullemitter, Action nullemitter)
        {
            var lbl_notnull = new NamedLabel("NotNull");
            var lbl_end = new object();

            _il.EmitOpCode(ILOpCode.Dup);
            _il.EmitBranch(ILOpCode.Brtrue, lbl_notnull);

            _il.EmitOpCode(ILOpCode.Pop);
            nullemitter();
            _il.EmitBranch(ILOpCode.Br, lbl_end);

            _il.MarkLabel(lbl_notnull);
            notnullemitter();

            _il.MarkLabel(lbl_end);
        }

        /// <summary>
        /// Initializes place with a default value.
        /// This applies to structs without default ctor that won't work properly when uninitialized.
        /// </summary>
        internal void EmitInitializePlace(IPlace place)
        {
            Contract.ThrowIfNull(place);
            var t = place.Type;
            Contract.ThrowIfNull(t);

            switch (t.SpecialType)
            {
                // we don't have to initialize those:
                case SpecialType.System_Boolean:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                case SpecialType.System_Double:
                case SpecialType.System_Object:
                    break;

                default:
                    // uninitialized:
                    if (t == CoreTypes.PhpString ||
                        t == CoreTypes.PhpValue)
                    {
                        Debug.Assert(t.IsValueType);
                        break;
                    }

                    // PhpNumber, PhpAlias:
                    if (t.IsValueType || t == CoreTypes.PhpAlias)
                    {
                        // fld = default(T)
                        place.EmitStorePrepare(_il);
                        EmitLoadDefault(t, 0);
                        place.EmitStore(_il);
                    }
                    break;
            }
        }

        /// <summary>
        /// Temporary data used to call routines that expect ref or out parameters when given variable can't be passed by ref.
        /// </summary>
        class WriteBackInfo
        {
            class WriteBackInfo_ArgsArray : WriteBackInfo
            {
                public IPlace arrplace;
                public int argindex;

                TypeSymbol arr_element => ((ArrayTypeSymbol)arrplace.Type).ElementType;

                protected override void EmitLoadTarget(CodeGenerator cg, TypeSymbol type)
                {
                    // Template: (type)arr[argindex] 

                    Debug.Assert(arr_element == cg.CoreTypes.PhpValue);

                    arrplace.EmitLoad(cg.Builder);
                    cg.Builder.EmitIntConstant(argindex);
                    cg.Builder.EmitOpCode(ILOpCode.Ldelem);
                    cg.EmitSymbolToken(arr_element, null);
                    cg.EmitConvert(arr_element, 0, type);
                }

                protected override void WriteBackAndFree(CodeGenerator cg)
                {
                    // Template: Operators.SetValue(ref arr[argindex], <TmpLocal>)

                    var arr_element = ((ArrayTypeSymbol)arrplace.Type).ElementType;
                    Debug.Assert(arr_element == cg.CoreTypes.PhpValue);

                    // ref arr[argindex] : &PhpValue
                    arrplace.EmitLoad(cg.Builder);
                    cg.Builder.EmitIntConstant(argindex);
                    cg.Builder.EmitOpCode(ILOpCode.Ldelema);
                    cg.EmitSymbolToken(arr_element, null);

                    // (PhpValue)TmpLocal : PhpValue
                    cg.Builder.EmitLocalLoad(TmpLocal);
                    cg.EmitConvert((TypeSymbol)TmpLocal.Type, 0, arr_element);

                    // CALL SetValue
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetValue_PhpValueRef_PhpValue);

                    //
                    Dispose(cg);
                }
            }

            /// <summary>
            /// The temporary local passed by reference to a function call.
            /// After the call, it's value has to be written back to <see cref="Target"/>.
            /// </summary>
            public LocalDefinition TmpLocal;

            /// <summary>
            /// Original variable passed to the function call.
            /// Target of the write-back routine.
            /// </summary>
            public BoundReferenceExpression Target;

            /// <summary>
            /// Loads temporary local variable as an argument to <paramref name="targetp"/>.
            /// </summary>
            /// <param name="cg"></param>
            /// <param name="targetp">Target parameter.</param>
            /// <param name="expr">Value to be passed as its argument.</param>
            /// <returns><see cref="WriteBackInfo"/> which has to be finalized with <see cref="WriteBackAndFree(CodeGenerator)"/> once the routine call ends.</returns>
            public static WriteBackInfo CreateAndLoad(CodeGenerator cg, ParameterSymbol targetp, BoundReferenceExpression expr)
            {
                var writeback = new WriteBackInfo()
                {
                    TmpLocal = cg.GetTemporaryLocal(targetp.Type),
                    Target = expr,
                };

                //
                writeback.EmitLoadArgument(cg, targetp);

                //
                return writeback;
            }

            public static WriteBackInfo CreateAndLoad(CodeGenerator cg, ParameterSymbol targetp, IPlace arrplace, int argindex)
            {
                var writeback = new WriteBackInfo_ArgsArray()
                {
                    TmpLocal = cg.GetTemporaryLocal(targetp.Type),
                    arrplace = arrplace,
                    argindex = argindex,
                };

                //
                writeback.EmitLoadArgument(cg, targetp);

                //
                return writeback;
            }

            void EmitLoadArgument(CodeGenerator cg, ParameterSymbol targetp)
            {
                Debug.Assert(TmpLocal != null);
                Debug.Assert(targetp.Type == (Symbol)TmpLocal.Type);

                if (targetp.RefKind != RefKind.Out)
                {
                    // copy Target to TmpLocal
                    // Template: TmpLocal = Target;
                    EmitLoadTarget(cg, (TypeSymbol)TmpLocal.Type);
                    cg.Builder.EmitLocalStore(TmpLocal);
                }

                if (targetp.RefKind != RefKind.None)
                {
                    // LOAD_REF TmpLocal
                    cg.Builder.EmitLocalAddress(TmpLocal);
                }
                else
                {
                    // unreachable
                    // LOAD TmpLocal
                    cg.Builder.EmitLocalLoad(TmpLocal);
                }
            }

            protected virtual void EmitLoadTarget(CodeGenerator cg, TypeSymbol type)
            {
                cg.EmitConvert(Target, type); // TODO: DetermineConversionKind(targetp)
            }

            /// <summary>
            /// Writes the value back to <see cref="Target"/> and free resources.
            /// </summary>
            protected virtual void WriteBackAndFree(CodeGenerator cg)
            {
                // Template: <Target> = <TmpLocal>;
                Target.BindPlace(cg).EmitStore(cg, TmpLocal, BoundAccess.Write);

                //
                Dispose(cg);
            }

            public static void WriteBackAndFree(CodeGenerator cg, IList<WriteBackInfo> writebacks)
            {
                if (writebacks != null && writebacks.Count != 0)
                {
                    foreach (var w in writebacks)
                    {
                        w.WriteBackAndFree(cg);
                    }
                }
            }

            protected void Dispose(CodeGenerator cg)
            {
                // free <TmpLocal>
                cg.ReturnTemporaryLocal(TmpLocal);
                TmpLocal = null;
            }
        }

        static ConversionKind DetermineConversionKind(ParameterSymbol targetp)
        {
            var t = targetp.ContainingType;
            if (t.IsPhpSourceFile() || t.IsPhpUserType())
            {
                // TODO: strict mode on file level?
                // var f = cg.ContainingFile;                    

                return ConversionKind.Strict;
            }
            else
            {
                // a library function
                return ConversionKind.Implicit;
            }
        }

        /// <summary>
        /// Loads argument from bound expression.
        /// </summary>
        void EmitLoadArgument(ParameterSymbol targetp, BoundExpression expr, List<WriteBackInfo> writebacks)
        {
            if (targetp.RefKind == RefKind.None)
            {
                // load argument
                EmitConvert(expr, targetp.Type,
                    conversion: DetermineConversionKind(targetp),
                    notNull: targetp.HasNotNull);
            }
            else
            {
                if (expr is BoundReferenceExpression refexpr)
                {
                    var place = refexpr.Place();
                    if (place != null && place.HasAddress && place.Type == targetp.Type)
                    {
                        // ref place directly
                        place.EmitLoadAddress(_il);
                        return;
                    }

                    // write-back
                    writebacks.Add(WriteBackInfo.CreateAndLoad(this, targetp, refexpr));
                    return;
                }
                else
                {
                    // TODO: report as a diagnostic before this happens!
                    throw this.NotImplementedException("Argument must be passed as a variable.");
                }
            }
        }

        /// <summary>
        /// Loads argument from arguments array.
        /// </summary>
        void EmitLoadArgument(ParameterSymbol targetp, IPlace arrplace, int argindex, List<WriteBackInfo> writebacks)
        {
            // assert arrplace is of type PhpValue[]
            Debug.Assert(arrplace != null);
            Debug.Assert(arrplace.Type.IsSZArray());

            var arr_element = ((ArrayTypeSymbol)arrplace.Type).ElementType;
            Debug.Assert(arr_element == CoreTypes.PhpValue);

            //
            if (targetp.RefKind == RefKind.None)
            {
                // Template: (T)arrplace[argindex]
                arrplace.EmitLoad(_il);
                _il.EmitIntConstant(argindex);
                _il.EmitOpCode(ILOpCode.Ldelem);
                EmitSymbolToken(arr_element, null);
                EmitConvert(CoreTypes.PhpValue, 0, targetp.Type);
            }
            else
            {
                // write-back
                writebacks.Add(WriteBackInfo.CreateAndLoad(this, targetp, arrplace, argindex));
            }
        }

        /// <summary>
        /// Emits default value of given parameter.
        /// Puts value of target parameter's type.
        /// </summary>
        /// <param name="targetp">Parameter to emit its default value.</param>
        internal void EmitParameterDefaultValue(ParameterSymbol targetp)
        {
            Contract.ThrowIfNull(targetp);

            //
            TypeSymbol ptype; // emitted type to be eventually converted to target parameter type

            // emit targetp default value:
            ConstantValue cvalue;
            BoundExpression boundinitializer;
            FieldSymbol defaultvaluefield;

            if ((cvalue = targetp.ExplicitDefaultConstantValue) != null)
            {
                ptype = EmitLoadConstant(cvalue.Value, targetp.Type);
            }
            else if ((defaultvaluefield = targetp.DefaultValueField) != null)
            {
                Debug.Assert(defaultvaluefield.IsStatic);
                ptype = defaultvaluefield.EmitLoad(this);

                if (ptype.Is_Func_Context_PhpValue())
                {
                    this.EmitLoadContext();

                    // .Invoke( ctx )
                    ptype = this.Builder.EmitCall(Module, Diagnostics, ILOpCode.Callvirt, ptype.DelegateInvokeMethod());
                }
            }
            else if ((boundinitializer = (targetp as IPhpValue)?.Initializer) != null)
            {
                // DEPRECATED AND NOT USED ANYMORE:

                var cg = this;

                if (targetp.OriginalDefinition is SourceParameterSymbol)
                {
                    // emit using correct TypeRefContext:

                    // TODO: use `boundinitializer.Parent` instead of following
                    // magically determine the source routine corresponding to the initializer expression:
                    SourceRoutineSymbol srcr = null;
                    for (var r = targetp.ContainingSymbol;
                         srcr == null && r != null; // we still don't have to original SourceRoutineSymbol, but we have "r"
                         r = (r as SynthesizedMethodSymbol)?.ForwardedCall?.OriginalDefinition) // dig in and find original SourceRoutineSymbol wrapped by this synthesized stub
                    {
                        srcr = r as SourceRoutineSymbol;
                    }

                    Debug.Assert(srcr != null, "!srcr");

                    if (srcr != null)
                    {
                        cg = new CodeGenerator(this, srcr);
                    }
                }

                //
                cg.EmitConvert(boundinitializer, ptype = targetp.Type);
            }
            else if (targetp.IsParams)
            {
                // Template: System.Array.Empty<T>()
                Emit_EmptyArray(((ArrayTypeSymbol)targetp.Type).ElementType);
                return;
            }
            else
            {
                ptype = EmitLoadDefault(targetp.Type, 0);
            }

            // eventually convert emitted value to target parameter type
            EmitConvert(ptype, 0, targetp.Type);

            // ref, out
            if (targetp.RefKind == RefKind.Ref || targetp.RefKind == RefKind.Out) // this usually won't happen, ref parameters are not optional
            {
                // T tmp = <DEFAULT>
                var tmp = GetTemporaryLocal(targetp.Type, true); // TODO: should not be returned immediatelly, remember tmp and return it postcall
                Builder.EmitLocalStore(tmp);

                // ref tmp, 
                Builder.EmitLocalAddress(tmp);
                return;
            }
        }

        internal TypeSymbol EmitGetProperty(IPlace holder, PropertySymbol prop)
        {
            Debug.Assert(prop.IsStatic || holder != null);
            Debug.Assert(prop.GetMethod != null);
            Debug.Assert(prop.GetMethod.ParameterCount == 0);

            return prop.EmitLoadValue(this, holder);
        }

        internal TypeSymbol EmitCastClass(TypeSymbol from, TypeSymbol to)
        {
            Debug.Assert(!from.IsUnreachable);
            Debug.Assert(!to.IsUnreachable);

            if (from.IsOfType(to))
            {
                return from;
            }
            else
            {
                EmitCastClass(to);
                return to;
            }
        }

        internal void EmitCastClass(TypeSymbol type)
        {
            Debug.Assert(!type.IsUnreachable);

            // (T)
            _il.EmitOpCode(ILOpCode.Castclass);
            EmitSymbolToken(type, null);
        }

        /// <summary>
        /// Emits <c>PhpString.Blob.Append</c> expecting <c>PhpString.Blob</c> on top of evaluation stack.
        /// </summary>
        /// <param name="value">The expression to be appended.</param>
        /// <param name="expandConcat">Whether to skip evaluation of <c>concat</c> expression and directly append its arguments.</param>
        internal void Emit_PhpStringBlob_Append(BoundExpression value, bool expandConcat = true)
        {
            if (value is BoundConcatEx concat && expandConcat)
            {
                var args = concat.ArgumentsInSourceOrder;
                for (int i = 0; i < args.Length; i++)
                {
                    if (i < args.Length - 1)
                    {
                        _il.EmitOpCode(ILOpCode.Dup);   // PhpString.Blob
                    }

                    Emit_PhpStringBlob_Append(args[i].Value);
                }
            }
            else
            {
                if (!IsDebug && value.IsConstant() && ExpressionsExtension.IsEmptyStringValue(value.ConstantValue.Value))
                {
                    _il.EmitOpCode(ILOpCode.Pop);
                }
                else
                {
                    Emit_PhpStringBlob_Append(Emit(value));
                }
            }
        }

        /// <summary>
        /// Emits <c>PhpString.Blob.Append</c> expecting <c>PhpString.Blob</c> and <paramref name="ytype"/> on top of evaluation stack.
        /// </summary>
        /// <param name="ytype">Type of argument loaded on stack.</param>
        void Emit_PhpStringBlob_Append(TypeSymbol ytype)
        {
            if (ytype == CoreTypes.PhpAlias)
            {
                ytype = Emit_PhpAlias_GetValue();
            }

            if (ytype.SpecialType == SpecialType.System_Void)
            {
                _il.EmitOpCode(ILOpCode.Pop);
            }
            else if (ytype == CoreTypes.PhpString)
            {
                // Append(PhpString)
                EmitCall(ILOpCode.Callvirt, CoreMethods.PhpStringBlob.Add_PhpString);
            }
            else if (ytype == CoreTypes.PhpValue)
            {
                // Append(PhpValue, Context)
                EmitLoadContext();
                EmitCall(ILOpCode.Callvirt, CoreMethods.PhpStringBlob.Add_PhpValue_Context);
            }
            else
            {
                // Append(string)
                EmitConvertToString(ytype, 0);
                EmitCall(ILOpCode.Callvirt, CoreMethods.PhpStringBlob.Add_String);
            }
        }

        public void EmitEcho(BoundExpression expr)
        {
            Contract.ThrowIfNull(expr);
            Debug.Assert(expr.Access.IsRead);

            if (_optimizations.IsRelease())
            {
                // check if the value won't be an empty string:
                if (expr.ConstantValue.HasValue && ExpressionsExtension.IsEmptyStringValue(expr.ConstantValue.Value))
                {
                    return;
                }

                // avoid concatenation if possible:
                if (expr is BoundConcatEx concat)
                {
                    // Check if arguments can be echo'ed separately without concatenating them,
                    // this is only possible if the arguments won't have side effects:
                    var issafe = true;
                    var concat_args = concat.ArgumentsInSourceOrder;
                    for (int i = 1; i < concat_args.Length; i++)
                    {
                        issafe &=
                            // TODO: add more expressions that are safe to echo
                            concat_args[i].Value.IsConstant() ||
                            concat_args[i].Value is BoundGlobalConst ||
                            concat_args[i].Value is BoundPseudoConst ||
                            concat_args[i].Value is BoundPseudoClassConst ||
                            concat_args[i].Value is BoundVariableRef;
                    }

                    if (issafe)
                    {
                        for (int i = 0; i < concat_args.Length; i++)
                        {
                            EmitEcho(concat_args[i].Value);
                        }
                        return;
                    }
                }
            }

            // Template: <ctx>.Echo(expr);

            this.EmitLoadContext();
            var type = EmitSpecialize(expr);

            //
            MethodSymbol method = null;

            switch (type.SpecialType)
            {
                case SpecialType.System_Void:
                    EmitPop(this.CoreTypes.Context);
                    return;
                case SpecialType.System_String:
                    method = CoreMethods.Operators.Echo_String.Symbol;
                    break;
                case SpecialType.System_Double:
                    method = CoreMethods.Operators.Echo_Double.Symbol;
                    break;
                case SpecialType.System_Int32:
                    method = CoreMethods.Operators.Echo_Int32.Symbol;
                    break;
                case SpecialType.System_Int64:
                    method = CoreMethods.Operators.Echo_Long.Symbol;
                    break;
                case SpecialType.System_Boolean:
                    method = CoreMethods.Operators.Echo_Bool.Symbol;
                    break;
                default:
                    if (type == CoreTypes.PhpString)
                    {
                        method = CoreMethods.Operators.Echo_PhpString.Symbol;
                    }
                    else if (type == CoreTypes.PhpNumber)
                    {
                        method = CoreMethods.Operators.Echo_PhpNumber.Symbol;
                    }
                    else if (type == CoreTypes.PhpValue)
                    {
                        method = CoreMethods.Operators.Echo_PhpValue.Symbol;
                    }
                    else if (type == CoreTypes.PhpAlias)
                    {
                        Emit_PhpAlias_GetValue();
                        method = CoreMethods.Operators.Echo_PhpValue.Symbol;
                    }
                    else
                    {
                        // TODO: check expr.TypeRefMask if it is only NULL
                        EmitBox(type);
                        method = CoreMethods.Operators.Echo_Object.Symbol;
                    }
                    break;
            }

            //
            Debug.Assert(method != null);
            EmitCall(ILOpCode.Call, method);
        }

        /// <summary>
        /// Emits the expression decorated with error reporting disabling routine.
        /// </summary>
        public TypeSymbol EmitWithDisabledErrorReporting(BoundExpression expr)
        {
            //		context.DisableErrorReporting();
            //		<expr>
            //		context.EnableErrorReporting();

            EmitLoadContext();
            EmitCall(ILOpCode.Callvirt, CoreMethods.Context.DisableErrorReporting)
                .Expect(SpecialType.System_Void);

            var t = Emit(expr);

            EmitLoadContext();
            EmitCall(ILOpCode.Callvirt, CoreMethods.Context.EnableErrorReporting)
                .Expect(SpecialType.System_Void);

            //
            return t;
        }

        public void EmitIntStringKey(long key)
        {
            _il.EmitLongConstant(key);
            EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.IntStringKey_long);
        }

        public void EmitIntStringKey(string key)
        {
            // try convert string to integer as it is in PHP:
            if (TryConvertToIntKey(key, out var ikey))
            {
                EmitIntStringKey(ikey);
            }
            else
            {
                // lookup common keys:
                var key_fields = CoreTypes.CommonPhpArrayKeys.Symbol.GetMembers(key);   // 0 or 1, FieldSymbol
                var key_field = key_fields.IsDefaultOrEmpty ? null : (FieldSymbol)key_fields[0];
                if (key_field != null)
                {
                    Debug.Assert(key_field.IsStatic, "!key_field.IsStatic");
                    Debug.Assert(key_field.Type == CoreTypes.IntStringKey, "key_field.Type != IntStringKey");

                    // Template: .ldsfld key_field
                    key_field.EmitLoad(this);
                    return;
                }

                // Template: new IntStringKey( <key> )
                _il.EmitStringConstant(key);
                EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.IntStringKey_string);
            }
        }

        static bool TryConvertToIntKey(string key, out long ikey)
        {
            ikey = default;

            if (string.IsNullOrEmpty(key))
            {
                return false;
            }

            // See Pchp.Core.Convert.StringToArrayKey:

            if (key.Length > 1)
            {
                // following are treated as string keys:
                // "-0..."
                // "-0"
                // "0..."
                if (key[0] == '0') return false;
                if (key[0] == '-' && key[1] == '0') return false;
            }


            return long.TryParse(key, out ikey);
        }

        public void EmitIntStringKey(BoundExpression expr)
        {
            Contract.ThrowIfNull(expr);

            var constant = expr.ConstantValue;
            if (constant.HasValue)
            {
                if (constant.Value == null)
                {
                    EmitIntStringKey(string.Empty);
                }
                else if (constant.Value is string s)
                {
                    EmitIntStringKey(s);
                }
                else if (constant.Value is long l)
                {
                    EmitIntStringKey(l);
                }
                else if (constant.Value is int i)
                {
                    EmitIntStringKey(i);
                }
                else if (constant.Value is double d)
                {
                    EmitIntStringKey((long)d);
                }
                else if (constant.Value is bool b)
                {
                    EmitIntStringKey(b ? 1 : 0);
                }
                else
                {
                    throw new NotSupportedException();
                }

                return;
            }

            //
            this.EmitImplicitConversion(Emit(expr), this.CoreTypes.IntStringKey); // TODO: ConvertToArrayKey
        }

        /// <summary>
        /// Emits declaring function into the context.
        /// </summary>
        public void EmitDeclareFunction(SourceFunctionSymbol f)
        {
            Debug.Assert(f != null);
            Debug.Assert(!f.IsUnreachable);

            this.EmitSequencePoint(((FunctionDecl)f.Syntax).HeadingSpan);

            // <ctx>.DeclareFunction(RoutineInfo)
            EmitLoadContext();
            f.EmitLoadRoutineInfo(this);

            EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareFunction_RoutineInfo);
        }

        /// <summary>
        /// Emits type declaration into the context.
        /// </summary>
        public void EmitDeclareType(SourceTypeSymbol t)
        {
            Contract.ThrowIfNull(t);
            Debug.Assert(!t.IsErrorType(), "Cannot declare an error type.");

            // 
            this.EmitSequencePoint(t.Syntax.HeadingSpan);

            // autoload base types or throw an error
            var versions = t.HasVersions ? t.AllReachableVersions() : default;
            if (!versions.IsDefault && versions.Length > 1)
            {
                // emit declaration of type that has ambiguous versions
                EmitVersionedTypeDeclaration(versions);
            }
            else
            {
                // Ensure to emit only reachable type
                if (t.HasVersions)
                {
                    // TODO: Error when all the ancestors have been eliminated
                    Debug.Assert(versions.Length == 1);
                    t = versions[0];
                }
                Debug.Assert(!t.IsUnreachable);

                var dependent = t.GetDependentSourceTypeSymbols();

                // ensure all types are loaded into context,
                // autoloads if necessary
                dependent.ForEach(EmitExpectTypeDeclared);

                if (t.Arity == 0)
                {
                    // <ctx>.DeclareType<T>()
                    EmitLoadContext();
                    EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareType_T.Symbol.Construct(t));
                }
                else
                {
                    // <ctx>.DeclareType( PhpTypeInfo, Name )
                    EmitLoadContext();
                    EmitLoadToken(t.AsUnboundGenericType(), null);
                    EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_RuntimeTypeHandle);
                    Builder.EmitStringConstant(t.FullName.ToString());
                    EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareType_PhpTypeInfo_String);
                }
            }

            //
            Debug.Assert(_il.IsStackEmpty);
        }

        /// <summary>
        /// If necessary, emits autoload and check the given type is loaded into context.
        /// </summary>
        public void EmitExpectTypeDeclared(ITypeSymbol d)
        {
            Debug.Assert(((TypeSymbol)d).IsValidType());
            Debug.Assert(!((TypeSymbol)d).IsUnreachable);

            if (d is NamedTypeSymbol ntype)
            {
                if (ntype.IsAnonymousType || !ntype.IsPhpUserType())
                {
                    // anonymous classes are not declared
                    // regular CLR types declared in app context
                    return;
                }

                // TODO: type has been checked already in current branch -> skip

                if (ntype.OriginalDefinition is SourceTypeSymbol srct && ReferenceEquals(srct.ContainingFile, this.ContainingFile) && !srct.Syntax.IsConditional)
                {
                    // declared in same file unconditionally,
                    // we don't have to check anything
                    return;
                }

                if (ntype.OriginalDefinition is IPhpTypeSymbol phpt && phpt.AutoloadFlag == 2)
                {
                    // type is autoloaded without side effects
                    return;
                }

                if (this.CallerType != null && this.CallerType.IsOfType(ntype))
                {
                    // the type is a sub-type of current class context, so it must be declared for sure
                    // e.g. self, parent
                    return;
                }

                if (ntype.Arity == 0)
                {
                    // Template: ctx.ExpectTypeDeclared<d>
                    EmitLoadContext();
                    EmitCall(ILOpCode.Call, CoreMethods.Context.ExpectTypeDeclared_T.Symbol.Construct(ntype));
                }
                else
                {
                    // workaround for traits - constructed traits do not match the declaration in Context
                    if (ntype.IsTraitType())
                    {
                        // Template: ctx.ExpectTypeDeclared(GetPhpTypeInfo(RuntimeTypeHandle(T<>)))
                        EmitLoadContext();

                        EmitLoadToken(ntype.AsUnboundGenericType(), null);
                        EmitCall(ILOpCode.Call, CoreMethods.Dynamic.GetPhpTypeInfo_RuntimeTypeHandle);

                        EmitCall(ILOpCode.Call, CoreMethods.Context.ExpectTypeDeclared_PhpTypeInfo);
                    }
                    else
                    {
                        // should not happen,
                        // user types cannot be generic types
                        Debug.Fail($"Unexpected: a user type '{ntype.Name}' has type arguments.");
                    }
                }
            }
        }

        /// <summary>
        /// Emit declaration of one of given versions (of the same source type) based on actually declared types that versions depend on.
        /// </summary>
        /// <param name="versions">Array of multiple versions of a source type declaration.</param>
        void EmitVersionedTypeDeclaration(ImmutableArray<SourceTypeSymbol> versions)
        {
            Debug.Assert(versions.Length > 1);

            // ensure all types are loaded into context and resolve version to declare

            // collect dependent types [name x symbols]
            var dependent = new Dictionary<QualifiedName, HashSet<NamedTypeSymbol>>();
            foreach (var v in versions)
            {
                Debug.Assert(!v.IsUnreachable);

                var deps = v.GetDependentSourceTypeSymbols(); // TODO: error when the type version reports it depends on a user type which will never be declared because of a library type
                foreach (var d in deps.OfType<IPhpTypeSymbol>())
                {
                    if (!dependent.TryGetValue(d.FullName, out var set))
                    {
                        dependent[d.FullName] = set = new HashSet<NamedTypeSymbol>();
                    }

                    set.Add((NamedTypeSymbol)d);
                }
            }

            //
            var dependent_handles = new Dictionary<QualifiedName, LocalDefinition>();

            // resolve dependent types:
            foreach (var d in dependent)
            {
                var first = d.Value.First();

                if (d.Value.Count == 1)
                {
                    EmitExpectTypeDeclared(first);
                }
                else
                {
                    var tname = ((IPhpTypeSymbol)first).FullName;

                    // Template: tmp_d = ctx.GetDeclaredTypeOrThrow(d_name, autoload: true).TypeHandle
                    EmitLoadContext();
                    _il.EmitStringConstant(tname.ToString());
                    _il.EmitBoolConstant(true);
                    EmitCall(ILOpCode.Call, CoreMethods.Context.GetDeclaredTypeOrThrow_string_bool);
                    var thandle = EmitCall(ILOpCode.Call, CoreMethods.Operators.GetTypeHandle_PhpTypeInfo.Getter);

                    var tmp_handle = GetTemporaryLocal(thandle);
                    _il.EmitLocalStore(tmp_handle);

                    //
                    dependent_handles.Add(tname, tmp_handle);
                }
            }

            Debug.Assert(dependent_handles.Count != 0, "the type declaration is not versioned in result, there should be a single version");

            // At this point, all dependant types are loaded, otherwise runtime would throw an exception

            // find out version to declare:
            var lblFail = new NamedLabel("declare_fail");
            var lblDone = new NamedLabel("declare_done");
            EmitDeclareTypeByDependencies(versions, dependent_handles.ToArray(), 0, dependent, lblDone, lblFail);

            // Template: throw new Exception("Cannot declare {T}");
            // TODO: compile type dynamically (eval of type declaration with actual base types)
            _il.MarkLabel(lblFail);
            EmitThrowException(string.Format(ErrorStrings.ERR_UnknownTypeDependencies, versions[0].FullName));

            _il.MarkLabel(lblDone);

            // return tmp variables
            dependent_handles.Values.ForEach(ReturnTemporaryLocal);
        }

        /// <summary>
        /// Emits decision tree.
        /// </summary>
        /// <param name="versions">Versions to decide of.</param>
        /// <param name="dependency_handle">Map of dependant types and associated local variable holding resolved real type handle.</param>
        /// <param name="index">Index to <paramref name="dependency_handle"/> where to decide from.</param>
        /// <param name="dependencies">Map of type names and possible real types.</param>
        /// <param name="lblDone">Label where to jump upon decision is done.</param>
        /// <param name="lblFail">Label where to jump when dependy does not match.</param>
        void EmitDeclareTypeByDependencies(
            ImmutableArray<SourceTypeSymbol> versions,
            KeyValuePair<QualifiedName, LocalDefinition>[] dependency_handle, int index,
            Dictionary<QualifiedName, HashSet<NamedTypeSymbol>> dependencies,
            NamedLabel lblDone, NamedLabel lblFail)
        {
            if (index == dependency_handle.Length || versions.Length == 1)
            {
                Debug.Assert(versions.Length == 1);
                Debug.Assert(versions[0].Arity == 0);   // declare as unbound generic type, see EmitDeclareType
                // <ctx>.DeclareType<T>();
                // goto DONE;
                EmitLoadContext();
                EmitCall(ILOpCode.Call, CoreMethods.Context.DeclareType_T.Symbol.Construct(versions[0]));
                _il.EmitBranch(ILOpCode.Br, lblDone);
                return;
            }

            var thandle = dependency_handle[index];
            var types = dependencies[thandle.Key];
            Debug.Assert(types.Count > 1);

            /* [A, B]:
             * if (A == A1) {
             *   if (B == B1) Declare(X11); goto Done;
             *   if (B == B2) Declare(X12); goto Done;
             *   goto Fail;
             * }
             * if (A == A2) {
             *   if (B == B1) Declare(X21); goto Done;
             *   if (B == B2) Declare(X22); goto Done;
             *   goto Fail;
             * }
             * Fail: throw;
             * Done:
             */

            object lblElse = null;

            foreach (var h in types)
            {
                Debug.Assert(!h.IsUnreachable);

                if (lblElse != null) _il.MarkLabel(lblElse);

                // Template: if (thandle.Equals(h)) { ... } else goto lblElse;
                _il.EmitLocalAddress(thandle.Value);
                EmitLoadToken(h, null);
                EmitCall(ILOpCode.Call, CoreTypes.RuntimeTypeHandle.Method("Equals", CoreTypes.RuntimeTypeHandle));
                _il.EmitBranch(ILOpCode.Brfalse, lblElse = new object());

                // Template: *recursion*
                // h == thandle: filter versions depending on thandle
                var filtered_versions = versions.Where(v => v.GetDependentSourceTypeSymbols().Contains(h));
                EmitDeclareTypeByDependencies(filtered_versions.AsImmutable(), dependency_handle, index + 1, dependencies, lblDone, lblFail);
            }
            _il.MarkLabel(lblElse);
            _il.EmitBranch(ILOpCode.Br, lblFail);
        }

        /// <summary>
        /// Emits <code>throw new Exception(message)</code>
        /// </summary>
        public void EmitThrowException(string message)
        {
            var exception_ctor = CoreTypes.Exception.Ctor(CoreTypes.String);
            _il.EmitStringConstant(message);
            EmitCall(ILOpCode.Newobj, exception_ctor);
            _il.EmitThrow(false);
        }

        /// <summary>
        /// Emits call to main method.
        /// </summary>
        /// <param name="mainmethod">Static Main method representing the script global code.</param>
        /// <returns>Main method result value type.</returns>
        public TypeSymbol EmitCallMain(MethodSymbol mainmethod)
        {
            Contract.ThrowIfNull(mainmethod);
            Debug.Assert(mainmethod.IsStatic);
            Debug.Assert(mainmethod.Name == WellKnownPchpNames.GlobalRoutineName);

            foreach (var p in mainmethod.Parameters)
            {
                switch (p.Name)
                {
                    case SpecialParameterSymbol.ContextName:
                        EmitLoadContext();
                        break;
                    case SpecialParameterSymbol.LocalsName:
                        Debug.Assert(LocalsPlaceOpt != null);
                        LocalsPlaceOpt.EmitLoad(_il);
                        break;
                    case SpecialParameterSymbol.ThisName:
                        EmitThisOrNull();
                        break;
                    case SpecialParameterSymbol.SelfName:
                        this.EmitCallerTypeHandle();
                        break;
                    default:
                        throw ExceptionUtilities.UnexpectedValue(p.Name);
                }
            }

            //
            return EmitCall(ILOpCode.Call, mainmethod);
        }

        public TypeSymbol EmitLoadConstant(object value, TypeSymbol targetOpt = null, bool notNull = false)
        {
            if (value == null)
            {
                if (notNull)
                {
                    // should be reported already
                    // Diagnostics.Add( ... )
                    Debug.Fail("value cannot be null");
                }

                if (targetOpt != null && targetOpt.IsValueType)
                {
                    return EmitLoadDefaultOfValueType(targetOpt);
                }
                else // reference type
                {
                    if (targetOpt == CoreTypes.PhpAlias)
                    {
                        // new PhpAlias(PhpValue.Null)
                        Emit_PhpValue_Null();
                        return Emit_PhpValue_MakeAlias();
                    }
                    else
                    {
                        Builder.EmitNullConstant();
                        return targetOpt ?? CoreTypes.Object;
                    }
                }
            }
            else if (value is int i)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(i != 0);
                        return targetOpt;
                    case SpecialType.System_Int64:
                        _il.EmitLongConstant(i);
                        return targetOpt;
                    case SpecialType.System_Double:
                        _il.EmitDoubleConstant(i);
                        return targetOpt;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(i.ToString());
                        return targetOpt;
                }

                Builder.EmitIntConstant((int)value);
                return CoreTypes.Int32;
            }
            else if (value is long l)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(l != 0);
                        return targetOpt;
                    case SpecialType.System_Int32:
                        _il.EmitIntConstant((int)l);
                        return targetOpt;
                    case SpecialType.System_Double:
                        _il.EmitDoubleConstant(l);
                        return targetOpt;
                    case SpecialType.System_Single:
                        _il.EmitSingleConstant(l);
                        return targetOpt;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(l.ToString());
                        return targetOpt;
                    default:
                        break;
                }

                Builder.EmitLongConstant(l);
                return CoreTypes.Long;
            }
            else if (value is string str)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Char:
                        if (str != null && str.Length == 1)
                        {
                            Builder.EmitCharConstant(str[0]);
                            return targetOpt;
                        }
                        break;
                    case SpecialType.System_Int32:
                        if (int.TryParse(str, out i))
                        {
                            Builder.EmitIntConstant(i);
                            return targetOpt;
                        }
                        break;
                    case SpecialType.System_Int64:
                        if (long.TryParse(str, out l))
                        {
                            Builder.EmitLongConstant(l);
                            return targetOpt;
                        }
                        break;
                    case SpecialType.System_Double:
                        if (double.TryParse(str, out var d))
                        {
                            Builder.EmitDoubleConstant(d);
                            return targetOpt;
                        }
                        break;
                }

                Builder.EmitStringConstant(str);
                return CoreTypes.String;
            }
            else if (value is bool b)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        break;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(b ? "1" : "");
                        return targetOpt;
                    default:
                        if (targetOpt == CoreTypes.PhpValue)
                        {
                            return b ? Emit_PhpValue_True() : Emit_PhpValue_False();
                        }
                        break;
                }

                // template: LOAD bool
                Builder.EmitBoolConstant(b);
                return CoreTypes.Boolean;
            }
            else if (value is double d)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(d != 0.0);
                        return targetOpt;
                    case SpecialType.System_Int64:
                        _il.EmitLongConstant((long)d);
                        return targetOpt;
                }

                Builder.EmitDoubleConstant(d);
                return CoreTypes.Double;
            }
            else if (value is float f)
            {
                Builder.EmitSingleConstant(f);
                return DeclaringCompilation.GetSpecialType(SpecialType.System_Single);
            }
            else if (value is uint)
            {
                Builder.EmitIntConstant(unchecked((int)(uint)value));
                return DeclaringCompilation.GetSpecialType(SpecialType.System_UInt32);
            }
            else if (value is ulong ul)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_Boolean:
                        _il.EmitBoolConstant(ul != 0.0);
                        return targetOpt;
                    case SpecialType.System_Int64:
                        _il.EmitLongConstant((long)ul);
                        return targetOpt;
                    case SpecialType.System_Double:
                        _il.EmitDoubleConstant((double)ul);
                        return targetOpt;
                    case SpecialType.System_String:
                        _il.EmitStringConstant(ul.ToString());
                        return targetOpt;
                }

                _il.EmitLongConstant(unchecked((long)ul));
                return DeclaringCompilation.GetSpecialType(SpecialType.System_UInt64);
            }
            else if (value is char c)
            {
                switch (targetOpt.GetSpecialTypeSafe())
                {
                    case SpecialType.System_String:
                        Builder.EmitStringConstant(value.ToString());
                        return targetOpt;
                }

                Builder.EmitCharConstant(c);
                return DeclaringCompilation.GetSpecialType(SpecialType.System_Char);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(value);
            }
        }

        public TypeSymbol EmitLoadDefault(TypeSymbol type, TypeRefMask typemask = default)
        {
            Debug.Assert(type != null);

            switch (type.SpecialType)
            {
                case SpecialType.System_Void:
                    break;
                case SpecialType.System_Double:
                    _il.EmitDoubleConstant(0.0);
                    break;
                case SpecialType.System_Int32:
                    _il.EmitIntConstant(0);
                    break;
                case SpecialType.System_Int64:
                    _il.EmitLongConstant(0);
                    break;
                case SpecialType.System_Boolean:
                    _il.EmitBoolConstant(false);
                    break;
                case SpecialType.System_Char:
                    _il.EmitCharConstant('\0');
                    break;
                default:
                    if (type == CoreTypes.PhpAlias)
                    {
                        // new PhpAlias(void, 1);
                        Emit_PhpValue_Void();
                        Emit_PhpValue_MakeAlias();
                    }
                    //else if (CoreTypes.PhpArray.Symbol.IsOfType(type))
                    //{
                    //    EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpArray);
                    //}
                    //else if (type == CoreTypes.PhpString)
                    //{
                    //    EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpString);
                    //}
                    else if (type.IsReferenceType)
                    {
                        _il.EmitNullConstant();
                    }
                    else
                    {
                        if (type == CoreTypes.PhpValue)
                        {
                            if (typemask.IsSingleType && this.Routine != null)
                            {
                                var typectx = this.TypeRefContext;

                                if (typectx.IsBoolean(typemask))
                                {
                                    Emit_PhpValue_False();
                                    break;
                                }
                                else if (typectx.IsLong(typemask))
                                {
                                    _il.EmitLongConstant(0);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_Long);
                                    break;
                                }
                                else if (typectx.IsDouble(typemask))
                                {
                                    _il.EmitDoubleConstant(0.0);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_Double);
                                    break;
                                }
                                else if (typectx.IsAString(typemask))
                                {
                                    // return ""
                                    _il.EmitStringConstant(string.Empty);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_String);
                                    break;
                                }
                                else if (typectx.IsArray(typemask))
                                {
                                    EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpArray);
                                    EmitCall(ILOpCode.Call, CoreMethods.PhpValue.Create_PhpArray);
                                    break;
                                }
                            }
                        }

                        //
                        EmitLoadDefaultOfValueType(type);
                    }
                    break;
            }

            return type;
        }

        /// <summary>
        /// Emits <c>default(valuetype)</c>.
        /// Handles special types with a default ctor.
        /// </summary>
        public TypeSymbol EmitLoadDefaultOfValueType(TypeSymbol valuetype)
        {
            Debug.Assert(valuetype != null && valuetype.IsValueType);

            if (valuetype == CoreTypes.PhpNumber)
            {
                // PhpNumber.Default ~ 0L
                _il.EmitOpCode(ILOpCode.Ldsfld);
                EmitSymbolToken(CoreMethods.PhpNumber.Default, null);
            }
            else if (valuetype == CoreTypes.PhpValue)
            {
                // PhpValue.Null
                Emit_PhpValue_Null();
            }
            else
            {
                // default(T)
                _il.EmitValueDefault(this.Module, this.Diagnostics, this.GetTemporaryLocal(valuetype, true));
            }

            //
            return valuetype;
        }

        public void EmitRetDefault()
        {
            // return default(RETURN_TYPE);

            var return_type = this.Routine.ReturnType;

            EmitLoadDefault(return_type, this.Routine.ResultTypeMask);
            EmitRet(return_type);
        }

        /// <summary>
        /// Emits .ret instruction with sequence point at closing brace.
        /// Eventually emits branching to closing block.
        /// </summary>
        public void EmitRet(TypeSymbol stack, bool yielding = false)
        {
            // sequence point
            var body = AstUtils.BodySpanOrInvalid(Routine?.Syntax);
            if (body.IsValid && EmitPdbSequencePoints)
            {
                EmitSequencePoint(new Span(body.End - 1, 1));
            }

            //
            if (_il.InExceptionHandler || (ExtraFinallyBlock != null && !yielding))
            {
                this.ExitBlock.EmitTmpRet(this, stack, yielding);
            }
            else
            {
                _il.EmitRet(stack.SpecialType == SpecialType.System_Void);
            }
        }

        /// <summary>
        /// Emits <c>place != null</c> expression.
        /// </summary>
        public void EmitNotNull(IPlace place)
        {
            Debug.Assert(place != null);
            Debug.Assert(place.Type.IsReferenceType);

            // {place} != null : boolean
            place.EmitLoad(_il);
            _il.EmitNullConstant();
            _il.EmitOpCode(ILOpCode.Cgt_un);
        }

        /// <summary>
        /// Emits <c>Debug.Assert([<paramref name="place"/>]) in debug compile mode.</c>
        /// </summary>
        /// <param name="place">The variable to emit assertion for.</param>
        /// <param name="messageOpt">Optional second argument for assert.</param>
        public void EmitDebugAssertNotNull(IPlace place, string messageOpt = null)
        {
            if (IsDebug)
            {
                //EmitNotNull(place);
                //EmitDebugAssert(messageOpt);
            }
        }

        /// <summary>
        /// Emits <c>Debug.Assert([stack]).</c>
        /// </summary>
        /// <param name="messageOpt">Optional second argument for assert.</param>
        public void EmitDebugAssert(string messageOpt = null)
        {
            //var dt = this.DeclaringCompilation.GetTypeByMetadataName("System.Diagnostics.Debug"); // System.dll
            //dt.GetMember("Assert")
            throw new NotImplementedException();
        }

        public TypeSymbol EmitDeepCopy(TypeSymbol t, bool nullcheck)
        {
            if (IsCopiable(t))
            {
                object lblnull = null;
                if (nullcheck && t.IsReferenceType)
                {
                    // ?.
                    var lbltrue = new object();
                    lblnull = new object();

                    _il.EmitOpCode(ILOpCode.Dup);
                    _il.EmitBranch(ILOpCode.Brtrue, lbltrue);
                    _il.EmitOpCode(ILOpCode.Pop);
                    _il.EmitNullConstant();
                    _il.EmitBranch(ILOpCode.Br, lblnull);
                    _il.MarkLabel(lbltrue);
                }

                if (t == CoreTypes.PhpValue)
                {
                    EmitPhpValueAddr();
                    t = EmitCall(ILOpCode.Call, CoreMethods.PhpValue.DeepCopy);
                }
                else if (t == CoreTypes.PhpString)
                {
                    Debug.Assert(t.IsStructType());
                    // Template: new PhpString( <STACK> )
                    t = EmitCall(ILOpCode.Newobj, CoreMethods.Ctors.PhpString_PhpString);
                }
                else if (t == CoreTypes.PhpArray)
                {
                    t = EmitCall(ILOpCode.Callvirt, CoreMethods.PhpArray.DeepCopy);
                }
                else
                {
                    throw this.NotImplementedException("copy " + t.Name);
                }

                //
                if (lblnull != null)
                {
                    _il.MarkLabel(lblnull);
                }
            }

            return t;
        }

        /// <summary>
        /// Emits copy of value from top of the stack if necessary.
        /// </summary>
        public TypeSymbol EmitDeepCopy(TypeSymbol t, TypeRefMask thint = default(TypeRefMask))
        {
            if (IsCopiable(thint))
            {
                return EmitDeepCopy(t, thint.IsAnyType || this.TypeRefContext.IsNullOrVoid(thint));
            }
            else
            {
                return t;
            }
        }
    }

    internal static class ILBuilderExtension
    {
        public static void EmitLoadToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, TypeSymbol type, SyntaxNode syntaxNodeOpt)
        {
            il.EmitOpCode(ILOpCode.Ldtoken);
            EmitSymbolToken(il, module, diagnostics, type, syntaxNodeOpt);
        }

        public static void EmitLoadToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, MethodSymbol method, SyntaxNode syntaxNodeOpt)
        {
            il.EmitOpCode(ILOpCode.Ldtoken);
            EmitSymbolToken(il, module, diagnostics, method, syntaxNodeOpt);
        }

        public static void EmitSymbolToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, TypeSymbol symbol, SyntaxNode syntaxNode)
        {
            il.EmitToken(module.Translate(symbol, syntaxNode, diagnostics), syntaxNode, diagnostics);
        }

        public static void EmitSymbolToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, MethodSymbol symbol, SyntaxNode syntaxNode)
        {
            il.EmitToken(module.Translate(symbol, syntaxNode, diagnostics, needDeclaration: false), syntaxNode, diagnostics);
        }

        public static void EmitSymbolToken(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, FieldSymbol symbol, SyntaxNode syntaxNode)
        {
            il.EmitToken(module.Translate(symbol, syntaxNode, diagnostics), syntaxNode, diagnostics);
        }

        public static void EmitValueDefault(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, LocalDefinition tmp)
        {
            Debug.Assert(tmp.Type.IsValueType);
            il.EmitLocalAddress(tmp);
            il.EmitOpCode(ILOpCode.Initobj);
            il.EmitSymbolToken(module, diagnostics, (TypeSymbol)tmp.Type, null);
            // ldloc <loc>
            il.EmitLocalLoad(tmp);
        }

        /// <summary>
        /// Gets addr of a default value. Used to call a method on default value.
        /// </summary>
        public static void EmitValueDefaultAddr(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, LocalDefinition tmp)
        {
            Debug.Assert(tmp.Type.IsValueType);
            il.EmitLocalAddress(tmp);
            il.EmitOpCode(ILOpCode.Initobj);
            il.EmitSymbolToken(module, diagnostics, (TypeSymbol)tmp.Type, null);
            // ldloca <loc>
            il.EmitLocalAddress(tmp);
        }

        /// <summary>
        /// Gets or create a local variable and returns it back to pool.
        /// </summary>
        public static LocalDefinition GetTemporaryLocalAndReturn(this ILBuilder il, TypeSymbol t)
        {
            var definition = il.LocalSlotManager.AllocateSlot((Microsoft.Cci.ITypeReference)t, LocalSlotConstraints.None);

            il.LocalSlotManager.FreeSlot(definition);

            return definition;
        }

        /// <summary>
        /// Copies a value type from the top of evaluation stack into a temporary variable and loads its address.
        /// </summary>
        public static void EmitStructAddr(this ILBuilder il, TypeSymbol t)
        {
            Debug.Assert(t.IsStructType());

            var tmp = GetTemporaryLocalAndReturn(il, t);
            il.EmitLocalStore(tmp);
            il.EmitLocalAddress(tmp);
        }

        /// <summary>
        /// Emits call to given method.
        /// </summary>
        /// <returns>Method return type.</returns>
        public static TypeSymbol EmitCall(this ILBuilder il, PEModuleBuilder module, DiagnosticBag diagnostics, ILOpCode code, MethodSymbol method)
        {
            Contract.ThrowIfNull(method);
            Debug.Assert(code == ILOpCode.Call || code == ILOpCode.Calli || code == ILOpCode.Callvirt || code == ILOpCode.Newobj);
            Debug.Assert(!method.IsErrorMethodOrNull());

            var stack = method.GetCallStackBehavior();

            if (code == ILOpCode.Newobj)
            {
                stack += 1 + 1;    // there is no <this>, + it pushes <newinst> on stack
            }

            if (code == ILOpCode.Callvirt && !method.IsAbstract && (!method.IsVirtual || method.IsSealed || method.ContainingType.IsSealed))
            {
                code = ILOpCode.Call; // virtual dispatch is unnecessary
            }

            il.EmitOpCode(code, stack);
            il.EmitToken(module.Translate(method, diagnostics, false), null, diagnostics);
            return (code == ILOpCode.Newobj) ? method.ContainingType : method.ReturnType;
        }

        public static void EmitCharConstant(this ILBuilder il, char value)
        {
            il.EmitIntConstant(unchecked((int)value));
        }

        public static TypeSymbol EmitLoad(this ParameterSymbol p, ILBuilder il)
        {
            Debug.Assert(p != null, nameof(p));

            var index = p.Ordinal;
            var hasthis = ((MethodSymbol)p.ContainingSymbol).HasThis ? 1 : 0;

            il.EmitLoadArgumentOpcode(index + hasthis);
            return p.Type;
        }

        public static TypeSymbol EmitLoad(this FieldSymbol f, CodeGenerator cg, IPlace holder = null)
        {
            Debug.Assert(f != null, nameof(f));

            if (!f.IsStatic)
            {
                // {holder}
                Debug.Assert(holder != null);
                VariableReferenceExtensions.EmitReceiver(cg.Builder, holder);
            }

            // .ldfld/.ldsfld {f}
            cg.Builder.EmitOpCode(f.IsStatic ? ILOpCode.Ldsfld : ILOpCode.Ldfld);
            cg.Builder.EmitToken(cg.Module.Translate(f, null, DiagnosticBag.GetInstance()), null, DiagnosticBag.GetInstance());

            //
            return f.Type;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(22,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(8,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(1872,44): error CS0165: Use of unassigned local variable 'arg_params',D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(22,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\CodeGenerator.Emit.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeGen;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.CodeGen;
using Pchp.CodeAnalysis.Symbols;
using Peachpie.CodeAnalysis.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;

namespace Pchp.CodeAnalysis.Semantics
{
    partial class BoundExpression
    {
        /// <summary>
        /// Emits the expression with its bound access.
        /// Only Read or None access is possible. Write access has to be handled separately.
        /// </summary>
        /// <param name="cg">Associated code generator.</param>
        /// <returns>The type of expression emitted on top of the evaluation stack.</returns>
        internal virtual TypeSymbol Emit(CodeGenerator cg)
        {
            throw ExceptionUtilities.UnexpectedValue(this.GetType().FullName);
        }
    }

    partial class BoundBinaryEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsRead || this.Access.IsNone);

            //
            TypeSymbol returned_type;

            if (UsesOperatorMethod)
            {
                throw new NotImplementedException();    // call this.Operator(Left, Right)
            }

            switch (this.Operation)
            {
                #region Arithmetic Operations

                case Operations.Add:
                    returned_type = (cg.IsLongOnly(this.TypeRefMask)) ? cg.CoreTypes.Long.Symbol : this.Access.TargetType;
                    returned_type = EmitAdd(cg, Left, Right, returned_type);
                    break;

                case Operations.Sub:
                    //Template: "x - y"        Operators.Subtract(x,y) [overloads]
                    returned_type = EmitSub(cg, Left, Right, this.Access.TargetType);
                    break;

                case Operations.Div:
                    //Template: "x / y"
                    returned_type = EmitDivision(cg);
                    break;

                case Operations.Mul:
                    //Template: "x * y"
                    returned_type = EmitMultiply(cg);
                    break;

                case Operations.Pow:
                    //Template: "x ** y"
                    returned_type = EmitPow(cg);
                    break;

                case Operations.Mod:
                    // x % y
                    returned_type = EmitRemainder(cg, Left, Right);
                    break;

                case Operations.ShiftLeft:
                    //Template: x << y : long
                    returned_type = EmitShift(cg, Left, Right, ILOpCode.Shl);
                    break;

                case Operations.ShiftRight:
                    //Template: x >> y : long
                    returned_type = EmitShift(cg, Left, Right, ILOpCode.Shr);
                    break;

                #endregion

                #region Boolean and Bitwise Operations

                case Operations.And:
                    returned_type = EmitBinaryBooleanOperation(cg, true);
                    break;

                case Operations.Or:
                    returned_type = EmitBinaryBooleanOperation(cg, false);
                    break;

                case Operations.Xor:
                    returned_type = EmitBinaryXor(cg);
                    break;

                case Operations.BitAnd:
                    returned_type = EmitBitAnd(cg, Left, Right);
                    break;

                case Operations.BitOr:
                    returned_type = EmitBitOr(cg, Left, Right);
                    break;

                case Operations.BitXor:
                    returned_type = EmitBitXor(cg, Left, Right);
                    break;

                #endregion

                #region Comparing Operations

                case Operations.Equal:
                    {
                        bool negation = false;
                        returned_type = EmitEquality(cg, ref negation);

                        Debug.Assert(negation == false);
                    }
                    break;

                case Operations.NotEqual:
                    {
                        bool negation = true;
                        EmitEquality(cg, ref negation);
                        returned_type = cg.CoreTypes.Boolean;

                        if (negation)
                        {
                            cg.EmitLogicNegation();
                        }
                    }
                    break;

                case Operations.GreaterThan:
                    returned_type = EmitLtGt(cg, false);
                    break;

                case Operations.LessThan:
                    returned_type = EmitLtGt(cg, true);
                    break;

                case Operations.GreaterThanOrEqual:
                    // template: !(LessThan)
                    returned_type = EmitLtGt(cg, true);
                    cg.EmitLogicNegation();
                    break;

                case Operations.LessThanOrEqual:
                    // template: !(GreaterThan)
                    returned_type = EmitLtGt(cg, false);
                    cg.EmitLogicNegation();
                    break;

                case Operations.Identical:

                    // Left === Right
                    returned_type = EmitStrictEquality(cg);
                    break;

                case Operations.NotIdentical:

                    // ! (Left === Right)
                    returned_type = EmitStrictEquality(cg);
                    cg.EmitLogicNegation();
                    break;

                #endregion

                case Operations.Coalesce:
                    returned_type = EmitCoalesce(cg);
                    break;

                case Operations.Spaceship:
                    returned_type = EmitSpaceship(cg);
                    break;

                default:
                    throw cg.NotImplementedException(message: $"BinaryEx {this.Operation} is not implemented.", op: this);
            }

            //
            if (Access.IsNone)
            {
                // Result is not read, pop the result
                cg.EmitPop(returned_type);
                returned_type = cg.CoreTypes.Void;
            }
            else if (Access.IsRead)
            {
                Debug.Assert(returned_type.SpecialType != SpecialType.System_Void);
            }

            //
            return returned_type;
        }

        /// <summary>
        /// Emits <c>+</c> operator suitable for actual operands.
        /// </summary>
        private static TypeSymbol EmitAdd(CodeGenerator cg, BoundExpression left, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            // Template: x + y
            return EmitAdd(cg, cg.Emit(left), right, resultTypeOpt);
        }

        /// <summary>
        /// Emits <c>+</c> operator suitable for actual operands.
        /// </summary>
        internal static TypeSymbol EmitAdd(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> long, string -> number
            cg.EmitPhpAliasDereference(ref xtype); // alias -> value

            //
            if (xtype == cg.CoreTypes.PhpNumber)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));  // int|bool -> long, string -> number
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype == cg.CoreTypes.PhpNumber)
                {
                    // number + number : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_number)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // number + r8 : r8
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_double)
                        .Expect(SpecialType.System_Double);
                }
                else if (ytype.SpecialType == SpecialType.System_Int64)
                {
                    // number + long : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_long)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else
                {
                    // number + value : number
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_value)
                        .Expect(cg.CoreTypes.PhpNumber);
                }

                //
                throw cg.NotImplementedException($"Add(number, {ytype.Name})", right);
            }
            else if (xtype.SpecialType == SpecialType.System_Double)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitExprConvertNumberToDouble(right)); // bool|int|long|number -> double, string -> number

                if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // r8 + r8 : r8
                    il.EmitOpCode(ILOpCode.Add);
                    return cg.CoreTypes.Double;
                }
                else
                {
                    // r8 + value : r8
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_double_value)
                        .Expect(SpecialType.System_Double);
                }

                //
                throw cg.NotImplementedException($"Add(double, {ytype.Name})", right);
            }
            else if (xtype.SpecialType == SpecialType.System_Int64)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));    // int|bool -> long, string -> number
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype.SpecialType == SpecialType.System_Int64)
                {
                    if (resultTypeOpt != null)
                    {
                        if (resultTypeOpt.SpecialType == SpecialType.System_Int64)
                        {
                            // (long)(i8 + i8 : number)
                            il.EmitOpCode(ILOpCode.Add);
                            return cg.CoreTypes.Long;
                        }
                    }

                    // i8 + i8 : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_long)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // i8 + r8 : r8
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_double)
                        .Expect(SpecialType.System_Double);
                }
                else if (ytype == cg.CoreTypes.PhpNumber)
                {
                    // i8 + number : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_number)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else
                {
                    // i8 + value : number
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_value)
                        .Expect(cg.CoreTypes.PhpNumber);
                }

                //
                throw cg.NotImplementedException($"Add(int64, {ytype.Name})", right);
            }
            else if (xtype == cg.CoreTypes.PhpArray)
            {
                var ytype = cg.Emit(right);
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype == cg.CoreTypes.PhpArray)
                {
                    // PhpArray.Union(array, array) : PhpArray
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Union_PhpArray_PhpArray)
                        .Expect(cg.CoreTypes.PhpArray);
                }
                else
                {
                    // array + value
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_array_value);
                }

                //
                throw cg.NotImplementedException($"Add(PhpArray, {ytype.Name})", right);
            }
            else if (xtype == cg.CoreTypes.PhpValue)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));    // int|bool -> long, string -> number
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype.SpecialType == SpecialType.System_Int64)
                {
                    // value + i8 : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_long)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // value + r8 : r8
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_double)
                        .Expect(SpecialType.System_Double);
                }
                else if (ytype == cg.CoreTypes.PhpArray)
                {
                    // value + array
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_array);
                }
                else if (ytype == cg.CoreTypes.PhpNumber)
                {
                    // value + number : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_number)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else
                {
                    // value + value : value
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_value)
                        .Expect(cg.CoreTypes.PhpValue);
                }

                //
                throw cg.NotImplementedException($"Add(PhpValue, {ytype.Name})", right);
            }
            else
            {
                // x -> PhpValue
                if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                // y -> PhpValue
                cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                var ytype = cg.CoreTypes.PhpValue;

                // value / value : number
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_value)
                    .Expect(cg.CoreTypes.PhpValue);


            }

            //
            throw cg.NotImplementedException($"Add({xtype.Name}, ...)", right);
        }

        /// <summary>
        /// Emits subtraction operator.
        /// </summary>
        internal static TypeSymbol EmitSub(CodeGenerator cg, BoundExpression left, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            return EmitSub(cg, cg.Emit(left), right, resultTypeOpt);
        }

        /// <summary>
        /// Emits subtraction operator.
        /// </summary>
        internal static TypeSymbol EmitSub(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> int64, string -> number
            TypeSymbol ytype;

            cg.EmitPhpAliasDereference(ref xtype); // alias -> value

            //
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                    cg.EmitPhpAliasDereference(ref ytype); // alias -> value
                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 - i8 : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_long)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 - r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_double)
                            .Expect(cg.CoreTypes.Double);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 - number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_number)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else
                    {
                        // i8 - value : number
                        if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_value)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }

                case SpecialType.System_Double:
                    ytype = cg.EmitConvertStringToPhpNumber(cg.EmitExprConvertNumberToDouble(right)); // bool|int|long|number -> double, string -> number
                    cg.EmitPhpAliasDereference(ref ytype); // alias -> value
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 - r8 : r8
                        il.EmitOpCode(ILOpCode.Sub);
                        return cg.CoreTypes.Double;
                    }
                    else
                    {
                        // r8 - value : double
                        if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_double_value)
                                .Expect(cg.CoreTypes.Double);

                    }

                case SpecialType.System_String:
                    xtype = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.ToNumber_String)
                        .Expect(cg.CoreTypes.PhpNumber);
                    goto default;

                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                        cg.EmitPhpAliasDereference(ref ytype); // alias -> value
                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number - i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number - r8 : double
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number - number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // number - value : number
                            if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }

                        throw cg.NotImplementedException($"Sub(PhpNumber, {ytype.Name})", right);
                    }
                    else if (xtype == cg.CoreTypes.PhpValue)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                        cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // value - i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // value - r8 : r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // value - number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // value - value : number
                            if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }

                        throw cg.NotImplementedException($"Sub(PhpValue, {ytype.Name})", right);
                    }
                    else
                    {
                        // x -> PhpValue
                        if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value / value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_value)
                            .Expect(cg.CoreTypes.PhpNumber);

                    }

                    throw cg.NotImplementedException($"Sub({xtype.Name},...)", right);
            }
        }

        internal static TypeSymbol EmitBitAnd(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            // most common cases:
            if (cg.IsLongOnly(left.TypeRefMask) || cg.IsLongOnly(right.TypeRefMask))
            {
                // i64 | i64 : i64
                cg.EmitConvert(left, cg.CoreTypes.Long);
                cg.EmitConvert(right, cg.CoreTypes.Long);
                cg.Builder.EmitOpCode(ILOpCode.And);
                return cg.CoreTypes.Long;
            }

            // TODO: IF cg.IsStringOnly(left.TypeRefMask) && cg.IsStringOnly(Right.TypeRefMask)

            //
            return EmitBitAnd(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitBitAnd(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                case SpecialType.System_Int32:
                case SpecialType.System_Boolean:
                case SpecialType.System_Double:
                    cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    cg.EmitConvert(right, cg.CoreTypes.Long);
                    cg.Builder.EmitOpCode(ILOpCode.And);
                    return cg.CoreTypes.Long;

                default:
                    if (right.ResultType != null && right.ResultType.SpecialType != SpecialType.System_String)
                    {
                        // value | !string -> long | long -> long
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                        goto case SpecialType.System_Int64;
                    }
                    else
                    {
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseAnd_PhpValue_PhpValue)
                            .Expect(cg.CoreTypes.PhpValue);

                    }
            }
        }

        internal static TypeSymbol EmitBitOr(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            // most common cases:
            if (cg.IsLongOnly(left.TypeRefMask) || cg.IsLongOnly(right.TypeRefMask))
            {
                // i64 | i64 : i64
                cg.EmitConvert(left, cg.CoreTypes.Long);
                cg.EmitConvert(right, cg.CoreTypes.Long);
                cg.Builder.EmitOpCode(ILOpCode.Or);
                return cg.CoreTypes.Long;
            }

            // TODO: IF cg.IsStringOnly(left.TypeRefMask) && cg.IsStringOnly(Right.TypeRefMask)

            //
            return EmitBitOr(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitBitOr(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                case SpecialType.System_Int32:
                case SpecialType.System_Boolean:
                case SpecialType.System_Double:
                    cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    cg.EmitConvert(right, cg.CoreTypes.Long);
                    cg.Builder.EmitOpCode(ILOpCode.Or);
                    return cg.CoreTypes.Long;

                default:
                    if (right.ResultType != null && right.ResultType.SpecialType != SpecialType.System_String)
                    {
                        // value | !string -> long | long -> long
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                        goto case SpecialType.System_Int64;
                    }
                    else
                    {
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseOr_PhpValue_PhpValue)
                            .Expect(cg.CoreTypes.PhpValue);

                    }
            }
        }

        internal static TypeSymbol EmitBitXor(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            // most common cases:
            if (cg.IsLongOnly(left.TypeRefMask) || cg.IsLongOnly(right.TypeRefMask))
            {
                // i64 | i64 : i64
                cg.EmitConvert(left, cg.CoreTypes.Long);
                cg.EmitConvert(right, cg.CoreTypes.Long);
                cg.Builder.EmitOpCode(ILOpCode.Xor);
                return cg.CoreTypes.Long;
            }

            // TODO: IF cg.IsStringOnly(left.TypeRefMask) && cg.IsStringOnly(Right.TypeRefMask)

            //
            return EmitBitXor(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitBitXor(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                case SpecialType.System_Int32:
                case SpecialType.System_Boolean:
                case SpecialType.System_Double:
                    cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    cg.EmitConvert(right, cg.CoreTypes.Long);
                    cg.Builder.EmitOpCode(ILOpCode.Xor);
                    return cg.CoreTypes.Long;

                default:
                    if (right.ResultType != null && right.ResultType.SpecialType != SpecialType.System_String)
                    {
                        // value | !string -> long | long -> long
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                        goto case SpecialType.System_Int64;
                    }
                    else
                    {
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseXor_PhpValue_PhpValue)
                            .Expect(cg.CoreTypes.PhpValue);
                    }

            }
        }

        internal static TypeSymbol EmitRemainder(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            return EmitRemainder(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitRemainder(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Int32:
                case SpecialType.System_Double:
                    cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // cast to long
                    xtype = cg.CoreTypes.Long;
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    if (cg.IsNumberOnly(right.TypeRefMask))
                    {
                        // long & long
                        cg.EmitConvert(right, cg.CoreTypes.Long);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_long_long);
                    }
                    else
                    {
                        // long % value
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_long_value);
                    }

                default:

                    cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);

                    if (cg.IsNumberOnly(right.TypeRefMask))
                    {
                        // value % long
                        cg.EmitConvert(right, cg.CoreTypes.Long);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_value_long);
                    }
                    else
                    {
                        // value % value
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_value_value);
                    }

            }
        }

        internal static TypeSymbol EmitShift(CodeGenerator cg, BoundExpression left, BoundExpression right, ILOpCode op)
        {
            cg.EmitConvert(left, cg.CoreTypes.Long);
            return EmitShift(cg, cg.CoreTypes.Long, right, op);
        }

        internal static TypeSymbol EmitShift(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, ILOpCode op)
        {
            Debug.Assert(op == ILOpCode.Shl || op == ILOpCode.Shr);
            cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
            cg.EmitConvert(right, cg.CoreTypes.Int32);
            cg.Builder.EmitOpCode(op);

            return cg.CoreTypes.Long;
        }

        /// <summary>Emits <c>??</c> operator and returns the result type.</summary>
        TypeSymbol EmitCoalesce(CodeGenerator cg) => EmitCoalesce(cg, cg.Emit(this.Left), this.Left.TypeRefMask, this.Right);

        internal static TypeSymbol EmitCoalesce(CodeGenerator cg, TypeSymbol left_type, FlowAnalysis.TypeRefMask left_type_mask, BoundExpression right)
        {
            // Left ?? Right

            if (!cg.CanBeNull(left_type)) // in case we truly believe in our type analysis: || !cg.CanBeNull(this.Left.TypeRefMask))
            {
                return left_type;
            }

            object trueLbl = new object();
            object endLbl = new object();

            // <stack> = <left_var> = Left
            var left_var = cg.GetTemporaryLocal(left_type);
            cg.Builder.EmitOpCode(ILOpCode.Dup);
            cg.Builder.EmitLocalStore(left_var);

            cg.EmitNotNull(left_type, left_type_mask);
            cg.Builder.EmitBranch(ILOpCode.Brtrue, trueLbl);

            // false:
            var right_type = cg.Emit(right);
            var result_type = cg.DeclaringCompilation.Merge(left_type, right_type);
            cg.EmitConvert(right_type, right.TypeRefMask, result_type);
            cg.Builder.EmitBranch(ILOpCode.Br, endLbl);
            cg.Builder.AdjustStack(-1);

            // trueLbl:
            cg.Builder.MarkLabel(trueLbl);
            cg.Builder.EmitLocalLoad(left_var);
            cg.EmitConvert(left_type, left_type_mask, result_type);

            // endLbl:
            cg.Builder.MarkLabel(endLbl);

            //
            cg.ReturnTemporaryLocal(left_var);

            //
            return result_type;
        }

        /// <summary>Emits the spaceship `&lt;=&gt;` operation.</summary>
        TypeSymbol EmitSpaceship(CodeGenerator cg)
        {
            // TODO: return strictly -1, 0, +1 (.NET compare operation returns number in range: < 0, 0, > 0
            // TODO: optimize for specific type of operands (mostly string, long)

            cg.EmitConvertToPhpValue(Left);
            cg.EmitConvertToPhpValue(Right);

            // Template: Comparison.Compare( <Left>, <Right> ) : i4

            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_value_value)
                .Expect(SpecialType.System_Int32);
        }

        /// <summary>
        /// Emits binary boolean operation (AND or OR).
        /// </summary>
        /// <param name="cg">A code generator.</param>
        /// <param name="isAnd">Whether to emit AND, otherwise OR.</param>
        /// <returns>A type code of the result.</returns>
        TypeSymbol EmitBinaryBooleanOperation(CodeGenerator cg, bool isAnd)
        {
            var boolean = cg.CoreTypes.Boolean;  // typeof(bool)

            var il = cg.Builder;
            var partial_eval_label = new NamedLabel("<partial_eval>" + this.GetHashCode().ToString("X"));
            var end_label = new NamedLabel("<end>" + this.GetHashCode().ToString("X"));

            // IF [!]<(bool) Left> THEN GOTO partial_eval;
            cg.EmitConvert(Left, cg.CoreTypes.Boolean);
            il.EmitBranch(isAnd ? ILOpCode.Brfalse : ILOpCode.Brtrue, partial_eval_label);

            // <RESULT> = <(bool) Right>;
            cg.EmitConvert(Right, cg.CoreTypes.Boolean);

            // GOTO end;
            il.EmitBranch(ILOpCode.Br, end_label);
            il.AdjustStack(-1);

            // partial_eval:
            il.MarkLabel(partial_eval_label);
            il.EmitOpCode(isAnd ? ILOpCode.Ldc_i4_0 : ILOpCode.Ldc_i4_1, 1);

            // end:
            il.MarkLabel(end_label);

            //
            return boolean;
        }

        /// <summary>
        /// Emits binary operation XOR.
        /// </summary>
        TypeSymbol EmitBinaryXor(CodeGenerator cg)
        {
            // LOAD <(bool) leftSon> == <(bool) rightSon>;
            cg.EmitConvert(Left, cg.CoreTypes.Boolean);
            cg.EmitConvert(Right, cg.CoreTypes.Boolean);
            cg.EmitOpCode(ILOpCode.Ceq);

            cg.EmitOpCode(ILOpCode.Ldc_i4_0);
            cg.EmitOpCode(ILOpCode.Ceq);

            return cg.CoreTypes.Boolean;
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        TypeSymbol EmitEquality(CodeGenerator cg, ref bool negation)
        {
            // x == y
            return EmitEquality(cg, Left, Right, ref negation);
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        internal static TypeSymbol EmitEquality(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            bool negation = false;  // unused
            return EmitEquality(cg, xtype, right, ref negation);
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        internal static TypeSymbol EmitEquality(CodeGenerator cg, BoundExpression left, BoundExpression right, ref bool negation)
        {
            if (left.ConstantValue.IsNull())
            {
                // null == right
                return EmitEqualityToNull(cg, right, ref negation);
            }
            else if (right.ConstantValue.IsNull())
            {
                // left == null
                return EmitEqualityToNull(cg, left, ref negation);
            }
            else
            {
                // left == right
                return EmitEquality(cg, cg.Emit(left), right, ref negation);
            }
        }

        static TypeSymbol EmitEqualityToNull(CodeGenerator cg, BoundExpression expr, ref bool negation)
        {
            // Template: <expr> == null

            var il = cg.Builder;
            var t = cg.Emit(expr);

            //
            switch (t.SpecialType)
            {
                case SpecialType.System_Object:
                    il.EmitNullConstant();
                    if (negation)
                    {
                        // object != null
                        il.EmitOpCode(ILOpCode.Cgt_un);
                        negation = false;   // handled
                    }
                    else
                    {
                        // object == null
                        il.EmitOpCode(ILOpCode.Ceq);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Double:
                    // r8 == 0
                    il.EmitDoubleConstant(0.0);
                    il.EmitOpCode(ILOpCode.Ceq);
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int32:
                    // i4 == 0
                    cg.EmitLogicNegation();
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int64:
                    // i8 == 0
                    il.EmitLongConstant(0);
                    if (negation)
                    {
                        il.EmitOpCode(ILOpCode.Cgt_un);
                        negation = false; // handled
                    }
                    else
                    {
                        il.EmitOpCode(ILOpCode.Ceq);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_String:
                    // string.IsNullOrEmpty(string)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsNullOrEmpty_String);
                    return cg.CoreTypes.Boolean;

                default:
                    if (t == cg.CoreTypes.PhpNumber)
                    {
                        // number == 0L
                        il.EmitLongConstant(0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_long)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (t == cg.CoreTypes.PhpAlias)
                    {
                        // LOAD <PhpAlias>.Value
                        cg.Emit_PhpAlias_GetValue();
                    }
                    else
                    {
                        // LOAD <PhpValue>
                        cg.EmitConvert(t, 0, cg.CoreTypes.PhpValue);
                    }

                    // CeqNull(<value>)
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.CeqNull_value)
                        .Expect(SpecialType.System_Boolean);
            }
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        internal static TypeSymbol EmitEquality(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, ref bool negation)
        {
            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Boolean:

                    // bool == y.ToBoolean()
                    cg.EmitConvert(right, cg.CoreTypes.Boolean);
                    cg.Builder.EmitOpCode(ILOpCode.Ceq);

                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int32:
                    // i4 -> i8
                    cg.Builder.EmitOpCode(ILOpCode.Conv_i8);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:

                    ytype = cg.Emit(right);

                    //
                    if (ytype.SpecialType == SpecialType.System_Int32)
                    {
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                        ytype = cg.CoreTypes.Long;
                    }

                    //
                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 == i8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 == r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_long_double)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // i8 == bool
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_long_bool)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // i8 == string
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_long_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 == number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_long_number)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);

                        // compare(i8, value) == 0
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_long_value);
                        cg.EmitLogicNegation();

                        return cg.CoreTypes.Boolean;
                    }


                case SpecialType.System_Double:

                    ytype = cg.EmitExprConvertNumberToDouble(right);  // bool|long|int -> double

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 == r8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // r8 == string
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_double_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);

                        // compare(double, value) == 0
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_double_value);
                        cg.EmitLogicNegation();

                        return cg.CoreTypes.Boolean;
                    }


                case SpecialType.System_String:

                    ytype = cg.Emit(right);

                    if (ytype.SpecialType == SpecialType.System_Int32)
                    {
                        // i4 -> i8
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);
                        ytype = cg.CoreTypes.Long;
                    }

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // string == i8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_long)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // string == bool
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_bool)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // string == r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_double)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // Ceq(string, string)
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);

                        if (negation)
                        {
                            // string != value
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Ineq_String_PhpValue)
                                .Expect(SpecialType.System_Boolean);
                            negation = false;   // handled
                        }
                        else
                        {
                            // string == value
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Eq_String_PhpValue)
                                .Expect(SpecialType.System_Boolean);
                        }
                        return cg.CoreTypes.Boolean;
                    }

                //case SpecialType.System_Object:
                //    goto default;

                default:

                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertIntToLong(cg.Emit(right));
                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number == i8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_long)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number == r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_double)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number == number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_number)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else
                        {
                            ytype = cg.EmitConvertToPhpValue(ytype, 0);
                            // number == value
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_PhpValue)
                                .Expect(SpecialType.System_Boolean);
                        }
                    }
                    else
                    {
                        // TODO: xtype: PhpArray, ...

                        xtype = cg.EmitConvertToPhpValue(xtype, 0);

                        ytype = cg.Emit(right);
                        switch (ytype.SpecialType)
                        {
                            case SpecialType.System_String:
                                if (negation)
                                {
                                    negation = false;   // handled
                                    // value == string
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Ineq_PhpValue_String)
                                        .Expect(SpecialType.System_Boolean);
                                }
                                else
                                {
                                    // value == string
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Eq_PhpValue_String)
                                        .Expect(SpecialType.System_Boolean);
                                }

                            // TODO: more types on right

                            default:
                                ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask);

                                if (negation)
                                {
                                    negation = false; // handled
                                    // value == value
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Ineq_PhpValue_PhpValue)
                                        .Expect(SpecialType.System_Boolean);
                                }
                                else
                                {
                                    // value == value
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Eq_PhpValue_PhpValue)
                                        .Expect(SpecialType.System_Boolean);
                                }
                        }
                    }
            }
        }

        TypeSymbol EmitStrictEquality(CodeGenerator cg)
            => EmitStrictEquality(cg, Left, Right);

        internal static TypeSymbol EmitStrictEquality(CodeGenerator cg, BoundExpression left, BoundExpression right)
            => EmitStrictEquality(cg, cg.Emit(left), right);

        internal static TypeSymbol EmitStrictEquality(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Boolean:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // bool == bool
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Double ||
                        ytype.SpecialType == SpecialType.System_Int32 ||
                        ytype.SpecialType == SpecialType.System_Int64 ||
                        ytype.SpecialType == SpecialType.System_String ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray) ||
                        ytype == cg.CoreTypes.PhpString ||
                        ytype == cg.CoreTypes.Object)
                    {
                        // bool == something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else
                    {
                        // bool == PhpValue
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_bool_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                case SpecialType.System_Int32:
                    cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_Int32)
                    {
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                        ytype = cg.CoreTypes.Long;
                    }

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 === i8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 === number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_long_PhpNumber)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Boolean ||
                        ytype.SpecialType == SpecialType.System_String ||
                        ytype.SpecialType == SpecialType.System_Double ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray) ||
                        ytype == cg.CoreTypes.Object ||
                        ytype == cg.CoreTypes.PhpString)
                    {
                        // i8 === something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else
                    {
                        // i8 === PhpValue
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_long_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                case SpecialType.System_Double:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 == r8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // r8 === number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_double_PhpNumber)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Boolean ||
                        ytype.SpecialType == SpecialType.System_Int32 ||
                        ytype.SpecialType == SpecialType.System_Int64 ||
                        ytype.SpecialType == SpecialType.System_String ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray) ||
                        ytype == cg.CoreTypes.Object ||
                        ytype == cg.CoreTypes.PhpString)
                    {
                        // r8 == something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else
                    {
                        // r8 == PhpValue
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_double_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                case SpecialType.System_String:
                    // string === RValue
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // string === string
                        return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(SpecialMember.System_String__op_Equality));
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Boolean ||
                        ytype.SpecialType == SpecialType.System_Int32 ||
                        ytype.SpecialType == SpecialType.System_Int64 ||
                        ytype.SpecialType == SpecialType.System_Double ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray))
                    {
                        // string == something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype.SpecialType == SpecialType.System_Object && right.ConstantValue.IsNull())
                    {
                        // comparison to NULL
                        // string === NULL
                        // Template: ReferenceEquals( string, object )
                        return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(SpecialMember.System_Object__ReferenceEquals))
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // string === value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_string_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                default:

                    // === NULL
                    if (right.ConstantValue.IsNull())
                    {
                        if (xtype.IsReferenceType && xtype != cg.CoreTypes.PhpAlias)
                        {
                            // Template: <STACK> == null
                            cg.Builder.EmitNullConstant();
                            cg.Builder.EmitOpCode(ILOpCode.Ceq);
                            return cg.CoreTypes.Boolean;
                        }

                        // StrictCeqNull( <VALUE> )
                        xtype = cg.EmitConvertToPhpValue(xtype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeqNull_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                    // TODO: PhpArray, Object === ...

                    xtype = cg.EmitConvertToPhpValue(xtype, 0);
                    ytype = cg.Emit(right);

                    if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // PhpValue == bool
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_PhpValue_bool)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // value === string
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_PhpValue_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }

                        // PhpValue == PhpValue
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_PhpValue_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }
            }
        }

        /// <summary>
        /// Emits comparison operator pushing <c>bool</c> (<c>i4</c> of value <c>0</c> or <c>1</c>) onto the evaluation stack.
        /// </summary>
        /// <param name="cg">Code generator helper.</param>
        /// <param name="lt">True for <c>clt</c> (less than) otherwise <c>cgt</c> (greater than).</param>
        /// <returns>Resulting type code pushed onto the top of evaliuation stack.</returns>
        TypeSymbol EmitLtGt(CodeGenerator cg, bool lt)
            => EmitLtGt(cg, cg.Emit(Left), Right, lt);

        /// <summary>
        /// Emits comparison operator pushing <c>bool</c> (<c>i4</c> of value <c>0</c> or <c>1</c>) onto the evaluation stack.
        /// </summary>
        /// <returns>Resulting type code pushed onto the top of evaluation stack.</returns>
        internal static TypeSymbol EmitLtGt(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, bool lt)
        {
            TypeSymbol ytype;
            var il = cg.Builder;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                    ytype = cg.Emit(right);    // bool|int -> long

                    // Template: Operators.CompareNull(value)
                    if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.CompareNull_value);

                    // {comparison }<> 0
                    il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                    il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int32:
                    // i4 -> i8
                    il.EmitOpCode(ILOpCode.Conv_i8);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // bool|int -> long
                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 <> r8
                        return cg.EmitCall(ILOpCode.Call, lt
                            ? cg.CoreMethods.Operators.Clt_long_double
                            : cg.CoreMethods.Operators.Cgt_long_double);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 <> number
                        return cg.EmitCall(ILOpCode.Call, lt
                            ? cg.CoreMethods.PhpNumber.lt_long_number
                            : cg.CoreMethods.PhpNumber.gt_long_number);
                    }
                    else
                    {
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }

                        // compare(i8, value) <> 0
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_long_value);

                        il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right);    // bool|int|long|number -> double
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 <> r8
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    else
                    {
                        // compare(r8, value)
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_double_value);

                        // <> 0
                        il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_String:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // compare(string, string)
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_string);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // compare(string, long)
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_long);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // compare(string, double)
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_double);
                    }
                    else
                    {
                        // compare(string, value)
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_value);
                    }

                    // <> 0
                    il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                    il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Boolean:

                    cg.EmitConvert(right, cg.CoreTypes.Boolean);
                    ytype = cg.CoreTypes.Boolean;

                    // compare(bool, bool)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_bool_bool);

                    // <> 0
                    il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                    il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    return cg.CoreTypes.Boolean;

                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // bool|int -> long
                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number <> i8
                            return cg.EmitCall(ILOpCode.Call, lt
                                ? cg.CoreMethods.PhpNumber.lt_number_long
                                : cg.CoreMethods.PhpNumber.gt_number_long)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number <> r8
                            return cg.EmitCall(ILOpCode.Call, lt
                                ? cg.CoreMethods.PhpNumber.lt_number_double
                                : cg.CoreMethods.PhpNumber.gt_number_double)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number <> number
                            return cg.EmitCall(ILOpCode.Call, lt
                                ? cg.CoreMethods.PhpNumber.lt_number_number
                                : cg.CoreMethods.PhpNumber.gt_number_number)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else
                        {
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }

                            // compare(number, value)
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_number_value);

                            // <> 0
                            il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);    // +1 on stack
                            il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                            return cg.CoreTypes.Boolean;
                        }
                    }
                    else
                    {
                        xtype = cg.EmitConvertToPhpValue(xtype, 0);
                        ytype = cg.Emit(right);

                        // TODO: if (ytype.SpecialType == SpecialType.System_Boolean) ...
                        // TODO: if (ytype.SpecialType == SpecialType.System_String) ...
                        // TODO: if (ytype.SpecialType == SpecialType.System_Double) ...

                        if (ytype.SpecialType == SpecialType.System_Int64 || ytype.SpecialType == SpecialType.System_Int32)
                        {
                            // compare(value, i8)
                            ytype = cg.EmitConvertIntToLong(ytype);
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_value_long);
                        }
                        else
                        {
                            // compare(value, value)
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_value_value);
                        }

                        // <> 0
                        il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                        return cg.CoreTypes.Boolean;
                    }
            }
        }

        /// <summary>
        /// Emits <c>*</c> operation.
        /// </summary>
        TypeSymbol EmitMultiply(CodeGenerator cg)
            => EmitMul(cg, cg.Emit(Left), Right);

        internal static TypeSymbol EmitMul(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> int64, string -> number

            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right); // bool|int|long|number -> double
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 * r8 : r8
                        il.EmitOpCode(ILOpCode.Mul);
                        return xtype;   // r8
                    }
                    else
                    {
                        // r8 * value : r8
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_double_value)
                                .Expect(SpecialType.System_Double);
                    }
                    //
                    throw cg.NotImplementedException($"Mul(double, {ytype.Name})", right);

                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 * i8 : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                    }
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 * r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_double)
                                .Expect(SpecialType.System_Double);
                    }
                    if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 * number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else
                    {
                        // i8 * value : number
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                    }
                    //
                    throw cg.NotImplementedException($"Mul(int64, {ytype.Name})", right);

                default:

                    if (xtype == cg.CoreTypes.PhpAlias)
                    {
                        // dereference:
                        xtype = cg.Emit_PhpAlias_GetValue();
                    }

                    //

                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));

                        if (ytype == cg.CoreTypes.PhpAlias)
                        {
                            // PhpAlias -> PhpValue
                            ytype = cg.Emit_PhpAlias_GetValue();
                        }

                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_double)
                                .Expect(cg.CoreTypes.Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number * number : number
                            cg.EmitConvertToPhpNumber(ytype, right.TypeRefMask);
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // number * value : number
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }

                        //
                        throw cg.NotImplementedException($"Mul(PhpNumber, {ytype.Name})", right);
                    }
                    else if (xtype == cg.CoreTypes.PhpValue)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));    // bool|int -> long, string -> number
                        if (ytype == cg.CoreTypes.PhpAlias)
                        {
                            // PhpAlias -> PhpValue
                            ytype = cg.Emit_PhpAlias_GetValue();
                        }

                        if (ytype == cg.CoreTypes.Long)
                        {
                            // value * i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype == cg.CoreTypes.Double)
                        {
                            // value * r8 : double
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // value * number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // value * value : number
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        //
                        throw cg.NotImplementedException($"Mul(PhpValue, {ytype.Name})", right);
                    }
                    else
                    {
                        // x -> PhpValue
                        if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value / value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_value)
                            .Expect(cg.CoreTypes.PhpNumber);

                    }


                    //
                    throw cg.NotImplementedException($"Mul({xtype.Name}, ...)", right);
            }
        }

        /// <summary>
        /// Emits <c>/</c> operator.
        /// </summary>
        TypeSymbol EmitDivision(CodeGenerator cg)
            => EmitDiv(cg, cg.Emit(Left), Right);

        internal static TypeSymbol EmitDiv(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> int64, string -> number

            if (xtype == cg.CoreTypes.PhpAlias)
            {
                // PhpAlias -> PhpValue
                xtype = cg.Emit_PhpAlias_GetValue();
            }

            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right); // bool|int|long|number -> double
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        il.EmitOpCode(ILOpCode.Div);
                        return xtype;   // r8
                    }
                    else
                    {
                        // double / value : double
                        cg.EmitConvertToPhpValue(ytype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Div_double_PhpValue);
                    }


                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertIntToLong(cg.Emit(right));  // bool|int -> long
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // long / number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_long_number)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else
                    {
                        // long / value : number
                        cg.EmitConvertToPhpValue(ytype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Div_long_PhpValue);
                    }


                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));  // bool|int -> long, string -> number
                        if (ytype == cg.CoreTypes.PhpAlias)
                        {
                            // PhpAlias -> PhpValue
                            ytype = cg.Emit_PhpAlias_GetValue();
                        }

                        if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number / number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number / i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_long);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number / r8 : r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_double);
                        }
                        else
                        {
                            // number / value : number
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_value);
                        }

                        //
                        throw cg.NotImplementedException($"Div(number, {ytype.Name})", right);
                    }
                    else
                    {
                        // x -> PhpValue
                        if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value / value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Div_PhpValue_PhpValue);

                    }

            }
        }

        /// <summary>
        /// Emits <c>pow</c> operator.
        /// </summary>
        TypeSymbol EmitPow(CodeGenerator cg)
        {
            return EmitPow(cg, cg.Emit(Left), Left.TypeRefMask, Right);
        }

        internal static TypeSymbol EmitPow(CodeGenerator cg, TypeSymbol xtype, FlowAnalysis.TypeRefMask xtype_hint, BoundExpression right)
        {
            var il = cg.Builder;

            TypeSymbol ytype;
            xtype = cg.EmitConvertIntToLong(xtype);    // int|bool -> long

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // int|bool -> long

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 ** i8 : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_long);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 ** r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_double);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 ** number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_number);
                    }
                    else
                    {
                        // y -> PhpValue
                        cg.EmitConvert(ytype, right.TypeRefMask, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // i8 ** value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_value);
                    }

                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right);    // int|bool|long|number -> double

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 ** r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_double_double);
                    }
                    else
                    {
                        // y -> PhpValue
                        cg.EmitConvert(ytype, right.TypeRefMask, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // r8 ** value : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_double_value);
                    }

                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // int|bool -> long
                        if (ytype == cg.CoreTypes.Double)
                        {
                            // number ** r8 : r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_number_double);
                        }

                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // y -> number
                            ytype = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Create_Long);
                        }

                        if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number ** number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_number_number);
                        }
                        else
                        {
                            // y -> PhpValue
                            ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask);

                            // number ** value : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_number_value);
                        }
                    }
                    else
                    {
                        // x -> PhpValue
                        xtype = cg.EmitConvertToPhpValue(xtype, xtype_hint);

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value ** value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_value_value);
                    }

            }
        }
    }

    partial class BoundUnaryEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsRead || Access.IsNone, "Access cannot be " + Access.ToString());

            TypeSymbol returned_type;

            switch (this.Operation)
            {
                case Operations.AtSign:
                    // special arrangement
                    // Template:
                    //		context.DisableErrorReporting();
                    //		s;
                    //		context.EnableErrorReporting();
                    returned_type = cg.EmitWithDisabledErrorReporting(Operand);
                    break;

                case Operations.BitNegation:
                    //Template: "~x" Operators.BitNot(x)                                     
                    returned_type = EmitBitNot(cg);
                    break;

                case Operations.Clone:
                    // Template: clone x
                    returned_type = EmitClone(cg);
                    break;

                case Operations.LogicNegation:
                    //Template: !(bool)(x);
                    cg.EmitConvertToBool(this.Operand);
                    cg.EmitLogicNegation();
                    returned_type = cg.CoreTypes.Boolean;
                    break;

                case Operations.Minus:
                    //Template: "-x"
                    returned_type = EmitMinus(cg);
                    break;

                case Operations.Plus:
                    //Template: "+x"
                    returned_type = EmitPlus(cg);
                    break;

                case Operations.Print:
                    cg.EmitEcho(this.Operand);

                    if (Access.IsRead)
                    {
                        // Always returns 1
                        cg.Builder.EmitLongConstant(1);
                        returned_type = cg.CoreTypes.Long;
                    }
                    else
                    {
                        // nobody reads the result anyway
                        returned_type = cg.CoreTypes.Void;
                    }
                    break;

                case Operations.UnsetCast:
                    // Template: "(unset)x"  null

                    cg.EmitPop(cg.Emit(this.Operand));

                    if (this.Access.IsRead)
                    {
                        cg.Builder.EmitNullConstant();
                        returned_type = cg.CoreTypes.Object;
                    }
                    else
                    {
                        returned_type = cg.CoreTypes.Void;
                    }
                    break;

                default:
                    throw ExceptionUtilities.Unreachable;
            }

            //
            if (Access.IsNone)
            {
                // Result is not read, pop the result
                cg.EmitPop(returned_type);
                returned_type = cg.CoreTypes.Void;
            }
            else if (Access.IsRead)
            {
                // Debug.Assert(returned_type.SpecialType != SpecialType.System_Void, "returns void, operation: " + this.Operation.ToString() + ", file: " + cg.ContainingFile.RelativeFilePath);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(Access);
            }

            return returned_type;
        }

        TypeSymbol EmitMinus(CodeGenerator cg)
        {
            // Template: 0L - Operand

            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            switch (t.SpecialType)
            {
                case SpecialType.System_Double:
                    // -r8
                    il.EmitOpCode(ILOpCode.Neg);
                    return t;
                case SpecialType.System_Int32:
                    // -(i8)i4
                    il.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                    il.EmitOpCode(ILOpCode.Neg);        // result will fit into long for sure
                    return cg.CoreTypes.Long;
                case SpecialType.System_Int64:
                    // PhpNumber.Minus(i8) : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Negation_long)
                            .Expect(cg.CoreTypes.PhpNumber);
                default:
                    if (t != cg.CoreTypes.PhpNumber)
                    {
                        cg.EmitConvertToPhpNumber(t, 0);
                    }

                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Negation)
                        .Expect(cg.CoreTypes.PhpNumber);
            }
        }

        TypeSymbol EmitPlus(CodeGenerator cg)
        {
            // Template: 0L + Operand

            // convert value to a number

            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            switch (t.SpecialType)
            {
                case SpecialType.System_Double:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                    return t;
                case SpecialType.System_Boolean:
                    // (long)(int)bool
                    il.EmitOpCode(ILOpCode.Conv_i4);
                    il.EmitOpCode(ILOpCode.Conv_i8);
                    return cg.CoreTypes.Long;
                default:
                    if (t != cg.CoreTypes.PhpNumber)
                    {
                        cg.EmitConvertToPhpNumber(t, 0);
                    }

                    return cg.CoreTypes.PhpNumber;
            }
        }

        TypeSymbol EmitBitNot(CodeGenerator cg)
        {
            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            switch (t.SpecialType)
            {
                case SpecialType.System_Double:
                case SpecialType.System_Int32:
                    // r8|i4 -> i8
                    il.EmitOpCode(ILOpCode.Conv_i8);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    il.EmitOpCode(ILOpCode.Not);    // ~i64 : i64
                    return cg.CoreTypes.Long;

                case SpecialType.System_Boolean:
                    throw new NotImplementedException();    // ERR
                default:
                    if (t == cg.CoreTypes.PhpArray)
                    {
                        throw new NotImplementedException(); // ERR
                    }

                    // ~ PhpValue
                    cg.EmitConvert(t, Operand.TypeRefMask, cg.CoreTypes.PhpValue);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseNot_PhpValue);
            }
        }

        TypeSymbol EmitClone(CodeGenerator cg)
        {
            // Template clone(Context, Object)
            cg.EmitLoadContext();
            var t = cg.EmitAsObject(cg.Emit(this.Operand));

            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Clone_Context_Object)
                .Expect(SpecialType.System_Object);

            //
            return t;
        }
    }

    partial class BoundConversionEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            // emit explicit 'cast' operation

            var t = cg.Emit(this.Operand);

            var target = (TypeSymbol)this.TargetType.ResolveTypeSymbol(cg.DeclaringCompilation);
            if (target.IsErrorTypeOrNull())
            {
                throw cg.NotImplementedException(op: this);
            }

            if (Access.IsNone)
            {
                cg.EmitPop(t);
                return cg.CoreTypes.Void;
            }

            var conv = cg.DeclaringCompilation.ClassifyExplicitConversion(t, target);
            if (conv.Exists == false && t.IsVoid())
            {
                if (target.IsValueType)
                {
                    // 0
                    cg.EmitLoadDefault(target);
                }
                else if (target.SpecialType == SpecialType.System_String)
                {
                    // ""
                    cg.Builder.EmitStringConstant(string.Empty);
                }
                else if (target.Is_PhpArray())
                {
                    // PhpArray(0)
                    cg.Emit_PhpArray_NewEmpty();
                }
                else
                {
                    throw cg.NotImplementedException($"Conversion from {t} to {target}");
                }
            }
            else
            {
                cg.EmitConversion(conv, t, target);
            }

            //

            return target;
        }
    }

    partial class BoundCallableConvert
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var m = TargetCallable as MethodSymbol;

            if ((m != null && m.IsValidMethod()) ||
                (m is AmbiguousMethodSymbol a && a.IsOverloadable && a.Ambiguities.Length != 0))
            {
                if (m.IsStatic)
                {
                    return m.EmitLoadRoutineInfo(cg);
                }
                else
                {
                    Debug.Assert(Receiver != null);

                    // PhpCallback.Create((object)Receiver, methodRoutineInfo)
                    cg.EmitConvert(Receiver, cg.CoreTypes.Object);
                    m.EmitLoadRoutineInfo(cg);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BindTargetToMethod_Object_RoutineInfo)
                        .Expect(cg.CoreTypes.IPhpCallable);
                }
            }

            // generic conversion to IPhpCallable:
            var target = (TypeSymbol)this.TargetType.ResolveTypeSymbol(cg.DeclaringCompilation);    // always IPhpCallable

            // 
            cg.EmitConvert(this.Operand, target);
            return target;
        }
    }

    partial class BoundLiteral
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsRead || Access.IsNone);

            // do nothing
            if (this.Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }

            // push value onto the evaluation stack

            Debug.Assert(ConstantValue.HasValue);
            return cg.EmitLoadConstant(ConstantValue.Value, this.Access.TargetType);
        }
    }

    partial class BoundCopyValue
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var expr = this.Expression;
            var t = cg.Emit(expr);

            if (expr.IsDeeplyCopied)
            {
                // dereference
                if (expr.TypeRefMask.IsRef)
                {
                    t = cg.EmitDereference(t);
                }

                // copy
                t = cg.EmitDeepCopy(t, expr.TypeRefMask);
            }

            //
            return t;
        }
    }

    partial class BoundReferenceExpression
    {
        /// <summary>
        /// Gets <see cref="IVariableReference"/> providing load and store operations.
        /// </summary>
        internal abstract IVariableReference BindPlace(CodeGenerator cg);

        internal abstract IPlace Place();

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsRead || this.Access.IsNone);

            if (Access.IsNone)
            {
                // do nothing
                return cg.CoreTypes.Void;
            }

            if (ConstantValue.HasValue)
            {
                return cg.EmitLoadConstant(ConstantValue.Value, this.Access.TargetType);
            }

            var boundplace = this.BindPlace(cg);
            if (boundplace != null)
            {
                return boundplace.EmitLoadValue(cg, Access);
            }
            else
            {
                throw cg.NotImplementedException($"IVariableReference of {this} is null!");
            }
        }
    }

    partial class BoundVariableName
    {
        /// <summary>
        /// Emits the name of variable leaving <c>string</c> on top of evaluation stack.
        /// </summary>
        internal TypeSymbol EmitVariableName(CodeGenerator cg)
        {
            if (this.IsDirect)
            {
                cg.Builder.EmitStringConstant(this.NameValue.Value);
            }
            else
            {
                cg.EmitConvert(this.NameExpression, cg.CoreTypes.String);
            }

            //
            return cg.CoreTypes.String;
        }

        internal void EmitIntStringKey(CodeGenerator cg)
        {
            if (this.IsDirect)
            {
                cg.EmitIntStringKey(this.NameValue.Value);
            }
            else
            {
                cg.EmitIntStringKey(this.NameExpression);
            }
        }
    }

    partial class BoundVariableRef
    {
        internal override IVariableReference BindPlace(CodeGenerator cg) => this.Variable; // .BindPlace(cg.Builder, this.Access, this.BeforeTypeRef);

        internal override IPlace Place() => this.Variable.Place;
    }

    partial class BoundListEx : IVariableReference
    {
        internal override IVariableReference BindPlace(CodeGenerator cg) => this;

        internal override IPlace Place() => null;

        /// <summary>
        /// Emits conversion to <c>IPhpArray</c>.
        /// Emits empty array on top of stack if object cannot be used as array.
        /// </summary>
        static TypeSymbol/*!*/EmitListAccess(CodeGenerator cg, TypeSymbol valueType)
        {
            Debug.Assert(valueType != null);

            if (valueType.IsReferenceType)
            {
                if (valueType.IsOfType(cg.CoreTypes.IPhpArray))
                {
                    return valueType; // keep value on stack
                }

                if (valueType.IsOfType(cg.CoreTypes.ArrayAccess))
                {
                    // Template: EnsureArray( ArrayAccess) : IPhpArray
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_ArrayAccess);
                }
            }

            // Template: Operators: GetListAccess( (PhpValue)value )
            cg.EmitConvertToPhpValue(valueType, 0);
            return cg.EmitCall(ILOpCode.Call, cg.CoreTypes.Operators.Method("GetListAccess", cg.CoreTypes.PhpValue));
        }

        static void EmitItemAssign(CodeGenerator cg, KeyValuePair<BoundExpression, BoundReferenceExpression> item, long index, IPlace arrplace)
        {
            var target = item;
            if (target.Value == null)
            {
                return;
            }

            // Template: <vars[i]> = <tmp>[i]

            var boundtarget = target.Value.BindPlace(cg);
            var lhs = boundtarget.EmitStorePreamble(cg, target.Value.TargetAccess());

            // LOAD IPhpArray.GetItemValue(IntStringKey{i})
            arrplace.EmitLoad(cg.Builder);
            if (target.Key == null)
            {
                cg.EmitIntStringKey(index);
            }
            else
            {
                cg.EmitIntStringKey(target.Key);
            }

            // GetItemVaue
            var itemtype = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.GetItemValue_IntStringKey);

            // dereference
            itemtype = cg.EmitDereference(itemtype);

            // copy
            itemtype = cg.EmitDeepCopy(itemtype, nullcheck: true);

            // STORE vars[i]
            boundtarget.EmitStore(cg, ref lhs, itemtype, target.Value.Access);
            lhs.Dispose();
        }

        #region IVariableReference

        Symbol IVariableReference.Symbol => null;

        TypeSymbol IVariableReference.Type => null; // throw new NotImplementedException();

        bool IVariableReference.HasAddress => false;

        IPlace IVariableReference.Place => null;

        LhsStack IVariableReference.EmitStorePreamble(CodeGenerator cg, BoundAccess access)
        {
            // nada
            return default;
        }

        void IVariableReference.EmitStore(CodeGenerator cg, ref LhsStack lhs, TypeSymbol stack, BoundAccess access)
        {
            var rtype = EmitListAccess(cg, stack);

            var tmp = cg.GetTemporaryLocal(rtype);
            cg.Builder.EmitLocalStore(tmp);

            var items = this.Items;

            // NOTE: since PHP7, variables are assigned from left to right

            for (int i = 0; i < items.Length; i++)
            {
                EmitItemAssign(cg, items[i], i, new LocalPlace(tmp));
            }

            //
            cg.ReturnTemporaryLocal(tmp);
        }

        TypeSymbol IVariableReference.EmitLoadValue(CodeGenerator cg, ref LhsStack lhsStack, BoundAccess access)
        {
            throw new InvalidOperationException("list() as R-Value at " + ExceptionUtilities.GuessSourceLocation(cg, this));
        }

        TypeSymbol IVariableReference.EmitLoadAddress(CodeGenerator cg, ref LhsStack lhsStack)
        {
            throw new InvalidOperationException("list() as R-Value at " + ExceptionUtilities.GuessSourceLocation(cg, this));
        }

        #endregion
    }

    partial class BoundFieldRef
    {
        internal IVariableReference BoundReference { get; set; }

        internal override IVariableReference BindPlace(CodeGenerator cg) => BoundReference;

        internal override IPlace Place() => BoundReference?.Place;
    }

    partial class BoundRoutineCall
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            EmitBeforeCall(cg);

            if (TargetMethod.IsValidMethod())
            {
                Debug.Assert(!TargetMethod.IsUnreachable);
                // the most preferred case when method is known,
                // the method can be called directly
                return EmitDirectCall(cg, IsVirtualCall ? ILOpCode.Callvirt : ILOpCode.Call, TargetMethod, (BoundTypeRef)LateStaticTypeRef);
            }
            else if (TargetMethod is MagicCallMethodSymbol magic && !this.HasArgumentsUnpacking)
            {
                return EmitMagicCall(cg, magic.OriginalMethodName, magic.RealMethod, (BoundTypeRef)LateStaticTypeRef);
            }
            else
            {
                //
                return EmitDynamicCall(cg);
            }
        }

        internal virtual void EmitBeforeCall(CodeGenerator cg)
        {

        }

        /// <summary>
        /// Emits the routine call in case the method symbol couldn't be resolved or it cannot be called directly.
        /// </summary>
        internal virtual TypeSymbol EmitDynamicCall(CodeGenerator cg)
        {
            return EmitCallsiteCall(cg);
        }

        internal TypeSymbol EmitDirectCall(CodeGenerator cg, ILOpCode opcode, MethodSymbol method, BoundTypeRef staticType = null)
        {
            // TODO: in case of a global user routine -> emit check the function is declared
            // <ctx>.AssertFunctionDeclared

            var stacktype = this.HasArgumentsUnpacking
                ? cg.EmitCall_UnpackingArgs(opcode, method, this.Instance, _arguments, staticType)  // call method with respect to argument unpacking
                : cg.EmitCall(opcode, method, this.Instance, _arguments, staticType);               // call method and pass provided arguments as they are

            //
            return (this.ResultType = cg.EmitMethodAccess(stacktype, method, Access));
        }

        /// <summary>
        /// Determines if the target magic method will be called using standard calling convention.
        /// </summary>
        static bool IsClrMagicCall(MethodSymbol method)
        {
            if (method.ContainingType.IsPhpType())
            {
                // defined in PHP source, use PHP calling convention
                return false;
            }

            var parameters = method.Parameters;
            if (parameters.Last().IsParams)
            {
                return true;
            }

            //var nimplicit = parameters.TakeWhile(p => p.IsImplicitlyDeclared).Count();

            //var actualparameters = parameters.Length - nimplicit;
            //if (actualparameters != 2)
            //{
            //    return true;
            //}

            //if (!parameters.Last().Type.Is_PhpArray() &&
            //    !parameters.Last().Type.Is_PhpValue())
            //{
            //    return true;
            //}

            // regular PHP semantic:
            // __call(name, PhpArray arguments)
            return false;
        }

        internal TypeSymbol EmitMagicCall(CodeGenerator cg, string originalMethodName, MethodSymbol method, BoundTypeRef staticType = null)
        {
            // call to __callStatic() or __call()
            Debug.Assert(
                string.Equals(method.Name, Name.SpecialMethodNames.Call.Value, StringComparison.OrdinalIgnoreCase) ||
                string.Equals(method.Name, Name.SpecialMethodNames.CallStatic.Value, StringComparison.OrdinalIgnoreCase));

            if (this.HasArgumentsUnpacking)
            {
                throw cg.NotImplementedException("__callStatic() with Arguments Unpacking", this);
            }

            ImmutableArray<BoundArgument> realArguments;

            var boundname = BoundArgument.Create(new BoundLiteral(originalMethodName).WithAccess(BoundAccess.Read));

            if (IsClrMagicCall(method))
            {
                // method is CLR method with params => don't pack arguments into phparray and call method normally
                // first argument is the method name:
                realArguments = _arguments.Insert(0, boundname);
            }
            else
            {
                // PHP behavior
                realArguments = ImmutableArray.Create(
                    // $name: string
                    boundname,
                    // $arguments: PhpArray
                    BoundArgument.Create(
                        new BoundArrayEx(
                            _arguments.Select(
                                arg => new KeyValuePair<BoundExpression, BoundExpression>(null, arg.Value)
                            ).ToImmutableArray())
                        .WithAccess(BoundAccess.Read))
                    );
            }

            //
            var opcode = (method.IsVirtual || IsVirtualCall) ? ILOpCode.Callvirt : ILOpCode.Call;

            //
            var stackType = cg.EmitCall(opcode, method, this.Instance, realArguments, staticType);

            return cg.EmitMethodAccess(stackType, method, Access);
        }

        protected virtual bool IsVirtualCall => true;

        /// <summary>Type reference to the static type. The containing type of called routine, e.g. <c>THE_TYPE::foo()</c>. Used for direct method call requiring late static type..</summary>
        protected virtual IBoundTypeRef LateStaticTypeRef => null;

        #region Emit CallSite

        protected virtual bool CallsiteRequiresCallerContext => false;
        protected virtual string CallsiteName => null;
        protected virtual BoundExpression RoutineNameExpr => null;
        protected virtual IBoundTypeRef RoutineTypeRef => null;

        /// <summary>
        /// Optional. Emits instance on which the method is invoked.
        /// In case of instance function call, it is the instance expression,
        /// in case of static method, it is reference to <c>$this</c> which may be needed in some cases.
        /// </summary>
        /// <returns>Type left on stack. Can be <c>null</c> if callsite does not expect a target.</returns>
        internal virtual TypeSymbol EmitTarget(CodeGenerator cg)
        {
            if (Instance != null)
            {
                return cg.Emit(Instance);
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Emits <c>System.Type[]</c> of type arguments.
        /// </summary>
        internal TypeSymbol EmitTypeArgumentsArray(CodeGenerator cg)
        {
            var system_type = cg.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Type);

            if (this.TypeArguments.IsDefaultOrEmpty)
            {
                // most common case
                return cg.Emit_EmptyArray(system_type);
            }
            else
            {
                return cg.Emit_NewArray(
                    system_type,
                    this.TypeArguments,
                    tref =>
                    {
                        var t = (BoundTypeRef)tref;
                        if (t.ResolvedType.IsErrorTypeOrNull())
                        {
                            throw ExceptionUtilities.NotImplementedException(cg, "type argument has not been resolved", this);
                        }

                        return cg.EmitSystemType(t.ResolvedType);
                    });
            }
        }

        internal TypeSymbol EmitCallsiteCall(CodeGenerator cg)
        {
            // callsite

            var callsite = cg.Factory.StartCallSite("call_" + this.CallsiteName);

            // LOAD callsite.Target
            callsite.EmitLoadTarget();

            // LOAD callsite arguments

            // (callsite, ctx, [target], [name], ...)
            callsite.EmitLoadCallsite();                // callsite
            callsite.EmitTargetInstance(EmitTarget);    // [target]
            callsite.EmitTargetTypeParam(RoutineTypeRef);// [target_type] : PhpTypeInfo
            callsite.EmitLateStaticTypeParam(LateStaticTypeRef);    // [late_static] : PhpTypeInfo
            callsite.EmitNameParam(RoutineNameExpr);    // [name] : string
            callsite.EmitLoadContext();                 // ctx : Context

            if (this.TypeArguments.IsDefaultOrEmpty == false)
            {
                callsite.AddArg(EmitTypeArgumentsArray(cg), false); // typeargs : System.Type[]
            }

            if (CallsiteRequiresCallerContext)
            {
                callsite.EmitCallerTypeParam();         // [class_ctx] : RuntimeTypeHandle
            }

            callsite.EmitArgs(_arguments);              // ...

            // RETURN TYPE:
            var return_type = this.Access.IsRead
                    ? this.Access.IsReadRef ? cg.CoreTypes.PhpAlias.Symbol
                    : this.Access.EnsureArray ? cg.CoreTypes.IPhpArray.Symbol
                    : this.Access.EnsureObject ? cg.CoreTypes.Object.Symbol
                    : (this.Access.TargetType ?? cg.CoreTypes.PhpValue.Symbol)
                : cg.CoreTypes.Void.Symbol;

            // Target()
            var functype = cg.Factory.GetCallSiteDelegateType(
                null, RefKind.None,
                callsite.Arguments,
                callsite.ArgumentsRefKinds,
                null,
                return_type);

            cg.EmitCall(ILOpCode.Callvirt, functype.DelegateInvokeMethod);

            // Create CallSite ...
            callsite.Construct(functype, cctor_cg => BuildCallsiteCreate(cctor_cg, return_type));

            //
            return return_type;
        }

        internal virtual void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype) { throw new InvalidOperationException(); }

        #endregion
    }

    partial class BoundGlobalFunctionCall
    {
        protected override string CallsiteName => _name.IsDirect ? _name.NameValue.ToString() : null;
        protected override BoundExpression RoutineNameExpr => _name.NameExpression;
        protected override bool IsVirtualCall => false;

        internal override TypeSymbol EmitDynamicCall(CodeGenerator cg)
        {
            if (_name.IsDirect)
            {
                return EmitCallsiteCall(cg);
            }
            else
            {
                Debug.Assert(_name.NameExpression != null);

                // better to use PhpCallback.Invoke instead of call sites

                // Template: NameExpression.AsCallback().Invoke(Context, PhpValue[])

                cg.EmitConvert(_name.NameExpression, cg.CoreTypes.IPhpCallable);    // (IPhpCallable)Name
                cg.EmitLoadContext();       // Context
                cg.Emit_ArgumentsIntoArray(_arguments, default(PhpSignatureMask)); // PhpValue[]

                return cg.EmitMethodAccess(
                    stack: cg.EmitCall(ILOpCode.Callvirt, cg.CoreTypes.IPhpCallable.Symbol.LookupMember<MethodSymbol>("Invoke")),
                    method: null,
                    access: this.Access);
            }
        }

        internal override void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype)
        {
            cg.Builder.EmitStringConstant(CallsiteName);    // function name
            cg.Builder.EmitStringConstant(_nameOpt.HasValue ? _nameOpt.Value.ToString() : null);    // fallback function name
            cg.EmitLoadToken(returntype, null);             // return type
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Dynamic.BinderFactory_Function);
        }
    }

    partial class BoundInstanceFunctionCall
    {
        protected override bool CallsiteRequiresCallerContext => true;
        protected override string CallsiteName => _name.IsDirect ? _name.NameValue.ToString() : null;
        protected override BoundExpression RoutineNameExpr => _name.NameExpression;

        internal override void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype)
        {
            cg.Builder.EmitStringConstant(CallsiteName);        // name
            cg.EmitLoadToken(cg.CallerType, null);              // class context
            cg.EmitLoadToken(returntype, null);                 // return type
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Dynamic.BinderFactory_InstanceFunction);
        }
    }

    partial class BoundStaticFunctionCall
    {
        protected override bool CallsiteRequiresCallerContext => true;
        protected override string CallsiteName => _name.IsDirect ? _name.NameValue.ToString() : null;
        protected override BoundExpression RoutineNameExpr => _name.NameExpression;
        protected override IBoundTypeRef RoutineTypeRef => _typeRef.ResolvedType.IsErrorTypeOrNull() ? _typeRef : null;    // in case the type has to be resolved in runtime and passed to callsite
        protected override IBoundTypeRef LateStaticTypeRef => _typeRef;  // used for direct routine call requiring late static type
        protected override bool IsVirtualCall => false;

        /// <summary>
        /// Emits current class instance, expected by callsite to resolve instance function called statically.
        /// </summary>
        internal override TypeSymbol EmitTarget(CodeGenerator cg)
        {
            return cg.EmitPhpThisOrNull();
        }

        internal override void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype)
        {
            cg.EmitLoadToken(_typeRef.ResolvedType, null);      // type
            cg.Builder.EmitStringConstant(CallsiteName);        // name
            cg.EmitLoadToken(cg.CallerType, null);              // class context
            cg.EmitLoadToken(returntype, null);                 // return type
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Dynamic.BinderFactory_StaticFunction);
        }

        internal override void EmitBeforeCall(CodeGenerator cg)
        {
            // ensure type is declared
            if (_typeRef.ResolvedType.IsValidType())
            {
                cg.EmitExpectTypeDeclared(_typeRef.ResolvedType);
            }
        }
    }

    partial class BoundNewEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var t = EmitNewClass(cg);

            // void
            if (Access.IsNone)
            {
                cg.EmitPop(t);
                return cg.CoreTypes.Void;
            }

            // &new // deprecated
            if (Access.IsReadRef)
            {
                // new PhpAlias(PhpValue.FromClass(.newobj))
                cg.EmitConvertToPhpValue(t, 0);
                return cg.Emit_PhpValue_MakeAlias();
            }

            //
            Debug.Assert(Access.IsRead);
            return t;
        }

        private TypeSymbol EmitNewClass(CodeGenerator cg)
        {
            if (!TargetMethod.IsErrorMethodOrNull())
            {
                // when instantiating anonoymous class
                // it has to be declared into the context (right before instantiation)
                if (TargetMethod.ContainingType.IsAnonymousType)
                {
                    // <ctx>.DeclareType<T>()
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Context.DeclareType_T.Symbol.Construct(TargetMethod.ContainingType)).Expect(SpecialType.System_Void);
                }
                else
                {
                    // ensure type is declared
                    cg.EmitExpectTypeDeclared(TargetMethod.ContainingType);
                }

                // Template: new T(args)
                return EmitDirectCall(cg, ILOpCode.Newobj, TargetMethod);
            }
            else
            {
                if (((BoundTypeRef)_typeref).ResolvedType.IsValidType())
                {
                    // ensure type is delcared
                    cg.EmitExpectTypeDeclared(_typeref.Type);

                    // context.Create<T>(caller, params)
                    var create_t = cg.CoreTypes.Context.Symbol.GetMembers("Create")
                        .OfType<MethodSymbol>()
                        .Single(s => s.Arity == 1 && s.ParameterCount == 2 &&
                            s.Parameters[1].IsParams &&
                            SpecialParameterSymbol.IsCallerClassParameter(s.Parameters[0]))
                        .Construct(_typeref.Type);

                    cg.EmitLoadContext();               // Context
                    cg.EmitCallerTypeHandle();          // RuntimeTypeHandle
                    cg.Emit_ArgumentsIntoArray(_arguments, default);  // PhpValue[]

                    return cg.EmitCall(ILOpCode.Call, create_t);
                }
                else
                {
                    // ctx.Create(caller, PhpTypeInfo, params)
                    var create = cg.CoreTypes.Context.Symbol.GetMembers("Create")
                        .OfType<MethodSymbol>()
                        .Single(s => s.Arity == 0 && s.ParameterCount == 3 &&
                            s.Parameters[1].Type == cg.CoreTypes.PhpTypeInfo &&
                            s.Parameters[2].IsParams && ((ArrayTypeSymbol)s.Parameters[2].Type).ElementType == cg.CoreTypes.PhpValue &&
                            SpecialParameterSymbol.IsCallerClassParameter(s.Parameters[0]))
;

                    cg.EmitLoadContext();               // Context
                    cg.EmitCallerTypeHandle();          // RuntimeTypeHandle
                    _typeref.EmitLoadTypeInfo(cg, true);// PhpTypeInfo
                    cg.Emit_ArgumentsIntoArray(_arguments, default);  // PhpValue[]

                    return cg.EmitCall(ILOpCode.Call, create);
                }
            }
        }
    }

    partial class BoundThrowExpression
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            cg.EmitConvert(Thrown, cg.CoreTypes.Exception);

            // throw <stack>;
            cg.Builder.EmitThrow(false);

            // push a default value (void)
            // stack is adjusted by caller if necessary
            return cg.CoreTypes.Void;
        }
    }

    partial class BoundEcho
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsNone);

            var args = ArgumentsInSourceOrder;
            for (int i = 0; i < args.Length; i++)
            {
                cg.EmitEcho(args[i].Value);
            }

            return cg.CoreTypes.Void;
        }
    }

    partial class BoundConcatEx
    {
        static SpecialMember? TryResolveConcatMethod(int stringargs) => stringargs switch
        {
            2 => (SpecialMember?)SpecialMember.System_String__ConcatStringString,
            3 => SpecialMember.System_String__ConcatStringStringString,
            4 => SpecialMember.System_String__ConcatStringStringStringString,
            _ => null,
        };

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var args = this.ArgumentsInSourceOrder;

            if (args.Length == 0)
            {
                // ""
                cg.Builder.EmitStringConstant(string.Empty);
                return cg.CoreTypes.String;
            }

            if (cg.IsReadonlyStringOnly(this.TypeRefMask) || this.Access.TargetType == cg.CoreTypes.String)
            {
                // the expression is annotated as it returns "System.String",
                // all its arguments are UTF16 values
                // perform standard System.String.Concat():

                var concat_method = TryResolveConcatMethod(args.Length);
                if (concat_method.HasValue)
                {
                    // Template: System.String.Concat( ... )
                    foreach (var x in args)
                    {
                        cg.EmitConvert(x.Value, cg.CoreTypes.String);
                    }

                    // String.Concat( (string)0, (string)1, ... );
                    return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(concat_method.Value))
                        .Expect(SpecialType.System_String);
                }
                else if (args.Length == 1)
                {
                    // Template: (string)arg[0]
                    cg.EmitConvert(args[0].Value, cg.CoreTypes.String);
                    return cg.CoreTypes.String;
                }
                else
                {
                    // Template: String.Concat( new []{ ... } )
                    cg.Emit_NewArray(cg.CoreTypes.String, args);
                    return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringArray))
                        .Expect(SpecialType.System_String);
                }
            }

            // returning PhpString:

            if (args.Length == 1)
            {
                // Template: (PhpString)args[0]
                cg.EmitConvert(args[0].Value, cg.CoreTypes.PhpString);
                return cg.CoreTypes.PhpString;
            }

            // Template: new PhpString( new PhpString.Blob() { a1, a2, ..., aN } )

            // new PhpString.Blob()
            cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.Blob);

            // TODO: overload for 2, 3, 4 parameters directly

            // <PhpString>.Append(<expr>)
            foreach (var x in args)
            {
                var expr = x.Value;
                if (IsEmpty(expr))
                {
                    continue;
                }

                //
                cg.Builder.EmitOpCode(ILOpCode.Dup);    // <Blob>
                cg.Emit_PhpStringBlob_Append(expr);     // .Append( ... )
            }

            // new PhpString( <Blob> )
            return cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpString_Blob)
                .Expect(cg.CoreTypes.PhpString);
        }

        static bool IsEmpty(BoundExpression x) => x.ConstantValue.HasValue && ExpressionsExtension.IsEmptyStringValue(x.ConstantValue.Value);
    }

    partial class BoundIncludeEx
    {
        /// <summary>
        /// True for <c>include_once</c> or <c>require_once</c>.
        /// </summary>
        public bool IsOnceSemantic => this.InclusionType == InclusionTypes.IncludeOnce || this.InclusionType == InclusionTypes.RequireOnce;

        /// <summary>
        /// True for <c>require</c> or <c>require_once</c>.
        /// </summary>
        public bool IsRequireSemantic => this.InclusionType == InclusionTypes.Require || this.InclusionType == InclusionTypes.RequireOnce;

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            TypeSymbol result;
            var isvoid = this.Access.IsNone;

            Debug.Assert(_arguments.Length == 1);
            Debug.Assert(_arguments[0].Value.Access.IsRead);
            Debug.Assert(Access.IsRead || Access.IsNone);

            var method = this.TargetMethod;
            if (method != null) // => IsResolved
            {
                // emit condition for include_once/require_once
                if (IsOnceSemantic)
                {
                    var tscript = method.ContainingType;

                    result = isvoid
                        ? cg.CoreTypes.Void.Symbol
                        : cg.DeclaringCompilation.GetTypeFromTypeRef(cg.Routine.TypeRefContext, this.TypeRefMask);

                    // Template: (<ctx>.CheckIncludeOnce<TScript>()) ? <Main>() : TRUE
                    // Template<isvoid>: if (<ctx>.CheckIncludeOnce<TScript>()) <Main>()
                    var falseLabel = new object();
                    var endLabel = new object();

                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.CheckIncludeOnce_TScript.Symbol.Construct(tscript));

                    cg.Builder.EmitBranch(ILOpCode.Brfalse, falseLabel);

                    // ? (PhpValue)<Main>(...)
                    cg.EmitCallMain(method);
                    if (isvoid)
                    {
                        cg.EmitPop(method.ReturnType);
                    }
                    else
                    {
                        cg.EmitConvert(method.ReturnType, 0, result);
                    }
                    cg.Builder.EmitBranch(ILOpCode.Br, endLabel);

                    if (!isvoid)
                    {
                        cg.Builder.AdjustStack(-1);
                    }

                    // : PhpValue.Create(true)
                    cg.Builder.MarkLabel(falseLabel);
                    if (!isvoid)
                    {
                        cg.Builder.EmitBoolConstant(true);
                        cg.EmitConvert(cg.CoreTypes.Boolean, 0, result);
                    }

                    //
                    cg.Builder.MarkLabel(endLabel);
                }
                else
                {
                    // <Main>
                    result = cg.EmitCallMain(method);
                }
            }
            else
            {
                Debug.Assert(cg.LocalsPlaceOpt != null);

                // Template: <ctx>.Include(dir, path, locals, @this, self, bool once = false, bool throwOnError = false)
                cg.EmitLoadContext();
                cg.Builder.EmitStringConstant(cg.ContainingFile.DirectoryRelativePath);
                cg.EmitConvert(_arguments[0].Value, cg.CoreTypes.String);
                cg.LocalsPlaceOpt.EmitLoad(cg.Builder); // scope of local variables, corresponds to $GLOBALS in global scope.
                cg.EmitThisOrNull();    // $this
                cg.EmitCallerTypeHandle();    // self : RuntimeTypeHandle
                cg.Builder.EmitBoolConstant(IsOnceSemantic);
                cg.Builder.EmitBoolConstant(IsRequireSemantic);
                return cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.Include_string_string_PhpArray_object_RuntimeTypeHandle_bool_bool);
            }

            //
            return result;
        }
    }

    partial class BoundLambda
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            if (this.BoundLambdaMethod == null)
            {
                throw new InvalidOperationException();
            }

            // Template: BuildClosure(ctx, BoundLambdaMethod.EnsureRoutineInfoField(), this, scope, statictype, [use1, use2, ...], [p1, p2, ...])

            var idxfld = this.BoundLambdaMethod.EnsureRoutineInfoField(cg.Module);

            cg.EmitLoadContext();           // Context
            idxfld.EmitLoad(cg);            // routine
            EmitThis(cg);                   // $this
            cg.EmitCallerTypeHandle();      // scope
            EmitStaticType(cg);             // statictype : PhpTypeInfo
            EmitParametersArray(cg);        // "parameters"
            EmitUseArray(cg);               // "static"

            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BuildClosure_Context_IPhpCallable_Object_RuntimeTypeHandle_PhpTypeInfo_PhpArray_PhpArray);
        }

        void EmitThis(CodeGenerator cg)
        {
            cg.EmitPhpThisOrNull();
        }

        void EmitStaticType(CodeGenerator cg)
        {
            if ((cg.Routine.Flags & FlowAnalysis.RoutineFlags.UsesLateStatic) != 0)
            {
                cg.EmitLoadStaticPhpTypeInfo();
            }
            else
            {
                cg.Builder.EmitNullConstant();
            }
        }

        void EmitUseArray(CodeGenerator cg)
        {
            if (UseVars.Length != 0)
            {
                // new PhpArray(<count>)
                cg.Builder.EmitIntConstant(UseVars.Length);
                cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray_int);

                // uses
                foreach (var u in UseVars)
                {
                    // <stack>.SetItemValue|SetItemAlias(name, value)
                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.EmitIntStringKey(u.Parameter.Name);

                    if (u.Value.Access.IsReadRef)
                    {
                        // PhpValue.Create( PhpAlias )
                        cg.Emit(u.Value).Expect(cg.CoreTypes.PhpAlias); // PhpAlias
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Create_PhpAlias);    // PhpValue.Create
                    }
                    else
                    {
                        // PhpValue
                        cg.EmitConvert(u.Value, cg.CoreTypes.PhpValue);
                    }

                    // Add(name, value)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_IntStringKey_PhpValue);
                }
            }
            else
            {
                cg.Emit_PhpArray_Empty();
            }
        }

        void EmitParametersArray(CodeGenerator cg)
        {
            var ps = ((LambdaFunctionExpr)PhpSyntax).Signature.FormalParams;
            if (ps != null && ps.Length != 0)
            {
                // TODO: cache singleton

                // new PhpArray(<count>){ ... }
                cg.Builder.EmitIntConstant(ps.Length);
                cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray_int);

                foreach (var p in ps)
                {
                    var keyname = "$" + p.Name.Name.Value;
                    if (p.PassedByRef) keyname = "&" + keyname;
                    var value = (p.InitValue != null) ? "<optional>" : "<required>";

                    // <stack>.SetItemValue("&$name", "<optional>"|"<required>")
                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.EmitIntStringKey(keyname);
                    cg.Builder.EmitStringConstant(value);
                    cg.EmitConvertToPhpValue(cg.CoreTypes.String, 0);
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_IntStringKey_PhpValue);
                }
            }
            else
            {
                // PhpArray.Empty
                cg.Emit_PhpArray_Empty();
            }
        }
    }

    partial class BoundEvalEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(cg.LocalsPlaceOpt != null);

            // get location of evaluated code
            var filepath = cg.ContainingFile.RelativeFilePath;
            int line, col;
            var unit = this.PhpSyntax.ContainingSourceUnit;
            unit.GetLineColumnFromPosition(this.CodeExpression.PhpSyntax.Span.Start, out line, out col);

            // Template: Operators.Eval(ctx, locals, @this, self, code, currentpath, line, column)
            cg.EmitLoadContext();
            cg.LocalsPlaceOpt.EmitLoad(cg.Builder);
            cg.EmitThisOrNull();
            cg.EmitCallerTypeHandle();           // self : RuntimeTypeHandle
            cg.EmitConvert(this.CodeExpression, cg.CoreTypes.String);   // (string)code
            cg.Builder.EmitStringConstant(filepath);    // currentpath
            cg.Builder.EmitIntConstant(line);           // line
            cg.Builder.EmitIntConstant(col);            // column

            // Eval( ... )
            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Eval_Context_PhpArray_object_RuntimeTypeHandle_string_string_int_int);
        }
    }

    partial class BoundExitEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            MethodSymbol ctorsymbol;

            if (_arguments.Length == 0)
            {
                // <ctx>.Exit();
                ctorsymbol = cg.CoreMethods.Ctors.ScriptDiedException;
            }
            else
            {
                // LOAD <status>
                var t = cg.Emit(_arguments[0].Value);

                switch (t.SpecialType)
                {
                    case SpecialType.System_Int32:
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                        goto case SpecialType.System_Int64;

                    case SpecialType.System_Int64:
                        ctorsymbol = cg.CoreMethods.Ctors.ScriptDiedException_Long;
                        break;

                    default:
                        cg.EmitConvertToPhpValue(t, 0);
                        ctorsymbol = cg.CoreMethods.Ctors.ScriptDiedException_PhpValue;
                        break;
                }
            }

            //
            cg.EmitCall(ILOpCode.Newobj, ctorsymbol);
            cg.Builder.EmitThrow(false);

            //
            return cg.CoreTypes.Void;
        }
    }

    partial class BoundAssertEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var args = ArgumentsInSourceOrder;
            if (args.Length == 0 ||
                args[0].Value.ConstantValue.EqualsOptional(true.AsOptional()) ||    // ignoring assertion evaluated to true
                cg.IsReadonlyStringOnly(args[0].Value.TypeRefMask))                 // ignoring string assertions
            {
                if (Access.IsNone)
                {
                    // emit nothing
                    return cg.CoreTypes.Void;
                }

                // always passing
                cg.Builder.EmitBoolConstant(true);
            }
            else
            {
                // Template: <ctx>.Assert( condition.ToBoolean(), action )
                cg.EmitLoadContext();

                cg.EmitConvertToBool(args[0].Value);

                if (args.Length > 1)
                {
                    cg.EmitConvertToPhpValue(args[1].Value);
                }
                else
                {
                    cg.Emit_PhpValue_Void();
                }

                // 
                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.Assert_bool_PhpValue)
                    .Expect(SpecialType.System_Boolean);
            }

            //
            return cg.CoreTypes.Boolean;
        }
    }

    partial class BoundAssignEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var target_place = this.Target.BindPlace(cg);

            Debug.Assert(target_place != null);
            Debug.Assert(target_place.Type == null || target_place.Type.SpecialType != SpecialType.System_Void);

            // T tmp; // in case access is Read
            LocalDefinition tmp = null;

            // <target> = <value>
            var lhs = target_place.EmitStorePreamble(cg, Target.TargetAccess());

            var t_value = target_place.Type;
            if (t_value != null &&
                t_value != cg.CoreTypes.PhpValue &&
                t_value != cg.CoreTypes.PhpAlias &&
                !Value.Access.IsReadRef &&
                Access.IsNone)
            {
                // we can convert more efficiently here
                cg.EmitConvert(Value, t_value);
            }
            else
            {
                t_value = cg.Emit(Value);
            }

            if (t_value.SpecialType == SpecialType.System_Void)
            {
                // default<T>
                t_value = target_place.Type ?? cg.CoreTypes.PhpValue; // T of PhpValue
                cg.EmitLoadDefault(t_value, 0);
            }

            //
            if (Access.IsNone)
            {
                // nothing
            }
            else if (Access.IsRead)
            {
                tmp = cg.GetTemporaryLocal(t_value, false);
                cg.Builder.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tmp);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(Access);
            }

            target_place.EmitStore(cg, ref lhs, t_value, Target.Access);

            lhs.Dispose();

            //
            if (Access.IsNone)
            {
                t_value = cg.CoreTypes.Void;
            }
            else if (Access.IsRead)
            {
                Debug.Assert(tmp != null);
                cg.Builder.EmitLocalLoad(tmp);
            }

            if (tmp != null)
            {
                cg.ReturnTemporaryLocal(tmp);
            }

            //
            return t_value;
        }
    }

    partial class BoundCompoundAssignEx
    {
        /// <summary>
        /// Searches for an occurance of <see cref="SearchForTargetVisitor._target"/>.
        /// </summary>
        class SearchForTargetVisitor : Graph.GraphWalker<VoidStruct>
        {
            readonly BoundReferenceExpression/*!*/_target;

            public bool Found { get; private set; }

            public SearchForTargetVisitor(BoundReferenceExpression target)
            {
                _target = target ?? throw ExceptionUtilities.ArgumentNull();
            }

            public override VoidStruct VisitVariableName(BoundVariableName x)
            {
                if (_target is BoundVariableRef v)
                {
                    Found |= !v.Name.IsDirect || !x.IsDirect || v.Name.NameValue == x.NameValue;
                }

                return default;
            }
        }

        /// <summary>
        /// Determines if <paramref name="target"/> is not referenced within <paramref name="rvalue"/>.
        /// </summary>
        static bool IsSafeToUnroll(BoundReferenceExpression target, BoundExpression rvalue)
        {
            if (rvalue.IsConstant() || rvalue is BoundGlobalConst || rvalue is BoundPseudoConst || (rvalue is BoundFieldRef f && f.IsClassConstant))
            {
                return true;
            }

            var visitor = new SearchForTargetVisitor(target);
            rvalue.Accept(visitor);
            return visitor.Found != true;
        }

        static TypeSymbol EmitAppend(CodeGenerator cg, BoundReferenceExpression target, BoundExpression rvalue, BoundAccess access)
        {
            var target_place = target.BindPlace(cg);

            bool inplace = false;
            var lhs = default(LhsStack);

            if (target_place.HasAddress && target_place.Type != null)
            {
                // we can perform in-place concatenation

                if (target_place.Type == cg.CoreTypes.PhpValue)
                {
                    // Template: Operators.EnsureWritableString(ref PhpValue target).Add( .. )
                    inplace = true;
                    target_place.EmitLoadAddress(cg, ref lhs);  // ref PhpValue
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureWritableString_PhpArrayRef)
                        .Expect(cg.CoreTypes.PhpString_Blob);
                }
                else if (target_place.Type == cg.CoreTypes.PhpAlias)
                {
                    // Template: target.Alias.EnsureWritableString().Add( .. )
                    inplace = true;
                    target_place.EmitLoadValue(cg, ref lhs, target.Access);
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.PhpAlias.EnsureWritableString)
                        .Expect(cg.CoreTypes.PhpString_Blob);
                }
                else if (target_place.Type == cg.CoreTypes.PhpString)
                {
                    // Template: (target : PhpString).EnsureWritable().Add( .. )
                    inplace = true;
                    target_place.EmitLoadAddress(cg, ref lhs);  // : ref PhpString
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.EnsureWritable)
                        .Expect(cg.CoreTypes.PhpString_Blob);
                }
            }

            //

            if (inplace)
            {
                lhs.Dispose();
            }
            else
            {
                // Template: PhpString.AsWritable( ((PhpString)target) ) : Blob
                lhs = target_place.EmitStorePreamble(cg, target.TargetAccess());
                cg.EmitConvertToPhpString(target_place.EmitLoadValue(cg, ref lhs, target.Access), 0);
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.AsWritable_PhpString) // Blob
                    .Expect(cg.CoreTypes.PhpString_Blob);
            }

            // STACK: PhpString.Blob

            // Template: .Add( rValue )

            if (access.IsRead || !inplace)
            {
                cg.Builder.EmitOpCode(ILOpCode.Dup);    // 
            }

            // check rValue does not contain lValue!
            // if {rvalue} references {target}, we cannot unroll concat expression

            cg.Emit_PhpStringBlob_Append(rvalue, expandConcat: IsSafeToUnroll(target, rvalue));

            // STACK: 'void' or 'PhpString.Blob'

            if (access.IsRead || !inplace)
            {
                // STACK: PhpString.Blob

                // Template: new PhpString(blob)
                var result_type = cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpString_Blob)
                    .Expect(cg.CoreTypes.PhpString);

                // STACK: PhpString

                LocalDefinition tmp = null;

                if (access.IsRead)
                {
                    tmp = cg.GetTemporaryLocal(result_type, false);
                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.Builder.EmitLocalStore(tmp);
                }

                if (!inplace)
                {
                    target_place.EmitStore(cg, ref lhs, result_type, target.Access);
                    lhs.Dispose();
                }
                else
                {
                    cg.Builder.EmitOpCode(ILOpCode.Pop);
                }

                // STACK: void

                if (access.IsRead)
                {
                    Debug.Assert(tmp != null);
                    cg.Builder.EmitLoad(tmp);
                    cg.ReturnTemporaryLocal(tmp);
                    return result_type;
                }
            }

            // STACK: void

            if (access.IsNone)
            {
                return cg.CoreTypes.Void;
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(access);
            }
        }

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsRead || Access.IsNone);

            // target X= value;

            if (this.Operation == Operations.AssignAppend)
            {
                return EmitAppend(cg, this.Target, this.Value, this.Access);
            }

            var target_place = this.Target.BindPlace(cg);
            Debug.Assert(target_place != null);
            Debug.Assert(target_place.Type == null || target_place.Type.SpecialType != SpecialType.System_Void);

            // <target> = <target> X <value>
            var lhs = target_place.EmitStorePreamble(cg, Target.TargetAccess());
            var xtype = target_place.EmitLoadValue(cg, ref lhs, Target.Access);

            TypeSymbol result_type;

            switch (this.Operation)
            {
                case Operations.AssignAdd:
                    result_type = BoundBinaryEx.EmitAdd(cg, xtype, Value, target_place.Type);
                    break;
                //case Operations.AssignAppend:
                //    result_type = EmitAppend(cg, xtype, Value);
                //    break;
                ////case Operations.AssignPrepend:
                ////    break;
                case Operations.AssignDiv:
                    result_type = BoundBinaryEx.EmitDiv(cg, xtype, Value, target_place.Type);
                    break;
                case Operations.AssignMod:
                    result_type = BoundBinaryEx.EmitRemainder(cg, xtype, Value);
                    break;
                case Operations.AssignMul:
                    result_type = BoundBinaryEx.EmitMul(cg, xtype, Value, target_place.Type);
                    break;
                case Operations.AssignAnd:
                    result_type = BoundBinaryEx.EmitBitAnd(cg, xtype, Value);
                    break;
                case Operations.AssignOr:
                    result_type = BoundBinaryEx.EmitBitOr(cg, xtype, Value);
                    break;
                case Operations.AssignXor:
                    result_type = BoundBinaryEx.EmitBitXor(cg, xtype, Value);
                    break;
                case Operations.AssignPow:
                    result_type = BoundBinaryEx.EmitPow(cg, xtype, /*this.Target.TypeRefMask*/0, Value);
                    break;
                case Operations.AssignShiftLeft:
                case Operations.AssignShiftRight:
                    result_type = BoundBinaryEx.EmitShift(cg, xtype, Value, this.Operation == Operations.AssignShiftLeft ? ILOpCode.Shl : ILOpCode.Shr);
                    break;
                case Operations.AssignSub:
                    result_type = BoundBinaryEx.EmitSub(cg, xtype, Value, target_place.Type);
                    break;
                case Operations.AssignCoalesce:
                    result_type = BoundBinaryEx.EmitCoalesce(cg, xtype, 0, Value);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(this.Operation);
            }

            LocalDefinition tmp = null;

            if (Access.IsRead)
            {
                tmp = cg.GetTemporaryLocal(result_type, false);
                cg.Builder.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tmp);
            }

            target_place.EmitStore(cg, ref lhs, result_type, Target.Access);
            lhs.Dispose();

            //
            if (Access.IsRead)
            {
                Debug.Assert(tmp != null);
                cg.Builder.EmitLoad(tmp);
                cg.ReturnTemporaryLocal(tmp);
                return result_type;
            }
            else if (Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(this.Access);
            }
        }
    }

    partial class BoundIncDecEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsNone || Access.IsRead);
            Debug.Assert(!this.Access.IsReadRef);
            Debug.Assert(!this.Access.IsWrite);
            Debug.Assert(this.Target.Access.IsRead && this.Target.Access.IsWrite);
            Debug.Assert(this.Value.Access.IsRead);

            Debug.Assert(this.Value is BoundLiteral);

            if (this.UsesOperatorMethod)
            {
                throw new NotImplementedException();
            }

            TypeSymbol result_type = cg.CoreTypes.Void;
            LocalDefinition tempvar = null;    // temporary variable containing result of the expression if needed

            var read = this.Access.IsRead;

            var target_place = this.Target.BindPlace(cg);
            Debug.Assert(target_place != null);

            // prepare target for store operation
            var lhs = target_place.EmitStorePreamble(cg, Target.TargetAccess());

            // load target value
            var target_load_type = target_place.EmitLoadValue(cg, ref lhs, Target.Access);

            TypeSymbol op_type;

            if (read && IsPostfix)
            {
                // store value of target
                // <temp> = TARGET
                tempvar = cg.GetTemporaryLocal(target_load_type);
                cg.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tempvar);
            }

            if (IsIncrement)
            {
                op_type = BoundBinaryEx.EmitAdd(cg, target_load_type, this.Value, target_place.Type);
            }
            else
            {
                Debug.Assert(IsDecrement);
                op_type = BoundBinaryEx.EmitSub(cg, target_load_type, this.Value, target_place.Type);
            }

            if (read && IsPrefix)
            {
                // store value of result
                // <temp> = TARGET
                tempvar = cg.GetTemporaryLocal(op_type);
                cg.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tempvar);
            }

            //
            target_place.EmitStore(cg, ref lhs, op_type, Target.Access);

            lhs.Dispose();

            if (read)
            {
                Debug.Assert(tempvar != null);

                // READ <temp>
                cg.Builder.EmitLocalLoad(tempvar);
                result_type = (TypeSymbol)tempvar.Type;

                //
                cg.ReturnTemporaryLocal(tempvar);
                tempvar = null;
            }

            //
            Debug.Assert(tempvar == null);
            Debug.Assert(!read || result_type.SpecialType != SpecialType.System_Void);

            //
            return result_type;
        }

        bool IsPrefix => !IsPostfix;
        bool IsDecrement => !this.IsIncrement;
    }

    partial class BoundConditionalEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            TypeSymbol result_type = cg.DeclaringCompilation.GetTypeFromTypeRef(cg.TypeRefContext, this.TypeRefMask);
            bool result_isvoid = result_type.SpecialType == SpecialType.System_Void;

            object trueLbl = new object();
            object endLbl = new object();

            if (this.IfTrue != null)
            {
                // !COND?T:F -> COND?F:T
                bool isnegation = this.Condition.IsLogicNegation(out var negexpr);
                var condition = isnegation ? negexpr : this.Condition;

                // Cond ? True : False
                cg.EmitConvertToBool(condition);   // i4
                cg.Builder.EmitBranch(isnegation ? ILOpCode.Brfalse : ILOpCode.Brtrue, trueLbl);

                // false:
                cg.EmitConvert(this.IfFalse, result_type);
                cg.Builder.EmitBranch(ILOpCode.Br, endLbl);
                if (!result_isvoid) cg.Builder.AdjustStack(-1);

                // trueLbl:
                cg.Builder.MarkLabel(trueLbl);
                cg.EmitConvert(this.IfTrue, result_type);

                // endLbl:
                cg.Builder.MarkLabel(endLbl);
            }
            else
            {
                // Cond ?: False

                // <stack> = <cond_var> = Cond
                var cond_type = cg.Emit(this.Condition);
                var cond_var = cg.GetTemporaryLocal(cond_type);
                cg.Builder.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(cond_var);

                cg.EmitConvertToBool(cond_type, this.Condition.TypeRefMask);
                cg.Builder.EmitBranch(ILOpCode.Brtrue, trueLbl);

                // false:
                cg.EmitConvert(this.IfFalse, result_type);
                cg.Builder.EmitBranch(ILOpCode.Br, endLbl);
                if (!result_isvoid) cg.Builder.AdjustStack(-1);

                // trueLbl:
                cg.Builder.MarkLabel(trueLbl);
                cg.Builder.EmitLocalLoad(cond_var);
                cg.EmitConvert(cond_type, this.Condition.TypeRefMask, result_type);

                // endLbl:
                cg.Builder.MarkLabel(endLbl);

                //
                cg.ReturnTemporaryLocal(cond_var);
            }

            //
            if (Access.IsNone)
            {
                cg.EmitPop(result_type);
                result_type = cg.CoreTypes.Void;
            }

            //
            return result_type;
        }
    }

    partial class BoundArrayEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            if (_items.Length == 0)
            {
                if (Access.IsNone && !cg.EmitPdbSequencePoints)
                {
                    return cg.CoreTypes.Void;
                }

                // PhpArray.NewEmpty()
                return cg.Emit_PhpArray_NewEmpty();
            }
            else if (cg.IsInCachedArrayExpression || this.RequiresContext)
            {
                // new PhpArray(){ ... }
                return EmitNewPhpArray(cg);
            }
            else // array items do not need Context => they are immutable/literals
            {
                if (Access.IsNone && !cg.EmitPdbSequencePoints)
                {
                    return cg.CoreTypes.Void;
                }

                // static PhpArray field;
                // field ?? (field = new PhpArray(){ ... })
                return EmitCachedPhpArray(cg);
            }
        }

        TypeSymbol EmitNewPhpArray(CodeGenerator cg)
        {
            // new PhpArray(count)
            cg.Builder.EmitIntConstant(_items.Length);
            var result = cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray_int)
                .Expect(cg.CoreTypes.PhpArray);

            foreach (var x in _items)
            {
                // <PhpArray>
                cg.Builder.EmitOpCode(ILOpCode.Dup);

                // key
                if (x.Key != null)
                {
                    cg.EmitIntStringKey(x.Key);
                }

                // value
                Debug.Assert(x.Value != null);
                cg.EmitConvert(x.Value, cg.CoreTypes.PhpValue);

                if (x.Key != null)
                {
                    // <stack>.Add(key, value)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_IntStringKey_PhpValue);
                }
                else
                {
                    // <stack>.Add(value) : int
                    cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                }
            }

            //
            return result;
        }

        /// <summary>
        /// Caches the array instance into an internal app-static field,
        /// so repetitious creations only uses the existing instance.
        /// </summary>
        TypeSymbol EmitCachedPhpArray(CodeGenerator cg)
        {
            Debug.Assert(cg.IsInCachedArrayExpression == false);

            // static PhpArray arr`;
            var fld = cg.Factory.CreateSynthesizedField(cg.CoreTypes.PhpArray, "<arr>", true);
            var fldplace = new FieldPlace(null, fld, cg.Module);

            // TODO: reuse existing cached PhpArray with the same content

            //
            cg.IsInCachedArrayExpression = true;

            // arr ?? (arr = new PhpArray(){...})
            fldplace.EmitLoad(cg.Builder);
            cg.EmitNullCoalescing((cg_) =>
            {
                fldplace.EmitStorePrepare(cg_.Builder);
                EmitNewPhpArray(cg_);
                cg_.Builder.EmitOpCode(ILOpCode.Dup);
                fldplace.EmitStore(cg_.Builder);
            });

            // .DeepCopy()
            // if (this.Access.IsReadCopy) // unsafe ?
            {
                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.PhpArray.DeepCopy);
            }

            //
            cg.IsInCachedArrayExpression = false;

            //
            return fld.Type;    // ~ PhpArray
        }
    }

    partial class BoundArrayItemEx : IVariableReference
    {
        internal override IVariableReference BindPlace(CodeGenerator cg) => this;

        internal override IPlace Place() => ((IVariableReference)this).Place;

        #region IBoundReference

        Symbol IVariableReference.Symbol => null;

        TypeSymbol IVariableReference.Type => DeclaringCompilation.CoreTypes.PhpValue;

        bool IVariableReference.HasAddress => false;

        IPlace IVariableReference.Place => null;    // TODO: simple array access in case Array is System.Array and Key is int|long

        #region Emitted Array Stack

        /// <summary>
        /// Stack of type of {array,index} emitted by <see cref="IVariableReference.EmitLoadValue"/> and <see cref="IVariableReference.EmitStorePreamble"/>.
        /// </summary>
        Stack<EmittedArrayInfo> _emittedArrays;

        struct EmittedArrayInfo
        {
            public TypeSymbol tArray, tIndex;
        }

        /// <summary>
        /// <see cref="IVariableReference.EmitStorePreamble"/> and <see cref="IVariableReference.EmitStorePreamble"/> remembers what was the array type it emitted.
        /// Used by <see cref="PopEmittedArray"/> and <see cref="IVariableReference.EmitLoadValue"/> or <see cref="IVariableReference.EmitStore"/> to emit specific operator.
        /// </summary>
        void PushEmittedArray(TypeSymbol tArray, TypeSymbol tIndex)
        {
            Debug.Assert(tArray != null);

            if (_emittedArrays == null)
            {
                _emittedArrays = new Stack<EmittedArrayInfo>();
            }

            _emittedArrays.Push(new EmittedArrayInfo() { tArray = tArray, tIndex = tIndex });
        }

        /// <summary>
        /// Used by <see cref="IVariableReference.EmitLoadValue"/> and <see cref="IVariableReference.EmitStore"/> to emit specific operator
        /// on a previously emitted array (<see cref="PushEmittedArray"/>).
        /// </summary>
        EmittedArrayInfo PopEmittedArray()
        {
            Debug.Assert(_emittedArrays != null && _emittedArrays.Count != 0);
            var result = _emittedArrays.Pop();
            if (_emittedArrays.Count == 0)
            {
                _emittedArrays = null;   // free
            }

            return result;
        }

        bool IndexIsSafe()
        {
            var constant = (Index != null) ? Index.ConstantValue : null;
            if (constant.HasValue)
            {
                var value = constant.Value;
                return value is long || value is int || value is string;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Emits <see cref="Index"/> either as <c>PhpValue</c> or <c>IntStringKey</c> if possible safely.
        /// If <see cref="Index"/> is a <c>null</c> reference, nothing is emitted and <c>null</c> is returned by the function.
        /// </summary>
        TypeSymbol EmitLoadIndex(CodeGenerator cg, ref LhsStack lhs, bool safeToUseIntStringKey)
        {
            TypeSymbol tIndex;

            if (this.Index != null)
            {
                if (safeToUseIntStringKey && IndexIsSafe())
                {
                    tIndex = cg.CoreTypes.IntStringKey;
                    cg.EmitIntStringKey(this.Index);
                }
                else
                {
                    tIndex = cg.CoreTypes.PhpValue;
                    cg.EmitConvert(this.Index, tIndex);
                }
            }
            else
            {
                tIndex = null;
            }

            //
            return tIndex;
        }

        #endregion

        void EmitLoadPrepare(CodeGenerator cg, ref LhsStack lhs)
        {
            // Template: array[index]

            bool safeToUseIntStringKey = false;
            bool canBeNull = true;

            //
            // LOAD Array
            //

            var tArray = lhs.EmitReceiver(cg, Array);

            // convert {t} to IPhpArray, string, System.Array

            if (tArray.IsOfType(cg.CoreTypes.IPhpArray))
            {
                // ok; PhpArray, PhpString, object implementing IPhpArray
                safeToUseIntStringKey = true;
            }
            else if (tArray == cg.CoreTypes.PhpValue)
            {
                // ok
            }
            else if (tArray == cg.CoreTypes.PhpAlias)
            {
                tArray = cg.Emit_PhpAlias_GetValue();
            }
            else if (tArray == cg.CoreTypes.String)
            {
                // ok
                safeToUseIntStringKey = true;
            }
            else if (tArray == cg.CoreTypes.PhpString)
            {
                // <PhpString>.AsArray
                tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.AsArray_PhpString);
                safeToUseIntStringKey = true;
            }
            else if (tArray == cg.CoreTypes.Void)
            {
                Debug.Fail("Use of uninitialized value.");  // TODO: Err in analysis, use of uninitialized value
            }
            else if (tArray.IsArray())   // TODO: IList, IDictionary
            {
                // ok
            }
            else if (tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                // ok
            }
            else
            {
                // object -> IPhpArray
                tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_Object);
                canBeNull = false;
            }

            if (this.Access.IsRead && this.Access.IsQuiet)  // TODO: analyse if Array can be NULL
            {
                // ?? PhpArray.Empty
                if (cg.CoreTypes.PhpArray.Symbol.IsOfType(tArray) && canBeNull)
                {
                    cg.EmitNullCoalescing((_cg) =>
                    {
                        _cg.EmitCastClass(_cg.Emit_PhpArray_Empty(), tArray);
                    });
                }
            }

            Debug.Assert(
                tArray.IsOfType(cg.CoreTypes.IPhpArray) ||
                tArray.SpecialType == SpecialType.System_String ||
                tArray.IsArray() ||
                tArray.IsOfType(cg.CoreTypes.ArrayAccess) ||
                tArray == cg.CoreTypes.PhpValue);

            //
            // LOAD [Index]
            //

            Debug.Assert(this.Index != null || this.Access.IsEnsure, "Index is required when reading the array item.");

            var tIndex = EmitLoadIndex(cg, ref lhs, safeToUseIntStringKey);

            // remember for EmitLoad
            PushEmittedArray(tArray, tIndex);
        }

        TypeSymbol IVariableReference.EmitLoadValue(CodeGenerator cg, ref LhsStack lhs, BoundAccess access)
        {
            EmitLoadPrepare(cg, ref lhs);

            // Template: array[index]

            var stack = PopEmittedArray();
            if (stack.tArray.IsOfType(cg.CoreTypes.IPhpArray))
            {
                // whether the target is instance of PhpArray, otherwise it is an IPhpArray and we have to use .callvirt and different operators
                var isphparr = (stack.tArray == cg.CoreTypes.PhpArray);

                if (this.Index == null)
                {
                    Debug.Assert(stack.tIndex == null);
                    Debug.Assert(this.Access.IsEnsure);
                    /*
                     * Template:
                     * <array>.AddValue((PhpValue)(tmp = new <T>));
                     * LOAD tmp;
                     */
                    LocalDefinition tmp;
                    if (Access.EnsureArray)
                    {
                        // tmp = new PhpArray();
                        tmp = cg.GetTemporaryLocal(cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray));
                    }
                    else if (Access.EnsureObject)
                    {
                        // tmp = new stdClass();
                        tmp = cg.GetTemporaryLocal(cg.EmitCall(ILOpCode.Newobj, cg.CoreTypes.stdClass.Ctor()));
                    }
                    else if (Access.IsReadRef)
                    {
                        // tmp = PhpAlias.Create(NULL)
                        cg.Emit_PhpValue_Null();
                        tmp = cg.GetTemporaryLocal(cg.Emit_PhpValue_MakeAlias());
                    }
                    else
                    {
                        throw ExceptionUtilities.UnexpectedValue(Access);
                    }

                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.Builder.EmitLocalStore(tmp);

                    var tmp_type = (TypeSymbol)tmp.Type;
                    cg.EmitConvertToPhpValue(tmp_type, 0);

                    if (isphparr) cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                    else cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.AddValue_PhpValue);

                    //
                    cg.Builder.EmitLocalLoad(tmp);
                    cg.ReturnTemporaryLocal(tmp);
                    return tmp_type;
                }
                else if (Access.EnsureObject)
                {
                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.EnsureItemObject(<index>)
                        return isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.EnsureItemObject_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.EnsureItemObject_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // EnsureItemObject(<array>, <index>)
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemObject_IPhpArray_PhpValue);
                    }
                }
                else if (Access.EnsureArray)
                {
                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.EnsureItemArray(<index>)
                        return isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.EnsureItemArray_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.EnsureItemArray_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // EnsureItemArray(<array>, <index>)
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemArray_IPhpArray_PhpValue);
                    }
                }
                else if (Access.IsReadRef)
                {
                    Debug.Assert(this.Array.Access.EnsureArray);

                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.EnsureItemAlias(<index>)
                        return isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.EnsureItemAlias_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.EnsureItemAlias_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // EnsureItemAlias(<array>, <index>, quiet)
                        cg.Builder.EmitBoolConstant(Access.IsQuiet);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemAlias_IPhpArray_PhpValue_Bool);
                    }
                }
                else
                {
                    Debug.Assert(Access.IsRead);

                    TypeSymbol t;

                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.GetItemValue(<index>)
                        t = isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.GetItemValue_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.GetItemValue_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // GetItemValue(<array>, <index>)
                        //cg.Builder.EmitBoolConstant(Access.IsQuiet);
                        t = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.GetItemValue_PhpValue);
                    }

                    return t;
                }
            }
            else if (stack.tArray.SpecialType == SpecialType.System_String)
            {
                if (Access.EnsureObject || Access.EnsureArray || Access.IsReadRef)
                {
                    // null
                    throw new InvalidOperationException();
                }
                else
                {
                    Debug.Assert(Access.IsRead);
                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // GetItemValue{OrNull}(string, IntStringKey)
                        return cg.EmitCall(ILOpCode.Call, this.Access.Flags.Isset()
                            ? cg.CoreMethods.Operators.GetItemValueOrNull_String_IntStringKey   // string or null
                            : cg.CoreMethods.Operators.GetItemValue_String_IntStringKey         // string or ""
                            );
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // GetItemValue(string, PhpValue, bool)
                        cg.Builder.EmitBoolConstant(Access.IsQuiet);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetItemValue_String_PhpValue_Bool);
                    }
                }
            }
            else if (stack.tArray == cg.CoreTypes.PhpValue)
            {
                Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);

                if (Access.EnsureObject || Access.EnsureArray)
                {
                    // null
                    throw new InvalidOperationException();
                }
                else if (Access.IsReadRef)
                {
                    Debug.WriteLine("TODO: we need reference to PhpValue so we can modify its content! This is not compatible with behavior of = &$null[0].");

                    // PhpValue.GetItemRef(index, bool)
                    cg.Builder.EmitBoolConstant(Access.IsQuiet);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemAlias_PhpValue_PhpValue_Bool);
                }
                else // IsRead
                {
                    Debug.Assert(Access.IsRead);
                    // PhpValue.GetItemValue(index, bool)
                    cg.Builder.EmitBoolConstant(Access.IsQuiet);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetItemValue_PhpValue_PhpValue_Bool);
                }
            }
            else if (stack.tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);

                // Template: ArrayAccess.offsetGet(<index>)
                var t = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetGet_ArrayAccess_PhpValue);

                if (Access.EnsureArray)
                {
                    Debug.Assert(t == cg.CoreTypes.PhpValue);
                    // Template: (ref PhpValue).EnsureArray()
                    cg.EmitPhpValueAddr();
                    t = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_PhpValueRef);
                }

                return t;
            }
            else if (stack.tArray.SpecialType == SpecialType.System_Void)
            {
                // array item on an uninitialized value
                // void[key] -> void
                cg.EmitPop(stack.tIndex);
                return cg.Emit_PhpValue_Void();
            }
            else
            {
                throw cg.NotImplementedException($"LOAD {stack.tArray.Name}[]");
            }
        }

        TypeSymbol IVariableReference.EmitLoadAddress(CodeGenerator cg, ref LhsStack lhs)
        {
            //EmitLoadPrepare(cg, ref lhs);

            //var stack = PopEmittedArray();
            //if (stack.tArray == cg.CoreTypes.PhpArray && stack.tIndex == cg.CoreTypes.IntStringKey)
            //{
            //    // STACK: <PhpArray> <key>

            //    // Template: ref PhpArray.GetItemRef(key)
            //    Debug.Assert(cg.CoreMethods.PhpArray.GetItemRef_IntStringKey.Symbol.ReturnValueIsByRef);
            //    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.GetItemRef_IntStringKey);
            //}
            //else
            //{
            //    throw new NotSupportedException();
            //    //PushEmittedArray(stack.tArray, stack.tIndex);
            //    //return null;    // TODO: IPhpArray if needed
            //}
            throw ExceptionUtilities.Unreachable;
        }

        LhsStack IVariableReference.EmitStorePreamble(CodeGenerator cg, BoundAccess access)
        {
            var lhs = new LhsStack { CodeGenerator = cg, IsEnabled = access.IsRead, };

            //Debug.Assert(this.Array.Access.EnsureArray || this.Array.Access.IsQuiet);

            // Template: array[index]

            bool safeToUseIntStringKey = false;

            //
            // ENSURE Array
            //

            var tArray = lhs.EmitReceiver(cg, Array);
            if (tArray.IsOfType(cg.CoreTypes.IPhpArray))    // PhpArray, PhpString
            {
                // ok
                safeToUseIntStringKey = true;
            }
            else if (tArray.IsOfType(cg.CoreTypes.ArrayAccess)) // ArrayAccess
            {
                // ok
            }
            else if (this.Array.Access.EnsureArray)
            {
                if (tArray == cg.CoreTypes.PhpAlias)
                {
                    // PhpAlias.EnsureArray
                    tArray = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.PhpAlias.EnsureArray);
                }
                else
                {
                    // Array should be ensured already
                    throw cg.NotImplementedException($"(ensure) STORE {tArray.Name}[]");
                }
            }
            else if (this.Array.Access.IsQuiet)
            {
                // WRITE semantics, without need of ensuring the underlaying value
                // isempty, unset; otherwise in store operation we should EnsureArray already

                if (tArray == cg.CoreTypes.PhpAlias)
                {
                    // dereference
                    tArray = cg.Emit_PhpAlias_GetValue();
                }

                if (tArray == cg.CoreTypes.PhpValue)
                {
                    Debug.WriteLine("TODO: we need reference to PhpValue so we can modify its content! Won't work with $string[] = ...");

                    cg.EmitPhpValueAddr();

                    tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetArrayAccess_PhpValueRef)
                        .Expect(cg.CoreTypes.IPhpArray);

                    // Template: <STACK> ?? (IPhpArray)PhpArray.Empty
                    cg.EmitNullCoalescing((_cg) =>
                    {
                        _cg.EmitCastClass(_cg.Emit_PhpArray_Empty(), _cg.CoreTypes.IPhpArray);
                    });
                }
                else if (tArray == cg.CoreTypes.String)
                {
                    // Template: (PhpString)string
                    tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.implicit_from_string);
                }
                else if (
                    tArray == cg.CoreTypes.Void ||
                    tArray == cg.CoreTypes.Boolean ||
                    tArray == cg.CoreTypes.Long ||
                    tArray == cg.CoreTypes.Double ||
                    tArray.IsOfType(cg.CoreTypes.PhpResource))
                {
                    // TODO: WRN: use value of type '...' as array
                    cg.EmitPop(tArray);
                    tArray = cg.Emit_PhpArray_Empty();
                }
                else if (tArray.IsReferenceType)
                {
                    // null -> PhpArray.Empty
                    if (cg.CanBeNull(Array.TypeRefMask))
                    {
                        // Template: (object)<STACK> ?? PhpArray.Empty
                        cg.EmitCastClass(tArray, cg.CoreTypes.Object);
                        cg.EmitNullCoalescing((_cg) =>
                        {
                            _cg.EmitCastClass(_cg.Emit_PhpArray_Empty(), _cg.CoreTypes.Object);
                        });
                        tArray = cg.CoreTypes.Object;
                    }

                    // EnsureArray(<STACK>) or throw
                    tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_Object)
                        .Expect(cg.CoreTypes.IPhpArray);
                }
                else
                {
                    throw cg.NotImplementedException($"(quiet) STORE {tArray.Name}[]");    // TODO: emit convert as PhpArray
                }
            }
            else
            {
                throw cg.NotImplementedException($"STORE {tArray.Name}[]");    // TODO: emit convert as PhpArray
            }

            Debug.Assert(tArray.IsOfType(cg.CoreTypes.IPhpArray) || tArray.IsOfType(cg.CoreTypes.ArrayAccess));

            //
            // LOAD [Index]
            //

            var tIndex = EmitLoadIndex(cg, ref lhs, safeToUseIntStringKey);

            if (tIndex == null && tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                // we need "NULL" key
                Debug.Assert(!safeToUseIntStringKey);
                tIndex = cg.Emit_PhpValue_Null();
            }

            // remember for EmitLoad
            PushEmittedArray(tArray, tIndex);

            //
            return lhs;
        }

        void IVariableReference.EmitStore(CodeGenerator cg, ref LhsStack lhs, TypeSymbol valueType, BoundAccess access)
        {
            // Template: array[index]

            var stack = PopEmittedArray();
            if (stack.tArray.IsOfType(cg.CoreTypes.IPhpArray))
            {
                // whether the target is instance of PhpArray, otherwise it is an IPhpArray and we have to use .callvirt
                var isphparr = (stack.tArray == cg.CoreTypes.PhpArray);

                if (Access.IsWriteRef)
                {
                    // PhpAlias
                    if (valueType != cg.CoreTypes.PhpAlias)
                    {
                        cg.EmitConvertToPhpValue(valueType, 0);
                        cg.Emit_PhpValue_MakeAlias();
                    }

                    // .SetItemAlias(key, alias) or .AddValue(PhpValue.Create(alias))
                    if (this.Index != null)
                    {
                        if (stack.tIndex == cg.CoreTypes.IntStringKey)
                        {
                            if (isphparr)
                                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.SetItemAlias_IntStringKey_PhpAlias);
                            else
                                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemAlias_IntStringKey_PhpAlias);
                        }
                        else
                        {
                            Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemAlias_PhpValue_PhpAlias);
                        }
                    }
                    else
                    {
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Create_PhpAlias);

                        if (isphparr)
                            cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                        else
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.AddValue_PhpValue);
                    }
                }
                else if (Access.IsUnset)
                {
                    if (this.Index == null)
                        throw new InvalidOperationException();

                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        if (isphparr)
                        {
                            // .UnsetValue(key)
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.UnsetValue_IntStringKey);
                        }
                        else
                        {
                            // .RemoveKey(key)
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.RemoveKey_IntStringKey);
                        }
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.RemoveKey_PhpValue);
                    }
                }
                else
                {
                    Debug.Assert(Access.IsWrite);

                    cg.EmitConvertToPhpValue(valueType, 0);

                    // .SetItemValue(key, value) or .AddValue(value)
                    if (this.Index != null)
                    {
                        if (stack.tIndex == cg.CoreTypes.IntStringKey)
                        {
                            if (isphparr)
                                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.SetItemValue_IntStringKey_PhpValue);
                            else
                                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemValue_IntStringKey_PhpValue);
                        }
                        else
                        {
                            Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemValue_PhpValue_PhpValue);
                        }
                    }
                    else
                    {
                        if (isphparr)
                            cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                        else
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.AddValue_PhpValue);
                    }
                }
            }
            else if (stack.tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                if (Access.IsUnset)
                {
                    Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                    Debug.Assert(valueType == null);

                    // Template: <STACK>.offsetUnset( key )
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetUnset_ArrayAccess_PhpValue);
                }
                else if (Access.IsWrite)
                {
                    Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);

                    // Template: <STACK>.offsetSet( key, value )
                    cg.EmitConvertToPhpValue(valueType, 0);
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetSet_ArrayAccess_PhpValue_PhpValue);
                }
                else
                {
                    throw ExceptionUtilities.UnexpectedValue(Access);
                }
            }
            else
            {
                throw cg.NotImplementedException($"STORE {stack.tArray.Name}[]");
            }
        }

        #endregion
    }

    partial class BoundArrayItemOrdEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(!Access.MightChange);
            Debug.Assert(Index != null);

            // Either specialize the call for the string types or fall back to PhpValue
            TypeSymbol arrType;
            MethodSymbol operation;

            var arrTypeMask = Array.TypeRefMask;
            if (arrTypeMask.IsSingleType && !arrTypeMask.IsRef && cg.TypeRefContext.IsAString(arrTypeMask))
            {
                arrType = cg.EmitSpecialize(Array);
            }
            else
            {
                arrType = cg.EmitConvertToPhpValue(Array);
            }

            if (arrType == cg.CoreTypes.String)
            {
                operation = cg.CoreMethods.Operators.GetItemOrdValue_String_Long;
            }
            else if (arrType == cg.CoreTypes.PhpString)
            {
                operation = cg.CoreMethods.Operators.GetItemOrdValue_PhpString_Long;
            }
            else
            {
                Debug.Assert(arrType == cg.CoreTypes.PhpValue);
                operation = cg.CoreMethods.Operators.GetItemOrdValue_PhpValue_Long.Symbol;
            }

            // The index must be integral
            var indexType = cg.EmitSpecialize(Index);
            Debug.Assert(indexType.IsIntegralType());
            cg.EmitConvertIntToLong(indexType);

            return cg.EmitCall(ILOpCode.Call, operation);
        }
    }

    partial class BoundInstanceOfEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsRead || Access.IsNone);

            var type = cg.Emit(Operand);

            //
            if (Access.IsNone)
            {
                cg.EmitPop(type);
                return cg.CoreTypes.Void;
            }

            type = cg.EmitAsObject(type, out bool isnull);
            Debug.Assert(type.IsReferenceType);

            //
            var tref = (BoundTypeRef)AsType;
            if (tref.ResolvedType.IsValidType())
            {
                if (!isnull)
                {
                    // Template: value is T : object
                    cg.Builder.EmitOpCode(ILOpCode.Isinst);
                    cg.EmitSymbolToken(tref.ResolvedType, null);

                    // object != null
                    cg.Builder.EmitNullConstant(); // .ldnull
                    cg.Builder.EmitOpCode(ILOpCode.Cgt_un); // .cgt.un
                }
                else
                {
                    cg.EmitPop(type);   // Operand is never an object instance

                    // FALSE
                    cg.Builder.EmitBoolConstant(false);
                }

                //
                return cg.CoreTypes.Boolean;
            }
            else
            {
                tref.EmitLoadTypeInfo(cg, false);

                // Template: Operators.IsInstanceOf(value, type);
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsInstanceOf_Object_PhpTypeInfo);
            }

            throw new NotImplementedException();
        }
    }

    partial class BoundPseudoConst
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var sourcefile = cg.ContainingFile;

            switch (this.ConstType)
            {
                case Types.File:

                    // <ctx>.RootPath + RelativePath
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.RootPath.Getter);

                    cg.Builder.EmitStringConstant("/" + sourcefile.RelativeFilePath);
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.NormalizePath_string);  // normalize slashes

                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Concat_String_String)
                        .Expect(SpecialType.System_String);

                case Types.Dir:

                    // <ctx>.RootPath + RelativeDirectory
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.RootPath.Getter);

                    var relative_dir = sourcefile.DirectoryRelativePath;
                    if (relative_dir.Length != 0)
                    {
                        cg.Builder.EmitStringConstant("/" + relative_dir);
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.NormalizePath_string);  // normalize slashes

                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Concat_String_String);
                    }

                    return cg.CoreTypes.String;

                case Types.Class:

                    // resolve name of self in runtime:
                    // Template: (string)Operators.GetSelfOrNull(<self>)?.Name
                    cg.EmitLoadSelf(throwOnError: false);  // GetSelf() : PhpTypeInfo
                    cg.EmitNullCoalescing(
                        () => cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetName_PhpTypeInfo.Getter), // Name : string
                        () => cg.Builder.EmitStringConstant(string.Empty));

                    return cg.CoreTypes.String;

                case Types.RootPath:
                    // <ctx>.RootPath
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.RootPath.Getter);
                    return cg.CoreTypes.String;

                default:

                    // the other pseudoconstants should be resolved by flow analysis
                    throw ExceptionUtilities.Unreachable;
            }
        }
    }

    partial class BoundPseudoClassConst
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            switch (this.ConstType)
            {
                case PseudoClassConstUse.Types.Class:
                    this.TargetType.EmitClassName(cg);
                    return cg.CoreTypes.String;

                default:
                    throw ExceptionUtilities.UnexpectedValue(this.ConstType);
            }
        }
    }

    partial class BoundGlobalConst
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(!Access.IsWrite);

            if (this.Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }

            // resolved constant value
            if (this.ConstantValue.HasValue)
            {
                return cg.EmitLoadConstant(this.ConstantValue.Value, this.Access.TargetType);
            }

            // resolved constant symbol
            if (_boundExpressionOpt != null)
            {
                return _boundExpressionOpt.EmitLoadValue(cg, BoundAccess.Read);
            }

            // the constant has to be resolved in runtime,
            // make it easier by caching its internal ID for fast lookup

            // Template: internal static int <const>Name;
            var idxfield = cg.Module.SynthesizedManager.GetGlobalConstantIndexField(Name.ToString());

            Debug.Assert(FallbackName.HasValue == false || Name != FallbackName.Value);

            // Template: Operators.ReadConstant(ctx, name, ref <idxfield> [, fallbackname])
            cg.EmitLoadContext();
            cg.Builder.EmitStringConstant(this.Name.ToString());
            cg.EmitFieldAddress(idxfield);

            if (FallbackName.HasValue)
            {
                // we have to try two possible constant names:
                cg.Builder.EmitStringConstant(this.FallbackName.Value.ToString());
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.ReadConstant_Context_String_Int_String)
                    .Expect(cg.CoreTypes.PhpValue);
            }
            else
            {
                // Operators.ReadConstant(ctx, name, ref <idxfield>)
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.ReadConstant_Context_String_Int)
                    .Expect(cg.CoreTypes.PhpValue);
            }
        }
    }

    partial class BoundIsEmptyEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            // resolve IsEmpty() operator
            var op = cg.Conversions.ResolveOperator(t, false, new[] { "IsEmpty" }, new[] { cg.CoreTypes.Operators.Symbol }, target: cg.CoreTypes.Boolean);
            if (op != null)
            {
                // {t} reference type and possibly NULL,
                // emit null check:
                if (t.IsReferenceType && cg.CanBeNull(this.Operand.TypeRefMask) && !op.IsStatic)
                {
                    // https://github.com/peachpiecompiler/peachpie/issues/816
                    // Template: <STACK> != null ? IsEmpty(STACK) : FALSE
                    cg.EmitNullCoalescing(
                        notnullemitter: () => cg.EmitConversion(new CommonConversion(true, false, false, false, false, false, op), t, cg.CoreTypes.Boolean),
                        nullemitter: () => cg.Builder.EmitBoolConstant(true)
                    );
                }
                else
                {
                    // Template: IsEmpty(STACK)
                    cg.EmitConversion(new CommonConversion(true, false, false, false, false, false, op), t, cg.CoreTypes.Boolean);
                }
            }
            else
            {
                //
                switch (t.SpecialType)
                {
                    case SpecialType.System_Object:
                        // object == null
                        il.EmitNullConstant();
                        il.EmitOpCode(ILOpCode.Ceq);
                        break;

                    case SpecialType.System_Double:
                    case SpecialType.System_Boolean:
                    case SpecialType.System_Int32:
                    case SpecialType.System_Int64:
                    case SpecialType.System_String:
                        // Template: !(bool)value
                        cg.EmitConvertToBool(t, this.Operand.TypeRefMask);
                        cg.EmitLogicNegation();
                        break;

                    default:

                        // (value).IsEmpty
                        cg.EmitConvert(t, this.Operand.TypeRefMask, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsEmpty_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                }
            }

            //
            return cg.CoreTypes.Boolean;
        }
    }

    partial class BoundIsSetEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var t = cg.Emit(this.VarReference);

            // t.IsSet
            if (t == cg.CoreTypes.PhpAlias)
            {
                // <PhpAlias>.Value
                t = cg.Emit_PhpAlias_GetValue();
            }

            if (t == cg.CoreTypes.PhpValue)
            {
                // IsSet(value)
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsSet_PhpValue);
            }
            else if (t.IsReferenceType)
            {
                // object != null
                cg.Builder.EmitNullConstant(); // .ldnull
                cg.Builder.EmitOpCode(ILOpCode.Cgt_un); // .cgt.un
            }
            else if (t.IsNullableType())
            {
                // Teplate: value.HasValue
                cg.EmitStructAddr(t); // value -> ref value
                cg.EmitCall(ILOpCode.Call, t.LookupMember<PropertySymbol>("HasValue").GetMethod)
                    .Expect(SpecialType.System_Boolean);
            }
            else
            {
                // clean this up ...
                // NOTICE: "IndirectProperty" performs `isset` by itself and returns the result as boolean
                if (t.SpecialType == SpecialType.System_Boolean)
                {
                    if (VarReference is BoundFieldRef boundfld)
                    {
                        if (boundfld.BoundReference is IndirectProperty)
                        {
                            // isset already checked by callsite:
                            return t;
                        }
                    }
                }

                // value type => true
                cg.EmitPop(t);
                cg.Builder.EmitBoolConstant(true);
            }

            //
            return cg.CoreTypes.Boolean;
        }
    }

    partial class BoundOffsetExists
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            // Operators.OffsetExists( Receiver, Index ) : bool

            var arrayType = cg.Emit(Receiver);
            var indexType = cg.Emit(Index);

            //if (arrayType.IsOfType(cg.CoreTypes.ArrayAccess))
            //{
            //    cg.EmitConvert(indexType, 0, cg.CoreTypes.PhpValue);
            //    return cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetExists_ArrayAccess_PhpValue);
            //}

            var op = cg.Conversions.ResolveOperator(arrayType, false, new[] { "offsetExists" }, new[] { cg.CoreTypes.Operators.Symbol }, operand: indexType, target: cg.CoreTypes.Boolean);
            if (op != null)
            {
                cg.EmitConversion(new CommonConversion(true, false, false, false, false, false, op), arrayType, cg.CoreTypes.Boolean, op: indexType);
                return cg.CoreTypes.Boolean;
            }
            else
            {
                throw cg.NotImplementedException($"offsetExists({arrayType}, {indexType})", this);
            }
        }
    }

    partial class BoundTryGetItem
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(!Access.IsEnsure);

            // Either specialize the call for PhpArray (possibly with string index) or fall back to PhpValue

            TypeSymbol arrType, indexType;
            MethodSymbol operation;

            var arrTypeMask = Array.TypeRefMask;
            if (arrTypeMask.IsSingleType && !arrTypeMask.IsRef && cg.TypeRefContext.IsArray(arrTypeMask))
            {
                arrType = cg.EmitSpecialize(Array);
            }
            else
            {
                arrType = cg.EmitConvertToPhpValue(Array);
            }

            var indexTypeMask = Index.TypeRefMask;
            if (arrType == cg.CoreTypes.PhpArray &&
                indexTypeMask.IsSingleType && !indexTypeMask.IsRef && cg.TypeRefContext.IsReadonlyString(indexTypeMask))
            {
                indexType = cg.EmitSpecialize(Index);
            }
            else
            {
                indexType = cg.EmitConvertToPhpValue(Index);
            }

            if (arrType == cg.CoreTypes.PhpArray)
            {
                if (indexType == cg.CoreTypes.String)
                {
                    operation = cg.CoreMethods.Operators.TryGetItemValue_PhpArray_string_PhpValueRef;
                }
                else
                {
                    Debug.Assert(indexType == cg.CoreTypes.PhpValue);
                    operation = cg.CoreMethods.Operators.TryGetItemValue_PhpArray_PhpValue_PhpValueRef;
                }
            }
            else
            {
                Debug.Assert(arrType == cg.CoreTypes.PhpValue);
                Debug.Assert(indexType == cg.CoreTypes.PhpValue);
                operation = cg.CoreMethods.Operators.TryGetItemValue_PhpValue_PhpValue_PhpValueRef;
            }

            // TryGetItemValue(Array, Index, out PhpValue temp) ? temp : Fallback

            object trueLbl = new object();
            object endLbl = new object();

            // call
            var temp = cg.GetTemporaryLocal(cg.CoreTypes.PhpValue);
            cg.Builder.EmitLocalAddress(temp);
            cg.EmitCall(ILOpCode.Call, operation);
            cg.Builder.EmitBranch(ILOpCode.Brtrue, trueLbl);

            // fallback:
            cg.EmitConvertToPhpValue(Fallback);
            cg.Builder.EmitBranch(ILOpCode.Br, endLbl);

            // trueLbl:
            cg.Builder.MarkLabel(trueLbl);
            cg.Builder.EmitLocalLoad(temp);

            // endLbl:
            cg.Builder.MarkLabel(endLbl);

            cg.ReturnTemporaryLocal(temp);

            return cg.CoreTypes.PhpValue;
        }
    }

    partial class BoundYieldEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(cg.GeneratorStateMachineMethod != null);

            if (this.Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }
            else if (this.Access.IsRead)
            {
                // leave result of yield expr. (sent value) on eval stack

                cg.EmitGeneratorInstance();
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetGeneratorSentItem_Generator);

                // type of expression result is PHP value (sent value)
                return cg.CoreTypes.PhpValue;
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(this.Access);
            }
        }
    }

    partial class BoundYieldFromEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            if (Access.IsRead)
            {
                var t = cg.EmitAsObject(cg.Emit(Operand), out bool isnull);
                Debug.Assert(t.IsReferenceType);

                if (isnull || (
                    !cg.CoreTypes.Generator.Symbol.IsOfType(t) &&
                    !t.IsOfType(cg.CoreTypes.Generator)))
                {
                    cg.EmitPop(t);
                    cg.Emit_PhpValue_Null();
                }
                else
                {
                    var il = cg.Builder;
                    var lbl_End = new NamedLabel("Generator_Null");

                    if (t != cg.CoreTypes.Generator)
                    {
                        // Template: (Operand as Generator)?.getReturn() : PhpValue
                        cg.Builder.EmitOpCode(ILOpCode.Isinst);
                        cg.EmitSymbolToken(cg.CoreTypes.Generator, null);

                        var lbl_notnull = new NamedLabel("Generator_NotNull");
                        il.EmitOpCode(ILOpCode.Dup);
                        il.EmitBranch(ILOpCode.Brtrue, lbl_notnull);

                        il.EmitOpCode(ILOpCode.Pop);
                        cg.Emit_PhpValue_Null();
                        il.EmitBranch(ILOpCode.Br, lbl_End);

                        il.MarkLabel(lbl_notnull);
                    }

                    // Generator.getReturn() : PhpValue
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreTypes.Generator.Method("getReturn"));

                    il.MarkLabel(lbl_End);
                }

                //
                return cg.CoreTypes.PhpValue;
            }
            else
            {
                return cg.CoreTypes.Void;
            }
        }
    }
}

---- Transformed Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeGen;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.CodeGen;
using Pchp.CodeAnalysis.Symbols;
using Peachpie.CodeAnalysis.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;

namespace Pchp.CodeAnalysis.Semantics
{
    partial class BoundExpression
    {
        /// <summary>
        /// Emits the expression with its bound access.
        /// Only Read or None access is possible. Write access has to be handled separately.
        /// </summary>
        /// <param name="cg">Associated code generator.</param>
        /// <returns>The type of expression emitted on top of the evaluation stack.</returns>
        internal virtual TypeSymbol Emit(CodeGenerator cg)
        {
            throw ExceptionUtilities.UnexpectedValue(this.GetType().FullName);
        }
    }

    partial class BoundBinaryEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsRead || this.Access.IsNone);

            //
            TypeSymbol returned_type;

            if (UsesOperatorMethod)
            {
                throw new NotImplementedException();    // call this.Operator(Left, Right)
            }

            switch (this.Operation)
            {
                #region Arithmetic Operations

                case Operations.Add:
                    returned_type = (cg.IsLongOnly(this.TypeRefMask)) ? cg.CoreTypes.Long.Symbol : this.Access.TargetType;
                    returned_type = EmitAdd(cg, Left, Right, returned_type);
                    break;

                case Operations.Sub:
                    //Template: "x - y"        Operators.Subtract(x,y) [overloads]
                    returned_type = EmitSub(cg, Left, Right, this.Access.TargetType);
                    break;

                case Operations.Div:
                    //Template: "x / y"
                    returned_type = EmitDivision(cg);
                    break;

                case Operations.Mul:
                    //Template: "x * y"
                    returned_type = EmitMultiply(cg);
                    break;

                case Operations.Pow:
                    //Template: "x ** y"
                    returned_type = EmitPow(cg);
                    break;

                case Operations.Mod:
                    // x % y
                    returned_type = EmitRemainder(cg, Left, Right);
                    break;

                case Operations.ShiftLeft:
                    //Template: x << y : long
                    returned_type = EmitShift(cg, Left, Right, ILOpCode.Shl);
                    break;

                case Operations.ShiftRight:
                    //Template: x >> y : long
                    returned_type = EmitShift(cg, Left, Right, ILOpCode.Shr);
                    break;

                #endregion

                #region Boolean and Bitwise Operations

                case Operations.And:
                    returned_type = EmitBinaryBooleanOperation(cg, true);
                    break;

                case Operations.Or:
                    returned_type = EmitBinaryBooleanOperation(cg, false);
                    break;

                case Operations.Xor:
                    returned_type = EmitBinaryXor(cg);
                    break;

                case Operations.BitAnd:
                    returned_type = EmitBitAnd(cg, Left, Right);
                    break;

                case Operations.BitOr:
                    returned_type = EmitBitOr(cg, Left, Right);
                    break;

                case Operations.BitXor:
                    returned_type = EmitBitXor(cg, Left, Right);
                    break;

                #endregion

                #region Comparing Operations

                case Operations.Equal:
                    {
                        bool negation = false;
                        returned_type = EmitEquality(cg, ref negation);

                        Debug.Assert(negation == false);
                    }
                    break;

                case Operations.NotEqual:
                    {
                        bool negation = true;
                        EmitEquality(cg, ref negation);
                        returned_type = cg.CoreTypes.Boolean;

                        if (negation)
                        {
                            cg.EmitLogicNegation();
                        }
                    }
                    break;

                case Operations.GreaterThan:
                    returned_type = EmitLtGt(cg, false);
                    break;

                case Operations.LessThan:
                    returned_type = EmitLtGt(cg, true);
                    break;

                case Operations.GreaterThanOrEqual:
                    // template: !(LessThan)
                    returned_type = EmitLtGt(cg, true);
                    cg.EmitLogicNegation();
                    break;

                case Operations.LessThanOrEqual:
                    // template: !(GreaterThan)
                    returned_type = EmitLtGt(cg, false);
                    cg.EmitLogicNegation();
                    break;

                case Operations.Identical:

                    // Left === Right
                    returned_type = EmitStrictEquality(cg);
                    break;

                case Operations.NotIdentical:

                    // ! (Left === Right)
                    returned_type = EmitStrictEquality(cg);
                    cg.EmitLogicNegation();
                    break;

                #endregion

                case Operations.Coalesce:
                    returned_type = EmitCoalesce(cg);
                    break;

                case Operations.Spaceship:
                    returned_type = EmitSpaceship(cg);
                    break;

                default:
                    throw cg.NotImplementedException(message: $"BinaryEx {this.Operation} is not implemented.", op: this);
            }

            //
            if (Access.IsNone)
            {
                // Result is not read, pop the result
                cg.EmitPop(returned_type);
                returned_type = cg.CoreTypes.Void;
            }
            else if (Access.IsRead)
            {
                Debug.Assert(returned_type.SpecialType != SpecialType.System_Void);
            }

            //
            return returned_type;
        }

        /// <summary>
        /// Emits <c>+</c> operator suitable for actual operands.
        /// </summary>
        private static TypeSymbol EmitAdd(CodeGenerator cg, BoundExpression left, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            // Template: x + y
            return EmitAdd(cg, cg.Emit(left), right, resultTypeOpt);
        }

        /// <summary>
        /// Emits <c>+</c> operator suitable for actual operands.
        /// </summary>
        internal static TypeSymbol EmitAdd(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> long, string -> number
            cg.EmitPhpAliasDereference(ref xtype); // alias -> value

            //
            if (xtype == cg.CoreTypes.PhpNumber)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));  // int|bool -> long, string -> number
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype == cg.CoreTypes.PhpNumber)
                {
                    // number + number : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_number)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // number + r8 : r8
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_double)
                        .Expect(SpecialType.System_Double);
                }
                else if (ytype.SpecialType == SpecialType.System_Int64)
                {
                    // number + long : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_long)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else
                {
                    // number + value : number
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_number_value)
                        .Expect(cg.CoreTypes.PhpNumber);
                }

                //
                throw cg.NotImplementedException($"Add(number, {ytype.Name})", right);
            }
            else if (xtype.SpecialType == SpecialType.System_Double)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitExprConvertNumberToDouble(right)); // bool|int|long|number -> double, string -> number

                if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // r8 + r8 : r8
                    il.EmitOpCode(ILOpCode.Add);
                    return cg.CoreTypes.Double;
                }
                else
                {
                    // r8 + value : r8
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_double_value)
                        .Expect(SpecialType.System_Double);
                }

                //
                throw cg.NotImplementedException($"Add(double, {ytype.Name})", right);
            }
            else if (xtype.SpecialType == SpecialType.System_Int64)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));    // int|bool -> long, string -> number
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype.SpecialType == SpecialType.System_Int64)
                {
                    if (resultTypeOpt != null)
                    {
                        if (resultTypeOpt.SpecialType == SpecialType.System_Int64)
                        {
                            // (long)(i8 + i8 : number)
                            il.EmitOpCode(ILOpCode.Add);
                            return cg.CoreTypes.Long;
                        }
                    }

                    // i8 + i8 : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_long)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // i8 + r8 : r8
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_double)
                        .Expect(SpecialType.System_Double);
                }
                else if (ytype == cg.CoreTypes.PhpNumber)
                {
                    // i8 + number : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_number)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else
                {
                    // i8 + value : number
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_long_value)
                        .Expect(cg.CoreTypes.PhpNumber);
                }

                //
                throw cg.NotImplementedException($"Add(int64, {ytype.Name})", right);
            }
            else if (xtype == cg.CoreTypes.PhpArray)
            {
                var ytype = cg.Emit(right);
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype == cg.CoreTypes.PhpArray)
                {
                    // PhpArray.Union(array, array) : PhpArray
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Union_PhpArray_PhpArray)
                        .Expect(cg.CoreTypes.PhpArray);
                }
                else
                {
                    // array + value
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_array_value);
                }

                //
                throw cg.NotImplementedException($"Add(PhpArray, {ytype.Name})", right);
            }
            else if (xtype == cg.CoreTypes.PhpValue)
            {
                var ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));    // int|bool -> long, string -> number
                cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                if (ytype.SpecialType == SpecialType.System_Int64)
                {
                    // value + i8 : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_long)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else if (ytype.SpecialType == SpecialType.System_Double)
                {
                    // value + r8 : r8
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_double)
                        .Expect(SpecialType.System_Double);
                }
                else if (ytype == cg.CoreTypes.PhpArray)
                {
                    // value + array
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_array);
                }
                else if (ytype == cg.CoreTypes.PhpNumber)
                {
                    // value + number : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_number)
                        .Expect(cg.CoreTypes.PhpNumber);
                }
                else
                {
                    // value + value : value
                    if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_value)
                        .Expect(cg.CoreTypes.PhpValue);
                }

                //
                throw cg.NotImplementedException($"Add(PhpValue, {ytype.Name})", right);
            }
            else
            {
                // x -> PhpValue
                if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                // y -> PhpValue
                cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                var ytype = cg.CoreTypes.PhpValue;

                // value / value : number
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Add_value_value)
                    .Expect(cg.CoreTypes.PhpValue);


            }

            //
            throw cg.NotImplementedException($"Add({xtype.Name}, ...)", right);
        }

        /// <summary>
        /// Emits subtraction operator.
        /// </summary>
        internal static TypeSymbol EmitSub(CodeGenerator cg, BoundExpression left, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            return EmitSub(cg, cg.Emit(left), right, resultTypeOpt);
        }

        /// <summary>
        /// Emits subtraction operator.
        /// </summary>
        internal static TypeSymbol EmitSub(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> int64, string -> number
            TypeSymbol ytype;

            cg.EmitPhpAliasDereference(ref xtype); // alias -> value

            //
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                    cg.EmitPhpAliasDereference(ref ytype); // alias -> value
                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 - i8 : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_long)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 - r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_double)
                            .Expect(cg.CoreTypes.Double);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 - number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_number)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else
                    {
                        // i8 - value : number
                        if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_long_value)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }

                case SpecialType.System_Double:
                    ytype = cg.EmitConvertStringToPhpNumber(cg.EmitExprConvertNumberToDouble(right)); // bool|int|long|number -> double, string -> number
                    cg.EmitPhpAliasDereference(ref ytype); // alias -> value
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 - r8 : r8
                        il.EmitOpCode(ILOpCode.Sub);
                        return cg.CoreTypes.Double;
                    }
                    else
                    {
                        // r8 - value : double
                        if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_double_value)
                                .Expect(cg.CoreTypes.Double);

                    }

                case SpecialType.System_String:
                    xtype = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.ToNumber_String)
                        .Expect(cg.CoreTypes.PhpNumber);
                    goto default;

                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                        cg.EmitPhpAliasDereference(ref ytype); // alias -> value
                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number - i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number - r8 : double
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number - number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // number - value : number
                            if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_number_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }

                        throw cg.NotImplementedException($"Sub(PhpNumber, {ytype.Name})", right);
                    }
                    else if (xtype == cg.CoreTypes.PhpValue)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                        cg.EmitPhpAliasDereference(ref ytype); // alias -> value

                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // value - i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // value - r8 : r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // value - number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // value - value : number
                            if (ytype != cg.CoreTypes.PhpValue) { ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }

                        throw cg.NotImplementedException($"Sub(PhpValue, {ytype.Name})", right);
                    }
                    else
                    {
                        // x -> PhpValue
                        if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value / value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Subtract_value_value)
                            .Expect(cg.CoreTypes.PhpNumber);

                    }

                    throw cg.NotImplementedException($"Sub({xtype.Name},...)", right);
            }
        }

        internal static TypeSymbol EmitBitAnd(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            // most common cases:
            if (cg.IsLongOnly(left.TypeRefMask) || cg.IsLongOnly(right.TypeRefMask))
            {
                // i64 | i64 : i64
                cg.EmitConvert(left, cg.CoreTypes.Long);
                cg.EmitConvert(right, cg.CoreTypes.Long);
                cg.Builder.EmitOpCode(ILOpCode.And);
                return cg.CoreTypes.Long;
            }

            // TODO: IF cg.IsStringOnly(left.TypeRefMask) && cg.IsStringOnly(Right.TypeRefMask)

            //
            return EmitBitAnd(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitBitAnd(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                case SpecialType.System_Int32:
                case SpecialType.System_Boolean:
                case SpecialType.System_Double:
                    cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    cg.EmitConvert(right, cg.CoreTypes.Long);
                    cg.Builder.EmitOpCode(ILOpCode.And);
                    return cg.CoreTypes.Long;

                default:
                    if (right.ResultType != null && right.ResultType.SpecialType != SpecialType.System_String)
                    {
                        // value | !string -> long | long -> long
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                        goto case SpecialType.System_Int64;
                    }
                    else
                    {
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseAnd_PhpValue_PhpValue)
                            .Expect(cg.CoreTypes.PhpValue);

                    }
            }
        }

        internal static TypeSymbol EmitBitOr(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            // most common cases:
            if (cg.IsLongOnly(left.TypeRefMask) || cg.IsLongOnly(right.TypeRefMask))
            {
                // i64 | i64 : i64
                cg.EmitConvert(left, cg.CoreTypes.Long);
                cg.EmitConvert(right, cg.CoreTypes.Long);
                cg.Builder.EmitOpCode(ILOpCode.Or);
                return cg.CoreTypes.Long;
            }

            // TODO: IF cg.IsStringOnly(left.TypeRefMask) && cg.IsStringOnly(Right.TypeRefMask)

            //
            return EmitBitOr(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitBitOr(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                case SpecialType.System_Int32:
                case SpecialType.System_Boolean:
                case SpecialType.System_Double:
                    cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    cg.EmitConvert(right, cg.CoreTypes.Long);
                    cg.Builder.EmitOpCode(ILOpCode.Or);
                    return cg.CoreTypes.Long;

                default:
                    if (right.ResultType != null && right.ResultType.SpecialType != SpecialType.System_String)
                    {
                        // value | !string -> long | long -> long
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                        goto case SpecialType.System_Int64;
                    }
                    else
                    {
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseOr_PhpValue_PhpValue)
                            .Expect(cg.CoreTypes.PhpValue);

                    }
            }
        }

        internal static TypeSymbol EmitBitXor(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            // most common cases:
            if (cg.IsLongOnly(left.TypeRefMask) || cg.IsLongOnly(right.TypeRefMask))
            {
                // i64 | i64 : i64
                cg.EmitConvert(left, cg.CoreTypes.Long);
                cg.EmitConvert(right, cg.CoreTypes.Long);
                cg.Builder.EmitOpCode(ILOpCode.Xor);
                return cg.CoreTypes.Long;
            }

            // TODO: IF cg.IsStringOnly(left.TypeRefMask) && cg.IsStringOnly(Right.TypeRefMask)

            //
            return EmitBitXor(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitBitXor(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                case SpecialType.System_Int32:
                case SpecialType.System_Boolean:
                case SpecialType.System_Double:
                    cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    cg.EmitConvert(right, cg.CoreTypes.Long);
                    cg.Builder.EmitOpCode(ILOpCode.Xor);
                    return cg.CoreTypes.Long;

                default:
                    if (right.ResultType != null && right.ResultType.SpecialType != SpecialType.System_String)
                    {
                        // value | !string -> long | long -> long
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
                        goto case SpecialType.System_Int64;
                    }
                    else
                    {
                        cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseXor_PhpValue_PhpValue)
                            .Expect(cg.CoreTypes.PhpValue);
                    }

            }
        }

        internal static TypeSymbol EmitRemainder(CodeGenerator cg, BoundExpression left, BoundExpression right)
        {
            return EmitRemainder(cg, cg.Emit(left), right);
        }

        internal static TypeSymbol EmitRemainder(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            switch (xtype.SpecialType)
            {
                case SpecialType.System_Int32:
                case SpecialType.System_Double:
                    cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // cast to long
                    xtype = cg.CoreTypes.Long;
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    if (cg.IsNumberOnly(right.TypeRefMask))
                    {
                        // long & long
                        cg.EmitConvert(right, cg.CoreTypes.Long);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_long_long);
                    }
                    else
                    {
                        // long % value
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_long_value);
                    }

                default:

                    cg.EmitConvert(xtype, 0, cg.CoreTypes.PhpValue);

                    if (cg.IsNumberOnly(right.TypeRefMask))
                    {
                        // value % long
                        cg.EmitConvert(right, cg.CoreTypes.Long);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_value_long);
                    }
                    else
                    {
                        // value % value
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mod_value_value);
                    }

            }
        }

        internal static TypeSymbol EmitShift(CodeGenerator cg, BoundExpression left, BoundExpression right, ILOpCode op)
        {
            cg.EmitConvert(left, cg.CoreTypes.Long);
            return EmitShift(cg, cg.CoreTypes.Long, right, op);
        }

        internal static TypeSymbol EmitShift(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, ILOpCode op)
        {
            Debug.Assert(op == ILOpCode.Shl || op == ILOpCode.Shr);
            cg.EmitConvert(xtype, 0, cg.CoreTypes.Long);
            cg.EmitConvert(right, cg.CoreTypes.Int32);
            cg.Builder.EmitOpCode(op);

            return cg.CoreTypes.Long;
        }

        /// <summary>Emits <c>??</c> operator and returns the result type.</summary>
        TypeSymbol EmitCoalesce(CodeGenerator cg) => EmitCoalesce(cg, cg.Emit(this.Left), this.Left.TypeRefMask, this.Right);

        internal static TypeSymbol EmitCoalesce(CodeGenerator cg, TypeSymbol left_type, FlowAnalysis.TypeRefMask left_type_mask, BoundExpression right)
        {
            // Left ?? Right

            if (!cg.CanBeNull(left_type)) // in case we truly believe in our type analysis: || !cg.CanBeNull(this.Left.TypeRefMask))
            {
                return left_type;
            }

            object trueLbl = new object();
            object endLbl = new object();

            // <stack> = <left_var> = Left
            var left_var = cg.GetTemporaryLocal(left_type);
            cg.Builder.EmitOpCode(ILOpCode.Dup);
            cg.Builder.EmitLocalStore(left_var);

            cg.EmitNotNull(left_type, left_type_mask);
            cg.Builder.EmitBranch(ILOpCode.Brtrue, trueLbl);

            // false:
            var right_type = cg.Emit(right);
            var result_type = cg.DeclaringCompilation.Merge(left_type, right_type);
            cg.EmitConvert(right_type, right.TypeRefMask, result_type);
            cg.Builder.EmitBranch(ILOpCode.Br, endLbl);
            cg.Builder.AdjustStack(-1);

            // trueLbl:
            cg.Builder.MarkLabel(trueLbl);
            cg.Builder.EmitLocalLoad(left_var);
            cg.EmitConvert(left_type, left_type_mask, result_type);

            // endLbl:
            cg.Builder.MarkLabel(endLbl);

            //
            cg.ReturnTemporaryLocal(left_var);

            //
            return result_type;
        }

        /// <summary>Emits the spaceship `&lt;=&gt;` operation.</summary>
        TypeSymbol EmitSpaceship(CodeGenerator cg)
        {
            // TODO: return strictly -1, 0, +1 (.NET compare operation returns number in range: < 0, 0, > 0
            // TODO: optimize for specific type of operands (mostly string, long)

            cg.EmitConvertToPhpValue(Left);
            cg.EmitConvertToPhpValue(Right);

            // Template: Comparison.Compare( <Left>, <Right> ) : i4

            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_value_value)
                .Expect(SpecialType.System_Int32);
        }

        /// <summary>
        /// Emits binary boolean operation (AND or OR).
        /// </summary>
        /// <param name="cg">A code generator.</param>
        /// <param name="isAnd">Whether to emit AND, otherwise OR.</param>
        /// <returns>A type code of the result.</returns>
        TypeSymbol EmitBinaryBooleanOperation(CodeGenerator cg, bool isAnd)
        {
            var boolean = cg.CoreTypes.Boolean;  // typeof(bool)

            var il = cg.Builder;
            var partial_eval_label = new NamedLabel("<partial_eval>" + this.GetHashCode().ToString("X"));
            var end_label = new NamedLabel("<end>" + this.GetHashCode().ToString("X"));

            // IF [!]<(bool) Left> THEN GOTO partial_eval;
            cg.EmitConvert(Left, cg.CoreTypes.Boolean);
            il.EmitBranch(isAnd ? ILOpCode.Brfalse : ILOpCode.Brtrue, partial_eval_label);

            // <RESULT> = <(bool) Right>;
            cg.EmitConvert(Right, cg.CoreTypes.Boolean);

            // GOTO end;
            il.EmitBranch(ILOpCode.Br, end_label);
            il.AdjustStack(-1);

            // partial_eval:
            il.MarkLabel(partial_eval_label);
            il.EmitOpCode(isAnd ? ILOpCode.Ldc_i4_0 : ILOpCode.Ldc_i4_1, 1);

            // end:
            il.MarkLabel(end_label);

            //
            return boolean;
        }

        /// <summary>
        /// Emits binary operation XOR.
        /// </summary>
        TypeSymbol EmitBinaryXor(CodeGenerator cg)
        {
            // LOAD <(bool) leftSon> == <(bool) rightSon>;
            cg.EmitConvert(Left, cg.CoreTypes.Boolean);
            cg.EmitConvert(Right, cg.CoreTypes.Boolean);
            cg.EmitOpCode(ILOpCode.Ceq);

            cg.EmitOpCode(ILOpCode.Ldc_i4_0);
            cg.EmitOpCode(ILOpCode.Ceq);

            return cg.CoreTypes.Boolean;
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        TypeSymbol EmitEquality(CodeGenerator cg, ref bool negation)
        {
            // x == y
            return EmitEquality(cg, Left, Right, ref negation);
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        internal static TypeSymbol EmitEquality(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            bool negation = false;  // unused
            return EmitEquality(cg, xtype, right, ref negation);
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        internal static TypeSymbol EmitEquality(CodeGenerator cg, BoundExpression left, BoundExpression right, ref bool negation)
        {
            if (left.ConstantValue.IsNull())
            {
                // null == right
                return EmitEqualityToNull(cg, right, ref negation);
            }
            else if (right.ConstantValue.IsNull())
            {
                // left == null
                return EmitEqualityToNull(cg, left, ref negation);
            }
            else
            {
                // left == right
                return EmitEquality(cg, cg.Emit(left), right, ref negation);
            }
        }

        static TypeSymbol EmitEqualityToNull(CodeGenerator cg, BoundExpression expr, ref bool negation)
        {
            // Template: <expr> == null

            var il = cg.Builder;
            var t = cg.Emit(expr);

            //
            switch (t.SpecialType)
            {
                case SpecialType.System_Object:
                    il.EmitNullConstant();
                    if (negation)
                    {
                        // object != null
                        il.EmitOpCode(ILOpCode.Cgt_un);
                        negation = false;   // handled
                    }
                    else
                    {
                        // object == null
                        il.EmitOpCode(ILOpCode.Ceq);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Double:
                    // r8 == 0
                    il.EmitDoubleConstant(0.0);
                    il.EmitOpCode(ILOpCode.Ceq);
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int32:
                    // i4 == 0
                    cg.EmitLogicNegation();
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int64:
                    // i8 == 0
                    il.EmitLongConstant(0);
                    if (negation)
                    {
                        il.EmitOpCode(ILOpCode.Cgt_un);
                        negation = false; // handled
                    }
                    else
                    {
                        il.EmitOpCode(ILOpCode.Ceq);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_String:
                    // string.IsNullOrEmpty(string)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsNullOrEmpty_String);
                    return cg.CoreTypes.Boolean;

                default:
                    if (t == cg.CoreTypes.PhpNumber)
                    {
                        // number == 0L
                        il.EmitLongConstant(0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_long)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (t == cg.CoreTypes.PhpAlias)
                    {
                        // LOAD <PhpAlias>.Value
                        cg.Emit_PhpAlias_GetValue();
                    }
                    else
                    {
                        // LOAD <PhpValue>
                        cg.EmitConvert(t, 0, cg.CoreTypes.PhpValue);
                    }

                    // CeqNull(<value>)
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.CeqNull_value)
                        .Expect(SpecialType.System_Boolean);
            }
        }

        /// <summary>
        /// Emits check for values equality.
        /// Lefts <c>bool</c> on top of evaluation stack.
        /// </summary>
        internal static TypeSymbol EmitEquality(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, ref bool negation)
        {
            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Boolean:

                    // bool == y.ToBoolean()
                    cg.EmitConvert(right, cg.CoreTypes.Boolean);
                    cg.Builder.EmitOpCode(ILOpCode.Ceq);

                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int32:
                    // i4 -> i8
                    cg.Builder.EmitOpCode(ILOpCode.Conv_i8);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:

                    ytype = cg.Emit(right);

                    //
                    if (ytype.SpecialType == SpecialType.System_Int32)
                    {
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                        ytype = cg.CoreTypes.Long;
                    }

                    //
                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 == i8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 == r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_long_double)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // i8 == bool
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_long_bool)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // i8 == string
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_long_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 == number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_long_number)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);

                        // compare(i8, value) == 0
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_long_value);
                        cg.EmitLogicNegation();

                        return cg.CoreTypes.Boolean;
                    }


                case SpecialType.System_Double:

                    ytype = cg.EmitExprConvertNumberToDouble(right);  // bool|long|int -> double

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 == r8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // r8 == string
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_double_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);

                        // compare(double, value) == 0
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_double_value);
                        cg.EmitLogicNegation();

                        return cg.CoreTypes.Boolean;
                    }


                case SpecialType.System_String:

                    ytype = cg.Emit(right);

                    if (ytype.SpecialType == SpecialType.System_Int32)
                    {
                        // i4 -> i8
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);
                        ytype = cg.CoreTypes.Long;
                    }

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // string == i8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_long)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // string == bool
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_bool)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // string == r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_double)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // Ceq(string, string)
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Ceq_string_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);

                        if (negation)
                        {
                            // string != value
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Ineq_String_PhpValue)
                                .Expect(SpecialType.System_Boolean);
                            negation = false;   // handled
                        }
                        else
                        {
                            // string == value
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Eq_String_PhpValue)
                                .Expect(SpecialType.System_Boolean);
                        }
                        return cg.CoreTypes.Boolean;
                    }

                //case SpecialType.System_Object:
                //    goto default;

                default:

                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertIntToLong(cg.Emit(right));
                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number == i8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_long)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number == r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_double)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number == number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_number)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else
                        {
                            ytype = cg.EmitConvertToPhpValue(ytype, 0);
                            // number == value
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Eq_number_PhpValue)
                                .Expect(SpecialType.System_Boolean);
                        }
                    }
                    else
                    {
                        // TODO: xtype: PhpArray, ...

                        xtype = cg.EmitConvertToPhpValue(xtype, 0);

                        ytype = cg.Emit(right);
                        switch (ytype.SpecialType)
                        {
                            case SpecialType.System_String:
                                if (negation)
                                {
                                    negation = false;   // handled
                                    // value == string
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Ineq_PhpValue_String)
                                        .Expect(SpecialType.System_Boolean);
                                }
                                else
                                {
                                    // value == string
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Eq_PhpValue_String)
                                        .Expect(SpecialType.System_Boolean);
                                }

                            // TODO: more types on right

                            default:
                                ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask);

                                if (negation)
                                {
                                    negation = false; // handled
                                    // value == value
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Ineq_PhpValue_PhpValue)
                                        .Expect(SpecialType.System_Boolean);
                                }
                                else
                                {
                                    // value == value
                                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Eq_PhpValue_PhpValue)
                                        .Expect(SpecialType.System_Boolean);
                                }
                        }
                    }
            }
        }

        TypeSymbol EmitStrictEquality(CodeGenerator cg)
            => EmitStrictEquality(cg, Left, Right);

        internal static TypeSymbol EmitStrictEquality(CodeGenerator cg, BoundExpression left, BoundExpression right)
            => EmitStrictEquality(cg, cg.Emit(left), right);

        internal static TypeSymbol EmitStrictEquality(CodeGenerator cg, TypeSymbol xtype, BoundExpression right)
        {
            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Boolean:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // bool == bool
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Double ||
                        ytype.SpecialType == SpecialType.System_Int32 ||
                        ytype.SpecialType == SpecialType.System_Int64 ||
                        ytype.SpecialType == SpecialType.System_String ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray) ||
                        ytype == cg.CoreTypes.PhpString ||
                        ytype == cg.CoreTypes.Object)
                    {
                        // bool == something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else
                    {
                        // bool == PhpValue
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_bool_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                case SpecialType.System_Int32:
                    cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_Int32)
                    {
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                        ytype = cg.CoreTypes.Long;
                    }

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 === i8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 === number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_long_PhpNumber)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Boolean ||
                        ytype.SpecialType == SpecialType.System_String ||
                        ytype.SpecialType == SpecialType.System_Double ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray) ||
                        ytype == cg.CoreTypes.Object ||
                        ytype == cg.CoreTypes.PhpString)
                    {
                        // i8 === something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else
                    {
                        // i8 === PhpValue
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_long_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                case SpecialType.System_Double:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 == r8
                        cg.Builder.EmitOpCode(ILOpCode.Ceq);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // r8 === number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_double_PhpNumber)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Boolean ||
                        ytype.SpecialType == SpecialType.System_Int32 ||
                        ytype.SpecialType == SpecialType.System_Int64 ||
                        ytype.SpecialType == SpecialType.System_String ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray) ||
                        ytype == cg.CoreTypes.Object ||
                        ytype == cg.CoreTypes.PhpString)
                    {
                        // r8 == something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else
                    {
                        // r8 == PhpValue
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_double_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                case SpecialType.System_String:
                    // string === RValue
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // string === string
                        return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(SpecialMember.System_String__op_Equality));
                    }
                    else if (
                        ytype.SpecialType == SpecialType.System_Boolean ||
                        ytype.SpecialType == SpecialType.System_Int32 ||
                        ytype.SpecialType == SpecialType.System_Int64 ||
                        ytype.SpecialType == SpecialType.System_Double ||
                        ytype.IsOfType(cg.CoreTypes.IPhpArray))
                    {
                        // string == something else => false
                        cg.EmitPop(ytype);
                        cg.EmitPop(xtype);
                        cg.Builder.EmitBoolConstant(false);
                        return cg.CoreTypes.Boolean;
                    }
                    else if (ytype.SpecialType == SpecialType.System_Object && right.ConstantValue.IsNull())
                    {
                        // comparison to NULL
                        // string === NULL
                        // Template: ReferenceEquals( string, object )
                        return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(SpecialMember.System_Object__ReferenceEquals))
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        // string === value
                        ytype = cg.EmitConvertToPhpValue(ytype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_string_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                default:

                    // === NULL
                    if (right.ConstantValue.IsNull())
                    {
                        if (xtype.IsReferenceType && xtype != cg.CoreTypes.PhpAlias)
                        {
                            // Template: <STACK> == null
                            cg.Builder.EmitNullConstant();
                            cg.Builder.EmitOpCode(ILOpCode.Ceq);
                            return cg.CoreTypes.Boolean;
                        }

                        // StrictCeqNull( <VALUE> )
                        xtype = cg.EmitConvertToPhpValue(xtype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeqNull_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }

                    // TODO: PhpArray, Object === ...

                    xtype = cg.EmitConvertToPhpValue(xtype, 0);
                    ytype = cg.Emit(right);

                    if (ytype.SpecialType == SpecialType.System_Boolean)
                    {
                        // PhpValue == bool
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_PhpValue_bool)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // value === string
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_PhpValue_string)
                            .Expect(SpecialType.System_Boolean);
                    }
                    else
                    {
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }

                        // PhpValue == PhpValue
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.StrictCeq_PhpValue_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                    }
            }
        }

        /// <summary>
        /// Emits comparison operator pushing <c>bool</c> (<c>i4</c> of value <c>0</c> or <c>1</c>) onto the evaluation stack.
        /// </summary>
        /// <param name="cg">Code generator helper.</param>
        /// <param name="lt">True for <c>clt</c> (less than) otherwise <c>cgt</c> (greater than).</param>
        /// <returns>Resulting type code pushed onto the top of evaliuation stack.</returns>
        TypeSymbol EmitLtGt(CodeGenerator cg, bool lt)
            => EmitLtGt(cg, cg.Emit(Left), Right, lt);

        /// <summary>
        /// Emits comparison operator pushing <c>bool</c> (<c>i4</c> of value <c>0</c> or <c>1</c>) onto the evaluation stack.
        /// </summary>
        /// <returns>Resulting type code pushed onto the top of evaluation stack.</returns>
        internal static TypeSymbol EmitLtGt(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, bool lt)
        {
            TypeSymbol ytype;
            var il = cg.Builder;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Void:
                    ytype = cg.Emit(right);    // bool|int -> long

                    // Template: Operators.CompareNull(value)
                    if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.CompareNull_value);

                    // {comparison }<> 0
                    il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                    il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Int32:
                    // i4 -> i8
                    il.EmitOpCode(ILOpCode.Conv_i8);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // bool|int -> long
                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 <> r8
                        return cg.EmitCall(ILOpCode.Call, lt
                            ? cg.CoreMethods.Operators.Clt_long_double
                            : cg.CoreMethods.Operators.Cgt_long_double);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 <> number
                        return cg.EmitCall(ILOpCode.Call, lt
                            ? cg.CoreMethods.PhpNumber.lt_long_number
                            : cg.CoreMethods.PhpNumber.gt_long_number);
                    }
                    else
                    {
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }

                        // compare(i8, value) <> 0
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_long_value);

                        il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right);    // bool|int|long|number -> double
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 <> r8
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    else
                    {
                        // compare(r8, value)
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_double_value);

                        // <> 0
                        il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    }
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_String:
                    ytype = cg.Emit(right);
                    if (ytype.SpecialType == SpecialType.System_String)
                    {
                        // compare(string, string)
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_string);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // compare(string, long)
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_long);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // compare(string, double)
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_double);
                    }
                    else
                    {
                        // compare(string, value)
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_string_value);
                    }

                    // <> 0
                    il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                    il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    return cg.CoreTypes.Boolean;

                case SpecialType.System_Boolean:

                    cg.EmitConvert(right, cg.CoreTypes.Boolean);
                    ytype = cg.CoreTypes.Boolean;

                    // compare(bool, bool)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_bool_bool);

                    // <> 0
                    il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                    il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                    return cg.CoreTypes.Boolean;

                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // bool|int -> long
                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number <> i8
                            return cg.EmitCall(ILOpCode.Call, lt
                                ? cg.CoreMethods.PhpNumber.lt_number_long
                                : cg.CoreMethods.PhpNumber.gt_number_long)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number <> r8
                            return cg.EmitCall(ILOpCode.Call, lt
                                ? cg.CoreMethods.PhpNumber.lt_number_double
                                : cg.CoreMethods.PhpNumber.gt_number_double)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number <> number
                            return cg.EmitCall(ILOpCode.Call, lt
                                ? cg.CoreMethods.PhpNumber.lt_number_number
                                : cg.CoreMethods.PhpNumber.gt_number_number)
                                .Expect(SpecialType.System_Boolean);
                        }
                        else
                        {
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }

                            // compare(number, value)
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_number_value);

                            // <> 0
                            il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);    // +1 on stack
                            il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                            return cg.CoreTypes.Boolean;
                        }
                    }
                    else
                    {
                        xtype = cg.EmitConvertToPhpValue(xtype, 0);
                        ytype = cg.Emit(right);

                        // TODO: if (ytype.SpecialType == SpecialType.System_Boolean) ...
                        // TODO: if (ytype.SpecialType == SpecialType.System_String) ...
                        // TODO: if (ytype.SpecialType == SpecialType.System_Double) ...

                        if (ytype.SpecialType == SpecialType.System_Int64 || ytype.SpecialType == SpecialType.System_Int32)
                        {
                            // compare(value, i8)
                            ytype = cg.EmitConvertIntToLong(ytype);
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_value_long);
                        }
                        else
                        {
                            // compare(value, value)
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Compare_value_value);
                        }

                        // <> 0
                        il.EmitOpCode(ILOpCode.Ldc_i4_0, 1);
                        il.EmitOpCode(lt ? ILOpCode.Clt : ILOpCode.Cgt);
                        return cg.CoreTypes.Boolean;
                    }
            }
        }

        /// <summary>
        /// Emits <c>*</c> operation.
        /// </summary>
        TypeSymbol EmitMultiply(CodeGenerator cg)
            => EmitMul(cg, cg.Emit(Left), Right);

        internal static TypeSymbol EmitMul(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> int64, string -> number

            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right); // bool|int|long|number -> double
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 * r8 : r8
                        il.EmitOpCode(ILOpCode.Mul);
                        return xtype;   // r8
                    }
                    else
                    {
                        // r8 * value : r8
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_double_value)
                                .Expect(SpecialType.System_Double);
                    }
                    //
                    throw cg.NotImplementedException($"Mul(double, {ytype.Name})", right);

                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 * i8 : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                    }
                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 * r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_double)
                                .Expect(SpecialType.System_Double);
                    }
                    if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 * number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else
                    {
                        // i8 * value : number
                        if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_long_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                    }
                    //
                    throw cg.NotImplementedException($"Mul(int64, {ytype.Name})", right);

                default:

                    if (xtype == cg.CoreTypes.PhpAlias)
                    {
                        // dereference:
                        xtype = cg.Emit_PhpAlias_GetValue();
                    }

                    //

                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));

                        if (ytype == cg.CoreTypes.PhpAlias)
                        {
                            // PhpAlias -> PhpValue
                            ytype = cg.Emit_PhpAlias_GetValue();
                        }

                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_double)
                                .Expect(cg.CoreTypes.Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number * number : number
                            cg.EmitConvertToPhpNumber(ytype, right.TypeRefMask);
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // number * value : number
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_number_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }

                        //
                        throw cg.NotImplementedException($"Mul(PhpNumber, {ytype.Name})", right);
                    }
                    else if (xtype == cg.CoreTypes.PhpValue)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));    // bool|int -> long, string -> number
                        if (ytype == cg.CoreTypes.PhpAlias)
                        {
                            // PhpAlias -> PhpValue
                            ytype = cg.Emit_PhpAlias_GetValue();
                        }

                        if (ytype == cg.CoreTypes.Long)
                        {
                            // value * i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_long)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype == cg.CoreTypes.Double)
                        {
                            // value * r8 : double
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_double)
                                .Expect(SpecialType.System_Double);
                        }
                        else if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // value * number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else
                        {
                            // value * value : number
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_value)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        //
                        throw cg.NotImplementedException($"Mul(PhpValue, {ytype.Name})", right);
                    }
                    else
                    {
                        // x -> PhpValue
                        if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value / value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Mul_value_value)
                            .Expect(cg.CoreTypes.PhpNumber);

                    }


                    //
                    throw cg.NotImplementedException($"Mul({xtype.Name}, ...)", right);
            }
        }

        /// <summary>
        /// Emits <c>/</c> operator.
        /// </summary>
        TypeSymbol EmitDivision(CodeGenerator cg)
            => EmitDiv(cg, cg.Emit(Left), Right);

        internal static TypeSymbol EmitDiv(CodeGenerator cg, TypeSymbol xtype, BoundExpression right, TypeSymbol resultTypeOpt = null)
        {
            var il = cg.Builder;

            xtype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(xtype));    // int|bool -> int64, string -> number

            if (xtype == cg.CoreTypes.PhpAlias)
            {
                // PhpAlias -> PhpValue
                xtype = cg.Emit_PhpAlias_GetValue();
            }

            TypeSymbol ytype;

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right); // bool|int|long|number -> double
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        il.EmitOpCode(ILOpCode.Div);
                        return xtype;   // r8
                    }
                    else
                    {
                        // double / value : double
                        cg.EmitConvertToPhpValue(ytype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Div_double_PhpValue);
                    }


                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertIntToLong(cg.Emit(right));  // bool|int -> long
                    if (ytype == cg.CoreTypes.PhpAlias)
                    {
                        // PhpAlias -> PhpValue
                        ytype = cg.Emit_PhpAlias_GetValue();
                    }

                    if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // long / number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_long_number)
                            .Expect(cg.CoreTypes.PhpNumber);
                    }
                    else
                    {
                        // long / value : number
                        cg.EmitConvertToPhpValue(ytype, 0);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Div_long_PhpValue);
                    }


                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertStringToPhpNumber(cg.EmitConvertIntToLong(cg.Emit(right)));  // bool|int -> long, string -> number
                        if (ytype == cg.CoreTypes.PhpAlias)
                        {
                            // PhpAlias -> PhpValue
                            ytype = cg.Emit_PhpAlias_GetValue();
                        }

                        if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number / number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_number)
                                .Expect(cg.CoreTypes.PhpNumber);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // number / i8 : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_long);
                        }
                        else if (ytype.SpecialType == SpecialType.System_Double)
                        {
                            // number / r8 : r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_double);
                        }
                        else
                        {
                            // number / value : number
                            if (ytype != cg.CoreTypes.PhpValue) { cg.EmitConvertToPhpValue(ytype, right.TypeRefMask); }
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Division_number_value);
                        }

                        //
                        throw cg.NotImplementedException($"Div(number, {ytype.Name})", right);
                    }
                    else
                    {
                        // x -> PhpValue
                        if (xtype != cg.CoreTypes.PhpValue) { xtype = cg.EmitConvertToPhpValue(xtype, right.TypeRefMask); }

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value / value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Div_PhpValue_PhpValue);

                    }

            }
        }

        /// <summary>
        /// Emits <c>pow</c> operator.
        /// </summary>
        TypeSymbol EmitPow(CodeGenerator cg)
        {
            return EmitPow(cg, cg.Emit(Left), Left.TypeRefMask, Right);
        }

        internal static TypeSymbol EmitPow(CodeGenerator cg, TypeSymbol xtype, FlowAnalysis.TypeRefMask xtype_hint, BoundExpression right)
        {
            var il = cg.Builder;

            TypeSymbol ytype;
            xtype = cg.EmitConvertIntToLong(xtype);    // int|bool -> long

            switch (xtype.SpecialType)
            {
                case SpecialType.System_Int64:
                    ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // int|bool -> long

                    if (ytype.SpecialType == SpecialType.System_Int64)
                    {
                        // i8 ** i8 : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_long);
                    }
                    else if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // i8 ** r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_double);
                    }
                    else if (ytype == cg.CoreTypes.PhpNumber)
                    {
                        // i8 ** number : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_number);
                    }
                    else
                    {
                        // y -> PhpValue
                        cg.EmitConvert(ytype, right.TypeRefMask, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // i8 ** value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_long_value);
                    }

                case SpecialType.System_Double:
                    ytype = cg.EmitExprConvertNumberToDouble(right);    // int|bool|long|number -> double

                    if (ytype.SpecialType == SpecialType.System_Double)
                    {
                        // r8 ** r8 : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_double_double);
                    }
                    else
                    {
                        // y -> PhpValue
                        cg.EmitConvert(ytype, right.TypeRefMask, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // r8 ** value : r8
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_double_value);
                    }

                default:
                    if (xtype == cg.CoreTypes.PhpNumber)
                    {
                        ytype = cg.EmitConvertIntToLong(cg.Emit(right));    // int|bool -> long
                        if (ytype == cg.CoreTypes.Double)
                        {
                            // number ** r8 : r8
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_number_double);
                        }

                        if (ytype.SpecialType == SpecialType.System_Int64)
                        {
                            // y -> number
                            ytype = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Create_Long);
                        }

                        if (ytype == cg.CoreTypes.PhpNumber)
                        {
                            // number ** number : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_number_number);
                        }
                        else
                        {
                            // y -> PhpValue
                            ytype = cg.EmitConvertToPhpValue(ytype, right.TypeRefMask);

                            // number ** value : number
                            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_number_value);
                        }
                    }
                    else
                    {
                        // x -> PhpValue
                        xtype = cg.EmitConvertToPhpValue(xtype, xtype_hint);

                        // y -> PhpValue
                        cg.EmitConvert(right, cg.CoreTypes.PhpValue);
                        ytype = cg.CoreTypes.PhpValue;

                        // value ** value : number
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Pow_value_value);
                    }

            }
        }
    }

    partial class BoundUnaryEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsRead || Access.IsNone, "Access cannot be " + Access.ToString());

            TypeSymbol returned_type;

            switch (this.Operation)
            {
                case Operations.AtSign:
                    // special arrangement
                    // Template:
                    //		context.DisableErrorReporting();
                    //		s;
                    //		context.EnableErrorReporting();
                    returned_type = cg.EmitWithDisabledErrorReporting(Operand);
                    break;

                case Operations.BitNegation:
                    //Template: "~x" Operators.BitNot(x)                                     
                    returned_type = EmitBitNot(cg);
                    break;

                case Operations.Clone:
                    // Template: clone x
                    returned_type = EmitClone(cg);
                    break;

                case Operations.LogicNegation:
                    //Template: !(bool)(x);
                    cg.EmitConvertToBool(this.Operand);
                    cg.EmitLogicNegation();
                    returned_type = cg.CoreTypes.Boolean;
                    break;

                case Operations.Minus:
                    //Template: "-x"
                    returned_type = EmitMinus(cg);
                    break;

                case Operations.Plus:
                    //Template: "+x"
                    returned_type = EmitPlus(cg);
                    break;

                case Operations.Print:
                    cg.EmitEcho(this.Operand);

                    if (Access.IsRead)
                    {
                        // Always returns 1
                        cg.Builder.EmitLongConstant(1);
                        returned_type = cg.CoreTypes.Long;
                    }
                    else
                    {
                        // nobody reads the result anyway
                        returned_type = cg.CoreTypes.Void;
                    }
                    break;

                case Operations.UnsetCast:
                    // Template: "(unset)x"  null

                    cg.EmitPop(cg.Emit(this.Operand));

                    if (this.Access.IsRead)
                    {
                        cg.Builder.EmitNullConstant();
                        returned_type = cg.CoreTypes.Object;
                    }
                    else
                    {
                        returned_type = cg.CoreTypes.Void;
                    }
                    break;

                default:
                    throw ExceptionUtilities.Unreachable;
            }

            //
            if (Access.IsNone)
            {
                // Result is not read, pop the result
                cg.EmitPop(returned_type);
                returned_type = cg.CoreTypes.Void;
            }
            else if (Access.IsRead)
            {
                // Debug.Assert(returned_type.SpecialType != SpecialType.System_Void, "returns void, operation: " + this.Operation.ToString() + ", file: " + cg.ContainingFile.RelativeFilePath);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(Access);
            }

            return returned_type;
        }

        TypeSymbol EmitMinus(CodeGenerator cg)
        {
            // Template: 0L - Operand

            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            switch (t.SpecialType)
            {
                case SpecialType.System_Double:
                    // -r8
                    il.EmitOpCode(ILOpCode.Neg);
                    return t;
                case SpecialType.System_Int32:
                    // -(i8)i4
                    il.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                    il.EmitOpCode(ILOpCode.Neg);        // result will fit into long for sure
                    return cg.CoreTypes.Long;
                case SpecialType.System_Int64:
                    // PhpNumber.Minus(i8) : number
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Negation_long)
                            .Expect(cg.CoreTypes.PhpNumber);
                default:
                    if (t != cg.CoreTypes.PhpNumber)
                    {
                        cg.EmitConvertToPhpNumber(t, 0);
                    }

                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpNumber.Negation)
                        .Expect(cg.CoreTypes.PhpNumber);
            }
        }

        TypeSymbol EmitPlus(CodeGenerator cg)
        {
            // Template: 0L + Operand

            // convert value to a number

            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            switch (t.SpecialType)
            {
                case SpecialType.System_Double:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                    return t;
                case SpecialType.System_Boolean:
                    // (long)(int)bool
                    il.EmitOpCode(ILOpCode.Conv_i4);
                    il.EmitOpCode(ILOpCode.Conv_i8);
                    return cg.CoreTypes.Long;
                default:
                    if (t != cg.CoreTypes.PhpNumber)
                    {
                        cg.EmitConvertToPhpNumber(t, 0);
                    }

                    return cg.CoreTypes.PhpNumber;
            }
        }

        TypeSymbol EmitBitNot(CodeGenerator cg)
        {
            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            switch (t.SpecialType)
            {
                case SpecialType.System_Double:
                case SpecialType.System_Int32:
                    // r8|i4 -> i8
                    il.EmitOpCode(ILOpCode.Conv_i8);
                    goto case SpecialType.System_Int64;

                case SpecialType.System_Int64:
                    il.EmitOpCode(ILOpCode.Not);    // ~i64 : i64
                    return cg.CoreTypes.Long;

                case SpecialType.System_Boolean:
                    throw new NotImplementedException();    // ERR
                default:
                    if (t == cg.CoreTypes.PhpArray)
                    {
                        throw new NotImplementedException(); // ERR
                    }

                    // ~ PhpValue
                    cg.EmitConvert(t, Operand.TypeRefMask, cg.CoreTypes.PhpValue);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BitwiseNot_PhpValue);
            }
        }

        TypeSymbol EmitClone(CodeGenerator cg)
        {
            // Template clone(Context, Object)
            cg.EmitLoadContext();
            var t = cg.EmitAsObject(cg.Emit(this.Operand));

            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Clone_Context_Object)
                .Expect(SpecialType.System_Object);

            //
            return t;
        }
    }

    partial class BoundConversionEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            // emit explicit 'cast' operation

            var t = cg.Emit(this.Operand);

            var target = (TypeSymbol)this.TargetType.ResolveTypeSymbol(cg.DeclaringCompilation);
            if (target.IsErrorTypeOrNull())
            {
                throw cg.NotImplementedException(op: this);
            }

            if (Access.IsNone)
            {
                cg.EmitPop(t);
                return cg.CoreTypes.Void;
            }

            var conv = cg.DeclaringCompilation.ClassifyExplicitConversion(t, target);
            if (conv.Exists == false && t.IsVoid())
            {
                if (target.IsValueType)
                {
                    // 0
                    cg.EmitLoadDefault(target);
                }
                else if (target.SpecialType == SpecialType.System_String)
                {
                    // ""
                    cg.Builder.EmitStringConstant(string.Empty);
                }
                else if (target.Is_PhpArray())
                {
                    // PhpArray(0)
                    cg.Emit_PhpArray_NewEmpty();
                }
                else
                {
                    throw cg.NotImplementedException($"Conversion from {t} to {target}");
                }
            }
            else
            {
                cg.EmitConversion(conv, t, target);
            }

            //

            return target;
        }
    }

    partial class BoundCallableConvert
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {

            if ((TargetCallable is MethodSymbol m && m.IsValidMethod()) ||
                (m is AmbiguousMethodSymbol a && a.IsOverloadable && a.Ambiguities.Length != 0))
            {
                if (m.IsStatic)
                {
                    return m.EmitLoadRoutineInfo(cg);
                }
                else
                {
                    Debug.Assert(Receiver != null);

                    // PhpCallback.Create((object)Receiver, methodRoutineInfo)
                    cg.EmitConvert(Receiver, cg.CoreTypes.Object);
                    m.EmitLoadRoutineInfo(cg);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BindTargetToMethod_Object_RoutineInfo)
                        .Expect(cg.CoreTypes.IPhpCallable);
                }
            }

            // generic conversion to IPhpCallable:
            var target = (TypeSymbol)this.TargetType.ResolveTypeSymbol(cg.DeclaringCompilation);    // always IPhpCallable

            // 
            cg.EmitConvert(this.Operand, target);
            return target;
        }
    }

    partial class BoundLiteral
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsRead || Access.IsNone);

            // do nothing
            if (this.Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }

            // push value onto the evaluation stack

            Debug.Assert(ConstantValue.HasValue);
            return cg.EmitLoadConstant(ConstantValue.Value, this.Access.TargetType);
        }
    }

    partial class BoundCopyValue
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var expr = this.Expression;
            var t = cg.Emit(expr);

            if (expr.IsDeeplyCopied)
            {
                // dereference
                if (expr.TypeRefMask.IsRef)
                {
                    t = cg.EmitDereference(t);
                }

                // copy
                t = cg.EmitDeepCopy(t, expr.TypeRefMask);
            }

            //
            return t;
        }
    }

    partial class BoundReferenceExpression
    {
        /// <summary>
        /// Gets <see cref="IVariableReference"/> providing load and store operations.
        /// </summary>
        internal abstract IVariableReference BindPlace(CodeGenerator cg);

        internal abstract IPlace Place();

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsRead || this.Access.IsNone);

            if (Access.IsNone)
            {
                // do nothing
                return cg.CoreTypes.Void;
            }

            if (ConstantValue.HasValue)
            {
                return cg.EmitLoadConstant(ConstantValue.Value, this.Access.TargetType);
            }

            var boundplace = this.BindPlace(cg);
            if (boundplace != null)
            {
                return boundplace.EmitLoadValue(cg, Access);
            }
            else
            {
                throw cg.NotImplementedException($"IVariableReference of {this} is null!");
            }
        }
    }

    partial class BoundVariableName
    {
        /// <summary>
        /// Emits the name of variable leaving <c>string</c> on top of evaluation stack.
        /// </summary>
        internal TypeSymbol EmitVariableName(CodeGenerator cg)
        {
            if (this.IsDirect)
            {
                cg.Builder.EmitStringConstant(this.NameValue.Value);
            }
            else
            {
                cg.EmitConvert(this.NameExpression, cg.CoreTypes.String);
            }

            //
            return cg.CoreTypes.String;
        }

        internal void EmitIntStringKey(CodeGenerator cg)
        {
            if (this.IsDirect)
            {
                cg.EmitIntStringKey(this.NameValue.Value);
            }
            else
            {
                cg.EmitIntStringKey(this.NameExpression);
            }
        }
    }

    partial class BoundVariableRef
    {
        internal override IVariableReference BindPlace(CodeGenerator cg) => this.Variable; // .BindPlace(cg.Builder, this.Access, this.BeforeTypeRef);

        internal override IPlace Place() => this.Variable.Place;
    }

    partial class BoundListEx : IVariableReference
    {
        internal override IVariableReference BindPlace(CodeGenerator cg) => this;

        internal override IPlace Place() => null;

        /// <summary>
        /// Emits conversion to <c>IPhpArray</c>.
        /// Emits empty array on top of stack if object cannot be used as array.
        /// </summary>
        static TypeSymbol/*!*/EmitListAccess(CodeGenerator cg, TypeSymbol valueType)
        {
            Debug.Assert(valueType != null);

            if (valueType.IsReferenceType)
            {
                if (valueType.IsOfType(cg.CoreTypes.IPhpArray))
                {
                    return valueType; // keep value on stack
                }

                if (valueType.IsOfType(cg.CoreTypes.ArrayAccess))
                {
                    // Template: EnsureArray( ArrayAccess) : IPhpArray
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_ArrayAccess);
                }
            }

            // Template: Operators: GetListAccess( (PhpValue)value )
            cg.EmitConvertToPhpValue(valueType, 0);
            return cg.EmitCall(ILOpCode.Call, cg.CoreTypes.Operators.Method("GetListAccess", cg.CoreTypes.PhpValue));
        }

        static void EmitItemAssign(CodeGenerator cg, KeyValuePair<BoundExpression, BoundReferenceExpression> item, long index, IPlace arrplace)
        {
            var target = item;
            if (target.Value == null)
            {
                return;
            }

            // Template: <vars[i]> = <tmp>[i]

            var boundtarget = target.Value.BindPlace(cg);
            var lhs = boundtarget.EmitStorePreamble(cg, target.Value.TargetAccess());

            // LOAD IPhpArray.GetItemValue(IntStringKey{i})
            arrplace.EmitLoad(cg.Builder);
            if (target.Key == null)
            {
                cg.EmitIntStringKey(index);
            }
            else
            {
                cg.EmitIntStringKey(target.Key);
            }

            // GetItemVaue
            var itemtype = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.GetItemValue_IntStringKey);

            // dereference
            itemtype = cg.EmitDereference(itemtype);

            // copy
            itemtype = cg.EmitDeepCopy(itemtype, nullcheck: true);

            // STORE vars[i]
            boundtarget.EmitStore(cg, ref lhs, itemtype, target.Value.Access);
            lhs.Dispose();
        }

        #region IVariableReference

        Symbol IVariableReference.Symbol => null;

        TypeSymbol IVariableReference.Type => null; // throw new NotImplementedException();

        bool IVariableReference.HasAddress => false;

        IPlace IVariableReference.Place => null;

        LhsStack IVariableReference.EmitStorePreamble(CodeGenerator cg, BoundAccess access)
        {
            // nada
            return default;
        }

        void IVariableReference.EmitStore(CodeGenerator cg, ref LhsStack lhs, TypeSymbol stack, BoundAccess access)
        {
            var rtype = EmitListAccess(cg, stack);

            var tmp = cg.GetTemporaryLocal(rtype);
            cg.Builder.EmitLocalStore(tmp);

            var items = this.Items;

            // NOTE: since PHP7, variables are assigned from left to right

            for (int i = 0; i < items.Length; i++)
            {
                EmitItemAssign(cg, items[i], i, new LocalPlace(tmp));
            }

            //
            cg.ReturnTemporaryLocal(tmp);
        }

        TypeSymbol IVariableReference.EmitLoadValue(CodeGenerator cg, ref LhsStack lhsStack, BoundAccess access)
        {
            throw new InvalidOperationException("list() as R-Value at " + ExceptionUtilities.GuessSourceLocation(cg, this));
        }

        TypeSymbol IVariableReference.EmitLoadAddress(CodeGenerator cg, ref LhsStack lhsStack)
        {
            throw new InvalidOperationException("list() as R-Value at " + ExceptionUtilities.GuessSourceLocation(cg, this));
        }

        #endregion
    }

    partial class BoundFieldRef
    {
        internal IVariableReference BoundReference { get; set; }

        internal override IVariableReference BindPlace(CodeGenerator cg) => BoundReference;

        internal override IPlace Place() => BoundReference?.Place;
    }

    partial class BoundRoutineCall
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            EmitBeforeCall(cg);

            if (TargetMethod.IsValidMethod())
            {
                Debug.Assert(!TargetMethod.IsUnreachable);
                // the most preferred case when method is known,
                // the method can be called directly
                return EmitDirectCall(cg, IsVirtualCall ? ILOpCode.Callvirt : ILOpCode.Call, TargetMethod, (BoundTypeRef)LateStaticTypeRef);
            }
            else if (TargetMethod is MagicCallMethodSymbol magic && !this.HasArgumentsUnpacking)
            {
                return EmitMagicCall(cg, magic.OriginalMethodName, magic.RealMethod, (BoundTypeRef)LateStaticTypeRef);
            }
            else
            {
                //
                return EmitDynamicCall(cg);
            }
        }

        internal virtual void EmitBeforeCall(CodeGenerator cg)
        {

        }

        /// <summary>
        /// Emits the routine call in case the method symbol couldn't be resolved or it cannot be called directly.
        /// </summary>
        internal virtual TypeSymbol EmitDynamicCall(CodeGenerator cg)
        {
            return EmitCallsiteCall(cg);
        }

        internal TypeSymbol EmitDirectCall(CodeGenerator cg, ILOpCode opcode, MethodSymbol method, BoundTypeRef staticType = null)
        {
            // TODO: in case of a global user routine -> emit check the function is declared
            // <ctx>.AssertFunctionDeclared

            var stacktype = this.HasArgumentsUnpacking
                ? cg.EmitCall_UnpackingArgs(opcode, method, this.Instance, _arguments, staticType)  // call method with respect to argument unpacking
                : cg.EmitCall(opcode, method, this.Instance, _arguments, staticType);               // call method and pass provided arguments as they are

            //
            return (this.ResultType = cg.EmitMethodAccess(stacktype, method, Access));
        }

        /// <summary>
        /// Determines if the target magic method will be called using standard calling convention.
        /// </summary>
        static bool IsClrMagicCall(MethodSymbol method)
        {
            if (method.ContainingType.IsPhpType())
            {
                // defined in PHP source, use PHP calling convention
                return false;
            }

            var parameters = method.Parameters;
            if (parameters.Last().IsParams)
            {
                return true;
            }

            //var nimplicit = parameters.TakeWhile(p => p.IsImplicitlyDeclared).Count();

            //var actualparameters = parameters.Length - nimplicit;
            //if (actualparameters != 2)
            //{
            //    return true;
            //}

            //if (!parameters.Last().Type.Is_PhpArray() &&
            //    !parameters.Last().Type.Is_PhpValue())
            //{
            //    return true;
            //}

            // regular PHP semantic:
            // __call(name, PhpArray arguments)
            return false;
        }

        internal TypeSymbol EmitMagicCall(CodeGenerator cg, string originalMethodName, MethodSymbol method, BoundTypeRef staticType = null)
        {
            // call to __callStatic() or __call()
            Debug.Assert(
                string.Equals(method.Name, Name.SpecialMethodNames.Call.Value, StringComparison.OrdinalIgnoreCase) ||
                string.Equals(method.Name, Name.SpecialMethodNames.CallStatic.Value, StringComparison.OrdinalIgnoreCase));

            if (this.HasArgumentsUnpacking)
            {
                throw cg.NotImplementedException("__callStatic() with Arguments Unpacking", this);
            }

            ImmutableArray<BoundArgument> realArguments;

            var boundname = BoundArgument.Create(new BoundLiteral(originalMethodName).WithAccess(BoundAccess.Read));

            if (IsClrMagicCall(method))
            {
                // method is CLR method with params => don't pack arguments into phparray and call method normally
                // first argument is the method name:
                realArguments = _arguments.Insert(0, boundname);
            }
            else
            {
                // PHP behavior
                realArguments = ImmutableArray.Create(
                    // $name: string
                    boundname,
                    // $arguments: PhpArray
                    BoundArgument.Create(
                        new BoundArrayEx(
                            _arguments.Select(
                                arg => new KeyValuePair<BoundExpression, BoundExpression>(null, arg.Value)
                            ).ToImmutableArray())
                        .WithAccess(BoundAccess.Read))
                    );
            }

            //
            var opcode = (method.IsVirtual || IsVirtualCall) ? ILOpCode.Callvirt : ILOpCode.Call;

            //
            var stackType = cg.EmitCall(opcode, method, this.Instance, realArguments, staticType);

            return cg.EmitMethodAccess(stackType, method, Access);
        }

        protected virtual bool IsVirtualCall => true;

        /// <summary>Type reference to the static type. The containing type of called routine, e.g. <c>THE_TYPE::foo()</c>. Used for direct method call requiring late static type..</summary>
        protected virtual IBoundTypeRef LateStaticTypeRef => null;

        #region Emit CallSite

        protected virtual bool CallsiteRequiresCallerContext => false;
        protected virtual string CallsiteName => null;
        protected virtual BoundExpression RoutineNameExpr => null;
        protected virtual IBoundTypeRef RoutineTypeRef => null;

        /// <summary>
        /// Optional. Emits instance on which the method is invoked.
        /// In case of instance function call, it is the instance expression,
        /// in case of static method, it is reference to <c>$this</c> which may be needed in some cases.
        /// </summary>
        /// <returns>Type left on stack. Can be <c>null</c> if callsite does not expect a target.</returns>
        internal virtual TypeSymbol EmitTarget(CodeGenerator cg)
        {
            if (Instance != null)
            {
                return cg.Emit(Instance);
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Emits <c>System.Type[]</c> of type arguments.
        /// </summary>
        internal TypeSymbol EmitTypeArgumentsArray(CodeGenerator cg)
        {
            var system_type = cg.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Type);

            if (this.TypeArguments.IsDefaultOrEmpty)
            {
                // most common case
                return cg.Emit_EmptyArray(system_type);
            }
            else
            {
                return cg.Emit_NewArray(
                    system_type,
                    this.TypeArguments,
                    tref =>
                    {
                        var t = (BoundTypeRef)tref;
                        if (t.ResolvedType.IsErrorTypeOrNull())
                        {
                            throw ExceptionUtilities.NotImplementedException(cg, "type argument has not been resolved", this);
                        }

                        return cg.EmitSystemType(t.ResolvedType);
                    });
            }
        }

        internal TypeSymbol EmitCallsiteCall(CodeGenerator cg)
        {
            // callsite

            var callsite = cg.Factory.StartCallSite("call_" + this.CallsiteName);

            // LOAD callsite.Target
            callsite.EmitLoadTarget();

            // LOAD callsite arguments

            // (callsite, ctx, [target], [name], ...)
            callsite.EmitLoadCallsite();                // callsite
            callsite.EmitTargetInstance(EmitTarget);    // [target]
            callsite.EmitTargetTypeParam(RoutineTypeRef);// [target_type] : PhpTypeInfo
            callsite.EmitLateStaticTypeParam(LateStaticTypeRef);    // [late_static] : PhpTypeInfo
            callsite.EmitNameParam(RoutineNameExpr);    // [name] : string
            callsite.EmitLoadContext();                 // ctx : Context

            if (this.TypeArguments.IsDefaultOrEmpty == false)
            {
                callsite.AddArg(EmitTypeArgumentsArray(cg), false); // typeargs : System.Type[]
            }

            if (CallsiteRequiresCallerContext)
            {
                callsite.EmitCallerTypeParam();         // [class_ctx] : RuntimeTypeHandle
            }

            callsite.EmitArgs(_arguments);              // ...

            // RETURN TYPE:
            var return_type = this.Access.IsRead
                    ? this.Access.IsReadRef ? cg.CoreTypes.PhpAlias.Symbol
                    : this.Access.EnsureArray ? cg.CoreTypes.IPhpArray.Symbol
                    : this.Access.EnsureObject ? cg.CoreTypes.Object.Symbol
                    : (this.Access.TargetType ?? cg.CoreTypes.PhpValue.Symbol)
                : cg.CoreTypes.Void.Symbol;

            // Target()
            var functype = cg.Factory.GetCallSiteDelegateType(
                null, RefKind.None,
                callsite.Arguments,
                callsite.ArgumentsRefKinds,
                null,
                return_type);

            cg.EmitCall(ILOpCode.Callvirt, functype.DelegateInvokeMethod);

            // Create CallSite ...
            callsite.Construct(functype, cctor_cg => BuildCallsiteCreate(cctor_cg, return_type));

            //
            return return_type;
        }

        internal virtual void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype) { throw new InvalidOperationException(); }

        #endregion
    }

    partial class BoundGlobalFunctionCall
    {
        protected override string CallsiteName => _name.IsDirect ? _name.NameValue.ToString() : null;
        protected override BoundExpression RoutineNameExpr => _name.NameExpression;
        protected override bool IsVirtualCall => false;

        internal override TypeSymbol EmitDynamicCall(CodeGenerator cg)
        {
            if (_name.IsDirect)
            {
                return EmitCallsiteCall(cg);
            }
            else
            {
                Debug.Assert(_name.NameExpression != null);

                // better to use PhpCallback.Invoke instead of call sites

                // Template: NameExpression.AsCallback().Invoke(Context, PhpValue[])

                cg.EmitConvert(_name.NameExpression, cg.CoreTypes.IPhpCallable);    // (IPhpCallable)Name
                cg.EmitLoadContext();       // Context
                cg.Emit_ArgumentsIntoArray(_arguments, default(PhpSignatureMask)); // PhpValue[]

                return cg.EmitMethodAccess(
                    stack: cg.EmitCall(ILOpCode.Callvirt, cg.CoreTypes.IPhpCallable.Symbol.LookupMember<MethodSymbol>("Invoke")),
                    method: null,
                    access: this.Access);
            }
        }

        internal override void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype)
        {
            cg.Builder.EmitStringConstant(CallsiteName);    // function name
            cg.Builder.EmitStringConstant(_nameOpt.HasValue ? _nameOpt.Value.ToString() : null);    // fallback function name
            cg.EmitLoadToken(returntype, null);             // return type
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Dynamic.BinderFactory_Function);
        }
    }

    partial class BoundInstanceFunctionCall
    {
        protected override bool CallsiteRequiresCallerContext => true;
        protected override string CallsiteName => _name.IsDirect ? _name.NameValue.ToString() : null;
        protected override BoundExpression RoutineNameExpr => _name.NameExpression;

        internal override void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype)
        {
            cg.Builder.EmitStringConstant(CallsiteName);        // name
            cg.EmitLoadToken(cg.CallerType, null);              // class context
            cg.EmitLoadToken(returntype, null);                 // return type
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Dynamic.BinderFactory_InstanceFunction);
        }
    }

    partial class BoundStaticFunctionCall
    {
        protected override bool CallsiteRequiresCallerContext => true;
        protected override string CallsiteName => _name.IsDirect ? _name.NameValue.ToString() : null;
        protected override BoundExpression RoutineNameExpr => _name.NameExpression;
        protected override IBoundTypeRef RoutineTypeRef => _typeRef.ResolvedType.IsErrorTypeOrNull() ? _typeRef : null;    // in case the type has to be resolved in runtime and passed to callsite
        protected override IBoundTypeRef LateStaticTypeRef => _typeRef;  // used for direct routine call requiring late static type
        protected override bool IsVirtualCall => false;

        /// <summary>
        /// Emits current class instance, expected by callsite to resolve instance function called statically.
        /// </summary>
        internal override TypeSymbol EmitTarget(CodeGenerator cg)
        {
            return cg.EmitPhpThisOrNull();
        }

        internal override void BuildCallsiteCreate(CodeGenerator cg, TypeSymbol returntype)
        {
            cg.EmitLoadToken(_typeRef.ResolvedType, null);      // type
            cg.Builder.EmitStringConstant(CallsiteName);        // name
            cg.EmitLoadToken(cg.CallerType, null);              // class context
            cg.EmitLoadToken(returntype, null);                 // return type
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Dynamic.BinderFactory_StaticFunction);
        }

        internal override void EmitBeforeCall(CodeGenerator cg)
        {
            // ensure type is declared
            if (_typeRef.ResolvedType.IsValidType())
            {
                cg.EmitExpectTypeDeclared(_typeRef.ResolvedType);
            }
        }
    }

    partial class BoundNewEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var t = EmitNewClass(cg);

            // void
            if (Access.IsNone)
            {
                cg.EmitPop(t);
                return cg.CoreTypes.Void;
            }

            // &new // deprecated
            if (Access.IsReadRef)
            {
                // new PhpAlias(PhpValue.FromClass(.newobj))
                cg.EmitConvertToPhpValue(t, 0);
                return cg.Emit_PhpValue_MakeAlias();
            }

            //
            Debug.Assert(Access.IsRead);
            return t;
        }

        private TypeSymbol EmitNewClass(CodeGenerator cg)
        {
            if (!TargetMethod.IsErrorMethodOrNull())
            {
                // when instantiating anonoymous class
                // it has to be declared into the context (right before instantiation)
                if (TargetMethod.ContainingType.IsAnonymousType)
                {
                    // <ctx>.DeclareType<T>()
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Context.DeclareType_T.Symbol.Construct(TargetMethod.ContainingType)).Expect(SpecialType.System_Void);
                }
                else
                {
                    // ensure type is declared
                    cg.EmitExpectTypeDeclared(TargetMethod.ContainingType);
                }

                // Template: new T(args)
                return EmitDirectCall(cg, ILOpCode.Newobj, TargetMethod);
            }
            else
            {
                if (((BoundTypeRef)_typeref).ResolvedType.IsValidType())
                {
                    // ensure type is delcared
                    cg.EmitExpectTypeDeclared(_typeref.Type);

                    // context.Create<T>(caller, params)
                    var create_t = cg.CoreTypes.Context.Symbol.GetMembers("Create")
                        .OfType<MethodSymbol>()
                        .Single(s => s.Arity == 1 && s.ParameterCount == 2 &&
                            s.Parameters[1].IsParams &&
                            SpecialParameterSymbol.IsCallerClassParameter(s.Parameters[0]))
                        .Construct(_typeref.Type);

                    cg.EmitLoadContext();               // Context
                    cg.EmitCallerTypeHandle();          // RuntimeTypeHandle
                    cg.Emit_ArgumentsIntoArray(_arguments, default);  // PhpValue[]

                    return cg.EmitCall(ILOpCode.Call, create_t);
                }
                else
                {
                    // ctx.Create(caller, PhpTypeInfo, params)
                    var create = cg.CoreTypes.Context.Symbol.GetMembers("Create")
                        .OfType<MethodSymbol>()
                        .Single(s => s.Arity == 0 && s.ParameterCount == 3 &&
                            s.Parameters[1].Type == cg.CoreTypes.PhpTypeInfo &&
                            s.Parameters[2].IsParams && ((ArrayTypeSymbol)s.Parameters[2].Type).ElementType == cg.CoreTypes.PhpValue &&
                            SpecialParameterSymbol.IsCallerClassParameter(s.Parameters[0]))
;

                    cg.EmitLoadContext();               // Context
                    cg.EmitCallerTypeHandle();          // RuntimeTypeHandle
                    _typeref.EmitLoadTypeInfo(cg, true);// PhpTypeInfo
                    cg.Emit_ArgumentsIntoArray(_arguments, default);  // PhpValue[]

                    return cg.EmitCall(ILOpCode.Call, create);
                }
            }
        }
    }

    partial class BoundThrowExpression
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            cg.EmitConvert(Thrown, cg.CoreTypes.Exception);

            // throw <stack>;
            cg.Builder.EmitThrow(false);

            // push a default value (void)
            // stack is adjusted by caller if necessary
            return cg.CoreTypes.Void;
        }
    }

    partial class BoundEcho
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsNone);

            var args = ArgumentsInSourceOrder;
            for (int i = 0; i < args.Length; i++)
            {
                cg.EmitEcho(args[i].Value);
            }

            return cg.CoreTypes.Void;
        }
    }

    partial class BoundConcatEx
    {
        static SpecialMember? TryResolveConcatMethod(int stringargs) => stringargs switch
        {
            2 => (SpecialMember?)SpecialMember.System_String__ConcatStringString,
            3 => SpecialMember.System_String__ConcatStringStringString,
            4 => SpecialMember.System_String__ConcatStringStringStringString,
            _ => null,
        };

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var args = this.ArgumentsInSourceOrder;

            if (args.Length == 0)
            {
                // ""
                cg.Builder.EmitStringConstant(string.Empty);
                return cg.CoreTypes.String;
            }

            if (cg.IsReadonlyStringOnly(this.TypeRefMask) || this.Access.TargetType == cg.CoreTypes.String)
            {
                // the expression is annotated as it returns "System.String",
                // all its arguments are UTF16 values
                // perform standard System.String.Concat():

                var concat_method = TryResolveConcatMethod(args.Length);
                if (concat_method.HasValue)
                {
                    // Template: System.String.Concat( ... )
                    foreach (var x in args)
                    {
                        cg.EmitConvert(x.Value, cg.CoreTypes.String);
                    }

                    // String.Concat( (string)0, (string)1, ... );
                    return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(concat_method.Value))
                        .Expect(SpecialType.System_String);
                }
                else if (args.Length == 1)
                {
                    // Template: (string)arg[0]
                    cg.EmitConvert(args[0].Value, cg.CoreTypes.String);
                    return cg.CoreTypes.String;
                }
                else
                {
                    // Template: String.Concat( new []{ ... } )
                    cg.Emit_NewArray(cg.CoreTypes.String, args);
                    return cg.EmitCall(ILOpCode.Call, (MethodSymbol)cg.DeclaringCompilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringArray))
                        .Expect(SpecialType.System_String);
                }
            }

            // returning PhpString:

            if (args.Length == 1)
            {
                // Template: (PhpString)args[0]
                cg.EmitConvert(args[0].Value, cg.CoreTypes.PhpString);
                return cg.CoreTypes.PhpString;
            }

            // Template: new PhpString( new PhpString.Blob() { a1, a2, ..., aN } )

            // new PhpString.Blob()
            cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.Blob);

            // TODO: overload for 2, 3, 4 parameters directly

            // <PhpString>.Append(<expr>)
            foreach (var x in args)
            {
                var expr = x.Value;
                if (IsEmpty(expr))
                {
                    continue;
                }

                //
                cg.Builder.EmitOpCode(ILOpCode.Dup);    // <Blob>
                cg.Emit_PhpStringBlob_Append(expr);     // .Append( ... )
            }

            // new PhpString( <Blob> )
            return cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpString_Blob)
                .Expect(cg.CoreTypes.PhpString);
        }

        static bool IsEmpty(BoundExpression x) => x.ConstantValue.HasValue && ExpressionsExtension.IsEmptyStringValue(x.ConstantValue.Value);
    }

    partial class BoundIncludeEx
    {
        /// <summary>
        /// True for <c>include_once</c> or <c>require_once</c>.
        /// </summary>
        public bool IsOnceSemantic => this.InclusionType == InclusionTypes.IncludeOnce || this.InclusionType == InclusionTypes.RequireOnce;

        /// <summary>
        /// True for <c>require</c> or <c>require_once</c>.
        /// </summary>
        public bool IsRequireSemantic => this.InclusionType == InclusionTypes.Require || this.InclusionType == InclusionTypes.RequireOnce;

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            TypeSymbol result;
            var isvoid = this.Access.IsNone;

            Debug.Assert(_arguments.Length == 1);
            Debug.Assert(_arguments[0].Value.Access.IsRead);
            Debug.Assert(Access.IsRead || Access.IsNone);

            var method = this.TargetMethod;
            if (method != null) // => IsResolved
            {
                // emit condition for include_once/require_once
                if (IsOnceSemantic)
                {
                    var tscript = method.ContainingType;

                    result = isvoid
                        ? cg.CoreTypes.Void.Symbol
                        : cg.DeclaringCompilation.GetTypeFromTypeRef(cg.Routine.TypeRefContext, this.TypeRefMask);

                    // Template: (<ctx>.CheckIncludeOnce<TScript>()) ? <Main>() : TRUE
                    // Template<isvoid>: if (<ctx>.CheckIncludeOnce<TScript>()) <Main>()
                    var falseLabel = new object();
                    var endLabel = new object();

                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.CheckIncludeOnce_TScript.Symbol.Construct(tscript));

                    cg.Builder.EmitBranch(ILOpCode.Brfalse, falseLabel);

                    // ? (PhpValue)<Main>(...)
                    cg.EmitCallMain(method);
                    if (isvoid)
                    {
                        cg.EmitPop(method.ReturnType);
                    }
                    else
                    {
                        cg.EmitConvert(method.ReturnType, 0, result);
                    }
                    cg.Builder.EmitBranch(ILOpCode.Br, endLabel);

                    if (!isvoid)
                    {
                        cg.Builder.AdjustStack(-1);
                    }

                    // : PhpValue.Create(true)
                    cg.Builder.MarkLabel(falseLabel);
                    if (!isvoid)
                    {
                        cg.Builder.EmitBoolConstant(true);
                        cg.EmitConvert(cg.CoreTypes.Boolean, 0, result);
                    }

                    //
                    cg.Builder.MarkLabel(endLabel);
                }
                else
                {
                    // <Main>
                    result = cg.EmitCallMain(method);
                }
            }
            else
            {
                Debug.Assert(cg.LocalsPlaceOpt != null);

                // Template: <ctx>.Include(dir, path, locals, @this, self, bool once = false, bool throwOnError = false)
                cg.EmitLoadContext();
                cg.Builder.EmitStringConstant(cg.ContainingFile.DirectoryRelativePath);
                cg.EmitConvert(_arguments[0].Value, cg.CoreTypes.String);
                cg.LocalsPlaceOpt.EmitLoad(cg.Builder); // scope of local variables, corresponds to $GLOBALS in global scope.
                cg.EmitThisOrNull();    // $this
                cg.EmitCallerTypeHandle();    // self : RuntimeTypeHandle
                cg.Builder.EmitBoolConstant(IsOnceSemantic);
                cg.Builder.EmitBoolConstant(IsRequireSemantic);
                return cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.Include_string_string_PhpArray_object_RuntimeTypeHandle_bool_bool);
            }

            //
            return result;
        }
    }

    partial class BoundLambda
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            if (this.BoundLambdaMethod == null)
            {
                throw new InvalidOperationException();
            }

            // Template: BuildClosure(ctx, BoundLambdaMethod.EnsureRoutineInfoField(), this, scope, statictype, [use1, use2, ...], [p1, p2, ...])

            var idxfld = this.BoundLambdaMethod.EnsureRoutineInfoField(cg.Module);

            cg.EmitLoadContext();           // Context
            idxfld.EmitLoad(cg);            // routine
            EmitThis(cg);                   // $this
            cg.EmitCallerTypeHandle();      // scope
            EmitStaticType(cg);             // statictype : PhpTypeInfo
            EmitParametersArray(cg);        // "parameters"
            EmitUseArray(cg);               // "static"

            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BuildClosure_Context_IPhpCallable_Object_RuntimeTypeHandle_PhpTypeInfo_PhpArray_PhpArray);
        }

        void EmitThis(CodeGenerator cg)
        {
            cg.EmitPhpThisOrNull();
        }

        void EmitStaticType(CodeGenerator cg)
        {
            if ((cg.Routine.Flags & FlowAnalysis.RoutineFlags.UsesLateStatic) != 0)
            {
                cg.EmitLoadStaticPhpTypeInfo();
            }
            else
            {
                cg.Builder.EmitNullConstant();
            }
        }

        void EmitUseArray(CodeGenerator cg)
        {
            if (UseVars.Length != 0)
            {
                // new PhpArray(<count>)
                cg.Builder.EmitIntConstant(UseVars.Length);
                cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray_int);

                // uses
                foreach (var u in UseVars)
                {
                    // <stack>.SetItemValue|SetItemAlias(name, value)
                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.EmitIntStringKey(u.Parameter.Name);

                    if (u.Value.Access.IsReadRef)
                    {
                        // PhpValue.Create( PhpAlias )
                        cg.Emit(u.Value).Expect(cg.CoreTypes.PhpAlias); // PhpAlias
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Create_PhpAlias);    // PhpValue.Create
                    }
                    else
                    {
                        // PhpValue
                        cg.EmitConvert(u.Value, cg.CoreTypes.PhpValue);
                    }

                    // Add(name, value)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_IntStringKey_PhpValue);
                }
            }
            else
            {
                cg.Emit_PhpArray_Empty();
            }
        }

        void EmitParametersArray(CodeGenerator cg)
        {
            var ps = ((LambdaFunctionExpr)PhpSyntax).Signature.FormalParams;
            if (ps != null && ps.Length != 0)
            {
                // TODO: cache singleton

                // new PhpArray(<count>){ ... }
                cg.Builder.EmitIntConstant(ps.Length);
                cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray_int);

                foreach (var p in ps)
                {
                    var keyname = "$" + p.Name.Name.Value;
                    if (p.PassedByRef) keyname = "&" + keyname;
                    var value = (p.InitValue != null) ? "<optional>" : "<required>";

                    // <stack>.SetItemValue("&$name", "<optional>"|"<required>")
                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.EmitIntStringKey(keyname);
                    cg.Builder.EmitStringConstant(value);
                    cg.EmitConvertToPhpValue(cg.CoreTypes.String, 0);
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_IntStringKey_PhpValue);
                }
            }
            else
            {
                // PhpArray.Empty
                cg.Emit_PhpArray_Empty();
            }
        }
    }

    partial class BoundEvalEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(cg.LocalsPlaceOpt != null);

            // get location of evaluated code
            var filepath = cg.ContainingFile.RelativeFilePath;
            int line, col;
            var unit = this.PhpSyntax.ContainingSourceUnit;
            unit.GetLineColumnFromPosition(this.CodeExpression.PhpSyntax.Span.Start, out line, out col);

            // Template: Operators.Eval(ctx, locals, @this, self, code, currentpath, line, column)
            cg.EmitLoadContext();
            cg.LocalsPlaceOpt.EmitLoad(cg.Builder);
            cg.EmitThisOrNull();
            cg.EmitCallerTypeHandle();           // self : RuntimeTypeHandle
            cg.EmitConvert(this.CodeExpression, cg.CoreTypes.String);   // (string)code
            cg.Builder.EmitStringConstant(filepath);    // currentpath
            cg.Builder.EmitIntConstant(line);           // line
            cg.Builder.EmitIntConstant(col);            // column

            // Eval( ... )
            return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Eval_Context_PhpArray_object_RuntimeTypeHandle_string_string_int_int);
        }
    }

    partial class BoundExitEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            MethodSymbol ctorsymbol;

            if (_arguments.Length == 0)
            {
                // <ctx>.Exit();
                ctorsymbol = cg.CoreMethods.Ctors.ScriptDiedException;
            }
            else
            {
                // LOAD <status>
                var t = cg.Emit(_arguments[0].Value);

                switch (t.SpecialType)
                {
                    case SpecialType.System_Int32:
                        cg.Builder.EmitOpCode(ILOpCode.Conv_i8);    // i4 -> i8
                        goto case SpecialType.System_Int64;

                    case SpecialType.System_Int64:
                        ctorsymbol = cg.CoreMethods.Ctors.ScriptDiedException_Long;
                        break;

                    default:
                        cg.EmitConvertToPhpValue(t, 0);
                        ctorsymbol = cg.CoreMethods.Ctors.ScriptDiedException_PhpValue;
                        break;
                }
            }

            //
            cg.EmitCall(ILOpCode.Newobj, ctorsymbol);
            cg.Builder.EmitThrow(false);

            //
            return cg.CoreTypes.Void;
        }
    }

    partial class BoundAssertEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var args = ArgumentsInSourceOrder;
            if (args.Length == 0 ||
                args[0].Value.ConstantValue.EqualsOptional(true.AsOptional()) ||    // ignoring assertion evaluated to true
                cg.IsReadonlyStringOnly(args[0].Value.TypeRefMask))                 // ignoring string assertions
            {
                if (Access.IsNone)
                {
                    // emit nothing
                    return cg.CoreTypes.Void;
                }

                // always passing
                cg.Builder.EmitBoolConstant(true);
            }
            else
            {
                // Template: <ctx>.Assert( condition.ToBoolean(), action )
                cg.EmitLoadContext();

                cg.EmitConvertToBool(args[0].Value);

                if (args.Length > 1)
                {
                    cg.EmitConvertToPhpValue(args[1].Value);
                }
                else
                {
                    cg.Emit_PhpValue_Void();
                }

                // 
                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.Assert_bool_PhpValue)
                    .Expect(SpecialType.System_Boolean);
            }

            //
            return cg.CoreTypes.Boolean;
        }
    }

    partial class BoundAssignEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var target_place = this.Target.BindPlace(cg);

            Debug.Assert(target_place != null);
            Debug.Assert(target_place.Type == null || target_place.Type.SpecialType != SpecialType.System_Void);

            // T tmp; // in case access is Read
            LocalDefinition tmp = null;

            // <target> = <value>
            var lhs = target_place.EmitStorePreamble(cg, Target.TargetAccess());

            var t_value = target_place.Type;
            if (t_value != null &&
                t_value != cg.CoreTypes.PhpValue &&
                t_value != cg.CoreTypes.PhpAlias &&
                !Value.Access.IsReadRef &&
                Access.IsNone)
            {
                // we can convert more efficiently here
                cg.EmitConvert(Value, t_value);
            }
            else
            {
                t_value = cg.Emit(Value);
            }

            if (t_value.SpecialType == SpecialType.System_Void)
            {
                // default<T>
                t_value = target_place.Type ?? cg.CoreTypes.PhpValue; // T of PhpValue
                cg.EmitLoadDefault(t_value, 0);
            }

            //
            if (Access.IsNone)
            {
                // nothing
            }
            else if (Access.IsRead)
            {
                tmp = cg.GetTemporaryLocal(t_value, false);
                cg.Builder.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tmp);
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(Access);
            }

            target_place.EmitStore(cg, ref lhs, t_value, Target.Access);

            lhs.Dispose();

            //
            if (Access.IsNone)
            {
                t_value = cg.CoreTypes.Void;
            }
            else if (Access.IsRead)
            {
                Debug.Assert(tmp != null);
                cg.Builder.EmitLocalLoad(tmp);
            }

            if (tmp != null)
            {
                cg.ReturnTemporaryLocal(tmp);
            }

            //
            return t_value;
        }
    }

    partial class BoundCompoundAssignEx
    {
        /// <summary>
        /// Searches for an occurance of <see cref="SearchForTargetVisitor._target"/>.
        /// </summary>
        class SearchForTargetVisitor : Graph.GraphWalker<VoidStruct>
        {
            readonly BoundReferenceExpression/*!*/_target;

            public bool Found { get; private set; }

            public SearchForTargetVisitor(BoundReferenceExpression target)
            {
                _target = target ?? throw ExceptionUtilities.ArgumentNull();
            }

            public override VoidStruct VisitVariableName(BoundVariableName x)
            {
                if (_target is BoundVariableRef v)
                {
                    Found |= !v.Name.IsDirect || !x.IsDirect || v.Name.NameValue == x.NameValue;
                }

                return default;
            }
        }

        /// <summary>
        /// Determines if <paramref name="target"/> is not referenced within <paramref name="rvalue"/>.
        /// </summary>
        static bool IsSafeToUnroll(BoundReferenceExpression target, BoundExpression rvalue)
        {
            if (rvalue.IsConstant() || rvalue is BoundGlobalConst || rvalue is BoundPseudoConst || (rvalue is BoundFieldRef f && f.IsClassConstant))
            {
                return true;
            }

            var visitor = new SearchForTargetVisitor(target);
            rvalue.Accept(visitor);
            return visitor.Found != true;
        }

        static TypeSymbol EmitAppend(CodeGenerator cg, BoundReferenceExpression target, BoundExpression rvalue, BoundAccess access)
        {
            var target_place = target.BindPlace(cg);

            bool inplace = false;
            var lhs = default(LhsStack);

            if (target_place.HasAddress && target_place.Type != null)
            {
                // we can perform in-place concatenation

                if (target_place.Type == cg.CoreTypes.PhpValue)
                {
                    // Template: Operators.EnsureWritableString(ref PhpValue target).Add( .. )
                    inplace = true;
                    target_place.EmitLoadAddress(cg, ref lhs);  // ref PhpValue
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureWritableString_PhpArrayRef)
                        .Expect(cg.CoreTypes.PhpString_Blob);
                }
                else if (target_place.Type == cg.CoreTypes.PhpAlias)
                {
                    // Template: target.Alias.EnsureWritableString().Add( .. )
                    inplace = true;
                    target_place.EmitLoadValue(cg, ref lhs, target.Access);
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.PhpAlias.EnsureWritableString)
                        .Expect(cg.CoreTypes.PhpString_Blob);
                }
                else if (target_place.Type == cg.CoreTypes.PhpString)
                {
                    // Template: (target : PhpString).EnsureWritable().Add( .. )
                    inplace = true;
                    target_place.EmitLoadAddress(cg, ref lhs);  // : ref PhpString
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.EnsureWritable)
                        .Expect(cg.CoreTypes.PhpString_Blob);
                }
            }

            //

            if (inplace)
            {
                lhs.Dispose();
            }
            else
            {
                // Template: PhpString.AsWritable( ((PhpString)target) ) : Blob
                lhs = target_place.EmitStorePreamble(cg, target.TargetAccess());
                cg.EmitConvertToPhpString(target_place.EmitLoadValue(cg, ref lhs, target.Access), 0);
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.AsWritable_PhpString) // Blob
                    .Expect(cg.CoreTypes.PhpString_Blob);
            }

            // STACK: PhpString.Blob

            // Template: .Add( rValue )

            if (access.IsRead || !inplace)
            {
                cg.Builder.EmitOpCode(ILOpCode.Dup);    // 
            }

            // check rValue does not contain lValue!
            // if {rvalue} references {target}, we cannot unroll concat expression

            cg.Emit_PhpStringBlob_Append(rvalue, expandConcat: IsSafeToUnroll(target, rvalue));

            // STACK: 'void' or 'PhpString.Blob'

            if (access.IsRead || !inplace)
            {
                // STACK: PhpString.Blob

                // Template: new PhpString(blob)
                var result_type = cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpString_Blob)
                    .Expect(cg.CoreTypes.PhpString);

                // STACK: PhpString

                LocalDefinition tmp = null;

                if (access.IsRead)
                {
                    tmp = cg.GetTemporaryLocal(result_type, false);
                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.Builder.EmitLocalStore(tmp);
                }

                if (!inplace)
                {
                    target_place.EmitStore(cg, ref lhs, result_type, target.Access);
                    lhs.Dispose();
                }
                else
                {
                    cg.Builder.EmitOpCode(ILOpCode.Pop);
                }

                // STACK: void

                if (access.IsRead)
                {
                    Debug.Assert(tmp != null);
                    cg.Builder.EmitLoad(tmp);
                    cg.ReturnTemporaryLocal(tmp);
                    return result_type;
                }
            }

            // STACK: void

            if (access.IsNone)
            {
                return cg.CoreTypes.Void;
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(access);
            }
        }

        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsRead || Access.IsNone);

            // target X= value;

            if (this.Operation == Operations.AssignAppend)
            {
                return EmitAppend(cg, this.Target, this.Value, this.Access);
            }

            var target_place = this.Target.BindPlace(cg);
            Debug.Assert(target_place != null);
            Debug.Assert(target_place.Type == null || target_place.Type.SpecialType != SpecialType.System_Void);

            // <target> = <target> X <value>
            var lhs = target_place.EmitStorePreamble(cg, Target.TargetAccess());
            var xtype = target_place.EmitLoadValue(cg, ref lhs, Target.Access);

            TypeSymbol result_type;

            switch (this.Operation)
            {
                case Operations.AssignAdd:
                    result_type = BoundBinaryEx.EmitAdd(cg, xtype, Value, target_place.Type);
                    break;
                //case Operations.AssignAppend:
                //    result_type = EmitAppend(cg, xtype, Value);
                //    break;
                ////case Operations.AssignPrepend:
                ////    break;
                case Operations.AssignDiv:
                    result_type = BoundBinaryEx.EmitDiv(cg, xtype, Value, target_place.Type);
                    break;
                case Operations.AssignMod:
                    result_type = BoundBinaryEx.EmitRemainder(cg, xtype, Value);
                    break;
                case Operations.AssignMul:
                    result_type = BoundBinaryEx.EmitMul(cg, xtype, Value, target_place.Type);
                    break;
                case Operations.AssignAnd:
                    result_type = BoundBinaryEx.EmitBitAnd(cg, xtype, Value);
                    break;
                case Operations.AssignOr:
                    result_type = BoundBinaryEx.EmitBitOr(cg, xtype, Value);
                    break;
                case Operations.AssignXor:
                    result_type = BoundBinaryEx.EmitBitXor(cg, xtype, Value);
                    break;
                case Operations.AssignPow:
                    result_type = BoundBinaryEx.EmitPow(cg, xtype, /*this.Target.TypeRefMask*/0, Value);
                    break;
                case Operations.AssignShiftLeft:
                case Operations.AssignShiftRight:
                    result_type = BoundBinaryEx.EmitShift(cg, xtype, Value, this.Operation == Operations.AssignShiftLeft ? ILOpCode.Shl : ILOpCode.Shr);
                    break;
                case Operations.AssignSub:
                    result_type = BoundBinaryEx.EmitSub(cg, xtype, Value, target_place.Type);
                    break;
                case Operations.AssignCoalesce:
                    result_type = BoundBinaryEx.EmitCoalesce(cg, xtype, 0, Value);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(this.Operation);
            }

            LocalDefinition tmp = null;

            if (Access.IsRead)
            {
                tmp = cg.GetTemporaryLocal(result_type, false);
                cg.Builder.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tmp);
            }

            target_place.EmitStore(cg, ref lhs, result_type, Target.Access);
            lhs.Dispose();

            //
            if (Access.IsRead)
            {
                Debug.Assert(tmp != null);
                cg.Builder.EmitLoad(tmp);
                cg.ReturnTemporaryLocal(tmp);
                return result_type;
            }
            else if (Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(this.Access);
            }
        }
    }

    partial class BoundIncDecEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(this.Access.IsNone || Access.IsRead);
            Debug.Assert(!this.Access.IsReadRef);
            Debug.Assert(!this.Access.IsWrite);
            Debug.Assert(this.Target.Access.IsRead && this.Target.Access.IsWrite);
            Debug.Assert(this.Value.Access.IsRead);

            Debug.Assert(this.Value is BoundLiteral);

            if (this.UsesOperatorMethod)
            {
                throw new NotImplementedException();
            }

            TypeSymbol result_type = cg.CoreTypes.Void;
            LocalDefinition tempvar = null;    // temporary variable containing result of the expression if needed

            var read = this.Access.IsRead;

            var target_place = this.Target.BindPlace(cg);
            Debug.Assert(target_place != null);

            // prepare target for store operation
            var lhs = target_place.EmitStorePreamble(cg, Target.TargetAccess());

            // load target value
            var target_load_type = target_place.EmitLoadValue(cg, ref lhs, Target.Access);

            TypeSymbol op_type;

            if (read && IsPostfix)
            {
                // store value of target
                // <temp> = TARGET
                tempvar = cg.GetTemporaryLocal(target_load_type);
                cg.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tempvar);
            }

            if (IsIncrement)
            {
                op_type = BoundBinaryEx.EmitAdd(cg, target_load_type, this.Value, target_place.Type);
            }
            else
            {
                Debug.Assert(IsDecrement);
                op_type = BoundBinaryEx.EmitSub(cg, target_load_type, this.Value, target_place.Type);
            }

            if (read && IsPrefix)
            {
                // store value of result
                // <temp> = TARGET
                tempvar = cg.GetTemporaryLocal(op_type);
                cg.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(tempvar);
            }

            //
            target_place.EmitStore(cg, ref lhs, op_type, Target.Access);

            lhs.Dispose();

            if (read)
            {
                Debug.Assert(tempvar != null);

                // READ <temp>
                cg.Builder.EmitLocalLoad(tempvar);
                result_type = (TypeSymbol)tempvar.Type;

                //
                cg.ReturnTemporaryLocal(tempvar);
                tempvar = null;
            }

            //
            Debug.Assert(tempvar == null);
            Debug.Assert(!read || result_type.SpecialType != SpecialType.System_Void);

            //
            return result_type;
        }

        bool IsPrefix => !IsPostfix;
        bool IsDecrement => !this.IsIncrement;
    }

    partial class BoundConditionalEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            TypeSymbol result_type = cg.DeclaringCompilation.GetTypeFromTypeRef(cg.TypeRefContext, this.TypeRefMask);
            bool result_isvoid = result_type.SpecialType == SpecialType.System_Void;

            object trueLbl = new object();
            object endLbl = new object();

            if (this.IfTrue != null)
            {
                // !COND?T:F -> COND?F:T
                bool isnegation = this.Condition.IsLogicNegation(out var negexpr);
                var condition = isnegation ? negexpr : this.Condition;

                // Cond ? True : False
                cg.EmitConvertToBool(condition);   // i4
                cg.Builder.EmitBranch(isnegation ? ILOpCode.Brfalse : ILOpCode.Brtrue, trueLbl);

                // false:
                cg.EmitConvert(this.IfFalse, result_type);
                cg.Builder.EmitBranch(ILOpCode.Br, endLbl);
                if (!result_isvoid) cg.Builder.AdjustStack(-1);

                // trueLbl:
                cg.Builder.MarkLabel(trueLbl);
                cg.EmitConvert(this.IfTrue, result_type);

                // endLbl:
                cg.Builder.MarkLabel(endLbl);
            }
            else
            {
                // Cond ?: False

                // <stack> = <cond_var> = Cond
                var cond_type = cg.Emit(this.Condition);
                var cond_var = cg.GetTemporaryLocal(cond_type);
                cg.Builder.EmitOpCode(ILOpCode.Dup);
                cg.Builder.EmitLocalStore(cond_var);

                cg.EmitConvertToBool(cond_type, this.Condition.TypeRefMask);
                cg.Builder.EmitBranch(ILOpCode.Brtrue, trueLbl);

                // false:
                cg.EmitConvert(this.IfFalse, result_type);
                cg.Builder.EmitBranch(ILOpCode.Br, endLbl);
                if (!result_isvoid) cg.Builder.AdjustStack(-1);

                // trueLbl:
                cg.Builder.MarkLabel(trueLbl);
                cg.Builder.EmitLocalLoad(cond_var);
                cg.EmitConvert(cond_type, this.Condition.TypeRefMask, result_type);

                // endLbl:
                cg.Builder.MarkLabel(endLbl);

                //
                cg.ReturnTemporaryLocal(cond_var);
            }

            //
            if (Access.IsNone)
            {
                cg.EmitPop(result_type);
                result_type = cg.CoreTypes.Void;
            }

            //
            return result_type;
        }
    }

    partial class BoundArrayEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            if (_items.Length == 0)
            {
                if (Access.IsNone && !cg.EmitPdbSequencePoints)
                {
                    return cg.CoreTypes.Void;
                }

                // PhpArray.NewEmpty()
                return cg.Emit_PhpArray_NewEmpty();
            }
            else if (cg.IsInCachedArrayExpression || this.RequiresContext)
            {
                // new PhpArray(){ ... }
                return EmitNewPhpArray(cg);
            }
            else // array items do not need Context => they are immutable/literals
            {
                if (Access.IsNone && !cg.EmitPdbSequencePoints)
                {
                    return cg.CoreTypes.Void;
                }

                // static PhpArray field;
                // field ?? (field = new PhpArray(){ ... })
                return EmitCachedPhpArray(cg);
            }
        }

        TypeSymbol EmitNewPhpArray(CodeGenerator cg)
        {
            // new PhpArray(count)
            cg.Builder.EmitIntConstant(_items.Length);
            var result = cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray_int)
                .Expect(cg.CoreTypes.PhpArray);

            foreach (var x in _items)
            {
                // <PhpArray>
                cg.Builder.EmitOpCode(ILOpCode.Dup);

                // key
                if (x.Key != null)
                {
                    cg.EmitIntStringKey(x.Key);
                }

                // value
                Debug.Assert(x.Value != null);
                cg.EmitConvert(x.Value, cg.CoreTypes.PhpValue);

                if (x.Key != null)
                {
                    // <stack>.Add(key, value)
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_IntStringKey_PhpValue);
                }
                else
                {
                    // <stack>.Add(value) : int
                    cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                }
            }

            //
            return result;
        }

        /// <summary>
        /// Caches the array instance into an internal app-static field,
        /// so repetitious creations only uses the existing instance.
        /// </summary>
        TypeSymbol EmitCachedPhpArray(CodeGenerator cg)
        {
            Debug.Assert(cg.IsInCachedArrayExpression == false);

            // static PhpArray arr`;
            var fld = cg.Factory.CreateSynthesizedField(cg.CoreTypes.PhpArray, "<arr>", true);
            var fldplace = new FieldPlace(null, fld, cg.Module);

            // TODO: reuse existing cached PhpArray with the same content

            //
            cg.IsInCachedArrayExpression = true;

            // arr ?? (arr = new PhpArray(){...})
            fldplace.EmitLoad(cg.Builder);
            cg.EmitNullCoalescing((cg_) =>
            {
                fldplace.EmitStorePrepare(cg_.Builder);
                EmitNewPhpArray(cg_);
                cg_.Builder.EmitOpCode(ILOpCode.Dup);
                fldplace.EmitStore(cg_.Builder);
            });

            // .DeepCopy()
            // if (this.Access.IsReadCopy) // unsafe ?
            {
                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.PhpArray.DeepCopy);
            }

            //
            cg.IsInCachedArrayExpression = false;

            //
            return fld.Type;    // ~ PhpArray
        }
    }

    partial class BoundArrayItemEx : IVariableReference
    {
        internal override IVariableReference BindPlace(CodeGenerator cg) => this;

        internal override IPlace Place() => ((IVariableReference)this).Place;

        #region IBoundReference

        Symbol IVariableReference.Symbol => null;

        TypeSymbol IVariableReference.Type => DeclaringCompilation.CoreTypes.PhpValue;

        bool IVariableReference.HasAddress => false;

        IPlace IVariableReference.Place => null;    // TODO: simple array access in case Array is System.Array and Key is int|long

        #region Emitted Array Stack

        /// <summary>
        /// Stack of type of {array,index} emitted by <see cref="IVariableReference.EmitLoadValue"/> and <see cref="IVariableReference.EmitStorePreamble"/>.
        /// </summary>
        Stack<EmittedArrayInfo> _emittedArrays;

        struct EmittedArrayInfo
        {
            public TypeSymbol tArray, tIndex;
        }

        /// <summary>
        /// <see cref="IVariableReference.EmitStorePreamble"/> and <see cref="IVariableReference.EmitStorePreamble"/> remembers what was the array type it emitted.
        /// Used by <see cref="PopEmittedArray"/> and <see cref="IVariableReference.EmitLoadValue"/> or <see cref="IVariableReference.EmitStore"/> to emit specific operator.
        /// </summary>
        void PushEmittedArray(TypeSymbol tArray, TypeSymbol tIndex)
        {
            Debug.Assert(tArray != null);

            if (_emittedArrays == null)
            {
                _emittedArrays = new Stack<EmittedArrayInfo>();
            }

            _emittedArrays.Push(new EmittedArrayInfo() { tArray = tArray, tIndex = tIndex });
        }

        /// <summary>
        /// Used by <see cref="IVariableReference.EmitLoadValue"/> and <see cref="IVariableReference.EmitStore"/> to emit specific operator
        /// on a previously emitted array (<see cref="PushEmittedArray"/>).
        /// </summary>
        EmittedArrayInfo PopEmittedArray()
        {
            Debug.Assert(_emittedArrays != null && _emittedArrays.Count != 0);
            var result = _emittedArrays.Pop();
            if (_emittedArrays.Count == 0)
            {
                _emittedArrays = null;   // free
            }

            return result;
        }

        bool IndexIsSafe()
        {
            var constant = (Index != null) ? Index.ConstantValue : null;
            if (constant.HasValue)
            {
                var value = constant.Value;
                return value is long || value is int || value is string;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Emits <see cref="Index"/> either as <c>PhpValue</c> or <c>IntStringKey</c> if possible safely.
        /// If <see cref="Index"/> is a <c>null</c> reference, nothing is emitted and <c>null</c> is returned by the function.
        /// </summary>
        TypeSymbol EmitLoadIndex(CodeGenerator cg, ref LhsStack lhs, bool safeToUseIntStringKey)
        {
            TypeSymbol tIndex;

            if (this.Index != null)
            {
                if (safeToUseIntStringKey && IndexIsSafe())
                {
                    tIndex = cg.CoreTypes.IntStringKey;
                    cg.EmitIntStringKey(this.Index);
                }
                else
                {
                    tIndex = cg.CoreTypes.PhpValue;
                    cg.EmitConvert(this.Index, tIndex);
                }
            }
            else
            {
                tIndex = null;
            }

            //
            return tIndex;
        }

        #endregion

        void EmitLoadPrepare(CodeGenerator cg, ref LhsStack lhs)
        {
            // Template: array[index]

            bool safeToUseIntStringKey = false;
            bool canBeNull = true;

            //
            // LOAD Array
            //

            var tArray = lhs.EmitReceiver(cg, Array);

            // convert {t} to IPhpArray, string, System.Array

            if (tArray.IsOfType(cg.CoreTypes.IPhpArray))
            {
                // ok; PhpArray, PhpString, object implementing IPhpArray
                safeToUseIntStringKey = true;
            }
            else if (tArray == cg.CoreTypes.PhpValue)
            {
                // ok
            }
            else if (tArray == cg.CoreTypes.PhpAlias)
            {
                tArray = cg.Emit_PhpAlias_GetValue();
            }
            else if (tArray == cg.CoreTypes.String)
            {
                // ok
                safeToUseIntStringKey = true;
            }
            else if (tArray == cg.CoreTypes.PhpString)
            {
                // <PhpString>.AsArray
                tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.AsArray_PhpString);
                safeToUseIntStringKey = true;
            }
            else if (tArray == cg.CoreTypes.Void)
            {
                Debug.Fail("Use of uninitialized value.");  // TODO: Err in analysis, use of uninitialized value
            }
            else if (tArray.IsArray())   // TODO: IList, IDictionary
            {
                // ok
            }
            else if (tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                // ok
            }
            else
            {
                // object -> IPhpArray
                tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_Object);
                canBeNull = false;
            }

            if (this.Access.IsRead && this.Access.IsQuiet)  // TODO: analyse if Array can be NULL
            {
                // ?? PhpArray.Empty
                if (cg.CoreTypes.PhpArray.Symbol.IsOfType(tArray) && canBeNull)
                {
                    cg.EmitNullCoalescing((_cg) =>
                    {
                        _cg.EmitCastClass(_cg.Emit_PhpArray_Empty(), tArray);
                    });
                }
            }

            Debug.Assert(
                tArray.IsOfType(cg.CoreTypes.IPhpArray) ||
                tArray.SpecialType == SpecialType.System_String ||
                tArray.IsArray() ||
                tArray.IsOfType(cg.CoreTypes.ArrayAccess) ||
                tArray == cg.CoreTypes.PhpValue);

            //
            // LOAD [Index]
            //

            Debug.Assert(this.Index != null || this.Access.IsEnsure, "Index is required when reading the array item.");

            var tIndex = EmitLoadIndex(cg, ref lhs, safeToUseIntStringKey);

            // remember for EmitLoad
            PushEmittedArray(tArray, tIndex);
        }

        TypeSymbol IVariableReference.EmitLoadValue(CodeGenerator cg, ref LhsStack lhs, BoundAccess access)
        {
            EmitLoadPrepare(cg, ref lhs);

            // Template: array[index]

            var stack = PopEmittedArray();
            if (stack.tArray.IsOfType(cg.CoreTypes.IPhpArray))
            {
                // whether the target is instance of PhpArray, otherwise it is an IPhpArray and we have to use .callvirt and different operators
                var isphparr = (stack.tArray == cg.CoreTypes.PhpArray);

                if (this.Index == null)
                {
                    Debug.Assert(stack.tIndex == null);
                    Debug.Assert(this.Access.IsEnsure);
                    /*
                     * Template:
                     * <array>.AddValue((PhpValue)(tmp = new <T>));
                     * LOAD tmp;
                     */
                    LocalDefinition tmp;
                    if (Access.EnsureArray)
                    {
                        // tmp = new PhpArray();
                        tmp = cg.GetTemporaryLocal(cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray));
                    }
                    else if (Access.EnsureObject)
                    {
                        // tmp = new stdClass();
                        tmp = cg.GetTemporaryLocal(cg.EmitCall(ILOpCode.Newobj, cg.CoreTypes.stdClass.Ctor()));
                    }
                    else if (Access.IsReadRef)
                    {
                        // tmp = PhpAlias.Create(NULL)
                        cg.Emit_PhpValue_Null();
                        tmp = cg.GetTemporaryLocal(cg.Emit_PhpValue_MakeAlias());
                    }
                    else
                    {
                        throw ExceptionUtilities.UnexpectedValue(Access);
                    }

                    cg.Builder.EmitOpCode(ILOpCode.Dup);
                    cg.Builder.EmitLocalStore(tmp);

                    var tmp_type = (TypeSymbol)tmp.Type;
                    cg.EmitConvertToPhpValue(tmp_type, 0);

                    if (isphparr) cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                    else cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.AddValue_PhpValue);

                    //
                    cg.Builder.EmitLocalLoad(tmp);
                    cg.ReturnTemporaryLocal(tmp);
                    return tmp_type;
                }
                else if (Access.EnsureObject)
                {
                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.EnsureItemObject(<index>)
                        return isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.EnsureItemObject_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.EnsureItemObject_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // EnsureItemObject(<array>, <index>)
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemObject_IPhpArray_PhpValue);
                    }
                }
                else if (Access.EnsureArray)
                {
                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.EnsureItemArray(<index>)
                        return isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.EnsureItemArray_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.EnsureItemArray_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // EnsureItemArray(<array>, <index>)
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemArray_IPhpArray_PhpValue);
                    }
                }
                else if (Access.IsReadRef)
                {
                    Debug.Assert(this.Array.Access.EnsureArray);

                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.EnsureItemAlias(<index>)
                        return isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.EnsureItemAlias_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.EnsureItemAlias_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // EnsureItemAlias(<array>, <index>, quiet)
                        cg.Builder.EmitBoolConstant(Access.IsQuiet);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemAlias_IPhpArray_PhpValue_Bool);
                    }
                }
                else
                {
                    Debug.Assert(Access.IsRead);

                    TypeSymbol t;

                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // <array>.GetItemValue(<index>)
                        t = isphparr
                            ? cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.GetItemValue_IntStringKey)
                            : cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.GetItemValue_IntStringKey);
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // GetItemValue(<array>, <index>)
                        //cg.Builder.EmitBoolConstant(Access.IsQuiet);
                        t = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.GetItemValue_PhpValue);
                    }

                    return t;
                }
            }
            else if (stack.tArray.SpecialType == SpecialType.System_String)
            {
                if (Access.EnsureObject || Access.EnsureArray || Access.IsReadRef)
                {
                    // null
                    throw new InvalidOperationException();
                }
                else
                {
                    Debug.Assert(Access.IsRead);
                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        // GetItemValue{OrNull}(string, IntStringKey)
                        return cg.EmitCall(ILOpCode.Call, this.Access.Flags.Isset()
                            ? cg.CoreMethods.Operators.GetItemValueOrNull_String_IntStringKey   // string or null
                            : cg.CoreMethods.Operators.GetItemValue_String_IntStringKey         // string or ""
                            );
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        // GetItemValue(string, PhpValue, bool)
                        cg.Builder.EmitBoolConstant(Access.IsQuiet);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetItemValue_String_PhpValue_Bool);
                    }
                }
            }
            else if (stack.tArray == cg.CoreTypes.PhpValue)
            {
                Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);

                if (Access.EnsureObject || Access.EnsureArray)
                {
                    // null
                    throw new InvalidOperationException();
                }
                else if (Access.IsReadRef)
                {
                    Debug.WriteLine("TODO: we need reference to PhpValue so we can modify its content! This is not compatible with behavior of = &$null[0].");

                    // PhpValue.GetItemRef(index, bool)
                    cg.Builder.EmitBoolConstant(Access.IsQuiet);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureItemAlias_PhpValue_PhpValue_Bool);
                }
                else // IsRead
                {
                    Debug.Assert(Access.IsRead);
                    // PhpValue.GetItemValue(index, bool)
                    cg.Builder.EmitBoolConstant(Access.IsQuiet);
                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetItemValue_PhpValue_PhpValue_Bool);
                }
            }
            else if (stack.tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);

                // Template: ArrayAccess.offsetGet(<index>)
                var t = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetGet_ArrayAccess_PhpValue);

                if (Access.EnsureArray)
                {
                    Debug.Assert(t == cg.CoreTypes.PhpValue);
                    // Template: (ref PhpValue).EnsureArray()
                    cg.EmitPhpValueAddr();
                    t = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_PhpValueRef);
                }

                return t;
            }
            else if (stack.tArray.SpecialType == SpecialType.System_Void)
            {
                // array item on an uninitialized value
                // void[key] -> void
                cg.EmitPop(stack.tIndex);
                return cg.Emit_PhpValue_Void();
            }
            else
            {
                throw cg.NotImplementedException($"LOAD {stack.tArray.Name}[]");
            }
        }

        TypeSymbol IVariableReference.EmitLoadAddress(CodeGenerator cg, ref LhsStack lhs)
        {
            //EmitLoadPrepare(cg, ref lhs);

            //var stack = PopEmittedArray();
            //if (stack.tArray == cg.CoreTypes.PhpArray && stack.tIndex == cg.CoreTypes.IntStringKey)
            //{
            //    // STACK: <PhpArray> <key>

            //    // Template: ref PhpArray.GetItemRef(key)
            //    Debug.Assert(cg.CoreMethods.PhpArray.GetItemRef_IntStringKey.Symbol.ReturnValueIsByRef);
            //    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.GetItemRef_IntStringKey);
            //}
            //else
            //{
            //    throw new NotSupportedException();
            //    //PushEmittedArray(stack.tArray, stack.tIndex);
            //    //return null;    // TODO: IPhpArray if needed
            //}
            throw ExceptionUtilities.Unreachable;
        }

        LhsStack IVariableReference.EmitStorePreamble(CodeGenerator cg, BoundAccess access)
        {
            var lhs = new LhsStack { CodeGenerator = cg, IsEnabled = access.IsRead, };

            //Debug.Assert(this.Array.Access.EnsureArray || this.Array.Access.IsQuiet);

            // Template: array[index]

            bool safeToUseIntStringKey = false;

            //
            // ENSURE Array
            //

            var tArray = lhs.EmitReceiver(cg, Array);
            if (tArray.IsOfType(cg.CoreTypes.IPhpArray))    // PhpArray, PhpString
            {
                // ok
                safeToUseIntStringKey = true;
            }
            else if (tArray.IsOfType(cg.CoreTypes.ArrayAccess)) // ArrayAccess
            {
                // ok
            }
            else if (this.Array.Access.EnsureArray)
            {
                if (tArray == cg.CoreTypes.PhpAlias)
                {
                    // PhpAlias.EnsureArray
                    tArray = cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.PhpAlias.EnsureArray);
                }
                else
                {
                    // Array should be ensured already
                    throw cg.NotImplementedException($"(ensure) STORE {tArray.Name}[]");
                }
            }
            else if (this.Array.Access.IsQuiet)
            {
                // WRITE semantics, without need of ensuring the underlaying value
                // isempty, unset; otherwise in store operation we should EnsureArray already

                if (tArray == cg.CoreTypes.PhpAlias)
                {
                    // dereference
                    tArray = cg.Emit_PhpAlias_GetValue();
                }

                if (tArray == cg.CoreTypes.PhpValue)
                {
                    Debug.WriteLine("TODO: we need reference to PhpValue so we can modify its content! Won't work with $string[] = ...");

                    cg.EmitPhpValueAddr();

                    tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetArrayAccess_PhpValueRef)
                        .Expect(cg.CoreTypes.IPhpArray);

                    // Template: <STACK> ?? (IPhpArray)PhpArray.Empty
                    cg.EmitNullCoalescing((_cg) =>
                    {
                        _cg.EmitCastClass(_cg.Emit_PhpArray_Empty(), _cg.CoreTypes.IPhpArray);
                    });
                }
                else if (tArray == cg.CoreTypes.String)
                {
                    // Template: (PhpString)string
                    tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpString.implicit_from_string);
                }
                else if (
                    tArray == cg.CoreTypes.Void ||
                    tArray == cg.CoreTypes.Boolean ||
                    tArray == cg.CoreTypes.Long ||
                    tArray == cg.CoreTypes.Double ||
                    tArray.IsOfType(cg.CoreTypes.PhpResource))
                {
                    // TODO: WRN: use value of type '...' as array
                    cg.EmitPop(tArray);
                    tArray = cg.Emit_PhpArray_Empty();
                }
                else if (tArray.IsReferenceType)
                {
                    // null -> PhpArray.Empty
                    if (cg.CanBeNull(Array.TypeRefMask))
                    {
                        // Template: (object)<STACK> ?? PhpArray.Empty
                        cg.EmitCastClass(tArray, cg.CoreTypes.Object);
                        cg.EmitNullCoalescing((_cg) =>
                        {
                            _cg.EmitCastClass(_cg.Emit_PhpArray_Empty(), _cg.CoreTypes.Object);
                        });
                        tArray = cg.CoreTypes.Object;
                    }

                    // EnsureArray(<STACK>) or throw
                    tArray = cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.EnsureArray_Object)
                        .Expect(cg.CoreTypes.IPhpArray);
                }
                else
                {
                    throw cg.NotImplementedException($"(quiet) STORE {tArray.Name}[]");    // TODO: emit convert as PhpArray
                }
            }
            else
            {
                throw cg.NotImplementedException($"STORE {tArray.Name}[]");    // TODO: emit convert as PhpArray
            }

            Debug.Assert(tArray.IsOfType(cg.CoreTypes.IPhpArray) || tArray.IsOfType(cg.CoreTypes.ArrayAccess));

            //
            // LOAD [Index]
            //

            var tIndex = EmitLoadIndex(cg, ref lhs, safeToUseIntStringKey);

            if (tIndex == null && tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                // we need "NULL" key
                Debug.Assert(!safeToUseIntStringKey);
                tIndex = cg.Emit_PhpValue_Null();
            }

            // remember for EmitLoad
            PushEmittedArray(tArray, tIndex);

            //
            return lhs;
        }

        void IVariableReference.EmitStore(CodeGenerator cg, ref LhsStack lhs, TypeSymbol valueType, BoundAccess access)
        {
            // Template: array[index]

            var stack = PopEmittedArray();
            if (stack.tArray.IsOfType(cg.CoreTypes.IPhpArray))
            {
                // whether the target is instance of PhpArray, otherwise it is an IPhpArray and we have to use .callvirt
                var isphparr = (stack.tArray == cg.CoreTypes.PhpArray);

                if (Access.IsWriteRef)
                {
                    // PhpAlias
                    if (valueType != cg.CoreTypes.PhpAlias)
                    {
                        cg.EmitConvertToPhpValue(valueType, 0);
                        cg.Emit_PhpValue_MakeAlias();
                    }

                    // .SetItemAlias(key, alias) or .AddValue(PhpValue.Create(alias))
                    if (this.Index != null)
                    {
                        if (stack.tIndex == cg.CoreTypes.IntStringKey)
                        {
                            if (isphparr)
                                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.SetItemAlias_IntStringKey_PhpAlias);
                            else
                                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemAlias_IntStringKey_PhpAlias);
                        }
                        else
                        {
                            Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemAlias_PhpValue_PhpAlias);
                        }
                    }
                    else
                    {
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpValue.Create_PhpAlias);

                        if (isphparr)
                            cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                        else
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.AddValue_PhpValue);
                    }
                }
                else if (Access.IsUnset)
                {
                    if (this.Index == null)
                        throw new InvalidOperationException();

                    if (stack.tIndex == cg.CoreTypes.IntStringKey)
                    {
                        if (isphparr)
                        {
                            // .UnsetValue(key)
                            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.UnsetValue_IntStringKey);
                        }
                        else
                        {
                            // .RemoveKey(key)
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.RemoveKey_IntStringKey);
                        }
                    }
                    else
                    {
                        Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                        cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.RemoveKey_PhpValue);
                    }
                }
                else
                {
                    Debug.Assert(Access.IsWrite);

                    cg.EmitConvertToPhpValue(valueType, 0);

                    // .SetItemValue(key, value) or .AddValue(value)
                    if (this.Index != null)
                    {
                        if (stack.tIndex == cg.CoreTypes.IntStringKey)
                        {
                            if (isphparr)
                                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.SetItemValue_IntStringKey_PhpValue);
                            else
                                cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemValue_IntStringKey_PhpValue);
                        }
                        else
                        {
                            Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.SetItemValue_PhpValue_PhpValue);
                        }
                    }
                    else
                    {
                        if (isphparr)
                            cg.EmitPop(cg.EmitCall(ILOpCode.Call, cg.CoreMethods.PhpArray.Add_PhpValue));
                        else
                            cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.IPhpArray.AddValue_PhpValue);
                    }
                }
            }
            else if (stack.tArray.IsOfType(cg.CoreTypes.ArrayAccess))
            {
                if (Access.IsUnset)
                {
                    Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);
                    Debug.Assert(valueType == null);

                    // Template: <STACK>.offsetUnset( key )
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetUnset_ArrayAccess_PhpValue);
                }
                else if (Access.IsWrite)
                {
                    Debug.Assert(stack.tIndex == cg.CoreTypes.PhpValue);

                    // Template: <STACK>.offsetSet( key, value )
                    cg.EmitConvertToPhpValue(valueType, 0);
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetSet_ArrayAccess_PhpValue_PhpValue);
                }
                else
                {
                    throw ExceptionUtilities.UnexpectedValue(Access);
                }
            }
            else
            {
                throw cg.NotImplementedException($"STORE {stack.tArray.Name}[]");
            }
        }

        #endregion
    }

    partial class BoundArrayItemOrdEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(!Access.MightChange);
            Debug.Assert(Index != null);

            // Either specialize the call for the string types or fall back to PhpValue
            TypeSymbol arrType;
            MethodSymbol operation;

            var arrTypeMask = Array.TypeRefMask;
            if (arrTypeMask.IsSingleType && !arrTypeMask.IsRef && cg.TypeRefContext.IsAString(arrTypeMask))
            {
                arrType = cg.EmitSpecialize(Array);
            }
            else
            {
                arrType = cg.EmitConvertToPhpValue(Array);
            }

            if (arrType == cg.CoreTypes.String)
            {
                operation = cg.CoreMethods.Operators.GetItemOrdValue_String_Long;
            }
            else if (arrType == cg.CoreTypes.PhpString)
            {
                operation = cg.CoreMethods.Operators.GetItemOrdValue_PhpString_Long;
            }
            else
            {
                Debug.Assert(arrType == cg.CoreTypes.PhpValue);
                operation = cg.CoreMethods.Operators.GetItemOrdValue_PhpValue_Long.Symbol;
            }

            // The index must be integral
            var indexType = cg.EmitSpecialize(Index);
            Debug.Assert(indexType.IsIntegralType());
            cg.EmitConvertIntToLong(indexType);

            return cg.EmitCall(ILOpCode.Call, operation);
        }
    }

    partial class BoundInstanceOfEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(Access.IsRead || Access.IsNone);

            var type = cg.Emit(Operand);

            //
            if (Access.IsNone)
            {
                cg.EmitPop(type);
                return cg.CoreTypes.Void;
            }

            type = cg.EmitAsObject(type, out bool isnull);
            Debug.Assert(type.IsReferenceType);

            //
            var tref = (BoundTypeRef)AsType;
            if (tref.ResolvedType.IsValidType())
            {
                if (!isnull)
                {
                    // Template: value is T : object
                    cg.Builder.EmitOpCode(ILOpCode.Isinst);
                    cg.EmitSymbolToken(tref.ResolvedType, null);

                    // object != null
                    cg.Builder.EmitNullConstant(); // .ldnull
                    cg.Builder.EmitOpCode(ILOpCode.Cgt_un); // .cgt.un
                }
                else
                {
                    cg.EmitPop(type);   // Operand is never an object instance

                    // FALSE
                    cg.Builder.EmitBoolConstant(false);
                }

                //
                return cg.CoreTypes.Boolean;
            }
            else
            {
                tref.EmitLoadTypeInfo(cg, false);

                // Template: Operators.IsInstanceOf(value, type);
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsInstanceOf_Object_PhpTypeInfo);
            }

            throw new NotImplementedException();
        }
    }

    partial class BoundPseudoConst
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var sourcefile = cg.ContainingFile;

            switch (this.ConstType)
            {
                case Types.File:

                    // <ctx>.RootPath + RelativePath
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.RootPath.Getter);

                    cg.Builder.EmitStringConstant("/" + sourcefile.RelativeFilePath);
                    cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.NormalizePath_string);  // normalize slashes

                    return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Concat_String_String)
                        .Expect(SpecialType.System_String);

                case Types.Dir:

                    // <ctx>.RootPath + RelativeDirectory
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.RootPath.Getter);

                    var relative_dir = sourcefile.DirectoryRelativePath;
                    if (relative_dir.Length != 0)
                    {
                        cg.Builder.EmitStringConstant("/" + relative_dir);
                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.NormalizePath_string);  // normalize slashes

                        cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.Concat_String_String);
                    }

                    return cg.CoreTypes.String;

                case Types.Class:

                    // resolve name of self in runtime:
                    // Template: (string)Operators.GetSelfOrNull(<self>)?.Name
                    cg.EmitLoadSelf(throwOnError: false);  // GetSelf() : PhpTypeInfo
                    cg.EmitNullCoalescing(
                        () => cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetName_PhpTypeInfo.Getter), // Name : string
                        () => cg.Builder.EmitStringConstant(string.Empty));

                    return cg.CoreTypes.String;

                case Types.RootPath:
                    // <ctx>.RootPath
                    cg.EmitLoadContext();
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Context.RootPath.Getter);
                    return cg.CoreTypes.String;

                default:

                    // the other pseudoconstants should be resolved by flow analysis
                    throw ExceptionUtilities.Unreachable;
            }
        }
    }

    partial class BoundPseudoClassConst
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            switch (this.ConstType)
            {
                case PseudoClassConstUse.Types.Class:
                    this.TargetType.EmitClassName(cg);
                    return cg.CoreTypes.String;

                default:
                    throw ExceptionUtilities.UnexpectedValue(this.ConstType);
            }
        }
    }

    partial class BoundGlobalConst
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(!Access.IsWrite);

            if (this.Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }

            // resolved constant value
            if (this.ConstantValue.HasValue)
            {
                return cg.EmitLoadConstant(this.ConstantValue.Value, this.Access.TargetType);
            }

            // resolved constant symbol
            if (_boundExpressionOpt != null)
            {
                return _boundExpressionOpt.EmitLoadValue(cg, BoundAccess.Read);
            }

            // the constant has to be resolved in runtime,
            // make it easier by caching its internal ID for fast lookup

            // Template: internal static int <const>Name;
            var idxfield = cg.Module.SynthesizedManager.GetGlobalConstantIndexField(Name.ToString());

            Debug.Assert(FallbackName.HasValue == false || Name != FallbackName.Value);

            // Template: Operators.ReadConstant(ctx, name, ref <idxfield> [, fallbackname])
            cg.EmitLoadContext();
            cg.Builder.EmitStringConstant(this.Name.ToString());
            cg.EmitFieldAddress(idxfield);

            if (FallbackName.HasValue)
            {
                // we have to try two possible constant names:
                cg.Builder.EmitStringConstant(this.FallbackName.Value.ToString());
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.ReadConstant_Context_String_Int_String)
                    .Expect(cg.CoreTypes.PhpValue);
            }
            else
            {
                // Operators.ReadConstant(ctx, name, ref <idxfield>)
                return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.ReadConstant_Context_String_Int)
                    .Expect(cg.CoreTypes.PhpValue);
            }
        }
    }

    partial class BoundIsEmptyEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var il = cg.Builder;
            var t = cg.Emit(this.Operand);

            // resolve IsEmpty() operator
            var op = cg.Conversions.ResolveOperator(t, false, new[] { "IsEmpty" }, new[] { cg.CoreTypes.Operators.Symbol }, target: cg.CoreTypes.Boolean);
            if (op != null)
            {
                // {t} reference type and possibly NULL,
                // emit null check:
                if (t.IsReferenceType && cg.CanBeNull(this.Operand.TypeRefMask) && !op.IsStatic)
                {
                    // https://github.com/peachpiecompiler/peachpie/issues/816
                    // Template: <STACK> != null ? IsEmpty(STACK) : FALSE
                    cg.EmitNullCoalescing(
                        notnullemitter: () => cg.EmitConversion(new CommonConversion(true, false, false, false, false, false, op), t, cg.CoreTypes.Boolean),
                        nullemitter: () => cg.Builder.EmitBoolConstant(true)
                    );
                }
                else
                {
                    // Template: IsEmpty(STACK)
                    cg.EmitConversion(new CommonConversion(true, false, false, false, false, false, op), t, cg.CoreTypes.Boolean);
                }
            }
            else
            {
                //
                switch (t.SpecialType)
                {
                    case SpecialType.System_Object:
                        // object == null
                        il.EmitNullConstant();
                        il.EmitOpCode(ILOpCode.Ceq);
                        break;

                    case SpecialType.System_Double:
                    case SpecialType.System_Boolean:
                    case SpecialType.System_Int32:
                    case SpecialType.System_Int64:
                    case SpecialType.System_String:
                        // Template: !(bool)value
                        cg.EmitConvertToBool(t, this.Operand.TypeRefMask);
                        cg.EmitLogicNegation();
                        break;

                    default:

                        // (value).IsEmpty
                        cg.EmitConvert(t, this.Operand.TypeRefMask, cg.CoreTypes.PhpValue);
                        return cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsEmpty_PhpValue)
                            .Expect(SpecialType.System_Boolean);
                }
            }

            //
            return cg.CoreTypes.Boolean;
        }
    }

    partial class BoundIsSetEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            var t = cg.Emit(this.VarReference);

            // t.IsSet
            if (t == cg.CoreTypes.PhpAlias)
            {
                // <PhpAlias>.Value
                t = cg.Emit_PhpAlias_GetValue();
            }

            if (t == cg.CoreTypes.PhpValue)
            {
                // IsSet(value)
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.IsSet_PhpValue);
            }
            else if (t.IsReferenceType)
            {
                // object != null
                cg.Builder.EmitNullConstant(); // .ldnull
                cg.Builder.EmitOpCode(ILOpCode.Cgt_un); // .cgt.un
            }
            else if (t.IsNullableType())
            {
                // Teplate: value.HasValue
                cg.EmitStructAddr(t); // value -> ref value
                cg.EmitCall(ILOpCode.Call, t.LookupMember<PropertySymbol>("HasValue").GetMethod)
                    .Expect(SpecialType.System_Boolean);
            }
            else
            {
                // clean this up ...
                // NOTICE: "IndirectProperty" performs `isset` by itself and returns the result as boolean
                if (t.SpecialType == SpecialType.System_Boolean)
                {
                    if (VarReference is BoundFieldRef boundfld)
                    {
                        if (boundfld.BoundReference is IndirectProperty)
                        {
                            // isset already checked by callsite:
                            return t;
                        }
                    }
                }

                // value type => true
                cg.EmitPop(t);
                cg.Builder.EmitBoolConstant(true);
            }

            //
            return cg.CoreTypes.Boolean;
        }
    }

    partial class BoundOffsetExists
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            // Operators.OffsetExists( Receiver, Index ) : bool

            var arrayType = cg.Emit(Receiver);
            var indexType = cg.Emit(Index);

            //if (arrayType.IsOfType(cg.CoreTypes.ArrayAccess))
            //{
            //    cg.EmitConvert(indexType, 0, cg.CoreTypes.PhpValue);
            //    return cg.EmitCall(ILOpCode.Callvirt, cg.CoreMethods.Operators.offsetExists_ArrayAccess_PhpValue);
            //}

            var op = cg.Conversions.ResolveOperator(arrayType, false, new[] { "offsetExists" }, new[] { cg.CoreTypes.Operators.Symbol }, operand: indexType, target: cg.CoreTypes.Boolean);
            if (op != null)
            {
                cg.EmitConversion(new CommonConversion(true, false, false, false, false, false, op), arrayType, cg.CoreTypes.Boolean, op: indexType);
                return cg.CoreTypes.Boolean;
            }
            else
            {
                throw cg.NotImplementedException($"offsetExists({arrayType}, {indexType})", this);
            }
        }
    }

    partial class BoundTryGetItem
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(!Access.IsEnsure);

            // Either specialize the call for PhpArray (possibly with string index) or fall back to PhpValue

            TypeSymbol arrType, indexType;
            MethodSymbol operation;

            var arrTypeMask = Array.TypeRefMask;
            if (arrTypeMask.IsSingleType && !arrTypeMask.IsRef && cg.TypeRefContext.IsArray(arrTypeMask))
            {
                arrType = cg.EmitSpecialize(Array);
            }
            else
            {
                arrType = cg.EmitConvertToPhpValue(Array);
            }

            var indexTypeMask = Index.TypeRefMask;
            if (arrType == cg.CoreTypes.PhpArray &&
                indexTypeMask.IsSingleType && !indexTypeMask.IsRef && cg.TypeRefContext.IsReadonlyString(indexTypeMask))
            {
                indexType = cg.EmitSpecialize(Index);
            }
            else
            {
                indexType = cg.EmitConvertToPhpValue(Index);
            }

            if (arrType == cg.CoreTypes.PhpArray)
            {
                if (indexType == cg.CoreTypes.String)
                {
                    operation = cg.CoreMethods.Operators.TryGetItemValue_PhpArray_string_PhpValueRef;
                }
                else
                {
                    Debug.Assert(indexType == cg.CoreTypes.PhpValue);
                    operation = cg.CoreMethods.Operators.TryGetItemValue_PhpArray_PhpValue_PhpValueRef;
                }
            }
            else
            {
                Debug.Assert(arrType == cg.CoreTypes.PhpValue);
                Debug.Assert(indexType == cg.CoreTypes.PhpValue);
                operation = cg.CoreMethods.Operators.TryGetItemValue_PhpValue_PhpValue_PhpValueRef;
            }

            // TryGetItemValue(Array, Index, out PhpValue temp) ? temp : Fallback

            object trueLbl = new object();
            object endLbl = new object();

            // call
            var temp = cg.GetTemporaryLocal(cg.CoreTypes.PhpValue);
            cg.Builder.EmitLocalAddress(temp);
            cg.EmitCall(ILOpCode.Call, operation);
            cg.Builder.EmitBranch(ILOpCode.Brtrue, trueLbl);

            // fallback:
            cg.EmitConvertToPhpValue(Fallback);
            cg.Builder.EmitBranch(ILOpCode.Br, endLbl);

            // trueLbl:
            cg.Builder.MarkLabel(trueLbl);
            cg.Builder.EmitLocalLoad(temp);

            // endLbl:
            cg.Builder.MarkLabel(endLbl);

            cg.ReturnTemporaryLocal(temp);

            return cg.CoreTypes.PhpValue;
        }
    }

    partial class BoundYieldEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            Debug.Assert(cg.GeneratorStateMachineMethod != null);

            if (this.Access.IsNone)
            {
                return cg.CoreTypes.Void;
            }
            else if (this.Access.IsRead)
            {
                // leave result of yield expr. (sent value) on eval stack

                cg.EmitGeneratorInstance();
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.GetGeneratorSentItem_Generator);

                // type of expression result is PHP value (sent value)
                return cg.CoreTypes.PhpValue;
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(this.Access);
            }
        }
    }

    partial class BoundYieldFromEx
    {
        internal override TypeSymbol Emit(CodeGenerator cg)
        {
            if (Access.IsRead)
            {
                var t = cg.EmitAsObject(cg.Emit(Operand), out bool isnull);
                Debug.Assert(t.IsReferenceType);

                if (isnull || (
                    !cg.CoreTypes.Generator.Symbol.IsOfType(t) &&
                    !t.IsOfType(cg.CoreTypes.Generator)))
                {
                    cg.EmitPop(t);
                    cg.Emit_PhpValue_Null();
                }
                else
                {
                    var il = cg.Builder;
                    var lbl_End = new NamedLabel("Generator_Null");

                    if (t != cg.CoreTypes.Generator)
                    {
                        // Template: (Operand as Generator)?.getReturn() : PhpValue
                        cg.Builder.EmitOpCode(ILOpCode.Isinst);
                        cg.EmitSymbolToken(cg.CoreTypes.Generator, null);

                        var lbl_notnull = new NamedLabel("Generator_NotNull");
                        il.EmitOpCode(ILOpCode.Dup);
                        il.EmitBranch(ILOpCode.Brtrue, lbl_notnull);

                        il.EmitOpCode(ILOpCode.Pop);
                        cg.Emit_PhpValue_Null();
                        il.EmitBranch(ILOpCode.Br, lbl_End);

                        il.MarkLabel(lbl_notnull);
                    }

                    // Generator.getReturn() : PhpValue
                    cg.EmitCall(ILOpCode.Callvirt, cg.CoreTypes.Generator.Method("getReturn"));

                    il.MarkLabel(lbl_End);
                }

                //
                return cg.CoreTypes.PhpValue;
            }
            else
            {
                return cg.CoreTypes.Void;
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs(15,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs(2358,18): error CS0165: Use of unassigned local variable 'm',D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Graph\BoundExpression.cs(15,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.CodeGen;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Pchp.CodeAnalysis.Emit;
using System.Reflection.Metadata;
using Pchp.CodeAnalysis.FlowAnalysis;
using Pchp.CodeAnalysis.Semantics;
using System.Collections.Immutable;

namespace Pchp.CodeAnalysis.Symbols
{
    partial class SourceRoutineSymbol
    {
        /// <summary>
        /// Gets place referring to <c>Pchp.Core.Context</c> object.
        /// </summary>
        internal virtual IPlace GetContextPlace(PEModuleBuilder module)
        {
            var ps = ImplicitParameters;
            if (ps.Length != 0 && SpecialParameterSymbol.IsContextParameter(ps[0]))
            {
                return new ParamPlace(ps[0]);  // <ctx>
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Gets place of <c>this</c> parameter in CLR corresponding to <c>current class instance</c>.
        /// </summary>
        internal virtual IPlace GetThisPlace()
        {
            return this.HasThis
                ? new ArgPlace(ContainingType, 0)
                : null;
        }

        internal virtual IPlace GetPhpThisVariablePlaceWithoutGenerator(PEModuleBuilder module = null)
        {
            var thisPlace = GetThisPlace();
            if (thisPlace != null)
            {
                //if (this.ContainingType.IsTraitType())
                if (this.ContainingType is SourceTraitTypeSymbol trait)
                {
                    // $this ~ this.<>this
                    return new FieldPlace(thisPlace, trait.RealThisField, module);
                }
                else
                {
                    Debug.Assert(!this.ContainingType.IsTraitType());
                }
            }

            //
            return thisPlace;
        }

        /// <summary>
        /// Gets place of PHP <c>$this</c> variable.
        /// </summary>
        public IPlace GetPhpThisVariablePlace(PEModuleBuilder module = null)
        {
            var thisPlace = GetPhpThisVariablePlaceWithoutGenerator(module);

            if (this.IsGeneratorMethod())
            {
                // $this ~ arg1
                return thisPlace != null
                    ? new ArgPlace(thisPlace.Type, 1)
                    : null;
            }

            return thisPlace;
        }

        /// <summary>
        /// Creates ghost stubs,
        /// i.e. methods with a different signature calling this routine to comply with CLR standards.
        /// </summary>
        /// <returns>List of additional overloads.</returns>
        internal virtual IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            //
            EmitParametersDefaultValue(module, diagnostic);

            // TODO: resolve this already in SourceTypeSymbol.GetMembers(), now it does not get overloaded properly
            return SynthesizeOverloadsWithOptionalParameters(module, diagnostic);
        }

        /// <summary>
        /// Synthesizes method overloads in case there are optional parameters which explicit default value cannot be resolved as a <see cref="ConstantValue"/>.
        /// </summary>
        /// <remarks>
        /// foo($a = [], $b = [1, 2, 3])
        /// + foo() => foo([], [1, 2, 3)
        /// + foo($a) => foo($a, [1, 2, 3])
        /// </remarks>
        protected IList<MethodSymbol> SynthesizeOverloadsWithOptionalParameters(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            List<MethodSymbol> list = null;

            var implparams = ImplicitParameters;
            var srcparams = SourceParameters;
            var implicitVarArgs = VarargsParam;

            for (int i = 0; i <= srcparams.Length; i++) // how many to be copied from {srcparams}
            {
                var isfake = /*srcparams[i - 1].IsFake*/ implicitVarArgs != null && i > 0 && srcparams[i - 1].Ordinal >= implicitVarArgs.Ordinal; // parameter was replaced with [params]
                var hasdefault = false; // i < srcparams.Length && srcparams[i].HasUnmappedDefaultValue();  // ConstantValue couldn't be resolved for optional parameter

                if (isfake || hasdefault)
                {
                    if (this.ContainingType.IsInterface)
                    {
                        // we can't build instance method in an interface
                        // CONSIDER: generate static extension method ?
                    }
                    else
                    {
                        // ghostparams := [...implparams, ...srcparams{0..i-1}]
                        var ghostparams = ImmutableArray.CreateBuilder<ParameterSymbol>(implparams.Length + i);
                        ghostparams.AddRange(implparams);
                        ghostparams.AddRange(srcparams, i);

                        // create ghost stub foo(p0, .. pi-1) => foo(p0, .. , pN)
                        var ghost = GhostMethodBuilder.CreateGhostOverload(
                            this, ContainingType, module, diagnostic,
                            ReturnType, ghostparams.MoveToImmutable());

                        //
                        if (list == null)
                        {
                            list = new List<MethodSymbol>();
                        }

                        list.Add(ghost);
                    }
                }
            }

            return list ?? (IList<MethodSymbol>)Array.Empty<MethodSymbol>();
        }

        /// <summary>
        /// Emits initializers of all parameter's non-standard default values (such as PhpArray)
        /// within the type's static .cctor
        /// </summary>
        private void EmitParametersDefaultValue(PEModuleBuilder module, DiagnosticBag diagnostics)
        {
            foreach (var p in this.SourceParameters)
            {
                var field = p.DefaultValueField;
                if (field is SynthesizedFieldSymbol)
                {
                    Debug.Assert(p.Initializer != null);

                    module.SynthesizedManager.AddField(field.ContainingType, field);

                    // .cctor() {

                    var cctor = module.GetStaticCtorBuilder(field.ContainingType);
                    lock (cctor)
                    {
                        SynthesizedMethodSymbol func = null;

                        if (field.Type.Is_Func_Context_PhpValue())  // Func<Context, PhpValue>
                        {
                            // private static PhpValue func(Context) => INITIALIZER()
                            func = new SynthesizedMethodSymbol(field.ContainingType, field.Name + "Func", isstatic: true, isvirtual: false, DeclaringCompilation.CoreTypes.PhpValue, isfinal: true);
                            func.SetParameters(new SynthesizedParameterSymbol(func, DeclaringCompilation.CoreTypes.Context, 0, RefKind.None, name: SpecialParameterSymbol.ContextName));

                            //
                            module.SetMethodBody(func, MethodGenerator.GenerateMethodBody(module, func, il =>
                            {
                                var ctxPlace = new ArgPlace(DeclaringCompilation.CoreTypes.Context, 0);
                                var cg = new CodeGenerator(il, module, diagnostics, module.Compilation.Options.OptimizationLevel, false, field.ContainingType, ctxPlace, null)
                                {
                                    CallerType = ContainingType,
                                    ContainingFile = ContainingFile,
                                    IsInCachedArrayExpression = true,   // do not cache array initializers twice
                                };

                                // return {Initializer}
                                cg.EmitConvert(p.Initializer, func.ReturnType);
                                cg.EmitRet(func.ReturnType);

                            }, null, diagnostics, false));

                            module.SynthesizedManager.AddMethod(func.ContainingType, func);
                        }

                        using (var cg = new CodeGenerator(cctor, module, diagnostics, module.Compilation.Options.OptimizationLevel, false, field.ContainingType,
                                contextPlace: null,
                                thisPlace: null)
                        {
                            CallerType = ContainingType,
                            ContainingFile = ContainingFile,
                            IsInCachedArrayExpression = true,   // do not cache array initializers twice
                        })
                        {
                            var fldplace = new FieldPlace(null, field, module);
                            fldplace.EmitStorePrepare(cg.Builder);
                            if (func == null)
                            {
                                // {field} = {Initializer};
                                cg.EmitConvert(p.Initializer, field.Type);
                            }
                            else
                            {
                                MethodSymbol funcsymbol = func;

                                // bind func in case it is generic
                                if (func.ContainingType is SourceTraitTypeSymbol st)
                                {
                                    funcsymbol = func.AsMember(st.Construct(st.TypeArguments));
                                }

                                // Func<,>(object @object, IntPtr method)
                                var func_ctor = ((NamedTypeSymbol)field.Type).InstanceConstructors.Single(m =>
                                    m.ParameterCount == 2 &&
                                    m.Parameters[0].Type.SpecialType == SpecialType.System_Object &&
                                    m.Parameters[1].Type.SpecialType == SpecialType.System_IntPtr
                                );

                                // {field} = new Func<Context, PhpValue>( {func} )
                                cg.Builder.EmitNullConstant(); // null
                                cg.EmitOpCode(ILOpCode.Ldftn); // method
                                cg.EmitSymbolToken(funcsymbol, null);
                                cg.EmitCall(ILOpCode.Newobj, func_ctor);
                            }
                            fldplace.EmitStore(cg.Builder);
                        }
                    }
                }
            }
        }

        public virtual void Generate(CodeGenerator cg)
        {
            if (this.IsGeneratorMethod())
            {
                // generate method as a state machine (SM) in a separate synthesized method
                // this routine returns instance of new SM:
                GenerateGeneratorMethod(cg);
            }
            else
            {
                // normal method generation:
                cg.GenerateScope(this.ControlFlowGraph.Start, int.MaxValue);
            }
        }

        private void GenerateGeneratorMethod(CodeGenerator cg)
        {
            Debug.Assert(this.IsGeneratorMethod());

            var genSymbol = new SourceGeneratorSymbol(this);
            //var genConstructed = (genSymbol.ContainingType is SourceTraitTypeSymbol st)
            //    ? genSymbol.AsMember(st.Construct(st.TypeArguments))
            //    : genSymbol;

            var il = cg.Builder;
            var lambda = this as SourceLambdaSymbol;

            /* Template:
             * return BuildGenerator( <ctx>, new PhpArray(){ p1, p2, ... }, new GeneratorStateMachineDelegate((IntPtr)<genSymbol>), (RuntimeMethodHandle)this )
             */

            cg.EmitLoadContext(); // ctx for generator

            // new PhpArray for generator's locals
            cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray);

            var generatorsLocals = cg.GetTemporaryLocal(cg.CoreTypes.PhpArray);
            cg.Builder.EmitLocalStore(generatorsLocals);

            // initialize parameters (set their _isOptimized and copy them to locals array)
            InitializeParametersForGeneratorMethod(cg, il, generatorsLocals);
            cg.Builder.EmitLoad(generatorsLocals);
            cg.ReturnTemporaryLocal(generatorsLocals);

            // new PhpArray for generator's synthesizedLocals
            cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray);

            // new GeneratorStateMachineDelegate(<genSymbol>) delegate for generator
            cg.Builder.EmitNullConstant(); // null
            cg.EmitOpCode(ILOpCode.Ldftn); // method
            cg.EmitSymbolToken(genSymbol, null);

            cg.EmitCall(ILOpCode.Newobj, cg.CoreTypes.GeneratorStateMachineDelegate.Ctor(cg.CoreTypes.Object, cg.CoreTypes.IntPtr)); // GeneratorStateMachineDelegate(object @object, IntPtr method)

            // handleof(this)
            cg.EmitLoadToken(this, null);

            // create generator object via Operators factory method
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BuildGenerator_Context_PhpArray_PhpArray_GeneratorStateMachineDelegate_RuntimeMethodHandle);

            // .SetGeneratorThis( object ) : Generator
            if (!this.IsStatic || (lambda != null && lambda.UseThis))
            {
                GetPhpThisVariablePlaceWithoutGenerator(cg.Module).EmitLoad(cg.Builder);
                cg.EmitCastClass(cg.DeclaringCompilation.GetSpecialType(SpecialType.System_Object));
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetGeneratorThis_Generator_Object)
                    .Expect(cg.CoreTypes.Generator);
            }

            // .SetGeneratorLazyStatic( PhpTypeInfo ) : Generator
            if ((this.Flags & RoutineFlags.UsesLateStatic) != 0 && this.IsStatic)
            {
                cg.EmitLoadStaticPhpTypeInfo();
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetGeneratorLazyStatic_Generator_PhpTypeInfo)
                    .Expect(cg.CoreTypes.Generator);
            }

            // .SetGeneratorDynamicScope( scope ) : Generator
            if (lambda != null)
            {
                lambda.GetCallerTypePlace().EmitLoad(cg.Builder); // RuntimeTypeContext
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetGeneratorDynamicScope_Generator_RuntimeTypeHandle)
                    .Expect(cg.CoreTypes.Generator);
            }

            // Convert to return type (Generator or PhpValue, depends on analysis)
            cg.EmitConvert(cg.CoreTypes.Generator, 0, this.ReturnType);
            il.EmitRet(false);

            // Generate SM method. Must be generated after EmitInit of parameters (it sets their _isUnoptimized field).
            CreateStateMachineNextMethod(cg, genSymbol);
        }

        private void InitializeParametersForGeneratorMethod(CodeGenerator cg, Microsoft.CodeAnalysis.CodeGen.ILBuilder il, Microsoft.CodeAnalysis.CodeGen.LocalDefinition generatorsLocals)
        {
            // Emit init of unoptimized BoundParameters using separate CodeGenerator that has locals place pointing to our generator's locals array
            using (var localsArrayCg = new CodeGenerator(
                il, cg.Module, cg.Diagnostics,
                cg.DeclaringCompilation.Options.OptimizationLevel,
                cg.EmitPdbSequencePoints,
                this.ContainingType,
                contextPlace: cg.ContextPlaceOpt,
                thisPlace: null,
                routine: this, // needed to support static variables (they need enclosing routine while binding)
                locals: new LocalPlace(generatorsLocals),
                localsInitialized: false
                    ))
            {
                // EmitInit (for UnoptimizedLocals) copies arguments to locals array, does nothing for normal variables, handles local statics, global variables ...
                LocalsTable.Variables.ForEach(v => v.EmitInit(localsArrayCg));
            }
        }

        private void CreateStateMachineNextMethod(CodeGenerator cg, SourceGeneratorSymbol genSymbol)
        {
            cg.Module.SynthesizedManager.AddMethod(ContainingType, genSymbol); // save method symbol to module

            // generate generator's next method body
            var genMethodBody = MethodGenerator.GenerateMethodBody(cg.Module, genSymbol, (_il) =>
            {
                GenerateStateMachinesNextMethod(cg, _il, genSymbol);
            }
            , null, cg.Diagnostics, cg.EmitPdbSequencePoints);

            cg.Module.SetMethodBody(genSymbol, genMethodBody);
        }

        //Initialized a new CodeGenerator for generation of SourceGeneratorSymbol (state machine's next method)
        private void GenerateStateMachinesNextMethod(CodeGenerator cg, Microsoft.CodeAnalysis.CodeGen.ILBuilder _il, SourceGeneratorSymbol genSymbol)
        {
            // TODO: get correct ThisPlace, ReturnType etc. resolution & binding out of the box without GN_SGS hacks
            // using SourceGeneratorSymbol

            //Refactor parameters references to proper fields
            using (var stateMachineNextCg = new CodeGenerator(
                _il, cg.Module, cg.Diagnostics,
                cg.DeclaringCompilation.Options.OptimizationLevel,
                cg.EmitPdbSequencePoints,
                this.ContainingType,
                contextPlace: new ParamPlace(genSymbol.ContextParameter),
                thisPlace: new ParamPlace(genSymbol.ThisParameter),
                routine: this,
                locals: new ParamPlace(genSymbol.LocalsParameter),
                localsInitialized: true,
                tempLocals: new ParamPlace(genSymbol.TmpLocalsParameter)
                    )
            {
                GeneratorStateMachineMethod = genSymbol,    // Pass SourceGeneratorSymbol to CG for additional yield and StartBlock emit 
            })
            {
                stateMachineNextCg.GenerateScope(this.ControlFlowGraph.Start, int.MaxValue);
            }
        }
    }

    partial class SourceGlobalMethodSymbol
    {
        /// <summary>
        /// Real main method with <c>MainDelegate</c> signature.
        /// The method is generated lazily in order to provide method compatible with MainDelegate.
        /// <see cref="SourceGlobalMethodSymbol"/> may have (usually have) a different return type.
        /// </summary>
        internal SynthesizedMethodSymbol _mainMethod0;

        internal override IPlace GetThisPlace() => new ParamPlace(ThisParameter);

        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            //base.SynthesizeStubs(module, diagnostic);          // ghosts (always empty)

            // <Main>'0
            this.SynthesizeMainMethodWrapper(module, diagnostic);

            // no overloads synthesized for global code
            return Array.Empty<MethodSymbol>();
        }

        /// <summary>
        /// Main method wrapper in case it does not return PhpValue.
        /// </summary>
        void SynthesizeMainMethodWrapper(PEModuleBuilder module, DiagnosticBag diagnostics)
        {
            if (this.ReturnType != DeclaringCompilation.CoreTypes.PhpValue)
            {
                // PhpValue <Main>`0(parameters)
                var wrapper = new SynthesizedMethodSymbol(
                    this.ContainingFile, WellKnownPchpNames.GlobalRoutineName + "`0", true, false,
                    DeclaringCompilation.CoreTypes.PhpValue, Accessibility.Public);

                wrapper.SetParameters(this.Parameters.Select(p =>
                    new SynthesizedParameterSymbol(wrapper, p.Type, p.Ordinal, p.RefKind, p.Name)).ToArray());

                // save method symbol to module
                module.SynthesizedManager.AddMethod(this.ContainingFile, wrapper);

                // generate method body
                module.CreateMainMethodWrapper(wrapper, this, diagnostics);

                //
                _mainMethod0 = wrapper;
            }
        }
    }

    partial class SourceMethodSymbol
    {
        internal override IPlace GetContextPlace(PEModuleBuilder module)
        {
            var thisplace = GetThisPlace();
            if (thisplace != null)
            {
                // <this>.<ctx> in instance methods
                var t = (SourceTypeSymbol)this.ContainingType;

                var ctx_field = t.ContextStore;
                if (ctx_field != null)  // might be null in interfaces
                {
                    return new FieldPlace(thisplace, ctx_field, module);
                }
                else
                {
                    Debug.Assert(t.IsInterface);
                    return null;
                }
            }

            //
            return base.GetContextPlace(module);
        }

        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            // empty body for static abstract
            if (this.ControlFlowGraph == null && this.IsStatic)
            {
                SynthesizeEmptyBody(module, diagnostic);
            }

            //
            return base.SynthesizeStubs(module, diagnostic);
        }

        void SynthesizeEmptyBody(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            Debug.Assert(this.ControlFlowGraph == null);
            Debug.Assert(this.IsAbstract == false);

            module.SetMethodBody(this, MethodGenerator.GenerateMethodBody(module, this, (il) =>
            {
                var cg = new CodeGenerator(this, il, module, diagnostic, module.Compilation.Options.OptimizationLevel, false);

                // Template: return default(T)
                cg.EmitRetDefault();
            }, null, diagnostic, false));
        }
    }

    partial class SourceFunctionSymbol
    {
        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            var overloads = base.SynthesizeStubs(module, diagnostic);

            // synthesize RoutineInfo:
            var cctor = module.GetStaticCtorBuilder(_file);
            lock (cctor)
            {
                using (var cg = new CodeGenerator(
                        cctor, module, diagnostic, PhpOptimizationLevel.Release, false, this.ContainingType,
                        contextPlace: null, thisPlace: null, routine: this))
                {
                    var field = new FieldPlace(null, this.EnsureRoutineInfoField(module), module);

                    // {RoutineInfoField} = RoutineInfo.CreateUserRoutine(name, handle, overloads[])
                    field.EmitStorePrepare(cctor);

                    cctor.EmitStringConstant(this.QualifiedName.ToString());
                    cctor.EmitLoadToken(module, DiagnosticBag.GetInstance(), this, null);
                    cg.Emit_NewArray(cg.CoreTypes.RuntimeMethodHandle, overloads.AsImmutable(), m => cg.EmitLoadToken(m, null));

                    cctor.EmitCall(module, DiagnosticBag.GetInstance(), ILOpCode.Call, cg.CoreMethods.Reflection.CreateUserRoutine_string_RuntimeMethodHandle_RuntimeMethodHandleArr);

                    field.EmitStore(cctor);
                }
            }

            //
            return overloads;
        }
    }

    partial class SourceLambdaSymbol
    {
        internal override IPlace GetContextPlace(PEModuleBuilder module)
        {
            // Template: Operators.Context(<closure>)
            return new OperatorPlace(DeclaringCompilation.CoreMethods.Operators.Context_Closure, new ParamPlace(ClosureParameter));
        }

        internal override IPlace GetThisPlace()
        {
            if (UseThis)
            {
                // Template: Operators.Context(<closure>)
                return new OperatorPlace(DeclaringCompilation.CoreMethods.Operators.This_Closure, new ParamPlace(ClosureParameter));
            }

            return base.GetThisPlace();
        }

        internal override IPlace GetPhpThisVariablePlaceWithoutGenerator(PEModuleBuilder module = null)
        {
            return GetThisPlace();
        }

        internal IPlace GetCallerTypePlace()
        {
            // Template: Operators.Scope(<closure>)
            return new OperatorPlace(DeclaringCompilation.CoreMethods.Operators.Scope_Closure, new ParamPlace(ClosureParameter));
        }

        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            var overloads = base.SynthesizeStubs(module, diagnostic);

            // synthesize RoutineInfo:
            var cctor = module.GetStaticCtorBuilder(Container);
            lock (cctor)
            {
                var field = new FieldPlace(null, this.EnsureRoutineInfoField(module), module);

                var ct = module.Compilation.CoreTypes;

                // {RoutineInfoField} = new PhpAnonymousRoutineInfo(name, handle)
                field.EmitStorePrepare(cctor);

                cctor.EmitStringConstant(this.MetadataName);
                cctor.EmitLoadToken(module, DiagnosticBag.GetInstance(), this, null);
                cctor.EmitCall(module, DiagnosticBag.GetInstance(), ILOpCode.Call, ct.Operators.Method("AnonymousRoutine", ct.String, ct.RuntimeMethodHandle));

                field.EmitStore(cctor);
            }

            //
            return overloads;
        }
    }

    partial class SourceGeneratorSymbol
    {
        internal void EmitInit(PEModuleBuilder module)
        {
            // Don't need any initial emit
        }
    }
};
---- Transformed Tree ----
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.CodeGen;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Pchp.CodeAnalysis.Emit;
using System.Reflection.Metadata;
using Pchp.CodeAnalysis.FlowAnalysis;
using Pchp.CodeAnalysis.Semantics;
using System.Collections.Immutable;

namespace Pchp.CodeAnalysis.Symbols
{
    partial class SourceRoutineSymbol
    {
        /// <summary>
        /// Gets place referring to <c>Pchp.Core.Context</c> object.
        /// </summary>
        internal virtual IPlace GetContextPlace(PEModuleBuilder module)
        {
            var ps = ImplicitParameters;
            if (ps.Length != 0 && SpecialParameterSymbol.IsContextParameter(ps[0]))
            {
                return new ParamPlace(ps[0]);  // <ctx>
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Gets place of <c>this</c> parameter in CLR corresponding to <c>current class instance</c>.
        /// </summary>
        internal virtual IPlace GetThisPlace()
        {
            return this.HasThis
                ? new ArgPlace(ContainingType, 0)
                : null;
        }

        internal virtual IPlace GetPhpThisVariablePlaceWithoutGenerator(PEModuleBuilder module = null)
        {
            var thisPlace = GetThisPlace();
            if (thisPlace != null)
            {
                //if (this.ContainingType.IsTraitType())
                if (this.ContainingType is SourceTraitTypeSymbol trait)
                {
                    // $this ~ this.<>this
                    return new FieldPlace(thisPlace, trait.RealThisField, module);
                }
                else
                {
                    Debug.Assert(!this.ContainingType.IsTraitType());
                }
            }

            //
            return thisPlace;
        }

        /// <summary>
        /// Gets place of PHP <c>$this</c> variable.
        /// </summary>
        public IPlace GetPhpThisVariablePlace(PEModuleBuilder module = null)
        {
            var thisPlace = GetPhpThisVariablePlaceWithoutGenerator(module);

            if (this.IsGeneratorMethod())
            {
                // $this ~ arg1
                return thisPlace != null
                    ? new ArgPlace(thisPlace.Type, 1)
                    : null;
            }

            return thisPlace;
        }

        /// <summary>
        /// Creates ghost stubs,
        /// i.e. methods with a different signature calling this routine to comply with CLR standards.
        /// </summary>
        /// <returns>List of additional overloads.</returns>
        internal virtual IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            //
            EmitParametersDefaultValue(module, diagnostic);

            // TODO: resolve this already in SourceTypeSymbol.GetMembers(), now it does not get overloaded properly
            return SynthesizeOverloadsWithOptionalParameters(module, diagnostic);
        }

        /// <summary>
        /// Synthesizes method overloads in case there are optional parameters which explicit default value cannot be resolved as a <see cref="ConstantValue"/>.
        /// </summary>
        /// <remarks>
        /// foo($a = [], $b = [1, 2, 3])
        /// + foo() => foo([], [1, 2, 3)
        /// + foo($a) => foo($a, [1, 2, 3])
        /// </remarks>
        protected IList<MethodSymbol> SynthesizeOverloadsWithOptionalParameters(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            List<MethodSymbol> list = null;

            var implparams = ImplicitParameters;
            var srcparams = SourceParameters;
            var implicitVarArgs = VarargsParam;

            for (int i = 0; i <= srcparams.Length; i++) // how many to be copied from {srcparams}
            {
                var isfake = /*srcparams[i - 1].IsFake*/ implicitVarArgs != null && i > 0 && srcparams[i - 1].Ordinal >= implicitVarArgs.Ordinal; // parameter was replaced with [params]
                var hasdefault = false; // i < srcparams.Length && srcparams[i].HasUnmappedDefaultValue();  // ConstantValue couldn't be resolved for optional parameter

                if (isfake || hasdefault)
                {
                    if (this.ContainingType.IsInterface)
                    {
                        // we can't build instance method in an interface
                        // CONSIDER: generate static extension method ?
                    }
                    else
                    {
                        // ghostparams := [...implparams, ...srcparams{0..i-1}]
                        var ghostparams = ImmutableArray.CreateBuilder<ParameterSymbol>(implparams.Length + i);
                        ghostparams.AddRange(implparams);
                        ghostparams.AddRange(srcparams, i);

                        // create ghost stub foo(p0, .. pi-1) => foo(p0, .. , pN)
                        var ghost = GhostMethodBuilder.CreateGhostOverload(
                            this, ContainingType, module, diagnostic,
                            ReturnType, ghostparams.MoveToImmutable());

                        //
                        if (list == null)
                        {
                            list = new List<MethodSymbol>();
                        }

                        list.Add(ghost);
                    }
                }
            }

            return list ?? (IList<MethodSymbol>)Array.Empty<MethodSymbol>();
        }

        /// <summary>
        /// Emits initializers of all parameter's non-standard default values (such as PhpArray)
        /// within the type's static .cctor
        /// </summary>
        private void EmitParametersDefaultValue(PEModuleBuilder module, DiagnosticBag diagnostics)
        {
            foreach (var p in this.SourceParameters)
            {
                var field = p.DefaultValueField;
                if (field is SynthesizedFieldSymbol)
                {
                    Debug.Assert(p.Initializer != null);

                    module.SynthesizedManager.AddField(field.ContainingType, field);

                    // .cctor() {

                    var cctor = module.GetStaticCtorBuilder(field.ContainingType);
                    lock (cctor)
                    {
                        SynthesizedMethodSymbol func = null;

                        if (field.Type.Is_Func_Context_PhpValue())  // Func<Context, PhpValue>
                        {
                            // private static PhpValue func(Context) => INITIALIZER()
                            func = new SynthesizedMethodSymbol(field.ContainingType, field.Name + "Func", isstatic: true, isvirtual: false, DeclaringCompilation.CoreTypes.PhpValue, isfinal: true);
                            func.SetParameters(new SynthesizedParameterSymbol(func, DeclaringCompilation.CoreTypes.Context, 0, RefKind.None, name: SpecialParameterSymbol.ContextName));

                            //
                            module.SetMethodBody(func, MethodGenerator.GenerateMethodBody(module, func, il =>
                            {
                                var ctxPlace = new ArgPlace(DeclaringCompilation.CoreTypes.Context, 0);
                                var cg = new CodeGenerator(il, module, diagnostics, module.Compilation.Options.OptimizationLevel, false, field.ContainingType, ctxPlace, null)
                                {
                                    CallerType = ContainingType,
                                    ContainingFile = ContainingFile,
                                    IsInCachedArrayExpression = true,   // do not cache array initializers twice
                                };

                                // return {Initializer}
                                cg.EmitConvert(p.Initializer, func.ReturnType);
                                cg.EmitRet(func.ReturnType);

                            }, null, diagnostics, false));

                            module.SynthesizedManager.AddMethod(func.ContainingType, func);
                        }

                        using (var cg = new CodeGenerator(cctor, module, diagnostics, module.Compilation.Options.OptimizationLevel, false, field.ContainingType,
                                contextPlace: null,
                                thisPlace: null)
                        {
                            CallerType = ContainingType,
                            ContainingFile = ContainingFile,
                            IsInCachedArrayExpression = true,   // do not cache array initializers twice
                        })
                        {
                            var fldplace = new FieldPlace(null, field, module);
                            fldplace.EmitStorePrepare(cg.Builder);
                            if (func == null)
                            {
                                // {field} = {Initializer};
                                cg.EmitConvert(p.Initializer, field.Type);
                            }
                            else
                            {
                                MethodSymbol funcsymbol = func;

                                // bind func in case it is generic
                                if (func.ContainingType is SourceTraitTypeSymbol st)
                                {
                                    funcsymbol = func.AsMember(st.Construct(st.TypeArguments));
                                }

                                // Func<,>(object @object, IntPtr method)
                                var func_ctor = ((NamedTypeSymbol)field.Type).InstanceConstructors.Single(m =>
                                    m.ParameterCount == 2 &&
                                    m.Parameters[0].Type.SpecialType == SpecialType.System_Object &&
                                    m.Parameters[1].Type.SpecialType == SpecialType.System_IntPtr
                                );

                                // {field} = new Func<Context, PhpValue>( {func} )
                                cg.Builder.EmitNullConstant(); // null
                                cg.EmitOpCode(ILOpCode.Ldftn); // method
                                cg.EmitSymbolToken(funcsymbol, null);
                                cg.EmitCall(ILOpCode.Newobj, func_ctor);
                            }
                            fldplace.EmitStore(cg.Builder);
                        }
                    }
                }
            }
        }

        public virtual void Generate(CodeGenerator cg)
        {
            if (this.IsGeneratorMethod())
            {
                // generate method as a state machine (SM) in a separate synthesized method
                // this routine returns instance of new SM:
                GenerateGeneratorMethod(cg);
            }
            else
            {
                // normal method generation:
                cg.GenerateScope(this.ControlFlowGraph.Start, int.MaxValue);
            }
        }

        private void GenerateGeneratorMethod(CodeGenerator cg)
        {
            Debug.Assert(this.IsGeneratorMethod());

            var genSymbol = new SourceGeneratorSymbol(this);
            //var genConstructed = (genSymbol.ContainingType is SourceTraitTypeSymbol st)
            //    ? genSymbol.AsMember(st.Construct(st.TypeArguments))
            //    : genSymbol;

            var il = cg.Builder;

            /* Template:
             * return BuildGenerator( <ctx>, new PhpArray(){ p1, p2, ... }, new GeneratorStateMachineDelegate((IntPtr)<genSymbol>), (RuntimeMethodHandle)this )
             */

            cg.EmitLoadContext(); // ctx for generator

            // new PhpArray for generator's locals
            cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray);

            var generatorsLocals = cg.GetTemporaryLocal(cg.CoreTypes.PhpArray);
            cg.Builder.EmitLocalStore(generatorsLocals);

            // initialize parameters (set their _isOptimized and copy them to locals array)
            InitializeParametersForGeneratorMethod(cg, il, generatorsLocals);
            cg.Builder.EmitLoad(generatorsLocals);
            cg.ReturnTemporaryLocal(generatorsLocals);

            // new PhpArray for generator's synthesizedLocals
            cg.EmitCall(ILOpCode.Newobj, cg.CoreMethods.Ctors.PhpArray);

            // new GeneratorStateMachineDelegate(<genSymbol>) delegate for generator
            cg.Builder.EmitNullConstant(); // null
            cg.EmitOpCode(ILOpCode.Ldftn); // method
            cg.EmitSymbolToken(genSymbol, null);

            cg.EmitCall(ILOpCode.Newobj, cg.CoreTypes.GeneratorStateMachineDelegate.Ctor(cg.CoreTypes.Object, cg.CoreTypes.IntPtr)); // GeneratorStateMachineDelegate(object @object, IntPtr method)

            // handleof(this)
            cg.EmitLoadToken(this, null);

            // create generator object via Operators factory method
            cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.BuildGenerator_Context_PhpArray_PhpArray_GeneratorStateMachineDelegate_RuntimeMethodHandle);

            // .SetGeneratorThis( object ) : Generator
            if (!this.IsStatic || (this is SourceLambdaSymbol lambda && lambda.UseThis))
            {
                GetPhpThisVariablePlaceWithoutGenerator(cg.Module).EmitLoad(cg.Builder);
                cg.EmitCastClass(cg.DeclaringCompilation.GetSpecialType(SpecialType.System_Object));
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetGeneratorThis_Generator_Object)
                    .Expect(cg.CoreTypes.Generator);
            }

            // .SetGeneratorLazyStatic( PhpTypeInfo ) : Generator
            if ((this.Flags & RoutineFlags.UsesLateStatic) != 0 && this.IsStatic)
            {
                cg.EmitLoadStaticPhpTypeInfo();
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetGeneratorLazyStatic_Generator_PhpTypeInfo)
                    .Expect(cg.CoreTypes.Generator);
            }

            // .SetGeneratorDynamicScope( scope ) : Generator
            if (this is SourceLambdaSymbol lambda)
            {
                lambda.GetCallerTypePlace().EmitLoad(cg.Builder); // RuntimeTypeContext
                cg.EmitCall(ILOpCode.Call, cg.CoreMethods.Operators.SetGeneratorDynamicScope_Generator_RuntimeTypeHandle)
                    .Expect(cg.CoreTypes.Generator);
            }

            // Convert to return type (Generator or PhpValue, depends on analysis)
            cg.EmitConvert(cg.CoreTypes.Generator, 0, this.ReturnType);
            il.EmitRet(false);

            // Generate SM method. Must be generated after EmitInit of parameters (it sets their _isUnoptimized field).
            CreateStateMachineNextMethod(cg, genSymbol);
        }

        private void InitializeParametersForGeneratorMethod(CodeGenerator cg, Microsoft.CodeAnalysis.CodeGen.ILBuilder il, Microsoft.CodeAnalysis.CodeGen.LocalDefinition generatorsLocals)
        {
            // Emit init of unoptimized BoundParameters using separate CodeGenerator that has locals place pointing to our generator's locals array
            using (var localsArrayCg = new CodeGenerator(
                il, cg.Module, cg.Diagnostics,
                cg.DeclaringCompilation.Options.OptimizationLevel,
                cg.EmitPdbSequencePoints,
                this.ContainingType,
                contextPlace: cg.ContextPlaceOpt,
                thisPlace: null,
                routine: this, // needed to support static variables (they need enclosing routine while binding)
                locals: new LocalPlace(generatorsLocals),
                localsInitialized: false
                    ))
            {
                // EmitInit (for UnoptimizedLocals) copies arguments to locals array, does nothing for normal variables, handles local statics, global variables ...
                LocalsTable.Variables.ForEach(v => v.EmitInit(localsArrayCg));
            }
        }

        private void CreateStateMachineNextMethod(CodeGenerator cg, SourceGeneratorSymbol genSymbol)
        {
            cg.Module.SynthesizedManager.AddMethod(ContainingType, genSymbol); // save method symbol to module

            // generate generator's next method body
            var genMethodBody = MethodGenerator.GenerateMethodBody(cg.Module, genSymbol, (_il) =>
            {
                GenerateStateMachinesNextMethod(cg, _il, genSymbol);
            }
            , null, cg.Diagnostics, cg.EmitPdbSequencePoints);

            cg.Module.SetMethodBody(genSymbol, genMethodBody);
        }

        //Initialized a new CodeGenerator for generation of SourceGeneratorSymbol (state machine's next method)
        private void GenerateStateMachinesNextMethod(CodeGenerator cg, Microsoft.CodeAnalysis.CodeGen.ILBuilder _il, SourceGeneratorSymbol genSymbol)
        {
            // TODO: get correct ThisPlace, ReturnType etc. resolution & binding out of the box without GN_SGS hacks
            // using SourceGeneratorSymbol

            //Refactor parameters references to proper fields
            using (var stateMachineNextCg = new CodeGenerator(
                _il, cg.Module, cg.Diagnostics,
                cg.DeclaringCompilation.Options.OptimizationLevel,
                cg.EmitPdbSequencePoints,
                this.ContainingType,
                contextPlace: new ParamPlace(genSymbol.ContextParameter),
                thisPlace: new ParamPlace(genSymbol.ThisParameter),
                routine: this,
                locals: new ParamPlace(genSymbol.LocalsParameter),
                localsInitialized: true,
                tempLocals: new ParamPlace(genSymbol.TmpLocalsParameter)
                    )
            {
                GeneratorStateMachineMethod = genSymbol,    // Pass SourceGeneratorSymbol to CG for additional yield and StartBlock emit 
            })
            {
                stateMachineNextCg.GenerateScope(this.ControlFlowGraph.Start, int.MaxValue);
            }
        }
    }

    partial class SourceGlobalMethodSymbol
    {
        /// <summary>
        /// Real main method with <c>MainDelegate</c> signature.
        /// The method is generated lazily in order to provide method compatible with MainDelegate.
        /// <see cref="SourceGlobalMethodSymbol"/> may have (usually have) a different return type.
        /// </summary>
        internal SynthesizedMethodSymbol _mainMethod0;

        internal override IPlace GetThisPlace() => new ParamPlace(ThisParameter);

        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            //base.SynthesizeStubs(module, diagnostic);          // ghosts (always empty)

            // <Main>'0
            this.SynthesizeMainMethodWrapper(module, diagnostic);

            // no overloads synthesized for global code
            return Array.Empty<MethodSymbol>();
        }

        /// <summary>
        /// Main method wrapper in case it does not return PhpValue.
        /// </summary>
        void SynthesizeMainMethodWrapper(PEModuleBuilder module, DiagnosticBag diagnostics)
        {
            if (this.ReturnType != DeclaringCompilation.CoreTypes.PhpValue)
            {
                // PhpValue <Main>`0(parameters)
                var wrapper = new SynthesizedMethodSymbol(
                    this.ContainingFile, WellKnownPchpNames.GlobalRoutineName + "`0", true, false,
                    DeclaringCompilation.CoreTypes.PhpValue, Accessibility.Public);

                wrapper.SetParameters(this.Parameters.Select(p =>
                    new SynthesizedParameterSymbol(wrapper, p.Type, p.Ordinal, p.RefKind, p.Name)).ToArray());

                // save method symbol to module
                module.SynthesizedManager.AddMethod(this.ContainingFile, wrapper);

                // generate method body
                module.CreateMainMethodWrapper(wrapper, this, diagnostics);

                //
                _mainMethod0 = wrapper;
            }
        }
    }

    partial class SourceMethodSymbol
    {
        internal override IPlace GetContextPlace(PEModuleBuilder module)
        {
            var thisplace = GetThisPlace();
            if (thisplace != null)
            {
                // <this>.<ctx> in instance methods
                var t = (SourceTypeSymbol)this.ContainingType;

                var ctx_field = t.ContextStore;
                if (ctx_field != null)  // might be null in interfaces
                {
                    return new FieldPlace(thisplace, ctx_field, module);
                }
                else
                {
                    Debug.Assert(t.IsInterface);
                    return null;
                }
            }

            //
            return base.GetContextPlace(module);
        }

        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            // empty body for static abstract
            if (this.ControlFlowGraph == null && this.IsStatic)
            {
                SynthesizeEmptyBody(module, diagnostic);
            }

            //
            return base.SynthesizeStubs(module, diagnostic);
        }

        void SynthesizeEmptyBody(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            Debug.Assert(this.ControlFlowGraph == null);
            Debug.Assert(this.IsAbstract == false);

            module.SetMethodBody(this, MethodGenerator.GenerateMethodBody(module, this, (il) =>
            {
                var cg = new CodeGenerator(this, il, module, diagnostic, module.Compilation.Options.OptimizationLevel, false);

                // Template: return default(T)
                cg.EmitRetDefault();
            }, null, diagnostic, false));
        }
    }

    partial class SourceFunctionSymbol
    {
        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            var overloads = base.SynthesizeStubs(module, diagnostic);

            // synthesize RoutineInfo:
            var cctor = module.GetStaticCtorBuilder(_file);
            lock (cctor)
            {
                using (var cg = new CodeGenerator(
                        cctor, module, diagnostic, PhpOptimizationLevel.Release, false, this.ContainingType,
                        contextPlace: null, thisPlace: null, routine: this))
                {
                    var field = new FieldPlace(null, this.EnsureRoutineInfoField(module), module);

                    // {RoutineInfoField} = RoutineInfo.CreateUserRoutine(name, handle, overloads[])
                    field.EmitStorePrepare(cctor);

                    cctor.EmitStringConstant(this.QualifiedName.ToString());
                    cctor.EmitLoadToken(module, DiagnosticBag.GetInstance(), this, null);
                    cg.Emit_NewArray(cg.CoreTypes.RuntimeMethodHandle, overloads.AsImmutable(), m => cg.EmitLoadToken(m, null));

                    cctor.EmitCall(module, DiagnosticBag.GetInstance(), ILOpCode.Call, cg.CoreMethods.Reflection.CreateUserRoutine_string_RuntimeMethodHandle_RuntimeMethodHandleArr);

                    field.EmitStore(cctor);
                }
            }

            //
            return overloads;
        }
    }

    partial class SourceLambdaSymbol
    {
        internal override IPlace GetContextPlace(PEModuleBuilder module)
        {
            // Template: Operators.Context(<closure>)
            return new OperatorPlace(DeclaringCompilation.CoreMethods.Operators.Context_Closure, new ParamPlace(ClosureParameter));
        }

        internal override IPlace GetThisPlace()
        {
            if (UseThis)
            {
                // Template: Operators.Context(<closure>)
                return new OperatorPlace(DeclaringCompilation.CoreMethods.Operators.This_Closure, new ParamPlace(ClosureParameter));
            }

            return base.GetThisPlace();
        }

        internal override IPlace GetPhpThisVariablePlaceWithoutGenerator(PEModuleBuilder module = null)
        {
            return GetThisPlace();
        }

        internal IPlace GetCallerTypePlace()
        {
            // Template: Operators.Scope(<closure>)
            return new OperatorPlace(DeclaringCompilation.CoreMethods.Operators.Scope_Closure, new ParamPlace(ClosureParameter));
        }

        internal override IList<MethodSymbol> SynthesizeStubs(PEModuleBuilder module, DiagnosticBag diagnostic)
        {
            var overloads = base.SynthesizeStubs(module, diagnostic);

            // synthesize RoutineInfo:
            var cctor = module.GetStaticCtorBuilder(Container);
            lock (cctor)
            {
                var field = new FieldPlace(null, this.EnsureRoutineInfoField(module), module);

                var ct = module.Compilation.CoreTypes;

                // {RoutineInfoField} = new PhpAnonymousRoutineInfo(name, handle)
                field.EmitStorePrepare(cctor);

                cctor.EmitStringConstant(this.MetadataName);
                cctor.EmitLoadToken(module, DiagnosticBag.GetInstance(), this, null);
                cctor.EmitCall(module, DiagnosticBag.GetInstance(), ILOpCode.Call, ct.Operators.Method("AnonymousRoutine", ct.String, ct.RuntimeMethodHandle));

                field.EmitStore(cctor);
            }

            //
            return overloads;
        }
    }

    partial class SourceGeneratorSymbol
    {
        internal void EmitInit(PEModuleBuilder module)
        {
            // Don't need any initial emit
        }
    }
};
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs(7,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs(323,44): error CS0128: A local variable or function named 'lambda' is already defined in this scope,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs(325,17): error CS0165: Use of unassigned local variable 'lambda',D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\CodeGen\Symbols\SourceRoutineSymbol.cs(7,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Devsense.PHP.Syntax;
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Pchp.CodeAnalysis.Symbols;

namespace Pchp.CodeAnalysis.FlowAnalysis
{
    static class AnalysisFacts
    {
        public static bool IsAutoloadDeprecated(Version langVersion)
        {
            // >= 7.2
            return langVersion != null && langVersion.Major > 7 || (langVersion.Major == 7 && langVersion.Minor >= 2);
        }

        public static bool IsStringableSupported(PhpCompilation compilation)
        {
            // >= 8.0
            return
                compilation.CoreTypes.Stringable.Symbol is PENamedTypeSymbol pe &&
                pe.TryGetPhpTypeAttribute(out _, out var minLangVersion) &&
                minLangVersion != null &&
                compilation.Options.LanguageVersion >= minLangVersion;

            //var langVersion = compilation.Options.LanguageVersion;
            //return langVersion != null && langVersion.Major >= 8;
        }

        /// <summary>
        /// Determines if given global function symbol is unconditionally declared (always declared).
        /// </summary>
        static bool IsUnconditionalDeclaration(IPhpRoutineSymbol symbol)
        {
            // method declaration in a referenced assembly,
            // not within a compiled source script:
            if (symbol is PEMethodSymbol method)
            {
                var container = method.ContainingType;
                return container != null && !container.IsPhpSourceFile();   // only functions declared in libraries, not in PHP source file
            }

            // Ambiguity,
            // only if all possible symbols are unconditionally declared.
            if (symbol is AmbiguousMethodSymbol ambiguous)
            {
                foreach (var a in ambiguous.Ambiguities)
                {
                    if (!IsUnconditionalDeclaration(a))
                    {
                        return false;
                    }
                }

                return true;
            }

            //
            return false;
        }

        /// <summary>
        /// Resolves value of the function call in compile time if possible and updates the variable type if necessary
        /// </summary>
        public static void HandleSpecialFunctionCall<T>(BoundGlobalFunctionCall call, ExpressionAnalysis<T> analysis, ConditionBranch branch)
        {
            // Only direct function names
            if (!HasSimpleName(call, out string name))
            {
                return;
            }

            // Type checking functions
            if (branch != ConditionBranch.AnyResult && CanBeTypeCheckingFunction(call, name, out var arg))
            {
                if (HandleTypeCheckingFunctions(call, name, arg, analysis, branch))
                {
                    return;
                }
            }

            var args = call.ArgumentsInSourceOrder;

            // Clear out the constant value result from the previous run of this method (if it was valid, it will be reassigned below)
            call.ConstantValue = default;

            string str;

            switch (name) // TODO: case insensitive
            {
                case "is_callable":     // bool is_callable( string $function_name )
                case "function_exists": // bool function_exists ( string $function_name )
                    if (args.Length == 1 && args[0].Value.ConstantValue.TryConvertToString(out str))
                    {
                        // TRUE <=> function is defined unconditionally in a reference library (PE assembly)
                        if (IsUnconditionalDeclaration(analysis.Model.ResolveFunction(NameUtils.MakeQualifiedName(str, true))))
                        {
                            call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                        }
                    }
                    break;

                // bool class_exists ( string $class_name [, bool $autoload = true ] )
                case "class_exists":
                case "interface_exists":
                    if (args.Length >= 1)
                    {
                        // TRUE <=> class is defined unconditionally in a reference library (PE assembly)
                        var class_name = args[0].Value.ConstantValue.Value as string;
                        if (!string.IsNullOrEmpty(class_name))
                        {
                            var tmp = (TypeSymbol)analysis.Model.ResolveType(NameUtils.MakeQualifiedName(class_name, true));
                            if (tmp is PENamedTypeSymbol && !tmp.IsPhpUserType())   // TODO: + SourceTypeSymbol when reachable unconditional declaration
                            {
                                bool @interface = (name == "interface_exists");
                                if (tmp.TypeKind == (@interface ? TypeKind.Interface : TypeKind.Class))
                                {
                                    call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                                }
                            }
                        }
                    }
                    break;

                // bool method_exists ( string $class_name , string $method_name )
                case "method_exists":
                    if (args.Length == 2)
                    {
                        var class_name = args[0].Value.ConstantValue.Value as string;
                        if (class_name != null && args[1].Value.ConstantValue.TryConvertToString(out str))
                        {
                            var tmp = (NamedTypeSymbol)analysis.Model.ResolveType(NameUtils.MakeQualifiedName(class_name, true));
                            if (tmp is PENamedTypeSymbol && !tmp.IsPhpUserType())
                            {
                                if (tmp.LookupMethods(str).Count != 0) // TODO: why not User Types // TODO: why not resolve FALSE as well below?
                                {
                                    call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                                }
                            }
                        }
                    }
                    break;

                case "defined":     // defined(CONST_NAME)
                case "constant":    // constant(CONST_NAME)
                    if (args.Length == 1 && args[0].Value.ConstantValue.TryConvertToString(out str))
                    {
                        // TODO: const_name in form of "{CLASS}::{NAME}"
                        // TODO: also user constants defined in the same scope?

                        // quick evaluation of PE constants that can't be changed at run time

                        var tmp = analysis.Model.ResolveConstant(str);
                        if (tmp is PEFieldSymbol fld)
                        {
                            if (name == "defined")
                            {
                                call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                            }
                            else // name == "constant"
                            {
                                if (fld.Type.Is_Func_Context_TResult(out var tresult))
                                {
                                    call.TypeRefMask = TypeRefFactory.CreateMask(analysis.TypeCtx, tresult);
                                }
                                else
                                {
                                    var cvalue = fld.GetConstantValue(false);
                                    call.ConstantValue = (cvalue != null) ? new Optional<object>(cvalue.Value) : null;
                                    call.TypeRefMask = TypeRefFactory.CreateMask(analysis.TypeCtx, fld.Type, notNull: fld.IsNotNull());
                                }
                            }
                        }
                        else if (tmp is PEPropertySymbol prop)
                        {
                            if (name == "defined")
                            {
                                call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                            }
                            else // name == "constant"
                            {
                                call.TypeRefMask = TypeRefFactory.CreateMask(analysis.TypeCtx, prop.Type, notNull: prop.IsNotNull());
                            }
                        }
                    }
                    break;

                case "strlen":
                    if (args.Length == 1 && args[0].Value.ConstantValue.TryConvertToString(out string value))
                    {
                        call.ConstantValue = new Optional<object>(value.Length);
                    }
                    break;

                case "file_exists":
                    if (args.Length == 1)
                    {
                        if (TryResolveFile(analysis.Model, analysis.Routine, args[0].Value, out var script))
                        {
                            // there is compiled script at this path,
                            // the expression will be always true
                            call.ConstantValue = true.AsOptional();
                        }
                    }
                    break;
            }
        }

        public static bool TryResolveFile(ISymbolProvider model, SourceRoutineSymbol routine, BoundExpression expr, out IPhpScriptTypeSymbol script)
        {
            script = null;

            if (expr.ConstantValue.TryConvertToString(out var path))
            {
                // include (path)
                script = model.ResolveFile(path);
            }
            else if (expr is BoundPseudoConst pc1 && pc1.ConstType == BoundPseudoConst.Types.File) // __FILE__
            {
                script = routine.ContainingFile;
            }
            else if (expr is BoundConcatEx concat) // common case
            {
                // include (dirname( __FILE__ ) . path) // changed to (__DIR__ . path) by graph rewriter
                // include (__DIR__ . path)
                if (concat.ArgumentsInSourceOrder.Length == 2 &&
                    concat.ArgumentsInSourceOrder[0].Value is BoundPseudoConst pc && pc.ConstType == BoundPseudoConst.Types.Dir &&
                    concat.ArgumentsInSourceOrder[1].Value.ConstantValue.TryConvertToString(out path))
                {
                    // create project relative path
                    // not starting with a directory separator!
                    path = routine.ContainingFile.DirectoryRelativePath + path;
                    if (path.Length != 0 && Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(path[0])) path = path.Substring(1);   // make nicer when we have a helper method for that
                    script = model.ResolveFile(path);
                }
                else // include (RootPath . path)
                if (concat.ArgumentsInSourceOrder.Length == 2 &&
                    concat.ArgumentsInSourceOrder[0].Value is BoundPseudoConst pc2 && pc2.ConstType == BoundPseudoConst.Types.RootPath &&
                    concat.ArgumentsInSourceOrder[1].Value.ConstantValue.TryConvertToString(out path))
                {
                    // create project relative path
                    // not starting with a directory separator!
                    if (path.Length != 0 && Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(path[0])) path = path.Substring(1);   // make nicer when we have a helper method for that
                    script = model.ResolveFile(path);
                }
            }

            return script != null;
        }

        public static bool HasSimpleName(BoundGlobalFunctionCall call, out string name)
        {
            if (call.Name.IsDirect)
            {
                // Take the function name ignoring current namespace resolution, simple names only:
                var qualifiedName = call.NameOpt ?? call.Name.NameValue;
                if (qualifiedName.IsSimpleName)
                {
                    name = qualifiedName.Name.Value;
                    return true;
                }
            }

            name = null;
            return false;
        }

        private static bool CanBeTypeCheckingFunction(BoundGlobalFunctionCall call, string name, out BoundVariableRef arg)
        {
            if (name.StartsWith("is_") && call.ArgumentsInSourceOrder.Length == 1
                && call.ArgumentsInSourceOrder[0].Value is BoundVariableRef onlyArg)
            {
                arg = onlyArg;
                return true;
            }
            else
            {
                arg = null;
                return false;
            }
        }

        /// <summary>
        /// Processes functions such as is_int, is_bool etc. Returns whether the function was one of these.
        /// </summary>
        private static bool HandleTypeCheckingFunctions<T>(
            BoundGlobalFunctionCall call,
            string name,
            BoundVariableRef arg,
            ExpressionAnalysis<T> analysis,
            ConditionBranch branch)
        {
            var typeCtx = analysis.TypeCtx;
            var flowState = analysis.State;

            switch (name)
            {
                case "is_int":
                case "is_integer":
                case "is_long":
                    HandleTypeCheckingExpression(arg, typeCtx.GetLongTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_bool":
                    HandleTypeCheckingExpression(arg, typeCtx.GetBooleanTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_float":
                case "is_double":
                case "is_real":
                    HandleTypeCheckingExpression(arg, typeCtx.GetDoubleTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_string":
                    var stringMask = typeCtx.GetStringTypeMask() | typeCtx.GetWritableStringTypeMask();
                    HandleTypeCheckingExpression(arg, stringMask, branch, flowState, checkExpr: call);
                    return true;

                case "is_resource":
                    HandleTypeCheckingExpression(arg, typeCtx.GetResourceTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_null":
                    HandleTypeCheckingExpression(arg, typeCtx.GetNullTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_array":
                    HandleTypeCheckingExpression(
                        arg,
                        currentType => typeCtx.GetArraysFromMask(currentType),
                        branch,
                        flowState,
                        skipPositiveIfAnyType: true,
                        checkExpr: call);
                    return true;

                case "is_object":
                    // Keep IncludesSubclasses flag in the true branch and clear it in the false branch
                    HandleTypeCheckingExpression(
                        arg,
                        currentType =>
                        {
                            var objType = currentType.IsAnyType
                            ? typeCtx.GetSystemObjectTypeMask()
                            : typeCtx.GetObjectsFromMask(currentType);
                            
                            return objType.WithSubclasses;
                        },
                        branch,
                        flowState,
                        skipPositiveIfAnyType: false,
                        checkExpr: call);
                    return true;

                // TODO
                //case "is_scalar":
                //    return;

                case "is_numeric":
                    HandleTypeCheckingExpression(
                        arg,
                        currentType =>
                        {
                            // Specify numeric types if they are present 
                            var targetType = typeCtx.IsLong(currentType) ? typeCtx.GetLongTypeMask() : 0;
                            targetType |= typeCtx.IsDouble(currentType) ? typeCtx.GetDoubleTypeMask() : 0;

                            if (branch == ConditionBranch.ToTrue)
                            {
                                // Also string types can make is_numeric return true, but not anything else
                                targetType |= typeCtx.IsReadonlyString(currentType) ? typeCtx.GetStringTypeMask() : 0;
                                targetType |= typeCtx.IsWritableString(currentType) ? typeCtx.GetWritableStringTypeMask() : 0;

                                return targetType;
                            }
                            else
                            {
                                // For number, is_numeric always returns true -> remove numeric types from false branch
                                return targetType;
                            }
                        },
                        branch,
                        flowState,
                        skipPositiveIfAnyType: true,
                        checkExpr: call);
                    return true;

                case "is_callable":
                    HandleTypeCheckingExpression(
                        arg,
                        currentType =>
                        {
                            // Closure and lambdas are specified in both branches
                            TypeRefMask targetType = typeCtx.GetClosureTypeMask();
                            targetType |= typeCtx.GetLambdasFromMask(currentType);

                            if (branch == ConditionBranch.ToTrue)
                            {
                                // Also string types, arrays and objects can make is_callable return true, but not anything else
                                targetType |= typeCtx.IsReadonlyString(currentType) ? typeCtx.GetStringTypeMask() : 0;
                                targetType |= typeCtx.IsWritableString(currentType) ? typeCtx.GetWritableStringTypeMask() : 0;
                                targetType |= typeCtx.GetArraysFromMask(currentType);
                                targetType |= typeCtx.GetObjectsFromMask(currentType);

                                return targetType;
                            }
                            else
                            {
                                // For closure and lambdas, is_callable always returns true -> remove them from false branch,
                                // don't remove IncludeSubclasses flag
                                return targetType;
                            }
                        },
                        branch,
                        flowState,
                        skipPositiveIfAnyType: true,
                        checkExpr: call);
                    return true;

                // TODO
                //case "is_iterable":
                //    return;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Ensures that the variable is of the given type(s) in the positive branch or not of this type in the negative
        /// branch. If the current branch is unfeasible, assigns an appropriate boolean to the
        /// <see cref="BoundExpression.ConstantValue"/> of <paramref name="checkExpr"/>.
        /// </summary>
        /// <param name="varRef">The reference to the variable whose types to check.</param>
        /// <param name="targetType">The target type of the variable.</param>
        /// <param name="branch">The branch to check - <see cref="ConditionBranch.ToTrue"/> is understood as the positive
        /// branch if <paramref name="isPositiveCheck"/> is true.</param>
        /// <param name="flowState">The flow state of the branch.</param>
        /// <param name="skipPositiveIfAnyType">Whether to skip a mask with <see cref="TypeRefMask.IsAnyType"/> in the
        /// positive branch (in the negative branch, it is always skipped).</param>
        /// <param name="checkExpr">The expression to have its <see cref="BoundExpression.ConstantValue"/> potentially
        /// updated.</param>
        /// <param name="isPositiveCheck">Whether the expression returns true when the type check succeeds. For example,
        /// in the case of != it would be false.</param>
        public static void HandleTypeCheckingExpression(
            BoundVariableRef varRef,
            TypeRefMask targetType,
            ConditionBranch branch,
            FlowState flowState,
            bool skipPositiveIfAnyType = false,
            BoundExpression checkExpr = null,
            bool isPositiveCheck = true)
        {
            HandleTypeCheckingExpression(varRef, (var) => targetType, branch, flowState, skipPositiveIfAnyType, checkExpr, isPositiveCheck);
        }

        /// <summary>
        /// Ensures that the variable is of the given type(s) in the positive branch or not of this type in the negative
        /// branch. If the current branch is unfeasible, assigns an appropriate boolean to the
        /// <see cref="BoundExpression.ConstantValue"/> of <paramref name="checkExpr"/>.
        /// </summary>
        /// <param name="varRef">The reference to the variable whose types to check.</param>
        /// <param name="targetTypeCallback">The callback that receives the current type mask of the variable and returns
        /// the target one.</param>
        /// <param name="branch">The branch to check - <see cref="ConditionBranch.ToTrue"/> is understood as the positive
        /// branch if <paramref name="isPositiveCheck"/> is true.</param>
        /// <param name="flowState">The flow state of the branch.</param>
        /// <param name="skipPositiveIfAnyType">Whether to skip a mask with <see cref="TypeRefMask.IsAnyType"/> in the
        /// positive branch (in the negative branch, it is always skipped).</param>
        /// <param name="checkExpr">The expression to have its <see cref="BoundExpression.ConstantValue"/> potentially
        /// updated.</param>
        /// <param name="isPositiveCheck">Whether the expression returns true when the type check succeeds. For example,
        /// in the case of != it would be false.</param>
        public static void HandleTypeCheckingExpression(
            BoundVariableRef varRef,
            Func<TypeRefMask, TypeRefMask> targetTypeCallback,
            ConditionBranch branch,
            FlowState flowState,
            bool skipPositiveIfAnyType = false,
            BoundExpression checkExpr = null,
            bool isPositiveCheck = true)
        {
            if (!TryGetVariableHandle(varRef.Variable, flowState, out var handle))
            {
                return;
            }

            var currentType = flowState.GetLocalType(handle);
            var targetType = targetTypeCallback(currentType);

            // Model negative type checks (such as $x != null) by inverting branches for the core checking function
            var branchHlp = isPositiveCheck ? branch : branch.NegativeBranch();

            bool isFeasible = HandleTypeChecking(currentType, targetType, branchHlp, flowState, handle, skipPositiveIfAnyType);

            // If the constant value was not meant to be updated, skip its computation
            if (checkExpr == null)
            {
                return;
            }

            if (!currentType.IsRef)
            {
                // If the true branch proves to be unfeasible, the function always returns false and vice versa
                var resultConstVal = isFeasible ? default(Optional<object>) : new Optional<object>(!branch.TargetValue().Value);

                // Each branch can clean only the constant value it produced during its analysis (in order not to lose result
                // of the other branch): true branch can produce false value and vice versa
                if (!resultConstVal.EqualsOptional(checkExpr.ConstantValue)
                    && (resultConstVal.HasValue
                        || checkExpr.ConstantValue.Value is false && branch == ConditionBranch.ToTrue
                        || checkExpr.ConstantValue.Value is true && branch == ConditionBranch.ToFalse))
                {
                    checkExpr.ConstantValue = resultConstVal;
                }
            }
            else
            {
                // We cannot reason about the result of the check if the variable can be modified by reference
                checkExpr.ConstantValue = default(Optional<object>);
            }
        }

        private static bool TryGetVariableHandle(IVariableReference boundvar, FlowState state, out VariableHandle varHandle)
        {
            if (boundvar is LocalVariableReference local && local.BoundName.IsDirect)  // direct variable name
            {
                if (local.VariableKind == VariableKind.LocalVariable ||
                    local.VariableKind == VariableKind.Parameter ||
                    local.VariableKind == VariableKind.LocalTemporalVariable)
                {
                    varHandle = state.GetLocalHandle(local.BoundName.NameValue);
                    return true;
                }
            }

            //
            varHandle = default(VariableHandle);
            return false;
        }

        private static bool HandleTypeChecking(
            TypeRefMask currentType,
            TypeRefMask targetType,
            ConditionBranch branch,
            FlowState flowState,
            VariableHandle handle,
            bool skipTrueIfAnyType)
        {
            // Information whether this path can ever be taken
            bool isFeasible = true;

            if (branch == ConditionBranch.ToTrue)
            {
                // In the true branch the IsAnyType case can be optionally skipped
                if (skipTrueIfAnyType && currentType.IsAnyType)
                {
                    return isFeasible;
                }

                // Intersect the possible types with those checked by the function, always keeping the IsRef flag.
                // IncludesSubclasses is kept only if it is specified in targetType.
                TypeRefMask resultType = (currentType & (targetType | TypeRefMask.IsRefMask));

                if (resultType.IsVoid)
                {
                    // Clearing the type out in this branch means the variable will never be of that type.
                    // In order to prevent errors in analysis and code generation, set the type to the one specified.
                    resultType = targetType | (currentType & TypeRefMask.IsRefMask);

                    isFeasible = false;
                }

                flowState.SetLocalType(handle, resultType);
            }
            else
            {
                Debug.Assert(branch == ConditionBranch.ToFalse);

                // In the false branch we cannot handle the IsAnyType case
                if (currentType.IsAnyType)
                {
                    return isFeasible;
                }

                // Remove the types and flags excluded by the fact that the function returned false
                TypeRefMask resultType = currentType & (~targetType);

                if (resultType.IsVoid)
                {
                    // Clearing the type out in this branch means the variable will always be of that type
                    // In order to prevent errors in analysis and code generation, do not alter the type in this case.

                    isFeasible = false;
                }
                else
                {
                    flowState.SetLocalType(handle, resultType);
                }
            }

            return isFeasible;
        }

        /// <summary>
        /// Returns whether the given type can be used as an array key.
        /// </summary>
        public static bool IsValidKeyType(IBoundTypeRef type)
        {
            if (type is BoundPrimitiveTypeRef pt)
            {
                switch (pt.TypeCode)
                {
                    case PhpTypeCode.Boolean:
                    case PhpTypeCode.Long:
                    case PhpTypeCode.Double:
                    case PhpTypeCode.String:
                    case PhpTypeCode.WritableString:
                    case PhpTypeCode.Null:
                    case PhpTypeCode.Mixed:
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// If present, transforms the given constant value to a string corresponding to the key under which the item is stored in an array.
        /// </summary>
        /// <param name="keyConst">Constant value of the key.</param>
        /// <param name="key">If <paramref name="keyConst"/> contains a value, the key as a (string, long) tuple.
        /// The second item should be taken into account only if the first one is null.</param>
        /// <returns>Whether the value was constant at all.</returns>
        public static bool TryGetCanonicKeyStringConstant(Optional<object> keyConst, out (string, long) key)
        {
            if (!keyConst.HasValue)
            {
                key = default;
                return false;
            }

            var obj = keyConst.Value;

            if (obj == null)
            {
                key = ("", default);
            }
            else if (keyConst.TryConvertToLong(out long l))
            {
                key = (null, l);
            }
            else if (obj is string s)
            {
                key = (s, default);
            }
            else
            {
                key = default;
                return false;
            }

            return true;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Devsense.PHP.Syntax;
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Pchp.CodeAnalysis.Symbols;

namespace Pchp.CodeAnalysis.FlowAnalysis
{
    static class AnalysisFacts
    {
        public static bool IsAutoloadDeprecated(Version langVersion)
        {
            // >= 7.2
            return langVersion != null && langVersion.Major > 7 || (langVersion.Major == 7 && langVersion.Minor >= 2);
        }

        public static bool IsStringableSupported(PhpCompilation compilation)
        {
            // >= 8.0
            return
                compilation.CoreTypes.Stringable.Symbol is PENamedTypeSymbol pe &&
                pe.TryGetPhpTypeAttribute(out _, out var minLangVersion) &&
                minLangVersion != null &&
                compilation.Options.LanguageVersion >= minLangVersion;

            //var langVersion = compilation.Options.LanguageVersion;
            //return langVersion != null && langVersion.Major >= 8;
        }

        /// <summary>
        /// Determines if given global function symbol is unconditionally declared (always declared).
        /// </summary>
        static bool IsUnconditionalDeclaration(IPhpRoutineSymbol symbol)
        {
            // method declaration in a referenced assembly,
            // not within a compiled source script:
            if (symbol is PEMethodSymbol method)
            {
                var container = method.ContainingType;
                return container != null && !container.IsPhpSourceFile();   // only functions declared in libraries, not in PHP source file
            }

            // Ambiguity,
            // only if all possible symbols are unconditionally declared.
            if (symbol is AmbiguousMethodSymbol ambiguous)
            {
                foreach (var a in ambiguous.Ambiguities)
                {
                    if (!IsUnconditionalDeclaration(a))
                    {
                        return false;
                    }
                }

                return true;
            }

            //
            return false;
        }

        /// <summary>
        /// Resolves value of the function call in compile time if possible and updates the variable type if necessary
        /// </summary>
        public static void HandleSpecialFunctionCall<T>(BoundGlobalFunctionCall call, ExpressionAnalysis<T> analysis, ConditionBranch branch)
        {
            // Only direct function names
            if (!HasSimpleName(call, out string name))
            {
                return;
            }

            // Type checking functions
            if (branch != ConditionBranch.AnyResult && CanBeTypeCheckingFunction(call, name, out var arg))
            {
                if (HandleTypeCheckingFunctions(call, name, arg, analysis, branch))
                {
                    return;
                }
            }

            var args = call.ArgumentsInSourceOrder;

            // Clear out the constant value result from the previous run of this method (if it was valid, it will be reassigned below)
            call.ConstantValue = default;

            string str;

            switch (name) // TODO: case insensitive
            {
                case "is_callable":     // bool is_callable( string $function_name )
                case "function_exists": // bool function_exists ( string $function_name )
                    if (args.Length == 1 && args[0].Value.ConstantValue.TryConvertToString(out str))
                    {
                        // TRUE <=> function is defined unconditionally in a reference library (PE assembly)
                        if (IsUnconditionalDeclaration(analysis.Model.ResolveFunction(NameUtils.MakeQualifiedName(str, true))))
                        {
                            call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                        }
                    }
                    break;

                // bool class_exists ( string $class_name [, bool $autoload = true ] )
                case "class_exists":
                case "interface_exists":
                    if (args.Length >= 1)
                    {
                        // TRUE <=> class is defined unconditionally in a reference library (PE assembly)
                        if (!string.IsNullOrEmpty(class_name))
                        {
                            var tmp = (TypeSymbol)analysis.Model.ResolveType(NameUtils.MakeQualifiedName(class_name, true));
                            if (tmp is PENamedTypeSymbol && !tmp.IsPhpUserType())   // TODO: + SourceTypeSymbol when reachable unconditional declaration
                            {
                                bool @interface = (name == "interface_exists");
                                if (tmp.TypeKind == (@interface ? TypeKind.Interface : TypeKind.Class))
                                {
                                    call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                                }
                            }
                        }
                    }
                    break;

                // bool method_exists ( string $class_name , string $method_name )
                case "method_exists":
                    if (args.Length == 2)
                    {
                        if (args[0].Value.ConstantValue.Value is string class_name && args[1].Value.ConstantValue.TryConvertToString(out str))
                        {
                            var tmp = (NamedTypeSymbol)analysis.Model.ResolveType(NameUtils.MakeQualifiedName(class_name, true));
                            if (tmp is PENamedTypeSymbol && !tmp.IsPhpUserType())
                            {
                                if (tmp.LookupMethods(str).Count != 0) // TODO: why not User Types // TODO: why not resolve FALSE as well below?
                                {
                                    call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                                }
                            }
                        }
                    }
                    break;

                case "defined":     // defined(CONST_NAME)
                case "constant":    // constant(CONST_NAME)
                    if (args.Length == 1 && args[0].Value.ConstantValue.TryConvertToString(out str))
                    {
                        // TODO: const_name in form of "{CLASS}::{NAME}"
                        // TODO: also user constants defined in the same scope?

                        // quick evaluation of PE constants that can't be changed at run time

                        var tmp = analysis.Model.ResolveConstant(str);
                        if (tmp is PEFieldSymbol fld)
                        {
                            if (name == "defined")
                            {
                                call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                            }
                            else // name == "constant"
                            {
                                if (fld.Type.Is_Func_Context_TResult(out var tresult))
                                {
                                    call.TypeRefMask = TypeRefFactory.CreateMask(analysis.TypeCtx, tresult);
                                }
                                else
                                {
                                    var cvalue = fld.GetConstantValue(false);
                                    call.ConstantValue = (cvalue != null) ? new Optional<object>(cvalue.Value) : null;
                                    call.TypeRefMask = TypeRefFactory.CreateMask(analysis.TypeCtx, fld.Type, notNull: fld.IsNotNull());
                                }
                            }
                        }
                        else if (tmp is PEPropertySymbol prop)
                        {
                            if (name == "defined")
                            {
                                call.ConstantValue = ConstantValueExtensions.AsOptional(true);
                            }
                            else // name == "constant"
                            {
                                call.TypeRefMask = TypeRefFactory.CreateMask(analysis.TypeCtx, prop.Type, notNull: prop.IsNotNull());
                            }
                        }
                    }
                    break;

                case "strlen":
                    if (args.Length == 1 && args[0].Value.ConstantValue.TryConvertToString(out string value))
                    {
                        call.ConstantValue = new Optional<object>(value.Length);
                    }
                    break;

                case "file_exists":
                    if (args.Length == 1)
                    {
                        if (TryResolveFile(analysis.Model, analysis.Routine, args[0].Value, out var script))
                        {
                            // there is compiled script at this path,
                            // the expression will be always true
                            call.ConstantValue = true.AsOptional();
                        }
                    }
                    break;
            }
        }

        public static bool TryResolveFile(ISymbolProvider model, SourceRoutineSymbol routine, BoundExpression expr, out IPhpScriptTypeSymbol script)
        {
            script = null;

            if (expr.ConstantValue.TryConvertToString(out var path))
            {
                // include (path)
                script = model.ResolveFile(path);
            }
            else if (expr is BoundPseudoConst pc1 && pc1.ConstType == BoundPseudoConst.Types.File) // __FILE__
            {
                script = routine.ContainingFile;
            }
            else if (expr is BoundConcatEx concat) // common case
            {
                // include (dirname( __FILE__ ) . path) // changed to (__DIR__ . path) by graph rewriter
                // include (__DIR__ . path)
                if (concat.ArgumentsInSourceOrder.Length == 2 &&
                    concat.ArgumentsInSourceOrder[0].Value is BoundPseudoConst pc && pc.ConstType == BoundPseudoConst.Types.Dir &&
                    concat.ArgumentsInSourceOrder[1].Value.ConstantValue.TryConvertToString(out path))
                {
                    // create project relative path
                    // not starting with a directory separator!
                    path = routine.ContainingFile.DirectoryRelativePath + path;
                    if (path.Length != 0 && Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(path[0])) path = path.Substring(1);   // make nicer when we have a helper method for that
                    script = model.ResolveFile(path);
                }
                else // include (RootPath . path)
                if (concat.ArgumentsInSourceOrder.Length == 2 &&
                    concat.ArgumentsInSourceOrder[0].Value is BoundPseudoConst pc2 && pc2.ConstType == BoundPseudoConst.Types.RootPath &&
                    concat.ArgumentsInSourceOrder[1].Value.ConstantValue.TryConvertToString(out path))
                {
                    // create project relative path
                    // not starting with a directory separator!
                    if (path.Length != 0 && Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(path[0])) path = path.Substring(1);   // make nicer when we have a helper method for that
                    script = model.ResolveFile(path);
                }
            }

            return script != null;
        }

        public static bool HasSimpleName(BoundGlobalFunctionCall call, out string name)
        {
            if (call.Name.IsDirect)
            {
                // Take the function name ignoring current namespace resolution, simple names only:
                var qualifiedName = call.NameOpt ?? call.Name.NameValue;
                if (qualifiedName.IsSimpleName)
                {
                    name = qualifiedName.Name.Value;
                    return true;
                }
            }

            name = null;
            return false;
        }

        private static bool CanBeTypeCheckingFunction(BoundGlobalFunctionCall call, string name, out BoundVariableRef arg)
        {
            if (name.StartsWith("is_") && call.ArgumentsInSourceOrder.Length == 1
                && call.ArgumentsInSourceOrder[0].Value is BoundVariableRef onlyArg)
            {
                arg = onlyArg;
                return true;
            }
            else
            {
                arg = null;
                return false;
            }
        }

        /// <summary>
        /// Processes functions such as is_int, is_bool etc. Returns whether the function was one of these.
        /// </summary>
        private static bool HandleTypeCheckingFunctions<T>(
            BoundGlobalFunctionCall call,
            string name,
            BoundVariableRef arg,
            ExpressionAnalysis<T> analysis,
            ConditionBranch branch)
        {
            var typeCtx = analysis.TypeCtx;
            var flowState = analysis.State;

            switch (name)
            {
                case "is_int":
                case "is_integer":
                case "is_long":
                    HandleTypeCheckingExpression(arg, typeCtx.GetLongTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_bool":
                    HandleTypeCheckingExpression(arg, typeCtx.GetBooleanTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_float":
                case "is_double":
                case "is_real":
                    HandleTypeCheckingExpression(arg, typeCtx.GetDoubleTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_string":
                    var stringMask = typeCtx.GetStringTypeMask() | typeCtx.GetWritableStringTypeMask();
                    HandleTypeCheckingExpression(arg, stringMask, branch, flowState, checkExpr: call);
                    return true;

                case "is_resource":
                    HandleTypeCheckingExpression(arg, typeCtx.GetResourceTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_null":
                    HandleTypeCheckingExpression(arg, typeCtx.GetNullTypeMask(), branch, flowState, checkExpr: call);
                    return true;

                case "is_array":
                    HandleTypeCheckingExpression(
                        arg,
                        currentType => typeCtx.GetArraysFromMask(currentType),
                        branch,
                        flowState,
                        skipPositiveIfAnyType: true,
                        checkExpr: call);
                    return true;

                case "is_object":
                    // Keep IncludesSubclasses flag in the true branch and clear it in the false branch
                    HandleTypeCheckingExpression(
                        arg,
                        currentType =>
                        {
                            var objType = currentType.IsAnyType
                            ? typeCtx.GetSystemObjectTypeMask()
                            : typeCtx.GetObjectsFromMask(currentType);
                            
                            return objType.WithSubclasses;
                        },
                        branch,
                        flowState,
                        skipPositiveIfAnyType: false,
                        checkExpr: call);
                    return true;

                // TODO
                //case "is_scalar":
                //    return;

                case "is_numeric":
                    HandleTypeCheckingExpression(
                        arg,
                        currentType =>
                        {
                            // Specify numeric types if they are present 
                            var targetType = typeCtx.IsLong(currentType) ? typeCtx.GetLongTypeMask() : 0;
                            targetType |= typeCtx.IsDouble(currentType) ? typeCtx.GetDoubleTypeMask() : 0;

                            if (branch == ConditionBranch.ToTrue)
                            {
                                // Also string types can make is_numeric return true, but not anything else
                                targetType |= typeCtx.IsReadonlyString(currentType) ? typeCtx.GetStringTypeMask() : 0;
                                targetType |= typeCtx.IsWritableString(currentType) ? typeCtx.GetWritableStringTypeMask() : 0;

                                return targetType;
                            }
                            else
                            {
                                // For number, is_numeric always returns true -> remove numeric types from false branch
                                return targetType;
                            }
                        },
                        branch,
                        flowState,
                        skipPositiveIfAnyType: true,
                        checkExpr: call);
                    return true;

                case "is_callable":
                    HandleTypeCheckingExpression(
                        arg,
                        currentType =>
                        {
                            // Closure and lambdas are specified in both branches
                            TypeRefMask targetType = typeCtx.GetClosureTypeMask();
                            targetType |= typeCtx.GetLambdasFromMask(currentType);

                            if (branch == ConditionBranch.ToTrue)
                            {
                                // Also string types, arrays and objects can make is_callable return true, but not anything else
                                targetType |= typeCtx.IsReadonlyString(currentType) ? typeCtx.GetStringTypeMask() : 0;
                                targetType |= typeCtx.IsWritableString(currentType) ? typeCtx.GetWritableStringTypeMask() : 0;
                                targetType |= typeCtx.GetArraysFromMask(currentType);
                                targetType |= typeCtx.GetObjectsFromMask(currentType);

                                return targetType;
                            }
                            else
                            {
                                // For closure and lambdas, is_callable always returns true -> remove them from false branch,
                                // don't remove IncludeSubclasses flag
                                return targetType;
                            }
                        },
                        branch,
                        flowState,
                        skipPositiveIfAnyType: true,
                        checkExpr: call);
                    return true;

                // TODO
                //case "is_iterable":
                //    return;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Ensures that the variable is of the given type(s) in the positive branch or not of this type in the negative
        /// branch. If the current branch is unfeasible, assigns an appropriate boolean to the
        /// <see cref="BoundExpression.ConstantValue"/> of <paramref name="checkExpr"/>.
        /// </summary>
        /// <param name="varRef">The reference to the variable whose types to check.</param>
        /// <param name="targetType">The target type of the variable.</param>
        /// <param name="branch">The branch to check - <see cref="ConditionBranch.ToTrue"/> is understood as the positive
        /// branch if <paramref name="isPositiveCheck"/> is true.</param>
        /// <param name="flowState">The flow state of the branch.</param>
        /// <param name="skipPositiveIfAnyType">Whether to skip a mask with <see cref="TypeRefMask.IsAnyType"/> in the
        /// positive branch (in the negative branch, it is always skipped).</param>
        /// <param name="checkExpr">The expression to have its <see cref="BoundExpression.ConstantValue"/> potentially
        /// updated.</param>
        /// <param name="isPositiveCheck">Whether the expression returns true when the type check succeeds. For example,
        /// in the case of != it would be false.</param>
        public static void HandleTypeCheckingExpression(
            BoundVariableRef varRef,
            TypeRefMask targetType,
            ConditionBranch branch,
            FlowState flowState,
            bool skipPositiveIfAnyType = false,
            BoundExpression checkExpr = null,
            bool isPositiveCheck = true)
        {
            HandleTypeCheckingExpression(varRef, (var) => targetType, branch, flowState, skipPositiveIfAnyType, checkExpr, isPositiveCheck);
        }

        /// <summary>
        /// Ensures that the variable is of the given type(s) in the positive branch or not of this type in the negative
        /// branch. If the current branch is unfeasible, assigns an appropriate boolean to the
        /// <see cref="BoundExpression.ConstantValue"/> of <paramref name="checkExpr"/>.
        /// </summary>
        /// <param name="varRef">The reference to the variable whose types to check.</param>
        /// <param name="targetTypeCallback">The callback that receives the current type mask of the variable and returns
        /// the target one.</param>
        /// <param name="branch">The branch to check - <see cref="ConditionBranch.ToTrue"/> is understood as the positive
        /// branch if <paramref name="isPositiveCheck"/> is true.</param>
        /// <param name="flowState">The flow state of the branch.</param>
        /// <param name="skipPositiveIfAnyType">Whether to skip a mask with <see cref="TypeRefMask.IsAnyType"/> in the
        /// positive branch (in the negative branch, it is always skipped).</param>
        /// <param name="checkExpr">The expression to have its <see cref="BoundExpression.ConstantValue"/> potentially
        /// updated.</param>
        /// <param name="isPositiveCheck">Whether the expression returns true when the type check succeeds. For example,
        /// in the case of != it would be false.</param>
        public static void HandleTypeCheckingExpression(
            BoundVariableRef varRef,
            Func<TypeRefMask, TypeRefMask> targetTypeCallback,
            ConditionBranch branch,
            FlowState flowState,
            bool skipPositiveIfAnyType = false,
            BoundExpression checkExpr = null,
            bool isPositiveCheck = true)
        {
            if (!TryGetVariableHandle(varRef.Variable, flowState, out var handle))
            {
                return;
            }

            var currentType = flowState.GetLocalType(handle);
            var targetType = targetTypeCallback(currentType);

            // Model negative type checks (such as $x != null) by inverting branches for the core checking function
            var branchHlp = isPositiveCheck ? branch : branch.NegativeBranch();

            bool isFeasible = HandleTypeChecking(currentType, targetType, branchHlp, flowState, handle, skipPositiveIfAnyType);

            // If the constant value was not meant to be updated, skip its computation
            if (checkExpr == null)
            {
                return;
            }

            if (!currentType.IsRef)
            {
                // If the true branch proves to be unfeasible, the function always returns false and vice versa
                var resultConstVal = isFeasible ? default(Optional<object>) : new Optional<object>(!branch.TargetValue().Value);

                // Each branch can clean only the constant value it produced during its analysis (in order not to lose result
                // of the other branch): true branch can produce false value and vice versa
                if (!resultConstVal.EqualsOptional(checkExpr.ConstantValue)
                    && (resultConstVal.HasValue
                        || checkExpr.ConstantValue.Value is false && branch == ConditionBranch.ToTrue
                        || checkExpr.ConstantValue.Value is true && branch == ConditionBranch.ToFalse))
                {
                    checkExpr.ConstantValue = resultConstVal;
                }
            }
            else
            {
                // We cannot reason about the result of the check if the variable can be modified by reference
                checkExpr.ConstantValue = default(Optional<object>);
            }
        }

        private static bool TryGetVariableHandle(IVariableReference boundvar, FlowState state, out VariableHandle varHandle)
        {
            if (boundvar is LocalVariableReference local && local.BoundName.IsDirect)  // direct variable name
            {
                if (local.VariableKind == VariableKind.LocalVariable ||
                    local.VariableKind == VariableKind.Parameter ||
                    local.VariableKind == VariableKind.LocalTemporalVariable)
                {
                    varHandle = state.GetLocalHandle(local.BoundName.NameValue);
                    return true;
                }
            }

            //
            varHandle = default(VariableHandle);
            return false;
        }

        private static bool HandleTypeChecking(
            TypeRefMask currentType,
            TypeRefMask targetType,
            ConditionBranch branch,
            FlowState flowState,
            VariableHandle handle,
            bool skipTrueIfAnyType)
        {
            // Information whether this path can ever be taken
            bool isFeasible = true;

            if (branch == ConditionBranch.ToTrue)
            {
                // In the true branch the IsAnyType case can be optionally skipped
                if (skipTrueIfAnyType && currentType.IsAnyType)
                {
                    return isFeasible;
                }

                // Intersect the possible types with those checked by the function, always keeping the IsRef flag.
                // IncludesSubclasses is kept only if it is specified in targetType.
                TypeRefMask resultType = (currentType & (targetType | TypeRefMask.IsRefMask));

                if (resultType.IsVoid)
                {
                    // Clearing the type out in this branch means the variable will never be of that type.
                    // In order to prevent errors in analysis and code generation, set the type to the one specified.
                    resultType = targetType | (currentType & TypeRefMask.IsRefMask);

                    isFeasible = false;
                }

                flowState.SetLocalType(handle, resultType);
            }
            else
            {
                Debug.Assert(branch == ConditionBranch.ToFalse);

                // In the false branch we cannot handle the IsAnyType case
                if (currentType.IsAnyType)
                {
                    return isFeasible;
                }

                // Remove the types and flags excluded by the fact that the function returned false
                TypeRefMask resultType = currentType & (~targetType);

                if (resultType.IsVoid)
                {
                    // Clearing the type out in this branch means the variable will always be of that type
                    // In order to prevent errors in analysis and code generation, do not alter the type in this case.

                    isFeasible = false;
                }
                else
                {
                    flowState.SetLocalType(handle, resultType);
                }
            }

            return isFeasible;
        }

        /// <summary>
        /// Returns whether the given type can be used as an array key.
        /// </summary>
        public static bool IsValidKeyType(IBoundTypeRef type)
        {
            if (type is BoundPrimitiveTypeRef pt)
            {
                switch (pt.TypeCode)
                {
                    case PhpTypeCode.Boolean:
                    case PhpTypeCode.Long:
                    case PhpTypeCode.Double:
                    case PhpTypeCode.String:
                    case PhpTypeCode.WritableString:
                    case PhpTypeCode.Null:
                    case PhpTypeCode.Mixed:
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// If present, transforms the given constant value to a string corresponding to the key under which the item is stored in an array.
        /// </summary>
        /// <param name="keyConst">Constant value of the key.</param>
        /// <param name="key">If <paramref name="keyConst"/> contains a value, the key as a (string, long) tuple.
        /// The second item should be taken into account only if the first one is null.</param>
        /// <returns>Whether the value was constant at all.</returns>
        public static bool TryGetCanonicKeyStringConstant(Optional<object> keyConst, out (string, long) key)
        {
            if (!keyConst.HasValue)
            {
                key = default;
                return false;
            }

            var obj = keyConst.Value;

            if (obj == null)
            {
                key = ("", default);
            }
            else if (keyConst.TryConvertToLong(out long l))
            {
                key = (null, l);
            }
            else if (obj is string s)
            {
                key = (s, default);
            }
            else
            {
                key = default;
                return false;
            }

            return true;
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(2,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(7,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(5,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(4,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(115,51): error CS0103: The name 'class_name' does not exist in the current context,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(117,106): error CS0103: The name 'class_name' does not exist in the current context,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(2,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(7,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(5,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\AnalysisFacts.cs(4,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 7 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.CodeGen;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Pchp.CodeAnalysis.Symbols;
using Roslyn.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Ast = Devsense.PHP.Syntax.Ast;

namespace Pchp.CodeAnalysis.FlowAnalysis
{
    /// <summary>
    /// Visits single expressions and project transformations to flow state.
    /// </summary>
    internal class ExpressionAnalysis<T> : AnalysisWalker<FlowState, T>
    {
        #region Fields & Properties

        /// <summary>
        /// The worklist to be used to enqueue next blocks.
        /// </summary>
        internal Worklist<BoundBlock> Worklist { get; }

        /// <summary>
        /// Gets model for symbols resolution.
        /// </summary>
        internal ISymbolProvider/*!*/Model => _model;
        readonly ISymbolProvider/*!*/_model;

        /// <summary>
        /// Reference to corresponding source routine.
        /// </summary>
        public SourceRoutineSymbol Routine => State.Routine;

        /// <summary>
        /// Gets current type context for type masks resolving.
        /// </summary>
        internal TypeRefContext TypeCtx => State.TypeRefContext;

        protected PhpCompilation DeclaringCompilation => _model.Compilation;

        protected BoundTypeRefFactory BoundTypeRefFactory => DeclaringCompilation.TypeRefFactory;

        #endregion

        #region Helpers

        /// <summary>
        /// In case given expression is a local or parameter reference,
        /// gets its variable handle within <see cref="State"/>.
        /// </summary>
        VariableHandle TryGetVariableHandle(BoundExpression expr)
        {
            var varname = AsVariableName(expr as BoundReferenceExpression);
            if (varname.IsValid())
            {
                return State.GetLocalHandle(varname);
            }
            else
            {
                return default(VariableHandle);
            }
        }

        /// <summary>
        /// In case of a local variable or parameter, gets its name.
        /// </summary>
        static VariableName AsVariableName(BoundReferenceExpression r)
        {
            if (r is BoundVariableRef vr)
            {
                return vr.Name.NameValue;
            }

            return default;
        }

        static bool IsLongConstant(BoundExpression expr, long value)
        {
            if (expr.ConstantValue.HasValue)
            {
                if (expr.ConstantValue.Value is long) return ((long)expr.ConstantValue.Value) == value;
                if (expr.ConstantValue.Value is int) return ((int)expr.ConstantValue.Value) == value;
            }
            return false;
        }

        static bool TryConvertToNumber(object value, out long l, out double d)
        {
            if (value is int)
            {
                l = (int)value;
                d = (double)l;
                return true;
            }

            if (value is long)
            {
                l = (long)value;
                d = (double)l;
                return true;
            }

            if (value is double)
            {
                d = (double)value;
                l = (long)d;
                return true;
            }

            if (value is bool)
            {
                l = (bool)value ? 1 : 0;
                d = (double)l;
                return true;
            }

            if (value is string s)
            {
                if (long.TryParse(s, out l))
                {
                    d = (double)l;
                    return true;
                }

                if (double.TryParse(s, out d))
                {
                    l = (long)d;
                    return true;
                }
            }

            l = default;
            d = default;
            return false;
        }

        bool BindConstantValue(BoundExpression target, FieldSymbol symbol)
        {
            if (symbol != null && symbol.IsConst)
            {
                var cvalue = symbol.GetConstantValue(false);
                target.ConstantValue = (cvalue != null) ? new Optional<object>(cvalue.Value) : null;

                if (cvalue != null && cvalue.IsNull)
                {
                    target.TypeRefMask = TypeCtx.GetNullTypeMask();
                    return true;
                }

                target.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, symbol.Type, notNull: true);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Finds the root of given chain, i.e.:
        /// $a : $a
        /// $$a : $a
        /// $a->b : $a
        /// $a[..] : $a
        /// $a->foo() : $a
        /// etc.
        /// </summary>
        /// <remarks>If given expression 'isset', its root returned by this method must be set as well.</remarks>
        internal BoundExpression TryGetExpressionChainRoot(BoundExpression x)
        {
            if (x != null)
            {
                if (x is BoundVariableRef v) return v.Name.IsDirect ? v : TryGetExpressionChainRoot(v.Name.NameExpression);
                if (x is BoundFieldRef f) return TryGetExpressionChainRoot(f.Instance ?? (f.ContainingType as BoundIndirectTypeRef)?.TypeExpression);
                if (x is BoundInstanceFunctionCall m) return TryGetExpressionChainRoot(m.Instance);
                if (x is BoundArrayItemEx a) return TryGetExpressionChainRoot(a.Array);
            }

            return null;
        }

        /// <summary>
        /// Gets current visibility scope.
        /// </summary>
        protected OverloadsList.VisibilityScope VisibilityScope => new OverloadsList.VisibilityScope(TypeCtx.SelfType, Routine);

        protected void PingSubscribers(ExitBlock exit)
        {
            if (exit != null)
            {
                var wasNotAnalysed = false;

                if (Routine != null && !Routine.IsReturnAnalysed)
                {
                    Routine.IsReturnAnalysed = true;
                    wasNotAnalysed = true;
                }

                // Ping the subscribers either if the return type has changed or
                // it is the first time the analysis reached the routine exit
                var rtype = State.GetReturnType();
                if (rtype != exit._lastReturnTypeMask || wasNotAnalysed)
                {
                    exit._lastReturnTypeMask = rtype;
                    var subscribers = exit.Subscribers;
                    if (subscribers.Count != 0)
                    {
                        lock (subscribers)
                        {
                            foreach (var subscriber in subscribers)
                            {
                                Worklist.PingReturnUpdate(exit, subscriber);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsDouble(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(BoundExpression x) => IsDoubleOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsLong(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(BoundExpression x) => IsLongOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        /// <param name="tmask"></param>
        /// <returns></returns>
        protected bool IsNumberOnly(TypeRefMask tmask)
        {
            if (TypeCtx.IsLong(tmask) || TypeCtx.IsDouble(tmask))
            {
                if (tmask.IsSingleType)
                {
                    return true;
                }

                return !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsNumber();
            }

            return false;
        }

        /// <summary>
        /// Gets value indicating the given type represents only class types.
        /// </summary>
        protected bool IsClassOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsObject();
        }

        /// <summary>
        /// Gets value indicating the given type represents only array types.
        /// </summary>
        protected bool IsArrayOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsArray();
        }

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        protected bool IsNumberOnly(BoundExpression x) => IsNumberOnly(x.TypeRefMask);

        #endregion

        #region Construction

        /// <summary>
        /// Creates an instance of <see cref="ExpressionAnalysis{T}"/> that can analyse a block.
        /// </summary>
        /// <param name="worklist">The worklist to be used to enqueue next blocks.</param>
        /// <param name="model">The semantic context of the compilation.</param>
        public ExpressionAnalysis(Worklist<BoundBlock> worklist, ISymbolProvider model)
        {
            Debug.Assert(model != null);
            _model = model;
            Worklist = worklist;
        }

        #endregion

        #region State and worklist handling

        protected override bool IsStateInitialized(FlowState state) => state != null;

        protected override bool AreStatesEqual(FlowState a, FlowState b) => a.Equals(b);

        protected override FlowState GetState(BoundBlock block) => block.FlowState;

        protected override void SetState(BoundBlock block, FlowState state) => block.FlowState = state;

        protected override FlowState CloneState(FlowState state) => state.Clone();

        protected override FlowState MergeStates(FlowState a, FlowState b) => a.Merge(b);

        protected override void SetStateUnknown(ref FlowState state) => state.SetAllUnknown(true);

        protected override void EnqueueBlock(BoundBlock block) => Worklist.Enqueue(block);

        #endregion

        #region Visit blocks

        public override T VisitCFGExitBlock(ExitBlock x)
        {
            VisitCFGBlock(x);

            // TODO: EdgeToCallers:
            PingSubscribers(x);

            return default;
        }

        public override T VisitCFGCatchBlock(CatchBlock x)
        {
            VisitCFGBlockInit(x);

            // add catch control variable to the state
            x.TypeRef.Accept(this);

            if (x.Variable != null)
            {
                x.Variable.Access = BoundAccess.Write.WithWrite(x.TypeRef.GetTypeRefMask(TypeCtx));
                State.SetLocalType(State.GetLocalHandle(x.Variable.Name.NameValue), x.Variable.Access.WriteMask);
                Accept(x.Variable);

                //
                x.Variable.ResultType = (TypeSymbol)x.TypeRef.Type;
            }


            //
            DefaultVisitBlock(x);

            return default;
        }

        #endregion

        #region Declaration Statements

        public override T VisitStaticStatement(BoundStaticVariableStatement x)
        {
            var v = x.Declaration;
            var local = State.GetLocalHandle(new VariableName(v.Name));

            State.SetVarKind(local, VariableKind.StaticVariable);

            var oldtype = State.GetLocalType(local).WithRefFlag;

            // set var
            if (v.InitialValue != null)
            {
                // analyse initializer
                Accept(v.InitialValue);

                bool isInt = v.InitialValue.ConstantValue.IsInteger(out long intVal);
                State.SetLessThanLongMax(local, isInt && intVal < long.MaxValue);
                State.SetGreaterThanLongMin(local, isInt && intVal > long.MinValue);

                State.SetLocalType(local, ((IPhpExpression)v.InitialValue).TypeRefMask | oldtype);
            }
            else
            {
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetLocalType(local, TypeCtx.GetNullTypeMask() | oldtype);
                // TODO: explicitly State.SetLocalUninitialized() ?
            }

            return default;
        }

        public override T VisitGlobalStatement(BoundGlobalVariableStatement x)
        {
            base.VisitGlobalStatement(x);   // Accept(x.Variable)

            return default;
        }

        #endregion

        #region Visit Literals

        public override T VisitLiteral(BoundLiteral x)
        {
            x.TypeRefMask = x.ResolveTypeMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit CopyValue

        public override T VisitCopyValue(BoundCopyValue x)
        {
            Accept(x.Expression);

            var tmask = x.Expression.TypeRefMask;

            if (tmask.IsRef)
            {
                // copied value is possible a reference,
                // might be anything:
                tmask = TypeRefMask.AnyType;
            }

            // the result is not a reference for sure:
            Debug.Assert(!tmask.IsRef);

            x.TypeRefMask = tmask;

            return default;
        }

        #endregion

        #region Visit Assignments

        public override T VisitAssign(BoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            //
            Accept(x.Value);

            // keep WriteRef flag
            var targetaccess = BoundAccess.None.WithWrite(x.Value.TypeRefMask);
            if (x.Target.Access.IsWriteRef)
            {
                targetaccess = targetaccess.WithWriteRef(0);
            }

            // new target access with resolved target type
            Visit(x.Target, targetaccess);

            //
            x.TypeRefMask = x.Value.TypeRefMask;

            return default;
        }

        public override T VisitCompoundAssign(BoundCompoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            // Target X Value
            var tmp = new BoundBinaryEx(x.Target.WithAccess(BoundAccess.Read), x.Value, AstUtils.CompoundOpToBinaryOp(x.Operation));
            Visit(tmp, ConditionBranch.AnyResult);

            // Target =
            Visit(x.Target, BoundAccess.Write.WithWrite(tmp.TypeRefMask));

            // put read access back
            x.Target.Access = x.Target.Access.WithRead();

            //
            x.TypeRefMask = tmp.TypeRefMask;

            return default;
        }

        protected virtual void VisitSuperglobalVariableRef(BoundVariableRef x)
        {
            Debug.Assert(x.Name.IsDirect);
            Debug.Assert(x.Name.NameValue.IsAutoGlobal);

            // remember the initial state of variable at this point
            x.BeforeTypeRef = TypeRefMask.AnyType;

            // bind variable place
            x.Variable = Routine.LocalsTable.BindAutoGlobalVariable(x.Name.NameValue);

            // update state
            if (x.Access.IsRead)
            {
                TypeRefMask vartype;

                if (x.Name.NameValue == VariableName.HttpRawPostDataName)
                {
                    // $HTTP_RAW_POST_DATA : string // TODO: make it mixed or string | binary string
                    vartype = TypeCtx.GetStringTypeMask();
                }
                else
                {
                    // all the other autoglobals are arrays:
                    vartype = TypeCtx.GetArrayTypeMask();
                }

                if (x.Access.IsReadRef)
                {
                    vartype = vartype.WithRefFlag;
                }

                if (x.Access.EnsureObject)
                {
                    // TODO: report ERR
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                x.TypeRefMask = x.Access.WriteMask;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
            }
        }

        protected virtual void VisitLocalVariableRef(BoundVariableRef x, VariableHandle local)
        {
            Debug.Assert(local.IsValid);

            if (Routine == null)
            {
                // invalid use of variable:
                return;
            }

            var previoustype = State.GetLocalType(local);       // type of the variable in the previous state

            // remember the initial state of variable at this point
            x.BeforeTypeRef = previoustype;

            // bind variable place
            if (x.Variable == null)
            {
                x.Variable = x.IsLowerTemp()     // synthesized variable constructed by semantic binder
                    ? Routine.LocalsTable.BindTemporalVariable(local.Name)
                    : Routine.LocalsTable.BindLocalVariable(local.Name, x.PhpSyntax.Span.ToTextSpan());
            }

            //
            State.VisitLocal(local);

            // update state
            if (x.Access.IsRead)
            {
                var vartype = previoustype;

                if (x.Variable is ThisVariableReference)
                {
                    // optimization; we know the exact type here or at least we know it is `Object` (instead of AnyType)
                    // if vartype is resolved to a single instance it was probably done by some operand like 'instanceof' already and better

                    if (vartype.IsSingleType == false || Routine.IsGlobalScope)
                    {
                        vartype = TypeCtx.GetThisTypeMask(); // : System.Object or exact type, with subclasses if applicable
                    }
                }
                else if (vartype.IsVoid || Routine.IsGlobalScope)
                {
                    // in global code or in case of undefined variable,
                    // assume the type is mixed (unspecified).
                    // In global code, the type of variable cannot be determined by type analysis, it can change between every two operations (this may be improved by better flow analysis).
                    vartype = TypeRefMask.AnyType;
                    vartype.IsRef = previoustype.IsRef;

                    if (Routine.IsGlobalScope)
                    {
                        // in global code, treat the variable as initialized always:
                        State.SetVarInitialized(local);
                        vartype.IsRef = true;   // variable might be a reference
                    }
                }
                else
                {
                    //// if there are multiple types possible
                    //// find the common base (this allows for better methods resolution)
                    //if (!vartype.IsAnyType && !vartype.IsRef && vartype.IncludesSubclasses && !vartype.IsSingleType && TypeCtx.IsObject(vartype))
                    //{
                    //    // ...
                    //}
                }

                if (x.Access.IsEnsure)
                {
                    if (x.Access.IsReadRef)
                    {
                        State.MarkLocalByRef(local);
                        vartype.IsRef = true;
                    }
                    if (x.Access.EnsureObject && !TypeCtx.IsObject(vartype))
                    {
                        vartype |= TypeCtx.GetSystemObjectTypeMask();
                    }
                    if (x.Access.EnsureArray)
                    {
                        if (!TypeHelpers.HasArrayAccess(vartype, TypeCtx, DeclaringCompilation))
                        {
                            vartype |= TypeCtx.GetArrayTypeMask();
                        }
                        else if (TypeCtx.IsReadonlyString(vartype))
                        {
                            vartype |= TypeCtx.GetWritableStringTypeMask();
                        }
                    }

                    State.SetLocalType(local, vartype);
                }
                else
                {
                    // reset 'MaybeUninitialized' flag:
                    x.MaybeUninitialized = false;

                    if (!State.IsLocalSet(local))
                    {
                        // do not flag as uninitialized if variable:
                        // - may be a reference
                        // - is in a global scope
                        if (!vartype.IsRef && !Routine.IsGlobalScope)
                        {
                            x.MaybeUninitialized = true;
                        }

                        // variable maybe null if it can be uninitialized
                        vartype |= TypeCtx.GetNullTypeMask();
                    }
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                var vartype = x.Access.WriteMask;

                if (x.Access.IsWriteRef || previoustype.IsRef)    // keep the ref flag of local
                {
                    vartype.IsRef = true;
                    State.MarkLocalByRef(local);
                }
                else if (vartype.IsRef)
                {
                    // // we can't be sure about the type
                    vartype = TypeRefMask.AnyType; // anything, not ref
                                                   //vartype.IsRef = false;  // the variable won't be a reference from this point
                }

                //
                State.SetLocalType(local, vartype);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
                State.SetLocalType(local, x.TypeRefMask);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetVarUninitialized(local);
            }
        }

        public override T VisitVariableRef(BoundVariableRef x)
        {
            if (x.Name.IsDirect)
            {
                // direct variable access:
                if (x.Name.NameValue.IsAutoGlobal)
                {
                    VisitSuperglobalVariableRef(x);
                }
                else
                {
                    VisitLocalVariableRef(x, State.GetLocalHandle(x.Name.NameValue));
                }
            }
            else
            {
                x.BeforeTypeRef = TypeRefMask.AnyType;

                Accept(x.Name.NameExpression);

                // bind variable place
                x.Variable ??= new LocalVariableReference(VariableKind.LocalVariable, Routine, null, x.Name);

                // update state
                if (x.Access.IsRead)
                {
                    State.FlowContext.SetAllUsed();
                    x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                }

                if (x.Access.IsWrite || x.Access.IsEnsure)
                {
                    State.SetAllUnknown(x.Access.IsWriteRef);
                    x.TypeRefMask = x.Access.WriteMask;
                }

                if (x.Access.IsUnset)
                {

                }
            }

            return default;
        }

        public override T VisitIncDec(BoundIncDecEx x)
        {
            // <target> = <target> +/- 1L

            Debug.Assert(x.Access.IsRead || x.Access.IsNone);
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);

            Visit(x.Target, BoundAccess.Read);
            Visit(x.Value, BoundAccess.Read);

            Debug.Assert(IsNumberOnly(x.Value));    // 1L

            TypeRefMask resulttype;
            TypeRefMask sourcetype = x.Target.TypeRefMask;  // type of target before operation

            VariableHandle lazyVarHandle = default;
            bool lessThanLongMax = false;               // whether the variable's value is less than the max long value
            bool greaterThanLongMin = false;            // or greater than the min long value

            if (IsDoubleOnly(x.Target))
            {
                // double++ => double
                resulttype = TypeCtx.GetDoubleTypeMask();
            }
            else
            {
                // we'd like to keep long if we are sure we don't overflow to double
                lazyVarHandle = TryGetVariableHandle(x.Target);
                if (lazyVarHandle.IsValid && x.IsIncrement && State.IsLessThanLongMax(lazyVarHandle))
                {
                    // long++ [< long.MaxValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    lessThanLongMax = true;
                }
                else if (lazyVarHandle.IsValid && !x.IsIncrement && State.IsGreaterThanLongMin(lazyVarHandle))
                {
                    // long-- [> long.MinValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    greaterThanLongMin = true;
                }
                else
                {
                    // long|double|anything++/-- => number
                    resulttype = TypeCtx.GetNumberTypeMask();
                }
            }

            Visit(x.Target, BoundAccess.Write.WithWrite(resulttype));

            //
            x.Target.Access = x.Target.Access.WithRead();   // put read access back to the target
            x.TypeRefMask = x.IsPostfix ? sourcetype : resulttype;

            // We expect that an incrementation doesn't change the property of being less than the max long value,
            // it needs to be restored due to the write access of the target variable
            if (lessThanLongMax)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetLessThanLongMax(lazyVarHandle, true);
            }

            // The same for the min long value
            if (greaterThanLongMin)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetGreaterThanLongMin(lazyVarHandle, true);
            }

            return default;
        }

        #endregion

        #region Visit BinaryEx

        private void VisitShortCircuitOp(BoundExpression lExpr, BoundExpression rExpr, bool isAndOp, ConditionBranch branch)
        {
            // Each operand has to be evaluated in various states and then the state merged.
            // Simulates short-circuit evaluation in runtime:

            var state = this.State; // original state

            if (branch == ConditionBranch.AnyResult)
            {
                if (isAndOp)
                {
                    // A == True && B == Any
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == Any
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToTrue)
            {
                if (isAndOp)
                {
                    // A == True && B == True

                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                }
                else
                {
                    // A == False && B == True
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToFalse)
            {
                if (isAndOp)
                {
                    // A == True && B == False
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == False

                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                }
            }
        }

        /// <summary>
        /// Gets resulting type of bit operation (bit or, and, xor).
        /// </summary>
        TypeRefMask GetBitOperationType(TypeRefMask lValType, TypeRefMask rValType)
        {
            TypeRefMask type;

            // type is string if both operands are string
            if ((lValType.IsAnyType && rValType.IsAnyType) ||
                (TypeCtx.IsAString(lValType) && TypeCtx.IsAString(rValType)))
            {
                type = TypeCtx.GetStringTypeMask();
            }
            else
            {
                type = default(TypeRefMask);
            }

            // type can be always long
            type |= TypeCtx.GetLongTypeMask();

            //
            return type;
        }

        Optional<object> ResolveBooleanOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (xobj.TryConvertToBool(out var bx) && yobj.TryConvertToBool(out var by))
            {
                return op switch
                {
                    Operations.And => (bx && by),
                    Operations.Or => (bx || by),
                    Operations.Xor => (bx ^ by),
                    _ => throw ExceptionUtilities.Unreachable,
                };
            }

            return default;
        }

        /// <summary>
        /// Resolves value of bit operation.
        /// </summary>
        /// <remarks>TODO: move to **evaluation**.</remarks>
        Optional<object> ResolveBitOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            var xconst = xobj.ToConstantValueOrNull();
            var yconst = yobj.ToConstantValueOrNull();

            if (xconst.TryConvertToLong(out long xval) && yconst.TryConvertToLong(out long yval))
            {
                long result;

                switch (op)
                {
                    case Operations.BitOr: result = xval | yval; break;
                    case Operations.BitAnd: result = xval & yval; break;
                    case Operations.BitXor: result = xval ^ yval; break;
                    default:
                        throw new ArgumentException(nameof(op));
                }

                //
                if (result >= int.MinValue && result <= int.MaxValue)
                {
                    return (int)result;
                }
                else
                {
                    return result;
                }

                //
            }

            return default(Optional<object>);
        }

        /// <summary>
        /// Gets resulting type of <c>+</c> operation.
        /// </summary>
        TypeRefMask GetPlusOperationType(BoundExpression left, BoundExpression right)
        {
            var lValType = left.TypeRefMask;
            var rValType = right.TypeRefMask;

            // array + array => array
            // array + number => 0 (ERROR)
            // number + number => number
            // anytype + array => array
            // anytype + number => number

            var or = lValType | rValType;

            if (IsNumberOnly(or))
            {
                // double + number => double
                if (IsDoubleOnly(lValType) || IsDoubleOnly(rValType))
                    return TypeCtx.GetDoubleTypeMask();

                // long + long => long
                if (State.IsLessThanLongMax(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG + 1, where LONG < long.MaxValue
                    return TypeCtx.GetLongTypeMask();

                return TypeCtx.GetNumberTypeMask();
            }

            if ((!lValType.IsRef && !lValType.IsAnyType && !TypeCtx.IsArray(lValType)) ||
                (!rValType.IsRef && !rValType.IsAnyType && !TypeCtx.IsArray(rValType)))
            {
                // not array for sure:
                return TypeCtx.GetNumberTypeMask();
            }

            //
            var type = TypeCtx.GetArraysFromMask(or);

            //
            if (or.IsAnyType || TypeCtx.IsNumber(or) || type == 0) // !this.TypeRefContext.IsArray(lValType & rValType))
                type |= TypeCtx.GetNumberTypeMask();    // anytype or an operand is number or operands are not a number nor both are not array

            if (or.IsAnyType)
                type |= TypeCtx.GetArrayTypeMask();

            //
            return type;
        }

        static Optional<object> ResolvePlusOperation(Optional<object> xobj, Optional<object> yobj)
        {
            if (xobj.HasValue && yobj.HasValue)
            {
                switch (xobj.Value)
                {
                    case double x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return x + y;
                        }
                        break;
                    case long x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y:
                                try { return checked(x + y); }
                                catch (OverflowException) { return (double)x + y; }
                            case int y: return x + y;
                        }
                        break;
                    case int x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return (long)x + y;
                        }
                        break;
                }
            }

            return default;
        }

        static Optional<object> ResolveOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (!xobj.HasValue || !yobj.HasValue)
            {
                return default;
            }

            switch (op)
            {
                case Operations.Add:
                    return ResolvePlusOperation(xobj, yobj);

                case Operations.Mul:
                    switch (xobj.Value)
                    {
                        case double x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y: return x * y;
                                case int y: return x * y;
                            }
                            break;
                        case int x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                        case long x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                    }
                    break;
            }

            return default;
        }

        /// <summary>
        /// Gets resulting type of <c>-</c> operation.
        /// </summary>
        TypeRefMask GetMinusOperationType(BoundExpression left, BoundExpression right)
        {
            if (IsDoubleOnly(left.TypeRefMask) || IsDoubleOnly(right.TypeRefMask)) // some operand is double and nothing else
                return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
            else if (State.IsGreaterThanLongMin(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG -1, where LONG > long.MinValue
                return TypeCtx.GetLongTypeMask();
            else
                return TypeCtx.GetNumberTypeMask();
        }

        protected override void Visit(BoundBinaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveBinaryEx(x, branch);
        }

        TypeRefMask ResolveBinaryEx(BoundBinaryEx x, ConditionBranch branch)
        {
            if (x.Operation == Operations.And || x.Operation == Operations.Or)
            {
                this.VisitShortCircuitOp(x.Left, x.Right, x.Operation == Operations.And, branch);
            }
            else
            {
                Accept(x.Left);
                Accept(x.Right);
            }

            switch (x.Operation)
            {
                #region Arithmetic Operations

                case Operations.Add:
                    x.ConstantValue = ResolvePlusOperation(x.Left.ConstantValue, x.Right.ConstantValue);
                    return x.ConstantValue.HasValue
                        ? TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue)
                        : GetPlusOperationType(x.Left, x.Right);

                case Operations.Sub:
                    return GetMinusOperationType(x.Left, x.Right);

                case Operations.Div:
                case Operations.Mul:
                case Operations.Pow:

                    x.ConstantValue = ResolveOperation(x.Left.ConstantValue, x.Right.ConstantValue.Value, x.Operation);
                    if (x.ConstantValue.HasValue)
                    {
                        return TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue);
                    }
                    else if (IsDoubleOnly(x.Left.TypeRefMask) || IsDoubleOnly(x.Right.TypeRefMask)) // some operand is double and nothing else
                    {
                        return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
                    }
                    else
                    {
                        return TypeCtx.GetNumberTypeMask();
                    }

                case Operations.Mod:
                    return TypeCtx.GetLongTypeMask();

                case Operations.ShiftLeft:
                case Operations.ShiftRight:

                    x.ConstantValue = ResolveShift(x.Operation, x.Left.ConstantValue, x.Right.ConstantValue);
                    return TypeCtx.GetLongTypeMask();

                #endregion

                #region Boolean and Bitwise Operations

                case Operations.And:
                case Operations.Or:
                case Operations.Xor:

                    x.ConstantValue = ResolveBooleanOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return TypeCtx.GetBooleanTypeMask();

                case Operations.BitAnd:
                case Operations.BitOr:
                case Operations.BitXor:

                    x.ConstantValue = ResolveBitOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return GetBitOperationType(x.Left.TypeRefMask, x.Right.TypeRefMask);    // int or string

                #endregion

                #region Comparing Operations

                case Operations.Equal:
                case Operations.NotEqual:
                case Operations.Identical:
                case Operations.NotIdentical:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    if (branch != ConditionBranch.AnyResult)
                    {
                        // We must beware not to compute constant value more than once (losing results) -> mark handling of the given expression by this boolean
                        bool handled = false;

                        if (x.Right.ConstantValue.HasValue && x.Left is BoundReferenceExpression boundLeft)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundLeft, x.Right.ConstantValue, branch);
                        }
                        else if (x.Left.ConstantValue.HasValue && x.Right is BoundReferenceExpression boundRight)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundRight, x.Left.ConstantValue, branch);
                        }

                        if (!handled)
                        {
                            ResolveEquality(x);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                case Operations.GreaterThan:
                case Operations.LessThan:
                case Operations.GreaterThanOrEqual:
                case Operations.LessThanOrEqual:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    // comparison with long value
                    if (branch == ConditionBranch.ToTrue && IsLongOnly(x.Right))
                    {
                        if (x.Operation == Operations.LessThan ||
                            (x.Operation == Operations.LessThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal) && rightVal < long.MaxValue))
                        {
                            // $x < Long.Max
                            State.SetLessThanLongMax(TryGetVariableHandle(x.Left), true);
                        }
                        else if (x.Operation == Operations.GreaterThan ||
                            (x.Operation == Operations.GreaterThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal2) && rightVal2 > long.MinValue))
                        {
                            // $x > Long.Min
                            State.SetGreaterThanLongMin(TryGetVariableHandle(x.Left), true);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                #endregion

                case Operations.Concat:
                    return TypeCtx.GetWritableStringTypeMask();

                case Operations.Coalesce:   // Left ?? Right
                    return x.Left.TypeRefMask | x.Right.TypeRefMask;

                case Operations.Spaceship:
                    return TypeCtx.GetLongTypeMask(); // -1, 0, +1

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.Operation);
            }
        }

        /// <summary>
        /// If possible, resolve the comparison operation in compile-time.
        /// </summary>
        static Optional<object> ResolveComparison(Operations op, object lvalue, object rvalue)
        {
            // TODO

            if (TryConvertToNumber(lvalue, out _, out var dl) && TryConvertToNumber(rvalue, out _, out var dr))
            {
                return op switch
                {
                    Operations.Equal => dl == dr,
                    Operations.GreaterThan => dl > dr,
                    Operations.LessThan => dl < dr,
                    Operations.GreaterThanOrEqual => dl >= dr,
                    Operations.LessThanOrEqual => dl <= dr,
                    _ => default(Optional<object>),
                };
            }

            //
            return default;
        }

        static Optional<object> ResolveShift(Operations op, Optional<object> lvalue, Optional<object> rvalue)
        {
            if (lvalue.TryConvertToLong(out var left) && rvalue.TryConvertToLong(out var right))
            {
                switch (op)
                {
                    case Operations.ShiftLeft:
                        return (left << (int)right).AsOptional();

                    case Operations.ShiftRight:
                        return (left >> (int)right).AsOptional();

                    default:
                        Debug.Fail("unexpected");
                        break;

                }
            }

            return default;
        }

        /// <summary>
        /// Resolves variable types and potentially assigns a constant boolean value to an expression of a comparison of
        /// a variable and a constant - operators ==, !=, === and !==. Returns true iff this expression was handled and there
        /// is no need to analyse it any more (adding constant value etc.).
        /// </summary>
        private bool ResolveEqualityWithConstantValue(
            BoundBinaryEx cmpExpr,
            BoundReferenceExpression refExpr,
            Optional<object> value,
            ConditionBranch branch)
        {
            Debug.Assert(branch != ConditionBranch.AnyResult);

            if (value.IsNull() && refExpr is BoundVariableRef varRef)
            {
                bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);

                // We cannot say much about the type of $x in the true branch of ($x == null) and the false branch of ($x != null),
                // because it holds for false, 0, "", array() etc.
                if (isStrict || branch.TargetValue() != isPositive)
                {
                    AnalysisFacts.HandleTypeCheckingExpression(
                        varRef,
                        TypeCtx.GetNullTypeMask(),
                        branch,
                        State,
                        checkExpr: cmpExpr,
                        isPositiveCheck: isPositive);
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Attempts to infer the result of an equality comparison from the types of the operands.
        /// </summary>
        private void ResolveEquality(BoundBinaryEx cmpExpr)
        {
            Debug.Assert(cmpExpr.Operation >= Operations.Equal && cmpExpr.Operation <= Operations.NotIdentical);

            bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);

            if (isStrict && !cmpExpr.Left.CanHaveSideEffects() && !cmpExpr.Right.CanHaveSideEffects())
            {
                // Always returns false if checked for strict equality and the operands are of different types (and vice versa for strict non-eq)
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);
                bool canBeSameType = Routine.TypeRefContext.CanBeSameType(cmpExpr.Left.TypeRefMask, cmpExpr.Right.TypeRefMask);
                cmpExpr.ConstantValue = !canBeSameType ? (!isPositive).AsOptional() : default;
            }
        }

        #endregion

        #region Visit UnaryEx

        protected override void Visit(BoundUnaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveUnaryOperatorExpression(x, branch);
        }

        TypeRefMask ResolveUnaryOperatorExpression(BoundUnaryEx x, ConditionBranch branch)
        {
            if (branch != ConditionBranch.AnyResult && x.Operation == Operations.LogicNegation)
            {
                // Negation swaps the branches
                VisitCondition(x.Operand, branch.NegativeBranch());
            }
            else
            {
                Accept(x.Operand);
            }

            // clear any previous resolved constant 
            x.ConstantValue = default(Optional<object>);

            //
            switch (x.Operation)
            {
                case Operations.AtSign:
                    return x.Operand.TypeRefMask;

                case Operations.BitNegation:
                    if (x.Operand.ConstantValue.HasValue)
                    {
                        if (x.Operand.ConstantValue.Value is long l)
                        {
                            x.ConstantValue = new Optional<object>(~l);
                        }
                        else if (x.Operand.ConstantValue.Value is int i)
                        {
                            x.ConstantValue = new Optional<object>(~(long)i);
                        }
                    }

                    return TypeCtx.GetLongTypeMask();   // TODO: or byte[]

                case Operations.Clone:
                    // result is always object, not aliased
                    return TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask).IsVoid
                        ? TypeCtx.GetSystemObjectTypeMask()                     // "object"
                        : TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask);    // (object)T

                case Operations.LogicNegation:
                    {
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(!constBool);
                        }
                        return TypeCtx.GetBooleanTypeMask();
                    }

                case Operations.Minus:
                    var cvalue = ResolveUnaryMinus(x.Operand.ConstantValue.ToConstantValueOrNull());
                    if (cvalue != null)
                    {
                        x.ConstantValue = new Optional<object>(cvalue.Value);
                        return TypeCtx.GetTypeMask(BoundTypeRefFactory.Create(cvalue), false);
                    }
                    else
                    {
                        if (IsDoubleOnly(x.Operand))
                        {
                            return TypeCtx.GetDoubleTypeMask(); // double in case operand is double
                        }
                        return TypeCtx.GetNumberTypeMask();     // TODO: long in case operand is not a number
                    }

                case Operations.UnsetCast:
                    return TypeCtx.GetNullTypeMask();   // null

                case Operations.Plus:
                    if (IsNumberOnly(x.Operand.TypeRefMask))
                        return x.Operand.TypeRefMask;
                    return TypeCtx.GetNumberTypeMask();

                case Operations.Print:
                    return TypeCtx.GetLongTypeMask();

                default:
                    throw ExceptionUtilities.Unreachable;
            }
        }

        ConstantValue ResolveUnaryMinus(ConstantValue value)
        {
            if (value != null)
            {
                switch (value.SpecialType)
                {
                    case SpecialType.System_Double:
                        return ConstantValue.Create(-value.DoubleValue);

                    case SpecialType.System_Int32:
                        return value.Int32Value != int.MinValue
                            ? ConstantValue.Create(-value.Int32Value)   // (- Int32.MinValue) overflows to int64
                            : ConstantValue.Create(-(long)value.Int32Value);

                    case SpecialType.System_Int64:
                        return (value.Int64Value != long.MinValue)  // (- Int64.MinValue) overflows to double
                            ? ConstantValue.Create(-value.Int64Value)
                            : ConstantValue.Create(-(double)value.Int64Value);
                    default:
                        break;
                }
            }

            return null;
        }

        #endregion

        #region Visit Conversion

        public override T VisitConversion(BoundConversionEx x)
        {
            base.VisitConversion(x);

            // evaluate if possible

            if (x.TargetType is BoundPrimitiveTypeRef pt)
            {
                switch (pt.TypeCode)
                {
                    case PhpTypeCode.Boolean:
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(constBool);
                        }
                        break;

                    case PhpTypeCode.Long:
                        if (x.Operand.ConstantValue.TryConvertToLong(out long l))
                        {
                            x.ConstantValue = new Optional<object>(l);
                        }
                        break;

                    case PhpTypeCode.Double:
                        break;

                    case PhpTypeCode.String:
                    case PhpTypeCode.WritableString:
                        if (x.Operand.ConstantValue.TryConvertToString(out string str))
                        {
                            x.ConstantValue = new Optional<object>(str);
                        }
                        break;

                    case PhpTypeCode.Object:
                        if (IsClassOnly(x.Operand.TypeRefMask))
                        {
                            // it is object already, keep its specific type
                            x.TypeRefMask = x.Operand.TypeRefMask;   // (object)<object>
                            return default;
                        }
                        else if (IsArrayOnly(x.Operand.TypeRefMask))
                        {
                            // array -> object conversion
                            // always stdClass
                            x.TypeRefMask = TypeCtx.GetTypeMask(BoundTypeRefFactory.stdClassTypeRef, false);
                            return default;
                        }
                        break;
                }
            }

            //

            x.TypeRefMask = x.TargetType.GetTypeRefMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit InstanceOf

        protected override void Visit(BoundInstanceOfEx x, ConditionBranch branch)
        {
            Accept(x.Operand);
            x.AsType.Accept(this);

            // TOOD: x.ConstantValue // in case we know and the operand is a local variable (we can ignore the expression and emit result immediatelly)

            var opTypeMask = x.Operand.TypeRefMask;
            if (x.Operand is BoundLiteral
                || (!opTypeMask.IsAnyType && !opTypeMask.IsRef && !Routine.TypeRefContext.IsObject(opTypeMask)))
            {
                x.ConstantValue = ConstantValueExtensions.AsOptional(false);
            }
            else if (x.Operand is BoundVariableRef vref && vref.Name.IsDirect)
            {
                if (branch == ConditionBranch.ToTrue)
                {
                    // if (Variable is T) => variable is T in True branch state
                    var vartype = x.AsType.GetTypeRefMask(TypeCtx);
                    if (opTypeMask.IsRef) vartype = vartype.WithRefFlag; // keep IsRef flag

                    State.SetLocalType(State.GetLocalHandle(vref.Name.NameValue), vartype);
                }
            }

            //
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        #endregion

        #region Visit IsSet, OffsetExists

        protected override void Visit(BoundIsSetEx x, ConditionBranch branch)
        {
            Accept(x.VarReference);

            // try to get resulting value and type of the variable
            var localname = AsVariableName(x.VarReference);
            if (localname.IsValid())
            {
                var handle = State.GetLocalHandle(localname);
                Debug.Assert(handle.IsValid);

                // Remove any constant value of isset()
                x.ConstantValue = default;

                //
                if (State.IsLocalSet(handle))
                {
                    // If the variable is always defined, isset() behaves like !is_null()
                    var currenttype = State.GetLocalType(handle);

                    // a type in the true branch:
                    var positivetype = TypeCtx.WithoutNull(currenttype);

                    // resolve the constant if possible,
                    // does not depend on the branch
                    if (!currenttype.IsRef && !currenttype.IsAnyType)
                    {
                        if (positivetype.IsVoid)    // always false
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                        }
                        else if (positivetype == currenttype)   // not void nor null
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(true);
                        }
                    }

                    // we can be more specific in true/false branches:
                    if (branch != ConditionBranch.AnyResult && !x.ConstantValue.HasValue)
                    {
                        // update target type in true/false branch:
                        var newtype = (branch == ConditionBranch.ToTrue)
                            ? positivetype
                            : TypeCtx.GetNullTypeMask();

                        // keep the flags
                        newtype |= currenttype.Flags;

                        //
                        State.SetLocalType(handle, newtype);
                    }
                }
                else if (localname.IsAutoGlobal)
                {
                    // nothing
                }
                else
                {
                    // variable is not set for sure
                    // isset : false
                    x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                }

                // mark variable as either initialized or uninintialized in respective branches
                if (branch == ConditionBranch.ToTrue)
                {
                    State.SetVarInitialized(handle);
                }
            }

            // always returns a boolean
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        public override T VisitOffsetExists(BoundOffsetExists x)
        {
            // receiver[index]
            base.VisitOffsetExists(x);

            // TODO: if receiver is undefined -> result is false

            // always bool
            x.ResultType = DeclaringCompilation.CoreTypes.Boolean;
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
            return default;
        }

        public override T VisitTryGetItem(BoundTryGetItem x)
        {
            // array, index, fallback
            base.VisitTryGetItem(x);

            // TODO: resulting type if possible (see VisitArrayItem)

            // The result of array[index] might be a reference
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;

            return default;
        }

        #endregion

        #region TypeRef

        internal override T VisitIndirectTypeRef(BoundIndirectTypeRef tref)
        {
            // visit indirect type
            base.VisitIndirectTypeRef(tref);

            //
            return VisitTypeRef(tref);
        }

        internal override T VisitTypeRef(BoundTypeRef tref)
        {
            Debug.Assert(!(tref is BoundMultipleTypeRef));

            // resolve type symbol
            tref.ResolvedType = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);

            return default;
        }

        #endregion

        #region Visit Function Call

        protected override T VisitRoutineCall(BoundRoutineCall x)
        {
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag; // unknown function might return a reference

            // TODO: write arguments Access
            // TODO: visit invocation member of
            // TODO: 2 pass, analyze arguments -> resolve method -> assign argument to parameter -> write arguments access -> analyze arguments again

            // visit arguments:
            base.VisitRoutineCall(x);

            return default;
        }

        bool BindParams(IList<PhpParam> expectedparams, ImmutableArray<BoundArgument> givenargs)
        {
            for (int i = 0; i < givenargs.Length; i++)
            {
                if (givenargs[i].IsUnpacking)
                {
                    break;
                }

                if (i < expectedparams.Count)
                {
                    var expected = expectedparams[i];
                    if (expected.IsVariadic)
                    {
                        for (;  i < givenargs.Length; i++)
                        {
                            if (givenargs[i].IsUnpacking)
                            {
                                break; // CONSIDER
                            }

                            BindParam(expected, givenargs[i]);
                        }
                    }
                    else
                    {
                        BindParam(expected, givenargs[i]);
                    }
                }
                else
                {
                    // argument cannot be bound
                    return false;
                }
            }

            return true;
        }

        void BindParam(PhpParam expected, BoundArgument givenarg)
        {
            // bind symbol
            givenarg.Parameter = expected.ParameterSymbol;

            // [PhpRwAttribute]
            if (expected.IsPhpRw)
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (TypeCtx.IsArray(expected.Type) && !givenarg.Value.Access.EnsureArray)   // [PhpRw]PhpArray
                    {
                        SemanticsBinder.BindEnsureArrayAccess(givenarg.Value as BoundReferenceExpression);
                        Worklist.Enqueue(CurrentBlock);
                    }
                }
            }

            // bind ref parameters to variables:
            if (expected.IsAlias || expected.IsByRef)  // => args[i] must be a variable
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (expected.IsByRef && !refexpr.Access.IsWrite)
                    {
                        SemanticsBinder.BindWriteAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (expected.IsAlias && !refexpr.Access.IsReadRef)
                    {
                        SemanticsBinder.BindReadRefAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (refexpr is BoundVariableRef refvar)
                    {
                        if (refvar.Name.IsDirect)
                        {
                            var local = State.GetLocalHandle(refvar.Name.NameValue);
                            State.SetLocalType(local, expected.Type);
                            refvar.MaybeUninitialized = false;
                            if (expected.IsAlias)
                            {
                                State.MarkLocalByRef(local);
                            }
                        }
                        else
                        {
                            // TODO: indirect variable -> all may be aliases of any type
                        }
                    }
                    else
                    {
                        // fields, array items, ...
                        // TODO: remember the field will be accessed as reference
                    }
                }
                else
                {
                    // TODO: Err, variable or field must be passed into byref argument. foo("hello") where function foo(&$x){}
                }
            }
            else if (!expected.Type.IsAnyType && givenarg.Value is BoundVariableRef refvar && refvar.Name.IsDirect)
            {
                // Even for variables passed by value we may gain information about their type (if we previously had none),
                // because not complying with the parameter type would have caused throwing a TypeError
                var local = State.GetLocalHandle(refvar.Name.NameValue);
                var localType = State.GetLocalType(local);
                var paramTypeNonNull = TypeCtx.WithoutNull(expected.Type);
                if (localType.IsAnyType && !localType.IsRef &&
                    (TypeCtx.IsObjectOnly(paramTypeNonNull) || TypeCtx.IsArrayOnly(paramTypeNonNull)))    // E.g. support ?MyClass but not callable
                {
                    Debug.Assert(!expected.Type.IsRef);
                    State.SetLocalType(local, expected.Type);
                }
            }
        }

        TypeRefMask BindValidRoutineCall(BoundRoutineCall call, MethodSymbol method, ImmutableArray<BoundArgument> args, bool maybeoverload)
        {
            // analyze TargetMethod with x.Arguments
            // require method result type if access != none
            if (call.Access.IsRead)
            {
                if (Worklist.EnqueueRoutine(method, CurrentBlock, call))
                {
                    // target will be reanalysed
                    // note: continuing current block may be waste of time, but it might gather other called targets

                    // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                    _flags |= AnalysisFlags.IsCanceled;
                }
            }

            if (Routine != null)
            {
                var rflags = method.InvocationFlags(out var localaccess);
                Routine.Flags |= rflags;

                if ((rflags & RoutineFlags.UsesLocals) != 0
                    //&& (x is BoundGlobalFunctionCall gf && gf.Name.NameValue.Name.Value == "extract") // "compact" does not change locals // CONSIDER // TODO
                    )
                {
                    // function may change/add local variables
                    State.SetAllUnknown(true);
                }

                if (localaccess != null)
                {
                    foreach (var lname in localaccess)
                    {
                        // the variable will be used as reference here
                        State.MarkLocalByRef(State.GetLocalHandle(lname));
                    }
                }
            }

            // process arguments
            if (!BindParams(method.GetExpectedArguments(this.TypeCtx), args) && maybeoverload)
            {
                call.TargetMethod = null; // nullify the target method -> call dynamically, arguments cannot be bound at compile time
            }

            //
            return method.GetResultType(TypeCtx);
        }

        /// <summary>
        /// Bind arguments to target method and resolve resulting <see cref="BoundExpression.TypeRefMask"/>.
        /// Expecting <see cref="BoundRoutineCall.TargetMethod"/> is resolved.
        /// If the target method cannot be bound at compile time, <see cref="BoundRoutineCall.TargetMethod"/> is nulled.
        /// </summary>
        void BindRoutineCall(BoundRoutineCall x, bool maybeOverload = false)
        {
            if (MethodSymbolExtensions.IsValidMethod(x.TargetMethod))
            {
                x.TypeRefMask = BindValidRoutineCall(x, x.TargetMethod, x.ArgumentsInSourceOrder, maybeOverload);
            }
            else if (x.TargetMethod is MissingMethodSymbol || x.TargetMethod == null)
            {
                // we don't know anything about the target callsite,
                // locals passed as arguments should be marked as possible refs:
                foreach (var arg in x.ArgumentsInSourceOrder)
                {
                    if (arg.Value is BoundVariableRef bvar && bvar.Name.IsDirect && !arg.IsUnpacking)
                    {
                        State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                    }
                }
            }
            else if (x.TargetMethod is AmbiguousMethodSymbol ambiguity)
            {
                // check if arguments are not passed by bref, mark locals eventually as refs:
                foreach (var m in ambiguity.Ambiguities)
                {
                    var expected = m.GetExpectedArguments(this.TypeCtx);
                    var given = x.ArgumentsInSourceOrder;

                    for (int i = 0; i < given.Length && i < expected.Count; i++)
                    {
                        if (expected[i].IsAlias && given[i].Value is BoundVariableRef bvar && bvar.Name.IsDirect)
                        {
                            State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                        }
                    }
                }

                // get the return type from all the ambiguities:
                if (!maybeOverload && x.Access.IsRead)
                {
                    var r = (TypeRefMask)0;
                    foreach (var m in ambiguity.Ambiguities)
                    {
                        if (Worklist.EnqueueRoutine(m, CurrentBlock, x))
                        {
                            // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                            _flags |= AnalysisFlags.IsCanceled;
                        }

                        r |= m.GetResultType(TypeCtx);
                    }

                    x.TypeRefMask = r;
                }
            }

            //

            if (x.Access.IsReadRef)
            {
                // reading by ref:
                x.TypeRefMask = x.TypeRefMask.WithRefFlag;
            }
        }

        public override T VisitExit(BoundExitEx x)
        {
            VisitRoutineCall(x);

            // no parameters binding
            // TODO: handle unpacking
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 0 || !x.ArgumentsInSourceOrder[0].IsUnpacking);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            return default;
        }

        public override T VisitEcho(BoundEcho x)
        {
            VisitRoutineCall(x);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            //
            return default;
        }

        public override T VisitConcat(BoundConcatEx x)
        {
            VisitRoutineCall(x);

            // if possible, mark the result type as "String",
            // otherwise we have to use "PhpString"
            var args = x.ArgumentsInSourceOrder;
            bool mustBePhpString = false;
            for (int i = 0; i < args.Length; i++)
            {
                var targ = args[i].Value.TypeRefMask;
                mustBePhpString |= targ.IsRef || targ.IsAnyType || this.TypeCtx.IsWritableString(targ) /*|| this.TypeCtx.IsObject(targ) //object are always converted to UTF16 String// */;
            }

            x.TypeRefMask = mustBePhpString ? TypeCtx.GetWritableStringTypeMask() : TypeCtx.GetStringTypeMask();

            return default;
        }

        public override T VisitAssert(BoundAssertEx x)
        {
            VisitRoutineCall(x);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override void VisitGlobalFunctionCall(BoundGlobalFunctionCall x, ConditionBranch branch)
        {
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.Name.NameValue, Routine);
                if (symbol.IsMissingMethod() && x.NameOpt.HasValue)
                {
                    symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.NameOpt.Value, Routine);
                }

                var overloads = symbol is AmbiguousMethodSymbol ambiguous && ambiguous.IsOverloadable
                    ? new OverloadsList(ambiguous.Ambiguities.ToList())
                    : new OverloadsList(symbol ?? new MissingMethodSymbol(x.Name.NameValue.ToString()));

                Debug.Assert(x.TypeArguments.IsDefaultOrEmpty);

                // symbol might be ErrorSymbol

                x.TargetMethod = overloads.Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.StaticCall);
            }

            BindRoutineCall(x);

            // if possible resolve ConstantValue and TypeRefMask:
            AnalysisFacts.HandleSpecialFunctionCall(x, this, branch);
        }

        public override T VisitInstanceFunctionCall(BoundInstanceFunctionCall x)
        {
            Accept(x.Instance);
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var resolvedtype = x.Instance.ResultType;
                if (resolvedtype == null)
                {
                    var typeref = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));    // ignore NULL, causes runtime exception anyway
                    if (typeref.IsSingle)
                    {
                        resolvedtype = (TypeSymbol)typeref.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                    // else: a common base?
                }

                if (resolvedtype.IsValidType())
                {
                    var candidates = resolvedtype.LookupMethods(x.Name.NameValue.Name.Value);

                    candidates = Construct(candidates, x);

                    x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.InstanceCall);

                    //
                    if (x.TargetMethod.IsValidMethod() && x.TargetMethod.IsStatic && x.Instance.TypeRefMask.IncludesSubclasses)
                    {
                        // static method invoked on an instance object,
                        // must be postponed to runtime since the type may change
                        x.TargetMethod = new AmbiguousMethodSymbol(ImmutableArray.Create(x.TargetMethod), false);
                    }
                }
                else
                {
                    x.TargetMethod = null;
                }
            }

            BindRoutineCall(x, maybeOverload: true);

            return default;
        }

        public override T VisitStaticFunctionCall(BoundStaticFunctionCall x)
        {
            Accept(x.TypeRef);
            Accept(x.Name);

            VisitRoutineCall(x);

            var type = (TypeSymbol)x.TypeRef.Type;

            if (x.Name.NameExpression != null)
            {
                // indirect method call -> not resolvable
            }
            else if (type.IsValidType())
            {
                var candidates = type.LookupMethods(x.Name.ToStringOrThrow());
                // if (candidates.Any(c => c.HasThis)) throw new NotImplementedException("instance method called statically");

                candidates = Construct(candidates, x);

                var flags = OverloadsList.InvocationKindFlags.StaticCall;

                if (Routine != null && !Routine.IsStatic && (x.TypeRef.IsSelf() || x.TypeRef.IsParent()))
                {
                    // self:: or parent:: $this forwarding, prefer both
                    flags |= OverloadsList.InvocationKindFlags.InstanceCall;
                }

                var method = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, flags);

                // method is missing or inaccessible:
                if (method is ErrorMethodSymbol errmethod && (errmethod.ErrorKind == ErrorMethodKind.Inaccessible || errmethod.ErrorKind == ErrorMethodKind.Missing))
                {
                    // NOTE: magic methods __call or __callStatic are called in both cases - the target method is inaccessible or missing

                    var isviable = true; // can we safely resolve the method?
                    List<MethodSymbol> call = null;

                    // __call() might be used, if we have a reference to $this:
                    if (Routine != null && !Routine.IsStatic)
                    {
                        // there is $this variable:
                        if (TypeCtx.ThisType == null || TypeCtx.ThisType.IsOfType(type) || type.IsOfType(TypeCtx.ThisType))
                        {
                            // try to use __call() first:
                            call = type.LookupMethods(Name.SpecialMethodNames.Call.Value);

                            //
                            if (TypeCtx.ThisType == null && call.Count != 0)
                            {
                                // $this is resolved dynamically in runtime and
                                // we don't know if we can use __call() here
                                isviable = false;
                            }
                        }
                    }

                    if (call == null || call.Count == 0)
                    {
                        // __callStatic()
                        call = type.LookupMethods(Name.SpecialMethodNames.CallStatic.Value);
                    }

                    if (call != null && call.Count != 0)
                    {
                        // NOTE: PHP ignores visibility of __callStatic
                        call = Construct(call, x);

                        method = call.Count == 1 && isviable
                            ? new MagicCallMethodSymbol(x.Name.ToStringOrThrow(), call[0])
                            : null; // nullify the symbol so it will be called dynamically and resolved in rutime
                    }
                }

                x.TargetMethod = method;
            }
            else if (x.TypeRef.IsSelf() && Routine != null && Routine.ContainingType.IsTraitType())
            {
                // self:: within trait type
                // resolve possible code path
                // we need this at least to determine possible late static type binding

                var candidates = Construct(Routine.ContainingType.LookupMethods(x.Name.ToStringOrThrow()), x);
                if (candidates.Count != 0)
                {
                    // accessibility not have to be checked here
                    x.TargetMethod = new AmbiguousMethodSymbol(candidates.AsImmutable(), overloadable: true);
                }
            }

            BindRoutineCall(x);

            return default;
        }

        // helper
        List<MethodSymbol> Construct(List<MethodSymbol> methods, BoundRoutineCall bound)
        {
            if (!bound.TypeArguments.IsDefaultOrEmpty)
            {
                var types = bound.TypeArguments.Select(t => (TypeSymbol)t.Type).AsImmutable();

                for (int i = methods.Count - 1; i >= 0; i--)
                {
                    if (methods[i].Arity == types.Length) // TODO: check the type argument is assignable
                    {
                        methods[i] = methods[i].Construct(types);
                    }
                    else
                    {
                        methods.RemoveAt(i);
                    }
                }
            }

            return methods;
        }

        public override T VisitNew(BoundNewEx x)
        {
            Accept(x.TypeRef);      // resolve target type

            VisitRoutineCall(x);    // analyse arguments

            // resolve .ctor method:
            var type = (NamedTypeSymbol)x.TypeRef.Type;
            if (type.IsValidType())
            {
                var candidates = type.InstanceConstructors.ToList();

                //
                x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.New);
                x.ResultType = type;
            }

            // bind arguments:
            BindRoutineCall(x);

            // resulting type is always known,
            // not null,
            // not ref:
            x.TypeRefMask = x.TypeRef.GetTypeRefMask(TypeCtx).WithoutSubclasses;

            return default;
        }

        public override T VisitInclude(BoundIncludeEx x)
        {
            VisitRoutineCall(x);

            // resolve target script
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 1);
            var targetExpr = x.ArgumentsInSourceOrder[0].Value;

            //
            x.TargetMethod = AnalysisFacts.TryResolveFile(_model, Routine, targetExpr, out var script)
                ? (MethodSymbol)script.MainMethod
                : null;

            // resolve result type
            if (x.Access.IsRead)
            {
                var target = x.TargetMethod;
                if (target != null)
                {
                    x.ResultType = target.ReturnType;
                    x.TypeRefMask = target.GetResultType(TypeCtx);

                    if (x.IsOnceSemantic)
                    {
                        // include_once, require_once returns TRUE in case the script was already included
                        x.TypeRefMask |= TypeCtx.GetBooleanTypeMask();
                    }
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;
                }
            }
            else
            {
                x.TypeRefMask = 0;
            }

            // reset type analysis (include may change local variables)
            State.SetAllUnknown(true);

            return default;
        }

        #endregion

        #region Visit FieldRef

        public override T VisitFieldRef(BoundFieldRef x)
        {
            Accept(x.Instance);
            Accept(x.ContainingType);
            Accept(x.FieldName);

            if (x.IsInstanceField)  // {Instance}->FieldName
            {
                Debug.Assert(x.Instance != null);
                Debug.Assert(x.Instance.Access.IsRead);

                // resolve field if possible
                var resolvedtype = x.Instance.ResultType as NamedTypeSymbol;
                if (resolvedtype == null)
                {
                    var typerefs = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));   // ignore NULL, would cause runtime exception in read access, will be ensured to non-null in write access
                    if (typerefs.IsSingle)
                    {
                        resolvedtype = (NamedTypeSymbol)typerefs.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                }

                if (resolvedtype != null)
                {
                    if (x.FieldName.IsDirect)
                    {
                        var fldname = x.FieldName.NameValue.Value;
                        var member = resolvedtype.ResolveInstanceProperty(fldname);
                        if (member != null && member.IsAccessible(this.TypeCtx.SelfType))
                        {
                            if (member is FieldSymbol)
                            {
                                var field = (FieldSymbol)member;
                                var srcf = field as SourceFieldSymbol;
                                var overridenf = srcf?.OverridenDefinition;

                                // field might be a redefinition with a different accessibility,
                                // such field is not declared actually and the base definition is used instead:

                                if (overridenf == null || overridenf.IsAccessible(this.TypeCtx.SelfType))
                                {
                                    x.BoundReference = new FieldReference(x.Instance, overridenf ?? field);
                                    x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                                    x.ResultType = field.Type;
                                    return default;
                                }
                                else if (srcf?.FieldAccessorProperty != null && srcf.FieldAccessorProperty.IsAccessible(TypeCtx.SelfType))
                                {
                                    member = srcf.FieldAccessorProperty; // use the wrapping property that is accessible from current context
                                    // -> continue
                                }
                                else
                                {
                                    member = null; // -> dynamic behavior
                                    // -> continue
                                }
                            }

                            if (member is PropertySymbol)
                            {
                                var prop = (PropertySymbol)member;
                                x.BoundReference = new PropertyReference(x.Instance, prop);
                                x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type);
                                x.ResultType = prop.Type;
                                return default;
                            }

                            //
                            if (member != null)
                            {
                                throw ExceptionUtilities.UnexpectedValue(member);
                            }
                        }
                        else
                        {
                            // TODO: use runtime fields directly, __get, __set, etc.,
                            // do not fallback to BoundIndirectFieldPlace
                        }
                    }
                }

                // dynamic behavior
                // indirect field access ...

                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectFieldPlace(x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                return default;
            }

            // static fields or constants
            if (x.IsStaticField || x.IsClassConstant)    // {ClassName}::${StaticFieldName}, {ClassName}::{ConstantName}
            {
                var containingType = (NamedTypeSymbol)x.ContainingType.Type;

                if (x.IsClassConstant)
                {
                    Debug.Assert(x.Access.IsRead || x.Access.IsNone);
                    Debug.Assert(!x.Access.IsEnsure && !x.Access.IsWrite && !x.Access.IsReadRef);
                }

                if (containingType.IsValidType() && x.FieldName.IsDirect)
                {
                    var fldname = x.FieldName.NameValue.Value;
                    var field = x.IsStaticField ? containingType.ResolveStaticField(fldname) : containingType.ResolveClassConstant(fldname);
                    if (field != null)
                    {
                        // TODO: visibility -> ErrCode

                        if (BindConstantValue(x, field))
                        {
                            Debug.Assert(x.Access.IsRead && !x.Access.IsWrite && !x.Access.IsEnsure);
                            x.BoundReference = null; // not reachable
                        }
                        else
                        {
                            // real.NET static member (CLR static fields) or
                            // the field may be contained in special __statics container (fields & constants)
                            x.BoundReference = new FieldReference(null, field);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                        }

                        x.ResultType = field.Type;
                        return default;
                    }
                    else if (x.IsStaticField)
                    {
                        // TODO: visibility
                        var prop = containingType.LookupMember<PropertySymbol>(fldname);
                        if (prop != null && prop.IsStatic)
                        {
                            x.BoundReference = new PropertyReference(null, prop);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type).WithIsRef(prop.Type.CanBePhpAlias());
                            return default;
                        }
                    }

                    // TODO: __getStatic, __setStatic
                }

                // indirect field access:
                // indirect field access with known class name:
                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectStFieldPlace((BoundTypeRef)x.ContainingType, x.FieldName, x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
            }

            return default;
        }

        #endregion

        #region Visit ArrayEx, ArrayItemEx, ArrayItemOrdEx

        public override T VisitArray(BoundArrayEx x)
        {
            var items = x.Items;
            TypeRefMask elementType = 0;

            // analyse elements
            foreach (var i in items)
            {
                Debug.Assert(i.Value != null);

                Accept(i.Key);
                Accept(i.Value);

                elementType |= i.Value.TypeRefMask;
            }

            // writeup result type
            x.TypeRefMask = elementType.IsVoid
                ? TypeCtx.GetArrayTypeMask()
                : TypeCtx.GetArrayTypeMask(elementType);

            return default;
        }

        public override T VisitArrayItem(BoundArrayItemEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // TODO: resulting type if possible:
            // var element_type = TypeCtx.GetElementType(x.Array.TypeRefMask); // + handle classes with ArrayAccess and TypeRefMask.Uninitialized

            //

            x.TypeRefMask =
                x.Access.IsReadRef ? TypeRefMask.AnyType.WithRefFlag :
                x.Access.IsEnsure ? TypeRefMask.AnyType : // object|array ?
                TypeRefMask.AnyType.WithRefFlag; // result might be a anything (including a reference?)

            return default;
        }

        public override T VisitArrayItemOrd(BoundArrayItemOrdEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // ord($s[$i]) cannot be used as an l-value
            Debug.Assert(!x.Access.MightChange);

            x.TypeRefMask = TypeCtx.GetLongTypeMask();

            return base.VisitArrayItemOrd(x);
        }

        #endregion

        #region VisitLambda

        public override T VisitLambda(BoundLambda x)
        {
            var container = (ILambdaContainerSymbol)Routine.ContainingFile;
            var symbol = container.ResolveLambdaSymbol((LambdaFunctionExpr)x.PhpSyntax);
            if (symbol == null)
            {
                throw ExceptionUtilities.UnexpectedValue(symbol);
            }

            // lambda uses `static` => we have to know where it is:
            Routine.Flags |= (symbol.Flags & RoutineFlags.UsesLateStatic);

            // bind arguments to parameters
            var ps = symbol.SourceParameters;

            // first {N} source parameters correspond to "use" parameters
            for (int pi = 0; pi < x.UseVars.Length; pi++)
            {
                x.UseVars[pi].Parameter = ps[pi];
                VisitArgument(x.UseVars[pi]);
            }

            //
            x.BoundLambdaMethod = symbol;
            x.ResultType = DeclaringCompilation.CoreTypes.Closure;
            Debug.Assert(x.ResultType != null);
            x.TypeRefMask = TypeCtx.GetTypeMask(new BoundLambdaTypeRef(TypeRefMask.AnyType), false); // specific {Closure}, no null, no subclasses

            return default;
        }

        #endregion

        #region VisitYield

        public override T VisitYieldStatement(BoundYieldStatement x)
        {
            base.VisitYieldStatement(x);

            return default;
        }

        public override T VisitYieldEx(BoundYieldEx x)
        {
            base.VisitYieldEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        public override T VisitYieldFromEx(BoundYieldFromEx x)
        {
            base.VisitYieldFromEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion

        #region Visit

        public override T VisitIsEmpty(BoundIsEmptyEx x)
        {
            Accept(x.Operand);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override T VisitUnset(BoundUnset x)
        {
            base.VisitUnset(x);

            return default;
        }

        public override T VisitList(BoundListEx x)
        {
            var elementtype = this.TypeCtx.GetElementType(x.Access.WriteMask);
            Debug.Assert(!elementtype.IsVoid);

            foreach (var v in x.Items)   // list() may contain NULL implying ignored variable
            {
                if (v.Value != null)
                {
                    Accept(v.Key);
                    Visit(v.Value, v.Value.Access.WithWrite(elementtype));
                }
            }

            return default;
        }

        public override T VisitPseudoConstUse(BoundPseudoConst x)
        {
            object value = null;

            switch (x.ConstType)
            {
                case BoundPseudoConst.Types.Line:
                    value = x.PhpSyntax.ContainingSourceUnit.GetLineFromPosition(x.PhpSyntax.Span.Start) + 1;
                    break;

                case BoundPseudoConst.Types.Class:
                case BoundPseudoConst.Types.Trait:
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        if (containingtype != null)
                        {
                            var intrait = containingtype.MemberAttributes.IsTrait();

                            value = containingtype.QualifiedName.ToString();

                            if (intrait && x.ConstType == BoundPseudoConst.Types.Class)
                            {
                                // __CLASS__ inside trait resolved in runtime
                                x.TypeRefMask = TypeCtx.GetStringTypeMask();
                                return default;
                            }

                            if (!intrait && x.ConstType == BoundPseudoConst.Types.Trait)
                            {
                                // __TRAIT__ inside class is empty string
                                value = string.Empty;
                            }
                        }
                        else
                        {
                            value = string.Empty;
                        }
                    }
                    break;

                case BoundPseudoConst.Types.Method:
                    if (Routine == null)
                    {
                        value = string.Empty;
                    }
                    else if (Routine is SourceLambdaSymbol)
                    {
                        // value = __CLASS__::"{closure}"; // PHP 5
                        value = "{closure}";    // PHP 7+
                    }
                    else
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        value = containingtype != null
                            ? containingtype.QualifiedName.ToString(new Name(Routine.RoutineName), false)
                            : Routine.RoutineName;
                    }
                    break;

                case BoundPseudoConst.Types.Function:
                    if (Routine is SourceLambdaSymbol)
                    {
                        value = "{closure}";
                    }
                    else
                    {
                        value = Routine != null ? Routine.RoutineName : string.Empty;
                    }
                    break;

                case BoundPseudoConst.Types.Namespace:
                    var ns = x.PhpSyntax.ContainingNamespace;
                    value = ns != null && ns.QualifiedName.HasValue
                        ? ns.QualifiedName.QualifiedName.NamespacePhpName
                        : string.Empty;
                    break;

                case BoundPseudoConst.Types.Dir:
                case BoundPseudoConst.Types.File:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                case BoundPseudoConst.Types.RootPath:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            Debug.Assert(value != null);    // pseudoconstant has been set

            x.ConstantValue = new Optional<object>(value);

            if (value is string) x.TypeRefMask = TypeCtx.GetStringTypeMask();
            else if (value is int || value is long) x.TypeRefMask = TypeCtx.GetLongTypeMask();
            else throw ExceptionUtilities.UnexpectedValue(value);

            return default;
        }

        public override T VisitPseudoClassConstUse(BoundPseudoClassConst x)
        {
            base.VisitPseudoClassConstUse(x);

            //
            if (x.ConstType == PseudoClassConstUse.Types.Class)
            {
                x.TypeRefMask = TypeCtx.GetStringTypeMask();

                // resolve the value:

                var type = x.TargetType.Type as TypeSymbol;
                if (type.IsValidType() && type is IPhpTypeSymbol phpt)
                {
                    x.ConstantValue = new Optional<object>(phpt.FullName.ToString());
                }
                else
                {
                    var tref = x.TargetType.PhpSyntax as TypeRef;
                    var qname = tref?.QualifiedName;
                    if (qname.HasValue)
                    {
                        if (!qname.Value.IsReservedClassName) // self, static, parent
                        {
                            x.ConstantValue = new Optional<object>(qname.Value.ToString());
                        }
                    }
                }
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            return default;
        }

        public override T VisitGlobalConstUse(BoundGlobalConst x)
        {
            // TODO: check constant name

            // bind to app-wide constant if possible
            var symbol = (Symbol)_model.ResolveConstant(x.Name.ToString());
            var field = symbol as FieldSymbol;

            if (!BindConstantValue(x, field))
            {
                if (field != null && field.IsStatic)
                {
                    if (field.Type.Is_Func_Context_TResult(out var tresult))
                    {
                        // lazy constant
                        // public static readonly Func<Context, TResult> Constant = (ctx) => VALUE;
                        x._boundExpressionOpt = new InvokeReference(new FieldPlace(null, field));
                        x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, tresult);
                    }
                    else
                    {
                        // constant
                        // public static readonly T Constant = VALUE
                        x._boundExpressionOpt = new FieldReference(null, field);
                        x.TypeRefMask = field.GetResultType(TypeCtx);
                    }
                }
                else if (symbol is PEPropertySymbol prop && prop.IsStatic)
                {
                    // constant
                    // public static T Constant => VALUE;
                    x._boundExpressionOpt = new PropertyReference(null, prop);
                    x.TypeRefMask = prop.GetResultType(TypeCtx);
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;    // only scalars ?
                }
            }

            return default;
        }

        public override T VisitConditional(BoundConditionalEx x)
        {
            BoundExpression positiveExpr;    // positive expression (if evaluated to true, FalseExpr is not evaluated)
            FlowState positiveState; // state after successful positive branch

            if (x.IfTrue != null && x.IfTrue != x.Condition)
            {
                // Template: Condition ? IfTrue : IfFalse

                var originalState = State.Clone();
                positiveExpr = x.IfTrue;

                // true branch:
                if (VisitCondition(x.Condition, ConditionBranch.ToTrue))
                {
                    Accept(x.IfTrue);
                    positiveState = State;

                    // false branch
                    State = originalState.Clone();
                    VisitCondition(x.Condition, ConditionBranch.ToFalse);
                }
                else
                {
                    // OPTIMIZATION: Condition does not have to be visited twice!

                    originalState = State.Clone(); // state after visiting Condition

                    Accept(x.IfTrue);
                    positiveState = State;

                    State = originalState.Clone();
                }
            }
            else
            {
                // Template: Condition ?: IfFalse
                positiveExpr = x.Condition;

                // in case ?: do not evaluate trueExpr twice:
                // Template: Condition ?: FalseExpr

                Accept(x.Condition);
                positiveState = State.Clone();

                // condition != false => condition != null =>
                // ignoring NULL type from Condition:
                x.Condition.TypeRefMask = TypeCtx.WithoutNull(x.Condition.TypeRefMask);
            }

            // and start over with false branch:
            Accept(x.IfFalse);

            // merge both states (after positive evaluation and the false branch)
            State = State.Merge(positiveState);
            x.TypeRefMask = positiveExpr.TypeRefMask | x.IfFalse.TypeRefMask;

            return default;
        }

        public override T VisitExpressionStatement(BoundExpressionStatement x)
        {
            return base.VisitExpressionStatement(x);
        }

        public override T VisitReturn(BoundReturnStatement x)
        {
            if (x.Returned != null)
            {
                Accept(x.Returned);
                State.FlowThroughReturn(x.Returned.TypeRefMask);
            }
            else
            {
                // remember "void" type explicitly
                var voidMask = State.TypeRefContext.GetTypeMask(BoundTypeRefFactory.VoidTypeRef, false); // NOTE: or remember the routine may return Void
                State.FlowThroughReturn(voidMask);
            }

            return default;
        }

        public override T VisitEval(BoundEvalEx x)
        {
            base.VisitEval(x);

            //
            State.SetAllUnknown(true);

            //
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion
    }
}

---- Transformed Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.CodeGen;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Pchp.CodeAnalysis.Symbols;
using Roslyn.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Ast = Devsense.PHP.Syntax.Ast;

namespace Pchp.CodeAnalysis.FlowAnalysis
{
    /// <summary>
    /// Visits single expressions and project transformations to flow state.
    /// </summary>
    internal class ExpressionAnalysis<T> : AnalysisWalker<FlowState, T>
    {
        #region Fields & Properties

        /// <summary>
        /// The worklist to be used to enqueue next blocks.
        /// </summary>
        internal Worklist<BoundBlock> Worklist { get; }

        /// <summary>
        /// Gets model for symbols resolution.
        /// </summary>
        internal ISymbolProvider/*!*/Model => _model;
        readonly ISymbolProvider/*!*/_model;

        /// <summary>
        /// Reference to corresponding source routine.
        /// </summary>
        public SourceRoutineSymbol Routine => State.Routine;

        /// <summary>
        /// Gets current type context for type masks resolving.
        /// </summary>
        internal TypeRefContext TypeCtx => State.TypeRefContext;

        protected PhpCompilation DeclaringCompilation => _model.Compilation;

        protected BoundTypeRefFactory BoundTypeRefFactory => DeclaringCompilation.TypeRefFactory;

        #endregion

        #region Helpers

        /// <summary>
        /// In case given expression is a local or parameter reference,
        /// gets its variable handle within <see cref="State"/>.
        /// </summary>
        VariableHandle TryGetVariableHandle(BoundExpression expr)
        {
            var varname = AsVariableName(expr as BoundReferenceExpression);
            if (varname.IsValid())
            {
                return State.GetLocalHandle(varname);
            }
            else
            {
                return default(VariableHandle);
            }
        }

        /// <summary>
        /// In case of a local variable or parameter, gets its name.
        /// </summary>
        static VariableName AsVariableName(BoundReferenceExpression r)
        {
            if (r is BoundVariableRef vr)
            {
                return vr.Name.NameValue;
            }

            return default;
        }

        static bool IsLongConstant(BoundExpression expr, long value)
        {
            if (expr.ConstantValue.HasValue)
            {
                if (expr.ConstantValue.Value is long) return ((long)expr.ConstantValue.Value) == value;
                if (expr.ConstantValue.Value is int) return ((int)expr.ConstantValue.Value) == value;
            }
            return false;
        }

        static bool TryConvertToNumber(object value, out long l, out double d)
        {
            if (value is int i)
            {
                l = i;
                d = (double)l;
                return true;
            }

            if (value is long l)
            {
                l = l;
                d = (double)l;
                return true;
            }

            if (value is double d)
            {
                d = d;
                l = (long)d;
                return true;
            }

            if (value is bool)
            {
                l = (bool)value ? 1 : 0;
                d = (double)l;
                return true;
            }

            if (value is string s)
            {
                if (long.TryParse(s, out l))
                {
                    d = (double)l;
                    return true;
                }

                if (double.TryParse(s, out d))
                {
                    l = (long)d;
                    return true;
                }
            }

            l = default;
            d = default;
            return false;
        }

        bool BindConstantValue(BoundExpression target, FieldSymbol symbol)
        {
            if (symbol != null && symbol.IsConst)
            {
                var cvalue = symbol.GetConstantValue(false);
                target.ConstantValue = (cvalue != null) ? new Optional<object>(cvalue.Value) : null;

                if (cvalue != null && cvalue.IsNull)
                {
                    target.TypeRefMask = TypeCtx.GetNullTypeMask();
                    return true;
                }

                target.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, symbol.Type, notNull: true);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Finds the root of given chain, i.e.:
        /// $a : $a
        /// $$a : $a
        /// $a->b : $a
        /// $a[..] : $a
        /// $a->foo() : $a
        /// etc.
        /// </summary>
        /// <remarks>If given expression 'isset', its root returned by this method must be set as well.</remarks>
        internal BoundExpression TryGetExpressionChainRoot(BoundExpression x)
        {
            if (x != null)
            {
                if (x is BoundVariableRef v) return v.Name.IsDirect ? v : TryGetExpressionChainRoot(v.Name.NameExpression);
                if (x is BoundFieldRef f) return TryGetExpressionChainRoot(f.Instance ?? (f.ContainingType as BoundIndirectTypeRef)?.TypeExpression);
                if (x is BoundInstanceFunctionCall m) return TryGetExpressionChainRoot(m.Instance);
                if (x is BoundArrayItemEx a) return TryGetExpressionChainRoot(a.Array);
            }

            return null;
        }

        /// <summary>
        /// Gets current visibility scope.
        /// </summary>
        protected OverloadsList.VisibilityScope VisibilityScope => new OverloadsList.VisibilityScope(TypeCtx.SelfType, Routine);

        protected void PingSubscribers(ExitBlock exit)
        {
            if (exit != null)
            {
                var wasNotAnalysed = false;

                if (Routine != null && !Routine.IsReturnAnalysed)
                {
                    Routine.IsReturnAnalysed = true;
                    wasNotAnalysed = true;
                }

                // Ping the subscribers either if the return type has changed or
                // it is the first time the analysis reached the routine exit
                var rtype = State.GetReturnType();
                if (rtype != exit._lastReturnTypeMask || wasNotAnalysed)
                {
                    exit._lastReturnTypeMask = rtype;
                    var subscribers = exit.Subscribers;
                    if (subscribers.Count != 0)
                    {
                        lock (subscribers)
                        {
                            foreach (var subscriber in subscribers)
                            {
                                Worklist.PingReturnUpdate(exit, subscriber);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsDouble(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(BoundExpression x) => IsDoubleOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsLong(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(BoundExpression x) => IsLongOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        /// <param name="tmask"></param>
        /// <returns></returns>
        protected bool IsNumberOnly(TypeRefMask tmask)
        {
            if (TypeCtx.IsLong(tmask) || TypeCtx.IsDouble(tmask))
            {
                if (tmask.IsSingleType)
                {
                    return true;
                }

                return !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsNumber();
            }

            return false;
        }

        /// <summary>
        /// Gets value indicating the given type represents only class types.
        /// </summary>
        protected bool IsClassOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsObject();
        }

        /// <summary>
        /// Gets value indicating the given type represents only array types.
        /// </summary>
        protected bool IsArrayOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsArray();
        }

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        protected bool IsNumberOnly(BoundExpression x) => IsNumberOnly(x.TypeRefMask);

        #endregion

        #region Construction

        /// <summary>
        /// Creates an instance of <see cref="ExpressionAnalysis{T}"/> that can analyse a block.
        /// </summary>
        /// <param name="worklist">The worklist to be used to enqueue next blocks.</param>
        /// <param name="model">The semantic context of the compilation.</param>
        public ExpressionAnalysis(Worklist<BoundBlock> worklist, ISymbolProvider model)
        {
            Debug.Assert(model != null);
            _model = model;
            Worklist = worklist;
        }

        #endregion

        #region State and worklist handling

        protected override bool IsStateInitialized(FlowState state) => state != null;

        protected override bool AreStatesEqual(FlowState a, FlowState b) => a.Equals(b);

        protected override FlowState GetState(BoundBlock block) => block.FlowState;

        protected override void SetState(BoundBlock block, FlowState state) => block.FlowState = state;

        protected override FlowState CloneState(FlowState state) => state.Clone();

        protected override FlowState MergeStates(FlowState a, FlowState b) => a.Merge(b);

        protected override void SetStateUnknown(ref FlowState state) => state.SetAllUnknown(true);

        protected override void EnqueueBlock(BoundBlock block) => Worklist.Enqueue(block);

        #endregion

        #region Visit blocks

        public override T VisitCFGExitBlock(ExitBlock x)
        {
            VisitCFGBlock(x);

            // TODO: EdgeToCallers:
            PingSubscribers(x);

            return default;
        }

        public override T VisitCFGCatchBlock(CatchBlock x)
        {
            VisitCFGBlockInit(x);

            // add catch control variable to the state
            x.TypeRef.Accept(this);

            if (x.Variable != null)
            {
                x.Variable.Access = BoundAccess.Write.WithWrite(x.TypeRef.GetTypeRefMask(TypeCtx));
                State.SetLocalType(State.GetLocalHandle(x.Variable.Name.NameValue), x.Variable.Access.WriteMask);
                Accept(x.Variable);

                //
                x.Variable.ResultType = (TypeSymbol)x.TypeRef.Type;
            }


            //
            DefaultVisitBlock(x);

            return default;
        }

        #endregion

        #region Declaration Statements

        public override T VisitStaticStatement(BoundStaticVariableStatement x)
        {
            var v = x.Declaration;
            var local = State.GetLocalHandle(new VariableName(v.Name));

            State.SetVarKind(local, VariableKind.StaticVariable);

            var oldtype = State.GetLocalType(local).WithRefFlag;

            // set var
            if (v.InitialValue != null)
            {
                // analyse initializer
                Accept(v.InitialValue);

                bool isInt = v.InitialValue.ConstantValue.IsInteger(out long intVal);
                State.SetLessThanLongMax(local, isInt && intVal < long.MaxValue);
                State.SetGreaterThanLongMin(local, isInt && intVal > long.MinValue);

                State.SetLocalType(local, ((IPhpExpression)v.InitialValue).TypeRefMask | oldtype);
            }
            else
            {
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetLocalType(local, TypeCtx.GetNullTypeMask() | oldtype);
                // TODO: explicitly State.SetLocalUninitialized() ?
            }

            return default;
        }

        public override T VisitGlobalStatement(BoundGlobalVariableStatement x)
        {
            base.VisitGlobalStatement(x);   // Accept(x.Variable)

            return default;
        }

        #endregion

        #region Visit Literals

        public override T VisitLiteral(BoundLiteral x)
        {
            x.TypeRefMask = x.ResolveTypeMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit CopyValue

        public override T VisitCopyValue(BoundCopyValue x)
        {
            Accept(x.Expression);

            var tmask = x.Expression.TypeRefMask;

            if (tmask.IsRef)
            {
                // copied value is possible a reference,
                // might be anything:
                tmask = TypeRefMask.AnyType;
            }

            // the result is not a reference for sure:
            Debug.Assert(!tmask.IsRef);

            x.TypeRefMask = tmask;

            return default;
        }

        #endregion

        #region Visit Assignments

        public override T VisitAssign(BoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            //
            Accept(x.Value);

            // keep WriteRef flag
            var targetaccess = BoundAccess.None.WithWrite(x.Value.TypeRefMask);
            if (x.Target.Access.IsWriteRef)
            {
                targetaccess = targetaccess.WithWriteRef(0);
            }

            // new target access with resolved target type
            Visit(x.Target, targetaccess);

            //
            x.TypeRefMask = x.Value.TypeRefMask;

            return default;
        }

        public override T VisitCompoundAssign(BoundCompoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            // Target X Value
            var tmp = new BoundBinaryEx(x.Target.WithAccess(BoundAccess.Read), x.Value, AstUtils.CompoundOpToBinaryOp(x.Operation));
            Visit(tmp, ConditionBranch.AnyResult);

            // Target =
            Visit(x.Target, BoundAccess.Write.WithWrite(tmp.TypeRefMask));

            // put read access back
            x.Target.Access = x.Target.Access.WithRead();

            //
            x.TypeRefMask = tmp.TypeRefMask;

            return default;
        }

        protected virtual void VisitSuperglobalVariableRef(BoundVariableRef x)
        {
            Debug.Assert(x.Name.IsDirect);
            Debug.Assert(x.Name.NameValue.IsAutoGlobal);

            // remember the initial state of variable at this point
            x.BeforeTypeRef = TypeRefMask.AnyType;

            // bind variable place
            x.Variable = Routine.LocalsTable.BindAutoGlobalVariable(x.Name.NameValue);

            // update state
            if (x.Access.IsRead)
            {
                TypeRefMask vartype;

                if (x.Name.NameValue == VariableName.HttpRawPostDataName)
                {
                    // $HTTP_RAW_POST_DATA : string // TODO: make it mixed or string | binary string
                    vartype = TypeCtx.GetStringTypeMask();
                }
                else
                {
                    // all the other autoglobals are arrays:
                    vartype = TypeCtx.GetArrayTypeMask();
                }

                if (x.Access.IsReadRef)
                {
                    vartype = vartype.WithRefFlag;
                }

                if (x.Access.EnsureObject)
                {
                    // TODO: report ERR
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                x.TypeRefMask = x.Access.WriteMask;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
            }
        }

        protected virtual void VisitLocalVariableRef(BoundVariableRef x, VariableHandle local)
        {
            Debug.Assert(local.IsValid);

            if (Routine == null)
            {
                // invalid use of variable:
                return;
            }

            var previoustype = State.GetLocalType(local);       // type of the variable in the previous state

            // remember the initial state of variable at this point
            x.BeforeTypeRef = previoustype;

            // bind variable place
            if (x.Variable == null)
            {
                x.Variable = x.IsLowerTemp()     // synthesized variable constructed by semantic binder
                    ? Routine.LocalsTable.BindTemporalVariable(local.Name)
                    : Routine.LocalsTable.BindLocalVariable(local.Name, x.PhpSyntax.Span.ToTextSpan());
            }

            //
            State.VisitLocal(local);

            // update state
            if (x.Access.IsRead)
            {
                var vartype = previoustype;

                if (x.Variable is ThisVariableReference)
                {
                    // optimization; we know the exact type here or at least we know it is `Object` (instead of AnyType)
                    // if vartype is resolved to a single instance it was probably done by some operand like 'instanceof' already and better

                    if (vartype.IsSingleType == false || Routine.IsGlobalScope)
                    {
                        vartype = TypeCtx.GetThisTypeMask(); // : System.Object or exact type, with subclasses if applicable
                    }
                }
                else if (vartype.IsVoid || Routine.IsGlobalScope)
                {
                    // in global code or in case of undefined variable,
                    // assume the type is mixed (unspecified).
                    // In global code, the type of variable cannot be determined by type analysis, it can change between every two operations (this may be improved by better flow analysis).
                    vartype = TypeRefMask.AnyType;
                    vartype.IsRef = previoustype.IsRef;

                    if (Routine.IsGlobalScope)
                    {
                        // in global code, treat the variable as initialized always:
                        State.SetVarInitialized(local);
                        vartype.IsRef = true;   // variable might be a reference
                    }
                }
                else
                {
                    //// if there are multiple types possible
                    //// find the common base (this allows for better methods resolution)
                    //if (!vartype.IsAnyType && !vartype.IsRef && vartype.IncludesSubclasses && !vartype.IsSingleType && TypeCtx.IsObject(vartype))
                    //{
                    //    // ...
                    //}
                }

                if (x.Access.IsEnsure)
                {
                    if (x.Access.IsReadRef)
                    {
                        State.MarkLocalByRef(local);
                        vartype.IsRef = true;
                    }
                    if (x.Access.EnsureObject && !TypeCtx.IsObject(vartype))
                    {
                        vartype |= TypeCtx.GetSystemObjectTypeMask();
                    }
                    if (x.Access.EnsureArray)
                    {
                        if (!TypeHelpers.HasArrayAccess(vartype, TypeCtx, DeclaringCompilation))
                        {
                            vartype |= TypeCtx.GetArrayTypeMask();
                        }
                        else if (TypeCtx.IsReadonlyString(vartype))
                        {
                            vartype |= TypeCtx.GetWritableStringTypeMask();
                        }
                    }

                    State.SetLocalType(local, vartype);
                }
                else
                {
                    // reset 'MaybeUninitialized' flag:
                    x.MaybeUninitialized = false;

                    if (!State.IsLocalSet(local))
                    {
                        // do not flag as uninitialized if variable:
                        // - may be a reference
                        // - is in a global scope
                        if (!vartype.IsRef && !Routine.IsGlobalScope)
                        {
                            x.MaybeUninitialized = true;
                        }

                        // variable maybe null if it can be uninitialized
                        vartype |= TypeCtx.GetNullTypeMask();
                    }
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                var vartype = x.Access.WriteMask;

                if (x.Access.IsWriteRef || previoustype.IsRef)    // keep the ref flag of local
                {
                    vartype.IsRef = true;
                    State.MarkLocalByRef(local);
                }
                else if (vartype.IsRef)
                {
                    // // we can't be sure about the type
                    vartype = TypeRefMask.AnyType; // anything, not ref
                                                   //vartype.IsRef = false;  // the variable won't be a reference from this point
                }

                //
                State.SetLocalType(local, vartype);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
                State.SetLocalType(local, x.TypeRefMask);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetVarUninitialized(local);
            }
        }

        public override T VisitVariableRef(BoundVariableRef x)
        {
            if (x.Name.IsDirect)
            {
                // direct variable access:
                if (x.Name.NameValue.IsAutoGlobal)
                {
                    VisitSuperglobalVariableRef(x);
                }
                else
                {
                    VisitLocalVariableRef(x, State.GetLocalHandle(x.Name.NameValue));
                }
            }
            else
            {
                x.BeforeTypeRef = TypeRefMask.AnyType;

                Accept(x.Name.NameExpression);

                // bind variable place
                x.Variable ??= new LocalVariableReference(VariableKind.LocalVariable, Routine, null, x.Name);

                // update state
                if (x.Access.IsRead)
                {
                    State.FlowContext.SetAllUsed();
                    x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                }

                if (x.Access.IsWrite || x.Access.IsEnsure)
                {
                    State.SetAllUnknown(x.Access.IsWriteRef);
                    x.TypeRefMask = x.Access.WriteMask;
                }

                if (x.Access.IsUnset)
                {

                }
            }

            return default;
        }

        public override T VisitIncDec(BoundIncDecEx x)
        {
            // <target> = <target> +/- 1L

            Debug.Assert(x.Access.IsRead || x.Access.IsNone);
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);

            Visit(x.Target, BoundAccess.Read);
            Visit(x.Value, BoundAccess.Read);

            Debug.Assert(IsNumberOnly(x.Value));    // 1L

            TypeRefMask resulttype;
            TypeRefMask sourcetype = x.Target.TypeRefMask;  // type of target before operation

            VariableHandle lazyVarHandle = default;
            bool lessThanLongMax = false;               // whether the variable's value is less than the max long value
            bool greaterThanLongMin = false;            // or greater than the min long value

            if (IsDoubleOnly(x.Target))
            {
                // double++ => double
                resulttype = TypeCtx.GetDoubleTypeMask();
            }
            else
            {
                // we'd like to keep long if we are sure we don't overflow to double
                lazyVarHandle = TryGetVariableHandle(x.Target);
                if (lazyVarHandle.IsValid && x.IsIncrement && State.IsLessThanLongMax(lazyVarHandle))
                {
                    // long++ [< long.MaxValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    lessThanLongMax = true;
                }
                else if (lazyVarHandle.IsValid && !x.IsIncrement && State.IsGreaterThanLongMin(lazyVarHandle))
                {
                    // long-- [> long.MinValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    greaterThanLongMin = true;
                }
                else
                {
                    // long|double|anything++/-- => number
                    resulttype = TypeCtx.GetNumberTypeMask();
                }
            }

            Visit(x.Target, BoundAccess.Write.WithWrite(resulttype));

            //
            x.Target.Access = x.Target.Access.WithRead();   // put read access back to the target
            x.TypeRefMask = x.IsPostfix ? sourcetype : resulttype;

            // We expect that an incrementation doesn't change the property of being less than the max long value,
            // it needs to be restored due to the write access of the target variable
            if (lessThanLongMax)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetLessThanLongMax(lazyVarHandle, true);
            }

            // The same for the min long value
            if (greaterThanLongMin)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetGreaterThanLongMin(lazyVarHandle, true);
            }

            return default;
        }

        #endregion

        #region Visit BinaryEx

        private void VisitShortCircuitOp(BoundExpression lExpr, BoundExpression rExpr, bool isAndOp, ConditionBranch branch)
        {
            // Each operand has to be evaluated in various states and then the state merged.
            // Simulates short-circuit evaluation in runtime:

            var state = this.State; // original state

            if (branch == ConditionBranch.AnyResult)
            {
                if (isAndOp)
                {
                    // A == True && B == Any
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == Any
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToTrue)
            {
                if (isAndOp)
                {
                    // A == True && B == True

                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                }
                else
                {
                    // A == False && B == True
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToFalse)
            {
                if (isAndOp)
                {
                    // A == True && B == False
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == False

                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                }
            }
        }

        /// <summary>
        /// Gets resulting type of bit operation (bit or, and, xor).
        /// </summary>
        TypeRefMask GetBitOperationType(TypeRefMask lValType, TypeRefMask rValType)
        {
            TypeRefMask type;

            // type is string if both operands are string
            if ((lValType.IsAnyType && rValType.IsAnyType) ||
                (TypeCtx.IsAString(lValType) && TypeCtx.IsAString(rValType)))
            {
                type = TypeCtx.GetStringTypeMask();
            }
            else
            {
                type = default(TypeRefMask);
            }

            // type can be always long
            type |= TypeCtx.GetLongTypeMask();

            //
            return type;
        }

        Optional<object> ResolveBooleanOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (xobj.TryConvertToBool(out var bx) && yobj.TryConvertToBool(out var by))
            {
                return op switch
                {
                    Operations.And => (bx && by),
                    Operations.Or => (bx || by),
                    Operations.Xor => (bx ^ by),
                    _ => throw ExceptionUtilities.Unreachable,
                };
            }

            return default;
        }

        /// <summary>
        /// Resolves value of bit operation.
        /// </summary>
        /// <remarks>TODO: move to **evaluation**.</remarks>
        Optional<object> ResolveBitOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            var xconst = xobj.ToConstantValueOrNull();
            var yconst = yobj.ToConstantValueOrNull();

            if (xconst.TryConvertToLong(out long xval) && yconst.TryConvertToLong(out long yval))
            {
                long result;

                switch (op)
                {
                    case Operations.BitOr: result = xval | yval; break;
                    case Operations.BitAnd: result = xval & yval; break;
                    case Operations.BitXor: result = xval ^ yval; break;
                    default:
                        throw new ArgumentException(nameof(op));
                }

                //
                if (result >= int.MinValue && result <= int.MaxValue)
                {
                    return (int)result;
                }
                else
                {
                    return result;
                }

                //
            }

            return default(Optional<object>);
        }

        /// <summary>
        /// Gets resulting type of <c>+</c> operation.
        /// </summary>
        TypeRefMask GetPlusOperationType(BoundExpression left, BoundExpression right)
        {
            var lValType = left.TypeRefMask;
            var rValType = right.TypeRefMask;

            // array + array => array
            // array + number => 0 (ERROR)
            // number + number => number
            // anytype + array => array
            // anytype + number => number

            var or = lValType | rValType;

            if (IsNumberOnly(or))
            {
                // double + number => double
                if (IsDoubleOnly(lValType) || IsDoubleOnly(rValType))
                    return TypeCtx.GetDoubleTypeMask();

                // long + long => long
                if (State.IsLessThanLongMax(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG + 1, where LONG < long.MaxValue
                    return TypeCtx.GetLongTypeMask();

                return TypeCtx.GetNumberTypeMask();
            }

            if ((!lValType.IsRef && !lValType.IsAnyType && !TypeCtx.IsArray(lValType)) ||
                (!rValType.IsRef && !rValType.IsAnyType && !TypeCtx.IsArray(rValType)))
            {
                // not array for sure:
                return TypeCtx.GetNumberTypeMask();
            }

            //
            var type = TypeCtx.GetArraysFromMask(or);

            //
            if (or.IsAnyType || TypeCtx.IsNumber(or) || type == 0) // !this.TypeRefContext.IsArray(lValType & rValType))
                type |= TypeCtx.GetNumberTypeMask();    // anytype or an operand is number or operands are not a number nor both are not array

            if (or.IsAnyType)
                type |= TypeCtx.GetArrayTypeMask();

            //
            return type;
        }

        static Optional<object> ResolvePlusOperation(Optional<object> xobj, Optional<object> yobj)
        {
            if (xobj.HasValue && yobj.HasValue)
            {
                switch (xobj.Value)
                {
                    case double x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return x + y;
                        }
                        break;
                    case long x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y:
                                try { return checked(x + y); }
                                catch (OverflowException) { return (double)x + y; }
                            case int y: return x + y;
                        }
                        break;
                    case int x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return (long)x + y;
                        }
                        break;
                }
            }

            return default;
        }

        static Optional<object> ResolveOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (!xobj.HasValue || !yobj.HasValue)
            {
                return default;
            }

            switch (op)
            {
                case Operations.Add:
                    return ResolvePlusOperation(xobj, yobj);

                case Operations.Mul:
                    switch (xobj.Value)
                    {
                        case double x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y: return x * y;
                                case int y: return x * y;
                            }
                            break;
                        case int x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                        case long x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                    }
                    break;
            }

            return default;
        }

        /// <summary>
        /// Gets resulting type of <c>-</c> operation.
        /// </summary>
        TypeRefMask GetMinusOperationType(BoundExpression left, BoundExpression right)
        {
            if (IsDoubleOnly(left.TypeRefMask) || IsDoubleOnly(right.TypeRefMask)) // some operand is double and nothing else
                return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
            else if (State.IsGreaterThanLongMin(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG -1, where LONG > long.MinValue
                return TypeCtx.GetLongTypeMask();
            else
                return TypeCtx.GetNumberTypeMask();
        }

        protected override void Visit(BoundBinaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveBinaryEx(x, branch);
        }

        TypeRefMask ResolveBinaryEx(BoundBinaryEx x, ConditionBranch branch)
        {
            if (x.Operation == Operations.And || x.Operation == Operations.Or)
            {
                this.VisitShortCircuitOp(x.Left, x.Right, x.Operation == Operations.And, branch);
            }
            else
            {
                Accept(x.Left);
                Accept(x.Right);
            }

            switch (x.Operation)
            {
                #region Arithmetic Operations

                case Operations.Add:
                    x.ConstantValue = ResolvePlusOperation(x.Left.ConstantValue, x.Right.ConstantValue);
                    return x.ConstantValue.HasValue
                        ? TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue)
                        : GetPlusOperationType(x.Left, x.Right);

                case Operations.Sub:
                    return GetMinusOperationType(x.Left, x.Right);

                case Operations.Div:
                case Operations.Mul:
                case Operations.Pow:

                    x.ConstantValue = ResolveOperation(x.Left.ConstantValue, x.Right.ConstantValue.Value, x.Operation);
                    if (x.ConstantValue.HasValue)
                    {
                        return TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue);
                    }
                    else if (IsDoubleOnly(x.Left.TypeRefMask) || IsDoubleOnly(x.Right.TypeRefMask)) // some operand is double and nothing else
                    {
                        return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
                    }
                    else
                    {
                        return TypeCtx.GetNumberTypeMask();
                    }

                case Operations.Mod:
                    return TypeCtx.GetLongTypeMask();

                case Operations.ShiftLeft:
                case Operations.ShiftRight:

                    x.ConstantValue = ResolveShift(x.Operation, x.Left.ConstantValue, x.Right.ConstantValue);
                    return TypeCtx.GetLongTypeMask();

                #endregion

                #region Boolean and Bitwise Operations

                case Operations.And:
                case Operations.Or:
                case Operations.Xor:

                    x.ConstantValue = ResolveBooleanOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return TypeCtx.GetBooleanTypeMask();

                case Operations.BitAnd:
                case Operations.BitOr:
                case Operations.BitXor:

                    x.ConstantValue = ResolveBitOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return GetBitOperationType(x.Left.TypeRefMask, x.Right.TypeRefMask);    // int or string

                #endregion

                #region Comparing Operations

                case Operations.Equal:
                case Operations.NotEqual:
                case Operations.Identical:
                case Operations.NotIdentical:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    if (branch != ConditionBranch.AnyResult)
                    {
                        // We must beware not to compute constant value more than once (losing results) -> mark handling of the given expression by this boolean
                        bool handled = false;

                        if (x.Right.ConstantValue.HasValue && x.Left is BoundReferenceExpression boundLeft)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundLeft, x.Right.ConstantValue, branch);
                        }
                        else if (x.Left.ConstantValue.HasValue && x.Right is BoundReferenceExpression boundRight)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundRight, x.Left.ConstantValue, branch);
                        }

                        if (!handled)
                        {
                            ResolveEquality(x);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                case Operations.GreaterThan:
                case Operations.LessThan:
                case Operations.GreaterThanOrEqual:
                case Operations.LessThanOrEqual:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    // comparison with long value
                    if (branch == ConditionBranch.ToTrue && IsLongOnly(x.Right))
                    {
                        if (x.Operation == Operations.LessThan ||
                            (x.Operation == Operations.LessThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal) && rightVal < long.MaxValue))
                        {
                            // $x < Long.Max
                            State.SetLessThanLongMax(TryGetVariableHandle(x.Left), true);
                        }
                        else if (x.Operation == Operations.GreaterThan ||
                            (x.Operation == Operations.GreaterThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal2) && rightVal2 > long.MinValue))
                        {
                            // $x > Long.Min
                            State.SetGreaterThanLongMin(TryGetVariableHandle(x.Left), true);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                #endregion

                case Operations.Concat:
                    return TypeCtx.GetWritableStringTypeMask();

                case Operations.Coalesce:   // Left ?? Right
                    return x.Left.TypeRefMask | x.Right.TypeRefMask;

                case Operations.Spaceship:
                    return TypeCtx.GetLongTypeMask(); // -1, 0, +1

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.Operation);
            }
        }

        /// <summary>
        /// If possible, resolve the comparison operation in compile-time.
        /// </summary>
        static Optional<object> ResolveComparison(Operations op, object lvalue, object rvalue)
        {
            // TODO

            if (TryConvertToNumber(lvalue, out _, out var dl) && TryConvertToNumber(rvalue, out _, out var dr))
            {
                return op switch
                {
                    Operations.Equal => dl == dr,
                    Operations.GreaterThan => dl > dr,
                    Operations.LessThan => dl < dr,
                    Operations.GreaterThanOrEqual => dl >= dr,
                    Operations.LessThanOrEqual => dl <= dr,
                    _ => default(Optional<object>),
                };
            }

            //
            return default;
        }

        static Optional<object> ResolveShift(Operations op, Optional<object> lvalue, Optional<object> rvalue)
        {
            if (lvalue.TryConvertToLong(out var left) && rvalue.TryConvertToLong(out var right))
            {
                switch (op)
                {
                    case Operations.ShiftLeft:
                        return (left << (int)right).AsOptional();

                    case Operations.ShiftRight:
                        return (left >> (int)right).AsOptional();

                    default:
                        Debug.Fail("unexpected");
                        break;

                }
            }

            return default;
        }

        /// <summary>
        /// Resolves variable types and potentially assigns a constant boolean value to an expression of a comparison of
        /// a variable and a constant - operators ==, !=, === and !==. Returns true iff this expression was handled and there
        /// is no need to analyse it any more (adding constant value etc.).
        /// </summary>
        private bool ResolveEqualityWithConstantValue(
            BoundBinaryEx cmpExpr,
            BoundReferenceExpression refExpr,
            Optional<object> value,
            ConditionBranch branch)
        {
            Debug.Assert(branch != ConditionBranch.AnyResult);

            if (value.IsNull() && refExpr is BoundVariableRef varRef)
            {
                bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);

                // We cannot say much about the type of $x in the true branch of ($x == null) and the false branch of ($x != null),
                // because it holds for false, 0, "", array() etc.
                if (isStrict || branch.TargetValue() != isPositive)
                {
                    AnalysisFacts.HandleTypeCheckingExpression(
                        varRef,
                        TypeCtx.GetNullTypeMask(),
                        branch,
                        State,
                        checkExpr: cmpExpr,
                        isPositiveCheck: isPositive);
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Attempts to infer the result of an equality comparison from the types of the operands.
        /// </summary>
        private void ResolveEquality(BoundBinaryEx cmpExpr)
        {
            Debug.Assert(cmpExpr.Operation >= Operations.Equal && cmpExpr.Operation <= Operations.NotIdentical);

            bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);

            if (isStrict && !cmpExpr.Left.CanHaveSideEffects() && !cmpExpr.Right.CanHaveSideEffects())
            {
                // Always returns false if checked for strict equality and the operands are of different types (and vice versa for strict non-eq)
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);
                bool canBeSameType = Routine.TypeRefContext.CanBeSameType(cmpExpr.Left.TypeRefMask, cmpExpr.Right.TypeRefMask);
                cmpExpr.ConstantValue = !canBeSameType ? (!isPositive).AsOptional() : default;
            }
        }

        #endregion

        #region Visit UnaryEx

        protected override void Visit(BoundUnaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveUnaryOperatorExpression(x, branch);
        }

        TypeRefMask ResolveUnaryOperatorExpression(BoundUnaryEx x, ConditionBranch branch)
        {
            if (branch != ConditionBranch.AnyResult && x.Operation == Operations.LogicNegation)
            {
                // Negation swaps the branches
                VisitCondition(x.Operand, branch.NegativeBranch());
            }
            else
            {
                Accept(x.Operand);
            }

            // clear any previous resolved constant 
            x.ConstantValue = default(Optional<object>);

            //
            switch (x.Operation)
            {
                case Operations.AtSign:
                    return x.Operand.TypeRefMask;

                case Operations.BitNegation:
                    if (x.Operand.ConstantValue.HasValue)
                    {
                        if (x.Operand.ConstantValue.Value is long l)
                        {
                            x.ConstantValue = new Optional<object>(~l);
                        }
                        else if (x.Operand.ConstantValue.Value is int i)
                        {
                            x.ConstantValue = new Optional<object>(~(long)i);
                        }
                    }

                    return TypeCtx.GetLongTypeMask();   // TODO: or byte[]

                case Operations.Clone:
                    // result is always object, not aliased
                    return TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask).IsVoid
                        ? TypeCtx.GetSystemObjectTypeMask()                     // "object"
                        : TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask);    // (object)T

                case Operations.LogicNegation:
                    {
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(!constBool);
                        }
                        return TypeCtx.GetBooleanTypeMask();
                    }

                case Operations.Minus:
                    var cvalue = ResolveUnaryMinus(x.Operand.ConstantValue.ToConstantValueOrNull());
                    if (cvalue != null)
                    {
                        x.ConstantValue = new Optional<object>(cvalue.Value);
                        return TypeCtx.GetTypeMask(BoundTypeRefFactory.Create(cvalue), false);
                    }
                    else
                    {
                        if (IsDoubleOnly(x.Operand))
                        {
                            return TypeCtx.GetDoubleTypeMask(); // double in case operand is double
                        }
                        return TypeCtx.GetNumberTypeMask();     // TODO: long in case operand is not a number
                    }

                case Operations.UnsetCast:
                    return TypeCtx.GetNullTypeMask();   // null

                case Operations.Plus:
                    if (IsNumberOnly(x.Operand.TypeRefMask))
                        return x.Operand.TypeRefMask;
                    return TypeCtx.GetNumberTypeMask();

                case Operations.Print:
                    return TypeCtx.GetLongTypeMask();

                default:
                    throw ExceptionUtilities.Unreachable;
            }
        }

        ConstantValue ResolveUnaryMinus(ConstantValue value)
        {
            if (value != null)
            {
                switch (value.SpecialType)
                {
                    case SpecialType.System_Double:
                        return ConstantValue.Create(-value.DoubleValue);

                    case SpecialType.System_Int32:
                        return value.Int32Value != int.MinValue
                            ? ConstantValue.Create(-value.Int32Value)   // (- Int32.MinValue) overflows to int64
                            : ConstantValue.Create(-(long)value.Int32Value);

                    case SpecialType.System_Int64:
                        return (value.Int64Value != long.MinValue)  // (- Int64.MinValue) overflows to double
                            ? ConstantValue.Create(-value.Int64Value)
                            : ConstantValue.Create(-(double)value.Int64Value);
                    default:
                        break;
                }
            }

            return null;
        }

        #endregion

        #region Visit Conversion

        public override T VisitConversion(BoundConversionEx x)
        {
            base.VisitConversion(x);

            // evaluate if possible

            if (x.TargetType is BoundPrimitiveTypeRef pt)
            {
                switch (pt.TypeCode)
                {
                    case PhpTypeCode.Boolean:
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(constBool);
                        }
                        break;

                    case PhpTypeCode.Long:
                        if (x.Operand.ConstantValue.TryConvertToLong(out long l))
                        {
                            x.ConstantValue = new Optional<object>(l);
                        }
                        break;

                    case PhpTypeCode.Double:
                        break;

                    case PhpTypeCode.String:
                    case PhpTypeCode.WritableString:
                        if (x.Operand.ConstantValue.TryConvertToString(out string str))
                        {
                            x.ConstantValue = new Optional<object>(str);
                        }
                        break;

                    case PhpTypeCode.Object:
                        if (IsClassOnly(x.Operand.TypeRefMask))
                        {
                            // it is object already, keep its specific type
                            x.TypeRefMask = x.Operand.TypeRefMask;   // (object)<object>
                            return default;
                        }
                        else if (IsArrayOnly(x.Operand.TypeRefMask))
                        {
                            // array -> object conversion
                            // always stdClass
                            x.TypeRefMask = TypeCtx.GetTypeMask(BoundTypeRefFactory.stdClassTypeRef, false);
                            return default;
                        }
                        break;
                }
            }

            //

            x.TypeRefMask = x.TargetType.GetTypeRefMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit InstanceOf

        protected override void Visit(BoundInstanceOfEx x, ConditionBranch branch)
        {
            Accept(x.Operand);
            x.AsType.Accept(this);

            // TOOD: x.ConstantValue // in case we know and the operand is a local variable (we can ignore the expression and emit result immediatelly)

            var opTypeMask = x.Operand.TypeRefMask;
            if (x.Operand is BoundLiteral
                || (!opTypeMask.IsAnyType && !opTypeMask.IsRef && !Routine.TypeRefContext.IsObject(opTypeMask)))
            {
                x.ConstantValue = ConstantValueExtensions.AsOptional(false);
            }
            else if (x.Operand is BoundVariableRef vref && vref.Name.IsDirect)
            {
                if (branch == ConditionBranch.ToTrue)
                {
                    // if (Variable is T) => variable is T in True branch state
                    var vartype = x.AsType.GetTypeRefMask(TypeCtx);
                    if (opTypeMask.IsRef) vartype = vartype.WithRefFlag; // keep IsRef flag

                    State.SetLocalType(State.GetLocalHandle(vref.Name.NameValue), vartype);
                }
            }

            //
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        #endregion

        #region Visit IsSet, OffsetExists

        protected override void Visit(BoundIsSetEx x, ConditionBranch branch)
        {
            Accept(x.VarReference);

            // try to get resulting value and type of the variable
            var localname = AsVariableName(x.VarReference);
            if (localname.IsValid())
            {
                var handle = State.GetLocalHandle(localname);
                Debug.Assert(handle.IsValid);

                // Remove any constant value of isset()
                x.ConstantValue = default;

                //
                if (State.IsLocalSet(handle))
                {
                    // If the variable is always defined, isset() behaves like !is_null()
                    var currenttype = State.GetLocalType(handle);

                    // a type in the true branch:
                    var positivetype = TypeCtx.WithoutNull(currenttype);

                    // resolve the constant if possible,
                    // does not depend on the branch
                    if (!currenttype.IsRef && !currenttype.IsAnyType)
                    {
                        if (positivetype.IsVoid)    // always false
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                        }
                        else if (positivetype == currenttype)   // not void nor null
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(true);
                        }
                    }

                    // we can be more specific in true/false branches:
                    if (branch != ConditionBranch.AnyResult && !x.ConstantValue.HasValue)
                    {
                        // update target type in true/false branch:
                        var newtype = (branch == ConditionBranch.ToTrue)
                            ? positivetype
                            : TypeCtx.GetNullTypeMask();

                        // keep the flags
                        newtype |= currenttype.Flags;

                        //
                        State.SetLocalType(handle, newtype);
                    }
                }
                else if (localname.IsAutoGlobal)
                {
                    // nothing
                }
                else
                {
                    // variable is not set for sure
                    // isset : false
                    x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                }

                // mark variable as either initialized or uninintialized in respective branches
                if (branch == ConditionBranch.ToTrue)
                {
                    State.SetVarInitialized(handle);
                }
            }

            // always returns a boolean
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        public override T VisitOffsetExists(BoundOffsetExists x)
        {
            // receiver[index]
            base.VisitOffsetExists(x);

            // TODO: if receiver is undefined -> result is false

            // always bool
            x.ResultType = DeclaringCompilation.CoreTypes.Boolean;
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
            return default;
        }

        public override T VisitTryGetItem(BoundTryGetItem x)
        {
            // array, index, fallback
            base.VisitTryGetItem(x);

            // TODO: resulting type if possible (see VisitArrayItem)

            // The result of array[index] might be a reference
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;

            return default;
        }

        #endregion

        #region TypeRef

        internal override T VisitIndirectTypeRef(BoundIndirectTypeRef tref)
        {
            // visit indirect type
            base.VisitIndirectTypeRef(tref);

            //
            return VisitTypeRef(tref);
        }

        internal override T VisitTypeRef(BoundTypeRef tref)
        {
            Debug.Assert(!(tref is BoundMultipleTypeRef));

            // resolve type symbol
            tref.ResolvedType = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);

            return default;
        }

        #endregion

        #region Visit Function Call

        protected override T VisitRoutineCall(BoundRoutineCall x)
        {
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag; // unknown function might return a reference

            // TODO: write arguments Access
            // TODO: visit invocation member of
            // TODO: 2 pass, analyze arguments -> resolve method -> assign argument to parameter -> write arguments access -> analyze arguments again

            // visit arguments:
            base.VisitRoutineCall(x);

            return default;
        }

        bool BindParams(IList<PhpParam> expectedparams, ImmutableArray<BoundArgument> givenargs)
        {
            for (int i = 0; i < givenargs.Length; i++)
            {
                if (givenargs[i].IsUnpacking)
                {
                    break;
                }

                if (i < expectedparams.Count)
                {
                    var expected = expectedparams[i];
                    if (expected.IsVariadic)
                    {
                        for (;  i < givenargs.Length; i++)
                        {
                            if (givenargs[i].IsUnpacking)
                            {
                                break; // CONSIDER
                            }

                            BindParam(expected, givenargs[i]);
                        }
                    }
                    else
                    {
                        BindParam(expected, givenargs[i]);
                    }
                }
                else
                {
                    // argument cannot be bound
                    return false;
                }
            }

            return true;
        }

        void BindParam(PhpParam expected, BoundArgument givenarg)
        {
            // bind symbol
            givenarg.Parameter = expected.ParameterSymbol;

            // [PhpRwAttribute]
            if (expected.IsPhpRw)
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (TypeCtx.IsArray(expected.Type) && !givenarg.Value.Access.EnsureArray)   // [PhpRw]PhpArray
                    {
                        SemanticsBinder.BindEnsureArrayAccess(givenarg.Value as BoundReferenceExpression);
                        Worklist.Enqueue(CurrentBlock);
                    }
                }
            }

            // bind ref parameters to variables:
            if (expected.IsAlias || expected.IsByRef)  // => args[i] must be a variable
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (expected.IsByRef && !refexpr.Access.IsWrite)
                    {
                        SemanticsBinder.BindWriteAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (expected.IsAlias && !refexpr.Access.IsReadRef)
                    {
                        SemanticsBinder.BindReadRefAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (refexpr is BoundVariableRef refvar)
                    {
                        if (refvar.Name.IsDirect)
                        {
                            var local = State.GetLocalHandle(refvar.Name.NameValue);
                            State.SetLocalType(local, expected.Type);
                            refvar.MaybeUninitialized = false;
                            if (expected.IsAlias)
                            {
                                State.MarkLocalByRef(local);
                            }
                        }
                        else
                        {
                            // TODO: indirect variable -> all may be aliases of any type
                        }
                    }
                    else
                    {
                        // fields, array items, ...
                        // TODO: remember the field will be accessed as reference
                    }
                }
                else
                {
                    // TODO: Err, variable or field must be passed into byref argument. foo("hello") where function foo(&$x){}
                }
            }
            else if (!expected.Type.IsAnyType && givenarg.Value is BoundVariableRef refvar && refvar.Name.IsDirect)
            {
                // Even for variables passed by value we may gain information about their type (if we previously had none),
                // because not complying with the parameter type would have caused throwing a TypeError
                var local = State.GetLocalHandle(refvar.Name.NameValue);
                var localType = State.GetLocalType(local);
                var paramTypeNonNull = TypeCtx.WithoutNull(expected.Type);
                if (localType.IsAnyType && !localType.IsRef &&
                    (TypeCtx.IsObjectOnly(paramTypeNonNull) || TypeCtx.IsArrayOnly(paramTypeNonNull)))    // E.g. support ?MyClass but not callable
                {
                    Debug.Assert(!expected.Type.IsRef);
                    State.SetLocalType(local, expected.Type);
                }
            }
        }

        TypeRefMask BindValidRoutineCall(BoundRoutineCall call, MethodSymbol method, ImmutableArray<BoundArgument> args, bool maybeoverload)
        {
            // analyze TargetMethod with x.Arguments
            // require method result type if access != none
            if (call.Access.IsRead)
            {
                if (Worklist.EnqueueRoutine(method, CurrentBlock, call))
                {
                    // target will be reanalysed
                    // note: continuing current block may be waste of time, but it might gather other called targets

                    // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                    _flags |= AnalysisFlags.IsCanceled;
                }
            }

            if (Routine != null)
            {
                var rflags = method.InvocationFlags(out var localaccess);
                Routine.Flags |= rflags;

                if ((rflags & RoutineFlags.UsesLocals) != 0
                    //&& (x is BoundGlobalFunctionCall gf && gf.Name.NameValue.Name.Value == "extract") // "compact" does not change locals // CONSIDER // TODO
                    )
                {
                    // function may change/add local variables
                    State.SetAllUnknown(true);
                }

                if (localaccess != null)
                {
                    foreach (var lname in localaccess)
                    {
                        // the variable will be used as reference here
                        State.MarkLocalByRef(State.GetLocalHandle(lname));
                    }
                }
            }

            // process arguments
            if (!BindParams(method.GetExpectedArguments(this.TypeCtx), args) && maybeoverload)
            {
                call.TargetMethod = null; // nullify the target method -> call dynamically, arguments cannot be bound at compile time
            }

            //
            return method.GetResultType(TypeCtx);
        }

        /// <summary>
        /// Bind arguments to target method and resolve resulting <see cref="BoundExpression.TypeRefMask"/>.
        /// Expecting <see cref="BoundRoutineCall.TargetMethod"/> is resolved.
        /// If the target method cannot be bound at compile time, <see cref="BoundRoutineCall.TargetMethod"/> is nulled.
        /// </summary>
        void BindRoutineCall(BoundRoutineCall x, bool maybeOverload = false)
        {
            if (MethodSymbolExtensions.IsValidMethod(x.TargetMethod))
            {
                x.TypeRefMask = BindValidRoutineCall(x, x.TargetMethod, x.ArgumentsInSourceOrder, maybeOverload);
            }
            else if (x.TargetMethod is MissingMethodSymbol || x.TargetMethod == null)
            {
                // we don't know anything about the target callsite,
                // locals passed as arguments should be marked as possible refs:
                foreach (var arg in x.ArgumentsInSourceOrder)
                {
                    if (arg.Value is BoundVariableRef bvar && bvar.Name.IsDirect && !arg.IsUnpacking)
                    {
                        State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                    }
                }
            }
            else if (x.TargetMethod is AmbiguousMethodSymbol ambiguity)
            {
                // check if arguments are not passed by bref, mark locals eventually as refs:
                foreach (var m in ambiguity.Ambiguities)
                {
                    var expected = m.GetExpectedArguments(this.TypeCtx);
                    var given = x.ArgumentsInSourceOrder;

                    for (int i = 0; i < given.Length && i < expected.Count; i++)
                    {
                        if (expected[i].IsAlias && given[i].Value is BoundVariableRef bvar && bvar.Name.IsDirect)
                        {
                            State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                        }
                    }
                }

                // get the return type from all the ambiguities:
                if (!maybeOverload && x.Access.IsRead)
                {
                    var r = (TypeRefMask)0;
                    foreach (var m in ambiguity.Ambiguities)
                    {
                        if (Worklist.EnqueueRoutine(m, CurrentBlock, x))
                        {
                            // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                            _flags |= AnalysisFlags.IsCanceled;
                        }

                        r |= m.GetResultType(TypeCtx);
                    }

                    x.TypeRefMask = r;
                }
            }

            //

            if (x.Access.IsReadRef)
            {
                // reading by ref:
                x.TypeRefMask = x.TypeRefMask.WithRefFlag;
            }
        }

        public override T VisitExit(BoundExitEx x)
        {
            VisitRoutineCall(x);

            // no parameters binding
            // TODO: handle unpacking
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 0 || !x.ArgumentsInSourceOrder[0].IsUnpacking);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            return default;
        }

        public override T VisitEcho(BoundEcho x)
        {
            VisitRoutineCall(x);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            //
            return default;
        }

        public override T VisitConcat(BoundConcatEx x)
        {
            VisitRoutineCall(x);

            // if possible, mark the result type as "String",
            // otherwise we have to use "PhpString"
            var args = x.ArgumentsInSourceOrder;
            bool mustBePhpString = false;
            for (int i = 0; i < args.Length; i++)
            {
                var targ = args[i].Value.TypeRefMask;
                mustBePhpString |= targ.IsRef || targ.IsAnyType || this.TypeCtx.IsWritableString(targ) /*|| this.TypeCtx.IsObject(targ) //object are always converted to UTF16 String// */;
            }

            x.TypeRefMask = mustBePhpString ? TypeCtx.GetWritableStringTypeMask() : TypeCtx.GetStringTypeMask();

            return default;
        }

        public override T VisitAssert(BoundAssertEx x)
        {
            VisitRoutineCall(x);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override void VisitGlobalFunctionCall(BoundGlobalFunctionCall x, ConditionBranch branch)
        {
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.Name.NameValue, Routine);
                if (symbol.IsMissingMethod() && x.NameOpt.HasValue)
                {
                    symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.NameOpt.Value, Routine);
                }

                var overloads = symbol is AmbiguousMethodSymbol ambiguous && ambiguous.IsOverloadable
                    ? new OverloadsList(ambiguous.Ambiguities.ToList())
                    : new OverloadsList(symbol ?? new MissingMethodSymbol(x.Name.NameValue.ToString()));

                Debug.Assert(x.TypeArguments.IsDefaultOrEmpty);

                // symbol might be ErrorSymbol

                x.TargetMethod = overloads.Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.StaticCall);
            }

            BindRoutineCall(x);

            // if possible resolve ConstantValue and TypeRefMask:
            AnalysisFacts.HandleSpecialFunctionCall(x, this, branch);
        }

        public override T VisitInstanceFunctionCall(BoundInstanceFunctionCall x)
        {
            Accept(x.Instance);
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var resolvedtype = x.Instance.ResultType;
                if (resolvedtype == null)
                {
                    var typeref = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));    // ignore NULL, causes runtime exception anyway
                    if (typeref.IsSingle)
                    {
                        resolvedtype = (TypeSymbol)typeref.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                    // else: a common base?
                }

                if (resolvedtype.IsValidType())
                {
                    var candidates = resolvedtype.LookupMethods(x.Name.NameValue.Name.Value);

                    candidates = Construct(candidates, x);

                    x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.InstanceCall);

                    //
                    if (x.TargetMethod.IsValidMethod() && x.TargetMethod.IsStatic && x.Instance.TypeRefMask.IncludesSubclasses)
                    {
                        // static method invoked on an instance object,
                        // must be postponed to runtime since the type may change
                        x.TargetMethod = new AmbiguousMethodSymbol(ImmutableArray.Create(x.TargetMethod), false);
                    }
                }
                else
                {
                    x.TargetMethod = null;
                }
            }

            BindRoutineCall(x, maybeOverload: true);

            return default;
        }

        public override T VisitStaticFunctionCall(BoundStaticFunctionCall x)
        {
            Accept(x.TypeRef);
            Accept(x.Name);

            VisitRoutineCall(x);

            var type = (TypeSymbol)x.TypeRef.Type;

            if (x.Name.NameExpression != null)
            {
                // indirect method call -> not resolvable
            }
            else if (type.IsValidType())
            {
                var candidates = type.LookupMethods(x.Name.ToStringOrThrow());
                // if (candidates.Any(c => c.HasThis)) throw new NotImplementedException("instance method called statically");

                candidates = Construct(candidates, x);

                var flags = OverloadsList.InvocationKindFlags.StaticCall;

                if (Routine != null && !Routine.IsStatic && (x.TypeRef.IsSelf() || x.TypeRef.IsParent()))
                {
                    // self:: or parent:: $this forwarding, prefer both
                    flags |= OverloadsList.InvocationKindFlags.InstanceCall;
                }

                var method = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, flags);

                // method is missing or inaccessible:
                if (method is ErrorMethodSymbol errmethod && (errmethod.ErrorKind == ErrorMethodKind.Inaccessible || errmethod.ErrorKind == ErrorMethodKind.Missing))
                {
                    // NOTE: magic methods __call or __callStatic are called in both cases - the target method is inaccessible or missing

                    var isviable = true; // can we safely resolve the method?
                    List<MethodSymbol> call = null;

                    // __call() might be used, if we have a reference to $this:
                    if (Routine != null && !Routine.IsStatic)
                    {
                        // there is $this variable:
                        if (TypeCtx.ThisType == null || TypeCtx.ThisType.IsOfType(type) || type.IsOfType(TypeCtx.ThisType))
                        {
                            // try to use __call() first:
                            call = type.LookupMethods(Name.SpecialMethodNames.Call.Value);

                            //
                            if (TypeCtx.ThisType == null && call.Count != 0)
                            {
                                // $this is resolved dynamically in runtime and
                                // we don't know if we can use __call() here
                                isviable = false;
                            }
                        }
                    }

                    if (call == null || call.Count == 0)
                    {
                        // __callStatic()
                        call = type.LookupMethods(Name.SpecialMethodNames.CallStatic.Value);
                    }

                    if (call != null && call.Count != 0)
                    {
                        // NOTE: PHP ignores visibility of __callStatic
                        call = Construct(call, x);

                        method = call.Count == 1 && isviable
                            ? new MagicCallMethodSymbol(x.Name.ToStringOrThrow(), call[0])
                            : null; // nullify the symbol so it will be called dynamically and resolved in rutime
                    }
                }

                x.TargetMethod = method;
            }
            else if (x.TypeRef.IsSelf() && Routine != null && Routine.ContainingType.IsTraitType())
            {
                // self:: within trait type
                // resolve possible code path
                // we need this at least to determine possible late static type binding

                var candidates = Construct(Routine.ContainingType.LookupMethods(x.Name.ToStringOrThrow()), x);
                if (candidates.Count != 0)
                {
                    // accessibility not have to be checked here
                    x.TargetMethod = new AmbiguousMethodSymbol(candidates.AsImmutable(), overloadable: true);
                }
            }

            BindRoutineCall(x);

            return default;
        }

        // helper
        List<MethodSymbol> Construct(List<MethodSymbol> methods, BoundRoutineCall bound)
        {
            if (!bound.TypeArguments.IsDefaultOrEmpty)
            {
                var types = bound.TypeArguments.Select(t => (TypeSymbol)t.Type).AsImmutable();

                for (int i = methods.Count - 1; i >= 0; i--)
                {
                    if (methods[i].Arity == types.Length) // TODO: check the type argument is assignable
                    {
                        methods[i] = methods[i].Construct(types);
                    }
                    else
                    {
                        methods.RemoveAt(i);
                    }
                }
            }

            return methods;
        }

        public override T VisitNew(BoundNewEx x)
        {
            Accept(x.TypeRef);      // resolve target type

            VisitRoutineCall(x);    // analyse arguments

            // resolve .ctor method:
            var type = (NamedTypeSymbol)x.TypeRef.Type;
            if (type.IsValidType())
            {
                var candidates = type.InstanceConstructors.ToList();

                //
                x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.New);
                x.ResultType = type;
            }

            // bind arguments:
            BindRoutineCall(x);

            // resulting type is always known,
            // not null,
            // not ref:
            x.TypeRefMask = x.TypeRef.GetTypeRefMask(TypeCtx).WithoutSubclasses;

            return default;
        }

        public override T VisitInclude(BoundIncludeEx x)
        {
            VisitRoutineCall(x);

            // resolve target script
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 1);
            var targetExpr = x.ArgumentsInSourceOrder[0].Value;

            //
            x.TargetMethod = AnalysisFacts.TryResolveFile(_model, Routine, targetExpr, out var script)
                ? (MethodSymbol)script.MainMethod
                : null;

            // resolve result type
            if (x.Access.IsRead)
            {
                var target = x.TargetMethod;
                if (target != null)
                {
                    x.ResultType = target.ReturnType;
                    x.TypeRefMask = target.GetResultType(TypeCtx);

                    if (x.IsOnceSemantic)
                    {
                        // include_once, require_once returns TRUE in case the script was already included
                        x.TypeRefMask |= TypeCtx.GetBooleanTypeMask();
                    }
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;
                }
            }
            else
            {
                x.TypeRefMask = 0;
            }

            // reset type analysis (include may change local variables)
            State.SetAllUnknown(true);

            return default;
        }

        #endregion

        #region Visit FieldRef

        public override T VisitFieldRef(BoundFieldRef x)
        {
            Accept(x.Instance);
            Accept(x.ContainingType);
            Accept(x.FieldName);

            if (x.IsInstanceField)  // {Instance}->FieldName
            {
                Debug.Assert(x.Instance != null);
                Debug.Assert(x.Instance.Access.IsRead);

                // resolve field if possible
                var resolvedtype = x.Instance.ResultType as NamedTypeSymbol;
                if (resolvedtype == null)
                {
                    var typerefs = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));   // ignore NULL, would cause runtime exception in read access, will be ensured to non-null in write access
                    if (typerefs.IsSingle)
                    {
                        resolvedtype = (NamedTypeSymbol)typerefs.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                }

                if (resolvedtype != null)
                {
                    if (x.FieldName.IsDirect)
                    {
                        var fldname = x.FieldName.NameValue.Value;
                        var member = resolvedtype.ResolveInstanceProperty(fldname);
                        if (member != null && member.IsAccessible(this.TypeCtx.SelfType))
                        {
                            if (member is FieldSymbol field)
                            {
                                var srcf = field as SourceFieldSymbol;
                                var overridenf = srcf?.OverridenDefinition;

                                // field might be a redefinition with a different accessibility,
                                // such field is not declared actually and the base definition is used instead:

                                if (overridenf == null || overridenf.IsAccessible(this.TypeCtx.SelfType))
                                {
                                    x.BoundReference = new FieldReference(x.Instance, overridenf ?? field);
                                    x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                                    x.ResultType = field.Type;
                                    return default;
                                }
                                else if (srcf?.FieldAccessorProperty != null && srcf.FieldAccessorProperty.IsAccessible(TypeCtx.SelfType))
                                {
                                    member = srcf.FieldAccessorProperty; // use the wrapping property that is accessible from current context
                                    // -> continue
                                }
                                else
                                {
                                    member = null; // -> dynamic behavior
                                    // -> continue
                                }
                            }

                            if (member is PropertySymbol prop)
                            {
                                x.BoundReference = new PropertyReference(x.Instance, prop);
                                x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type);
                                x.ResultType = prop.Type;
                                return default;
                            }

                            //
                            if (member != null)
                            {
                                throw ExceptionUtilities.UnexpectedValue(member);
                            }
                        }
                        else
                        {
                            // TODO: use runtime fields directly, __get, __set, etc.,
                            // do not fallback to BoundIndirectFieldPlace
                        }
                    }
                }

                // dynamic behavior
                // indirect field access ...

                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectFieldPlace(x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                return default;
            }

            // static fields or constants
            if (x.IsStaticField || x.IsClassConstant)    // {ClassName}::${StaticFieldName}, {ClassName}::{ConstantName}
            {
                var containingType = (NamedTypeSymbol)x.ContainingType.Type;

                if (x.IsClassConstant)
                {
                    Debug.Assert(x.Access.IsRead || x.Access.IsNone);
                    Debug.Assert(!x.Access.IsEnsure && !x.Access.IsWrite && !x.Access.IsReadRef);
                }

                if (containingType.IsValidType() && x.FieldName.IsDirect)
                {
                    var fldname = x.FieldName.NameValue.Value;
                    var field = x.IsStaticField ? containingType.ResolveStaticField(fldname) : containingType.ResolveClassConstant(fldname);
                    if (field != null)
                    {
                        // TODO: visibility -> ErrCode

                        if (BindConstantValue(x, field))
                        {
                            Debug.Assert(x.Access.IsRead && !x.Access.IsWrite && !x.Access.IsEnsure);
                            x.BoundReference = null; // not reachable
                        }
                        else
                        {
                            // real.NET static member (CLR static fields) or
                            // the field may be contained in special __statics container (fields & constants)
                            x.BoundReference = new FieldReference(null, field);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                        }

                        x.ResultType = field.Type;
                        return default;
                    }
                    else if (x.IsStaticField)
                    {
                        // TODO: visibility
                        var prop = containingType.LookupMember<PropertySymbol>(fldname);
                        if (prop != null && prop.IsStatic)
                        {
                            x.BoundReference = new PropertyReference(null, prop);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type).WithIsRef(prop.Type.CanBePhpAlias());
                            return default;
                        }
                    }

                    // TODO: __getStatic, __setStatic
                }

                // indirect field access:
                // indirect field access with known class name:
                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectStFieldPlace((BoundTypeRef)x.ContainingType, x.FieldName, x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
            }

            return default;
        }

        #endregion

        #region Visit ArrayEx, ArrayItemEx, ArrayItemOrdEx

        public override T VisitArray(BoundArrayEx x)
        {
            var items = x.Items;
            TypeRefMask elementType = 0;

            // analyse elements
            foreach (var i in items)
            {
                Debug.Assert(i.Value != null);

                Accept(i.Key);
                Accept(i.Value);

                elementType |= i.Value.TypeRefMask;
            }

            // writeup result type
            x.TypeRefMask = elementType.IsVoid
                ? TypeCtx.GetArrayTypeMask()
                : TypeCtx.GetArrayTypeMask(elementType);

            return default;
        }

        public override T VisitArrayItem(BoundArrayItemEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // TODO: resulting type if possible:
            // var element_type = TypeCtx.GetElementType(x.Array.TypeRefMask); // + handle classes with ArrayAccess and TypeRefMask.Uninitialized

            //

            x.TypeRefMask =
                x.Access.IsReadRef ? TypeRefMask.AnyType.WithRefFlag :
                x.Access.IsEnsure ? TypeRefMask.AnyType : // object|array ?
                TypeRefMask.AnyType.WithRefFlag; // result might be a anything (including a reference?)

            return default;
        }

        public override T VisitArrayItemOrd(BoundArrayItemOrdEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // ord($s[$i]) cannot be used as an l-value
            Debug.Assert(!x.Access.MightChange);

            x.TypeRefMask = TypeCtx.GetLongTypeMask();

            return base.VisitArrayItemOrd(x);
        }

        #endregion

        #region VisitLambda

        public override T VisitLambda(BoundLambda x)
        {
            var container = (ILambdaContainerSymbol)Routine.ContainingFile;
            var symbol = container.ResolveLambdaSymbol((LambdaFunctionExpr)x.PhpSyntax);
            if (symbol == null)
            {
                throw ExceptionUtilities.UnexpectedValue(symbol);
            }

            // lambda uses `static` => we have to know where it is:
            Routine.Flags |= (symbol.Flags & RoutineFlags.UsesLateStatic);

            // bind arguments to parameters
            var ps = symbol.SourceParameters;

            // first {N} source parameters correspond to "use" parameters
            for (int pi = 0; pi < x.UseVars.Length; pi++)
            {
                x.UseVars[pi].Parameter = ps[pi];
                VisitArgument(x.UseVars[pi]);
            }

            //
            x.BoundLambdaMethod = symbol;
            x.ResultType = DeclaringCompilation.CoreTypes.Closure;
            Debug.Assert(x.ResultType != null);
            x.TypeRefMask = TypeCtx.GetTypeMask(new BoundLambdaTypeRef(TypeRefMask.AnyType), false); // specific {Closure}, no null, no subclasses

            return default;
        }

        #endregion

        #region VisitYield

        public override T VisitYieldStatement(BoundYieldStatement x)
        {
            base.VisitYieldStatement(x);

            return default;
        }

        public override T VisitYieldEx(BoundYieldEx x)
        {
            base.VisitYieldEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        public override T VisitYieldFromEx(BoundYieldFromEx x)
        {
            base.VisitYieldFromEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion

        #region Visit

        public override T VisitIsEmpty(BoundIsEmptyEx x)
        {
            Accept(x.Operand);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override T VisitUnset(BoundUnset x)
        {
            base.VisitUnset(x);

            return default;
        }

        public override T VisitList(BoundListEx x)
        {
            var elementtype = this.TypeCtx.GetElementType(x.Access.WriteMask);
            Debug.Assert(!elementtype.IsVoid);

            foreach (var v in x.Items)   // list() may contain NULL implying ignored variable
            {
                if (v.Value != null)
                {
                    Accept(v.Key);
                    Visit(v.Value, v.Value.Access.WithWrite(elementtype));
                }
            }

            return default;
        }

        public override T VisitPseudoConstUse(BoundPseudoConst x)
        {
            object value = null;

            switch (x.ConstType)
            {
                case BoundPseudoConst.Types.Line:
                    value = x.PhpSyntax.ContainingSourceUnit.GetLineFromPosition(x.PhpSyntax.Span.Start) + 1;
                    break;

                case BoundPseudoConst.Types.Class:
                case BoundPseudoConst.Types.Trait:
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        if (containingtype != null)
                        {
                            var intrait = containingtype.MemberAttributes.IsTrait();

                            value = containingtype.QualifiedName.ToString();

                            if (intrait && x.ConstType == BoundPseudoConst.Types.Class)
                            {
                                // __CLASS__ inside trait resolved in runtime
                                x.TypeRefMask = TypeCtx.GetStringTypeMask();
                                return default;
                            }

                            if (!intrait && x.ConstType == BoundPseudoConst.Types.Trait)
                            {
                                // __TRAIT__ inside class is empty string
                                value = string.Empty;
                            }
                        }
                        else
                        {
                            value = string.Empty;
                        }
                    }
                    break;

                case BoundPseudoConst.Types.Method:
                    if (Routine == null)
                    {
                        value = string.Empty;
                    }
                    else if (Routine is SourceLambdaSymbol)
                    {
                        // value = __CLASS__::"{closure}"; // PHP 5
                        value = "{closure}";    // PHP 7+
                    }
                    else
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        value = containingtype != null
                            ? containingtype.QualifiedName.ToString(new Name(Routine.RoutineName), false)
                            : Routine.RoutineName;
                    }
                    break;

                case BoundPseudoConst.Types.Function:
                    if (Routine is SourceLambdaSymbol)
                    {
                        value = "{closure}";
                    }
                    else
                    {
                        value = Routine != null ? Routine.RoutineName : string.Empty;
                    }
                    break;

                case BoundPseudoConst.Types.Namespace:
                    var ns = x.PhpSyntax.ContainingNamespace;
                    value = ns != null && ns.QualifiedName.HasValue
                        ? ns.QualifiedName.QualifiedName.NamespacePhpName
                        : string.Empty;
                    break;

                case BoundPseudoConst.Types.Dir:
                case BoundPseudoConst.Types.File:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                case BoundPseudoConst.Types.RootPath:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            Debug.Assert(value != null);    // pseudoconstant has been set

            x.ConstantValue = new Optional<object>(value);

            if (value is string) x.TypeRefMask = TypeCtx.GetStringTypeMask();
            else if (value is int || value is long) x.TypeRefMask = TypeCtx.GetLongTypeMask();
            else throw ExceptionUtilities.UnexpectedValue(value);

            return default;
        }

        public override T VisitPseudoClassConstUse(BoundPseudoClassConst x)
        {
            base.VisitPseudoClassConstUse(x);

            //
            if (x.ConstType == PseudoClassConstUse.Types.Class)
            {
                x.TypeRefMask = TypeCtx.GetStringTypeMask();

                // resolve the value:

                var type = x.TargetType.Type as TypeSymbol;
                if (type.IsValidType() && type is IPhpTypeSymbol phpt)
                {
                    x.ConstantValue = new Optional<object>(phpt.FullName.ToString());
                }
                else
                {
                    var tref = x.TargetType.PhpSyntax as TypeRef;
                    var qname = tref?.QualifiedName;
                    if (qname.HasValue)
                    {
                        if (!qname.Value.IsReservedClassName) // self, static, parent
                        {
                            x.ConstantValue = new Optional<object>(qname.Value.ToString());
                        }
                    }
                }
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            return default;
        }

        public override T VisitGlobalConstUse(BoundGlobalConst x)
        {
            // TODO: check constant name

            // bind to app-wide constant if possible
            var symbol = (Symbol)_model.ResolveConstant(x.Name.ToString());
            var field = symbol as FieldSymbol;

            if (!BindConstantValue(x, field))
            {
                if (field != null && field.IsStatic)
                {
                    if (field.Type.Is_Func_Context_TResult(out var tresult))
                    {
                        // lazy constant
                        // public static readonly Func<Context, TResult> Constant = (ctx) => VALUE;
                        x._boundExpressionOpt = new InvokeReference(new FieldPlace(null, field));
                        x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, tresult);
                    }
                    else
                    {
                        // constant
                        // public static readonly T Constant = VALUE
                        x._boundExpressionOpt = new FieldReference(null, field);
                        x.TypeRefMask = field.GetResultType(TypeCtx);
                    }
                }
                else if (symbol is PEPropertySymbol prop && prop.IsStatic)
                {
                    // constant
                    // public static T Constant => VALUE;
                    x._boundExpressionOpt = new PropertyReference(null, prop);
                    x.TypeRefMask = prop.GetResultType(TypeCtx);
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;    // only scalars ?
                }
            }

            return default;
        }

        public override T VisitConditional(BoundConditionalEx x)
        {
            BoundExpression positiveExpr;    // positive expression (if evaluated to true, FalseExpr is not evaluated)
            FlowState positiveState; // state after successful positive branch

            if (x.IfTrue != null && x.IfTrue != x.Condition)
            {
                // Template: Condition ? IfTrue : IfFalse

                var originalState = State.Clone();
                positiveExpr = x.IfTrue;

                // true branch:
                if (VisitCondition(x.Condition, ConditionBranch.ToTrue))
                {
                    Accept(x.IfTrue);
                    positiveState = State;

                    // false branch
                    State = originalState.Clone();
                    VisitCondition(x.Condition, ConditionBranch.ToFalse);
                }
                else
                {
                    // OPTIMIZATION: Condition does not have to be visited twice!

                    originalState = State.Clone(); // state after visiting Condition

                    Accept(x.IfTrue);
                    positiveState = State;

                    State = originalState.Clone();
                }
            }
            else
            {
                // Template: Condition ?: IfFalse
                positiveExpr = x.Condition;

                // in case ?: do not evaluate trueExpr twice:
                // Template: Condition ?: FalseExpr

                Accept(x.Condition);
                positiveState = State.Clone();

                // condition != false => condition != null =>
                // ignoring NULL type from Condition:
                x.Condition.TypeRefMask = TypeCtx.WithoutNull(x.Condition.TypeRefMask);
            }

            // and start over with false branch:
            Accept(x.IfFalse);

            // merge both states (after positive evaluation and the false branch)
            State = State.Merge(positiveState);
            x.TypeRefMask = positiveExpr.TypeRefMask | x.IfFalse.TypeRefMask;

            return default;
        }

        public override T VisitExpressionStatement(BoundExpressionStatement x)
        {
            return base.VisitExpressionStatement(x);
        }

        public override T VisitReturn(BoundReturnStatement x)
        {
            if (x.Returned != null)
            {
                Accept(x.Returned);
                State.FlowThroughReturn(x.Returned.TypeRefMask);
            }
            else
            {
                // remember "void" type explicitly
                var voidMask = State.TypeRefContext.GetTypeMask(BoundTypeRefFactory.VoidTypeRef, false); // NOTE: or remember the routine may return Void
                State.FlowThroughReturn(voidMask);
            }

            return default;
        }

        public override T VisitEval(BoundEvalEx x)
        {
            base.VisitEval(x);

            //
            State.SetAllUnknown(true);

            //
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(4,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(17,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(102,17): error CS0841: Cannot use local variable 'l' before it is declared,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(103,17): error CS0841: Cannot use local variable 'd' before it is declared,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(103,29): error CS0841: Cannot use local variable 'l' before it is declared,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(107,31): error CS0136: A local or parameter named 'l' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(110,17): error CS0841: Cannot use local variable 'd' before it is declared,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(114,33): error CS0136: A local or parameter named 'd' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(109,17): warning CS1717: Assignment made to same variable; did you mean to assign something else?,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(116,17): warning CS1717: Assignment made to same variable; did you mean to assign something else?,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(104,17): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(104,17): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(111,17): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(111,17): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(118,17): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(118,17): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(125,17): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(125,17): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(133,21): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(133,21): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(139,21): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(139,21): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(145,13): error CS0177: The out parameter 'l' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(145,13): error CS0177: The out parameter 'd' must be assigned to before control leaves the current method,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(4,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.CodeGen;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Pchp.CodeAnalysis.Symbols;
using Roslyn.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Ast = Devsense.PHP.Syntax.Ast;

namespace Pchp.CodeAnalysis.FlowAnalysis
{
    /// <summary>
    /// Visits single expressions and project transformations to flow state.
    /// </summary>
    internal class ExpressionAnalysis<T> : AnalysisWalker<FlowState, T>
    {
        #region Fields & Properties

        /// <summary>
        /// The worklist to be used to enqueue next blocks.
        /// </summary>
        internal Worklist<BoundBlock> Worklist { get; }

        /// <summary>
        /// Gets model for symbols resolution.
        /// </summary>
        internal ISymbolProvider/*!*/Model => _model;
        readonly ISymbolProvider/*!*/_model;

        /// <summary>
        /// Reference to corresponding source routine.
        /// </summary>
        public SourceRoutineSymbol Routine => State.Routine;

        /// <summary>
        /// Gets current type context for type masks resolving.
        /// </summary>
        internal TypeRefContext TypeCtx => State.TypeRefContext;

        protected PhpCompilation DeclaringCompilation => _model.Compilation;

        protected BoundTypeRefFactory BoundTypeRefFactory => DeclaringCompilation.TypeRefFactory;

        #endregion

        #region Helpers

        /// <summary>
        /// In case given expression is a local or parameter reference,
        /// gets its variable handle within <see cref="State"/>.
        /// </summary>
        VariableHandle TryGetVariableHandle(BoundExpression expr)
        {
            var varname = AsVariableName(expr as BoundReferenceExpression);
            if (varname.IsValid())
            {
                return State.GetLocalHandle(varname);
            }
            else
            {
                return default(VariableHandle);
            }
        }

        /// <summary>
        /// In case of a local variable or parameter, gets its name.
        /// </summary>
        static VariableName AsVariableName(BoundReferenceExpression r)
        {
            if (r is BoundVariableRef vr)
            {
                return vr.Name.NameValue;
            }

            return default;
        }

        static bool IsLongConstant(BoundExpression expr, long value)
        {
            if (expr.ConstantValue.HasValue)
            {
                if (expr.ConstantValue.Value is long) return ((long)expr.ConstantValue.Value) == value;
                if (expr.ConstantValue.Value is int) return ((int)expr.ConstantValue.Value) == value;
            }
            return false;
        }

        static bool TryConvertToNumber(object value, out long l, out double d)
        {
            if (value is int)
            {
                l = (int)value;
                d = (double)l;
                return true;
            }

            if (value is long)
            {
                l = (long)value;
                d = (double)l;
                return true;
            }

            if (value is double)
            {
                d = (double)value;
                l = (long)d;
                return true;
            }

            if (value is bool)
            {
                l = (bool)value ? 1 : 0;
                d = (double)l;
                return true;
            }

            if (value is string s)
            {
                if (long.TryParse(s, out l))
                {
                    d = (double)l;
                    return true;
                }

                if (double.TryParse(s, out d))
                {
                    l = (long)d;
                    return true;
                }
            }

            l = default;
            d = default;
            return false;
        }

        bool BindConstantValue(BoundExpression target, FieldSymbol symbol)
        {
            if (symbol != null && symbol.IsConst)
            {
                var cvalue = symbol.GetConstantValue(false);
                target.ConstantValue = (cvalue != null) ? new Optional<object>(cvalue.Value) : null;

                if (cvalue != null && cvalue.IsNull)
                {
                    target.TypeRefMask = TypeCtx.GetNullTypeMask();
                    return true;
                }

                target.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, symbol.Type, notNull: true);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Finds the root of given chain, i.e.:
        /// $a : $a
        /// $$a : $a
        /// $a->b : $a
        /// $a[..] : $a
        /// $a->foo() : $a
        /// etc.
        /// </summary>
        /// <remarks>If given expression 'isset', its root returned by this method must be set as well.</remarks>
        internal BoundExpression TryGetExpressionChainRoot(BoundExpression x)
        {
            if (x != null)
            {
                if (x is BoundVariableRef v) return v.Name.IsDirect ? v : TryGetExpressionChainRoot(v.Name.NameExpression);
                if (x is BoundFieldRef f) return TryGetExpressionChainRoot(f.Instance ?? (f.ContainingType as BoundIndirectTypeRef)?.TypeExpression);
                if (x is BoundInstanceFunctionCall m) return TryGetExpressionChainRoot(m.Instance);
                if (x is BoundArrayItemEx a) return TryGetExpressionChainRoot(a.Array);
            }

            return null;
        }

        /// <summary>
        /// Gets current visibility scope.
        /// </summary>
        protected OverloadsList.VisibilityScope VisibilityScope => new OverloadsList.VisibilityScope(TypeCtx.SelfType, Routine);

        protected void PingSubscribers(ExitBlock exit)
        {
            if (exit != null)
            {
                var wasNotAnalysed = false;

                if (Routine != null && !Routine.IsReturnAnalysed)
                {
                    Routine.IsReturnAnalysed = true;
                    wasNotAnalysed = true;
                }

                // Ping the subscribers either if the return type has changed or
                // it is the first time the analysis reached the routine exit
                var rtype = State.GetReturnType();
                if (rtype != exit._lastReturnTypeMask || wasNotAnalysed)
                {
                    exit._lastReturnTypeMask = rtype;
                    var subscribers = exit.Subscribers;
                    if (subscribers.Count != 0)
                    {
                        lock (subscribers)
                        {
                            foreach (var subscriber in subscribers)
                            {
                                Worklist.PingReturnUpdate(exit, subscriber);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsDouble(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(BoundExpression x) => IsDoubleOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsLong(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(BoundExpression x) => IsLongOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        /// <param name="tmask"></param>
        /// <returns></returns>
        protected bool IsNumberOnly(TypeRefMask tmask)
        {
            if (TypeCtx.IsLong(tmask) || TypeCtx.IsDouble(tmask))
            {
                if (tmask.IsSingleType)
                {
                    return true;
                }

                return !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsNumber();
            }

            return false;
        }

        /// <summary>
        /// Gets value indicating the given type represents only class types.
        /// </summary>
        protected bool IsClassOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsObject();
        }

        /// <summary>
        /// Gets value indicating the given type represents only array types.
        /// </summary>
        protected bool IsArrayOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsArray();
        }

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        protected bool IsNumberOnly(BoundExpression x) => IsNumberOnly(x.TypeRefMask);

        #endregion

        #region Construction

        /// <summary>
        /// Creates an instance of <see cref="ExpressionAnalysis{T}"/> that can analyse a block.
        /// </summary>
        /// <param name="worklist">The worklist to be used to enqueue next blocks.</param>
        /// <param name="model">The semantic context of the compilation.</param>
        public ExpressionAnalysis(Worklist<BoundBlock> worklist, ISymbolProvider model)
        {
            Debug.Assert(model != null);
            _model = model;
            Worklist = worklist;
        }

        #endregion

        #region State and worklist handling

        protected override bool IsStateInitialized(FlowState state) => state != null;

        protected override bool AreStatesEqual(FlowState a, FlowState b) => a.Equals(b);

        protected override FlowState GetState(BoundBlock block) => block.FlowState;

        protected override void SetState(BoundBlock block, FlowState state) => block.FlowState = state;

        protected override FlowState CloneState(FlowState state) => state.Clone();

        protected override FlowState MergeStates(FlowState a, FlowState b) => a.Merge(b);

        protected override void SetStateUnknown(ref FlowState state) => state.SetAllUnknown(true);

        protected override void EnqueueBlock(BoundBlock block) => Worklist.Enqueue(block);

        #endregion

        #region Visit blocks

        public override T VisitCFGExitBlock(ExitBlock x)
        {
            VisitCFGBlock(x);

            // TODO: EdgeToCallers:
            PingSubscribers(x);

            return default;
        }

        public override T VisitCFGCatchBlock(CatchBlock x)
        {
            VisitCFGBlockInit(x);

            // add catch control variable to the state
            x.TypeRef.Accept(this);

            if (x.Variable != null)
            {
                x.Variable.Access = BoundAccess.Write.WithWrite(x.TypeRef.GetTypeRefMask(TypeCtx));
                State.SetLocalType(State.GetLocalHandle(x.Variable.Name.NameValue), x.Variable.Access.WriteMask);
                Accept(x.Variable);

                //
                x.Variable.ResultType = (TypeSymbol)x.TypeRef.Type;
            }


            //
            DefaultVisitBlock(x);

            return default;
        }

        #endregion

        #region Declaration Statements

        public override T VisitStaticStatement(BoundStaticVariableStatement x)
        {
            var v = x.Declaration;
            var local = State.GetLocalHandle(new VariableName(v.Name));

            State.SetVarKind(local, VariableKind.StaticVariable);

            var oldtype = State.GetLocalType(local).WithRefFlag;

            // set var
            if (v.InitialValue != null)
            {
                // analyse initializer
                Accept(v.InitialValue);

                bool isInt = v.InitialValue.ConstantValue.IsInteger(out long intVal);
                State.SetLessThanLongMax(local, isInt && intVal < long.MaxValue);
                State.SetGreaterThanLongMin(local, isInt && intVal > long.MinValue);

                State.SetLocalType(local, ((IPhpExpression)v.InitialValue).TypeRefMask | oldtype);
            }
            else
            {
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetLocalType(local, TypeCtx.GetNullTypeMask() | oldtype);
                // TODO: explicitly State.SetLocalUninitialized() ?
            }

            return default;
        }

        public override T VisitGlobalStatement(BoundGlobalVariableStatement x)
        {
            base.VisitGlobalStatement(x);   // Accept(x.Variable)

            return default;
        }

        #endregion

        #region Visit Literals

        public override T VisitLiteral(BoundLiteral x)
        {
            x.TypeRefMask = x.ResolveTypeMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit CopyValue

        public override T VisitCopyValue(BoundCopyValue x)
        {
            Accept(x.Expression);

            var tmask = x.Expression.TypeRefMask;

            if (tmask.IsRef)
            {
                // copied value is possible a reference,
                // might be anything:
                tmask = TypeRefMask.AnyType;
            }

            // the result is not a reference for sure:
            Debug.Assert(!tmask.IsRef);

            x.TypeRefMask = tmask;

            return default;
        }

        #endregion

        #region Visit Assignments

        public override T VisitAssign(BoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            //
            Accept(x.Value);

            // keep WriteRef flag
            var targetaccess = BoundAccess.None.WithWrite(x.Value.TypeRefMask);
            if (x.Target.Access.IsWriteRef)
            {
                targetaccess = targetaccess.WithWriteRef(0);
            }

            // new target access with resolved target type
            Visit(x.Target, targetaccess);

            //
            x.TypeRefMask = x.Value.TypeRefMask;

            return default;
        }

        public override T VisitCompoundAssign(BoundCompoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            // Target X Value
            var tmp = new BoundBinaryEx(x.Target.WithAccess(BoundAccess.Read), x.Value, AstUtils.CompoundOpToBinaryOp(x.Operation));
            Visit(tmp, ConditionBranch.AnyResult);

            // Target =
            Visit(x.Target, BoundAccess.Write.WithWrite(tmp.TypeRefMask));

            // put read access back
            x.Target.Access = x.Target.Access.WithRead();

            //
            x.TypeRefMask = tmp.TypeRefMask;

            return default;
        }

        protected virtual void VisitSuperglobalVariableRef(BoundVariableRef x)
        {
            Debug.Assert(x.Name.IsDirect);
            Debug.Assert(x.Name.NameValue.IsAutoGlobal);

            // remember the initial state of variable at this point
            x.BeforeTypeRef = TypeRefMask.AnyType;

            // bind variable place
            x.Variable = Routine.LocalsTable.BindAutoGlobalVariable(x.Name.NameValue);

            // update state
            if (x.Access.IsRead)
            {
                TypeRefMask vartype;

                if (x.Name.NameValue == VariableName.HttpRawPostDataName)
                {
                    // $HTTP_RAW_POST_DATA : string // TODO: make it mixed or string | binary string
                    vartype = TypeCtx.GetStringTypeMask();
                }
                else
                {
                    // all the other autoglobals are arrays:
                    vartype = TypeCtx.GetArrayTypeMask();
                }

                if (x.Access.IsReadRef)
                {
                    vartype = vartype.WithRefFlag;
                }

                if (x.Access.EnsureObject)
                {
                    // TODO: report ERR
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                x.TypeRefMask = x.Access.WriteMask;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
            }
        }

        protected virtual void VisitLocalVariableRef(BoundVariableRef x, VariableHandle local)
        {
            Debug.Assert(local.IsValid);

            if (Routine == null)
            {
                // invalid use of variable:
                return;
            }

            var previoustype = State.GetLocalType(local);       // type of the variable in the previous state

            // remember the initial state of variable at this point
            x.BeforeTypeRef = previoustype;

            // bind variable place
            if (x.Variable == null)
            {
                x.Variable = x.IsLowerTemp()     // synthesized variable constructed by semantic binder
                    ? Routine.LocalsTable.BindTemporalVariable(local.Name)
                    : Routine.LocalsTable.BindLocalVariable(local.Name, x.PhpSyntax.Span.ToTextSpan());
            }

            //
            State.VisitLocal(local);

            // update state
            if (x.Access.IsRead)
            {
                var vartype = previoustype;

                if (x.Variable is ThisVariableReference)
                {
                    // optimization; we know the exact type here or at least we know it is `Object` (instead of AnyType)
                    // if vartype is resolved to a single instance it was probably done by some operand like 'instanceof' already and better

                    if (vartype.IsSingleType == false || Routine.IsGlobalScope)
                    {
                        vartype = TypeCtx.GetThisTypeMask(); // : System.Object or exact type, with subclasses if applicable
                    }
                }
                else if (vartype.IsVoid || Routine.IsGlobalScope)
                {
                    // in global code or in case of undefined variable,
                    // assume the type is mixed (unspecified).
                    // In global code, the type of variable cannot be determined by type analysis, it can change between every two operations (this may be improved by better flow analysis).
                    vartype = TypeRefMask.AnyType;
                    vartype.IsRef = previoustype.IsRef;

                    if (Routine.IsGlobalScope)
                    {
                        // in global code, treat the variable as initialized always:
                        State.SetVarInitialized(local);
                        vartype.IsRef = true;   // variable might be a reference
                    }
                }
                else
                {
                    //// if there are multiple types possible
                    //// find the common base (this allows for better methods resolution)
                    //if (!vartype.IsAnyType && !vartype.IsRef && vartype.IncludesSubclasses && !vartype.IsSingleType && TypeCtx.IsObject(vartype))
                    //{
                    //    // ...
                    //}
                }

                if (x.Access.IsEnsure)
                {
                    if (x.Access.IsReadRef)
                    {
                        State.MarkLocalByRef(local);
                        vartype.IsRef = true;
                    }
                    if (x.Access.EnsureObject && !TypeCtx.IsObject(vartype))
                    {
                        vartype |= TypeCtx.GetSystemObjectTypeMask();
                    }
                    if (x.Access.EnsureArray)
                    {
                        if (!TypeHelpers.HasArrayAccess(vartype, TypeCtx, DeclaringCompilation))
                        {
                            vartype |= TypeCtx.GetArrayTypeMask();
                        }
                        else if (TypeCtx.IsReadonlyString(vartype))
                        {
                            vartype |= TypeCtx.GetWritableStringTypeMask();
                        }
                    }

                    State.SetLocalType(local, vartype);
                }
                else
                {
                    // reset 'MaybeUninitialized' flag:
                    x.MaybeUninitialized = false;

                    if (!State.IsLocalSet(local))
                    {
                        // do not flag as uninitialized if variable:
                        // - may be a reference
                        // - is in a global scope
                        if (!vartype.IsRef && !Routine.IsGlobalScope)
                        {
                            x.MaybeUninitialized = true;
                        }

                        // variable maybe null if it can be uninitialized
                        vartype |= TypeCtx.GetNullTypeMask();
                    }
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                var vartype = x.Access.WriteMask;

                if (x.Access.IsWriteRef || previoustype.IsRef)    // keep the ref flag of local
                {
                    vartype.IsRef = true;
                    State.MarkLocalByRef(local);
                }
                else if (vartype.IsRef)
                {
                    // // we can't be sure about the type
                    vartype = TypeRefMask.AnyType; // anything, not ref
                                                   //vartype.IsRef = false;  // the variable won't be a reference from this point
                }

                //
                State.SetLocalType(local, vartype);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
                State.SetLocalType(local, x.TypeRefMask);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetVarUninitialized(local);
            }
        }

        public override T VisitVariableRef(BoundVariableRef x)
        {
            if (x.Name.IsDirect)
            {
                // direct variable access:
                if (x.Name.NameValue.IsAutoGlobal)
                {
                    VisitSuperglobalVariableRef(x);
                }
                else
                {
                    VisitLocalVariableRef(x, State.GetLocalHandle(x.Name.NameValue));
                }
            }
            else
            {
                x.BeforeTypeRef = TypeRefMask.AnyType;

                Accept(x.Name.NameExpression);

                // bind variable place
                x.Variable ??= new LocalVariableReference(VariableKind.LocalVariable, Routine, null, x.Name);

                // update state
                if (x.Access.IsRead)
                {
                    State.FlowContext.SetAllUsed();
                    x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                }

                if (x.Access.IsWrite || x.Access.IsEnsure)
                {
                    State.SetAllUnknown(x.Access.IsWriteRef);
                    x.TypeRefMask = x.Access.WriteMask;
                }

                if (x.Access.IsUnset)
                {

                }
            }

            return default;
        }

        public override T VisitIncDec(BoundIncDecEx x)
        {
            // <target> = <target> +/- 1L

            Debug.Assert(x.Access.IsRead || x.Access.IsNone);
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);

            Visit(x.Target, BoundAccess.Read);
            Visit(x.Value, BoundAccess.Read);

            Debug.Assert(IsNumberOnly(x.Value));    // 1L

            TypeRefMask resulttype;
            TypeRefMask sourcetype = x.Target.TypeRefMask;  // type of target before operation

            VariableHandle lazyVarHandle = default;
            bool lessThanLongMax = false;               // whether the variable's value is less than the max long value
            bool greaterThanLongMin = false;            // or greater than the min long value

            if (IsDoubleOnly(x.Target))
            {
                // double++ => double
                resulttype = TypeCtx.GetDoubleTypeMask();
            }
            else
            {
                // we'd like to keep long if we are sure we don't overflow to double
                lazyVarHandle = TryGetVariableHandle(x.Target);
                if (lazyVarHandle.IsValid && x.IsIncrement && State.IsLessThanLongMax(lazyVarHandle))
                {
                    // long++ [< long.MaxValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    lessThanLongMax = true;
                }
                else if (lazyVarHandle.IsValid && !x.IsIncrement && State.IsGreaterThanLongMin(lazyVarHandle))
                {
                    // long-- [> long.MinValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    greaterThanLongMin = true;
                }
                else
                {
                    // long|double|anything++/-- => number
                    resulttype = TypeCtx.GetNumberTypeMask();
                }
            }

            Visit(x.Target, BoundAccess.Write.WithWrite(resulttype));

            //
            x.Target.Access = x.Target.Access.WithRead();   // put read access back to the target
            x.TypeRefMask = x.IsPostfix ? sourcetype : resulttype;

            // We expect that an incrementation doesn't change the property of being less than the max long value,
            // it needs to be restored due to the write access of the target variable
            if (lessThanLongMax)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetLessThanLongMax(lazyVarHandle, true);
            }

            // The same for the min long value
            if (greaterThanLongMin)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetGreaterThanLongMin(lazyVarHandle, true);
            }

            return default;
        }

        #endregion

        #region Visit BinaryEx

        private void VisitShortCircuitOp(BoundExpression lExpr, BoundExpression rExpr, bool isAndOp, ConditionBranch branch)
        {
            // Each operand has to be evaluated in various states and then the state merged.
            // Simulates short-circuit evaluation in runtime:

            var state = this.State; // original state

            if (branch == ConditionBranch.AnyResult)
            {
                if (isAndOp)
                {
                    // A == True && B == Any
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == Any
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToTrue)
            {
                if (isAndOp)
                {
                    // A == True && B == True

                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                }
                else
                {
                    // A == False && B == True
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToFalse)
            {
                if (isAndOp)
                {
                    // A == True && B == False
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == False

                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                }
            }
        }

        /// <summary>
        /// Gets resulting type of bit operation (bit or, and, xor).
        /// </summary>
        TypeRefMask GetBitOperationType(TypeRefMask lValType, TypeRefMask rValType)
        {
            TypeRefMask type;

            // type is string if both operands are string
            if ((lValType.IsAnyType && rValType.IsAnyType) ||
                (TypeCtx.IsAString(lValType) && TypeCtx.IsAString(rValType)))
            {
                type = TypeCtx.GetStringTypeMask();
            }
            else
            {
                type = default(TypeRefMask);
            }

            // type can be always long
            type |= TypeCtx.GetLongTypeMask();

            //
            return type;
        }

        Optional<object> ResolveBooleanOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (xobj.TryConvertToBool(out var bx) && yobj.TryConvertToBool(out var by))
            {
                return op switch
                {
                    Operations.And => (bx && by),
                    Operations.Or => (bx || by),
                    Operations.Xor => (bx ^ by),
                    _ => throw ExceptionUtilities.Unreachable,
                };
            }

            return default;
        }

        /// <summary>
        /// Resolves value of bit operation.
        /// </summary>
        /// <remarks>TODO: move to **evaluation**.</remarks>
        Optional<object> ResolveBitOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            var xconst = xobj.ToConstantValueOrNull();
            var yconst = yobj.ToConstantValueOrNull();

            if (xconst.TryConvertToLong(out long xval) && yconst.TryConvertToLong(out long yval))
            {
                long result;

                switch (op)
                {
                    case Operations.BitOr: result = xval | yval; break;
                    case Operations.BitAnd: result = xval & yval; break;
                    case Operations.BitXor: result = xval ^ yval; break;
                    default:
                        throw new ArgumentException(nameof(op));
                }

                //
                if (result >= int.MinValue && result <= int.MaxValue)
                {
                    return (int)result;
                }
                else
                {
                    return result;
                }

                //
            }

            return default(Optional<object>);
        }

        /// <summary>
        /// Gets resulting type of <c>+</c> operation.
        /// </summary>
        TypeRefMask GetPlusOperationType(BoundExpression left, BoundExpression right)
        {
            var lValType = left.TypeRefMask;
            var rValType = right.TypeRefMask;

            // array + array => array
            // array + number => 0 (ERROR)
            // number + number => number
            // anytype + array => array
            // anytype + number => number

            var or = lValType | rValType;

            if (IsNumberOnly(or))
            {
                // double + number => double
                if (IsDoubleOnly(lValType) || IsDoubleOnly(rValType))
                    return TypeCtx.GetDoubleTypeMask();

                // long + long => long
                if (State.IsLessThanLongMax(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG + 1, where LONG < long.MaxValue
                    return TypeCtx.GetLongTypeMask();

                return TypeCtx.GetNumberTypeMask();
            }

            if ((!lValType.IsRef && !lValType.IsAnyType && !TypeCtx.IsArray(lValType)) ||
                (!rValType.IsRef && !rValType.IsAnyType && !TypeCtx.IsArray(rValType)))
            {
                // not array for sure:
                return TypeCtx.GetNumberTypeMask();
            }

            //
            var type = TypeCtx.GetArraysFromMask(or);

            //
            if (or.IsAnyType || TypeCtx.IsNumber(or) || type == 0) // !this.TypeRefContext.IsArray(lValType & rValType))
                type |= TypeCtx.GetNumberTypeMask();    // anytype or an operand is number or operands are not a number nor both are not array

            if (or.IsAnyType)
                type |= TypeCtx.GetArrayTypeMask();

            //
            return type;
        }

        static Optional<object> ResolvePlusOperation(Optional<object> xobj, Optional<object> yobj)
        {
            if (xobj.HasValue && yobj.HasValue)
            {
                switch (xobj.Value)
                {
                    case double x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return x + y;
                        }
                        break;
                    case long x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y:
                                try { return checked(x + y); }
                                catch (OverflowException) { return (double)x + y; }
                            case int y: return x + y;
                        }
                        break;
                    case int x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return (long)x + y;
                        }
                        break;
                }
            }

            return default;
        }

        static Optional<object> ResolveOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (!xobj.HasValue || !yobj.HasValue)
            {
                return default;
            }

            switch (op)
            {
                case Operations.Add:
                    return ResolvePlusOperation(xobj, yobj);

                case Operations.Mul:
                    switch (xobj.Value)
                    {
                        case double x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y: return x * y;
                                case int y: return x * y;
                            }
                            break;
                        case int x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                        case long x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                    }
                    break;
            }

            return default;
        }

        /// <summary>
        /// Gets resulting type of <c>-</c> operation.
        /// </summary>
        TypeRefMask GetMinusOperationType(BoundExpression left, BoundExpression right)
        {
            if (IsDoubleOnly(left.TypeRefMask) || IsDoubleOnly(right.TypeRefMask)) // some operand is double and nothing else
                return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
            else if (State.IsGreaterThanLongMin(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG -1, where LONG > long.MinValue
                return TypeCtx.GetLongTypeMask();
            else
                return TypeCtx.GetNumberTypeMask();
        }

        protected override void Visit(BoundBinaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveBinaryEx(x, branch);
        }

        TypeRefMask ResolveBinaryEx(BoundBinaryEx x, ConditionBranch branch)
        {
            if (x.Operation == Operations.And || x.Operation == Operations.Or)
            {
                this.VisitShortCircuitOp(x.Left, x.Right, x.Operation == Operations.And, branch);
            }
            else
            {
                Accept(x.Left);
                Accept(x.Right);
            }

            switch (x.Operation)
            {
                #region Arithmetic Operations

                case Operations.Add:
                    x.ConstantValue = ResolvePlusOperation(x.Left.ConstantValue, x.Right.ConstantValue);
                    return x.ConstantValue.HasValue
                        ? TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue)
                        : GetPlusOperationType(x.Left, x.Right);

                case Operations.Sub:
                    return GetMinusOperationType(x.Left, x.Right);

                case Operations.Div:
                case Operations.Mul:
                case Operations.Pow:

                    x.ConstantValue = ResolveOperation(x.Left.ConstantValue, x.Right.ConstantValue.Value, x.Operation);
                    if (x.ConstantValue.HasValue)
                    {
                        return TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue);
                    }
                    else if (IsDoubleOnly(x.Left.TypeRefMask) || IsDoubleOnly(x.Right.TypeRefMask)) // some operand is double and nothing else
                    {
                        return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
                    }
                    else
                    {
                        return TypeCtx.GetNumberTypeMask();
                    }

                case Operations.Mod:
                    return TypeCtx.GetLongTypeMask();

                case Operations.ShiftLeft:
                case Operations.ShiftRight:

                    x.ConstantValue = ResolveShift(x.Operation, x.Left.ConstantValue, x.Right.ConstantValue);
                    return TypeCtx.GetLongTypeMask();

                #endregion

                #region Boolean and Bitwise Operations

                case Operations.And:
                case Operations.Or:
                case Operations.Xor:

                    x.ConstantValue = ResolveBooleanOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return TypeCtx.GetBooleanTypeMask();

                case Operations.BitAnd:
                case Operations.BitOr:
                case Operations.BitXor:

                    x.ConstantValue = ResolveBitOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return GetBitOperationType(x.Left.TypeRefMask, x.Right.TypeRefMask);    // int or string

                #endregion

                #region Comparing Operations

                case Operations.Equal:
                case Operations.NotEqual:
                case Operations.Identical:
                case Operations.NotIdentical:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    if (branch != ConditionBranch.AnyResult)
                    {
                        // We must beware not to compute constant value more than once (losing results) -> mark handling of the given expression by this boolean
                        bool handled = false;

                        if (x.Right.ConstantValue.HasValue && x.Left is BoundReferenceExpression boundLeft)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundLeft, x.Right.ConstantValue, branch);
                        }
                        else if (x.Left.ConstantValue.HasValue && x.Right is BoundReferenceExpression boundRight)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundRight, x.Left.ConstantValue, branch);
                        }

                        if (!handled)
                        {
                            ResolveEquality(x);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                case Operations.GreaterThan:
                case Operations.LessThan:
                case Operations.GreaterThanOrEqual:
                case Operations.LessThanOrEqual:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    // comparison with long value
                    if (branch == ConditionBranch.ToTrue && IsLongOnly(x.Right))
                    {
                        if (x.Operation == Operations.LessThan ||
                            (x.Operation == Operations.LessThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal) && rightVal < long.MaxValue))
                        {
                            // $x < Long.Max
                            State.SetLessThanLongMax(TryGetVariableHandle(x.Left), true);
                        }
                        else if (x.Operation == Operations.GreaterThan ||
                            (x.Operation == Operations.GreaterThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal2) && rightVal2 > long.MinValue))
                        {
                            // $x > Long.Min
                            State.SetGreaterThanLongMin(TryGetVariableHandle(x.Left), true);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                #endregion

                case Operations.Concat:
                    return TypeCtx.GetWritableStringTypeMask();

                case Operations.Coalesce:   // Left ?? Right
                    return x.Left.TypeRefMask | x.Right.TypeRefMask;

                case Operations.Spaceship:
                    return TypeCtx.GetLongTypeMask(); // -1, 0, +1

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.Operation);
            }
        }

        /// <summary>
        /// If possible, resolve the comparison operation in compile-time.
        /// </summary>
        static Optional<object> ResolveComparison(Operations op, object lvalue, object rvalue)
        {
            // TODO

            if (TryConvertToNumber(lvalue, out _, out var dl) && TryConvertToNumber(rvalue, out _, out var dr))
            {
                return op switch
                {
                    Operations.Equal => dl == dr,
                    Operations.GreaterThan => dl > dr,
                    Operations.LessThan => dl < dr,
                    Operations.GreaterThanOrEqual => dl >= dr,
                    Operations.LessThanOrEqual => dl <= dr,
                    _ => default(Optional<object>),
                };
            }

            //
            return default;
        }

        static Optional<object> ResolveShift(Operations op, Optional<object> lvalue, Optional<object> rvalue)
        {
            if (lvalue.TryConvertToLong(out var left) && rvalue.TryConvertToLong(out var right))
            {
                switch (op)
                {
                    case Operations.ShiftLeft:
                        return (left << (int)right).AsOptional();

                    case Operations.ShiftRight:
                        return (left >> (int)right).AsOptional();

                    default:
                        Debug.Fail("unexpected");
                        break;

                }
            }

            return default;
        }

        /// <summary>
        /// Resolves variable types and potentially assigns a constant boolean value to an expression of a comparison of
        /// a variable and a constant - operators ==, !=, === and !==. Returns true iff this expression was handled and there
        /// is no need to analyse it any more (adding constant value etc.).
        /// </summary>
        private bool ResolveEqualityWithConstantValue(
            BoundBinaryEx cmpExpr,
            BoundReferenceExpression refExpr,
            Optional<object> value,
            ConditionBranch branch)
        {
            Debug.Assert(branch != ConditionBranch.AnyResult);

            if (value.IsNull() && refExpr is BoundVariableRef varRef)
            {
                bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);

                // We cannot say much about the type of $x in the true branch of ($x == null) and the false branch of ($x != null),
                // because it holds for false, 0, "", array() etc.
                if (isStrict || branch.TargetValue() != isPositive)
                {
                    AnalysisFacts.HandleTypeCheckingExpression(
                        varRef,
                        TypeCtx.GetNullTypeMask(),
                        branch,
                        State,
                        checkExpr: cmpExpr,
                        isPositiveCheck: isPositive);
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Attempts to infer the result of an equality comparison from the types of the operands.
        /// </summary>
        private void ResolveEquality(BoundBinaryEx cmpExpr)
        {
            Debug.Assert(cmpExpr.Operation >= Operations.Equal && cmpExpr.Operation <= Operations.NotIdentical);

            bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);

            if (isStrict && !cmpExpr.Left.CanHaveSideEffects() && !cmpExpr.Right.CanHaveSideEffects())
            {
                // Always returns false if checked for strict equality and the operands are of different types (and vice versa for strict non-eq)
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);
                bool canBeSameType = Routine.TypeRefContext.CanBeSameType(cmpExpr.Left.TypeRefMask, cmpExpr.Right.TypeRefMask);
                cmpExpr.ConstantValue = !canBeSameType ? (!isPositive).AsOptional() : default;
            }
        }

        #endregion

        #region Visit UnaryEx

        protected override void Visit(BoundUnaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveUnaryOperatorExpression(x, branch);
        }

        TypeRefMask ResolveUnaryOperatorExpression(BoundUnaryEx x, ConditionBranch branch)
        {
            if (branch != ConditionBranch.AnyResult && x.Operation == Operations.LogicNegation)
            {
                // Negation swaps the branches
                VisitCondition(x.Operand, branch.NegativeBranch());
            }
            else
            {
                Accept(x.Operand);
            }

            // clear any previous resolved constant 
            x.ConstantValue = default(Optional<object>);

            //
            switch (x.Operation)
            {
                case Operations.AtSign:
                    return x.Operand.TypeRefMask;

                case Operations.BitNegation:
                    if (x.Operand.ConstantValue.HasValue)
                    {
                        if (x.Operand.ConstantValue.Value is long l)
                        {
                            x.ConstantValue = new Optional<object>(~l);
                        }
                        else if (x.Operand.ConstantValue.Value is int i)
                        {
                            x.ConstantValue = new Optional<object>(~(long)i);
                        }
                    }

                    return TypeCtx.GetLongTypeMask();   // TODO: or byte[]

                case Operations.Clone:
                    // result is always object, not aliased
                    return TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask).IsVoid
                        ? TypeCtx.GetSystemObjectTypeMask()                     // "object"
                        : TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask);    // (object)T

                case Operations.LogicNegation:
                    {
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(!constBool);
                        }
                        return TypeCtx.GetBooleanTypeMask();
                    }

                case Operations.Minus:
                    var cvalue = ResolveUnaryMinus(x.Operand.ConstantValue.ToConstantValueOrNull());
                    if (cvalue != null)
                    {
                        x.ConstantValue = new Optional<object>(cvalue.Value);
                        return TypeCtx.GetTypeMask(BoundTypeRefFactory.Create(cvalue), false);
                    }
                    else
                    {
                        if (IsDoubleOnly(x.Operand))
                        {
                            return TypeCtx.GetDoubleTypeMask(); // double in case operand is double
                        }
                        return TypeCtx.GetNumberTypeMask();     // TODO: long in case operand is not a number
                    }

                case Operations.UnsetCast:
                    return TypeCtx.GetNullTypeMask();   // null

                case Operations.Plus:
                    if (IsNumberOnly(x.Operand.TypeRefMask))
                        return x.Operand.TypeRefMask;
                    return TypeCtx.GetNumberTypeMask();

                case Operations.Print:
                    return TypeCtx.GetLongTypeMask();

                default:
                    throw ExceptionUtilities.Unreachable;
            }
        }

        ConstantValue ResolveUnaryMinus(ConstantValue value)
        {
            if (value != null)
            {
                switch (value.SpecialType)
                {
                    case SpecialType.System_Double:
                        return ConstantValue.Create(-value.DoubleValue);

                    case SpecialType.System_Int32:
                        return value.Int32Value != int.MinValue
                            ? ConstantValue.Create(-value.Int32Value)   // (- Int32.MinValue) overflows to int64
                            : ConstantValue.Create(-(long)value.Int32Value);

                    case SpecialType.System_Int64:
                        return (value.Int64Value != long.MinValue)  // (- Int64.MinValue) overflows to double
                            ? ConstantValue.Create(-value.Int64Value)
                            : ConstantValue.Create(-(double)value.Int64Value);
                    default:
                        break;
                }
            }

            return null;
        }

        #endregion

        #region Visit Conversion

        public override T VisitConversion(BoundConversionEx x)
        {
            base.VisitConversion(x);

            // evaluate if possible

            if (x.TargetType is BoundPrimitiveTypeRef pt)
            {
                switch (pt.TypeCode)
                {
                    case PhpTypeCode.Boolean:
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(constBool);
                        }
                        break;

                    case PhpTypeCode.Long:
                        if (x.Operand.ConstantValue.TryConvertToLong(out long l))
                        {
                            x.ConstantValue = new Optional<object>(l);
                        }
                        break;

                    case PhpTypeCode.Double:
                        break;

                    case PhpTypeCode.String:
                    case PhpTypeCode.WritableString:
                        if (x.Operand.ConstantValue.TryConvertToString(out string str))
                        {
                            x.ConstantValue = new Optional<object>(str);
                        }
                        break;

                    case PhpTypeCode.Object:
                        if (IsClassOnly(x.Operand.TypeRefMask))
                        {
                            // it is object already, keep its specific type
                            x.TypeRefMask = x.Operand.TypeRefMask;   // (object)<object>
                            return default;
                        }
                        else if (IsArrayOnly(x.Operand.TypeRefMask))
                        {
                            // array -> object conversion
                            // always stdClass
                            x.TypeRefMask = TypeCtx.GetTypeMask(BoundTypeRefFactory.stdClassTypeRef, false);
                            return default;
                        }
                        break;
                }
            }

            //

            x.TypeRefMask = x.TargetType.GetTypeRefMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit InstanceOf

        protected override void Visit(BoundInstanceOfEx x, ConditionBranch branch)
        {
            Accept(x.Operand);
            x.AsType.Accept(this);

            // TOOD: x.ConstantValue // in case we know and the operand is a local variable (we can ignore the expression and emit result immediatelly)

            var opTypeMask = x.Operand.TypeRefMask;
            if (x.Operand is BoundLiteral
                || (!opTypeMask.IsAnyType && !opTypeMask.IsRef && !Routine.TypeRefContext.IsObject(opTypeMask)))
            {
                x.ConstantValue = ConstantValueExtensions.AsOptional(false);
            }
            else if (x.Operand is BoundVariableRef vref && vref.Name.IsDirect)
            {
                if (branch == ConditionBranch.ToTrue)
                {
                    // if (Variable is T) => variable is T in True branch state
                    var vartype = x.AsType.GetTypeRefMask(TypeCtx);
                    if (opTypeMask.IsRef) vartype = vartype.WithRefFlag; // keep IsRef flag

                    State.SetLocalType(State.GetLocalHandle(vref.Name.NameValue), vartype);
                }
            }

            //
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        #endregion

        #region Visit IsSet, OffsetExists

        protected override void Visit(BoundIsSetEx x, ConditionBranch branch)
        {
            Accept(x.VarReference);

            // try to get resulting value and type of the variable
            var localname = AsVariableName(x.VarReference);
            if (localname.IsValid())
            {
                var handle = State.GetLocalHandle(localname);
                Debug.Assert(handle.IsValid);

                // Remove any constant value of isset()
                x.ConstantValue = default;

                //
                if (State.IsLocalSet(handle))
                {
                    // If the variable is always defined, isset() behaves like !is_null()
                    var currenttype = State.GetLocalType(handle);

                    // a type in the true branch:
                    var positivetype = TypeCtx.WithoutNull(currenttype);

                    // resolve the constant if possible,
                    // does not depend on the branch
                    if (!currenttype.IsRef && !currenttype.IsAnyType)
                    {
                        if (positivetype.IsVoid)    // always false
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                        }
                        else if (positivetype == currenttype)   // not void nor null
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(true);
                        }
                    }

                    // we can be more specific in true/false branches:
                    if (branch != ConditionBranch.AnyResult && !x.ConstantValue.HasValue)
                    {
                        // update target type in true/false branch:
                        var newtype = (branch == ConditionBranch.ToTrue)
                            ? positivetype
                            : TypeCtx.GetNullTypeMask();

                        // keep the flags
                        newtype |= currenttype.Flags;

                        //
                        State.SetLocalType(handle, newtype);
                    }
                }
                else if (localname.IsAutoGlobal)
                {
                    // nothing
                }
                else
                {
                    // variable is not set for sure
                    // isset : false
                    x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                }

                // mark variable as either initialized or uninintialized in respective branches
                if (branch == ConditionBranch.ToTrue)
                {
                    State.SetVarInitialized(handle);
                }
            }

            // always returns a boolean
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        public override T VisitOffsetExists(BoundOffsetExists x)
        {
            // receiver[index]
            base.VisitOffsetExists(x);

            // TODO: if receiver is undefined -> result is false

            // always bool
            x.ResultType = DeclaringCompilation.CoreTypes.Boolean;
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
            return default;
        }

        public override T VisitTryGetItem(BoundTryGetItem x)
        {
            // array, index, fallback
            base.VisitTryGetItem(x);

            // TODO: resulting type if possible (see VisitArrayItem)

            // The result of array[index] might be a reference
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;

            return default;
        }

        #endregion

        #region TypeRef

        internal override T VisitIndirectTypeRef(BoundIndirectTypeRef tref)
        {
            // visit indirect type
            base.VisitIndirectTypeRef(tref);

            //
            return VisitTypeRef(tref);
        }

        internal override T VisitTypeRef(BoundTypeRef tref)
        {
            Debug.Assert(!(tref is BoundMultipleTypeRef));

            // resolve type symbol
            tref.ResolvedType = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);

            return default;
        }

        #endregion

        #region Visit Function Call

        protected override T VisitRoutineCall(BoundRoutineCall x)
        {
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag; // unknown function might return a reference

            // TODO: write arguments Access
            // TODO: visit invocation member of
            // TODO: 2 pass, analyze arguments -> resolve method -> assign argument to parameter -> write arguments access -> analyze arguments again

            // visit arguments:
            base.VisitRoutineCall(x);

            return default;
        }

        bool BindParams(IList<PhpParam> expectedparams, ImmutableArray<BoundArgument> givenargs)
        {
            for (int i = 0; i < givenargs.Length; i++)
            {
                if (givenargs[i].IsUnpacking)
                {
                    break;
                }

                if (i < expectedparams.Count)
                {
                    var expected = expectedparams[i];
                    if (expected.IsVariadic)
                    {
                        for (;  i < givenargs.Length; i++)
                        {
                            if (givenargs[i].IsUnpacking)
                            {
                                break; // CONSIDER
                            }

                            BindParam(expected, givenargs[i]);
                        }
                    }
                    else
                    {
                        BindParam(expected, givenargs[i]);
                    }
                }
                else
                {
                    // argument cannot be bound
                    return false;
                }
            }

            return true;
        }

        void BindParam(PhpParam expected, BoundArgument givenarg)
        {
            // bind symbol
            givenarg.Parameter = expected.ParameterSymbol;

            // [PhpRwAttribute]
            if (expected.IsPhpRw)
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (TypeCtx.IsArray(expected.Type) && !givenarg.Value.Access.EnsureArray)   // [PhpRw]PhpArray
                    {
                        SemanticsBinder.BindEnsureArrayAccess(givenarg.Value as BoundReferenceExpression);
                        Worklist.Enqueue(CurrentBlock);
                    }
                }
            }

            // bind ref parameters to variables:
            if (expected.IsAlias || expected.IsByRef)  // => args[i] must be a variable
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (expected.IsByRef && !refexpr.Access.IsWrite)
                    {
                        SemanticsBinder.BindWriteAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (expected.IsAlias && !refexpr.Access.IsReadRef)
                    {
                        SemanticsBinder.BindReadRefAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (refexpr is BoundVariableRef refvar)
                    {
                        if (refvar.Name.IsDirect)
                        {
                            var local = State.GetLocalHandle(refvar.Name.NameValue);
                            State.SetLocalType(local, expected.Type);
                            refvar.MaybeUninitialized = false;
                            if (expected.IsAlias)
                            {
                                State.MarkLocalByRef(local);
                            }
                        }
                        else
                        {
                            // TODO: indirect variable -> all may be aliases of any type
                        }
                    }
                    else
                    {
                        // fields, array items, ...
                        // TODO: remember the field will be accessed as reference
                    }
                }
                else
                {
                    // TODO: Err, variable or field must be passed into byref argument. foo("hello") where function foo(&$x){}
                }
            }
            else if (!expected.Type.IsAnyType && givenarg.Value is BoundVariableRef refvar && refvar.Name.IsDirect)
            {
                // Even for variables passed by value we may gain information about their type (if we previously had none),
                // because not complying with the parameter type would have caused throwing a TypeError
                var local = State.GetLocalHandle(refvar.Name.NameValue);
                var localType = State.GetLocalType(local);
                var paramTypeNonNull = TypeCtx.WithoutNull(expected.Type);
                if (localType.IsAnyType && !localType.IsRef &&
                    (TypeCtx.IsObjectOnly(paramTypeNonNull) || TypeCtx.IsArrayOnly(paramTypeNonNull)))    // E.g. support ?MyClass but not callable
                {
                    Debug.Assert(!expected.Type.IsRef);
                    State.SetLocalType(local, expected.Type);
                }
            }
        }

        TypeRefMask BindValidRoutineCall(BoundRoutineCall call, MethodSymbol method, ImmutableArray<BoundArgument> args, bool maybeoverload)
        {
            // analyze TargetMethod with x.Arguments
            // require method result type if access != none
            if (call.Access.IsRead)
            {
                if (Worklist.EnqueueRoutine(method, CurrentBlock, call))
                {
                    // target will be reanalysed
                    // note: continuing current block may be waste of time, but it might gather other called targets

                    // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                    _flags |= AnalysisFlags.IsCanceled;
                }
            }

            if (Routine != null)
            {
                var rflags = method.InvocationFlags(out var localaccess);
                Routine.Flags |= rflags;

                if ((rflags & RoutineFlags.UsesLocals) != 0
                    //&& (x is BoundGlobalFunctionCall gf && gf.Name.NameValue.Name.Value == "extract") // "compact" does not change locals // CONSIDER // TODO
                    )
                {
                    // function may change/add local variables
                    State.SetAllUnknown(true);
                }

                if (localaccess != null)
                {
                    foreach (var lname in localaccess)
                    {
                        // the variable will be used as reference here
                        State.MarkLocalByRef(State.GetLocalHandle(lname));
                    }
                }
            }

            // process arguments
            if (!BindParams(method.GetExpectedArguments(this.TypeCtx), args) && maybeoverload)
            {
                call.TargetMethod = null; // nullify the target method -> call dynamically, arguments cannot be bound at compile time
            }

            //
            return method.GetResultType(TypeCtx);
        }

        /// <summary>
        /// Bind arguments to target method and resolve resulting <see cref="BoundExpression.TypeRefMask"/>.
        /// Expecting <see cref="BoundRoutineCall.TargetMethod"/> is resolved.
        /// If the target method cannot be bound at compile time, <see cref="BoundRoutineCall.TargetMethod"/> is nulled.
        /// </summary>
        void BindRoutineCall(BoundRoutineCall x, bool maybeOverload = false)
        {
            if (MethodSymbolExtensions.IsValidMethod(x.TargetMethod))
            {
                x.TypeRefMask = BindValidRoutineCall(x, x.TargetMethod, x.ArgumentsInSourceOrder, maybeOverload);
            }
            else if (x.TargetMethod is MissingMethodSymbol || x.TargetMethod == null)
            {
                // we don't know anything about the target callsite,
                // locals passed as arguments should be marked as possible refs:
                foreach (var arg in x.ArgumentsInSourceOrder)
                {
                    if (arg.Value is BoundVariableRef bvar && bvar.Name.IsDirect && !arg.IsUnpacking)
                    {
                        State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                    }
                }
            }
            else if (x.TargetMethod is AmbiguousMethodSymbol ambiguity)
            {
                // check if arguments are not passed by bref, mark locals eventually as refs:
                foreach (var m in ambiguity.Ambiguities)
                {
                    var expected = m.GetExpectedArguments(this.TypeCtx);
                    var given = x.ArgumentsInSourceOrder;

                    for (int i = 0; i < given.Length && i < expected.Count; i++)
                    {
                        if (expected[i].IsAlias && given[i].Value is BoundVariableRef bvar && bvar.Name.IsDirect)
                        {
                            State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                        }
                    }
                }

                // get the return type from all the ambiguities:
                if (!maybeOverload && x.Access.IsRead)
                {
                    var r = (TypeRefMask)0;
                    foreach (var m in ambiguity.Ambiguities)
                    {
                        if (Worklist.EnqueueRoutine(m, CurrentBlock, x))
                        {
                            // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                            _flags |= AnalysisFlags.IsCanceled;
                        }

                        r |= m.GetResultType(TypeCtx);
                    }

                    x.TypeRefMask = r;
                }
            }

            //

            if (x.Access.IsReadRef)
            {
                // reading by ref:
                x.TypeRefMask = x.TypeRefMask.WithRefFlag;
            }
        }

        public override T VisitExit(BoundExitEx x)
        {
            VisitRoutineCall(x);

            // no parameters binding
            // TODO: handle unpacking
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 0 || !x.ArgumentsInSourceOrder[0].IsUnpacking);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            return default;
        }

        public override T VisitEcho(BoundEcho x)
        {
            VisitRoutineCall(x);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            //
            return default;
        }

        public override T VisitConcat(BoundConcatEx x)
        {
            VisitRoutineCall(x);

            // if possible, mark the result type as "String",
            // otherwise we have to use "PhpString"
            var args = x.ArgumentsInSourceOrder;
            bool mustBePhpString = false;
            for (int i = 0; i < args.Length; i++)
            {
                var targ = args[i].Value.TypeRefMask;
                mustBePhpString |= targ.IsRef || targ.IsAnyType || this.TypeCtx.IsWritableString(targ) /*|| this.TypeCtx.IsObject(targ) //object are always converted to UTF16 String// */;
            }

            x.TypeRefMask = mustBePhpString ? TypeCtx.GetWritableStringTypeMask() : TypeCtx.GetStringTypeMask();

            return default;
        }

        public override T VisitAssert(BoundAssertEx x)
        {
            VisitRoutineCall(x);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override void VisitGlobalFunctionCall(BoundGlobalFunctionCall x, ConditionBranch branch)
        {
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.Name.NameValue, Routine);
                if (symbol.IsMissingMethod() && x.NameOpt.HasValue)
                {
                    symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.NameOpt.Value, Routine);
                }

                var overloads = symbol is AmbiguousMethodSymbol ambiguous && ambiguous.IsOverloadable
                    ? new OverloadsList(ambiguous.Ambiguities.ToList())
                    : new OverloadsList(symbol ?? new MissingMethodSymbol(x.Name.NameValue.ToString()));

                Debug.Assert(x.TypeArguments.IsDefaultOrEmpty);

                // symbol might be ErrorSymbol

                x.TargetMethod = overloads.Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.StaticCall);
            }

            BindRoutineCall(x);

            // if possible resolve ConstantValue and TypeRefMask:
            AnalysisFacts.HandleSpecialFunctionCall(x, this, branch);
        }

        public override T VisitInstanceFunctionCall(BoundInstanceFunctionCall x)
        {
            Accept(x.Instance);
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var resolvedtype = x.Instance.ResultType;
                if (resolvedtype == null)
                {
                    var typeref = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));    // ignore NULL, causes runtime exception anyway
                    if (typeref.IsSingle)
                    {
                        resolvedtype = (TypeSymbol)typeref.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                    // else: a common base?
                }

                if (resolvedtype.IsValidType())
                {
                    var candidates = resolvedtype.LookupMethods(x.Name.NameValue.Name.Value);

                    candidates = Construct(candidates, x);

                    x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.InstanceCall);

                    //
                    if (x.TargetMethod.IsValidMethod() && x.TargetMethod.IsStatic && x.Instance.TypeRefMask.IncludesSubclasses)
                    {
                        // static method invoked on an instance object,
                        // must be postponed to runtime since the type may change
                        x.TargetMethod = new AmbiguousMethodSymbol(ImmutableArray.Create(x.TargetMethod), false);
                    }
                }
                else
                {
                    x.TargetMethod = null;
                }
            }

            BindRoutineCall(x, maybeOverload: true);

            return default;
        }

        public override T VisitStaticFunctionCall(BoundStaticFunctionCall x)
        {
            Accept(x.TypeRef);
            Accept(x.Name);

            VisitRoutineCall(x);

            var type = (TypeSymbol)x.TypeRef.Type;

            if (x.Name.NameExpression != null)
            {
                // indirect method call -> not resolvable
            }
            else if (type.IsValidType())
            {
                var candidates = type.LookupMethods(x.Name.ToStringOrThrow());
                // if (candidates.Any(c => c.HasThis)) throw new NotImplementedException("instance method called statically");

                candidates = Construct(candidates, x);

                var flags = OverloadsList.InvocationKindFlags.StaticCall;

                if (Routine != null && !Routine.IsStatic && (x.TypeRef.IsSelf() || x.TypeRef.IsParent()))
                {
                    // self:: or parent:: $this forwarding, prefer both
                    flags |= OverloadsList.InvocationKindFlags.InstanceCall;
                }

                var method = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, flags);

                // method is missing or inaccessible:
                if (method is ErrorMethodSymbol errmethod && (errmethod.ErrorKind == ErrorMethodKind.Inaccessible || errmethod.ErrorKind == ErrorMethodKind.Missing))
                {
                    // NOTE: magic methods __call or __callStatic are called in both cases - the target method is inaccessible or missing

                    var isviable = true; // can we safely resolve the method?
                    List<MethodSymbol> call = null;

                    // __call() might be used, if we have a reference to $this:
                    if (Routine != null && !Routine.IsStatic)
                    {
                        // there is $this variable:
                        if (TypeCtx.ThisType == null || TypeCtx.ThisType.IsOfType(type) || type.IsOfType(TypeCtx.ThisType))
                        {
                            // try to use __call() first:
                            call = type.LookupMethods(Name.SpecialMethodNames.Call.Value);

                            //
                            if (TypeCtx.ThisType == null && call.Count != 0)
                            {
                                // $this is resolved dynamically in runtime and
                                // we don't know if we can use __call() here
                                isviable = false;
                            }
                        }
                    }

                    if (call == null || call.Count == 0)
                    {
                        // __callStatic()
                        call = type.LookupMethods(Name.SpecialMethodNames.CallStatic.Value);
                    }

                    if (call != null && call.Count != 0)
                    {
                        // NOTE: PHP ignores visibility of __callStatic
                        call = Construct(call, x);

                        method = call.Count == 1 && isviable
                            ? new MagicCallMethodSymbol(x.Name.ToStringOrThrow(), call[0])
                            : null; // nullify the symbol so it will be called dynamically and resolved in rutime
                    }
                }

                x.TargetMethod = method;
            }
            else if (x.TypeRef.IsSelf() && Routine != null && Routine.ContainingType.IsTraitType())
            {
                // self:: within trait type
                // resolve possible code path
                // we need this at least to determine possible late static type binding

                var candidates = Construct(Routine.ContainingType.LookupMethods(x.Name.ToStringOrThrow()), x);
                if (candidates.Count != 0)
                {
                    // accessibility not have to be checked here
                    x.TargetMethod = new AmbiguousMethodSymbol(candidates.AsImmutable(), overloadable: true);
                }
            }

            BindRoutineCall(x);

            return default;
        }

        // helper
        List<MethodSymbol> Construct(List<MethodSymbol> methods, BoundRoutineCall bound)
        {
            if (!bound.TypeArguments.IsDefaultOrEmpty)
            {
                var types = bound.TypeArguments.Select(t => (TypeSymbol)t.Type).AsImmutable();

                for (int i = methods.Count - 1; i >= 0; i--)
                {
                    if (methods[i].Arity == types.Length) // TODO: check the type argument is assignable
                    {
                        methods[i] = methods[i].Construct(types);
                    }
                    else
                    {
                        methods.RemoveAt(i);
                    }
                }
            }

            return methods;
        }

        public override T VisitNew(BoundNewEx x)
        {
            Accept(x.TypeRef);      // resolve target type

            VisitRoutineCall(x);    // analyse arguments

            // resolve .ctor method:
            var type = (NamedTypeSymbol)x.TypeRef.Type;
            if (type.IsValidType())
            {
                var candidates = type.InstanceConstructors.ToList();

                //
                x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.New);
                x.ResultType = type;
            }

            // bind arguments:
            BindRoutineCall(x);

            // resulting type is always known,
            // not null,
            // not ref:
            x.TypeRefMask = x.TypeRef.GetTypeRefMask(TypeCtx).WithoutSubclasses;

            return default;
        }

        public override T VisitInclude(BoundIncludeEx x)
        {
            VisitRoutineCall(x);

            // resolve target script
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 1);
            var targetExpr = x.ArgumentsInSourceOrder[0].Value;

            //
            x.TargetMethod = AnalysisFacts.TryResolveFile(_model, Routine, targetExpr, out var script)
                ? (MethodSymbol)script.MainMethod
                : null;

            // resolve result type
            if (x.Access.IsRead)
            {
                var target = x.TargetMethod;
                if (target != null)
                {
                    x.ResultType = target.ReturnType;
                    x.TypeRefMask = target.GetResultType(TypeCtx);

                    if (x.IsOnceSemantic)
                    {
                        // include_once, require_once returns TRUE in case the script was already included
                        x.TypeRefMask |= TypeCtx.GetBooleanTypeMask();
                    }
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;
                }
            }
            else
            {
                x.TypeRefMask = 0;
            }

            // reset type analysis (include may change local variables)
            State.SetAllUnknown(true);

            return default;
        }

        #endregion

        #region Visit FieldRef

        public override T VisitFieldRef(BoundFieldRef x)
        {
            Accept(x.Instance);
            Accept(x.ContainingType);
            Accept(x.FieldName);

            if (x.IsInstanceField)  // {Instance}->FieldName
            {
                Debug.Assert(x.Instance != null);
                Debug.Assert(x.Instance.Access.IsRead);

                // resolve field if possible
                var resolvedtype = x.Instance.ResultType as NamedTypeSymbol;
                if (resolvedtype == null)
                {
                    var typerefs = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));   // ignore NULL, would cause runtime exception in read access, will be ensured to non-null in write access
                    if (typerefs.IsSingle)
                    {
                        resolvedtype = (NamedTypeSymbol)typerefs.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                }

                if (resolvedtype != null)
                {
                    if (x.FieldName.IsDirect)
                    {
                        var fldname = x.FieldName.NameValue.Value;
                        var member = resolvedtype.ResolveInstanceProperty(fldname);
                        if (member != null && member.IsAccessible(this.TypeCtx.SelfType))
                        {
                            if (member is FieldSymbol)
                            {
                                var field = (FieldSymbol)member;
                                var srcf = field as SourceFieldSymbol;
                                var overridenf = srcf?.OverridenDefinition;

                                // field might be a redefinition with a different accessibility,
                                // such field is not declared actually and the base definition is used instead:

                                if (overridenf == null || overridenf.IsAccessible(this.TypeCtx.SelfType))
                                {
                                    x.BoundReference = new FieldReference(x.Instance, overridenf ?? field);
                                    x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                                    x.ResultType = field.Type;
                                    return default;
                                }
                                else if (srcf?.FieldAccessorProperty != null && srcf.FieldAccessorProperty.IsAccessible(TypeCtx.SelfType))
                                {
                                    member = srcf.FieldAccessorProperty; // use the wrapping property that is accessible from current context
                                    // -> continue
                                }
                                else
                                {
                                    member = null; // -> dynamic behavior
                                    // -> continue
                                }
                            }

                            if (member is PropertySymbol)
                            {
                                var prop = (PropertySymbol)member;
                                x.BoundReference = new PropertyReference(x.Instance, prop);
                                x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type);
                                x.ResultType = prop.Type;
                                return default;
                            }

                            //
                            if (member != null)
                            {
                                throw ExceptionUtilities.UnexpectedValue(member);
                            }
                        }
                        else
                        {
                            // TODO: use runtime fields directly, __get, __set, etc.,
                            // do not fallback to BoundIndirectFieldPlace
                        }
                    }
                }

                // dynamic behavior
                // indirect field access ...

                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectFieldPlace(x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                return default;
            }

            // static fields or constants
            if (x.IsStaticField || x.IsClassConstant)    // {ClassName}::${StaticFieldName}, {ClassName}::{ConstantName}
            {
                var containingType = (NamedTypeSymbol)x.ContainingType.Type;

                if (x.IsClassConstant)
                {
                    Debug.Assert(x.Access.IsRead || x.Access.IsNone);
                    Debug.Assert(!x.Access.IsEnsure && !x.Access.IsWrite && !x.Access.IsReadRef);
                }

                if (containingType.IsValidType() && x.FieldName.IsDirect)
                {
                    var fldname = x.FieldName.NameValue.Value;
                    var field = x.IsStaticField ? containingType.ResolveStaticField(fldname) : containingType.ResolveClassConstant(fldname);
                    if (field != null)
                    {
                        // TODO: visibility -> ErrCode

                        if (BindConstantValue(x, field))
                        {
                            Debug.Assert(x.Access.IsRead && !x.Access.IsWrite && !x.Access.IsEnsure);
                            x.BoundReference = null; // not reachable
                        }
                        else
                        {
                            // real.NET static member (CLR static fields) or
                            // the field may be contained in special __statics container (fields & constants)
                            x.BoundReference = new FieldReference(null, field);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                        }

                        x.ResultType = field.Type;
                        return default;
                    }
                    else if (x.IsStaticField)
                    {
                        // TODO: visibility
                        var prop = containingType.LookupMember<PropertySymbol>(fldname);
                        if (prop != null && prop.IsStatic)
                        {
                            x.BoundReference = new PropertyReference(null, prop);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type).WithIsRef(prop.Type.CanBePhpAlias());
                            return default;
                        }
                    }

                    // TODO: __getStatic, __setStatic
                }

                // indirect field access:
                // indirect field access with known class name:
                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectStFieldPlace((BoundTypeRef)x.ContainingType, x.FieldName, x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
            }

            return default;
        }

        #endregion

        #region Visit ArrayEx, ArrayItemEx, ArrayItemOrdEx

        public override T VisitArray(BoundArrayEx x)
        {
            var items = x.Items;
            TypeRefMask elementType = 0;

            // analyse elements
            foreach (var i in items)
            {
                Debug.Assert(i.Value != null);

                Accept(i.Key);
                Accept(i.Value);

                elementType |= i.Value.TypeRefMask;
            }

            // writeup result type
            x.TypeRefMask = elementType.IsVoid
                ? TypeCtx.GetArrayTypeMask()
                : TypeCtx.GetArrayTypeMask(elementType);

            return default;
        }

        public override T VisitArrayItem(BoundArrayItemEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // TODO: resulting type if possible:
            // var element_type = TypeCtx.GetElementType(x.Array.TypeRefMask); // + handle classes with ArrayAccess and TypeRefMask.Uninitialized

            //

            x.TypeRefMask =
                x.Access.IsReadRef ? TypeRefMask.AnyType.WithRefFlag :
                x.Access.IsEnsure ? TypeRefMask.AnyType : // object|array ?
                TypeRefMask.AnyType.WithRefFlag; // result might be a anything (including a reference?)

            return default;
        }

        public override T VisitArrayItemOrd(BoundArrayItemOrdEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // ord($s[$i]) cannot be used as an l-value
            Debug.Assert(!x.Access.MightChange);

            x.TypeRefMask = TypeCtx.GetLongTypeMask();

            return base.VisitArrayItemOrd(x);
        }

        #endregion

        #region VisitLambda

        public override T VisitLambda(BoundLambda x)
        {
            var container = (ILambdaContainerSymbol)Routine.ContainingFile;
            var symbol = container.ResolveLambdaSymbol((LambdaFunctionExpr)x.PhpSyntax);
            if (symbol == null)
            {
                throw ExceptionUtilities.UnexpectedValue(symbol);
            }

            // lambda uses `static` => we have to know where it is:
            Routine.Flags |= (symbol.Flags & RoutineFlags.UsesLateStatic);

            // bind arguments to parameters
            var ps = symbol.SourceParameters;

            // first {N} source parameters correspond to "use" parameters
            for (int pi = 0; pi < x.UseVars.Length; pi++)
            {
                x.UseVars[pi].Parameter = ps[pi];
                VisitArgument(x.UseVars[pi]);
            }

            //
            x.BoundLambdaMethod = symbol;
            x.ResultType = DeclaringCompilation.CoreTypes.Closure;
            Debug.Assert(x.ResultType != null);
            x.TypeRefMask = TypeCtx.GetTypeMask(new BoundLambdaTypeRef(TypeRefMask.AnyType), false); // specific {Closure}, no null, no subclasses

            return default;
        }

        #endregion

        #region VisitYield

        public override T VisitYieldStatement(BoundYieldStatement x)
        {
            base.VisitYieldStatement(x);

            return default;
        }

        public override T VisitYieldEx(BoundYieldEx x)
        {
            base.VisitYieldEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        public override T VisitYieldFromEx(BoundYieldFromEx x)
        {
            base.VisitYieldFromEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion

        #region Visit

        public override T VisitIsEmpty(BoundIsEmptyEx x)
        {
            Accept(x.Operand);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override T VisitUnset(BoundUnset x)
        {
            base.VisitUnset(x);

            return default;
        }

        public override T VisitList(BoundListEx x)
        {
            var elementtype = this.TypeCtx.GetElementType(x.Access.WriteMask);
            Debug.Assert(!elementtype.IsVoid);

            foreach (var v in x.Items)   // list() may contain NULL implying ignored variable
            {
                if (v.Value != null)
                {
                    Accept(v.Key);
                    Visit(v.Value, v.Value.Access.WithWrite(elementtype));
                }
            }

            return default;
        }

        public override T VisitPseudoConstUse(BoundPseudoConst x)
        {
            object value = null;

            switch (x.ConstType)
            {
                case BoundPseudoConst.Types.Line:
                    value = x.PhpSyntax.ContainingSourceUnit.GetLineFromPosition(x.PhpSyntax.Span.Start) + 1;
                    break;

                case BoundPseudoConst.Types.Class:
                case BoundPseudoConst.Types.Trait:
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        if (containingtype != null)
                        {
                            var intrait = containingtype.MemberAttributes.IsTrait();

                            value = containingtype.QualifiedName.ToString();

                            if (intrait && x.ConstType == BoundPseudoConst.Types.Class)
                            {
                                // __CLASS__ inside trait resolved in runtime
                                x.TypeRefMask = TypeCtx.GetStringTypeMask();
                                return default;
                            }

                            if (!intrait && x.ConstType == BoundPseudoConst.Types.Trait)
                            {
                                // __TRAIT__ inside class is empty string
                                value = string.Empty;
                            }
                        }
                        else
                        {
                            value = string.Empty;
                        }
                    }
                    break;

                case BoundPseudoConst.Types.Method:
                    if (Routine == null)
                    {
                        value = string.Empty;
                    }
                    else if (Routine is SourceLambdaSymbol)
                    {
                        // value = __CLASS__::"{closure}"; // PHP 5
                        value = "{closure}";    // PHP 7+
                    }
                    else
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        value = containingtype != null
                            ? containingtype.QualifiedName.ToString(new Name(Routine.RoutineName), false)
                            : Routine.RoutineName;
                    }
                    break;

                case BoundPseudoConst.Types.Function:
                    if (Routine is SourceLambdaSymbol)
                    {
                        value = "{closure}";
                    }
                    else
                    {
                        value = Routine != null ? Routine.RoutineName : string.Empty;
                    }
                    break;

                case BoundPseudoConst.Types.Namespace:
                    var ns = x.PhpSyntax.ContainingNamespace;
                    value = ns != null && ns.QualifiedName.HasValue
                        ? ns.QualifiedName.QualifiedName.NamespacePhpName
                        : string.Empty;
                    break;

                case BoundPseudoConst.Types.Dir:
                case BoundPseudoConst.Types.File:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                case BoundPseudoConst.Types.RootPath:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            Debug.Assert(value != null);    // pseudoconstant has been set

            x.ConstantValue = new Optional<object>(value);

            if (value is string) x.TypeRefMask = TypeCtx.GetStringTypeMask();
            else if (value is int || value is long) x.TypeRefMask = TypeCtx.GetLongTypeMask();
            else throw ExceptionUtilities.UnexpectedValue(value);

            return default;
        }

        public override T VisitPseudoClassConstUse(BoundPseudoClassConst x)
        {
            base.VisitPseudoClassConstUse(x);

            //
            if (x.ConstType == PseudoClassConstUse.Types.Class)
            {
                x.TypeRefMask = TypeCtx.GetStringTypeMask();

                // resolve the value:

                var type = x.TargetType.Type as TypeSymbol;
                if (type.IsValidType() && type is IPhpTypeSymbol phpt)
                {
                    x.ConstantValue = new Optional<object>(phpt.FullName.ToString());
                }
                else
                {
                    var tref = x.TargetType.PhpSyntax as TypeRef;
                    var qname = tref?.QualifiedName;
                    if (qname.HasValue)
                    {
                        if (!qname.Value.IsReservedClassName) // self, static, parent
                        {
                            x.ConstantValue = new Optional<object>(qname.Value.ToString());
                        }
                    }
                }
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            return default;
        }

        public override T VisitGlobalConstUse(BoundGlobalConst x)
        {
            // TODO: check constant name

            // bind to app-wide constant if possible
            var symbol = (Symbol)_model.ResolveConstant(x.Name.ToString());
            var field = symbol as FieldSymbol;

            if (!BindConstantValue(x, field))
            {
                if (field != null && field.IsStatic)
                {
                    if (field.Type.Is_Func_Context_TResult(out var tresult))
                    {
                        // lazy constant
                        // public static readonly Func<Context, TResult> Constant = (ctx) => VALUE;
                        x._boundExpressionOpt = new InvokeReference(new FieldPlace(null, field));
                        x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, tresult);
                    }
                    else
                    {
                        // constant
                        // public static readonly T Constant = VALUE
                        x._boundExpressionOpt = new FieldReference(null, field);
                        x.TypeRefMask = field.GetResultType(TypeCtx);
                    }
                }
                else if (symbol is PEPropertySymbol prop && prop.IsStatic)
                {
                    // constant
                    // public static T Constant => VALUE;
                    x._boundExpressionOpt = new PropertyReference(null, prop);
                    x.TypeRefMask = prop.GetResultType(TypeCtx);
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;    // only scalars ?
                }
            }

            return default;
        }

        public override T VisitConditional(BoundConditionalEx x)
        {
            BoundExpression positiveExpr;    // positive expression (if evaluated to true, FalseExpr is not evaluated)
            FlowState positiveState; // state after successful positive branch

            if (x.IfTrue != null && x.IfTrue != x.Condition)
            {
                // Template: Condition ? IfTrue : IfFalse

                var originalState = State.Clone();
                positiveExpr = x.IfTrue;

                // true branch:
                if (VisitCondition(x.Condition, ConditionBranch.ToTrue))
                {
                    Accept(x.IfTrue);
                    positiveState = State;

                    // false branch
                    State = originalState.Clone();
                    VisitCondition(x.Condition, ConditionBranch.ToFalse);
                }
                else
                {
                    // OPTIMIZATION: Condition does not have to be visited twice!

                    originalState = State.Clone(); // state after visiting Condition

                    Accept(x.IfTrue);
                    positiveState = State;

                    State = originalState.Clone();
                }
            }
            else
            {
                // Template: Condition ?: IfFalse
                positiveExpr = x.Condition;

                // in case ?: do not evaluate trueExpr twice:
                // Template: Condition ?: FalseExpr

                Accept(x.Condition);
                positiveState = State.Clone();

                // condition != false => condition != null =>
                // ignoring NULL type from Condition:
                x.Condition.TypeRefMask = TypeCtx.WithoutNull(x.Condition.TypeRefMask);
            }

            // and start over with false branch:
            Accept(x.IfFalse);

            // merge both states (after positive evaluation and the false branch)
            State = State.Merge(positiveState);
            x.TypeRefMask = positiveExpr.TypeRefMask | x.IfFalse.TypeRefMask;

            return default;
        }

        public override T VisitExpressionStatement(BoundExpressionStatement x)
        {
            return base.VisitExpressionStatement(x);
        }

        public override T VisitReturn(BoundReturnStatement x)
        {
            if (x.Returned != null)
            {
                Accept(x.Returned);
                State.FlowThroughReturn(x.Returned.TypeRefMask);
            }
            else
            {
                // remember "void" type explicitly
                var voidMask = State.TypeRefContext.GetTypeMask(BoundTypeRefFactory.VoidTypeRef, false); // NOTE: or remember the routine may return Void
                State.FlowThroughReturn(voidMask);
            }

            return default;
        }

        public override T VisitEval(BoundEvalEx x)
        {
            base.VisitEval(x);

            //
            State.SetAllUnknown(true);

            //
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion
    }
}

---- Transformed Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.CodeGen;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Pchp.CodeAnalysis.Symbols;
using Roslyn.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Ast = Devsense.PHP.Syntax.Ast;

namespace Pchp.CodeAnalysis.FlowAnalysis
{
    /// <summary>
    /// Visits single expressions and project transformations to flow state.
    /// </summary>
    internal class ExpressionAnalysis<T> : AnalysisWalker<FlowState, T>
    {
        #region Fields & Properties

        /// <summary>
        /// The worklist to be used to enqueue next blocks.
        /// </summary>
        internal Worklist<BoundBlock> Worklist { get; }

        /// <summary>
        /// Gets model for symbols resolution.
        /// </summary>
        internal ISymbolProvider/*!*/Model => _model;
        readonly ISymbolProvider/*!*/_model;

        /// <summary>
        /// Reference to corresponding source routine.
        /// </summary>
        public SourceRoutineSymbol Routine => State.Routine;

        /// <summary>
        /// Gets current type context for type masks resolving.
        /// </summary>
        internal TypeRefContext TypeCtx => State.TypeRefContext;

        protected PhpCompilation DeclaringCompilation => _model.Compilation;

        protected BoundTypeRefFactory BoundTypeRefFactory => DeclaringCompilation.TypeRefFactory;

        #endregion

        #region Helpers

        /// <summary>
        /// In case given expression is a local or parameter reference,
        /// gets its variable handle within <see cref="State"/>.
        /// </summary>
        VariableHandle TryGetVariableHandle(BoundExpression expr)
        {
            var varname = AsVariableName(expr as BoundReferenceExpression);
            if (varname.IsValid())
            {
                return State.GetLocalHandle(varname);
            }
            else
            {
                return default(VariableHandle);
            }
        }

        /// <summary>
        /// In case of a local variable or parameter, gets its name.
        /// </summary>
        static VariableName AsVariableName(BoundReferenceExpression r)
        {
            if (r is BoundVariableRef vr)
            {
                return vr.Name.NameValue;
            }

            return default;
        }

        static bool IsLongConstant(BoundExpression expr, long value)
        {
            if (expr.ConstantValue.HasValue)
            {
                if (expr.ConstantValue.Value is long) return ((long)expr.ConstantValue.Value) == value;
                if (expr.ConstantValue.Value is int) return ((int)expr.ConstantValue.Value) == value;
            }
            return false;
        }

        static bool TryConvertToNumber(object value, out long l, out double d)
        {
            if (value is int)
            {
                l = (int)value;
                d = (double)l;
                return true;
            }

            if (value is long)
            {
                l = (long)value;
                d = (double)l;
                return true;
            }

            if (value is double)
            {
                d = (double)value;
                l = (long)d;
                return true;
            }

            if (value is bool)
            {
                l = (bool)value ? 1 : 0;
                d = (double)l;
                return true;
            }

            if (value is string s)
            {
                if (long.TryParse(s, out l))
                {
                    d = (double)l;
                    return true;
                }

                if (double.TryParse(s, out d))
                {
                    l = (long)d;
                    return true;
                }
            }

            l = default;
            d = default;
            return false;
        }

        bool BindConstantValue(BoundExpression target, FieldSymbol symbol)
        {
            if (symbol != null && symbol.IsConst)
            {
                var cvalue = symbol.GetConstantValue(false);
                target.ConstantValue = (cvalue != null) ? new Optional<object>(cvalue.Value) : null;

                if (cvalue != null && cvalue.IsNull)
                {
                    target.TypeRefMask = TypeCtx.GetNullTypeMask();
                    return true;
                }

                target.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, symbol.Type, notNull: true);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Finds the root of given chain, i.e.:
        /// $a : $a
        /// $$a : $a
        /// $a->b : $a
        /// $a[..] : $a
        /// $a->foo() : $a
        /// etc.
        /// </summary>
        /// <remarks>If given expression 'isset', its root returned by this method must be set as well.</remarks>
        internal BoundExpression TryGetExpressionChainRoot(BoundExpression x)
        {
            if (x != null)
            {
                if (x is BoundVariableRef v) return v.Name.IsDirect ? v : TryGetExpressionChainRoot(v.Name.NameExpression);
                if (x is BoundFieldRef f) return TryGetExpressionChainRoot(f.Instance ?? (f.ContainingType as BoundIndirectTypeRef)?.TypeExpression);
                if (x is BoundInstanceFunctionCall m) return TryGetExpressionChainRoot(m.Instance);
                if (x is BoundArrayItemEx a) return TryGetExpressionChainRoot(a.Array);
            }

            return null;
        }

        /// <summary>
        /// Gets current visibility scope.
        /// </summary>
        protected OverloadsList.VisibilityScope VisibilityScope => new OverloadsList.VisibilityScope(TypeCtx.SelfType, Routine);

        protected void PingSubscribers(ExitBlock exit)
        {
            if (exit != null)
            {
                var wasNotAnalysed = false;

                if (Routine != null && !Routine.IsReturnAnalysed)
                {
                    Routine.IsReturnAnalysed = true;
                    wasNotAnalysed = true;
                }

                // Ping the subscribers either if the return type has changed or
                // it is the first time the analysis reached the routine exit
                var rtype = State.GetReturnType();
                if (rtype != exit._lastReturnTypeMask || wasNotAnalysed)
                {
                    exit._lastReturnTypeMask = rtype;
                    var subscribers = exit.Subscribers;
                    if (subscribers.Count != 0)
                    {
                        lock (subscribers)
                        {
                            foreach (var subscriber in subscribers)
                            {
                                Worklist.PingReturnUpdate(exit, subscriber);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsDouble(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a double and nothing else.
        /// </summary>
        protected bool IsDoubleOnly(BoundExpression x) => IsDoubleOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(TypeRefMask tmask)
        {
            return tmask.IsSingleType && this.TypeCtx.IsLong(tmask);
        }

        /// <summary>
        /// Gets value indicating the given type represents a long and nothing else.
        /// </summary>
        protected bool IsLongOnly(BoundExpression x) => IsLongOnly(x.TypeRefMask);

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        /// <param name="tmask"></param>
        /// <returns></returns>
        protected bool IsNumberOnly(TypeRefMask tmask)
        {
            if (TypeCtx.IsLong(tmask) || TypeCtx.IsDouble(tmask))
            {
                if (tmask.IsSingleType)
                {
                    return true;
                }

                return !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsNumber();
            }

            return false;
        }

        /// <summary>
        /// Gets value indicating the given type represents only class types.
        /// </summary>
        protected bool IsClassOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsObject();
        }

        /// <summary>
        /// Gets value indicating the given type represents only array types.
        /// </summary>
        protected bool IsArrayOnly(TypeRefMask tmask)
        {
            return !tmask.IsVoid && !tmask.IsAnyType && TypeCtx.GetTypes(tmask).AllIsArray();
        }

        /// <summary>
        /// Gets value indicating the given type is long or double or both but nothing else.
        /// </summary>
        protected bool IsNumberOnly(BoundExpression x) => IsNumberOnly(x.TypeRefMask);

        #endregion

        #region Construction

        /// <summary>
        /// Creates an instance of <see cref="ExpressionAnalysis{T}"/> that can analyse a block.
        /// </summary>
        /// <param name="worklist">The worklist to be used to enqueue next blocks.</param>
        /// <param name="model">The semantic context of the compilation.</param>
        public ExpressionAnalysis(Worklist<BoundBlock> worklist, ISymbolProvider model)
        {
            Debug.Assert(model != null);
            _model = model;
            Worklist = worklist;
        }

        #endregion

        #region State and worklist handling

        protected override bool IsStateInitialized(FlowState state) => state != null;

        protected override bool AreStatesEqual(FlowState a, FlowState b) => a.Equals(b);

        protected override FlowState GetState(BoundBlock block) => block.FlowState;

        protected override void SetState(BoundBlock block, FlowState state) => block.FlowState = state;

        protected override FlowState CloneState(FlowState state) => state.Clone();

        protected override FlowState MergeStates(FlowState a, FlowState b) => a.Merge(b);

        protected override void SetStateUnknown(ref FlowState state) => state.SetAllUnknown(true);

        protected override void EnqueueBlock(BoundBlock block) => Worklist.Enqueue(block);

        #endregion

        #region Visit blocks

        public override T VisitCFGExitBlock(ExitBlock x)
        {
            VisitCFGBlock(x);

            // TODO: EdgeToCallers:
            PingSubscribers(x);

            return default;
        }

        public override T VisitCFGCatchBlock(CatchBlock x)
        {
            VisitCFGBlockInit(x);

            // add catch control variable to the state
            x.TypeRef.Accept(this);

            if (x.Variable != null)
            {
                x.Variable.Access = BoundAccess.Write.WithWrite(x.TypeRef.GetTypeRefMask(TypeCtx));
                State.SetLocalType(State.GetLocalHandle(x.Variable.Name.NameValue), x.Variable.Access.WriteMask);
                Accept(x.Variable);

                //
                x.Variable.ResultType = (TypeSymbol)x.TypeRef.Type;
            }


            //
            DefaultVisitBlock(x);

            return default;
        }

        #endregion

        #region Declaration Statements

        public override T VisitStaticStatement(BoundStaticVariableStatement x)
        {
            var v = x.Declaration;
            var local = State.GetLocalHandle(new VariableName(v.Name));

            State.SetVarKind(local, VariableKind.StaticVariable);

            var oldtype = State.GetLocalType(local).WithRefFlag;

            // set var
            if (v.InitialValue != null)
            {
                // analyse initializer
                Accept(v.InitialValue);

                bool isInt = v.InitialValue.ConstantValue.IsInteger(out long intVal);
                State.SetLessThanLongMax(local, isInt && intVal < long.MaxValue);
                State.SetGreaterThanLongMin(local, isInt && intVal > long.MinValue);

                State.SetLocalType(local, ((IPhpExpression)v.InitialValue).TypeRefMask | oldtype);
            }
            else
            {
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetLocalType(local, TypeCtx.GetNullTypeMask() | oldtype);
                // TODO: explicitly State.SetLocalUninitialized() ?
            }

            return default;
        }

        public override T VisitGlobalStatement(BoundGlobalVariableStatement x)
        {
            base.VisitGlobalStatement(x);   // Accept(x.Variable)

            return default;
        }

        #endregion

        #region Visit Literals

        public override T VisitLiteral(BoundLiteral x)
        {
            x.TypeRefMask = x.ResolveTypeMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit CopyValue

        public override T VisitCopyValue(BoundCopyValue x)
        {
            Accept(x.Expression);

            var tmask = x.Expression.TypeRefMask;

            if (tmask.IsRef)
            {
                // copied value is possible a reference,
                // might be anything:
                tmask = TypeRefMask.AnyType;
            }

            // the result is not a reference for sure:
            Debug.Assert(!tmask.IsRef);

            x.TypeRefMask = tmask;

            return default;
        }

        #endregion

        #region Visit Assignments

        public override T VisitAssign(BoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            //
            Accept(x.Value);

            // keep WriteRef flag
            var targetaccess = BoundAccess.None.WithWrite(x.Value.TypeRefMask);
            if (x.Target.Access.IsWriteRef)
            {
                targetaccess = targetaccess.WithWriteRef(0);
            }

            // new target access with resolved target type
            Visit(x.Target, targetaccess);

            //
            x.TypeRefMask = x.Value.TypeRefMask;

            return default;
        }

        public override T VisitCompoundAssign(BoundCompoundAssignEx x)
        {
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);
            Debug.Assert(x.Value.Access.IsRead);

            // Target X Value
            var tmp = new BoundBinaryEx(x.Target.WithAccess(BoundAccess.Read), x.Value, AstUtils.CompoundOpToBinaryOp(x.Operation));
            Visit(tmp, ConditionBranch.AnyResult);

            // Target =
            Visit(x.Target, BoundAccess.Write.WithWrite(tmp.TypeRefMask));

            // put read access back
            x.Target.Access = x.Target.Access.WithRead();

            //
            x.TypeRefMask = tmp.TypeRefMask;

            return default;
        }

        protected virtual void VisitSuperglobalVariableRef(BoundVariableRef x)
        {
            Debug.Assert(x.Name.IsDirect);
            Debug.Assert(x.Name.NameValue.IsAutoGlobal);

            // remember the initial state of variable at this point
            x.BeforeTypeRef = TypeRefMask.AnyType;

            // bind variable place
            x.Variable = Routine.LocalsTable.BindAutoGlobalVariable(x.Name.NameValue);

            // update state
            if (x.Access.IsRead)
            {
                TypeRefMask vartype;

                if (x.Name.NameValue == VariableName.HttpRawPostDataName)
                {
                    // $HTTP_RAW_POST_DATA : string // TODO: make it mixed or string | binary string
                    vartype = TypeCtx.GetStringTypeMask();
                }
                else
                {
                    // all the other autoglobals are arrays:
                    vartype = TypeCtx.GetArrayTypeMask();
                }

                if (x.Access.IsReadRef)
                {
                    vartype = vartype.WithRefFlag;
                }

                if (x.Access.EnsureObject)
                {
                    // TODO: report ERR
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                x.TypeRefMask = x.Access.WriteMask;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
            }
        }

        protected virtual void VisitLocalVariableRef(BoundVariableRef x, VariableHandle local)
        {
            Debug.Assert(local.IsValid);

            if (Routine == null)
            {
                // invalid use of variable:
                return;
            }

            var previoustype = State.GetLocalType(local);       // type of the variable in the previous state

            // remember the initial state of variable at this point
            x.BeforeTypeRef = previoustype;

            // bind variable place
            if (x.Variable == null)
            {
                x.Variable = x.IsLowerTemp()     // synthesized variable constructed by semantic binder
                    ? Routine.LocalsTable.BindTemporalVariable(local.Name)
                    : Routine.LocalsTable.BindLocalVariable(local.Name, x.PhpSyntax.Span.ToTextSpan());
            }

            //
            State.VisitLocal(local);

            // update state
            if (x.Access.IsRead)
            {
                var vartype = previoustype;

                if (x.Variable is ThisVariableReference)
                {
                    // optimization; we know the exact type here or at least we know it is `Object` (instead of AnyType)
                    // if vartype is resolved to a single instance it was probably done by some operand like 'instanceof' already and better

                    if (vartype.IsSingleType == false || Routine.IsGlobalScope)
                    {
                        vartype = TypeCtx.GetThisTypeMask(); // : System.Object or exact type, with subclasses if applicable
                    }
                }
                else if (vartype.IsVoid || Routine.IsGlobalScope)
                {
                    // in global code or in case of undefined variable,
                    // assume the type is mixed (unspecified).
                    // In global code, the type of variable cannot be determined by type analysis, it can change between every two operations (this may be improved by better flow analysis).
                    vartype = TypeRefMask.AnyType;
                    vartype.IsRef = previoustype.IsRef;

                    if (Routine.IsGlobalScope)
                    {
                        // in global code, treat the variable as initialized always:
                        State.SetVarInitialized(local);
                        vartype.IsRef = true;   // variable might be a reference
                    }
                }
                else
                {
                    //// if there are multiple types possible
                    //// find the common base (this allows for better methods resolution)
                    //if (!vartype.IsAnyType && !vartype.IsRef && vartype.IncludesSubclasses && !vartype.IsSingleType && TypeCtx.IsObject(vartype))
                    //{
                    //    // ...
                    //}
                }

                if (x.Access.IsEnsure)
                {
                    if (x.Access.IsReadRef)
                    {
                        State.MarkLocalByRef(local);
                        vartype.IsRef = true;
                    }
                    if (x.Access.EnsureObject && !TypeCtx.IsObject(vartype))
                    {
                        vartype |= TypeCtx.GetSystemObjectTypeMask();
                    }
                    if (x.Access.EnsureArray)
                    {
                        if (!TypeHelpers.HasArrayAccess(vartype, TypeCtx, DeclaringCompilation))
                        {
                            vartype |= TypeCtx.GetArrayTypeMask();
                        }
                        else if (TypeCtx.IsReadonlyString(vartype))
                        {
                            vartype |= TypeCtx.GetWritableStringTypeMask();
                        }
                    }

                    State.SetLocalType(local, vartype);
                }
                else
                {
                    // reset 'MaybeUninitialized' flag:
                    x.MaybeUninitialized = false;

                    if (!State.IsLocalSet(local))
                    {
                        // do not flag as uninitialized if variable:
                        // - may be a reference
                        // - is in a global scope
                        if (!vartype.IsRef && !Routine.IsGlobalScope)
                        {
                            x.MaybeUninitialized = true;
                        }

                        // variable maybe null if it can be uninitialized
                        vartype |= TypeCtx.GetNullTypeMask();
                    }
                }

                // resulting type of the expression
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsWrite)
            {
                var vartype = x.Access.WriteMask;

                if (x.Access.IsWriteRef || previoustype.IsRef)    // keep the ref flag of local
                {
                    vartype.IsRef = true;
                    State.MarkLocalByRef(local);
                }
                else if (vartype.IsRef)
                {
                    // // we can't be sure about the type
                    vartype = TypeRefMask.AnyType; // anything, not ref
                                                   //vartype.IsRef = false;  // the variable won't be a reference from this point
                }

                //
                State.SetLocalType(local, vartype);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                x.TypeRefMask = vartype;
            }

            if (x.Access.IsUnset)
            {
                x.TypeRefMask = TypeCtx.GetNullTypeMask();
                State.SetLocalType(local, x.TypeRefMask);
                State.SetLessThanLongMax(local, false);
                State.SetGreaterThanLongMin(local, false);
                State.SetVarUninitialized(local);
            }
        }

        public override T VisitVariableRef(BoundVariableRef x)
        {
            if (x.Name.IsDirect)
            {
                // direct variable access:
                if (x.Name.NameValue.IsAutoGlobal)
                {
                    VisitSuperglobalVariableRef(x);
                }
                else
                {
                    VisitLocalVariableRef(x, State.GetLocalHandle(x.Name.NameValue));
                }
            }
            else
            {
                x.BeforeTypeRef = TypeRefMask.AnyType;

                Accept(x.Name.NameExpression);

                // bind variable place
                x.Variable ??= new LocalVariableReference(VariableKind.LocalVariable, Routine, null, x.Name);

                // update state
                if (x.Access.IsRead)
                {
                    State.FlowContext.SetAllUsed();
                    x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                }

                if (x.Access.IsWrite || x.Access.IsEnsure)
                {
                    State.SetAllUnknown(x.Access.IsWriteRef);
                    x.TypeRefMask = x.Access.WriteMask;
                }

                if (x.Access.IsUnset)
                {

                }
            }

            return default;
        }

        public override T VisitIncDec(BoundIncDecEx x)
        {
            // <target> = <target> +/- 1L

            Debug.Assert(x.Access.IsRead || x.Access.IsNone);
            Debug.Assert(x.Target.Access.IsRead && x.Target.Access.IsWrite);

            Visit(x.Target, BoundAccess.Read);
            Visit(x.Value, BoundAccess.Read);

            Debug.Assert(IsNumberOnly(x.Value));    // 1L

            TypeRefMask resulttype;
            TypeRefMask sourcetype = x.Target.TypeRefMask;  // type of target before operation

            VariableHandle lazyVarHandle = default;
            bool lessThanLongMax = false;               // whether the variable's value is less than the max long value
            bool greaterThanLongMin = false;            // or greater than the min long value

            if (IsDoubleOnly(x.Target))
            {
                // double++ => double
                resulttype = TypeCtx.GetDoubleTypeMask();
            }
            else
            {
                // we'd like to keep long if we are sure we don't overflow to double
                lazyVarHandle = TryGetVariableHandle(x.Target);
                if (lazyVarHandle.IsValid && x.IsIncrement && State.IsLessThanLongMax(lazyVarHandle))
                {
                    // long++ [< long.MaxValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    lessThanLongMax = true;
                }
                else if (lazyVarHandle.IsValid && !x.IsIncrement && State.IsGreaterThanLongMin(lazyVarHandle))
                {
                    // long-- [> long.MinValue] => long
                    resulttype = TypeCtx.GetLongTypeMask();
                    greaterThanLongMin = true;
                }
                else
                {
                    // long|double|anything++/-- => number
                    resulttype = TypeCtx.GetNumberTypeMask();
                }
            }

            Visit(x.Target, BoundAccess.Write.WithWrite(resulttype));

            //
            x.Target.Access = x.Target.Access.WithRead();   // put read access back to the target
            x.TypeRefMask = x.IsPostfix ? sourcetype : resulttype;

            // We expect that an incrementation doesn't change the property of being less than the max long value,
            // it needs to be restored due to the write access of the target variable
            if (lessThanLongMax)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetLessThanLongMax(lazyVarHandle, true);
            }

            // The same for the min long value
            if (greaterThanLongMin)
            {
                Debug.Assert(lazyVarHandle.IsValid);
                State.SetGreaterThanLongMin(lazyVarHandle, true);
            }

            return default;
        }

        #endregion

        #region Visit BinaryEx

        private void VisitShortCircuitOp(BoundExpression lExpr, BoundExpression rExpr, bool isAndOp, ConditionBranch branch)
        {
            // Each operand has to be evaluated in various states and then the state merged.
            // Simulates short-circuit evaluation in runtime:

            var state = this.State; // original state

            if (branch == ConditionBranch.AnyResult)
            {
                if (isAndOp)
                {
                    // A == True && B == Any
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == Any
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.AnyResult);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToTrue)
            {
                if (isAndOp)
                {
                    // A == True && B == True

                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                }
                else
                {
                    // A == False && B == True
                    // A == True

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToTrue);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    State = State.Merge(tmp);
                }
            }
            else if (branch == ConditionBranch.ToFalse)
            {
                if (isAndOp)
                {
                    // A == True && B == False
                    // A == False

                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToTrue);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                    var tmp = State;
                    State = state.Clone();
                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    State = State.Merge(tmp);
                }
                else
                {
                    // A == False && B == False

                    VisitCondition(lExpr, ConditionBranch.ToFalse);
                    VisitCondition(rExpr, ConditionBranch.ToFalse);
                }
            }
        }

        /// <summary>
        /// Gets resulting type of bit operation (bit or, and, xor).
        /// </summary>
        TypeRefMask GetBitOperationType(TypeRefMask lValType, TypeRefMask rValType)
        {
            TypeRefMask type;

            // type is string if both operands are string
            if ((lValType.IsAnyType && rValType.IsAnyType) ||
                (TypeCtx.IsAString(lValType) && TypeCtx.IsAString(rValType)))
            {
                type = TypeCtx.GetStringTypeMask();
            }
            else
            {
                type = default(TypeRefMask);
            }

            // type can be always long
            type |= TypeCtx.GetLongTypeMask();

            //
            return type;
        }

        Optional<object> ResolveBooleanOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (xobj.TryConvertToBool(out var bx) && yobj.TryConvertToBool(out var by))
            {
                return op switch
                {
                    Operations.And => (bx && by),
                    Operations.Or => (bx || by),
                    Operations.Xor => (bx ^ by),
                    _ => throw ExceptionUtilities.Unreachable,
                };
            }

            return default;
        }

        /// <summary>
        /// Resolves value of bit operation.
        /// </summary>
        /// <remarks>TODO: move to **evaluation**.</remarks>
        Optional<object> ResolveBitOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            var xconst = xobj.ToConstantValueOrNull();
            var yconst = yobj.ToConstantValueOrNull();

            if (xconst.TryConvertToLong(out long xval) && yconst.TryConvertToLong(out long yval))
            {
                long result;

                switch (op)
                {
                    case Operations.BitOr: result = xval | yval; break;
                    case Operations.BitAnd: result = xval & yval; break;
                    case Operations.BitXor: result = xval ^ yval; break;
                    default:
                        throw new ArgumentException(nameof(op));
                }

                //
                if (result >= int.MinValue && result <= int.MaxValue)
                {
                    return (int)result;
                }
                else
                {
                    return result;
                }

                //
            }

            return default(Optional<object>);
        }

        /// <summary>
        /// Gets resulting type of <c>+</c> operation.
        /// </summary>
        TypeRefMask GetPlusOperationType(BoundExpression left, BoundExpression right)
        {
            var lValType = left.TypeRefMask;
            var rValType = right.TypeRefMask;

            // array + array => array
            // array + number => 0 (ERROR)
            // number + number => number
            // anytype + array => array
            // anytype + number => number

            var or = lValType | rValType;

            if (IsNumberOnly(or))
            {
                // double + number => double
                if (IsDoubleOnly(lValType) || IsDoubleOnly(rValType))
                    return TypeCtx.GetDoubleTypeMask();

                // long + long => long
                if (State.IsLessThanLongMax(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG + 1, where LONG < long.MaxValue
                    return TypeCtx.GetLongTypeMask();

                return TypeCtx.GetNumberTypeMask();
            }

            if ((!lValType.IsRef && !lValType.IsAnyType && !TypeCtx.IsArray(lValType)) ||
                (!rValType.IsRef && !rValType.IsAnyType && !TypeCtx.IsArray(rValType)))
            {
                // not array for sure:
                return TypeCtx.GetNumberTypeMask();
            }

            //
            var type = TypeCtx.GetArraysFromMask(or);

            //
            if (or.IsAnyType || TypeCtx.IsNumber(or) || type == 0) // !this.TypeRefContext.IsArray(lValType & rValType))
                type |= TypeCtx.GetNumberTypeMask();    // anytype or an operand is number or operands are not a number nor both are not array

            if (or.IsAnyType)
                type |= TypeCtx.GetArrayTypeMask();

            //
            return type;
        }

        static Optional<object> ResolvePlusOperation(Optional<object> xobj, Optional<object> yobj)
        {
            if (xobj.HasValue && yobj.HasValue)
            {
                switch (xobj.Value)
                {
                    case double x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return x + y;
                        }
                        break;
                    case long x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y:
                                try { return checked(x + y); }
                                catch (OverflowException) { return (double)x + y; }
                            case int y: return x + y;
                        }
                        break;
                    case int x:
                        switch (yobj.Value)
                        {
                            case double y: return x + y;
                            case long y: return x + y;
                            case int y: return (long)x + y;
                        }
                        break;
                }
            }

            return default;
        }

        static Optional<object> ResolveOperation(Optional<object> xobj, Optional<object> yobj, Operations op)
        {
            if (!xobj.HasValue || !yobj.HasValue)
            {
                return default;
            }

            switch (op)
            {
                case Operations.Add:
                    return ResolvePlusOperation(xobj, yobj);

                case Operations.Mul:
                    switch (xobj.Value)
                    {
                        case double x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y: return x * y;
                                case int y: return x * y;
                            }
                            break;
                        case int x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                        case long x:
                            switch (yobj.Value)
                            {
                                case double y: return x * y;
                                case long y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                                case int y:
                                    try { return checked(x * y); }
                                    catch (OverflowException) { return (double)x * y; }
                            }
                            break;
                    }
                    break;
            }

            return default;
        }

        /// <summary>
        /// Gets resulting type of <c>-</c> operation.
        /// </summary>
        TypeRefMask GetMinusOperationType(BoundExpression left, BoundExpression right)
        {
            if (IsDoubleOnly(left.TypeRefMask) || IsDoubleOnly(right.TypeRefMask)) // some operand is double and nothing else
                return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
            else if (State.IsGreaterThanLongMin(TryGetVariableHandle(left)) && IsLongConstant(right, 1)) // LONG -1, where LONG > long.MinValue
                return TypeCtx.GetLongTypeMask();
            else
                return TypeCtx.GetNumberTypeMask();
        }

        protected override void Visit(BoundBinaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveBinaryEx(x, branch);
        }

        TypeRefMask ResolveBinaryEx(BoundBinaryEx x, ConditionBranch branch)
        {
            if (x.Operation == Operations.And || x.Operation == Operations.Or)
            {
                this.VisitShortCircuitOp(x.Left, x.Right, x.Operation == Operations.And, branch);
            }
            else
            {
                Accept(x.Left);
                Accept(x.Right);
            }

            switch (x.Operation)
            {
                #region Arithmetic Operations

                case Operations.Add:
                    x.ConstantValue = ResolvePlusOperation(x.Left.ConstantValue, x.Right.ConstantValue);
                    return x.ConstantValue.HasValue
                        ? TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue)
                        : GetPlusOperationType(x.Left, x.Right);

                case Operations.Sub:
                    return GetMinusOperationType(x.Left, x.Right);

                case Operations.Div:
                case Operations.Mul:
                case Operations.Pow:

                    x.ConstantValue = ResolveOperation(x.Left.ConstantValue, x.Right.ConstantValue.Value, x.Operation);
                    if (x.ConstantValue.HasValue)
                    {
                        return TypeCtx.GetTypeMaskFromLiteral(x.ConstantValue);
                    }
                    else if (IsDoubleOnly(x.Left.TypeRefMask) || IsDoubleOnly(x.Right.TypeRefMask)) // some operand is double and nothing else
                    {
                        return TypeCtx.GetDoubleTypeMask(); // double if we are sure about operands
                    }
                    else
                    {
                        return TypeCtx.GetNumberTypeMask();
                    }

                case Operations.Mod:
                    return TypeCtx.GetLongTypeMask();

                case Operations.ShiftLeft:
                case Operations.ShiftRight:

                    x.ConstantValue = ResolveShift(x.Operation, x.Left.ConstantValue, x.Right.ConstantValue);
                    return TypeCtx.GetLongTypeMask();

                #endregion

                #region Boolean and Bitwise Operations

                case Operations.And:
                case Operations.Or:
                case Operations.Xor:

                    x.ConstantValue = ResolveBooleanOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return TypeCtx.GetBooleanTypeMask();

                case Operations.BitAnd:
                case Operations.BitOr:
                case Operations.BitXor:

                    x.ConstantValue = ResolveBitOperation(x.Left.ConstantValue, x.Right.ConstantValue, x.Operation);
                    return GetBitOperationType(x.Left.TypeRefMask, x.Right.TypeRefMask);    // int or string

                #endregion

                #region Comparing Operations

                case Operations.Equal:
                case Operations.NotEqual:
                case Operations.Identical:
                case Operations.NotIdentical:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    if (branch != ConditionBranch.AnyResult)
                    {
                        // We must beware not to compute constant value more than once (losing results) -> mark handling of the given expression by this boolean
                        bool handled = false;

                        if (x.Right.ConstantValue.HasValue && x.Left is BoundReferenceExpression boundLeft)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundLeft, x.Right.ConstantValue, branch);
                        }
                        else if (x.Left.ConstantValue.HasValue && x.Right is BoundReferenceExpression boundRight)
                        {
                            handled = ResolveEqualityWithConstantValue(x, boundRight, x.Left.ConstantValue, branch);
                        }

                        if (!handled)
                        {
                            ResolveEquality(x);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                case Operations.GreaterThan:
                case Operations.LessThan:
                case Operations.GreaterThanOrEqual:
                case Operations.LessThanOrEqual:

                    if (x.Left.IsConstant() && x.Right.IsConstant())
                    {
                        x.ConstantValue = ResolveComparison(x.Operation, x.Left.ConstantValue.Value, x.Right.ConstantValue.Value);
                    }

                    // comparison with long value
                    if (branch == ConditionBranch.ToTrue && IsLongOnly(x.Right))
                    {
                        if (x.Operation == Operations.LessThan ||
                            (x.Operation == Operations.LessThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal) && rightVal < long.MaxValue))
                        {
                            // $x < Long.Max
                            State.SetLessThanLongMax(TryGetVariableHandle(x.Left), true);
                        }
                        else if (x.Operation == Operations.GreaterThan ||
                            (x.Operation == Operations.GreaterThanOrEqual && x.Right.ConstantValue.IsInteger(out long rightVal2) && rightVal2 > long.MinValue))
                        {
                            // $x > Long.Min
                            State.SetGreaterThanLongMin(TryGetVariableHandle(x.Left), true);
                        }
                    }

                    return TypeCtx.GetBooleanTypeMask();

                #endregion

                case Operations.Concat:
                    return TypeCtx.GetWritableStringTypeMask();

                case Operations.Coalesce:   // Left ?? Right
                    return x.Left.TypeRefMask | x.Right.TypeRefMask;

                case Operations.Spaceship:
                    return TypeCtx.GetLongTypeMask(); // -1, 0, +1

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.Operation);
            }
        }

        /// <summary>
        /// If possible, resolve the comparison operation in compile-time.
        /// </summary>
        static Optional<object> ResolveComparison(Operations op, object lvalue, object rvalue)
        {
            // TODO

            if (TryConvertToNumber(lvalue, out _, out var dl) && TryConvertToNumber(rvalue, out _, out var dr))
            {
                return op switch
                {
                    Operations.Equal => dl == dr,
                    Operations.GreaterThan => dl > dr,
                    Operations.LessThan => dl < dr,
                    Operations.GreaterThanOrEqual => dl >= dr,
                    Operations.LessThanOrEqual => dl <= dr,
                    _ => default(Optional<object>),
                };
            }

            //
            return default;
        }

        static Optional<object> ResolveShift(Operations op, Optional<object> lvalue, Optional<object> rvalue)
        {
            if (lvalue.TryConvertToLong(out var left) && rvalue.TryConvertToLong(out var right))
            {
                switch (op)
                {
                    case Operations.ShiftLeft:
                        return (left << (int)right).AsOptional();

                    case Operations.ShiftRight:
                        return (left >> (int)right).AsOptional();

                    default:
                        Debug.Fail("unexpected");
                        break;

                }
            }

            return default;
        }

        /// <summary>
        /// Resolves variable types and potentially assigns a constant boolean value to an expression of a comparison of
        /// a variable and a constant - operators ==, !=, === and !==. Returns true iff this expression was handled and there
        /// is no need to analyse it any more (adding constant value etc.).
        /// </summary>
        private bool ResolveEqualityWithConstantValue(
            BoundBinaryEx cmpExpr,
            BoundReferenceExpression refExpr,
            Optional<object> value,
            ConditionBranch branch)
        {
            Debug.Assert(branch != ConditionBranch.AnyResult);

            if (value.IsNull() && refExpr is BoundVariableRef varRef)
            {
                bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);

                // We cannot say much about the type of $x in the true branch of ($x == null) and the false branch of ($x != null),
                // because it holds for false, 0, "", array() etc.
                if (isStrict || branch.TargetValue() != isPositive)
                {
                    AnalysisFacts.HandleTypeCheckingExpression(
                        varRef,
                        TypeCtx.GetNullTypeMask(),
                        branch,
                        State,
                        checkExpr: cmpExpr,
                        isPositiveCheck: isPositive);
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Attempts to infer the result of an equality comparison from the types of the operands.
        /// </summary>
        private void ResolveEquality(BoundBinaryEx cmpExpr)
        {
            Debug.Assert(cmpExpr.Operation >= Operations.Equal && cmpExpr.Operation <= Operations.NotIdentical);

            bool isStrict = (cmpExpr.Operation == Operations.Identical || cmpExpr.Operation == Operations.NotIdentical);

            if (isStrict && !cmpExpr.Left.CanHaveSideEffects() && !cmpExpr.Right.CanHaveSideEffects())
            {
                // Always returns false if checked for strict equality and the operands are of different types (and vice versa for strict non-eq)
                bool isPositive = (cmpExpr.Operation == Operations.Equal || cmpExpr.Operation == Operations.Identical);
                bool canBeSameType = Routine.TypeRefContext.CanBeSameType(cmpExpr.Left.TypeRefMask, cmpExpr.Right.TypeRefMask);
                cmpExpr.ConstantValue = !canBeSameType ? (!isPositive).AsOptional() : default;
            }
        }

        #endregion

        #region Visit UnaryEx

        protected override void Visit(BoundUnaryEx x, ConditionBranch branch)
        {
            x.TypeRefMask = ResolveUnaryOperatorExpression(x, branch);
        }

        TypeRefMask ResolveUnaryOperatorExpression(BoundUnaryEx x, ConditionBranch branch)
        {
            if (branch != ConditionBranch.AnyResult && x.Operation == Operations.LogicNegation)
            {
                // Negation swaps the branches
                VisitCondition(x.Operand, branch.NegativeBranch());
            }
            else
            {
                Accept(x.Operand);
            }

            // clear any previous resolved constant 
            x.ConstantValue = default(Optional<object>);

            //
            switch (x.Operation)
            {
                case Operations.AtSign:
                    return x.Operand.TypeRefMask;

                case Operations.BitNegation:
                    if (x.Operand.ConstantValue.HasValue)
                    {
                        if (x.Operand.ConstantValue.Value is long l)
                        {
                            x.ConstantValue = new Optional<object>(~l);
                        }
                        else if (x.Operand.ConstantValue.Value is int i)
                        {
                            x.ConstantValue = new Optional<object>(~(long)i);
                        }
                    }

                    return TypeCtx.GetLongTypeMask();   // TODO: or byte[]

                case Operations.Clone:
                    // result is always object, not aliased
                    return TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask).IsVoid
                        ? TypeCtx.GetSystemObjectTypeMask()                     // "object"
                        : TypeCtx.GetObjectsFromMask(x.Operand.TypeRefMask);    // (object)T

                case Operations.LogicNegation:
                    {
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(!constBool);
                        }
                        return TypeCtx.GetBooleanTypeMask();
                    }

                case Operations.Minus:
                    var cvalue = ResolveUnaryMinus(x.Operand.ConstantValue.ToConstantValueOrNull());
                    if (cvalue != null)
                    {
                        x.ConstantValue = new Optional<object>(cvalue.Value);
                        return TypeCtx.GetTypeMask(BoundTypeRefFactory.Create(cvalue), false);
                    }
                    else
                    {
                        if (IsDoubleOnly(x.Operand))
                        {
                            return TypeCtx.GetDoubleTypeMask(); // double in case operand is double
                        }
                        return TypeCtx.GetNumberTypeMask();     // TODO: long in case operand is not a number
                    }

                case Operations.UnsetCast:
                    return TypeCtx.GetNullTypeMask();   // null

                case Operations.Plus:
                    if (IsNumberOnly(x.Operand.TypeRefMask))
                        return x.Operand.TypeRefMask;
                    return TypeCtx.GetNumberTypeMask();

                case Operations.Print:
                    return TypeCtx.GetLongTypeMask();

                default:
                    throw ExceptionUtilities.Unreachable;
            }
        }

        ConstantValue ResolveUnaryMinus(ConstantValue value)
        {
            if (value != null)
            {
                switch (value.SpecialType)
                {
                    case SpecialType.System_Double:
                        return ConstantValue.Create(-value.DoubleValue);

                    case SpecialType.System_Int32:
                        return value.Int32Value != int.MinValue
                            ? ConstantValue.Create(-value.Int32Value)   // (- Int32.MinValue) overflows to int64
                            : ConstantValue.Create(-(long)value.Int32Value);

                    case SpecialType.System_Int64:
                        return (value.Int64Value != long.MinValue)  // (- Int64.MinValue) overflows to double
                            ? ConstantValue.Create(-value.Int64Value)
                            : ConstantValue.Create(-(double)value.Int64Value);
                    default:
                        break;
                }
            }

            return null;
        }

        #endregion

        #region Visit Conversion

        public override T VisitConversion(BoundConversionEx x)
        {
            base.VisitConversion(x);

            // evaluate if possible

            if (x.TargetType is BoundPrimitiveTypeRef pt)
            {
                switch (pt.TypeCode)
                {
                    case PhpTypeCode.Boolean:
                        if (x.Operand.ConstantValue.TryConvertToBool(out bool constBool))
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(constBool);
                        }
                        break;

                    case PhpTypeCode.Long:
                        if (x.Operand.ConstantValue.TryConvertToLong(out long l))
                        {
                            x.ConstantValue = new Optional<object>(l);
                        }
                        break;

                    case PhpTypeCode.Double:
                        break;

                    case PhpTypeCode.String:
                    case PhpTypeCode.WritableString:
                        if (x.Operand.ConstantValue.TryConvertToString(out string str))
                        {
                            x.ConstantValue = new Optional<object>(str);
                        }
                        break;

                    case PhpTypeCode.Object:
                        if (IsClassOnly(x.Operand.TypeRefMask))
                        {
                            // it is object already, keep its specific type
                            x.TypeRefMask = x.Operand.TypeRefMask;   // (object)<object>
                            return default;
                        }
                        else if (IsArrayOnly(x.Operand.TypeRefMask))
                        {
                            // array -> object conversion
                            // always stdClass
                            x.TypeRefMask = TypeCtx.GetTypeMask(BoundTypeRefFactory.stdClassTypeRef, false);
                            return default;
                        }
                        break;
                }
            }

            //

            x.TypeRefMask = x.TargetType.GetTypeRefMask(TypeCtx);

            return default;
        }

        #endregion

        #region Visit InstanceOf

        protected override void Visit(BoundInstanceOfEx x, ConditionBranch branch)
        {
            Accept(x.Operand);
            x.AsType.Accept(this);

            // TOOD: x.ConstantValue // in case we know and the operand is a local variable (we can ignore the expression and emit result immediatelly)

            var opTypeMask = x.Operand.TypeRefMask;
            if (x.Operand is BoundLiteral
                || (!opTypeMask.IsAnyType && !opTypeMask.IsRef && !Routine.TypeRefContext.IsObject(opTypeMask)))
            {
                x.ConstantValue = ConstantValueExtensions.AsOptional(false);
            }
            else if (x.Operand is BoundVariableRef vref && vref.Name.IsDirect)
            {
                if (branch == ConditionBranch.ToTrue)
                {
                    // if (Variable is T) => variable is T in True branch state
                    var vartype = x.AsType.GetTypeRefMask(TypeCtx);
                    if (opTypeMask.IsRef) vartype = vartype.WithRefFlag; // keep IsRef flag

                    State.SetLocalType(State.GetLocalHandle(vref.Name.NameValue), vartype);
                }
            }

            //
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        #endregion

        #region Visit IsSet, OffsetExists

        protected override void Visit(BoundIsSetEx x, ConditionBranch branch)
        {
            Accept(x.VarReference);

            // try to get resulting value and type of the variable
            var localname = AsVariableName(x.VarReference);
            if (localname.IsValid())
            {
                var handle = State.GetLocalHandle(localname);
                Debug.Assert(handle.IsValid);

                // Remove any constant value of isset()
                x.ConstantValue = default;

                //
                if (State.IsLocalSet(handle))
                {
                    // If the variable is always defined, isset() behaves like !is_null()
                    var currenttype = State.GetLocalType(handle);

                    // a type in the true branch:
                    var positivetype = TypeCtx.WithoutNull(currenttype);

                    // resolve the constant if possible,
                    // does not depend on the branch
                    if (!currenttype.IsRef && !currenttype.IsAnyType)
                    {
                        if (positivetype.IsVoid)    // always false
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                        }
                        else if (positivetype == currenttype)   // not void nor null
                        {
                            x.ConstantValue = ConstantValueExtensions.AsOptional(true);
                        }
                    }

                    // we can be more specific in true/false branches:
                    if (branch != ConditionBranch.AnyResult && !x.ConstantValue.HasValue)
                    {
                        // update target type in true/false branch:
                        var newtype = (branch == ConditionBranch.ToTrue)
                            ? positivetype
                            : TypeCtx.GetNullTypeMask();

                        // keep the flags
                        newtype |= currenttype.Flags;

                        //
                        State.SetLocalType(handle, newtype);
                    }
                }
                else if (localname.IsAutoGlobal)
                {
                    // nothing
                }
                else
                {
                    // variable is not set for sure
                    // isset : false
                    x.ConstantValue = ConstantValueExtensions.AsOptional(false);
                }

                // mark variable as either initialized or uninintialized in respective branches
                if (branch == ConditionBranch.ToTrue)
                {
                    State.SetVarInitialized(handle);
                }
            }

            // always returns a boolean
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
        }

        public override T VisitOffsetExists(BoundOffsetExists x)
        {
            // receiver[index]
            base.VisitOffsetExists(x);

            // TODO: if receiver is undefined -> result is false

            // always bool
            x.ResultType = DeclaringCompilation.CoreTypes.Boolean;
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();
            return default;
        }

        public override T VisitTryGetItem(BoundTryGetItem x)
        {
            // array, index, fallback
            base.VisitTryGetItem(x);

            // TODO: resulting type if possible (see VisitArrayItem)

            // The result of array[index] might be a reference
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;

            return default;
        }

        #endregion

        #region TypeRef

        internal override T VisitIndirectTypeRef(BoundIndirectTypeRef tref)
        {
            // visit indirect type
            base.VisitIndirectTypeRef(tref);

            //
            return VisitTypeRef(tref);
        }

        internal override T VisitTypeRef(BoundTypeRef tref)
        {
            Debug.Assert(!(tref is BoundMultipleTypeRef));

            // resolve type symbol
            tref.ResolvedType = (TypeSymbol)tref.ResolveTypeSymbol(DeclaringCompilation);

            return default;
        }

        #endregion

        #region Visit Function Call

        protected override T VisitRoutineCall(BoundRoutineCall x)
        {
            x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag; // unknown function might return a reference

            // TODO: write arguments Access
            // TODO: visit invocation member of
            // TODO: 2 pass, analyze arguments -> resolve method -> assign argument to parameter -> write arguments access -> analyze arguments again

            // visit arguments:
            base.VisitRoutineCall(x);

            return default;
        }

        bool BindParams(IList<PhpParam> expectedparams, ImmutableArray<BoundArgument> givenargs)
        {
            for (int i = 0; i < givenargs.Length; i++)
            {
                if (givenargs[i].IsUnpacking)
                {
                    break;
                }

                if (i < expectedparams.Count)
                {
                    var expected = expectedparams[i];
                    if (expected.IsVariadic)
                    {
                        for (;  i < givenargs.Length; i++)
                        {
                            if (givenargs[i].IsUnpacking)
                            {
                                break; // CONSIDER
                            }

                            BindParam(expected, givenargs[i]);
                        }
                    }
                    else
                    {
                        BindParam(expected, givenargs[i]);
                    }
                }
                else
                {
                    // argument cannot be bound
                    return false;
                }
            }

            return true;
        }

        void BindParam(PhpParam expected, BoundArgument givenarg)
        {
            // bind symbol
            givenarg.Parameter = expected.ParameterSymbol;

            // [PhpRwAttribute]
            if (expected.IsPhpRw)
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (TypeCtx.IsArray(expected.Type) && !givenarg.Value.Access.EnsureArray)   // [PhpRw]PhpArray
                    {
                        SemanticsBinder.BindEnsureArrayAccess(givenarg.Value as BoundReferenceExpression);
                        Worklist.Enqueue(CurrentBlock);
                    }
                }
            }

            // bind ref parameters to variables:
            if (expected.IsAlias || expected.IsByRef)  // => args[i] must be a variable
            {
                if (givenarg.Value is BoundReferenceExpression refexpr)
                {
                    if (expected.IsByRef && !refexpr.Access.IsWrite)
                    {
                        SemanticsBinder.BindWriteAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (expected.IsAlias && !refexpr.Access.IsReadRef)
                    {
                        SemanticsBinder.BindReadRefAccess(refexpr);
                        Worklist.Enqueue(CurrentBlock);
                    }

                    if (refexpr is BoundVariableRef refvar)
                    {
                        if (refvar.Name.IsDirect)
                        {
                            var local = State.GetLocalHandle(refvar.Name.NameValue);
                            State.SetLocalType(local, expected.Type);
                            refvar.MaybeUninitialized = false;
                            if (expected.IsAlias)
                            {
                                State.MarkLocalByRef(local);
                            }
                        }
                        else
                        {
                            // TODO: indirect variable -> all may be aliases of any type
                        }
                    }
                    else
                    {
                        // fields, array items, ...
                        // TODO: remember the field will be accessed as reference
                    }
                }
                else
                {
                    // TODO: Err, variable or field must be passed into byref argument. foo("hello") where function foo(&$x){}
                }
            }
            else if (!expected.Type.IsAnyType && givenarg.Value is BoundVariableRef refvar && refvar.Name.IsDirect)
            {
                // Even for variables passed by value we may gain information about their type (if we previously had none),
                // because not complying with the parameter type would have caused throwing a TypeError
                var local = State.GetLocalHandle(refvar.Name.NameValue);
                var localType = State.GetLocalType(local);
                var paramTypeNonNull = TypeCtx.WithoutNull(expected.Type);
                if (localType.IsAnyType && !localType.IsRef &&
                    (TypeCtx.IsObjectOnly(paramTypeNonNull) || TypeCtx.IsArrayOnly(paramTypeNonNull)))    // E.g. support ?MyClass but not callable
                {
                    Debug.Assert(!expected.Type.IsRef);
                    State.SetLocalType(local, expected.Type);
                }
            }
        }

        TypeRefMask BindValidRoutineCall(BoundRoutineCall call, MethodSymbol method, ImmutableArray<BoundArgument> args, bool maybeoverload)
        {
            // analyze TargetMethod with x.Arguments
            // require method result type if access != none
            if (call.Access.IsRead)
            {
                if (Worklist.EnqueueRoutine(method, CurrentBlock, call))
                {
                    // target will be reanalysed
                    // note: continuing current block may be waste of time, but it might gather other called targets

                    // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                    _flags |= AnalysisFlags.IsCanceled;
                }
            }

            if (Routine != null)
            {
                var rflags = method.InvocationFlags(out var localaccess);
                Routine.Flags |= rflags;

                if ((rflags & RoutineFlags.UsesLocals) != 0
                    //&& (x is BoundGlobalFunctionCall gf && gf.Name.NameValue.Name.Value == "extract") // "compact" does not change locals // CONSIDER // TODO
                    )
                {
                    // function may change/add local variables
                    State.SetAllUnknown(true);
                }

                if (localaccess != null)
                {
                    foreach (var lname in localaccess)
                    {
                        // the variable will be used as reference here
                        State.MarkLocalByRef(State.GetLocalHandle(lname));
                    }
                }
            }

            // process arguments
            if (!BindParams(method.GetExpectedArguments(this.TypeCtx), args) && maybeoverload)
            {
                call.TargetMethod = null; // nullify the target method -> call dynamically, arguments cannot be bound at compile time
            }

            //
            return method.GetResultType(TypeCtx);
        }

        /// <summary>
        /// Bind arguments to target method and resolve resulting <see cref="BoundExpression.TypeRefMask"/>.
        /// Expecting <see cref="BoundRoutineCall.TargetMethod"/> is resolved.
        /// If the target method cannot be bound at compile time, <see cref="BoundRoutineCall.TargetMethod"/> is nulled.
        /// </summary>
        void BindRoutineCall(BoundRoutineCall x, bool maybeOverload = false)
        {
            if (MethodSymbolExtensions.IsValidMethod(x.TargetMethod))
            {
                x.TypeRefMask = BindValidRoutineCall(x, x.TargetMethod, x.ArgumentsInSourceOrder, maybeOverload);
            }
            else if (x.TargetMethod is MissingMethodSymbol || x.TargetMethod == null)
            {
                // we don't know anything about the target callsite,
                // locals passed as arguments should be marked as possible refs:
                foreach (var arg in x.ArgumentsInSourceOrder)
                {
                    if (arg.Value is BoundVariableRef bvar && bvar.Name.IsDirect && !arg.IsUnpacking)
                    {
                        State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                    }
                }
            }
            else if (x.TargetMethod is AmbiguousMethodSymbol ambiguity)
            {
                // check if arguments are not passed by bref, mark locals eventually as refs:
                foreach (var m in ambiguity.Ambiguities)
                {
                    var expected = m.GetExpectedArguments(this.TypeCtx);
                    var given = x.ArgumentsInSourceOrder;

                    for (int i = 0; i < given.Length && i < expected.Count; i++)
                    {
                        if (expected[i].IsAlias && given[i].Value is BoundVariableRef bvar && bvar.Name.IsDirect)
                        {
                            State.SetLocalRef(State.GetLocalHandle(bvar.Name.NameValue));
                        }
                    }
                }

                // get the return type from all the ambiguities:
                if (!maybeOverload && x.Access.IsRead)
                {
                    var r = (TypeRefMask)0;
                    foreach (var m in ambiguity.Ambiguities)
                    {
                        if (Worklist.EnqueueRoutine(m, CurrentBlock, x))
                        {
                            // The next blocks will be analysed after this routine is re-enqueued due to the dependency
                            _flags |= AnalysisFlags.IsCanceled;
                        }

                        r |= m.GetResultType(TypeCtx);
                    }

                    x.TypeRefMask = r;
                }
            }

            //

            if (x.Access.IsReadRef)
            {
                // reading by ref:
                x.TypeRefMask = x.TypeRefMask.WithRefFlag;
            }
        }

        public override T VisitExit(BoundExitEx x)
        {
            VisitRoutineCall(x);

            // no parameters binding
            // TODO: handle unpacking
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 0 || !x.ArgumentsInSourceOrder[0].IsUnpacking);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            return default;
        }

        public override T VisitEcho(BoundEcho x)
        {
            VisitRoutineCall(x);

            x.TypeRefMask = 0;  // returns void
            x.ResultType = DeclaringCompilation.GetSpecialType(SpecialType.System_Void);

            //
            return default;
        }

        public override T VisitConcat(BoundConcatEx x)
        {
            VisitRoutineCall(x);

            // if possible, mark the result type as "String",
            // otherwise we have to use "PhpString"
            var args = x.ArgumentsInSourceOrder;
            bool mustBePhpString = false;
            for (int i = 0; i < args.Length; i++)
            {
                var targ = args[i].Value.TypeRefMask;
                mustBePhpString |= targ.IsRef || targ.IsAnyType || this.TypeCtx.IsWritableString(targ) /*|| this.TypeCtx.IsObject(targ) //object are always converted to UTF16 String// */;
            }

            x.TypeRefMask = mustBePhpString ? TypeCtx.GetWritableStringTypeMask() : TypeCtx.GetStringTypeMask();

            return default;
        }

        public override T VisitAssert(BoundAssertEx x)
        {
            VisitRoutineCall(x);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override void VisitGlobalFunctionCall(BoundGlobalFunctionCall x, ConditionBranch branch)
        {
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.Name.NameValue, Routine);
                if (symbol.IsMissingMethod() && x.NameOpt.HasValue)
                {
                    symbol = (MethodSymbol)DeclaringCompilation.ResolveFunction(x.NameOpt.Value, Routine);
                }

                var overloads = symbol is AmbiguousMethodSymbol ambiguous && ambiguous.IsOverloadable
                    ? new OverloadsList(ambiguous.Ambiguities.ToList())
                    : new OverloadsList(symbol ?? new MissingMethodSymbol(x.Name.NameValue.ToString()));

                Debug.Assert(x.TypeArguments.IsDefaultOrEmpty);

                // symbol might be ErrorSymbol

                x.TargetMethod = overloads.Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.StaticCall);
            }

            BindRoutineCall(x);

            // if possible resolve ConstantValue and TypeRefMask:
            AnalysisFacts.HandleSpecialFunctionCall(x, this, branch);
        }

        public override T VisitInstanceFunctionCall(BoundInstanceFunctionCall x)
        {
            Accept(x.Instance);
            Accept(x.Name);

            VisitRoutineCall(x);

            if (x.Name.IsDirect)
            {
                var resolvedtype = x.Instance.ResultType;
                if (resolvedtype == null)
                {
                    var typeref = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));    // ignore NULL, causes runtime exception anyway
                    if (typeref.IsSingle)
                    {
                        resolvedtype = (TypeSymbol)typeref.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                    // else: a common base?
                }

                if (resolvedtype.IsValidType())
                {
                    var candidates = resolvedtype.LookupMethods(x.Name.NameValue.Name.Value);

                    candidates = Construct(candidates, x);

                    x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.InstanceCall);

                    //
                    if (x.TargetMethod.IsValidMethod() && x.TargetMethod.IsStatic && x.Instance.TypeRefMask.IncludesSubclasses)
                    {
                        // static method invoked on an instance object,
                        // must be postponed to runtime since the type may change
                        x.TargetMethod = new AmbiguousMethodSymbol(ImmutableArray.Create(x.TargetMethod), false);
                    }
                }
                else
                {
                    x.TargetMethod = null;
                }
            }

            BindRoutineCall(x, maybeOverload: true);

            return default;
        }

        public override T VisitStaticFunctionCall(BoundStaticFunctionCall x)
        {
            Accept(x.TypeRef);
            Accept(x.Name);

            VisitRoutineCall(x);

            var type = (TypeSymbol)x.TypeRef.Type;

            if (x.Name.NameExpression != null)
            {
                // indirect method call -> not resolvable
            }
            else if (type.IsValidType())
            {
                var candidates = type.LookupMethods(x.Name.ToStringOrThrow());
                // if (candidates.Any(c => c.HasThis)) throw new NotImplementedException("instance method called statically");

                candidates = Construct(candidates, x);

                var flags = OverloadsList.InvocationKindFlags.StaticCall;

                if (Routine != null && !Routine.IsStatic && (x.TypeRef.IsSelf() || x.TypeRef.IsParent()))
                {
                    // self:: or parent:: $this forwarding, prefer both
                    flags |= OverloadsList.InvocationKindFlags.InstanceCall;
                }

                var method = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, flags);

                // method is missing or inaccessible:
                if (method is ErrorMethodSymbol errmethod && (errmethod.ErrorKind == ErrorMethodKind.Inaccessible || errmethod.ErrorKind == ErrorMethodKind.Missing))
                {
                    // NOTE: magic methods __call or __callStatic are called in both cases - the target method is inaccessible or missing

                    var isviable = true; // can we safely resolve the method?
                    List<MethodSymbol> call = null;

                    // __call() might be used, if we have a reference to $this:
                    if (Routine != null && !Routine.IsStatic)
                    {
                        // there is $this variable:
                        if (TypeCtx.ThisType == null || TypeCtx.ThisType.IsOfType(type) || type.IsOfType(TypeCtx.ThisType))
                        {
                            // try to use __call() first:
                            call = type.LookupMethods(Name.SpecialMethodNames.Call.Value);

                            //
                            if (TypeCtx.ThisType == null && call.Count != 0)
                            {
                                // $this is resolved dynamically in runtime and
                                // we don't know if we can use __call() here
                                isviable = false;
                            }
                        }
                    }

                    if (call == null || call.Count == 0)
                    {
                        // __callStatic()
                        call = type.LookupMethods(Name.SpecialMethodNames.CallStatic.Value);
                    }

                    if (call != null && call.Count != 0)
                    {
                        // NOTE: PHP ignores visibility of __callStatic
                        call = Construct(call, x);

                        method = call.Count == 1 && isviable
                            ? new MagicCallMethodSymbol(x.Name.ToStringOrThrow(), call[0])
                            : null; // nullify the symbol so it will be called dynamically and resolved in rutime
                    }
                }

                x.TargetMethod = method;
            }
            else if (x.TypeRef.IsSelf() && Routine != null && Routine.ContainingType.IsTraitType())
            {
                // self:: within trait type
                // resolve possible code path
                // we need this at least to determine possible late static type binding

                var candidates = Construct(Routine.ContainingType.LookupMethods(x.Name.ToStringOrThrow()), x);
                if (candidates.Count != 0)
                {
                    // accessibility not have to be checked here
                    x.TargetMethod = new AmbiguousMethodSymbol(candidates.AsImmutable(), overloadable: true);
                }
            }

            BindRoutineCall(x);

            return default;
        }

        // helper
        List<MethodSymbol> Construct(List<MethodSymbol> methods, BoundRoutineCall bound)
        {
            if (!bound.TypeArguments.IsDefaultOrEmpty)
            {
                var types = bound.TypeArguments.Select(t => (TypeSymbol)t.Type).AsImmutable();

                for (int i = methods.Count - 1; i >= 0; i--)
                {
                    if (methods[i].Arity == types.Length) // TODO: check the type argument is assignable
                    {
                        methods[i] = methods[i].Construct(types);
                    }
                    else
                    {
                        methods.RemoveAt(i);
                    }
                }
            }

            return methods;
        }

        public override T VisitNew(BoundNewEx x)
        {
            Accept(x.TypeRef);      // resolve target type

            VisitRoutineCall(x);    // analyse arguments

            // resolve .ctor method:
            var type = (NamedTypeSymbol)x.TypeRef.Type;
            if (type.IsValidType())
            {
                var candidates = type.InstanceConstructors.ToList();

                //
                x.TargetMethod = new OverloadsList(candidates).Resolve(this.TypeCtx, x.ArgumentsInSourceOrder, VisibilityScope, OverloadsList.InvocationKindFlags.New);
                x.ResultType = type;
            }

            // bind arguments:
            BindRoutineCall(x);

            // resulting type is always known,
            // not null,
            // not ref:
            x.TypeRefMask = x.TypeRef.GetTypeRefMask(TypeCtx).WithoutSubclasses;

            return default;
        }

        public override T VisitInclude(BoundIncludeEx x)
        {
            VisitRoutineCall(x);

            // resolve target script
            Debug.Assert(x.ArgumentsInSourceOrder.Length == 1);
            var targetExpr = x.ArgumentsInSourceOrder[0].Value;

            //
            x.TargetMethod = AnalysisFacts.TryResolveFile(_model, Routine, targetExpr, out var script)
                ? (MethodSymbol)script.MainMethod
                : null;

            // resolve result type
            if (x.Access.IsRead)
            {
                var target = x.TargetMethod;
                if (target != null)
                {
                    x.ResultType = target.ReturnType;
                    x.TypeRefMask = target.GetResultType(TypeCtx);

                    if (x.IsOnceSemantic)
                    {
                        // include_once, require_once returns TRUE in case the script was already included
                        x.TypeRefMask |= TypeCtx.GetBooleanTypeMask();
                    }
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;
                }
            }
            else
            {
                x.TypeRefMask = 0;
            }

            // reset type analysis (include may change local variables)
            State.SetAllUnknown(true);

            return default;
        }

        #endregion

        #region Visit FieldRef

        public override T VisitFieldRef(BoundFieldRef x)
        {
            Accept(x.Instance);
            Accept(x.ContainingType);
            Accept(x.FieldName);

            if (x.IsInstanceField)  // {Instance}->FieldName
            {
                Debug.Assert(x.Instance != null);
                Debug.Assert(x.Instance.Access.IsRead);
                // resolve field if possible
                if (resolvedtype == null)
                {
                    var typerefs = TypeCtx.GetObjectTypes(TypeCtx.WithoutNull(x.Instance.TypeRefMask));   // ignore NULL, would cause runtime exception in read access, will be ensured to non-null in write access
                    if (typerefs.IsSingle)
                    {
                        resolvedtype = (NamedTypeSymbol)typerefs.FirstOrDefault().ResolveTypeSymbol(DeclaringCompilation);
                    }
                }

                if (x.Instance.ResultType is NamedTypeSymbol resolvedtype)
                {
                    if (x.FieldName.IsDirect)
                    {
                        var fldname = x.FieldName.NameValue.Value;
                        var member = resolvedtype.ResolveInstanceProperty(fldname);
                        if (member != null && member.IsAccessible(this.TypeCtx.SelfType))
                        {
                            if (member is FieldSymbol)
                            {
                                var field = (FieldSymbol)member;
                                var srcf = field as SourceFieldSymbol;
                                var overridenf = srcf?.OverridenDefinition;

                                // field might be a redefinition with a different accessibility,
                                // such field is not declared actually and the base definition is used instead:

                                if (overridenf == null || overridenf.IsAccessible(this.TypeCtx.SelfType))
                                {
                                    x.BoundReference = new FieldReference(x.Instance, overridenf ?? field);
                                    x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                                    x.ResultType = field.Type;
                                    return default;
                                }
                                else if (srcf?.FieldAccessorProperty != null && srcf.FieldAccessorProperty.IsAccessible(TypeCtx.SelfType))
                                {
                                    member = srcf.FieldAccessorProperty; // use the wrapping property that is accessible from current context
                                    // -> continue
                                }
                                else
                                {
                                    member = null; // -> dynamic behavior
                                    // -> continue
                                }
                            }

                            if (member is PropertySymbol)
                            {
                                var prop = (PropertySymbol)member;
                                x.BoundReference = new PropertyReference(x.Instance, prop);
                                x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type);
                                x.ResultType = prop.Type;
                                return default;
                            }

                            //
                            if (member != null)
                            {
                                throw ExceptionUtilities.UnexpectedValue(member);
                            }
                        }
                        else
                        {
                            // TODO: use runtime fields directly, __get, __set, etc.,
                            // do not fallback to BoundIndirectFieldPlace
                        }
                    }
                }

                // dynamic behavior
                // indirect field access ...

                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectFieldPlace(x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
                return default;
            }

            // static fields or constants
            if (x.IsStaticField || x.IsClassConstant)    // {ClassName}::${StaticFieldName}, {ClassName}::{ConstantName}
            {
                var containingType = (NamedTypeSymbol)x.ContainingType.Type;

                if (x.IsClassConstant)
                {
                    Debug.Assert(x.Access.IsRead || x.Access.IsNone);
                    Debug.Assert(!x.Access.IsEnsure && !x.Access.IsWrite && !x.Access.IsReadRef);
                }

                if (containingType.IsValidType() && x.FieldName.IsDirect)
                {
                    var fldname = x.FieldName.NameValue.Value;
                    var field = x.IsStaticField ? containingType.ResolveStaticField(fldname) : containingType.ResolveClassConstant(fldname);
                    if (field != null)
                    {
                        // TODO: visibility -> ErrCode

                        if (BindConstantValue(x, field))
                        {
                            Debug.Assert(x.Access.IsRead && !x.Access.IsWrite && !x.Access.IsEnsure);
                            x.BoundReference = null; // not reachable
                        }
                        else
                        {
                            // real.NET static member (CLR static fields) or
                            // the field may be contained in special __statics container (fields & constants)
                            x.BoundReference = new FieldReference(null, field);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, field.Type).WithIsRef(field.Type.CanBePhpAlias());
                        }

                        x.ResultType = field.Type;
                        return default;
                    }
                    else if (x.IsStaticField)
                    {
                        // TODO: visibility
                        var prop = containingType.LookupMember<PropertySymbol>(fldname);
                        if (prop != null && prop.IsStatic)
                        {
                            x.BoundReference = new PropertyReference(null, prop);
                            x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, prop.Type).WithIsRef(prop.Type.CanBePhpAlias());
                            return default;
                        }
                    }

                    // TODO: __getStatic, __setStatic
                }

                // indirect field access:
                // indirect field access with known class name:
                x.BoundReference = new IndirectProperty(x); // ~ dynamic // new BoundIndirectStFieldPlace((BoundTypeRef)x.ContainingType, x.FieldName, x);
                x.TypeRefMask = TypeRefMask.AnyType.WithRefFlag;
            }

            return default;
        }

        #endregion

        #region Visit ArrayEx, ArrayItemEx, ArrayItemOrdEx

        public override T VisitArray(BoundArrayEx x)
        {
            var items = x.Items;
            TypeRefMask elementType = 0;

            // analyse elements
            foreach (var i in items)
            {
                Debug.Assert(i.Value != null);

                Accept(i.Key);
                Accept(i.Value);

                elementType |= i.Value.TypeRefMask;
            }

            // writeup result type
            x.TypeRefMask = elementType.IsVoid
                ? TypeCtx.GetArrayTypeMask()
                : TypeCtx.GetArrayTypeMask(elementType);

            return default;
        }

        public override T VisitArrayItem(BoundArrayItemEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // TODO: resulting type if possible:
            // var element_type = TypeCtx.GetElementType(x.Array.TypeRefMask); // + handle classes with ArrayAccess and TypeRefMask.Uninitialized

            //

            x.TypeRefMask =
                x.Access.IsReadRef ? TypeRefMask.AnyType.WithRefFlag :
                x.Access.IsEnsure ? TypeRefMask.AnyType : // object|array ?
                TypeRefMask.AnyType.WithRefFlag; // result might be a anything (including a reference?)

            return default;
        }

        public override T VisitArrayItemOrd(BoundArrayItemOrdEx x)
        {
            Accept(x.Array);
            Accept(x.Index);

            // ord($s[$i]) cannot be used as an l-value
            Debug.Assert(!x.Access.MightChange);

            x.TypeRefMask = TypeCtx.GetLongTypeMask();

            return base.VisitArrayItemOrd(x);
        }

        #endregion

        #region VisitLambda

        public override T VisitLambda(BoundLambda x)
        {
            var container = (ILambdaContainerSymbol)Routine.ContainingFile;
            var symbol = container.ResolveLambdaSymbol((LambdaFunctionExpr)x.PhpSyntax);
            if (symbol == null)
            {
                throw ExceptionUtilities.UnexpectedValue(symbol);
            }

            // lambda uses `static` => we have to know where it is:
            Routine.Flags |= (symbol.Flags & RoutineFlags.UsesLateStatic);

            // bind arguments to parameters
            var ps = symbol.SourceParameters;

            // first {N} source parameters correspond to "use" parameters
            for (int pi = 0; pi < x.UseVars.Length; pi++)
            {
                x.UseVars[pi].Parameter = ps[pi];
                VisitArgument(x.UseVars[pi]);
            }

            //
            x.BoundLambdaMethod = symbol;
            x.ResultType = DeclaringCompilation.CoreTypes.Closure;
            Debug.Assert(x.ResultType != null);
            x.TypeRefMask = TypeCtx.GetTypeMask(new BoundLambdaTypeRef(TypeRefMask.AnyType), false); // specific {Closure}, no null, no subclasses

            return default;
        }

        #endregion

        #region VisitYield

        public override T VisitYieldStatement(BoundYieldStatement x)
        {
            base.VisitYieldStatement(x);

            return default;
        }

        public override T VisitYieldEx(BoundYieldEx x)
        {
            base.VisitYieldEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        public override T VisitYieldFromEx(BoundYieldFromEx x)
        {
            base.VisitYieldFromEx(x);
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion

        #region Visit

        public override T VisitIsEmpty(BoundIsEmptyEx x)
        {
            Accept(x.Operand);
            x.TypeRefMask = TypeCtx.GetBooleanTypeMask();

            return default;
        }

        public override T VisitUnset(BoundUnset x)
        {
            base.VisitUnset(x);

            return default;
        }

        public override T VisitList(BoundListEx x)
        {
            var elementtype = this.TypeCtx.GetElementType(x.Access.WriteMask);
            Debug.Assert(!elementtype.IsVoid);

            foreach (var v in x.Items)   // list() may contain NULL implying ignored variable
            {
                if (v.Value != null)
                {
                    Accept(v.Key);
                    Visit(v.Value, v.Value.Access.WithWrite(elementtype));
                }
            }

            return default;
        }

        public override T VisitPseudoConstUse(BoundPseudoConst x)
        {
            object value = null;

            switch (x.ConstType)
            {
                case BoundPseudoConst.Types.Line:
                    value = x.PhpSyntax.ContainingSourceUnit.GetLineFromPosition(x.PhpSyntax.Span.Start) + 1;
                    break;

                case BoundPseudoConst.Types.Class:
                case BoundPseudoConst.Types.Trait:
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        if (containingtype != null)
                        {
                            var intrait = containingtype.MemberAttributes.IsTrait();

                            value = containingtype.QualifiedName.ToString();

                            if (intrait && x.ConstType == BoundPseudoConst.Types.Class)
                            {
                                // __CLASS__ inside trait resolved in runtime
                                x.TypeRefMask = TypeCtx.GetStringTypeMask();
                                return default;
                            }

                            if (!intrait && x.ConstType == BoundPseudoConst.Types.Trait)
                            {
                                // __TRAIT__ inside class is empty string
                                value = string.Empty;
                            }
                        }
                        else
                        {
                            value = string.Empty;
                        }
                    }
                    break;

                case BoundPseudoConst.Types.Method:
                    if (Routine == null)
                    {
                        value = string.Empty;
                    }
                    else if (Routine is SourceLambdaSymbol)
                    {
                        // value = __CLASS__::"{closure}"; // PHP 5
                        value = "{closure}";    // PHP 7+
                    }
                    else
                    {
                        var containingtype = x.PhpSyntax.ContainingType;
                        value = containingtype != null
                            ? containingtype.QualifiedName.ToString(new Name(Routine.RoutineName), false)
                            : Routine.RoutineName;
                    }
                    break;

                case BoundPseudoConst.Types.Function:
                    if (Routine is SourceLambdaSymbol)
                    {
                        value = "{closure}";
                    }
                    else
                    {
                        value = Routine != null ? Routine.RoutineName : string.Empty;
                    }
                    break;

                case BoundPseudoConst.Types.Namespace:
                    var ns = x.PhpSyntax.ContainingNamespace;
                    value = ns != null && ns.QualifiedName.HasValue
                        ? ns.QualifiedName.QualifiedName.NamespacePhpName
                        : string.Empty;
                    break;

                case BoundPseudoConst.Types.Dir:
                case BoundPseudoConst.Types.File:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                case BoundPseudoConst.Types.RootPath:
                    x.TypeRefMask = TypeCtx.GetStringTypeMask();
                    return default;

                default:
                    throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            Debug.Assert(value != null);    // pseudoconstant has been set

            x.ConstantValue = new Optional<object>(value);

            if (value is string) x.TypeRefMask = TypeCtx.GetStringTypeMask();
            else if (value is int || value is long) x.TypeRefMask = TypeCtx.GetLongTypeMask();
            else throw ExceptionUtilities.UnexpectedValue(value);

            return default;
        }

        public override T VisitPseudoClassConstUse(BoundPseudoClassConst x)
        {
            base.VisitPseudoClassConstUse(x);

            //
            if (x.ConstType == PseudoClassConstUse.Types.Class)
            {
                x.TypeRefMask = TypeCtx.GetStringTypeMask();

                // resolve the value:

                var type = x.TargetType.Type as TypeSymbol;
                if (type.IsValidType() && type is IPhpTypeSymbol phpt)
                {
                    x.ConstantValue = new Optional<object>(phpt.FullName.ToString());
                }
                else
                {
                    var tref = x.TargetType.PhpSyntax as TypeRef;
                    var qname = tref?.QualifiedName;
                    if (qname.HasValue)
                    {
                        if (!qname.Value.IsReservedClassName) // self, static, parent
                        {
                            x.ConstantValue = new Optional<object>(qname.Value.ToString());
                        }
                    }
                }
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(x.ConstType);
            }

            return default;
        }

        public override T VisitGlobalConstUse(BoundGlobalConst x)
        {
            // TODO: check constant name

            // bind to app-wide constant if possible
            var symbol = (Symbol)_model.ResolveConstant(x.Name.ToString());

            if (!BindConstantValue(x, field))
            {
                if (symbol is FieldSymbol field && field.IsStatic)
                {
                    if (field.Type.Is_Func_Context_TResult(out var tresult))
                    {
                        // lazy constant
                        // public static readonly Func<Context, TResult> Constant = (ctx) => VALUE;
                        x._boundExpressionOpt = new InvokeReference(new FieldPlace(null, field));
                        x.TypeRefMask = TypeRefFactory.CreateMask(TypeCtx, tresult);
                    }
                    else
                    {
                        // constant
                        // public static readonly T Constant = VALUE
                        x._boundExpressionOpt = new FieldReference(null, field);
                        x.TypeRefMask = field.GetResultType(TypeCtx);
                    }
                }
                else if (symbol is PEPropertySymbol prop && prop.IsStatic)
                {
                    // constant
                    // public static T Constant => VALUE;
                    x._boundExpressionOpt = new PropertyReference(null, prop);
                    x.TypeRefMask = prop.GetResultType(TypeCtx);
                }
                else
                {
                    x.TypeRefMask = TypeRefMask.AnyType;    // only scalars ?
                }
            }

            return default;
        }

        public override T VisitConditional(BoundConditionalEx x)
        {
            BoundExpression positiveExpr;    // positive expression (if evaluated to true, FalseExpr is not evaluated)
            FlowState positiveState; // state after successful positive branch

            if (x.IfTrue != null && x.IfTrue != x.Condition)
            {
                // Template: Condition ? IfTrue : IfFalse

                var originalState = State.Clone();
                positiveExpr = x.IfTrue;

                // true branch:
                if (VisitCondition(x.Condition, ConditionBranch.ToTrue))
                {
                    Accept(x.IfTrue);
                    positiveState = State;

                    // false branch
                    State = originalState.Clone();
                    VisitCondition(x.Condition, ConditionBranch.ToFalse);
                }
                else
                {
                    // OPTIMIZATION: Condition does not have to be visited twice!

                    originalState = State.Clone(); // state after visiting Condition

                    Accept(x.IfTrue);
                    positiveState = State;

                    State = originalState.Clone();
                }
            }
            else
            {
                // Template: Condition ?: IfFalse
                positiveExpr = x.Condition;

                // in case ?: do not evaluate trueExpr twice:
                // Template: Condition ?: FalseExpr

                Accept(x.Condition);
                positiveState = State.Clone();

                // condition != false => condition != null =>
                // ignoring NULL type from Condition:
                x.Condition.TypeRefMask = TypeCtx.WithoutNull(x.Condition.TypeRefMask);
            }

            // and start over with false branch:
            Accept(x.IfFalse);

            // merge both states (after positive evaluation and the false branch)
            State = State.Merge(positiveState);
            x.TypeRefMask = positiveExpr.TypeRefMask | x.IfFalse.TypeRefMask;

            return default;
        }

        public override T VisitExpressionStatement(BoundExpressionStatement x)
        {
            return base.VisitExpressionStatement(x);
        }

        public override T VisitReturn(BoundReturnStatement x)
        {
            if (x.Returned != null)
            {
                Accept(x.Returned);
                State.FlowThroughReturn(x.Returned.TypeRefMask);
            }
            else
            {
                // remember "void" type explicitly
                var voidMask = State.TypeRefContext.GetTypeMask(BoundTypeRefFactory.VoidTypeRef, false); // NOTE: or remember the routine may return Void
                State.FlowThroughReturn(voidMask);
            }

            return default;
        }

        public override T VisitEval(BoundEvalEx x)
        {
            base.VisitEval(x);

            //
            State.SetAllUnknown(true);

            //
            x.TypeRefMask = TypeRefMask.AnyType;

            return default;
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(4,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(2324,21): error CS0841: Cannot use local variable 'resolvedtype' before it is declared,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(2329,25): error CS0841: Cannot use local variable 'resolvedtype' before it is declared,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(2761,39): error CS0103: The name 'field' does not exist in the current context,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\ExpressionAnalysis.cs(4,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\Passes\DiagnosticWalker.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Pchp.CodeAnalysis.Errors;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Pchp.CodeAnalysis.Symbols;
using Devsense.PHP.Syntax.Ast;
using Peachpie.CodeAnalysis.Utilities;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Devsense.PHP.Syntax;
using Pchp.CodeAnalysis.Utilities;
using Peachpie.CodeAnalysis.Semantics;

namespace Pchp.CodeAnalysis.FlowAnalysis.Passes
{
    internal partial class DiagnosticWalker<T> : GraphExplorer<T>
    {
        readonly DiagnosticBag _diagnostics;
        readonly SourceRoutineSymbol _routine;

        private bool CallsParentCtor { get; set; }

        PhpCompilation DeclaringCompilation => _routine.DeclaringCompilation;

        TypeRefContext TypeCtx => _routine.TypeRefContext;

        void CheckMissusedPrimitiveType(IBoundTypeRef tref)
        {
            if (tref.IsPrimitiveType)
            {
                // error: use of primitive type {0} is misused // primitive type does not make any sense in this context
                _diagnostics.Add(_routine, tref.PhpSyntax, ErrorCode.ERR_PrimitiveTypeNameMisused, tref);
            }
        }

        void Add(Devsense.PHP.Text.Span span, Devsense.PHP.Errors.ErrorInfo err, params string[] args)
        {
            _diagnostics.Add(DiagnosticBagExtensions.ParserDiagnostic(_routine, span, err, args));
        }

        void CannotInstantiate(IPhpOperation op, string kind, IBoundTypeRef t)
        {
            _diagnostics.Add(_routine, op.PhpSyntax, ErrorCode.ERR_CannotInstantiateType, kind, t.Type);
        }

        public static void Analyse(DiagnosticBag diagnostics, SourceRoutineSymbol routine)
        {
            //
            routine.GetDiagnostics(diagnostics);

            var visitor = new DiagnosticWalker<VoidStruct>(diagnostics, routine);

            //
            if (routine.ControlFlowGraph != null)   // non-abstract method
            {
                visitor.VisitCFG(routine.ControlFlowGraph);
            }

            //
            visitor.CheckParams();
        }

        private DiagnosticWalker(DiagnosticBag diagnostics, SourceRoutineSymbol routine)
        {
            _diagnostics = diagnostics;
            _routine = routine;
        }

        protected override void VisitCFGInternal(ControlFlowGraph x)
        {
            Debug.Assert(x == _routine.ControlFlowGraph);

            base.VisitCFGInternal(x);

            if (CallsParentCtor == false &&
                new Name(_routine.Name).IsConstructName &&
                HasBaseConstruct(_routine.ContainingType))
            {
                // Missing calling parent::__construct
                _diagnostics.Add(_routine, _routine.SyntaxSignature.Span.ToTextSpan(), ErrorCode.WRN_ParentCtorNotCalled, _routine.ContainingType.Name);
            }

            // analyse missing or redefined labels
            CheckLabels(x.Labels);

            // report unreachable blocks
            CheckUnreachableCode(x);
        }

        /// <summary>
        /// Checks the base class has implementation of `__construct` which should be called.
        /// </summary>
        /// <param name="type">Self.</param>
        /// <returns>Whether the base of <paramref name="type"/> has `__construct` method implementation.</returns>
        static bool HasBaseConstruct(NamedTypeSymbol type)
        {
            var btype = type?.BaseType;
            if (btype != null && btype.SpecialType != SpecialType.System_Object && btype.IsClassType() && !btype.IsAbstract)
            {
                var bconstruct = btype.ResolvePhpCtor();    // TODO: recursive: true // needs inf recursion prevention
                if (bconstruct != null && !bconstruct.IsAbstract)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Determines if both identifiers differ only in casing.
        /// </summary>
        static bool IsLetterCasingMismatch(string str1, string str2)
        {
            return str1 != str2 && string.Equals(str1, str2, StringComparison.InvariantCultureIgnoreCase);
        }

        private void CheckParams()
        {
            // Check the compatibility of type hints with PhpDoc, if both exist
            if (_routine.PHPDocBlock != null)
            {
                for (int i = 0; i < _routine.SourceParameters.Length; i++)
                {
                    var param = _routine.SourceParameters[i];

                    //// Consider only parameters passed by value, with both typehints and PHPDoc comments
                    //if (!param.Syntax.IsOut && !param.Syntax.PassedByRef
                    //    && param.Syntax.TypeHint != null
                    //    && param.PHPDocOpt != null && param.PHPDocOpt.TypeNamesArray.Length != 0)
                    //{
                    //    var tmask = PHPDoc.GetTypeMask(TypeCtx, param.PHPDocOpt.TypeNamesArray, _routine.GetNamingContext());
                    //    if (!tmask.IsVoid && !tmask.IsAnyType)
                    //    {
                    //        var hintType = param.Type;
                    //        var docType = DeclaringCompilation.GetTypeFromTypeRef(TypeCtx, tmask);
                    //        if (!docType.IsOfType(hintType))  // REVIEW: not correct, CLR type might result in PhpValue or anything else which is never "of type" specified in PHPDoc
                    //        {
                    //            // PHPDoc type is incompatible with type hint
                    //            _diagnostics.Add(_routine, param.Syntax, ErrorCode.WRN_ParamPhpDocTypeHintIncompatible,
                    //                param.PHPDocOpt.TypeNames, param.Name, param.Syntax.TypeHint);
                    //        }
                    //    }
                    //}
                }
            }

            // check source parameters
            var srcparams = _routine.SourceParameters;
            foreach (var p in srcparams)
            {
                if (!CheckParameterDefaultValue(p))
                {
                    var expectedtype = (p.Syntax.TypeHint is NullableTypeRef nullable ? nullable.TargetType : p.Syntax.TypeHint).ToString(); // do not show "?" in nullable types
                    var valuetype = TypeCtx.ToString(p.Initializer.TypeRefMask);

                    _diagnostics.Add(_routine, p.Syntax.InitValue, ErrorCode.ERR_DefaultParameterValueTypeMismatch, p.Name, expectedtype, valuetype);
                }
            }
        }

        bool CheckParameterDefaultValue(SourceParameterSymbol p)
        {
            var thint = p.Syntax.TypeHint;
            if (thint != null)
            {
                // check type hint and default value
                var defaultvalue = p.Initializer;
                if (defaultvalue != null && !defaultvalue.TypeRefMask.IsAnyType && !defaultvalue.TypeRefMask.IsDefault)
                {
                    var valuetype = defaultvalue.TypeRefMask;

                    if (TypeCtx.IsNull(valuetype))
                    {
                        // allow NULL anytime
                        return true;
                    }

                    if (thint is NullableTypeRef nullable)
                    {
                        // unwrap nullable type hint
                        thint = nullable.TargetType;
                    }

                    if (thint is PrimitiveTypeRef primitive)
                    {
                        switch (primitive.PrimitiveTypeName)
                        {
                            case PrimitiveTypeRef.PrimitiveType.@bool:
                                return TypeCtx.IsBoolean(valuetype);

                            case PrimitiveTypeRef.PrimitiveType.array:
                                return TypeCtx.IsArray(valuetype);

                            case PrimitiveTypeRef.PrimitiveType.@string:
                                return TypeCtx.IsAString(valuetype);

                            case PrimitiveTypeRef.PrimitiveType.@object:
                                return false;

                            case PrimitiveTypeRef.PrimitiveType.@float:
                            case PrimitiveTypeRef.PrimitiveType.@int:
                                return TypeCtx.IsNumber(valuetype);
                        }
                    }
                    else if (thint is ClassTypeRef classtref)
                    {
                        return false; // cannot have default value other than NULL
                    }
                }
            }

            // ok
            return true;
        }

        void CheckLabels(ImmutableArray<ControlFlowGraph.LabelBlockState> labels)
        {
            if (labels == null || labels.Length == 0)
            {
                return;
            }

            for (int i = 0; i < labels.Length; i++)
            {
                var flags = labels[i].Flags;
                if ((flags & ControlFlowGraph.LabelBlockFlags.Defined) == 0)
                {
                    Add(labels[i].LabelSpan, Devsense.PHP.Errors.Errors.UndefinedLabel, labels[i].Label);
                }
                if ((flags & ControlFlowGraph.LabelBlockFlags.Used) == 0)
                {
                    // Warning: label not used
                }
                if ((flags & ControlFlowGraph.LabelBlockFlags.Redefined) != 0)
                {
                    Add(labels[i].LabelSpan, Devsense.PHP.Errors.Errors.LabelRedeclared, labels[i].Label);
                }
            }
        }

        public override T VisitEval(BoundEvalEx x)
        {
            _diagnostics.Add(_routine, new TextSpan(x.PhpSyntax.Span.Start, 4)/*'eval'*/, ErrorCode.INF_EvalDiscouraged);

            return base.VisitEval(x);
        }

        public override T VisitArray(BoundArrayEx x)
        {
            if (x.Access.IsNone)
            {
                // The expression is not being read. Did you mean to assign it somewhere?
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_ExpressionNotRead);
            }

            // Check valid types and uniqueness of the keys
            HashSet<(string, long)> lazyKeyConstSet = null;             // Stores canonic string representations of the keys to check for duplicates
            for (int i = 0; i < x.Items.Length; i++)
            {
                var item = x.Items[i];
                if (item.Key == null)
                    continue;

                var keyTypeMask = item.Key.TypeRefMask;
                if (!keyTypeMask.IsAnyType && !keyTypeMask.IsRef)    // Disallowing 'mixed' for key type would have caused too many false positives
                {
                    var valid = !keyTypeMask.IsVoid;
                    foreach (var t in TypeCtx.GetTypes(keyTypeMask))
                    {
                        valid &= AnalysisFacts.IsValidKeyType(t);
                    }

                    if (!valid)
                    {
                        string keyTypeStr = TypeCtx.ToString(keyTypeMask);
                        _diagnostics.Add(_routine, item.Key.PhpSyntax, ErrorCode.WRN_InvalidArrayKeyType, keyTypeStr);
                    }
                }

                if (AnalysisFacts.TryGetCanonicKeyStringConstant(item.Key.ConstantValue, out var keyConst))
                {
                    if (lazyKeyConstSet == null)
                        lazyKeyConstSet = new HashSet<(string, long)>();

                    if (!lazyKeyConstSet.Add(keyConst))
                    {
                        // Duplicate array key: '{0}'
                        _diagnostics.Add(
                            _routine,
                            item.Key.PhpSyntax ?? item.Value.PhpSyntax,
                            ErrorCode.WRN_DuplicateArrayKey,
                            keyConst.Item1 ?? keyConst.Item2.ToString());
                    }
                }
            }

            return base.VisitArray(x);
        }

        internal override T VisitIndirectTypeRef(BoundIndirectTypeRef x)
        {
            return base.VisitIndirectTypeRef(x);
        }

        internal override T VisitTypeRef(BoundTypeRef typeRef)
        {
            CheckUndefinedType(typeRef);

            // Check that the right case of a class name is used
            if (typeRef.IsObject && typeRef is BoundClassTypeRef ct && ct.Type != null)
            {
                string refName = ct.ClassName.Name.Value;

                if (ct.Type.Kind != SymbolKind.ErrorType)
                {
                    var symbolName = ct.Type.Name;

                    if (IsLetterCasingMismatch(refName, symbolName))
                    {
                        // Wrong class name case
                        _diagnostics.Add(_routine, typeRef.PhpSyntax, ErrorCode.INF_TypeNameCaseMismatch, refName, symbolName);
                    }
                }
            }

            return base.VisitTypeRef(typeRef);
        }

        public override T VisitNew(BoundNewEx x)
        {
            CheckMissusedPrimitiveType(x.TypeRef);

            var type = (TypeSymbol)x.TypeRef.Type;

            if (type.IsValidType())
            {
                if (type.IsInterfaceType())
                {
                    CannotInstantiate(x, "interface", x.TypeRef);
                }
                else if (type.IsStatic)
                {
                    CannotInstantiate(x, "static", x.TypeRef);
                }
                else if (type.IsTraitType())
                {
                    CannotInstantiate(x, "trait", x.TypeRef);
                }
                else // class:
                {
                    // cannot instantiate Closure
                    if (type == DeclaringCompilation.CoreTypes.Closure)
                    {
                        // Instantiation of '{0}' is not allowed
                        Add(x.TypeRef.PhpSyntax.Span, Devsense.PHP.Errors.Errors.ClosureInstantiated, type.Name);
                    }

                    //
                    else if (type.IsAbstract)
                    {
                        // Cannot instantiate abstract class {0}
                        CannotInstantiate(x, "abstract class", x.TypeRef);
                    }
                }
            }

            return base.VisitNew(x);
        }

        public override T VisitReturn(BoundReturnStatement x)
        {
            if (_routine.Syntax is MethodDecl m)
            {
                if (m.Name.Name.IsToStringName)
                {
                    // __tostring() allows only strings to be returned
                    if (x.Returned == null || !IsAllowedToStringReturnType(x.Returned.TypeRefMask))
                    {
                        var span = (x.PhpSyntax != null ? x.PhpSyntax.Span : m.HeadingSpan).ToTextSpan();   // span of return expression OR span of routine header
                        _diagnostics.Add(_routine, span, ErrorCode.WRN_ToStringMustReturnString, _routine.ContainingType.PhpQualifiedName().ToString());
                    }
                }
            }

            if (_routine.SyntaxReturnType != null)
            {
                // "void" return type hint ?
                if (_routine.SyntaxReturnType.IsVoid() && x.Returned != null)
                {
                    // A void function must not return a value
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.ERR_VoidFunctionCannotReturnValue);
                }

                if (x.Returned == null)
                {
                    if (!_routine.SyntaxReturnType.IsVoid())
                    {
                        // CONSIDER: Err or silently return NULL
                    }
                }
                else if (x.Returned.ConstantValue.IsNull() && !_routine.SyntaxReturnType.CanBeNull())
                {
                    // not nullable return type
                    // Cannot convert {0} to {1}
                    _diagnostics.Add(_routine, x.Returned.PhpSyntax, ErrorCode.ERR_TypeMismatch, "NULL", _routine.SyntaxReturnType.ToString());
                }
            }

            //
            return base.VisitReturn(x);
        }

        bool IsAllowedToStringReturnType(TypeRefMask tmask)
        {
            return
                tmask.IsRef ||
                tmask.IsAnyType ||  // dunno
                TypeCtx.IsAString(tmask);

            // anything else (object (even convertible to string), array, number, boolean, ...) is not allowed
        }

        public override T VisitAssign(BoundAssignEx x)
        {
            // Template: <x> = <x>
            if (x.Target is BoundVariableRef lvar && lvar.Variable is LocalVariableReference lloc &&
                x.Value is BoundVariableRef rvar && rvar.Variable is LocalVariableReference rloc &&
                lloc.BoundName == rloc.BoundName && x.PhpSyntax != null)
            {
                // Assignment made to same variable
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_AssigningSameVariable);
            }

            // Following is commented since it does not have any effect on the compiler and the type check also needs to be improved.
            // Currently it is very inaccurate:

            //// Check the type of the value assigned to a field against its PHPDoc
            //var valMask = x.Value.TypeRefMask;
            //if (!valMask.IsAnyType && !valMask.IsRef
            //    && x.Target is BoundFieldRef fr && fr.BoundReference.Symbol is SourceFieldSymbol fieldSymbol
            //    && fieldSymbol.FindPhpDocVarTag() is PHPDocBlock.TypeVarDescTag fieldDoc
            //    && fieldDoc.TypeNamesArray.Length != 0)
            //{
            //    var namingCtx = NameUtils.GetNamingContext(fieldSymbol.PHPDocBlock.ContainingType);
            //    var fieldMask = PHPDoc.GetTypeMask(TypeCtx, fieldDoc.TypeNamesArray, namingCtx);

            //    if (!TypeCtx.CanBeSameType(fieldMask, valMask))
            //    {
            //        // The value can't be of the type specified in PHPDoc
            //        _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_FieldPhpDocAssignIncompatible,
            //            TypeCtx.ToString(valMask), fieldSymbol, fieldDoc.TypeNames);
            //    }
            //}

            //

            return base.VisitAssign(x);
        }

        public override T VisitInclude(BoundIncludeEx x)
        {
            // check arguments
            base.VisitRoutineCall(x);

            // check the target was not resolved
            if (x.TargetMethod == null)
            {
                foreach (var arg in x.ArgumentsInSourceOrder)
                {
                    // in case the include is in form (__DIR__ . LITERAL)
                    // it should get resolved
                    if (arg.Value is BoundConcatEx concat &&
                        concat.ArgumentsInSourceOrder.Length == 2 &&
                        concat.ArgumentsInSourceOrder[0].Value is BoundPseudoConst pc &&
                        pc.ConstType == BoundPseudoConst.Types.Dir &&
                        concat.ArgumentsInSourceOrder[1].Value.ConstantValue.TryConvertToString(out var relativePath) &&
                        relativePath.Length != 0)
                    {
                        // WARNING: Script file '{0}' could not be resolved
                        if (_routine != null)
                        {
                            relativePath = PhpFileUtilities.NormalizeSlashes(_routine.ContainingFile.DirectoryRelativePath + relativePath);

                            if (Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(relativePath[0]))
                            {
                                relativePath = relativePath.Substring(1); // trim leading slash
                            }

                            _diagnostics.Add(_routine, concat.PhpSyntax ?? x.PhpSyntax, ErrorCode.WRN_CannotIncludeFile, relativePath);
                        }
                    }
                }
            }

            //
            return default;
        }

        protected override T VisitRoutineCall(BoundRoutineCall x)
        {
            // check arguments
            base.VisitRoutineCall(x);

            // check method
            if (x.TargetMethod.IsValidMethod())
            {
                var ps = x.TargetMethod.Parameters;

                var skippedps = 0; // number of implicit parameters provided by compiler
                var expectsmin = 0;

                for (int i = 0; i < ps.Length; i++)
                {
                    if (i == skippedps && ps[i].IsImplicitlyDeclared)
                    {
                        // implicitly provided arguments,
                        // ignored
                        skippedps++;
                    }
                    else
                    {
                        var p = ps[i];

                        if (!p.IsPhpOptionalParameter() && (i < ps.Length - 1 /*check for IsParams only for last parameter*/ || !p.IsParams))
                        {
                            expectsmin = i - skippedps + 1;
                        }

                        var arg = x.ArgumentMatchingParameter(p);
                        if (arg != null)
                        {
                            // TODO: check arg.Value.BoundConversion.Exists in general, instead of the following

                            if (arg.Value.ConstantValue.IsNull() && p.HasNotNull)
                            {
                                // Argument {0} passed to {1}() must be of the type {2}, {3} given
                                _diagnostics.Add(_routine, arg.Value.PhpSyntax,
                                    ErrorCode.ERR_ArgumentTypeMismatch,
                                    (i - skippedps + 1).ToString(), x.TargetMethod.RoutineName, GetNameForDiagnostic(p.Type), "NULL");
                            }
                        }
                    }
                }

                var expectsmax = ps.Length != 0 && ps.Last().IsParams
                    ? int.MaxValue
                    : ps.Length - skippedps;

                // check mandatory parameters are provided:
                if (x.ArgumentsInSourceOrder.Length < expectsmin && !x.HasArgumentsUnpacking)
                {
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_MissingArguments, GetMemberNameForDiagnostic(x), expectsmin, x.ArgumentsInSourceOrder.Length);
                }
                else if (x.ArgumentsInSourceOrder.Length > expectsmax)
                {
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_TooManyArguments, GetMemberNameForDiagnostic(x), expectsmax, x.ArgumentsInSourceOrder.Length);
                }
            }

            return default;
        }

        public override T VisitArgument(BoundArgument x)
        {
            base.VisitArgument(x);

            //if (!x.Value.TypeRefMask.IsRef && NOT PASSED BY REF) // if value is referenced, we dunno
            //{
            //    // argument should not be 'void' (NULL in PHP)
            //    if ((x.Type != null && x.Type.SpecialType == SpecialType.System_Void) ||
            //        x.Value.TypeRefMask.IsVoid(TypeCtx))
            //    {
            //        // WRN: Argument has no value, parameter will be always NULL
            //        _diagnostics.Add(_routine, x.Value.PhpSyntax, ErrorCode.WRN_ArgumentVoid);
            //    }
            //}

            //
            return default;
        }

        public override T VisitGlobalFunctionCall(BoundGlobalFunctionCall x)
        {
            CheckUndefinedFunctionCall(x);

            // calling indirectly:
            if (x.Name.IsDirect)
            {
                CheckObsoleteSymbol(x.PhpSyntax, x.TargetMethod, isMemberCall: false);
                CheckGlobalFunctionCall(x);
            }
            else
            {
                Debug.Assert(x.Name.NameExpression != null);
                // check whether expression can be used as a function callback (must be callable - string, array, object ...)
                if (!TypeHelpers.IsCallable(TypeCtx, x.Name.NameExpression.TypeRefMask))
                {
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.ERR_InvalidFunctionName, TypeCtx.ToString(x.Name.NameExpression.TypeRefMask));
                }
            }

            //
            return base.VisitGlobalFunctionCall(x);
        }

        public override T VisitInstanceFunctionCall(BoundInstanceFunctionCall call)
        {
            // TODO: Consider checking if there are enough situations where this makes sense
            //       (it could only work if IncludeSubclasses is false or the class is final)
            //CheckUndefinedMethodCall(call, call.Instance?.ResultType, call.Name);

            // check target type
            CheckMethodCallTargetInstance(call.Instance, call.Name.NameValue.Name.Value);

            // check deprecated
            CheckObsoleteSymbol(call.PhpSyntax, call.TargetMethod, isMemberCall: true);

            //
            return base.VisitInstanceFunctionCall(call);
        }

        public override T VisitFieldRef(BoundFieldRef x)
        {
            if (x.ContainingType != null)
            {
                // class const
                // static field
                CheckMissusedPrimitiveType(x.ContainingType);
            }

            if (x.Access.IsWrite && ((Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation)x).Member is PropertySymbol prop && prop.SetMethod == null)
            {
                // read-only property written
                _diagnostics.Add(_routine, GetMemberNameSpanForDiagnostic(x.PhpSyntax),
                    ErrorCode.ERR_ReadOnlyPropertyWritten,
                    prop.ContainingType.PhpQualifiedName().ToString(),  // TOOD: _statics
                    prop.Name);
            }

            //
            return base.VisitFieldRef(x);
        }

        public override T VisitCFGCatchBlock(CatchBlock x)
        {
            // TODO: x.TypeRefs -> CheckMissusedPrimitiveType

            return base.VisitCFGCatchBlock(x);
        }

        public override T VisitStaticFunctionCall(BoundStaticFunctionCall call)
        {
            CheckMissusedPrimitiveType(call.TypeRef);

            CheckUndefinedMethodCall(call, call.TypeRef.ResolveTypeSymbol(DeclaringCompilation) as TypeSymbol, call.Name);

            // check deprecated
            CheckObsoleteSymbol(call.PhpSyntax, call.TargetMethod, isMemberCall: true);

            // remember there is call to `parent::__construct`
            if (call.TypeRef.IsParent() &&
                call.Name.IsDirect &&
                call.Name.NameValue.Name.IsConstructName)
            {
                CallsParentCtor = true;
            }

            // check the called method is not abstract
            if (call.TargetMethod.IsValidMethod() && call.TargetMethod.IsAbstract)
            {
                // ERR
                Add(call.PhpSyntax.Span, Devsense.PHP.Errors.Errors.AbstractMethodCalled, call.TargetMethod.ContainingType.PhpName(), call.Name.NameValue.Name.Value);
            }

            //
            return base.VisitStaticFunctionCall(call);
        }

        public override T VisitInstanceOf(BoundInstanceOfEx x)
        {
            CheckMissusedPrimitiveType(x.AsType);

            return base.VisitInstanceOf(x);
        }

        public override T VisitVariableRef(BoundVariableRef x)
        {
            CheckUninitializedVariableUse(x);

            return base.VisitVariableRef(x);
        }

        public override T VisitTemporalVariableRef(BoundTemporalVariableRef x)
        {
            // do not make diagnostics on syntesized variables
            return default;
        }

        public override T VisitDeclareStatement(BoundDeclareStatement x)
        {
            _diagnostics.Add(
                _routine,
                ((DeclareStmt)x.PhpSyntax).GetDeclareClauseSpan(),
                ErrorCode.WRN_NotYetImplementedIgnored,
                "Declare construct");

            return base.VisitDeclareStatement(x);
        }

        public override T VisitAssert(BoundAssertEx x)
        {
            base.VisitAssert(x);

            var args = x.ArgumentsInSourceOrder;

            // check number of parameters
            // check whether it is not always false or always true
            if (args.Length >= 1)
            {
                if (args[0].Value.ConstantValue.EqualsOptional(false.AsOptional()))
                {
                    // always failing
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_AssertAlwaysFail);
                }

                if (TypeCtx.IsAString(args[0].Value.TypeRefMask))
                {
                    // deprecated and not supported
                    _diagnostics.Add(_routine, args[0].Value.PhpSyntax, ErrorCode.WRN_StringAssertionDeprecated);
                }

                if (args.Length > 2)
                {
                    // too many args
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_TooManyArguments, "assert", 2, args.Length);
                }
            }
            else
            {
                // assert() expects at least 1 parameter, 0 given
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_MissingArguments, "assert", 1, 0);
            }

            return default;
        }

        public override T VisitUnaryExpression(BoundUnaryEx x)
        {
            base.VisitUnaryExpression(x);

            switch (x.Operation)
            {
                case Operations.Clone:
                    // check we only pass object instances to the "clone" operation
                    // anything else causes a runtime warning!
                    var operandTypeMask = x.Operand.TypeRefMask;
                    if (!operandTypeMask.IsAnyType &&
                        !operandTypeMask.IsRef &&
                        !TypeCtx.IsObjectOnly(operandTypeMask))
                    {
                        _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_CloneNonObject, TypeCtx.ToString(operandTypeMask));
                    }
                    break;
            }

            return default;
        }

        public override T VisitBinaryExpression(BoundBinaryEx x)
        {
            base.VisitBinaryExpression(x);

            //

            switch (x.Operation)
            {
                case Operations.Div:
                    if (x.Right.IsConstant())
                    {
                        if (x.Right.ConstantValue.IsZero())
                        {
                            Add(x.Right.PhpSyntax.Span, Devsense.PHP.Errors.Warnings.DivisionByZero);
                        }
                    }
                    break;
            }

            return default;
        }

        public override T VisitConversion(BoundConversionEx x)
        {
            base.VisitConversion(x);

            if (!x.IsImplicit && x.PhpSyntax != null &&
                x.Operand.TypeRefMask.IsSingleType &&
                x.TargetType == TypeCtx.GetTypes(x.Operand.TypeRefMask).FirstOrDefault())
            {
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.INF_RedundantCast);
            }

            return default;
        }

        void CheckMethodCallTargetInstance(BoundExpression target, string methodName)
        {
            if (target == null)
            {
                // syntax error (?)
                return;
            }

            string nonobjtype = null;

            if (target.ResultType != null)
            {
                switch (target.ResultType.SpecialType)
                {
                    case SpecialType.System_Void:
                    case SpecialType.System_Int32:
                    case SpecialType.System_Int64:
                    case SpecialType.System_String:
                    case SpecialType.System_Boolean:
                        nonobjtype = target.ResultType.GetPhpTypeNameOrNull();
                        break;
                    default:
                        if (target.ResultType == DeclaringCompilation.CoreTypes.PhpString ||
                            target.ResultType == DeclaringCompilation.CoreTypes.PhpArray ||
                            target.ResultType == DeclaringCompilation.CoreTypes.PhpNumber ||
                            target.ResultType == DeclaringCompilation.CoreTypes.PhpResource ||
                            target.ResultType == DeclaringCompilation.CoreTypes.IPhpArray ||
                            target.ResultType == DeclaringCompilation.CoreTypes.IPhpCallable)
                        {
                            nonobjtype = target.ResultType.GetPhpTypeNameOrNull();
                        }
                        break;
                }
            }
            else
            {
                var tmask = target.TypeRefMask;
                if (!tmask.IsAnyType && !tmask.IsRef && !TypeCtx.IsObject(tmask))
                {
                    nonobjtype = TypeCtx.ToString(tmask);
                }
            }

            //
            if (nonobjtype != null)
            {
                _diagnostics.Add(_routine, target.PhpSyntax, ErrorCode.ERR_MethodCalledOnNonObject, methodName ?? "{}", nonobjtype);
            }
        }

        static string GetMemberNameForDiagnostic(BoundRoutineCall x)
        {
            if (x.TargetMethod.IsValidMethod())
            {
                if (x is BoundNewEx)
                {
                    return "new " + x.TargetMethod.ContainingType.PhpName();
                }
                else
                {
                    return GetMemberNameForDiagnostic(x.TargetMethod, x.Instance != null || x is BoundStaticFunctionCall);
                }
            }
            else
            {
                throw ExceptionUtilities.Unreachable;
            }
        }

        static string GetMemberNameForDiagnostic(Symbol target, bool isMemberName = false)
        {
            var name = target.PhpName();

            if (isMemberName)
            {
                var qname = target.ContainingType.PhpQualifiedName();   // TOOD: _statics
                name = qname.ToString(new Name(name), false);
            }

            return name;
        }

        static string GetNameForDiagnostic(TypeSymbol t)
        {
            return t.SpecialType switch
            {
                SpecialType.System_Object => QualifiedName.Object.ToString(),
                SpecialType.System_Double => QualifiedName.Float.ToString(),
                SpecialType.System_Boolean => QualifiedName.Bool.ToString(),
                SpecialType.System_Int32 => QualifiedName.Int.ToString(),
                SpecialType.System_Int64 => QualifiedName.Int.ToString(),
                SpecialType.System_String => QualifiedName.String.ToString(),
                _ => t.PhpName(),
            };
        }

        static TextSpan GetMemberNameSpanForDiagnostic(LangElement node)
        {
            if (node is FunctionCall fnc)
            {
                return fnc.NameSpan.ToTextSpan();
            }
            else
            {
                return node.Span.ToTextSpan();
            }
        }

        void CheckObsoleteSymbol(LangElement syntax, Symbol target, bool isMemberCall)
        {
            var obsolete = target?.ObsoleteAttributeData;
            if (obsolete != null)
            {
                // do not report the deprecation if the containing method itself is deprecated
                if (_routine?.ObsoleteAttributeData != null)
                {
                    return;
                }

                _diagnostics.Add(_routine, GetMemberNameSpanForDiagnostic(syntax), ErrorCode.WRN_SymbolDeprecated, target.Kind.ToString(), GetMemberNameForDiagnostic(target, isMemberCall), obsolete.Message);
            }
        }

        private void CheckUndefinedFunctionCall(BoundGlobalFunctionCall x)
        {
            if (x.Name.IsDirect &&
                x.TargetMethod is ErrorMethodSymbol errmethod && errmethod.ErrorKind == ErrorMethodKind.Missing)
            {
                var originalName = (x.PhpSyntax is DirectFcnCall fnc)
                    ? fnc.FullName.OriginalName
                    : x.Name.NameValue;

                _diagnostics.Add(_routine, GetMemberNameSpanForDiagnostic(x.PhpSyntax), ErrorCode.WRN_UndefinedFunctionCall, originalName.ToString());
            }
        }

        private void CheckUndefinedMethodCall(BoundRoutineCall x, TypeSymbol type, BoundRoutineName name)
        {
            if (x.TargetMethod is MissingMethodSymbol)
            {
                var span = x.PhpSyntax is FunctionCall fnc ? fnc.NameSpan : x.PhpSyntax.Span;
                _diagnostics.Add(_routine, span.ToTextSpan(), ErrorCode.WRN_UndefinedMethodCall, type.Name, name.NameValue.ToString());
            }
        }

        private void CheckUninitializedVariableUse(BoundVariableRef x)
        {
            if (x.MaybeUninitialized && !x.Access.IsQuiet && x.PhpSyntax != null)
            {
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_UninitializedVariableUse, x.Name.NameValue.ToString());
            }
        }

        private void CheckUndefinedType(BoundTypeRef typeRef)
        {
            var type = typeRef.ResolvedType;

            // Ignore indirect types (e.g. $foo = new $className())
            if (type.IsErrorTypeOrNull() && !(typeRef is BoundIndirectTypeRef))
            {
                var errtype = typeRef.ResolvedType as ErrorTypeSymbol;
                if (errtype != null && errtype.CandidateReason == CandidateReason.Ambiguous)
                {
                    // type is declared but ambiguously,
                    // warning with declaration ambiguity was already reported, we may skip following
                    return;
                }

                if (typeRef is BoundReservedTypeRef)
                {
                    // unresolved parent, self ?
                }
                else
                {
                    _diagnostics.Add(_routine, typeRef.PhpSyntax, ErrorCode.WRN_UndefinedType, typeRef.ToString());
                }
            }

            // undefined "parent"
            if (typeRef is BoundReservedTypeRef reservedType && reservedType.ReservedType == ReservedTypeRef.ReservedType.parent && typeRef.PhpSyntax != null)
            {
                var typeCtx = _routine.ContainingType as SourceTypeSymbol;
                if ((typeCtx != null && typeCtx.IsTrait) || _routine.IsGlobalScope)
                {
                    // global code or trait -> resolved at run time
                }
                else if (typeCtx == null || typeCtx.Syntax.BaseClass == null)
                {
                    // in a global function or a class without parent -> error
                    Add(typeRef.PhpSyntax.Span, Devsense.PHP.Errors.FatalErrors.ParentAccessedInParentlessClass);
                }
            }
        }

        public override T VisitCFGTryCatchEdge(TryCatchEdge x)
        {
            return base.VisitCFGTryCatchEdge(x);
        }

        public override T VisitStaticStatement(BoundStaticVariableStatement x)
        {
            return base.VisitStaticStatement(x);
        }

        public override T VisitCFGForeachEnumereeEdge(ForeachEnumereeEdge x)
        {
            base.VisitCFGForeachEnumereeEdge(x);

            var enumereeTypeMask = x.Enumeree.TypeRefMask;
            if (!enumereeTypeMask.IsAnyType && !enumereeTypeMask.IsRef)
            {
                // Apart from array, any object can possibly implement Traversable, hence no warning for them
                var types = TypeCtx.GetTypes(enumereeTypeMask);
                if (!types.Any(t => t.IsArray || t.IsObject))   // Using !All causes too many false positives (due to explode(..) etc.)
                {
                    // Using non-iterable type for enumeree
                    _diagnostics.Add(_routine, x.Enumeree.PhpSyntax, ErrorCode.WRN_ForeachNonIterable, TypeCtx.ToString(enumereeTypeMask));
                }
            }

            return default;
        }
    }
}

---- Transformed Tree ----
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Pchp.CodeAnalysis.Errors;
using Pchp.CodeAnalysis.Semantics;
using Pchp.CodeAnalysis.Semantics.Graph;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Pchp.CodeAnalysis.Symbols;
using Devsense.PHP.Syntax.Ast;
using Peachpie.CodeAnalysis.Utilities;
using Pchp.CodeAnalysis.Semantics.TypeRef;
using Devsense.PHP.Syntax;
using Pchp.CodeAnalysis.Utilities;
using Peachpie.CodeAnalysis.Semantics;

namespace Pchp.CodeAnalysis.FlowAnalysis.Passes
{
    internal partial class DiagnosticWalker<T> : GraphExplorer<T>
    {
        readonly DiagnosticBag _diagnostics;
        readonly SourceRoutineSymbol _routine;

        private bool CallsParentCtor { get; set; }

        PhpCompilation DeclaringCompilation => _routine.DeclaringCompilation;

        TypeRefContext TypeCtx => _routine.TypeRefContext;

        void CheckMissusedPrimitiveType(IBoundTypeRef tref)
        {
            if (tref.IsPrimitiveType)
            {
                // error: use of primitive type {0} is misused // primitive type does not make any sense in this context
                _diagnostics.Add(_routine, tref.PhpSyntax, ErrorCode.ERR_PrimitiveTypeNameMisused, tref);
            }
        }

        void Add(Devsense.PHP.Text.Span span, Devsense.PHP.Errors.ErrorInfo err, params string[] args)
        {
            _diagnostics.Add(DiagnosticBagExtensions.ParserDiagnostic(_routine, span, err, args));
        }

        void CannotInstantiate(IPhpOperation op, string kind, IBoundTypeRef t)
        {
            _diagnostics.Add(_routine, op.PhpSyntax, ErrorCode.ERR_CannotInstantiateType, kind, t.Type);
        }

        public static void Analyse(DiagnosticBag diagnostics, SourceRoutineSymbol routine)
        {
            //
            routine.GetDiagnostics(diagnostics);

            var visitor = new DiagnosticWalker<VoidStruct>(diagnostics, routine);

            //
            if (routine.ControlFlowGraph != null)   // non-abstract method
            {
                visitor.VisitCFG(routine.ControlFlowGraph);
            }

            //
            visitor.CheckParams();
        }

        private DiagnosticWalker(DiagnosticBag diagnostics, SourceRoutineSymbol routine)
        {
            _diagnostics = diagnostics;
            _routine = routine;
        }

        protected override void VisitCFGInternal(ControlFlowGraph x)
        {
            Debug.Assert(x == _routine.ControlFlowGraph);

            base.VisitCFGInternal(x);

            if (CallsParentCtor == false &&
                new Name(_routine.Name).IsConstructName &&
                HasBaseConstruct(_routine.ContainingType))
            {
                // Missing calling parent::__construct
                _diagnostics.Add(_routine, _routine.SyntaxSignature.Span.ToTextSpan(), ErrorCode.WRN_ParentCtorNotCalled, _routine.ContainingType.Name);
            }

            // analyse missing or redefined labels
            CheckLabels(x.Labels);

            // report unreachable blocks
            CheckUnreachableCode(x);
        }

        /// <summary>
        /// Checks the base class has implementation of `__construct` which should be called.
        /// </summary>
        /// <param name="type">Self.</param>
        /// <returns>Whether the base of <paramref name="type"/> has `__construct` method implementation.</returns>
        static bool HasBaseConstruct(NamedTypeSymbol type)
        {
            var btype = type?.BaseType;
            if (btype != null && btype.SpecialType != SpecialType.System_Object && btype.IsClassType() && !btype.IsAbstract)
            {
                var bconstruct = btype.ResolvePhpCtor();    // TODO: recursive: true // needs inf recursion prevention
                if (bconstruct != null && !bconstruct.IsAbstract)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Determines if both identifiers differ only in casing.
        /// </summary>
        static bool IsLetterCasingMismatch(string str1, string str2)
        {
            return str1 != str2 && string.Equals(str1, str2, StringComparison.InvariantCultureIgnoreCase);
        }

        private void CheckParams()
        {
            // Check the compatibility of type hints with PhpDoc, if both exist
            if (_routine.PHPDocBlock != null)
            {
                for (int i = 0; i < _routine.SourceParameters.Length; i++)
                {
                    var param = _routine.SourceParameters[i];

                    //// Consider only parameters passed by value, with both typehints and PHPDoc comments
                    //if (!param.Syntax.IsOut && !param.Syntax.PassedByRef
                    //    && param.Syntax.TypeHint != null
                    //    && param.PHPDocOpt != null && param.PHPDocOpt.TypeNamesArray.Length != 0)
                    //{
                    //    var tmask = PHPDoc.GetTypeMask(TypeCtx, param.PHPDocOpt.TypeNamesArray, _routine.GetNamingContext());
                    //    if (!tmask.IsVoid && !tmask.IsAnyType)
                    //    {
                    //        var hintType = param.Type;
                    //        var docType = DeclaringCompilation.GetTypeFromTypeRef(TypeCtx, tmask);
                    //        if (!docType.IsOfType(hintType))  // REVIEW: not correct, CLR type might result in PhpValue or anything else which is never "of type" specified in PHPDoc
                    //        {
                    //            // PHPDoc type is incompatible with type hint
                    //            _diagnostics.Add(_routine, param.Syntax, ErrorCode.WRN_ParamPhpDocTypeHintIncompatible,
                    //                param.PHPDocOpt.TypeNames, param.Name, param.Syntax.TypeHint);
                    //        }
                    //    }
                    //}
                }
            }

            // check source parameters
            var srcparams = _routine.SourceParameters;
            foreach (var p in srcparams)
            {
                if (!CheckParameterDefaultValue(p))
                {
                    var expectedtype = (p.Syntax.TypeHint is NullableTypeRef nullable ? nullable.TargetType : p.Syntax.TypeHint).ToString(); // do not show "?" in nullable types
                    var valuetype = TypeCtx.ToString(p.Initializer.TypeRefMask);

                    _diagnostics.Add(_routine, p.Syntax.InitValue, ErrorCode.ERR_DefaultParameterValueTypeMismatch, p.Name, expectedtype, valuetype);
                }
            }
        }

        bool CheckParameterDefaultValue(SourceParameterSymbol p)
        {
            var thint = p.Syntax.TypeHint;
            if (thint != null)
            {
                // check type hint and default value
                var defaultvalue = p.Initializer;
                if (defaultvalue != null && !defaultvalue.TypeRefMask.IsAnyType && !defaultvalue.TypeRefMask.IsDefault)
                {
                    var valuetype = defaultvalue.TypeRefMask;

                    if (TypeCtx.IsNull(valuetype))
                    {
                        // allow NULL anytime
                        return true;
                    }

                    if (thint is NullableTypeRef nullable)
                    {
                        // unwrap nullable type hint
                        thint = nullable.TargetType;
                    }

                    if (thint is PrimitiveTypeRef primitive)
                    {
                        switch (primitive.PrimitiveTypeName)
                        {
                            case PrimitiveTypeRef.PrimitiveType.@bool:
                                return TypeCtx.IsBoolean(valuetype);

                            case PrimitiveTypeRef.PrimitiveType.array:
                                return TypeCtx.IsArray(valuetype);

                            case PrimitiveTypeRef.PrimitiveType.@string:
                                return TypeCtx.IsAString(valuetype);

                            case PrimitiveTypeRef.PrimitiveType.@object:
                                return false;

                            case PrimitiveTypeRef.PrimitiveType.@float:
                            case PrimitiveTypeRef.PrimitiveType.@int:
                                return TypeCtx.IsNumber(valuetype);
                        }
                    }
                    else if (thint is ClassTypeRef classtref)
                    {
                        return false; // cannot have default value other than NULL
                    }
                }
            }

            // ok
            return true;
        }

        void CheckLabels(ImmutableArray<ControlFlowGraph.LabelBlockState> labels)
        {
            if (labels == null || labels.Length == 0)
            {
                return;
            }

            for (int i = 0; i < labels.Length; i++)
            {
                var flags = labels[i].Flags;
                if ((flags & ControlFlowGraph.LabelBlockFlags.Defined) == 0)
                {
                    Add(labels[i].LabelSpan, Devsense.PHP.Errors.Errors.UndefinedLabel, labels[i].Label);
                }
                if ((flags & ControlFlowGraph.LabelBlockFlags.Used) == 0)
                {
                    // Warning: label not used
                }
                if ((flags & ControlFlowGraph.LabelBlockFlags.Redefined) != 0)
                {
                    Add(labels[i].LabelSpan, Devsense.PHP.Errors.Errors.LabelRedeclared, labels[i].Label);
                }
            }
        }

        public override T VisitEval(BoundEvalEx x)
        {
            _diagnostics.Add(_routine, new TextSpan(x.PhpSyntax.Span.Start, 4)/*'eval'*/, ErrorCode.INF_EvalDiscouraged);

            return base.VisitEval(x);
        }

        public override T VisitArray(BoundArrayEx x)
        {
            if (x.Access.IsNone)
            {
                // The expression is not being read. Did you mean to assign it somewhere?
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_ExpressionNotRead);
            }

            // Check valid types and uniqueness of the keys
            HashSet<(string, long)> lazyKeyConstSet = null;             // Stores canonic string representations of the keys to check for duplicates
            for (int i = 0; i < x.Items.Length; i++)
            {
                var item = x.Items[i];
                if (item.Key == null)
                    continue;

                var keyTypeMask = item.Key.TypeRefMask;
                if (!keyTypeMask.IsAnyType && !keyTypeMask.IsRef)    // Disallowing 'mixed' for key type would have caused too many false positives
                {
                    var valid = !keyTypeMask.IsVoid;
                    foreach (var t in TypeCtx.GetTypes(keyTypeMask))
                    {
                        valid &= AnalysisFacts.IsValidKeyType(t);
                    }

                    if (!valid)
                    {
                        string keyTypeStr = TypeCtx.ToString(keyTypeMask);
                        _diagnostics.Add(_routine, item.Key.PhpSyntax, ErrorCode.WRN_InvalidArrayKeyType, keyTypeStr);
                    }
                }

                if (AnalysisFacts.TryGetCanonicKeyStringConstant(item.Key.ConstantValue, out var keyConst))
                {
                    if (lazyKeyConstSet == null)
                        lazyKeyConstSet = new HashSet<(string, long)>();

                    if (!lazyKeyConstSet.Add(keyConst))
                    {
                        // Duplicate array key: '{0}'
                        _diagnostics.Add(
                            _routine,
                            item.Key.PhpSyntax ?? item.Value.PhpSyntax,
                            ErrorCode.WRN_DuplicateArrayKey,
                            keyConst.Item1 ?? keyConst.Item2.ToString());
                    }
                }
            }

            return base.VisitArray(x);
        }

        internal override T VisitIndirectTypeRef(BoundIndirectTypeRef x)
        {
            return base.VisitIndirectTypeRef(x);
        }

        internal override T VisitTypeRef(BoundTypeRef typeRef)
        {
            CheckUndefinedType(typeRef);

            // Check that the right case of a class name is used
            if (typeRef.IsObject && typeRef is BoundClassTypeRef ct && ct.Type != null)
            {
                string refName = ct.ClassName.Name.Value;

                if (ct.Type.Kind != SymbolKind.ErrorType)
                {
                    var symbolName = ct.Type.Name;

                    if (IsLetterCasingMismatch(refName, symbolName))
                    {
                        // Wrong class name case
                        _diagnostics.Add(_routine, typeRef.PhpSyntax, ErrorCode.INF_TypeNameCaseMismatch, refName, symbolName);
                    }
                }
            }

            return base.VisitTypeRef(typeRef);
        }

        public override T VisitNew(BoundNewEx x)
        {
            CheckMissusedPrimitiveType(x.TypeRef);

            var type = (TypeSymbol)x.TypeRef.Type;

            if (type.IsValidType())
            {
                if (type.IsInterfaceType())
                {
                    CannotInstantiate(x, "interface", x.TypeRef);
                }
                else if (type.IsStatic)
                {
                    CannotInstantiate(x, "static", x.TypeRef);
                }
                else if (type.IsTraitType())
                {
                    CannotInstantiate(x, "trait", x.TypeRef);
                }
                else // class:
                {
                    // cannot instantiate Closure
                    if (type == DeclaringCompilation.CoreTypes.Closure)
                    {
                        // Instantiation of '{0}' is not allowed
                        Add(x.TypeRef.PhpSyntax.Span, Devsense.PHP.Errors.Errors.ClosureInstantiated, type.Name);
                    }

                    //
                    else if (type.IsAbstract)
                    {
                        // Cannot instantiate abstract class {0}
                        CannotInstantiate(x, "abstract class", x.TypeRef);
                    }
                }
            }

            return base.VisitNew(x);
        }

        public override T VisitReturn(BoundReturnStatement x)
        {
            if (_routine.Syntax is MethodDecl m)
            {
                if (m.Name.Name.IsToStringName)
                {
                    // __tostring() allows only strings to be returned
                    if (x.Returned == null || !IsAllowedToStringReturnType(x.Returned.TypeRefMask))
                    {
                        var span = (x.PhpSyntax != null ? x.PhpSyntax.Span : m.HeadingSpan).ToTextSpan();   // span of return expression OR span of routine header
                        _diagnostics.Add(_routine, span, ErrorCode.WRN_ToStringMustReturnString, _routine.ContainingType.PhpQualifiedName().ToString());
                    }
                }
            }

            if (_routine.SyntaxReturnType != null)
            {
                // "void" return type hint ?
                if (_routine.SyntaxReturnType.IsVoid() && x.Returned != null)
                {
                    // A void function must not return a value
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.ERR_VoidFunctionCannotReturnValue);
                }

                if (x.Returned == null)
                {
                    if (!_routine.SyntaxReturnType.IsVoid())
                    {
                        // CONSIDER: Err or silently return NULL
                    }
                }
                else if (x.Returned.ConstantValue.IsNull() && !_routine.SyntaxReturnType.CanBeNull())
                {
                    // not nullable return type
                    // Cannot convert {0} to {1}
                    _diagnostics.Add(_routine, x.Returned.PhpSyntax, ErrorCode.ERR_TypeMismatch, "NULL", _routine.SyntaxReturnType.ToString());
                }
            }

            //
            return base.VisitReturn(x);
        }

        bool IsAllowedToStringReturnType(TypeRefMask tmask)
        {
            return
                tmask.IsRef ||
                tmask.IsAnyType ||  // dunno
                TypeCtx.IsAString(tmask);

            // anything else (object (even convertible to string), array, number, boolean, ...) is not allowed
        }

        public override T VisitAssign(BoundAssignEx x)
        {
            // Template: <x> = <x>
            if (x.Target is BoundVariableRef lvar && lvar.Variable is LocalVariableReference lloc &&
                x.Value is BoundVariableRef rvar && rvar.Variable is LocalVariableReference rloc &&
                lloc.BoundName == rloc.BoundName && x.PhpSyntax != null)
            {
                // Assignment made to same variable
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_AssigningSameVariable);
            }

            // Following is commented since it does not have any effect on the compiler and the type check also needs to be improved.
            // Currently it is very inaccurate:

            //// Check the type of the value assigned to a field against its PHPDoc
            //var valMask = x.Value.TypeRefMask;
            //if (!valMask.IsAnyType && !valMask.IsRef
            //    && x.Target is BoundFieldRef fr && fr.BoundReference.Symbol is SourceFieldSymbol fieldSymbol
            //    && fieldSymbol.FindPhpDocVarTag() is PHPDocBlock.TypeVarDescTag fieldDoc
            //    && fieldDoc.TypeNamesArray.Length != 0)
            //{
            //    var namingCtx = NameUtils.GetNamingContext(fieldSymbol.PHPDocBlock.ContainingType);
            //    var fieldMask = PHPDoc.GetTypeMask(TypeCtx, fieldDoc.TypeNamesArray, namingCtx);

            //    if (!TypeCtx.CanBeSameType(fieldMask, valMask))
            //    {
            //        // The value can't be of the type specified in PHPDoc
            //        _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_FieldPhpDocAssignIncompatible,
            //            TypeCtx.ToString(valMask), fieldSymbol, fieldDoc.TypeNames);
            //    }
            //}

            //

            return base.VisitAssign(x);
        }

        public override T VisitInclude(BoundIncludeEx x)
        {
            // check arguments
            base.VisitRoutineCall(x);

            // check the target was not resolved
            if (x.TargetMethod == null)
            {
                foreach (var arg in x.ArgumentsInSourceOrder)
                {
                    // in case the include is in form (__DIR__ . LITERAL)
                    // it should get resolved
                    if (arg.Value is BoundConcatEx concat &&
                        concat.ArgumentsInSourceOrder.Length == 2 &&
                        concat.ArgumentsInSourceOrder[0].Value is BoundPseudoConst pc &&
                        pc.ConstType == BoundPseudoConst.Types.Dir &&
                        concat.ArgumentsInSourceOrder[1].Value.ConstantValue.TryConvertToString(out var relativePath) &&
                        relativePath.Length != 0)
                    {
                        // WARNING: Script file '{0}' could not be resolved
                        if (_routine != null)
                        {
                            relativePath = PhpFileUtilities.NormalizeSlashes(_routine.ContainingFile.DirectoryRelativePath + relativePath);

                            if (Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(relativePath[0]))
                            {
                                relativePath = relativePath.Substring(1); // trim leading slash
                            }

                            _diagnostics.Add(_routine, concat.PhpSyntax ?? x.PhpSyntax, ErrorCode.WRN_CannotIncludeFile, relativePath);
                        }
                    }
                }
            }

            //
            return default;
        }

        protected override T VisitRoutineCall(BoundRoutineCall x)
        {
            // check arguments
            base.VisitRoutineCall(x);

            // check method
            if (x.TargetMethod.IsValidMethod())
            {
                var ps = x.TargetMethod.Parameters;

                var skippedps = 0; // number of implicit parameters provided by compiler
                var expectsmin = 0;

                for (int i = 0; i < ps.Length; i++)
                {
                    if (i == skippedps && ps[i].IsImplicitlyDeclared)
                    {
                        // implicitly provided arguments,
                        // ignored
                        skippedps++;
                    }
                    else
                    {
                        var p = ps[i];

                        if (!p.IsPhpOptionalParameter() && (i < ps.Length - 1 /*check for IsParams only for last parameter*/ || !p.IsParams))
                        {
                            expectsmin = i - skippedps + 1;
                        }

                        var arg = x.ArgumentMatchingParameter(p);
                        if (arg != null)
                        {
                            // TODO: check arg.Value.BoundConversion.Exists in general, instead of the following

                            if (arg.Value.ConstantValue.IsNull() && p.HasNotNull)
                            {
                                // Argument {0} passed to {1}() must be of the type {2}, {3} given
                                _diagnostics.Add(_routine, arg.Value.PhpSyntax,
                                    ErrorCode.ERR_ArgumentTypeMismatch,
                                    (i - skippedps + 1).ToString(), x.TargetMethod.RoutineName, GetNameForDiagnostic(p.Type), "NULL");
                            }
                        }
                    }
                }

                var expectsmax = ps.Length != 0 && ps.Last().IsParams
                    ? int.MaxValue
                    : ps.Length - skippedps;

                // check mandatory parameters are provided:
                if (x.ArgumentsInSourceOrder.Length < expectsmin && !x.HasArgumentsUnpacking)
                {
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_MissingArguments, GetMemberNameForDiagnostic(x), expectsmin, x.ArgumentsInSourceOrder.Length);
                }
                else if (x.ArgumentsInSourceOrder.Length > expectsmax)
                {
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_TooManyArguments, GetMemberNameForDiagnostic(x), expectsmax, x.ArgumentsInSourceOrder.Length);
                }
            }

            return default;
        }

        public override T VisitArgument(BoundArgument x)
        {
            base.VisitArgument(x);

            //if (!x.Value.TypeRefMask.IsRef && NOT PASSED BY REF) // if value is referenced, we dunno
            //{
            //    // argument should not be 'void' (NULL in PHP)
            //    if ((x.Type != null && x.Type.SpecialType == SpecialType.System_Void) ||
            //        x.Value.TypeRefMask.IsVoid(TypeCtx))
            //    {
            //        // WRN: Argument has no value, parameter will be always NULL
            //        _diagnostics.Add(_routine, x.Value.PhpSyntax, ErrorCode.WRN_ArgumentVoid);
            //    }
            //}

            //
            return default;
        }

        public override T VisitGlobalFunctionCall(BoundGlobalFunctionCall x)
        {
            CheckUndefinedFunctionCall(x);

            // calling indirectly:
            if (x.Name.IsDirect)
            {
                CheckObsoleteSymbol(x.PhpSyntax, x.TargetMethod, isMemberCall: false);
                CheckGlobalFunctionCall(x);
            }
            else
            {
                Debug.Assert(x.Name.NameExpression != null);
                // check whether expression can be used as a function callback (must be callable - string, array, object ...)
                if (!TypeHelpers.IsCallable(TypeCtx, x.Name.NameExpression.TypeRefMask))
                {
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.ERR_InvalidFunctionName, TypeCtx.ToString(x.Name.NameExpression.TypeRefMask));
                }
            }

            //
            return base.VisitGlobalFunctionCall(x);
        }

        public override T VisitInstanceFunctionCall(BoundInstanceFunctionCall call)
        {
            // TODO: Consider checking if there are enough situations where this makes sense
            //       (it could only work if IncludeSubclasses is false or the class is final)
            //CheckUndefinedMethodCall(call, call.Instance?.ResultType, call.Name);

            // check target type
            CheckMethodCallTargetInstance(call.Instance, call.Name.NameValue.Name.Value);

            // check deprecated
            CheckObsoleteSymbol(call.PhpSyntax, call.TargetMethod, isMemberCall: true);

            //
            return base.VisitInstanceFunctionCall(call);
        }

        public override T VisitFieldRef(BoundFieldRef x)
        {
            if (x.ContainingType != null)
            {
                // class const
                // static field
                CheckMissusedPrimitiveType(x.ContainingType);
            }

            if (x.Access.IsWrite && ((Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation)x).Member is PropertySymbol prop && prop.SetMethod == null)
            {
                // read-only property written
                _diagnostics.Add(_routine, GetMemberNameSpanForDiagnostic(x.PhpSyntax),
                    ErrorCode.ERR_ReadOnlyPropertyWritten,
                    prop.ContainingType.PhpQualifiedName().ToString(),  // TOOD: _statics
                    prop.Name);
            }

            //
            return base.VisitFieldRef(x);
        }

        public override T VisitCFGCatchBlock(CatchBlock x)
        {
            // TODO: x.TypeRefs -> CheckMissusedPrimitiveType

            return base.VisitCFGCatchBlock(x);
        }

        public override T VisitStaticFunctionCall(BoundStaticFunctionCall call)
        {
            CheckMissusedPrimitiveType(call.TypeRef);

            CheckUndefinedMethodCall(call, call.TypeRef.ResolveTypeSymbol(DeclaringCompilation) as TypeSymbol, call.Name);

            // check deprecated
            CheckObsoleteSymbol(call.PhpSyntax, call.TargetMethod, isMemberCall: true);

            // remember there is call to `parent::__construct`
            if (call.TypeRef.IsParent() &&
                call.Name.IsDirect &&
                call.Name.NameValue.Name.IsConstructName)
            {
                CallsParentCtor = true;
            }

            // check the called method is not abstract
            if (call.TargetMethod.IsValidMethod() && call.TargetMethod.IsAbstract)
            {
                // ERR
                Add(call.PhpSyntax.Span, Devsense.PHP.Errors.Errors.AbstractMethodCalled, call.TargetMethod.ContainingType.PhpName(), call.Name.NameValue.Name.Value);
            }

            //
            return base.VisitStaticFunctionCall(call);
        }

        public override T VisitInstanceOf(BoundInstanceOfEx x)
        {
            CheckMissusedPrimitiveType(x.AsType);

            return base.VisitInstanceOf(x);
        }

        public override T VisitVariableRef(BoundVariableRef x)
        {
            CheckUninitializedVariableUse(x);

            return base.VisitVariableRef(x);
        }

        public override T VisitTemporalVariableRef(BoundTemporalVariableRef x)
        {
            // do not make diagnostics on syntesized variables
            return default;
        }

        public override T VisitDeclareStatement(BoundDeclareStatement x)
        {
            _diagnostics.Add(
                _routine,
                ((DeclareStmt)x.PhpSyntax).GetDeclareClauseSpan(),
                ErrorCode.WRN_NotYetImplementedIgnored,
                "Declare construct");

            return base.VisitDeclareStatement(x);
        }

        public override T VisitAssert(BoundAssertEx x)
        {
            base.VisitAssert(x);

            var args = x.ArgumentsInSourceOrder;

            // check number of parameters
            // check whether it is not always false or always true
            if (args.Length >= 1)
            {
                if (args[0].Value.ConstantValue.EqualsOptional(false.AsOptional()))
                {
                    // always failing
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_AssertAlwaysFail);
                }

                if (TypeCtx.IsAString(args[0].Value.TypeRefMask))
                {
                    // deprecated and not supported
                    _diagnostics.Add(_routine, args[0].Value.PhpSyntax, ErrorCode.WRN_StringAssertionDeprecated);
                }

                if (args.Length > 2)
                {
                    // too many args
                    _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_TooManyArguments, "assert", 2, args.Length);
                }
            }
            else
            {
                // assert() expects at least 1 parameter, 0 given
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_MissingArguments, "assert", 1, 0);
            }

            return default;
        }

        public override T VisitUnaryExpression(BoundUnaryEx x)
        {
            base.VisitUnaryExpression(x);

            switch (x.Operation)
            {
                case Operations.Clone:
                    // check we only pass object instances to the "clone" operation
                    // anything else causes a runtime warning!
                    var operandTypeMask = x.Operand.TypeRefMask;
                    if (!operandTypeMask.IsAnyType &&
                        !operandTypeMask.IsRef &&
                        !TypeCtx.IsObjectOnly(operandTypeMask))
                    {
                        _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_CloneNonObject, TypeCtx.ToString(operandTypeMask));
                    }
                    break;
            }

            return default;
        }

        public override T VisitBinaryExpression(BoundBinaryEx x)
        {
            base.VisitBinaryExpression(x);

            //

            switch (x.Operation)
            {
                case Operations.Div:
                    if (x.Right.IsConstant())
                    {
                        if (x.Right.ConstantValue.IsZero())
                        {
                            Add(x.Right.PhpSyntax.Span, Devsense.PHP.Errors.Warnings.DivisionByZero);
                        }
                    }
                    break;
            }

            return default;
        }

        public override T VisitConversion(BoundConversionEx x)
        {
            base.VisitConversion(x);

            if (!x.IsImplicit && x.PhpSyntax != null &&
                x.Operand.TypeRefMask.IsSingleType &&
                x.TargetType == TypeCtx.GetTypes(x.Operand.TypeRefMask).FirstOrDefault())
            {
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.INF_RedundantCast);
            }

            return default;
        }

        void CheckMethodCallTargetInstance(BoundExpression target, string methodName)
        {
            if (target == null)
            {
                // syntax error (?)
                return;
            }

            string nonobjtype = null;

            if (target.ResultType != null)
            {
                switch (target.ResultType.SpecialType)
                {
                    case SpecialType.System_Void:
                    case SpecialType.System_Int32:
                    case SpecialType.System_Int64:
                    case SpecialType.System_String:
                    case SpecialType.System_Boolean:
                        nonobjtype = target.ResultType.GetPhpTypeNameOrNull();
                        break;
                    default:
                        if (target.ResultType == DeclaringCompilation.CoreTypes.PhpString ||
                            target.ResultType == DeclaringCompilation.CoreTypes.PhpArray ||
                            target.ResultType == DeclaringCompilation.CoreTypes.PhpNumber ||
                            target.ResultType == DeclaringCompilation.CoreTypes.PhpResource ||
                            target.ResultType == DeclaringCompilation.CoreTypes.IPhpArray ||
                            target.ResultType == DeclaringCompilation.CoreTypes.IPhpCallable)
                        {
                            nonobjtype = target.ResultType.GetPhpTypeNameOrNull();
                        }
                        break;
                }
            }
            else
            {
                var tmask = target.TypeRefMask;
                if (!tmask.IsAnyType && !tmask.IsRef && !TypeCtx.IsObject(tmask))
                {
                    nonobjtype = TypeCtx.ToString(tmask);
                }
            }

            //
            if (nonobjtype != null)
            {
                _diagnostics.Add(_routine, target.PhpSyntax, ErrorCode.ERR_MethodCalledOnNonObject, methodName ?? "{}", nonobjtype);
            }
        }

        static string GetMemberNameForDiagnostic(BoundRoutineCall x)
        {
            if (x.TargetMethod.IsValidMethod())
            {
                if (x is BoundNewEx)
                {
                    return "new " + x.TargetMethod.ContainingType.PhpName();
                }
                else
                {
                    return GetMemberNameForDiagnostic(x.TargetMethod, x.Instance != null || x is BoundStaticFunctionCall);
                }
            }
            else
            {
                throw ExceptionUtilities.Unreachable;
            }
        }

        static string GetMemberNameForDiagnostic(Symbol target, bool isMemberName = false)
        {
            var name = target.PhpName();

            if (isMemberName)
            {
                var qname = target.ContainingType.PhpQualifiedName();   // TOOD: _statics
                name = qname.ToString(new Name(name), false);
            }

            return name;
        }

        static string GetNameForDiagnostic(TypeSymbol t)
        {
            return t.SpecialType switch
            {
                SpecialType.System_Object => QualifiedName.Object.ToString(),
                SpecialType.System_Double => QualifiedName.Float.ToString(),
                SpecialType.System_Boolean => QualifiedName.Bool.ToString(),
                SpecialType.System_Int32 => QualifiedName.Int.ToString(),
                SpecialType.System_Int64 => QualifiedName.Int.ToString(),
                SpecialType.System_String => QualifiedName.String.ToString(),
                _ => t.PhpName(),
            };
        }

        static TextSpan GetMemberNameSpanForDiagnostic(LangElement node)
        {
            if (node is FunctionCall fnc)
            {
                return fnc.NameSpan.ToTextSpan();
            }
            else
            {
                return node.Span.ToTextSpan();
            }
        }

        void CheckObsoleteSymbol(LangElement syntax, Symbol target, bool isMemberCall)
        {
            var obsolete = target?.ObsoleteAttributeData;
            if (obsolete != null)
            {
                // do not report the deprecation if the containing method itself is deprecated
                if (_routine?.ObsoleteAttributeData != null)
                {
                    return;
                }

                _diagnostics.Add(_routine, GetMemberNameSpanForDiagnostic(syntax), ErrorCode.WRN_SymbolDeprecated, target.Kind.ToString(), GetMemberNameForDiagnostic(target, isMemberCall), obsolete.Message);
            }
        }

        private void CheckUndefinedFunctionCall(BoundGlobalFunctionCall x)
        {
            if (x.Name.IsDirect &&
                x.TargetMethod is ErrorMethodSymbol errmethod && errmethod.ErrorKind == ErrorMethodKind.Missing)
            {
                var originalName = (x.PhpSyntax is DirectFcnCall fnc)
                    ? fnc.FullName.OriginalName
                    : x.Name.NameValue;

                _diagnostics.Add(_routine, GetMemberNameSpanForDiagnostic(x.PhpSyntax), ErrorCode.WRN_UndefinedFunctionCall, originalName.ToString());
            }
        }

        private void CheckUndefinedMethodCall(BoundRoutineCall x, TypeSymbol type, BoundRoutineName name)
        {
            if (x.TargetMethod is MissingMethodSymbol)
            {
                var span = x.PhpSyntax is FunctionCall fnc ? fnc.NameSpan : x.PhpSyntax.Span;
                _diagnostics.Add(_routine, span.ToTextSpan(), ErrorCode.WRN_UndefinedMethodCall, type.Name, name.NameValue.ToString());
            }
        }

        private void CheckUninitializedVariableUse(BoundVariableRef x)
        {
            if (x.MaybeUninitialized && !x.Access.IsQuiet && x.PhpSyntax != null)
            {
                _diagnostics.Add(_routine, x.PhpSyntax, ErrorCode.WRN_UninitializedVariableUse, x.Name.NameValue.ToString());
            }
        }

        private void CheckUndefinedType(BoundTypeRef typeRef)
        {
            var type = typeRef.ResolvedType;

            // Ignore indirect types (e.g. $foo = new $className())
            if (type.IsErrorTypeOrNull() && !(typeRef is BoundIndirectTypeRef))
            {
                if (typeRef.ResolvedType is ErrorTypeSymbol errtype && errtype.CandidateReason == CandidateReason.Ambiguous)
                {
                    // type is declared but ambiguously,
                    // warning with declaration ambiguity was already reported, we may skip following
                    return;
                }

                if (typeRef is BoundReservedTypeRef)
                {
                    // unresolved parent, self ?
                }
                else
                {
                    _diagnostics.Add(_routine, typeRef.PhpSyntax, ErrorCode.WRN_UndefinedType, typeRef.ToString());
                }
            }

            // undefined "parent"
            if (typeRef is BoundReservedTypeRef reservedType && reservedType.ReservedType == ReservedTypeRef.ReservedType.parent && typeRef.PhpSyntax != null)
            {
                if ((_routine.ContainingType is SourceTypeSymbol typeCtx && typeCtx.IsTrait) || _routine.IsGlobalScope)
                {
                    // global code or trait -> resolved at run time
                }
                else if (typeCtx == null || typeCtx.Syntax.BaseClass == null)
                {
                    // in a global function or a class without parent -> error
                    Add(typeRef.PhpSyntax.Span, Devsense.PHP.Errors.FatalErrors.ParentAccessedInParentlessClass);
                }
            }
        }

        public override T VisitCFGTryCatchEdge(TryCatchEdge x)
        {
            return base.VisitCFGTryCatchEdge(x);
        }

        public override T VisitStaticStatement(BoundStaticVariableStatement x)
        {
            return base.VisitStaticStatement(x);
        }

        public override T VisitCFGForeachEnumereeEdge(ForeachEnumereeEdge x)
        {
            base.VisitCFGForeachEnumereeEdge(x);

            var enumereeTypeMask = x.Enumeree.TypeRefMask;
            if (!enumereeTypeMask.IsAnyType && !enumereeTypeMask.IsRef)
            {
                // Apart from array, any object can possibly implement Traversable, hence no warning for them
                var types = TypeCtx.GetTypes(enumereeTypeMask);
                if (!types.Any(t => t.IsArray || t.IsObject))   // Using !All causes too many false positives (due to explode(..) etc.)
                {
                    // Using non-iterable type for enumeree
                    _diagnostics.Add(_routine, x.Enumeree.PhpSyntax, ErrorCode.WRN_ForeachNonIterable, TypeCtx.ToString(enumereeTypeMask));
                }
            }

            return default;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\Passes\DiagnosticWalker.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\Passes\DiagnosticWalker.cs(11,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\Passes\DiagnosticWalker.cs(997,26): error CS0165: Use of unassigned local variable 'typeCtx',D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\Passes\DiagnosticWalker.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\FlowAnalysis\Passes\DiagnosticWalker.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Graph\BoundBlock.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using Devsense.PHP.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.Utilities;

namespace Pchp.CodeAnalysis.Semantics.Graph
{
    /// <summary>
    /// Represents control flow block.
    /// </summary>
    [DebuggerDisplay("{DebugDisplay}")]
    public partial class BoundBlock : BoundStatement, IBlockOperation
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected virtual string DebugName => "Block";

        /// <summary>
        /// Debugger display.
        /// </summary>
        internal string DebugDisplay => $"{FlowState?.Routine?.RoutineName}: {DebugName} #{Ordinal}";

        readonly List<BoundStatement>/*!*/_statements;
        Edge _next;

        /// <summary>
        /// Tag used for graph algorithms.
        /// </summary>
        public int Tag { get { return _tag; } set { _tag = value; } }
        private int _tag;

        /// <summary>
        /// Gets statements contained in this block.
        /// </summary>
        public List<BoundStatement>/*!!*/Statements => _statements;

        /// <summary>
        /// Gets edge pointing out of this block.
        /// </summary>
        public Edge NextEdge
        {
            get { return _next; }
            internal set { _next = value; }
        }

        /// <summary>
        /// Gets block topological index.
        /// Index is unique within the graph.
        /// </summary>
        public int Ordinal { get { return _ordinal; } internal set { _ordinal = value; } }
        private int _ordinal;

        /// <summary>
        /// Gets value indicating the block is unreachable.
        /// </summary>
        public bool IsDead => _ordinal < 0;

        internal BoundBlock()
            :this(new List<BoundStatement>())
        {
            
        }

        internal BoundBlock(List<BoundStatement> statements)
        {
            Debug.Assert(statements != null);
            _statements = statements;

            //CompilerLogSource.Log.Count("TotalBoundBlocks");
        }

        internal BoundBlock Update(List<BoundStatement> statements, Edge nextEdge)
        {
            if (statements == _statements && nextEdge == _next)
            {
                return this;
            }
            else
            {
                return new BoundBlock(statements) { NextEdge = nextEdge, }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal virtual BoundBlock Clone()
        {
            // We duplicate _statements because of the List's mutability
            return new BoundBlock(new List<BoundStatement>(_statements)) { NextEdge = this.NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        /// <summary>
        /// Adds statement to the block.
        /// </summary>
        internal void Add(BoundStatement stmt)
        {
            Contract.ThrowIfNull(stmt);
            _statements.Add(stmt);
        }

        /// <summary>
        /// Traverses empty blocks to their non-empty successor. Skips duplicities.
        /// </summary>
        internal static List<BoundBlock>/*!*/SkipEmpty(IEnumerable<BoundBlock>/*!*/blocks)
        {
            Contract.ThrowIfNull(blocks);

            var result = new HashSet<BoundBlock>();

            foreach (var x in blocks)
            {
                var block = x;
                while (block != null && block.GetType() == typeof(BoundBlock) && block.Statements.Count == 0)
                {
                    var edge = block.NextEdge as SimpleEdge;
                    if (edge != null || block.NextEdge == null)
                    {
                        block = (edge != null && edge.NextBlock != block) ? edge.NextBlock : null;
                    }
                    else
                    {
                        break;
                    }
                }

                if (block != null)
                {
                    result.Add(block);
                }
            }

            //
            return result.ToList();
        }

        public virtual TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGBlock(this);

        #region IBlockStatement

        ImmutableArray<IOperation> IBlockOperation.Operations => _statements.Cast<IOperation>().AsImmutable();

        ImmutableArray<ILocalSymbol> IBlockOperation.Locals => Locals;
        protected virtual ImmutableArray<ILocalSymbol> Locals => ImmutableArray<ILocalSymbol>.Empty;

        public override OperationKind Kind => OperationKind.Block;

        SyntaxNode IOperation.Syntax => null;

        public override TResult Accept<TResult>(PhpOperationVisitor<TResult> visitor) => visitor.VisitBlockStatement(this);

        public override void Accept(OperationVisitor visitor) => visitor.VisitBlock(this);

        public override TResult Accept<TArgument, TResult>(OperationVisitor<TArgument, TResult> visitor, TArgument argument)
            => visitor.VisitBlock(this, argument);

        #endregion
    }

    /// <summary>
    /// Represents a start block.
    /// </summary>
    [DebuggerDisplay("Start")]
    public sealed partial class StartBlock : BoundBlock
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => "Start";

        internal StartBlock()
            : base()
        { }

        private StartBlock(List<BoundStatement> statements)
            : base(statements)
        { }

        internal new StartBlock Update(List<BoundStatement> statements, Edge nextEdge)
        {
            if (statements == Statements && nextEdge == NextEdge)
            {
                return this;
            }
            else
            {
                return new StartBlock(statements) { NextEdge = nextEdge }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new StartBlock(new List<BoundStatement>(Statements)) { NextEdge = this.NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGStartBlock(this);
    }

    /// <summary>
    /// Represents an exit block.
    /// </summary>
    [DebuggerDisplay("Exit")]
    public sealed partial class ExitBlock : BoundBlock
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => "Exit";

        internal ExitBlock()
            : base()
        { }

        private ExitBlock(List<BoundStatement> statements)
            : base(statements)
        { }

        internal ExitBlock Update(List<BoundStatement> statements)
        {
            Debug.Assert(NextEdge == null);

            if (statements == Statements)
            {
                return this;
            }
            else
            {
                return new ExitBlock(statements)
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new ExitBlock(new List<BoundStatement>(Statements))
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGExitBlock(this);
    }

    /// <summary>
    /// Represents control flow block of catch item.
    /// </summary>
    [DebuggerDisplay("CatchBlock({TypeRef})")]
    public partial class CatchBlock : BoundBlock //, ICatch
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => "Catch";

        /// <summary>
        /// Catch variable type.
        /// </summary>
        public IBoundTypeRef TypeRef { get { return _typeRef; } }
        private readonly IBoundTypeRef _typeRef;

        /// <summary>
        /// A variable where an exception is assigned in.
        /// Can be <c>null</c> if catch is non-capturing.
        /// </summary>
        public BoundVariableRef Variable { get; }

        public CatchBlock(IBoundTypeRef typeRef, BoundVariableRef variable)
            : this(typeRef, variable, new List<BoundStatement>())
        { }

        private CatchBlock(IBoundTypeRef typeRef, BoundVariableRef variable, List<BoundStatement> statements)
            : base(statements)
        {
            _typeRef = typeRef;
            this.Variable = variable;
        }

        internal CatchBlock Update(BoundTypeRef typeRef, BoundVariableRef variable, List<BoundStatement> statements, Edge nextEdge)
        {
            if (typeRef == _typeRef && variable == Variable && statements == Statements && nextEdge == NextEdge)
            {
                return this;
            }
            else
            {
                return new CatchBlock(typeRef, variable, statements) { NextEdge = nextEdge }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new CatchBlock(_typeRef, Variable, new List<BoundStatement>(Statements)) { NextEdge = NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGCatchBlock(this);

        //#region ICatch

        //IBlockStatement ICatch.Handler => this.NextEdge.Targets.Single();

        //ITypeSymbol ICatch.CaughtType => this.ResolvedType;

        //IExpression ICatch.Filter => null;

        //ILocalSymbol ICatch.ExceptionLocal => _variable.Variable?.Symbol as ILocalSymbol;

        //#endregion
    }

    /// <summary>
    /// Represents control flow block of case item.
    /// </summary>
    [DebuggerDisplay("CaseBlock")]
    public partial class CaseBlock : BoundBlock
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => IsDefault ? "default:" : "case:";

        /// <summary>
        /// Gets case value expression bag.
        /// In case of default case, it is set <see cref="BoundItemsBag{BoundExpression}.Empty"/>.
        /// </summary>
        public BoundItemsBag<BoundExpression> CaseValue => _caseValue;
        private readonly BoundItemsBag<BoundExpression> _caseValue;

        /// <summary>
        /// Gets value indicating whether the case represents a default.
        /// </summary>
        public bool IsDefault => _caseValue.IsEmpty;

        public CaseBlock(BoundItemsBag<BoundExpression> caseValue)
            : this(caseValue, new List<BoundStatement>())
        { }

        private CaseBlock(BoundItemsBag<BoundExpression> caseValue, List<BoundStatement> statements)
            : base(statements)
        {
            _caseValue = caseValue;
        }

        internal CaseBlock Update(BoundItemsBag<BoundExpression> caseValue, List<BoundStatement> statements, Edge nextEdge)
        {
            if (caseValue == _caseValue && statements == Statements && nextEdge == NextEdge)
            {
                return this;
            }
            else
            {
                return new CaseBlock(caseValue, statements) { NextEdge = nextEdge }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new CaseBlock(_caseValue, new List<BoundStatement>(Statements)) { NextEdge = NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGCaseBlock(this);
    }
}

---- Transformed Tree ----
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using Devsense.PHP.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Operations;
using Pchp.CodeAnalysis.Utilities;

namespace Pchp.CodeAnalysis.Semantics.Graph
{
    /// <summary>
    /// Represents control flow block.
    /// </summary>
    [DebuggerDisplay("{DebugDisplay}")]
    public partial class BoundBlock : BoundStatement, IBlockOperation
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected virtual string DebugName => "Block";

        /// <summary>
        /// Debugger display.
        /// </summary>
        internal string DebugDisplay => $"{FlowState?.Routine?.RoutineName}: {DebugName} #{Ordinal}";

        readonly List<BoundStatement>/*!*/_statements;
        Edge _next;

        /// <summary>
        /// Tag used for graph algorithms.
        /// </summary>
        public int Tag { get { return _tag; } set { _tag = value; } }
        private int _tag;

        /// <summary>
        /// Gets statements contained in this block.
        /// </summary>
        public List<BoundStatement>/*!!*/Statements => _statements;

        /// <summary>
        /// Gets edge pointing out of this block.
        /// </summary>
        public Edge NextEdge
        {
            get { return _next; }
            internal set { _next = value; }
        }

        /// <summary>
        /// Gets block topological index.
        /// Index is unique within the graph.
        /// </summary>
        public int Ordinal { get { return _ordinal; } internal set { _ordinal = value; } }
        private int _ordinal;

        /// <summary>
        /// Gets value indicating the block is unreachable.
        /// </summary>
        public bool IsDead => _ordinal < 0;

        internal BoundBlock()
            :this(new List<BoundStatement>())
        {
            
        }

        internal BoundBlock(List<BoundStatement> statements)
        {
            Debug.Assert(statements != null);
            _statements = statements;

            //CompilerLogSource.Log.Count("TotalBoundBlocks");
        }

        internal BoundBlock Update(List<BoundStatement> statements, Edge nextEdge)
        {
            if (statements == _statements && nextEdge == _next)
            {
                return this;
            }
            else
            {
                return new BoundBlock(statements) { NextEdge = nextEdge, }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal virtual BoundBlock Clone()
        {
            // We duplicate _statements because of the List's mutability
            return new BoundBlock(new List<BoundStatement>(_statements)) { NextEdge = this.NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        /// <summary>
        /// Adds statement to the block.
        /// </summary>
        internal void Add(BoundStatement stmt)
        {
            Contract.ThrowIfNull(stmt);
            _statements.Add(stmt);
        }

        /// <summary>
        /// Traverses empty blocks to their non-empty successor. Skips duplicities.
        /// </summary>
        internal static List<BoundBlock>/*!*/SkipEmpty(IEnumerable<BoundBlock>/*!*/blocks)
        {
            Contract.ThrowIfNull(blocks);

            var result = new HashSet<BoundBlock>();

            foreach (var x in blocks)
            {
                var block = x;
                while (block != null && block.GetType() == typeof(BoundBlock) && block.Statements.Count == 0)
                {
                    if (block.NextEdge is SimpleEdge edge || block.NextEdge == null)
                    {
                        block = (block.NextEdge is SimpleEdge edge && edge.NextBlock != block) ? edge.NextBlock : null;
                    }
                    else
                    {
                        break;
                    }
                }

                if (block != null)
                {
                    result.Add(block);
                }
            }

            //
            return result.ToList();
        }

        public virtual TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGBlock(this);

        #region IBlockStatement

        ImmutableArray<IOperation> IBlockOperation.Operations => _statements.Cast<IOperation>().AsImmutable();

        ImmutableArray<ILocalSymbol> IBlockOperation.Locals => Locals;
        protected virtual ImmutableArray<ILocalSymbol> Locals => ImmutableArray<ILocalSymbol>.Empty;

        public override OperationKind Kind => OperationKind.Block;

        SyntaxNode IOperation.Syntax => null;

        public override TResult Accept<TResult>(PhpOperationVisitor<TResult> visitor) => visitor.VisitBlockStatement(this);

        public override void Accept(OperationVisitor visitor) => visitor.VisitBlock(this);

        public override TResult Accept<TArgument, TResult>(OperationVisitor<TArgument, TResult> visitor, TArgument argument)
            => visitor.VisitBlock(this, argument);

        #endregion
    }

    /// <summary>
    /// Represents a start block.
    /// </summary>
    [DebuggerDisplay("Start")]
    public sealed partial class StartBlock : BoundBlock
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => "Start";

        internal StartBlock()
            : base()
        { }

        private StartBlock(List<BoundStatement> statements)
            : base(statements)
        { }

        internal new StartBlock Update(List<BoundStatement> statements, Edge nextEdge)
        {
            if (statements == Statements && nextEdge == NextEdge)
            {
                return this;
            }
            else
            {
                return new StartBlock(statements) { NextEdge = nextEdge }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new StartBlock(new List<BoundStatement>(Statements)) { NextEdge = this.NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGStartBlock(this);
    }

    /// <summary>
    /// Represents an exit block.
    /// </summary>
    [DebuggerDisplay("Exit")]
    public sealed partial class ExitBlock : BoundBlock
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => "Exit";

        internal ExitBlock()
            : base()
        { }

        private ExitBlock(List<BoundStatement> statements)
            : base(statements)
        { }

        internal ExitBlock Update(List<BoundStatement> statements)
        {
            Debug.Assert(NextEdge == null);

            if (statements == Statements)
            {
                return this;
            }
            else
            {
                return new ExitBlock(statements)
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new ExitBlock(new List<BoundStatement>(Statements))
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGExitBlock(this);
    }

    /// <summary>
    /// Represents control flow block of catch item.
    /// </summary>
    [DebuggerDisplay("CatchBlock({TypeRef})")]
    public partial class CatchBlock : BoundBlock //, ICatch
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => "Catch";

        /// <summary>
        /// Catch variable type.
        /// </summary>
        public IBoundTypeRef TypeRef { get { return _typeRef; } }
        private readonly IBoundTypeRef _typeRef;

        /// <summary>
        /// A variable where an exception is assigned in.
        /// Can be <c>null</c> if catch is non-capturing.
        /// </summary>
        public BoundVariableRef Variable { get; }

        public CatchBlock(IBoundTypeRef typeRef, BoundVariableRef variable)
            : this(typeRef, variable, new List<BoundStatement>())
        { }

        private CatchBlock(IBoundTypeRef typeRef, BoundVariableRef variable, List<BoundStatement> statements)
            : base(statements)
        {
            _typeRef = typeRef;
            this.Variable = variable;
        }

        internal CatchBlock Update(BoundTypeRef typeRef, BoundVariableRef variable, List<BoundStatement> statements, Edge nextEdge)
        {
            if (typeRef == _typeRef && variable == Variable && statements == Statements && nextEdge == NextEdge)
            {
                return this;
            }
            else
            {
                return new CatchBlock(typeRef, variable, statements) { NextEdge = nextEdge }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new CatchBlock(_typeRef, Variable, new List<BoundStatement>(Statements)) { NextEdge = NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGCatchBlock(this);

        //#region ICatch

        //IBlockStatement ICatch.Handler => this.NextEdge.Targets.Single();

        //ITypeSymbol ICatch.CaughtType => this.ResolvedType;

        //IExpression ICatch.Filter => null;

        //ILocalSymbol ICatch.ExceptionLocal => _variable.Variable?.Symbol as ILocalSymbol;

        //#endregion
    }

    /// <summary>
    /// Represents control flow block of case item.
    /// </summary>
    [DebuggerDisplay("CaseBlock")]
    public partial class CaseBlock : BoundBlock
    {
        /// <summary>
        /// Internal name of the block.
        /// </summary>
        protected override string DebugName => IsDefault ? "default:" : "case:";

        /// <summary>
        /// Gets case value expression bag.
        /// In case of default case, it is set <see cref="BoundItemsBag{BoundExpression}.Empty"/>.
        /// </summary>
        public BoundItemsBag<BoundExpression> CaseValue => _caseValue;
        private readonly BoundItemsBag<BoundExpression> _caseValue;

        /// <summary>
        /// Gets value indicating whether the case represents a default.
        /// </summary>
        public bool IsDefault => _caseValue.IsEmpty;

        public CaseBlock(BoundItemsBag<BoundExpression> caseValue)
            : this(caseValue, new List<BoundStatement>())
        { }

        private CaseBlock(BoundItemsBag<BoundExpression> caseValue, List<BoundStatement> statements)
            : base(statements)
        {
            _caseValue = caseValue;
        }

        internal CaseBlock Update(BoundItemsBag<BoundExpression> caseValue, List<BoundStatement> statements, Edge nextEdge)
        {
            if (caseValue == _caseValue && statements == Statements && nextEdge == NextEdge)
            {
                return this;
            }
            else
            {
                return new CaseBlock(caseValue, statements) { NextEdge = nextEdge }
                    .WithLocalPropertiesFrom(this);
            }
        }

        internal override BoundBlock Clone()
        {
            return new CaseBlock(_caseValue, new List<BoundStatement>(Statements)) { NextEdge = NextEdge }
                .WithLocalPropertiesFrom(this);
        }

        public override TResult Accept<TResult>(GraphVisitor<TResult> visitor) => visitor.VisitCFGCaseBlock(this);
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Graph\BoundBlock.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Graph\BoundBlock.cs(5,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Graph\BoundBlock.cs(122,63): error CS0136: A local or parameter named 'edge' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Graph\BoundBlock.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Semantics\Graph\BoundBlock.cs(5,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.FlowAnalysis;
using Pchp.CodeAnalysis.Semantics;
using Peachpie.CodeAnalysis.Semantics;
using Peachpie.CodeAnalysis.Symbols;
using Roslyn.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Pchp.CodeAnalysis.Symbols
{
    public static class PhpRoutineSymbolExtensions
    {
        /// <summary>
        /// Gets value indicating the routine does not override any other routine.
        /// (static methods, private methods or sealed virtual methods not overriding anything)
        /// </summary>
        static bool IsNotOverriding(SourceRoutineSymbol routine)
        {
            return
                routine.IsStatic ||
                routine.DeclaredAccessibility == Accessibility.Private ||
                (routine.OverriddenMethod == null && (routine.ContainingType.IsSealed || routine.IsSealed));
        }

        /// <summary>
        /// Constructs most appropriate CLR return type of given routine.
        /// The method handles returning by alias, PHP7 return type, PHPDoc @return tag and result of flow analysis.
        /// In case the routine is an override or can be overriden, the CLR type is a value.
        /// </summary>
        internal static TypeSymbol ConstructClrReturnType(SourceRoutineSymbol routine)
        {
            var compilation = routine.DeclaringCompilation;

            // if the method is generator and can't be overriden then the return type must be generator 
            // TODO: would not be necessary if GN_SGS got fixed (the routine could report the return type correctly itself)
            if (routine.IsGeneratorMethod())
            {
                // if non-virtual -> return Generator directly
                if (IsNotOverriding(routine))
                {
                    return compilation.CoreTypes.Generator;
                }
                else //can't be sure -> play safe with PhpValue
                {
                    return compilation.CoreTypes.PhpValue;
                }
            }

            // &
            if (routine.SyntaxSignature.AliasReturn)
            {
                return compilation.CoreTypes.PhpAlias;
            }

            // : return type
            if (routine.SyntaxReturnType != null)
            {
                // "static"
                if (routine.SyntaxReturnType is ReservedTypeRef rt && rt.Type == ReservedTypeRef.ReservedType.@static &&
                    routine.ContainingType is SourceTypeSymbol srct && !srct.IsTrait)
                {
                    return srct;
                }

                //
                return compilation.GetTypeFromTypeRef(routine.SyntaxReturnType, routine.ContainingType as SourceTypeSymbol);
            }

            // for non virtual methods:
            if (IsNotOverriding(routine))
            {
                // /** @return */
                var typeCtx = routine.TypeRefContext;
                if (routine.PHPDocBlock != null && (compilation.Options.PhpDocTypes & PhpDocTypes.ReturnTypes) != 0)
                {
                    var returnTag = routine.PHPDocBlock.Returns;
                    if (returnTag != null && returnTag.TypeNames.Length != 0)
                    {
                        var tmask = PHPDoc.GetTypeMask(typeCtx, returnTag.TypeNamesArray, routine.GetNamingContext());
                        if (!tmask.IsVoid && !tmask.IsAnyType)
                        {
                            return compilation.GetTypeFromTypeRef(typeCtx, tmask);
                        }
                    }
                }

                // determine from code flow
                return compilation.GetTypeFromTypeRef(typeCtx, routine.ResultTypeMask);
            }
            else
            {
                // TODO: an override that respects the base? check routine.ResultTypeMask (flow analysis) and base implementation is it matches
            }

            // any value by default
            return compilation.CoreTypes.PhpValue;
        }

        /// <summary>
        /// Gets expected return type mask of given symbol (field, function, method or property).
        /// </summary>
        /// <remarks>Returned type mask corresponds to types that can be returned by invoking given symbol.</remarks>
        public static TypeRefMask GetResultType(this IPhpValue symbol, TypeRefContext ctx)
        {
            Contract.ThrowIfNull(symbol);
            Contract.ThrowIfNull(ctx);

            TypeSymbol t;

            if (symbol is FieldSymbol fieldSymbol)
            {
                t = fieldSymbol.Type;
            }
            else if (symbol is MethodSymbol m)
            {
                var r = symbol as SourceRoutineSymbol;

                // if the method is generator use ConstructClrReturnType analysis for return type
                // TODO: would not be necessary if GN_SGS got fixed (the routine could report the return type correctly itself)
                if (r != null && r.IsGeneratorMethod())
                {
                    t = m.ReturnType;
                }
                else if (r != null && r.IsStatic && r.SyntaxReturnType == null)
                {
                    // In case of a static function, we can return expected return type mask exactly.
                    // Such function cannot be overriden and we know exactly what the return type will be even the CLR type covers more possibilities.
                    return ctx.AddToContext(r.TypeRefContext, r.ResultTypeMask);
                }
                else
                {
                    t = m.ReturnType;
                }
            }
            else if (symbol is PropertySymbol propertySymbol)
            {
                t = propertySymbol.Type;
            }
            else if (symbol is SourceParameterSymbol ps)
            {
                t = ps.Type;

                if (ps.IsParams)
                {
                    Debug.Assert(t.IsSZArray());
                    return ctx.GetArrayTypeMask(TypeRefFactory.CreateMask(ctx, ((ArrayTypeSymbol)t).ElementType));
                }
                else if (ps.Syntax.TypeHint.IsCallable())
                {
                    var callableMask = ctx.GetCallableTypeMask();
                    callableMask.IsRef = ps.Syntax.PassedByRef;
                    if (!ps.HasNotNull)
                        callableMask |= ctx.GetNullTypeMask();

                    return callableMask;
                }

                // TODO: handle union types precisely, now we resolve them mostly as PhpValue which results in AnyType mask
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(symbol);
            }

            // create the type mask from the CLR type symbol
            var mask = TypeRefFactory.CreateMask(ctx, t, notNull: (symbol as Symbol).IsNotNull());

            if (symbol is IPhpRoutineSymbol phpr)
            {
                // [CastToFalse]
                if (phpr.CastToFalse)
                {
                    mask |= ctx.GetBooleanTypeMask();    // the function may return FALSE

                    // remove NULL (NULL is changed to FALSE), note it also can't return -1
                    mask = ctx.WithoutNull(mask);
                }
            }

            //
            return mask;
        }

        /// <summary>
        /// Resolves list of input arguments.
        /// Implicit parameters passed by compiler are ignored.
        /// </summary>
        /// <param name="routine">Routine.</param>
        /// <param name="ctx">Type context to transfer type masks into.</param>
        /// <returns>List of input PHP arguments.</returns>
        public static IList<PhpParam> GetExpectedArguments(this IPhpRoutineSymbol routine, TypeRefContext ctx)
        {
            Contract.ThrowIfNull(routine);
            Contract.ThrowIfNull(ctx);

            List<PhpParam> result = null;

            int index = 0;

            var ps = routine.Parameters;
            foreach (ParameterSymbol p in ps)
            {
                if (result == null && p.IsImplicitlyDeclared && !p.IsParams)
                {
                    continue;
                }

                //
                var phpparam = p.IsParams
                    ? new PhpParam(p, index++, TypeRefMask.AnyType.WithIsRef(((ArrayTypeSymbol)p.Type).ElementType.Is_PhpAlias()))
                    : new PhpParam(p, index++, TypeRefFactory.CreateMask(ctx, p.Type, notNull: p.HasNotNull));

                result ??= new List<PhpParam>(ps.Length);
                result.Add(phpparam);
            }

            //
            return result ?? (IList<PhpParam>)Array.Empty<PhpParam>();
        }

        /// <summary>
        /// Gets mask with 1-bits corresponding to an argument that must be passed by reference.
        /// </summary>
        internal static PhpSignatureMask GetByRefArguments(this IPhpRoutineSymbol routine)
        {
            Contract.ThrowIfNull(routine);

            var mask = new PhpSignatureMask();
            var ps = routine.Parameters;

            int index = 0;

            foreach (ParameterSymbol p in ps)
            {
                if (index == 0 && p.IsImplicitlyDeclared && !p.IsParams)
                {
                    continue;
                }

                if (p.IsParams)
                {
                    if (((ArrayTypeSymbol)p.Type).ElementType.Is_PhpAlias())    // PHP: ... &$p
                    {
                        mask.SetFrom(index++);
                    }
                }
                else
                {
                    mask[index++] =
                        p.RefKind != RefKind.None ||  // C#: ref|out p
                        p.Type.Is_PhpAlias();         // PHP: &$p
                }
            }

            return mask;
        }

        /// <summary>
        /// Gets additional flags of the caller routine.
        /// </summary>
        /// <param name="routine">The routine.</param>
        /// <param name="localaccess">Gets local variables that will be accessed by the routine. <c>NULL</c> if none (a common case).</param>
        public static RoutineFlags InvocationFlags(this IPhpRoutineSymbol routine, out IList<VariableName> localaccess)
        {
            localaccess = null;

            var f = RoutineFlags.None;

            var ps = /*routine is SourceRoutineSymbol sr ? sr.ImplicitParameters :*/ routine.Parameters;
            foreach (var p in ps)
            {
                if (p.IsImplicitlyDeclared)
                {
                    switch (((ParameterSymbol)p).ImportValueAttributeData.Value)
                    {
                        case ImportValueAttributeData.ValueSpec.CallerArgs:
                            f |= RoutineFlags.UsesArgs;
                            break;
                        case ImportValueAttributeData.ValueSpec.Locals:
                            f |= RoutineFlags.UsesLocals;
                            break;
                        case ImportValueAttributeData.ValueSpec.CallerStaticClass:
                            f |= RoutineFlags.UsesLateStatic;
                            break;
                        case ImportValueAttributeData.ValueSpec.LocalVariable:
                            if (p.Type.Is_PhpAlias())
                            {
                                if (localaccess == null) localaccess = new List<VariableName>(1);
                                localaccess.Add(new VariableName(p.Name));
                            }
                            break;
                    }
                }
                else
                {
                    // implicit parameters are at begining only
                    break;
                }
            }

            return f;
        }

        /// <summary>
        /// Determines if the given routine uses late static binding i.e. `static` keyword or it forwards the late static type.
        /// </summary>
        internal static bool HasLateStaticBoundParam(this MethodSymbol method)
        {
            if (method.IsErrorMethodOrNull() || !method.IsStatic)
            {
                return false;
            }

            if (method.OriginalDefinition is SourceRoutineSymbol sr)
            {
                return sr.RequiresLateStaticBoundParam;
            }

            // PE method
            return method.LateStaticParameter() != null;
        }

        /// <summary>
        /// Gets the special <c>&lt;static&gt;</c> parameter of given method if any. Otherwise <c>null</c>.
        /// </summary>
        internal static ParameterSymbol LateStaticParameter(this MethodSymbol method)
        {
            // in source routines, we can iterate just the implicit parameters and not populating the source parameters
            var ps = method is SourceRoutineSymbol sr ? sr.ImplicitParameters : method.Parameters;

            foreach (var p in ps)
            {
                if (SpecialParameterSymbol.IsLateStaticParameter(p))
                {
                    return p;
                }
                else if (!p.IsImplicitlyDeclared)
                {
                    break;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets value indicating the routine was found containing <c>yield</c>
        /// hence it is considered as a generator state machine method.
        /// </summary>
        /// <param name="routine">The analysed routine.</param>
        /// <returns>Value indicating the routine gets a generator.</returns>
        internal static bool IsGeneratorMethod(this SourceRoutineSymbol routine) => (routine.Flags & RoutineFlags.IsGenerator) != 0;

        /// <summary>
        /// Gets enumeration of all routines (global code, functions and methods) within the file.
        /// </summary>
        internal static IEnumerable<SourceRoutineSymbol> GetAllRoutines(this SourceFileSymbol file)
        {
            // all functions + global code + methods + lambdas
            var funcs = file.Functions.Cast<SourceRoutineSymbol>();
            var main = (SourceRoutineSymbol)file.MainMethod;

            var types = file.ContainedTypes.SelectMany(t => t.AllReachableVersions());
            var methods = types.SelectMany(f => f.GetMembers().OfType<SourceRoutineSymbol>());
            var lambdas = ((ILambdaContainerSymbol)file).Lambdas;

            return funcs.Concat(main).Concat(methods).Concat(lambdas);
        }

        /// <summary>
        /// Gets PHPDoc assoviated with given source symbol.
        /// </summary>
        internal static bool TryGetPHPDocBlock(this Symbol symbol, out PHPDocBlock phpdoc)
        {
            phpdoc = symbol?.OriginalDefinition switch
            {
                SourceRoutineSymbol routine => routine.PHPDocBlock,
                SourceFieldSymbol field => field.PHPDocBlock,
                SourceTypeSymbol type => type.Syntax.PHPDoc,
                _ => null
            };

            return phpdoc != null;
        }

        /// <summary>
        /// The resource contains an additional textual metadata to be used by the runtime if needed (JSON format).
        /// The resource is indexed by the symbol full metadata name.
        /// Can be <c>null</c>.
        /// </summary>
        internal static string GetSymbolMetadataResource(this Symbol symbol)
        {
            // CONSIDER: not for private/internal symbols ?

            if (TryGetPHPDocBlock(symbol, out var phpdoc) && symbol.GetContainingFileSymbol() is SourceFileSymbol file)
            {
                var phpdoctext = file.SyntaxTree.GetText().ToString(phpdoc.Span.ToTextSpan());

                // cleanup the phpdoctext
                // trim lines:
                var result = new StringBuilder(phpdoctext.Length);

                using (var reader = new StringReader(phpdoctext))
                {
                    for (; ; )
                    {
                        var line = reader.ReadLine();
                        if (line != null)
                        {
                            if (result.Length != 0)
                                result.Append("\n ");

                            result.Append(line.Trim());
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                ////
                //var stream = new System.IO.StringWriter();
                //using (var writer = new JsonWriter(stream))
                //{
                //    writer.WriteObjectStart();
                //    writer.Write("doc", phpdoctext);
                //    // TODO: location, return type, ...
                //    writer.WriteObjectEnd();
                //}

                //return stream.ToString();

                // create "smaller" json // CONSIDER: use some library that allows to skip whitespaces, newtonsoft or netcore 3.0
                result.Replace("\\", "\\\\").Replace("\n", "\\n").Replace("\r", "").Replace("\"", "\\\"");  // naively escape
                return $"{{\"doc\":\"{(result.ToString())}\"}}";
            }

            // no metadata
            return null;
        }
    }
}

---- Transformed Tree ----
using Devsense.PHP.Syntax;
using Devsense.PHP.Syntax.Ast;
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.FlowAnalysis;
using Pchp.CodeAnalysis.Semantics;
using Peachpie.CodeAnalysis.Semantics;
using Peachpie.CodeAnalysis.Symbols;
using Roslyn.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Pchp.CodeAnalysis.Symbols
{
    public static class PhpRoutineSymbolExtensions
    {
        /// <summary>
        /// Gets value indicating the routine does not override any other routine.
        /// (static methods, private methods or sealed virtual methods not overriding anything)
        /// </summary>
        static bool IsNotOverriding(SourceRoutineSymbol routine)
        {
            return
                routine.IsStatic ||
                routine.DeclaredAccessibility == Accessibility.Private ||
                (routine.OverriddenMethod == null && (routine.ContainingType.IsSealed || routine.IsSealed));
        }

        /// <summary>
        /// Constructs most appropriate CLR return type of given routine.
        /// The method handles returning by alias, PHP7 return type, PHPDoc @return tag and result of flow analysis.
        /// In case the routine is an override or can be overriden, the CLR type is a value.
        /// </summary>
        internal static TypeSymbol ConstructClrReturnType(SourceRoutineSymbol routine)
        {
            var compilation = routine.DeclaringCompilation;

            // if the method is generator and can't be overriden then the return type must be generator 
            // TODO: would not be necessary if GN_SGS got fixed (the routine could report the return type correctly itself)
            if (routine.IsGeneratorMethod())
            {
                // if non-virtual -> return Generator directly
                if (IsNotOverriding(routine))
                {
                    return compilation.CoreTypes.Generator;
                }
                else //can't be sure -> play safe with PhpValue
                {
                    return compilation.CoreTypes.PhpValue;
                }
            }

            // &
            if (routine.SyntaxSignature.AliasReturn)
            {
                return compilation.CoreTypes.PhpAlias;
            }

            // : return type
            if (routine.SyntaxReturnType != null)
            {
                // "static"
                if (routine.SyntaxReturnType is ReservedTypeRef rt && rt.Type == ReservedTypeRef.ReservedType.@static &&
                    routine.ContainingType is SourceTypeSymbol srct && !srct.IsTrait)
                {
                    return srct;
                }

                //
                return compilation.GetTypeFromTypeRef(routine.SyntaxReturnType, routine.ContainingType as SourceTypeSymbol);
            }

            // for non virtual methods:
            if (IsNotOverriding(routine))
            {
                // /** @return */
                var typeCtx = routine.TypeRefContext;
                if (routine.PHPDocBlock != null && (compilation.Options.PhpDocTypes & PhpDocTypes.ReturnTypes) != 0)
                {
                    var returnTag = routine.PHPDocBlock.Returns;
                    if (returnTag != null && returnTag.TypeNames.Length != 0)
                    {
                        var tmask = PHPDoc.GetTypeMask(typeCtx, returnTag.TypeNamesArray, routine.GetNamingContext());
                        if (!tmask.IsVoid && !tmask.IsAnyType)
                        {
                            return compilation.GetTypeFromTypeRef(typeCtx, tmask);
                        }
                    }
                }

                // determine from code flow
                return compilation.GetTypeFromTypeRef(typeCtx, routine.ResultTypeMask);
            }
            else
            {
                // TODO: an override that respects the base? check routine.ResultTypeMask (flow analysis) and base implementation is it matches
            }

            // any value by default
            return compilation.CoreTypes.PhpValue;
        }

        /// <summary>
        /// Gets expected return type mask of given symbol (field, function, method or property).
        /// </summary>
        /// <remarks>Returned type mask corresponds to types that can be returned by invoking given symbol.</remarks>
        public static TypeRefMask GetResultType(this IPhpValue symbol, TypeRefContext ctx)
        {
            Contract.ThrowIfNull(symbol);
            Contract.ThrowIfNull(ctx);

            TypeSymbol t;

            if (symbol is FieldSymbol fieldSymbol)
            {
                t = fieldSymbol.Type;
            }
            else if (symbol is MethodSymbol m)
            {
                // if the method is generator use ConstructClrReturnType analysis for return type
                // TODO: would not be necessary if GN_SGS got fixed (the routine could report the return type correctly itself)
                if (symbol is SourceRoutineSymbol r && r.IsGeneratorMethod())
                {
                    t = m.ReturnType;
                }
                else if (symbol is SourceRoutineSymbol r && r.IsStatic && r.SyntaxReturnType == null)
                {
                    // In case of a static function, we can return expected return type mask exactly.
                    // Such function cannot be overriden and we know exactly what the return type will be even the CLR type covers more possibilities.
                    return ctx.AddToContext(r.TypeRefContext, r.ResultTypeMask);
                }
                else
                {
                    t = m.ReturnType;
                }
            }
            else if (symbol is PropertySymbol propertySymbol)
            {
                t = propertySymbol.Type;
            }
            else if (symbol is SourceParameterSymbol ps)
            {
                t = ps.Type;

                if (ps.IsParams)
                {
                    Debug.Assert(t.IsSZArray());
                    return ctx.GetArrayTypeMask(TypeRefFactory.CreateMask(ctx, ((ArrayTypeSymbol)t).ElementType));
                }
                else if (ps.Syntax.TypeHint.IsCallable())
                {
                    var callableMask = ctx.GetCallableTypeMask();
                    callableMask.IsRef = ps.Syntax.PassedByRef;
                    if (!ps.HasNotNull)
                        callableMask |= ctx.GetNullTypeMask();

                    return callableMask;
                }

                // TODO: handle union types precisely, now we resolve them mostly as PhpValue which results in AnyType mask
            }
            else
            {
                throw ExceptionUtilities.UnexpectedValue(symbol);
            }

            // create the type mask from the CLR type symbol
            var mask = TypeRefFactory.CreateMask(ctx, t, notNull: (symbol as Symbol).IsNotNull());

            if (symbol is IPhpRoutineSymbol phpr)
            {
                // [CastToFalse]
                if (phpr.CastToFalse)
                {
                    mask |= ctx.GetBooleanTypeMask();    // the function may return FALSE

                    // remove NULL (NULL is changed to FALSE), note it also can't return -1
                    mask = ctx.WithoutNull(mask);
                }
            }

            //
            return mask;
        }

        /// <summary>
        /// Resolves list of input arguments.
        /// Implicit parameters passed by compiler are ignored.
        /// </summary>
        /// <param name="routine">Routine.</param>
        /// <param name="ctx">Type context to transfer type masks into.</param>
        /// <returns>List of input PHP arguments.</returns>
        public static IList<PhpParam> GetExpectedArguments(this IPhpRoutineSymbol routine, TypeRefContext ctx)
        {
            Contract.ThrowIfNull(routine);
            Contract.ThrowIfNull(ctx);

            List<PhpParam> result = null;

            int index = 0;

            var ps = routine.Parameters;
            foreach (ParameterSymbol p in ps)
            {
                if (result == null && p.IsImplicitlyDeclared && !p.IsParams)
                {
                    continue;
                }

                //
                var phpparam = p.IsParams
                    ? new PhpParam(p, index++, TypeRefMask.AnyType.WithIsRef(((ArrayTypeSymbol)p.Type).ElementType.Is_PhpAlias()))
                    : new PhpParam(p, index++, TypeRefFactory.CreateMask(ctx, p.Type, notNull: p.HasNotNull));

                result ??= new List<PhpParam>(ps.Length);
                result.Add(phpparam);
            }

            //
            return result ?? (IList<PhpParam>)Array.Empty<PhpParam>();
        }

        /// <summary>
        /// Gets mask with 1-bits corresponding to an argument that must be passed by reference.
        /// </summary>
        internal static PhpSignatureMask GetByRefArguments(this IPhpRoutineSymbol routine)
        {
            Contract.ThrowIfNull(routine);

            var mask = new PhpSignatureMask();
            var ps = routine.Parameters;

            int index = 0;

            foreach (ParameterSymbol p in ps)
            {
                if (index == 0 && p.IsImplicitlyDeclared && !p.IsParams)
                {
                    continue;
                }

                if (p.IsParams)
                {
                    if (((ArrayTypeSymbol)p.Type).ElementType.Is_PhpAlias())    // PHP: ... &$p
                    {
                        mask.SetFrom(index++);
                    }
                }
                else
                {
                    mask[index++] =
                        p.RefKind != RefKind.None ||  // C#: ref|out p
                        p.Type.Is_PhpAlias();         // PHP: &$p
                }
            }

            return mask;
        }

        /// <summary>
        /// Gets additional flags of the caller routine.
        /// </summary>
        /// <param name="routine">The routine.</param>
        /// <param name="localaccess">Gets local variables that will be accessed by the routine. <c>NULL</c> if none (a common case).</param>
        public static RoutineFlags InvocationFlags(this IPhpRoutineSymbol routine, out IList<VariableName> localaccess)
        {
            localaccess = null;

            var f = RoutineFlags.None;

            var ps = /*routine is SourceRoutineSymbol sr ? sr.ImplicitParameters :*/ routine.Parameters;
            foreach (var p in ps)
            {
                if (p.IsImplicitlyDeclared)
                {
                    switch (((ParameterSymbol)p).ImportValueAttributeData.Value)
                    {
                        case ImportValueAttributeData.ValueSpec.CallerArgs:
                            f |= RoutineFlags.UsesArgs;
                            break;
                        case ImportValueAttributeData.ValueSpec.Locals:
                            f |= RoutineFlags.UsesLocals;
                            break;
                        case ImportValueAttributeData.ValueSpec.CallerStaticClass:
                            f |= RoutineFlags.UsesLateStatic;
                            break;
                        case ImportValueAttributeData.ValueSpec.LocalVariable:
                            if (p.Type.Is_PhpAlias())
                            {
                                if (localaccess == null) localaccess = new List<VariableName>(1);
                                localaccess.Add(new VariableName(p.Name));
                            }
                            break;
                    }
                }
                else
                {
                    // implicit parameters are at begining only
                    break;
                }
            }

            return f;
        }

        /// <summary>
        /// Determines if the given routine uses late static binding i.e. `static` keyword or it forwards the late static type.
        /// </summary>
        internal static bool HasLateStaticBoundParam(this MethodSymbol method)
        {
            if (method.IsErrorMethodOrNull() || !method.IsStatic)
            {
                return false;
            }

            if (method.OriginalDefinition is SourceRoutineSymbol sr)
            {
                return sr.RequiresLateStaticBoundParam;
            }

            // PE method
            return method.LateStaticParameter() != null;
        }

        /// <summary>
        /// Gets the special <c>&lt;static&gt;</c> parameter of given method if any. Otherwise <c>null</c>.
        /// </summary>
        internal static ParameterSymbol LateStaticParameter(this MethodSymbol method)
        {
            // in source routines, we can iterate just the implicit parameters and not populating the source parameters
            var ps = method is SourceRoutineSymbol sr ? sr.ImplicitParameters : method.Parameters;

            foreach (var p in ps)
            {
                if (SpecialParameterSymbol.IsLateStaticParameter(p))
                {
                    return p;
                }
                else if (!p.IsImplicitlyDeclared)
                {
                    break;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets value indicating the routine was found containing <c>yield</c>
        /// hence it is considered as a generator state machine method.
        /// </summary>
        /// <param name="routine">The analysed routine.</param>
        /// <returns>Value indicating the routine gets a generator.</returns>
        internal static bool IsGeneratorMethod(this SourceRoutineSymbol routine) => (routine.Flags & RoutineFlags.IsGenerator) != 0;

        /// <summary>
        /// Gets enumeration of all routines (global code, functions and methods) within the file.
        /// </summary>
        internal static IEnumerable<SourceRoutineSymbol> GetAllRoutines(this SourceFileSymbol file)
        {
            // all functions + global code + methods + lambdas
            var funcs = file.Functions.Cast<SourceRoutineSymbol>();
            var main = (SourceRoutineSymbol)file.MainMethod;

            var types = file.ContainedTypes.SelectMany(t => t.AllReachableVersions());
            var methods = types.SelectMany(f => f.GetMembers().OfType<SourceRoutineSymbol>());
            var lambdas = ((ILambdaContainerSymbol)file).Lambdas;

            return funcs.Concat(main).Concat(methods).Concat(lambdas);
        }

        /// <summary>
        /// Gets PHPDoc assoviated with given source symbol.
        /// </summary>
        internal static bool TryGetPHPDocBlock(this Symbol symbol, out PHPDocBlock phpdoc)
        {
            phpdoc = symbol?.OriginalDefinition switch
            {
                SourceRoutineSymbol routine => routine.PHPDocBlock,
                SourceFieldSymbol field => field.PHPDocBlock,
                SourceTypeSymbol type => type.Syntax.PHPDoc,
                _ => null
            };

            return phpdoc != null;
        }

        /// <summary>
        /// The resource contains an additional textual metadata to be used by the runtime if needed (JSON format).
        /// The resource is indexed by the symbol full metadata name.
        /// Can be <c>null</c>.
        /// </summary>
        internal static string GetSymbolMetadataResource(this Symbol symbol)
        {
            // CONSIDER: not for private/internal symbols ?

            if (TryGetPHPDocBlock(symbol, out var phpdoc) && symbol.GetContainingFileSymbol() is SourceFileSymbol file)
            {
                var phpdoctext = file.SyntaxTree.GetText().ToString(phpdoc.Span.ToTextSpan());

                // cleanup the phpdoctext
                // trim lines:
                var result = new StringBuilder(phpdoctext.Length);

                using (var reader = new StringReader(phpdoctext))
                {
                    for (; ; )
                    {
                        var line = reader.ReadLine();
                        if (line != null)
                        {
                            if (result.Length != 0)
                                result.Append("\n ");

                            result.Append(line.Trim());
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                ////
                //var stream = new System.IO.StringWriter();
                //using (var writer = new JsonWriter(stream))
                //{
                //    writer.WriteObjectStart();
                //    writer.Write("doc", phpdoctext);
                //    // TODO: location, return type, ...
                //    writer.WriteObjectEnd();
                //}

                //return stream.ToString();

                // create "smaller" json // CONSIDER: use some library that allows to skip whitespaces, newtonsoft or netcore 3.0
                result.Replace("\\", "\\\\").Replace("\n", "\\n").Replace("\r", "").Replace("\"", "\\\"");  // naively escape
                return $"{{\"doc\":\"{(result.ToString())}\"}}";
            }

            // no metadata
            return null;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs(15,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs(5,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs(130,56): error CS0136: A local or parameter named 'r' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs(15,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Symbols\Php\PhpRoutineSymbolExtensions.cs(5,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.Text;
using Devsense.PHP.Text;
using Devsense.PHP.Syntax.Ast;
using Devsense.PHP.Syntax;
using System.Diagnostics;
using System.Collections.Immutable;
using Pchp.CodeAnalysis.Symbols;
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.Semantics;
using System.Runtime.InteropServices;

namespace Pchp.CodeAnalysis
{
    public static class AstUtils
    {
        internal static Operations CompoundOpToBinaryOp(Operations op)
        {
            switch (op)
            {
                case Operations.AssignAdd: return Operations.Add;
                case Operations.AssignAnd: return Operations.BitAnd;
                case Operations.AssignAppend: return Operations.Concat;
                case Operations.AssignDiv: return Operations.Div;
                case Operations.AssignMod: return Operations.Mod;
                case Operations.AssignMul: return Operations.Mul;
                case Operations.AssignOr: return Operations.BitOr;
                case Operations.AssignPow: return Operations.Pow;
                case Operations.AssignPrepend: return Operations.Concat;
                case Operations.AssignShiftLeft: return Operations.ShiftLeft;
                case Operations.AssignShiftRight: return Operations.ShiftRight;
                case Operations.AssignSub: return Operations.Sub;
                case Operations.AssignXor: return Operations.BitXor;
                case Operations.AssignCoalesce: return Operations.Coalesce;
                default:
                    throw Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(op);
            }
        }

        internal static Operations BinaryToCompoundOp(Operations op)
        {
            switch (op)
            {
                case Operations.Add: return Operations.AssignAdd;
                case Operations.BitAnd: return Operations.AssignAnd;
                case Operations.Concat: return Operations.AssignAppend;
                case Operations.Div: return Operations.AssignDiv;
                case Operations.Mod: return Operations.AssignMod;
                case Operations.Mul: return Operations.AssignMul;
                case Operations.BitOr: return Operations.AssignOr;
                case Operations.Pow: return Operations.AssignPow;
                case Operations.ShiftLeft: return Operations.AssignShiftLeft;
                case Operations.ShiftRight: return Operations.AssignShiftRight;
                case Operations.Sub: return Operations.AssignSub;
                case Operations.BitXor: return Operations.AssignXor;
                case Operations.Coalesce: return Operations.AssignCoalesce;
                default:
                    throw Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(op);
            }
        }

        /// <summary>
        /// Fixes <see cref="ItemUse"/> so it propagates correctly through our visitor.
        /// </summary>
        /// <remarks><c>IsMemberOf</c> will be set on Array, not ItemUse itself.</remarks>
        public static void PatchItemUse(ItemUse item)
        {
            if (item.IsMemberOf != null)
            {
                var varlike = item.Array as VarLikeConstructUse;

                Debug.Assert(varlike != null);
                Debug.Assert(varlike.IsMemberOf == null);

                // fix this ast weirdness:
                varlike.IsMemberOf = item.IsMemberOf;
                item.IsMemberOf = null;
            }
        }

        /// <summary>
        /// Creates new struct with updated <see cref="CompleteToken.TokenText"/>.
        /// </summary>
        public static CompleteToken WithTokenText(this CompleteToken t, string text)
        {
            return new CompleteToken(t.Token, t.TokenValue, t.TokenPosition, text);
        }

        /// <summary>
        /// Creates new struct with updated <see cref="CompleteToken.TokenText"/>.
        /// </summary>
        public static CompleteToken WithToken(this CompleteToken t, Tokens token)
        {
            return new CompleteToken(token, t.TokenValue, t.TokenPosition, t.TokenText);
        }

        /// <summary>
        /// Gets value indicating the token is an ignored token - whitespace or comment.
        /// </summary>
        public static bool IsWhitespace(this CompleteToken t) => t.Token == Tokens.T_WHITESPACE || t.Token == Tokens.T_COMMENT; // not T_DOC_COMMENT

        /// <summary>
        /// Determines whether method has <c>$this</c> variable.
        /// </summary>
        public static bool HasThisVariable(MethodDecl method)
        {
            return method != null && (method.Modifiers & PhpMemberAttributes.Static) == 0;
        }

        public static Span BodySpanOrInvalid(this AstNode routine)
        {
            if (routine is FunctionDecl f)
            {
                return f.Body.Span;
            }
            if (routine is MethodDecl m)
            {
                return (m.Body != null) ? m.Body.Span : Span.Invalid;
            }
            if (routine is LambdaFunctionExpr lambda)
            {
                var body = (ILangElement)lambda.Expression ?? lambda.Body;
                return body.Span;
            }
            else
            {
                return Span.Invalid;
            }
        }

        /// <summary>
        /// Gets <see cref="Microsoft.CodeAnalysis.Text.LinePosition"/> from source position.
        /// </summary>
        public static LinePosition LinePosition(this ILineBreaks lines, int pos)
        {
            lines.GetLineColumnFromPosition(pos, out int line, out int col);

            // https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#sequence-points-blob - column must be less than 0x10000
            return new LinePosition(line, Math.Min(col, 0x09999));
        }

        /// <summary>
        /// Gets value indicating this entry will be skipped.
        /// </summary>
        public static bool IsIgnoredEntry(this Devsense.PHP.Phar.Entry entry)
        {
            if (entry.Name.EndsWith(".phpstorm.meta.php"))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Determines whether to treat given PHAR entry as a PHP source file (whether to compile it).
        /// </summary>
        public static bool IsCompileEntry(this Devsense.PHP.Phar.Entry entry)
        {
            // TODO: what entries will be compiled?
            if (entry.IsDirectory)
            {
                return false;
            }

            if (entry.Name.EndsWith(".php"))
            {
                return true;
            }

            if (string.IsNullOrEmpty(entry.Code))
            {
                return false;
            }

            var ext = System.IO.Path.GetExtension(entry.Name);
            if (string.IsNullOrEmpty(ext) && entry.Code.StartsWith("<?php"))
            {
                return true;
            }

            if (ext == ".php5" || ext == ".inc" || ext == ".module")
            {
                return entry.Code.IndexOf("<?php") >= 0;
            }

            return false;
        }

        /// <summary>
        /// Returns the offset of the location specified by (zero-based) line and character from the start of the file.
        /// In the case of invalid line, -1 is returned.
        /// </summary>
        public static int GetOffset(this PhpSyntaxTree tree, LinePosition linePosition)
        {
            if (linePosition.Line < 0 || linePosition.Line > tree.Source.LineBreaks.Count)
            {
                return -1;
            }

            int lineStart = (linePosition.Line == 0) ? 0 : tree.Source.LineBreaks.EndOfLineBreak(linePosition.Line - 1);
            return lineStart + linePosition.Character;
        }

        /// <summary>
        /// Attribute name determining the field below is app-static instead of context-static.
        /// </summary>
        public const string AppStaticTagName = "@appstatic";

        /// <summary>
        /// Lookups notation determining given field as app-static instead of context-static.
        /// </summary>
        /// <param name="field"></param>
        /// <returns></returns>
        public static bool IsAppStatic(this FieldDeclList field)
        {
            if (field != null && field.Modifiers.IsStatic())
            {
                var phpdoc = field.PHPDoc;
                if (phpdoc != null)
                {
                    return phpdoc.Elements
                        .OfType<PHPDocBlock.UnknownTextTag>()
                        .Any(t => t.TagName.Equals(AppStaticTagName, StringComparison.OrdinalIgnoreCase));
                }
            }

            return false;
        }

        /// <summary>
        /// Wraps given <see cref="Devsense.PHP.Text.Span"/> into <see cref="Microsoft.CodeAnalysis.Text.TextSpan"/> representing the same value.
        /// </summary>
        public static Microsoft.CodeAnalysis.Text.TextSpan ToTextSpan(this Devsense.PHP.Text.Span span)
        {
            return span.IsValid
                ? new Microsoft.CodeAnalysis.Text.TextSpan(span.Start, span.Length)
                : default;
        }

        /// <summary>
        /// Gets text span of given expression.
        /// </summary>
        public static Microsoft.CodeAnalysis.Text.TextSpan GetTextSpan(this BoundExpression expression)
        {
            return expression?.PhpSyntax != null
                ? expression.PhpSyntax.Span.ToTextSpan()
                : default;
        }

        /// <summary>
        /// CLR compliant anonymous class name.
        /// </summary>
        public static string GetAnonymousTypeName(this AnonymousTypeDecl tdecl)
        {
            var fname = System.IO.Path.GetFileName(tdecl.ContainingSourceUnit.FilePath).Replace('.', '_');  // TODO: relative to app root
            // PHP: class@anonymous\0{FULLPATH}{BUFFER_POINTER,X8}
            return $"class@anonymous {fname}{tdecl.Span.Start.ToString("X4")}";
        }

        /// <summary>
        /// Builds qualified name for an anonymous PHP class.
        /// Instead of name provided by parser, we do create our own which is more readable and shorter.
        /// </summary>
        /// <remarks>Wherever <see cref="AnonymousTypeDecl.QualifiedName"/> would be used, use this method instead.</remarks>
        public static QualifiedName GetAnonymousTypeQualifiedName(this AnonymousTypeDecl tdecl)
        {
            return new QualifiedName(new Name(GetAnonymousTypeName(tdecl)));
        }

        /// <summary>
        /// Traverses AST and finds closest parent element of desired type.
        /// </summary>
        public static T FindParentLangElement<T>(LangElement node) where T : LangElement
        {
            while (node != null && !(node is T))
            {
                node = node.ContainingElement;
            }

            return (T)node;
        }

        /// <summary>
        /// Gets containing routine element (function, method or lambda).
        /// </summary>
        public static LangElement GetContainingRoutine(this LangElement element)
        {
            while (!(element is MethodDecl || element is FunctionDecl || element is LambdaFunctionExpr || element is GlobalCode || element == null))
            {
                element = element.ContainingElement;
            }

            //
            return element;
        }

        public static Microsoft.CodeAnalysis.Text.TextSpan GetDeclareClauseSpan(this DeclareStmt declStmt)
        {
            if (declStmt.Statement is EmptyStmt)
            {
                // declare (...); - return whole span
                return declStmt.Span.ToTextSpan();
            }
            else
            {
                // declare (...) { ... } - return only the span of declare (...)
                int clauseStart = declStmt.Span.Start;
                int blockStart = declStmt.Statement.Span.Start;
                var searchSpan = new Span(clauseStart, blockStart - clauseStart);
                string searchText = declStmt.ContainingSourceUnit.GetSourceCode(searchSpan);
                int clauseLength = searchText.LastIndexOf(')') + 1;

                return new Microsoft.CodeAnalysis.Text.TextSpan(clauseStart, clauseLength);
            }
        }

        /// <summary>
        /// Gets the span of "as" keyword in between enumeree and variables.
        /// </summary>
        public static Microsoft.CodeAnalysis.Text.TextSpan GetMoveNextSpan(this ForeachStmt stmt)
        {
            Debug.Assert(stmt != null);

            // foreach(enumeree as key => value)
            // foreach(enumeree as value)

            var enumeree = stmt.Enumeree.Span;
            if (enumeree.IsValid)
            {
                // key => value
                // value
                var variable = (stmt.KeyVariable ?? stmt.ValueVariable).Span;
                if (variable.IsValid)
                {
                    return Span.FromBounds(enumeree.End + 1, variable.Start - 1).ToTextSpan();
                }
            }

            // spans are not available
            return default;
        }

        sealed class ElementVisitor<TElement> : TreeVisitor
            where TElement : LangElement
        {
            readonly Func<LangElement, bool> _acceptPredicate;

            public List<TElement> Result { get; } = new List<TElement>();

            public ElementVisitor(Func<LangElement, bool> acceptPredicate)
            {
                _acceptPredicate = acceptPredicate;
            }

            public override void VisitElement(LangElement element)
            {
                if (element is TElement x)
                {
                    Result.Add(x);
                }

                if (_acceptPredicate(element))
                {
                    base.VisitElement(element);
                }
            }
        }

        /// <summary>
        /// Gets all elements of given type.
        /// </summary>
        public static List<TElement> SelectElements<TElement>(this LangElement root, Func<LangElement, bool> acceptPredicate)
            where TElement : LangElement
        {
            var visitor = new ElementVisitor<TElement>(acceptPredicate);
            visitor.VisitElement(root);
            return visitor.Result;
        }

        /// <summary>
        /// Gets all occurences of <see cref="DirectVarUse"/> in given scope.
        /// Ignores autoglobals and $this.
        /// </summary>
        public static IEnumerable<DirectVarUse> SelectLocalVariables(this LangElement root)
        {
            return root.SelectElements<DirectVarUse>(
                scope => !(scope is FunctionDecl || scope is ILambdaExpression || scope is TypeDecl || scope is MethodDecl) || scope == root)
                .Where(dvar => dvar.IsMemberOf == null && !dvar.VarName.IsAutoGlobal && !dvar.VarName.IsThisVariableName);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.Text;
using Devsense.PHP.Text;
using Devsense.PHP.Syntax.Ast;
using Devsense.PHP.Syntax;
using System.Diagnostics;
using System.Collections.Immutable;
using Pchp.CodeAnalysis.Symbols;
using Microsoft.CodeAnalysis;
using Pchp.CodeAnalysis.Semantics;
using System.Runtime.InteropServices;

namespace Pchp.CodeAnalysis
{
    public static class AstUtils
    {
        internal static Operations CompoundOpToBinaryOp(Operations op)
        {
            switch (op)
            {
                case Operations.AssignAdd: return Operations.Add;
                case Operations.AssignAnd: return Operations.BitAnd;
                case Operations.AssignAppend: return Operations.Concat;
                case Operations.AssignDiv: return Operations.Div;
                case Operations.AssignMod: return Operations.Mod;
                case Operations.AssignMul: return Operations.Mul;
                case Operations.AssignOr: return Operations.BitOr;
                case Operations.AssignPow: return Operations.Pow;
                case Operations.AssignPrepend: return Operations.Concat;
                case Operations.AssignShiftLeft: return Operations.ShiftLeft;
                case Operations.AssignShiftRight: return Operations.ShiftRight;
                case Operations.AssignSub: return Operations.Sub;
                case Operations.AssignXor: return Operations.BitXor;
                case Operations.AssignCoalesce: return Operations.Coalesce;
                default:
                    throw Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(op);
            }
        }

        internal static Operations BinaryToCompoundOp(Operations op)
        {
            switch (op)
            {
                case Operations.Add: return Operations.AssignAdd;
                case Operations.BitAnd: return Operations.AssignAnd;
                case Operations.Concat: return Operations.AssignAppend;
                case Operations.Div: return Operations.AssignDiv;
                case Operations.Mod: return Operations.AssignMod;
                case Operations.Mul: return Operations.AssignMul;
                case Operations.BitOr: return Operations.AssignOr;
                case Operations.Pow: return Operations.AssignPow;
                case Operations.ShiftLeft: return Operations.AssignShiftLeft;
                case Operations.ShiftRight: return Operations.AssignShiftRight;
                case Operations.Sub: return Operations.AssignSub;
                case Operations.BitXor: return Operations.AssignXor;
                case Operations.Coalesce: return Operations.AssignCoalesce;
                default:
                    throw Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(op);
            }
        }

        /// <summary>
        /// Fixes <see cref="ItemUse"/> so it propagates correctly through our visitor.
        /// </summary>
        /// <remarks><c>IsMemberOf</c> will be set on Array, not ItemUse itself.</remarks>
        public static void PatchItemUse(ItemUse item)
        {
            if (item.IsMemberOf != null)
            {

                Debug.Assert(item.Array is VarLikeConstructUse varlike);
                Debug.Assert(varlike.IsMemberOf == null);

                // fix this ast weirdness:
                varlike.IsMemberOf = item.IsMemberOf;
                item.IsMemberOf = null;
            }
        }

        /// <summary>
        /// Creates new struct with updated <see cref="CompleteToken.TokenText"/>.
        /// </summary>
        public static CompleteToken WithTokenText(this CompleteToken t, string text)
        {
            return new CompleteToken(t.Token, t.TokenValue, t.TokenPosition, text);
        }

        /// <summary>
        /// Creates new struct with updated <see cref="CompleteToken.TokenText"/>.
        /// </summary>
        public static CompleteToken WithToken(this CompleteToken t, Tokens token)
        {
            return new CompleteToken(token, t.TokenValue, t.TokenPosition, t.TokenText);
        }

        /// <summary>
        /// Gets value indicating the token is an ignored token - whitespace or comment.
        /// </summary>
        public static bool IsWhitespace(this CompleteToken t) => t.Token == Tokens.T_WHITESPACE || t.Token == Tokens.T_COMMENT; // not T_DOC_COMMENT

        /// <summary>
        /// Determines whether method has <c>$this</c> variable.
        /// </summary>
        public static bool HasThisVariable(MethodDecl method)
        {
            return method != null && (method.Modifiers & PhpMemberAttributes.Static) == 0;
        }

        public static Span BodySpanOrInvalid(this AstNode routine)
        {
            if (routine is FunctionDecl f)
            {
                return f.Body.Span;
            }
            if (routine is MethodDecl m)
            {
                return (m.Body != null) ? m.Body.Span : Span.Invalid;
            }
            if (routine is LambdaFunctionExpr lambda)
            {
                var body = (ILangElement)lambda.Expression ?? lambda.Body;
                return body.Span;
            }
            else
            {
                return Span.Invalid;
            }
        }

        /// <summary>
        /// Gets <see cref="Microsoft.CodeAnalysis.Text.LinePosition"/> from source position.
        /// </summary>
        public static LinePosition LinePosition(this ILineBreaks lines, int pos)
        {
            lines.GetLineColumnFromPosition(pos, out int line, out int col);

            // https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#sequence-points-blob - column must be less than 0x10000
            return new LinePosition(line, Math.Min(col, 0x09999));
        }

        /// <summary>
        /// Gets value indicating this entry will be skipped.
        /// </summary>
        public static bool IsIgnoredEntry(this Devsense.PHP.Phar.Entry entry)
        {
            if (entry.Name.EndsWith(".phpstorm.meta.php"))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Determines whether to treat given PHAR entry as a PHP source file (whether to compile it).
        /// </summary>
        public static bool IsCompileEntry(this Devsense.PHP.Phar.Entry entry)
        {
            // TODO: what entries will be compiled?
            if (entry.IsDirectory)
            {
                return false;
            }

            if (entry.Name.EndsWith(".php"))
            {
                return true;
            }

            if (string.IsNullOrEmpty(entry.Code))
            {
                return false;
            }

            var ext = System.IO.Path.GetExtension(entry.Name);
            if (string.IsNullOrEmpty(ext) && entry.Code.StartsWith("<?php"))
            {
                return true;
            }

            if (ext == ".php5" || ext == ".inc" || ext == ".module")
            {
                return entry.Code.IndexOf("<?php") >= 0;
            }

            return false;
        }

        /// <summary>
        /// Returns the offset of the location specified by (zero-based) line and character from the start of the file.
        /// In the case of invalid line, -1 is returned.
        /// </summary>
        public static int GetOffset(this PhpSyntaxTree tree, LinePosition linePosition)
        {
            if (linePosition.Line < 0 || linePosition.Line > tree.Source.LineBreaks.Count)
            {
                return -1;
            }

            int lineStart = (linePosition.Line == 0) ? 0 : tree.Source.LineBreaks.EndOfLineBreak(linePosition.Line - 1);
            return lineStart + linePosition.Character;
        }

        /// <summary>
        /// Attribute name determining the field below is app-static instead of context-static.
        /// </summary>
        public const string AppStaticTagName = "@appstatic";

        /// <summary>
        /// Lookups notation determining given field as app-static instead of context-static.
        /// </summary>
        /// <param name="field"></param>
        /// <returns></returns>
        public static bool IsAppStatic(this FieldDeclList field)
        {
            if (field != null && field.Modifiers.IsStatic())
            {
                var phpdoc = field.PHPDoc;
                if (phpdoc != null)
                {
                    return phpdoc.Elements
                        .OfType<PHPDocBlock.UnknownTextTag>()
                        .Any(t => t.TagName.Equals(AppStaticTagName, StringComparison.OrdinalIgnoreCase));
                }
            }

            return false;
        }

        /// <summary>
        /// Wraps given <see cref="Devsense.PHP.Text.Span"/> into <see cref="Microsoft.CodeAnalysis.Text.TextSpan"/> representing the same value.
        /// </summary>
        public static Microsoft.CodeAnalysis.Text.TextSpan ToTextSpan(this Devsense.PHP.Text.Span span)
        {
            return span.IsValid
                ? new Microsoft.CodeAnalysis.Text.TextSpan(span.Start, span.Length)
                : default;
        }

        /// <summary>
        /// Gets text span of given expression.
        /// </summary>
        public static Microsoft.CodeAnalysis.Text.TextSpan GetTextSpan(this BoundExpression expression)
        {
            return expression?.PhpSyntax != null
                ? expression.PhpSyntax.Span.ToTextSpan()
                : default;
        }

        /// <summary>
        /// CLR compliant anonymous class name.
        /// </summary>
        public static string GetAnonymousTypeName(this AnonymousTypeDecl tdecl)
        {
            var fname = System.IO.Path.GetFileName(tdecl.ContainingSourceUnit.FilePath).Replace('.', '_');  // TODO: relative to app root
            // PHP: class@anonymous\0{FULLPATH}{BUFFER_POINTER,X8}
            return $"class@anonymous {fname}{tdecl.Span.Start.ToString("X4")}";
        }

        /// <summary>
        /// Builds qualified name for an anonymous PHP class.
        /// Instead of name provided by parser, we do create our own which is more readable and shorter.
        /// </summary>
        /// <remarks>Wherever <see cref="AnonymousTypeDecl.QualifiedName"/> would be used, use this method instead.</remarks>
        public static QualifiedName GetAnonymousTypeQualifiedName(this AnonymousTypeDecl tdecl)
        {
            return new QualifiedName(new Name(GetAnonymousTypeName(tdecl)));
        }

        /// <summary>
        /// Traverses AST and finds closest parent element of desired type.
        /// </summary>
        public static T FindParentLangElement<T>(LangElement node) where T : LangElement
        {
            while (node != null && !(node is T))
            {
                node = node.ContainingElement;
            }

            return (T)node;
        }

        /// <summary>
        /// Gets containing routine element (function, method or lambda).
        /// </summary>
        public static LangElement GetContainingRoutine(this LangElement element)
        {
            while (!(element is MethodDecl || element is FunctionDecl || element is LambdaFunctionExpr || element is GlobalCode || element == null))
            {
                element = element.ContainingElement;
            }

            //
            return element;
        }

        public static Microsoft.CodeAnalysis.Text.TextSpan GetDeclareClauseSpan(this DeclareStmt declStmt)
        {
            if (declStmt.Statement is EmptyStmt)
            {
                // declare (...); - return whole span
                return declStmt.Span.ToTextSpan();
            }
            else
            {
                // declare (...) { ... } - return only the span of declare (...)
                int clauseStart = declStmt.Span.Start;
                int blockStart = declStmt.Statement.Span.Start;
                var searchSpan = new Span(clauseStart, blockStart - clauseStart);
                string searchText = declStmt.ContainingSourceUnit.GetSourceCode(searchSpan);
                int clauseLength = searchText.LastIndexOf(')') + 1;

                return new Microsoft.CodeAnalysis.Text.TextSpan(clauseStart, clauseLength);
            }
        }

        /// <summary>
        /// Gets the span of "as" keyword in between enumeree and variables.
        /// </summary>
        public static Microsoft.CodeAnalysis.Text.TextSpan GetMoveNextSpan(this ForeachStmt stmt)
        {
            Debug.Assert(stmt != null);

            // foreach(enumeree as key => value)
            // foreach(enumeree as value)

            var enumeree = stmt.Enumeree.Span;
            if (enumeree.IsValid)
            {
                // key => value
                // value
                var variable = (stmt.KeyVariable ?? stmt.ValueVariable).Span;
                if (variable.IsValid)
                {
                    return Span.FromBounds(enumeree.End + 1, variable.Start - 1).ToTextSpan();
                }
            }

            // spans are not available
            return default;
        }

        sealed class ElementVisitor<TElement> : TreeVisitor
            where TElement : LangElement
        {
            readonly Func<LangElement, bool> _acceptPredicate;

            public List<TElement> Result { get; } = new List<TElement>();

            public ElementVisitor(Func<LangElement, bool> acceptPredicate)
            {
                _acceptPredicate = acceptPredicate;
            }

            public override void VisitElement(LangElement element)
            {
                if (element is TElement x)
                {
                    Result.Add(x);
                }

                if (_acceptPredicate(element))
                {
                    base.VisitElement(element);
                }
            }
        }

        /// <summary>
        /// Gets all elements of given type.
        /// </summary>
        public static List<TElement> SelectElements<TElement>(this LangElement root, Func<LangElement, bool> acceptPredicate)
            where TElement : LangElement
        {
            var visitor = new ElementVisitor<TElement>(acceptPredicate);
            visitor.VisitElement(root);
            return visitor.Result;
        }

        /// <summary>
        /// Gets all occurences of <see cref="DirectVarUse"/> in given scope.
        /// Ignores autoglobals and $this.
        /// </summary>
        public static IEnumerable<DirectVarUse> SelectLocalVariables(this LangElement root)
        {
            return root.SelectElements<DirectVarUse>(
                scope => !(scope is FunctionDecl || scope is ILambdaExpression || scope is TypeDecl || scope is MethodDecl) || scope == root)
                .Where(dvar => dvar.IsMemberOf == null && !dvar.VarName.IsAutoGlobal && !dvar.VarName.IsThisVariableName);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(15,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(4,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(5,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(76,30): error CS0165: Use of unassigned local variable 'varlike',D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(15,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(4,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\AstUtils.cs(5,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 13 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

namespace Pchp.CodeAnalysis
{
    internal static class ConstantValueExtensions
    {
        /// <summary>
        /// Tries to convert <paramref name="value"/> to a <see cref="ConstantValue"/> if possible.
        /// Argument that doesn't have value or values which cannot be represented as <see cref="ConstantValue"/> causes a <c>null</c> reference to be returned.
        /// </summary>
        /// <param name="value">Optional boced value.</param>
        /// <returns><see cref="ConstantValue"/> instance if possible. Otherwise a <c>null</c> reference.</returns>
        public static ConstantValue ToConstantValueOrNull(this Optional<object> value)
        {
            if (value.HasValue)
            {
                var obj = value.Value;
                if (obj == null) return ConstantValue.Null;
                if (obj is int) return ConstantValue.Create((int)obj);
                if (obj is long) return ConstantValue.Create((long)obj);
                if (obj is string) return ConstantValue.Create((string)obj);
                if (obj is bool) return ConstantValue.Create((bool)obj);
                if (obj is double) return ConstantValue.Create((double)obj);
                if (obj is float) return ConstantValue.Create((float)obj);
                if (obj is decimal) return ConstantValue.Create((decimal)obj);
                if (obj is ulong) return ConstantValue.Create((ulong)obj);
                if (obj is uint) return ConstantValue.Create((uint)obj);
                if (obj is sbyte) return ConstantValue.Create((sbyte)obj);
                if (obj is short) return ConstantValue.Create((short)obj);
                if (obj is DateTime) return ConstantValue.Create((DateTime)obj);
            }

            return null;
        }

        /// <summary>
        /// Gets value indicating the constant value is set and its value is <c>null</c>.
        /// </summary>
        public static bool IsNull(this Optional<object> value)
        {
            return value.HasValue && ReferenceEquals(value.Value, null);
        }

        /// <summary>
        /// Gets value indicating the given constant is number zero.
        /// </summary>
        public static bool IsZero(this Optional<object> value)
        {
            if (value.HasValue)
            {
                var obj = value.Value;
                if (obj is long l) return l == 0L;
                if (obj is int i) return i == 0;
                if (obj is double d) return d == 0.0;
            }

            return false;
        }

        /// <summary>
        /// Determines whether the specified optional value is equal to the current one.
        /// If <see cref="Optional{T}.HasValue"/> of both is set to false, they are considered equal.
        /// </summary>
        public static bool EqualsOptional(this Optional<object> value, Optional<object> other)
        {
            return
                (value.HasValue == other.HasValue) &&
                (value.HasValue == false || Equals(value.Value, other.Value));
        }

        /// <summary>
        /// PHP safe implicit conversion to <c>long</c> (null|long|double to long).
        /// </summary>
        public static bool TryConvertToLong(this ConstantValue value, out long result)
        {
            result = 0;

            if (value == null) return false;
            else if (value.IsNull) result = 0;
            else if (value.IsIntegral) result = value.Int64Value;
            else if (value.IsFloating) result = (long)value.DoubleValue;
            else
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// PHP safe implicit conversion to <c>bool</c> if the value is known.
        /// </summary>
        public static bool TryConvertToBool(this Optional<object> value, out bool result)
        {
            if (!value.HasValue)
            {
                result = false;
                return false;
            }

            var obj = value.Value;

            if (obj == null) result = false;
            else if (obj is bool) result = (bool)obj;
            else if (obj is int) result = (int)obj != 0;
            else if (obj is long) result = (long)obj != 0;
            else if (obj is string) result = StringToBoolean((string)obj);
            else if (obj is double) result = (double)obj != 0.0;
            else if (obj is float) result = (float)obj != 0;
            else if (obj is decimal) result = (decimal)obj != 0;
            else if (obj is ulong) result = (ulong)obj != 0;
            else if (obj is uint) result = (uint)obj != 0;
            else if (obj is sbyte) result = (sbyte)obj != 0;
            else if (obj is short) result = (short)obj != 0;
            else
            {
                result = false;
                return false;
            }

            //
            return true;
        }

        /// <summary>
        /// PHP safe implicit conversion to <c>long</c> if the value is known.
        /// </summary>
        public static bool TryConvertToLong(this Optional<object> value, out long result)
        {
                result = 0;

            if (!value.HasValue)
            {
                return false;
            }

            var obj = value.Value;

            if (obj == null) result = 0;
            else if (obj is bool) result = (bool)obj ? 1 : 0;
            else if (obj is int) result = (int)obj;
            else if (obj is long) result = (long)obj;
            else if (obj is string && long.TryParse((string)obj, out result)) { }
            else if (obj is double) result = (long)(double)obj;
            else if (obj is float) result = (long)(float)obj;
            else if (obj is uint) result = (uint)obj;
            else if (obj is sbyte) result = (sbyte)obj;
            else if (obj is short) result = (short)obj;
            else
            {
                return false;
            }

            //
            return true;
        }

        public static bool TryConvertToString(this Optional<object> value, out string result)
        {
            result = null;

            if (value.HasValue)
            {
                var obj = value.Value;

                if (obj == null) result = string.Empty;
                else if (obj is string str) result = str;
                else if (obj is long l) result = l.ToString(CultureInfo.InvariantCulture);
                else if (obj is bool b) result = b ? "1" : string.Empty;
                else if (obj is int i) result = i.ToString(CultureInfo.InvariantCulture);
                // else if (obj is double d) result = d.ToString(CultureInfo.InvariantCulture) // NOTE: NegativeInfinitySymbol = "-INF", PositiveInfinitySymbol = "INF", NaNSymbol = "NAN"
            }

            return result != null;
        }

        static bool StringToBoolean(string value)
        {
            return !string.IsNullOrEmpty(value) && value != "0";
        }

        /// <summary>Boxed <c>boolean</c> to be re-used.</summary>
        readonly static object s_true = true;
        /// <summary>Boxed <c>boolean</c> to be re-used.</summary>
        readonly static object s_false = false;

        readonly static object s_long_zero = 0L;

        /// <summary>
        /// Boxes <see cref="bool"/> into object without memory allocation.
        /// </summary>
        public static object AsObject(this bool b) => b ? s_true : s_false;

        /// <summary>
        /// Gets <see cref="Optional{Object}"/> of <see cref="bool"/>.
        /// This method does not allocate a new boolean on heap.
        /// </summary>
        public static Optional<object> AsOptional(this bool b) => new Optional<object>(AsObject(b));

        /// <summary>
        /// Gets <see cref="Optional{Object}"/> of <see cref="long"/>.
        /// </summary>
        public static Optional<object> AsOptional(this long l) => new Optional<object>(l == 0L ? s_long_zero : (object)l);

        /// <summary>
        /// Checks if <paramref name="optional"/> contains a boolean value. If so, it retrieves it in
        /// <paramref name="value"/> and return TRUE. Otherwise, returns FALSE.
        /// </summary>
        public static bool IsBool(this Optional<object> optional, out bool value)
        {
            if (optional.HasValue && optional.Value is bool optValue)
            {
                value = optValue;
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        /// <summary>
        /// Checks if <paramref name="optional"/> contains a long or int value. If so, it retrieves it as long
        /// (possibly converting from int) in <paramref name="value"/> and returns TRUE. Otherwise, returns FALSE.
        /// </summary>
        public static bool IsInteger(this Optional<object> optional, out long value)
        {
            if (optional.HasValue)
            {
                var obj = optional.Value;
                if (obj is long l) { value = l; return true; }
                if (obj is int i) { value = i; return true; }
            }

            value = default;
            return false;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

namespace Pchp.CodeAnalysis
{
    internal static class ConstantValueExtensions
    {
        /// <summary>
        /// Tries to convert <paramref name="value"/> to a <see cref="ConstantValue"/> if possible.
        /// Argument that doesn't have value or values which cannot be represented as <see cref="ConstantValue"/> causes a <c>null</c> reference to be returned.
        /// </summary>
        /// <param name="value">Optional boced value.</param>
        /// <returns><see cref="ConstantValue"/> instance if possible. Otherwise a <c>null</c> reference.</returns>
        public static ConstantValue ToConstantValueOrNull(this Optional<object> value)
        {
            if (value.HasValue)
            {
                var obj = value.Value;
                if (obj == null) return ConstantValue.Null;
                if (obj is int i) return ConstantValue.Create(i);
                if (obj is long l) return ConstantValue.Create(l);
                if (obj is string s) return ConstantValue.Create(s);
                if (obj is bool b) return ConstantValue.Create(b);
                if (obj is double d) return ConstantValue.Create(d);
                if (obj is float f) return ConstantValue.Create(f);
                if (obj is decimal d) return ConstantValue.Create(d);
                if (obj is ulong ul) return ConstantValue.Create(ul);
                if (obj is uint ui) return ConstantValue.Create(ui);
                if (obj is sbyte sb) return ConstantValue.Create(sb);
                if (obj is short sh) return ConstantValue.Create(sh);
                if (obj is DateTime dateTime) return ConstantValue.Create(dateTime);
            }

            return null;
        }

        /// <summary>
        /// Gets value indicating the constant value is set and its value is <c>null</c>.
        /// </summary>
        public static bool IsNull(this Optional<object> value)
        {
            return value.HasValue && ReferenceEquals(value.Value, null);
        }

        /// <summary>
        /// Gets value indicating the given constant is number zero.
        /// </summary>
        public static bool IsZero(this Optional<object> value)
        {
            if (value.HasValue)
            {
                var obj = value.Value;
                if (obj is long l) return l == 0L;
                if (obj is int i) return i == 0;
                if (obj is double d) return d == 0.0;
            }

            return false;
        }

        /// <summary>
        /// Determines whether the specified optional value is equal to the current one.
        /// If <see cref="Optional{T}.HasValue"/> of both is set to false, they are considered equal.
        /// </summary>
        public static bool EqualsOptional(this Optional<object> value, Optional<object> other)
        {
            return
                (value.HasValue == other.HasValue) &&
                (value.HasValue == false || Equals(value.Value, other.Value));
        }

        /// <summary>
        /// PHP safe implicit conversion to <c>long</c> (null|long|double to long).
        /// </summary>
        public static bool TryConvertToLong(this ConstantValue value, out long result)
        {
            result = 0;

            if (value == null) return false;
            else if (value.IsNull) result = 0;
            else if (value.IsIntegral) result = value.Int64Value;
            else if (value.IsFloating) result = (long)value.DoubleValue;
            else
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// PHP safe implicit conversion to <c>bool</c> if the value is known.
        /// </summary>
        public static bool TryConvertToBool(this Optional<object> value, out bool result)
        {
            if (!value.HasValue)
            {
                result = false;
                return false;
            }

            var obj = value.Value;

            if (obj == null) result = false;
            else if (obj is bool b) result = b;
            else if (obj is int) result = (int)obj != 0;
            else if (obj is long) result = (long)obj != 0;
            else if (obj is string s) result = StringToBoolean(s);
            else if (obj is double) result = (double)obj != 0.0;
            else if (obj is float) result = (float)obj != 0;
            else if (obj is decimal) result = (decimal)obj != 0;
            else if (obj is ulong) result = (ulong)obj != 0;
            else if (obj is uint) result = (uint)obj != 0;
            else if (obj is sbyte) result = (sbyte)obj != 0;
            else if (obj is short) result = (short)obj != 0;
            else
            {
                result = false;
                return false;
            }

            //
            return true;
        }

        /// <summary>
        /// PHP safe implicit conversion to <c>long</c> if the value is known.
        /// </summary>
        public static bool TryConvertToLong(this Optional<object> value, out long result)
        {
                result = 0;

            if (!value.HasValue)
            {
                return false;
            }

            var obj = value.Value;

            if (obj == null) result = 0;
            else if (obj is bool) result = (bool)obj ? 1 : 0;
            else if (obj is int i) result = i;
            else if (obj is long l) result = l;
            else if (obj is string && long.TryParse((string)obj, out result)) { }
            else if (obj is double) result = (long)(double)obj;
            else if (obj is float) result = (long)(float)obj;
            else if (obj is uint ui) result = ui;
            else if (obj is sbyte sb) result = sb;
            else if (obj is short sh) result = sh;
            else
            {
                return false;
            }

            //
            return true;
        }

        public static bool TryConvertToString(this Optional<object> value, out string result)
        {
            result = null;

            if (value.HasValue)
            {
                var obj = value.Value;

                if (obj == null) result = string.Empty;
                else if (obj is string str) result = str;
                else if (obj is long l) result = l.ToString(CultureInfo.InvariantCulture);
                else if (obj is bool b) result = b ? "1" : string.Empty;
                else if (obj is int i) result = i.ToString(CultureInfo.InvariantCulture);
                // else if (obj is double d) result = d.ToString(CultureInfo.InvariantCulture) // NOTE: NegativeInfinitySymbol = "-INF", PositiveInfinitySymbol = "INF", NaNSymbol = "NAN"
            }

            return result != null;
        }

        static bool StringToBoolean(string value)
        {
            return !string.IsNullOrEmpty(value) && value != "0";
        }

        /// <summary>Boxed <c>boolean</c> to be re-used.</summary>
        readonly static object s_true = true;
        /// <summary>Boxed <c>boolean</c> to be re-used.</summary>
        readonly static object s_false = false;

        readonly static object s_long_zero = 0L;

        /// <summary>
        /// Boxes <see cref="bool"/> into object without memory allocation.
        /// </summary>
        public static object AsObject(this bool b) => b ? s_true : s_false;

        /// <summary>
        /// Gets <see cref="Optional{Object}"/> of <see cref="bool"/>.
        /// This method does not allocate a new boolean on heap.
        /// </summary>
        public static Optional<object> AsOptional(this bool b) => new Optional<object>(AsObject(b));

        /// <summary>
        /// Gets <see cref="Optional{Object}"/> of <see cref="long"/>.
        /// </summary>
        public static Optional<object> AsOptional(this long l) => new Optional<object>(l == 0L ? s_long_zero : (object)l);

        /// <summary>
        /// Checks if <paramref name="optional"/> contains a boolean value. If so, it retrieves it in
        /// <paramref name="value"/> and return TRUE. Otherwise, returns FALSE.
        /// </summary>
        public static bool IsBool(this Optional<object> optional, out bool value)
        {
            if (optional.HasValue && optional.Value is bool optValue)
            {
                value = optValue;
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        /// <summary>
        /// Checks if <paramref name="optional"/> contains a long or int value. If so, it retrieves it as long
        /// (possibly converting from int) in <paramref name="value"/> and returns TRUE. Otherwise, returns FALSE.
        /// </summary>
        public static bool IsInteger(this Optional<object> optional, out long value)
        {
            if (optional.HasValue)
            {
                var obj = optional.Value;
                if (obj is long l) { value = l; return true; }
                if (obj is int i) { value = i; return true; }
            }

            value = default;
            return false;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(4,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(5,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(2,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(30,36): error CS0128: A local variable or function named 'd' is already defined in this scope,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(30,67): error CS0165: Use of unassigned local variable 'd',D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(5,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(2,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Peachpie.CodeAnalysis\Utilities\ConstantValueExtensions.cs(4,1): hidden CS8019: Unnecessary using directive.
######################################################################


