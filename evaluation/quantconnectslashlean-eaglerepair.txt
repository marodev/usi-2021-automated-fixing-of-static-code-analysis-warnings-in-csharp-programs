Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: QuantConnect.Lean.Engine
    #1 Path: D:\a\1\s\Engine\AlgorithmManager.cs, Line: 1012, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\Engine\AlgorithmManager.cs, Line: 795, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\Engine\DataFeeds\AggregationManager.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\Engine\DataFeeds\DataPermissionManager.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\Factories\LiveCustomDataSubscriptionEnumeratorFactory.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\Factories\TimeTriggeredUniverseSubscriptionEnumeratorFactory.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\FuturesChainUniverseDataCollectionAggregatorEnumerator.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\OptionChainUniverseDataCollectionEnumerator.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\QuoteBarFillForwardEnumerator.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\RefreshEnumerator.cs, Line: 115, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #11 Path: D:\a\1\s\Engine\DataFeeds\Enumerators\RefreshEnumerator.cs, Line: 80, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #12 Path: D:\a\1\s\Engine\DataFeeds\LiveTradingDataFeed.cs, Line: 312, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\Engine\DataFeeds\SubscriptionDataReader.cs, Line: 191, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\Engine\DataFeeds\SubscriptionDataReader.cs, Line: 201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\Engine\DataFeeds\SubscriptionDataReader.cs, Line: 211, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\Engine\DataFeeds\SubscriptionDataReader.cs, Line: 221, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\Engine\DataFeeds\SubscriptionDataReader.cs, Line: 522, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #18 Path: D:\a\1\s\Engine\DataFeeds\UniverseSelection.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\Engine\DataFeeds\UniverseSelection.cs, Line: 399, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\Engine\Results\BacktestingResultHandler.cs, Line: 299, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\Engine\Results\LiveTradingResultHandler.cs, Line: 862, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: QuantConnect.Algorithm
    #22 Path: D:\a\1\s\Algorithm\Alphas\AlphaModelExtensions.cs, Line: 29, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\Algorithm\QCAlgorithm.cs, Line: 1732, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\Algorithm\QCAlgorithm.cs, Line: 527, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\Algorithm\QCAlgorithm.Framework.cs, Line: 278, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\Algorithm\QCAlgorithm.Framework.cs, Line: 311, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\Algorithm\QCAlgorithm.Framework.cs, Line: 362, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #28 Path: D:\a\1\s\Algorithm\QCAlgorithm.Framework.cs, Line: 445, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #29 Path: D:\a\1\s\Algorithm\QCAlgorithm.Universe.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\Algorithm\QCAlgorithm.Universe.cs, Line: 564, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: QuantConnect
    #31 Path: D:\a\1\s\Common\Brokerages\FxcmBrokerageModel.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\Common\Brokerages\FxcmBrokerageModel.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\Common\Brokerages\TradingTechnologiesBrokerageModel.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\Common\Brokerages\TradingTechnologiesBrokerageModel.cs, Line: 137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\Common\Data\Auxiliary\FactorFile.cs, Line: 342, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\Common\Data\Auxiliary\FactorFile.cs, Line: 347, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\Common\Data\BaseData.cs, Line: 405, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\Common\Data\BaseData.cs, Line: 411, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\Common\Data\DynamicData.cs, Line: 64, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #40 Path: D:\a\1\s\Common\Data\Slice.cs, Line: 576, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\Common\Extensions.cs, Line: 2499, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\Common\Extensions.cs, Line: 2547, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\Common\Extensions.cs, Line: 333, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\Common\Extensions.cs, Line: 338, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\Common\Extensions.cs, Line: 344, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\Common\Extensions.cs, Line: 349, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\Common\Field.cs, Line: 112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\Common\Orders\OrderTicket.cs, Line: 620, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\Common\Python\PandasData.cs, Line: 391, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\Common\Python\PandasData.cs, Line: 397, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\Common\Scheduling\FluentScheduledEventBuilder.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\Common\Securities\CashAmount.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #53 Path: D:\a\1\s\Common\Securities\CashBuyingPowerModel.cs, Line: 430, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\Common\Securities\DefaultMarginCallModel.cs, Line: 103, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\Common\Securities\DynamicSecurityData.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\Common\Securities\Option\ConstantQLUnderlyingVolatilityEstimator.cs, Line: 46, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #57 Path: D:\a\1\s\Common\Securities\Option\StrategyMatcher\ConstantOptionStrategyLegPredicateReferenceValue.cs, Line: 64, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #58 Path: D:\a\1\s\Common\Securities\Option\StrategyMatcher\ConstantOptionStrategyLegPredicateReferenceValue.cs, Line: 69, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #59 Path: D:\a\1\s\Common\Securities\Option\StrategyMatcher\ConstantOptionStrategyLegPredicateReferenceValue.cs, Line: 74, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #60 Path: D:\a\1\s\Common\Securities\SecurityPortfolioManager.cs, Line: 725, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\Common\Securities\SecurityPortfolioManager.cs, Line: 734, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\Common\Securities\SecurityPortfolioManager.cs, Line: 820, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\Common\Securities\SecurityTransactionManager.cs, Line: 144, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #64 Path: D:\a\1\s\Common\Statistics\Statistics.cs, Line: 528, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #65 Path: D:\a\1\s\Common\Statistics\Statistics.cs, Line: 528, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #66 Path: D:\a\1\s\Common\Statistics\Statistics.cs, Line: 534, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #67 Path: D:\a\1\s\Common\StringExtensions.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\Common\Symbol.cs, Line: 378, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\Common\Symbol.cs, Line: 388, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #70 Path: D:\a\1\s\Common\Symbol.cs, Line: 420, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\Common\Symbol.cs, Line: 425, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\Common\SymbolValueJsonConverter.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\Common\Util\Composer.cs, Line: 222, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #74 Path: D:\a\1\s\Common\Util\Composer.cs, Line: 243, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #75 Path: D:\a\1\s\Common\Util\JsonRoundingConverter.cs, Line: 70, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #76 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #77 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #78 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #80 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 152, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 232, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 245, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 255, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 262, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 267, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 303, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #89 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 310, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #90 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 316, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 326, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 333, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 338, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 374, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #95 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 381, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 387, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 397, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 404, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #99 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 409, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 829, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #101 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #102 Path: D:\a\1\s\Common\Util\LeanData.cs, Line: 89, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: QuantConnect.Indicators
    #103 Path: D:\a\1\s\Indicators\FunctionalIndicator.cs, Line: 87, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #104 Path: D:\a\1\s\Indicators\HeikinAshi.cs, Line: 111, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #105 Path: D:\a\1\s\Indicators\HeikinAshi.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: QuantConnect.Tests
    #106 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 232, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #107 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 233, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #108 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 238, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #109 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 239, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #110 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 300, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #111 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 301, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #112 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 306, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #113 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 307, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #114 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 364, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #115 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 365, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #116 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 371, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #117 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 372, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #118 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 470, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #119 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 471, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #120 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 479, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #121 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 480, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #122 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 503, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #123 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 504, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #124 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 512, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #125 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 513, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #126 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 534, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #127 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 535, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #128 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 540, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #129 Path: D:\a\1\s\Tests\Algorithm\AlgorithmAddDataTests.cs, Line: 541, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #130 Path: D:\a\1\s\Tests\AlgorithmRunner.cs, Line: 203, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #131 Path: D:\a\1\s\Tests\AlgorithmRunner.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\Tests\Brokerages\Binance\BinanceBrokerageTests.cs, Line: 182, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #133 Path: D:\a\1\s\Tests\Brokerages\Binance\BinanceBrokerageTests.cs, Line: 188, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #134 Path: D:\a\1\s\Tests\Brokerages\BrokerageTests.cs, Line: 628, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #135 Path: D:\a\1\s\Tests\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerageDataQueueHandlerTest.cs, Line: 129, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #136 Path: D:\a\1\s\Tests\Common\Securities\FutureMarginBuyingPowerModelTests.cs, Line: 905, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #137 Path: D:\a\1\s\Tests\Common\Securities\TradingCalendarTests.cs, Line: 114, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #138 Path: D:\a\1\s\Tests\Common\Securities\TradingCalendarTests.cs, Line: 122, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #139 Path: D:\a\1\s\Tests\Common\Securities\TradingCalendarTests.cs, Line: 125, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #140 Path: D:\a\1\s\Tests\Common\Statistics\AnnualPerformanceTests.cs, Line: 54, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #141 Path: D:\a\1\s\Tests\Common\Statistics\AnnualPerformanceTests.cs, Line: 70, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #142 Path: D:\a\1\s\Tests\Common\Statistics\AnnualPerformanceTests.cs, Line: 90, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #143 Path: D:\a\1\s\Tests\Common\Statistics\TrackingErrorTests.cs, Line: 49, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #144 Path: D:\a\1\s\Tests\Common\Statistics\TrackingErrorTests.cs, Line: 67, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #145 Path: D:\a\1\s\Tests\Engine\DataFeeds\AggregationManagerTests.cs, Line: 178, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #146 Path: D:\a\1\s\Tests\Engine\DataFeeds\Enumerators\FillForwardEnumeratorTests.cs, Line: 2092, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #147 Path: D:\a\1\s\Tests\Engine\DataFeeds\Enumerators\FillForwardEnumeratorTests.cs, Line: 2125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: QuantConnect.Brokerages
    #148 Path: D:\a\1\s\Brokerages\Bitfinex\BitfinexBrokerage.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #149 Path: D:\a\1\s\Brokerages\Bitfinex\BitfinexSubscriptionManager.cs, Line: 504, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #150 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #151 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #152 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #153 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #154 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #155 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #156 Path: D:\a\1\s\Brokerages\Fxcm\FxcmBrokerage.Messaging.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #157 Path: D:\a\1\s\Brokerages\GDAX\GDAXBrokerage.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #158 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1014, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1730, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1757, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1761, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1765, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1771, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #164 Path: D:\a\1\s\Brokerages\InteractiveBrokers\InteractiveBrokersBrokerage.cs, Line: 1784, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #165 Path: D:\a\1\s\Brokerages\Oanda\RestV20\Client\ApiClient.cs, Line: 234, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #166 Path: D:\a\1\s\Brokerages\Oanda\RestV20\Client\ApiClient.cs, Line: 249, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #167 Path: D:\a\1\s\Brokerages\Oanda\RestV20\Client\ApiClient.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #168 Path: D:\a\1\s\Brokerages\Oanda\RestV20\Session\StreamSession.cs, Line: 81, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #169 Path: D:\a\1\s\Brokerages\Oanda\RestV20\Session\StreamSession.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #170 Path: D:\a\1\s\Brokerages\Tradier\TradierBrokerage.cs, Line: 1037, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #171 Path: D:\a\1\s\Brokerages\Tradier\TradierBrokerage.cs, Line: 1749, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #172 Path: D:\a\1\s\Brokerages\Tradier\TradierBrokerage.cs, Line: 1754, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\Brokerages\Tradier\TradierBrokerage.cs, Line: 1769, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\Brokerages\Tradier\TradierBrokerage.cs, Line: 1774, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\Brokerages\Zerodha\Utils.cs, Line: 147, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #176 Path: D:\a\1\s\Brokerages\Zerodha\ZerodhaBrokerage.cs, Line: 170, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #177 Path: D:\a\1\s\Brokerages\Zerodha\ZerodhaSymbolMapper.cs, Line: 271, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #178 Path: D:\a\1\s\Brokerages\Zerodha\ZerodhaSymbolMapper.cs, Line: 318, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: QuantConnect.Algorithm.CSharp
    #179 Path: D:\a\1\s\Algorithm.CSharp\Alphas\GasAndCrudeOilEnergyCorrelationAlpha.cs, Line: 195, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #180 Path: D:\a\1\s\Algorithm.CSharp\Alphas\GasAndCrudeOilEnergyCorrelationAlpha.cs, Line: 195, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #181 Path: D:\a\1\s\Algorithm.CSharp\Alphas\GreenblattMagicFormulaAlpha.cs, Line: 127, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #182 Path: D:\a\1\s\Algorithm.CSharp\Alphas\GreenblattMagicFormulaAlpha.cs, Line: 127, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #183 Path: D:\a\1\s\Algorithm.CSharp\Alphas\MeanReversionLunchBreakAlpha.cs, Line: 126, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #184 Path: D:\a\1\s\Algorithm.CSharp\Alphas\MeanReversionLunchBreakAlpha.cs, Line: 126, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #185 Path: D:\a\1\s\Algorithm.CSharp\FilteredIdentityAlgorithm.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\Algorithm.CSharp\OptionChainProviderAlgorithm.cs, Line: 66, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #187 Path: D:\a\1\s\Algorithm.CSharp\TickDataFilteringAlgorithm.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: QuantConnect.ToolBox
    #188 Path: D:\a\1\s\ToolBox\AlgoSeekFuturesConverter\AlgoSeekFuturesConverter.cs, Line: 76, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #189 Path: D:\a\1\s\ToolBox\AlgoSeekFuturesConverter\AlgoSeekFuturesConverter.cs, Line: 80, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #190 Path: D:\a\1\s\ToolBox\EstimizeDataDownloader\EstimizeConsensusDataDownloader.cs, Line: 93, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #191 Path: D:\a\1\s\ToolBox\FxcmDownloader\FxcmDataDownloader.cs, Line: 246, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #192 Path: D:\a\1\s\ToolBox\FxcmDownloader\FxcmDataDownloader.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #193 Path: D:\a\1\s\ToolBox\LazyStreamWriter.cs, Line: 56, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #194 Path: D:\a\1\s\ToolBox\LazyStreamWriter.cs, Line: 67, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: QuantConnect.Algorithm.Framework
    #195 Path: D:\a\1\s\Algorithm.Framework\Portfolio\SectorWeightingPortfolioConstructionModel.cs, Line: 156, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: QuantConnect.Report
    #196 Path: D:\a\1\s\Report\DeedleUtil.cs, Line: 187, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #197 Path: D:\a\1\s\Report\PortfolioLooper\PortfolioLooper.cs, Line: 358, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\Report\ReportElements\DrawdownReportElement.cs, Line: 87, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: QuantConnect.Optimizer
    #199 Path: D:\a\1\s\Optimizer\Strategies\EulerSearchOptimizationStrategy.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #200 Path: D:\a\1\s\Optimizer\Strategies\StepBaseOptimizationStrategy.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



--- Rules Summary ---
R8: 106
R4: 47
R5: 25
R7: 10
R6: 10
R2: 2

--- Summary ---
Fixed ReSharper issues: 198
Fixed SonarQube issues: 82
Total fixed issues: 200

Finished in: 33 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using NodaTime;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Data.UniverseSelection;
using QuantConnect.Interfaces;
using QuantConnect.Logging;

namespace QuantConnect.Lean.Engine.DataFeeds
{
    /// <summary>
    /// Instance base class that will provide methods for creating new <see cref="TimeSlice"/>
    /// </summary>
    public class TimeSliceFactory
    {
        private readonly DateTimeZone _timeZone;

        // performance: these collections are not always used so keep a reference to an empty
        // instance to use and avoid unnecessary constructors and allocations
        private readonly List<UpdateData<ISecurityPrice>> _emptyCustom = new List<UpdateData<ISecurityPrice>>();
        private readonly TradeBars _emptyTradeBars = new TradeBars();
        private readonly QuoteBars _emptyQuoteBars = new QuoteBars();
        private readonly Ticks _emptyTicks = new Ticks();
        private readonly Splits _emptySplits = new Splits();
        private readonly Dividends _emptyDividends = new Dividends();
        private readonly Delistings _emptyDelistings = new Delistings();
        private readonly OptionChains _emptyOptionChains = new OptionChains();
        private readonly FuturesChains _emptyFuturesChains = new FuturesChains();
        private readonly SymbolChangedEvents _emptySymbolChangedEvents = new SymbolChangedEvents();

        /// <summary>
        /// Creates a new instance
        /// </summary>
        /// <param name="timeZone">The time zone required for computing algorithm and slice time</param>
        public TimeSliceFactory(DateTimeZone timeZone)
        {
            _timeZone = timeZone;
        }

        /// <summary>
        /// Creates a new empty <see cref="TimeSlice"/> to be used as a time pulse
        /// </summary>
        /// <remarks>The objective of this method is to standardize the time pulse creation</remarks>
        /// <param name="utcDateTime">The UTC frontier date time</param>
        /// <returns>A new <see cref="TimeSlice"/> time pulse</returns>
        public TimeSlice CreateTimePulse(DateTime utcDateTime)
        {
            // setting all data collections to null, this time slice shouldn't be used
            // for its data, we want to see fireworks it someone tries
            return new TimeSlice(utcDateTime,
                0,
                null,
                null,
                null,
                null,
                null,
                SecurityChanges.None,
                null,
                isTimePulse:true);
        }

        /// <summary>
        /// Creates a new <see cref="TimeSlice"/> for the specified time using the specified data
        /// </summary>
        /// <param name="utcDateTime">The UTC frontier date time</param>
        /// <param name="data">The data in this <see cref="TimeSlice"/></param>
        /// <param name="changes">The new changes that are seen in this time slice as a result of universe selection</param>
        /// <param name="universeData"></param>
        /// <returns>A new <see cref="TimeSlice"/> containing the specified data</returns>
        public TimeSlice Create(DateTime utcDateTime,
            List<DataFeedPacket> data,
            SecurityChanges changes,
            Dictionary<Universe, BaseDataCollection> universeData)
        {
            int count = 0;
            var security = new List<UpdateData<ISecurityPrice>>(data.Count);
            List<UpdateData<ISecurityPrice>> custom = null;
            var consolidator = new List<UpdateData<SubscriptionDataConfig>>(data.Count);
            var allDataForAlgorithm = new List<BaseData>(data.Count);
            var optionUnderlyingUpdates = new Dictionary<Symbol, BaseData>();

            Split split;
            Dividend dividend;
            Delisting delisting;
            SymbolChangedEvent symbolChange;

            // we need to be able to reference the slice being created in order to define the
            // evaluation of option price models, so we define a 'future' that can be referenced
            // in the option price model evaluation delegates for each contract
            Slice slice = null;
            var sliceFuture = new Lazy<Slice>(() => slice);

            var algorithmTime = utcDateTime.ConvertFromUtc(_timeZone);
            TradeBars tradeBars = null;
            QuoteBars quoteBars = null;
            Ticks ticks = null;
            Splits splits = null;
            Dividends dividends = null;
            Delistings delistings = null;
            OptionChains optionChains = null;
            FuturesChains futuresChains = null;
            SymbolChangedEvents symbolChanges = null;

            UpdateEmptyCollections(algorithmTime);

            if (universeData.Count > 0)
            {
                // count universe data
                foreach (var kvp in universeData)
                {
                    count += kvp.Value.Data.Count;
                }
            }

            // ensure we read equity data before option data, so we can set the current underlying price
            foreach (var packet in data)
            {
                // filter out packets for removed subscriptions
                if (packet.IsSubscriptionRemoved)
                {
                    continue;
                }

                var list = packet.Data;
                var symbol = packet.Configuration.Symbol;

                if (list.Count == 0) continue;

                // keep count of all data points
                if (list.Count == 1 && list[0] is BaseDataCollection)
                {
                    var baseDataCollectionCount = ((BaseDataCollection)list[0]).Data.Count;
                    if (baseDataCollectionCount == 0)
                    {
                        continue;
                    }
                    count += baseDataCollectionCount;
                }
                else
                {
                    count += list.Count;
                }

                if (!packet.Configuration.IsInternalFeed && packet.Configuration.IsCustomData)
                {
                    if (custom == null)
                    {
                        custom = new List<UpdateData<ISecurityPrice>>(1);
                    }
                    // This is all the custom data
                    custom.Add(new UpdateData<ISecurityPrice>(packet.Security, packet.Configuration.Type, list, packet.Configuration.IsInternalFeed));
                }

                var securityUpdate = new List<BaseData>(list.Count);
                var consolidatorUpdate = new List<BaseData>(list.Count);
                var containsFillForwardData = false;
                for (var i = 0; i < list.Count; i++)
                {
                    var baseData = list[i];
                    if (!packet.Configuration.IsInternalFeed)
                    {
                        // this is all the data that goes into the algorithm
                        allDataForAlgorithm.Add(baseData);
                    }

                    containsFillForwardData |= baseData.IsFillForward;

                    // don't add internal feed data to ticks/bars objects
                    if (baseData.DataType != MarketDataType.Auxiliary)
                    {
                        var tick = baseData as Tick;

                        if (!packet.Configuration.IsInternalFeed)
                        {
                            // populate data dictionaries
                            switch (baseData.DataType)
                            {
                                case MarketDataType.Tick:
                                    if (ticks == null)
                                    {
                                        ticks = new Ticks(algorithmTime);
                                    }
                                    ticks.Add(baseData.Symbol, (Tick)baseData);
                                    break;

                                case MarketDataType.TradeBar:
                                    if (tradeBars == null)
                                    {
                                        tradeBars = new TradeBars(algorithmTime);
                                    }

                                    var newTradeBar = (TradeBar)baseData;
                                    TradeBar existingTradeBar;
                                    // if we have an existing bar keep the highest resolution one
                                    // e.g Hour and Minute resolution subscriptions for the same symbol
                                    // see CustomUniverseWithBenchmarkRegressionAlgorithm
                                    if (!tradeBars.TryGetValue(baseData.Symbol, out existingTradeBar)
                                        || existingTradeBar.Period > newTradeBar.Period)
                                    {
                                        tradeBars[baseData.Symbol] = newTradeBar;
                                    }
                                    break;

                                case MarketDataType.QuoteBar:
                                    if (quoteBars == null)
                                    {
                                        quoteBars = new QuoteBars(algorithmTime);
                                    }

                                    var newQuoteBar = (QuoteBar)baseData;
                                    QuoteBar existingQuoteBar;
                                    // if we have an existing bar keep the highest resolution one
                                    // e.g Hour and Minute resolution subscriptions for the same symbol
                                    // see CustomUniverseWithBenchmarkRegressionAlgorithm
                                    if (!quoteBars.TryGetValue(baseData.Symbol, out existingQuoteBar)
                                        || existingQuoteBar.Period > newQuoteBar.Period)
                                    {
                                        quoteBars[baseData.Symbol] = newQuoteBar;
                                    }
                                    break;

                                case MarketDataType.OptionChain:
                                    if (optionChains == null)
                                    {
                                        optionChains = new OptionChains(algorithmTime);
                                    }
                                    optionChains[baseData.Symbol] = (OptionChain)baseData;
                                    break;

                                case MarketDataType.FuturesChain:
                                    if (futuresChains == null)
                                    {
                                        futuresChains = new FuturesChains(algorithmTime);
                                    }
                                    futuresChains[baseData.Symbol] = (FuturesChain)baseData;
                                    break;
                            }

                            // this is data used to update consolidators
                            // do not add it if it is a Suspicious tick
                            if (tick == null || !tick.Suspicious)
                            {
                                consolidatorUpdate.Add(baseData);
                            }
                        }

                        // special handling of options data to build the option chain
                        if (symbol.SecurityType == SecurityType.Option || symbol.SecurityType == SecurityType.FutureOption)
                        {
                            // internal feeds, like open interest, will not create the chain but will update it if it exists
                            // this is because the open interest could arrive at some closed market hours in which there is no other data and we don't
                            // want to generate a chain object in this case
                            if (optionChains == null && !packet.Configuration.IsInternalFeed)
                            {
                                optionChains = new OptionChains(algorithmTime);
                            }

                            if (baseData.DataType == MarketDataType.OptionChain)
                            {
                                optionChains[baseData.Symbol] = (OptionChain)baseData;
                            }
                            else if (optionChains != null && !HandleOptionData(algorithmTime, baseData, optionChains, packet.Security, sliceFuture, optionUnderlyingUpdates))
                            {
                                continue;
                            }
                        }

                        // special handling of futures data to build the futures chain
                        if (symbol.SecurityType == SecurityType.Future)
                        {
                            // internal feeds, like open interest, will not create the chain but will update it if it exists
                            // this is because the open interest could arrive at some closed market hours in which there is no other data and we don't
                            // want to generate a chain object in this case
                            if (futuresChains == null && !packet.Configuration.IsInternalFeed)
                            {
                                futuresChains = new FuturesChains(algorithmTime);
                            }
                            if (baseData.DataType == MarketDataType.FuturesChain)
                            {
                                futuresChains[baseData.Symbol] = (FuturesChain)baseData;
                            }
                            else if (futuresChains != null && !HandleFuturesData(algorithmTime, baseData, futuresChains, packet.Security))
                            {
                                continue;
                            }
                        }

                        // this is the data used set market prices
                        // do not add it if it is a Suspicious tick
                        if (tick != null && tick.Suspicious) continue;

                        securityUpdate.Add(baseData);

                        // option underlying security update
                        if (!packet.Configuration.IsInternalFeed)
                        {
                            optionUnderlyingUpdates[symbol] = baseData;
                        }
                    }
                    else if (!packet.Configuration.IsInternalFeed)
                    {
                        // include checks for various aux types so we don't have to construct the dictionaries in Slice
                        if ((delisting = baseData as Delisting) != null)
                        {
                            if (delistings == null)
                            {
                                delistings = new Delistings(algorithmTime);
                            }
                            delistings[symbol] = delisting;
                        }
                        else if ((dividend = baseData as Dividend) != null)
                        {
                            if (dividends == null)
                            {
                                dividends = new Dividends(algorithmTime);
                            }
                            dividends[symbol] = dividend;
                        }
                        else if ((split = baseData as Split) != null)
                        {
                            if (splits == null)
                            {
                                splits = new Splits(algorithmTime);
                            }
                            splits[symbol] = split;
                        }
                        else if ((symbolChange = baseData as SymbolChangedEvent) != null)
                        {
                            if (symbolChanges == null)
                            {
                                symbolChanges = new SymbolChangedEvents(algorithmTime);
                            }
                            // symbol changes is keyed by the requested symbol
                            symbolChanges[packet.Configuration.Symbol] = symbolChange;
                        }
                    }
                }

                if (securityUpdate.Count > 0)
                {
                    security.Add(new UpdateData<ISecurityPrice>(packet.Security, packet.Configuration.Type, securityUpdate, packet.Configuration.IsInternalFeed, containsFillForwardData));
                }
                if (consolidatorUpdate.Count > 0)
                {
                    consolidator.Add(new UpdateData<SubscriptionDataConfig>(packet.Configuration, packet.Configuration.Type, consolidatorUpdate, packet.Configuration.IsInternalFeed, containsFillForwardData));
                }
            }

            slice = new Slice(algorithmTime, allDataForAlgorithm, tradeBars ?? _emptyTradeBars, quoteBars ?? _emptyQuoteBars, ticks ?? _emptyTicks, optionChains ?? _emptyOptionChains, futuresChains ?? _emptyFuturesChains, splits ?? _emptySplits, dividends ?? _emptyDividends, delistings ?? _emptyDelistings, symbolChanges ?? _emptySymbolChangedEvents, allDataForAlgorithm.Count > 0);

            return new TimeSlice(utcDateTime, count, slice, data, security, consolidator, custom ?? _emptyCustom, changes, universeData);
        }

        private void UpdateEmptyCollections(DateTime algorithmTime)
        {
            // just in case
            _emptyTradeBars.Clear();
            _emptyQuoteBars.Clear();
            _emptyTicks.Clear();
            _emptySplits.Clear();
            _emptyDividends.Clear();
            _emptyDelistings.Clear();
            _emptyOptionChains.Clear();
            _emptyFuturesChains.Clear();
            _emptySymbolChangedEvents.Clear();

            _emptyTradeBars.Time
                = _emptyQuoteBars.Time
                = _emptyTicks.Time
                = _emptySplits.Time
                = _emptyDividends.Time
                = _emptyDelistings.Time
                = _emptyOptionChains.Time
                = _emptyFuturesChains.Time
                = _emptySymbolChangedEvents.Time = algorithmTime;
        }

        private bool HandleOptionData(DateTime algorithmTime, BaseData baseData, OptionChains optionChains, ISecurityPrice security, Lazy<Slice> sliceFuture, IReadOnlyDictionary<Symbol, BaseData> optionUnderlyingUpdates)
        {
            var symbol = baseData.Symbol;

            OptionChain chain;
            var canonical = Symbol.CreateOption(symbol.Underlying, symbol.ID.Market, default(OptionStyle), default(OptionRight), 0, SecurityIdentifier.DefaultDate);
            if (!optionChains.TryGetValue(canonical, out chain))
            {
                chain = new OptionChain(canonical, algorithmTime);
                optionChains[canonical] = chain;
            }

            // set the underlying current data point in the option chain
            var option = security as IOptionPrice;
            if (option != null)
            {
                if (option.Underlying == null)
                {
                    Log.Error($"TimeSlice.HandleOptionData(): {algorithmTime}: Option underlying is null");
                    return false;
                }

                BaseData underlyingData;
                if (!optionUnderlyingUpdates.TryGetValue(option.Underlying.Symbol, out underlyingData))
                {
                    underlyingData = option.Underlying.GetLastData();
                }

                if (underlyingData == null)
                {
                    Log.Error($"TimeSlice.HandleOptionData(): {algorithmTime}: Option underlying GetLastData returned null");
                    return false;
                }
                chain.Underlying = underlyingData;
            }

            var universeData = baseData as OptionChainUniverseDataCollection;
            if (universeData != null)
            {
                if (universeData.Underlying != null)
                {
                    foreach (var addedContract in chain.Contracts)
                    {
                        addedContract.Value.UnderlyingLastPrice = chain.Underlying.Price;
                    }
                }
                foreach (var contractSymbol in universeData.FilteredContracts)
                {
                    chain.FilteredContracts.Add(contractSymbol);
                }
                return false;
            }

            OptionContract contract;
            if (!chain.Contracts.TryGetValue(baseData.Symbol, out contract))
            {
                var underlyingSymbol = baseData.Symbol.Underlying;
                contract = new OptionContract(baseData.Symbol, underlyingSymbol)
                {
                    Time = baseData.EndTime,
                    LastPrice = security.Close,
                    Volume = (long)security.Volume,
                    BidPrice = security.BidPrice,
                    BidSize = (long)security.BidSize,
                    AskPrice = security.AskPrice,
                    AskSize = (long)security.AskSize,
                    OpenInterest = security.OpenInterest,
                    UnderlyingLastPrice = chain.Underlying.Price
                };

                chain.Contracts[baseData.Symbol] = contract;

                if (option != null)
                {
                    contract.SetOptionPriceModel(() => option.EvaluatePriceModel(sliceFuture.Value, contract));
                }
            }

            // populate ticks and tradebars dictionaries with no aux data
            switch (baseData.DataType)
            {
                case MarketDataType.Tick:
                    var tick = (Tick)baseData;
                    chain.Ticks.Add(tick.Symbol, tick);
                    UpdateContract(contract, tick);
                    break;

                case MarketDataType.TradeBar:
                    var tradeBar = (TradeBar)baseData;
                    chain.TradeBars[symbol] = tradeBar;
                    UpdateContract(contract, tradeBar);
                    break;

                case MarketDataType.QuoteBar:
                    var quote = (QuoteBar)baseData;
                    chain.QuoteBars[symbol] = quote;
                    UpdateContract(contract, quote);
                    break;

                case MarketDataType.Base:
                    chain.AddAuxData(baseData);
                    break;
            }
            return true;
        }


        private bool HandleFuturesData(DateTime algorithmTime, BaseData baseData, FuturesChains futuresChains, ISecurityPrice security)
        {
            var symbol = baseData.Symbol;

            FuturesChain chain;
            var canonical = Symbol.Create(symbol.ID.Symbol, SecurityType.Future, symbol.ID.Market);
            if (!futuresChains.TryGetValue(canonical, out chain))
            {
                chain = new FuturesChain(canonical, algorithmTime);
                futuresChains[canonical] = chain;
            }

            var universeData = baseData as FuturesChainUniverseDataCollection;
            if (universeData != null)
            {
                foreach (var contractSymbol in universeData.FilteredContracts)
                {
                    chain.FilteredContracts.Add(contractSymbol);
                }
                return false;
            }

            FuturesContract contract;
            if (!chain.Contracts.TryGetValue(baseData.Symbol, out contract))
            {
                var underlyingSymbol = baseData.Symbol.Underlying;
                contract = new FuturesContract(baseData.Symbol, underlyingSymbol)
                {
                    Time = baseData.EndTime,
                    LastPrice = security.Close,
                    Volume = (long)security.Volume,
                    BidPrice = security.BidPrice,
                    BidSize = (long)security.BidSize,
                    AskPrice = security.AskPrice,
                    AskSize = (long)security.AskSize,
                    OpenInterest = security.OpenInterest
                };
                chain.Contracts[baseData.Symbol] = contract;
            }

            // populate ticks and tradebars dictionaries with no aux data
            switch (baseData.DataType)
            {
                case MarketDataType.Tick:
                    var tick = (Tick)baseData;
                    chain.Ticks.Add(tick.Symbol, tick);
                    UpdateContract(contract, tick);
                    break;

                case MarketDataType.TradeBar:
                    var tradeBar = (TradeBar)baseData;
                    chain.TradeBars[symbol] = tradeBar;
                    UpdateContract(contract, tradeBar);
                    break;

                case MarketDataType.QuoteBar:
                    var quote = (QuoteBar)baseData;
                    chain.QuoteBars[symbol] = quote;
                    UpdateContract(contract, quote);
                    break;

                case MarketDataType.Base:
                    chain.AddAuxData(baseData);
                    break;
            }
            return true;
        }

        private static void UpdateContract(OptionContract contract, QuoteBar quote)
        {
            if (quote.Ask != null && quote.Ask.Close != 0m)
            {
                contract.AskPrice = quote.Ask.Close;
                contract.AskSize = (long)quote.LastAskSize;
            }
            if (quote.Bid != null && quote.Bid.Close != 0m)
            {
                contract.BidPrice = quote.Bid.Close;
                contract.BidSize = (long)quote.LastBidSize;
            }
        }

        private static void UpdateContract(OptionContract contract, Tick tick)
        {
            if (tick.TickType == TickType.Trade)
            {
                contract.LastPrice = tick.Price;
            }
            else if (tick.TickType == TickType.Quote)
            {
                if (tick.AskPrice != 0m)
                {
                    contract.AskPrice = tick.AskPrice;
                    contract.AskSize = (long)tick.AskSize;
                }
                if (tick.BidPrice != 0m)
                {
                    contract.BidPrice = tick.BidPrice;
                    contract.BidSize = (long)tick.BidSize;
                }
            }
            else if (tick.TickType == TickType.OpenInterest)
            {
                if (tick.Value != 0m)
                {
                    contract.OpenInterest = tick.Value;
                }
            }
        }

        private static void UpdateContract(OptionContract contract, TradeBar tradeBar)
        {
            if (tradeBar.Close == 0m) return;
            contract.LastPrice = tradeBar.Close;
            contract.Volume = (long)tradeBar.Volume;
        }

        private static void UpdateContract(FuturesContract contract, QuoteBar quote)
        {
            if (quote.Ask != null && quote.Ask.Close != 0m)
            {
                contract.AskPrice = quote.Ask.Close;
                contract.AskSize = (long)quote.LastAskSize;
            }
            if (quote.Bid != null && quote.Bid.Close != 0m)
            {
                contract.BidPrice = quote.Bid.Close;
                contract.BidSize = (long)quote.LastBidSize;
            }
        }

        private static void UpdateContract(FuturesContract contract, Tick tick)
        {
            if (tick.TickType == TickType.Trade)
            {
                contract.LastPrice = tick.Price;
            }
            else if (tick.TickType == TickType.Quote)
            {
                if (tick.AskPrice != 0m)
                {
                    contract.AskPrice = tick.AskPrice;
                    contract.AskSize = (long)tick.AskSize;
                }
                if (tick.BidPrice != 0m)
                {
                    contract.BidPrice = tick.BidPrice;
                    contract.BidSize = (long)tick.BidSize;
                }
            }
            else if (tick.TickType == TickType.OpenInterest)
            {
                if (tick.Value != 0m)
                {
                    contract.OpenInterest = tick.Value;
                }
            }
        }

        private static void UpdateContract(FuturesContract contract, TradeBar tradeBar)
        {
            if (tradeBar.Close == 0m) return;
            contract.LastPrice = tradeBar.Close;
            contract.Volume = (long)tradeBar.Volume;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using NodaTime;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Data.UniverseSelection;
using QuantConnect.Interfaces;
using QuantConnect.Logging;

namespace QuantConnect.Lean.Engine.DataFeeds
{
    /// <summary>
    /// Instance base class that will provide methods for creating new <see cref="TimeSlice"/>
    /// </summary>
    public class TimeSliceFactory
    {
        private readonly DateTimeZone _timeZone;

        // performance: these collections are not always used so keep a reference to an empty
        // instance to use and avoid unnecessary constructors and allocations
        private readonly List<UpdateData<ISecurityPrice>> _emptyCustom = new List<UpdateData<ISecurityPrice>>();
        private readonly TradeBars _emptyTradeBars = new TradeBars();
        private readonly QuoteBars _emptyQuoteBars = new QuoteBars();
        private readonly Ticks _emptyTicks = new Ticks();
        private readonly Splits _emptySplits = new Splits();
        private readonly Dividends _emptyDividends = new Dividends();
        private readonly Delistings _emptyDelistings = new Delistings();
        private readonly OptionChains _emptyOptionChains = new OptionChains();
        private readonly FuturesChains _emptyFuturesChains = new FuturesChains();
        private readonly SymbolChangedEvents _emptySymbolChangedEvents = new SymbolChangedEvents();

        /// <summary>
        /// Creates a new instance
        /// </summary>
        /// <param name="timeZone">The time zone required for computing algorithm and slice time</param>
        public TimeSliceFactory(DateTimeZone timeZone)
        {
            _timeZone = timeZone;
        }

        /// <summary>
        /// Creates a new empty <see cref="TimeSlice"/> to be used as a time pulse
        /// </summary>
        /// <remarks>The objective of this method is to standardize the time pulse creation</remarks>
        /// <param name="utcDateTime">The UTC frontier date time</param>
        /// <returns>A new <see cref="TimeSlice"/> time pulse</returns>
        public TimeSlice CreateTimePulse(DateTime utcDateTime)
        {
            // setting all data collections to null, this time slice shouldn't be used
            // for its data, we want to see fireworks it someone tries
            return new TimeSlice(utcDateTime,
                0,
                null,
                null,
                null,
                null,
                null,
                SecurityChanges.None,
                null,
                isTimePulse:true);
        }

        /// <summary>
        /// Creates a new <see cref="TimeSlice"/> for the specified time using the specified data
        /// </summary>
        /// <param name="utcDateTime">The UTC frontier date time</param>
        /// <param name="data">The data in this <see cref="TimeSlice"/></param>
        /// <param name="changes">The new changes that are seen in this time slice as a result of universe selection</param>
        /// <param name="universeData"></param>
        /// <returns>A new <see cref="TimeSlice"/> containing the specified data</returns>
        public TimeSlice Create(DateTime utcDateTime,
            List<DataFeedPacket> data,
            SecurityChanges changes,
            Dictionary<Universe, BaseDataCollection> universeData)
        {
            int count = 0;
            var security = new List<UpdateData<ISecurityPrice>>(data.Count);
            List<UpdateData<ISecurityPrice>> custom = null;
            var consolidator = new List<UpdateData<SubscriptionDataConfig>>(data.Count);
            var allDataForAlgorithm = new List<BaseData>(data.Count);
            var optionUnderlyingUpdates = new Dictionary<Symbol, BaseData>();

            Split split;
            Dividend dividend;
            Delisting delisting;
            SymbolChangedEvent symbolChange;

            // we need to be able to reference the slice being created in order to define the
            // evaluation of option price models, so we define a 'future' that can be referenced
            // in the option price model evaluation delegates for each contract
            Slice slice = null;
            var sliceFuture = new Lazy<Slice>(() => slice);

            var algorithmTime = utcDateTime.ConvertFromUtc(_timeZone);
            TradeBars tradeBars = null;
            QuoteBars quoteBars = null;
            Ticks ticks = null;
            Splits splits = null;
            Dividends dividends = null;
            Delistings delistings = null;
            OptionChains optionChains = null;
            FuturesChains futuresChains = null;
            SymbolChangedEvents symbolChanges = null;

            UpdateEmptyCollections(algorithmTime);

            if (universeData.Count > 0)
            {
                // count universe data
                foreach (var kvp in universeData)
                {
                    count += kvp.Value.Data.Count;
                }
            }

            // ensure we read equity data before option data, so we can set the current underlying price
            foreach (var packet in data)
            {
                // filter out packets for removed subscriptions
                if (packet.IsSubscriptionRemoved)
                {
                    continue;
                }

                var list = packet.Data;
                var symbol = packet.Configuration.Symbol;

                if (list.Count == 0) continue;

                // keep count of all data points
                if (list.Count == 1 && list[0] is BaseDataCollection)
                {
                    var baseDataCollectionCount = ((BaseDataCollection)list[0]).Data.Count;
                    if (baseDataCollectionCount == 0)
                    {
                        continue;
                    }
                    count += baseDataCollectionCount;
                }
                else
                {
                    count += list.Count;
                }

                if (!packet.Configuration.IsInternalFeed && packet.Configuration.IsCustomData)
                {
                    if (custom == null)
                    {
                        custom = new List<UpdateData<ISecurityPrice>>(1);
                    }
                    // This is all the custom data
                    custom.Add(new UpdateData<ISecurityPrice>(packet.Security, packet.Configuration.Type, list, packet.Configuration.IsInternalFeed));
                }

                var securityUpdate = new List<BaseData>(list.Count);
                var consolidatorUpdate = new List<BaseData>(list.Count);
                var containsFillForwardData = false;
                for (var i = 0; i < list.Count; i++)
                {
                    var baseData = list[i];
                    if (!packet.Configuration.IsInternalFeed)
                    {
                        // this is all the data that goes into the algorithm
                        allDataForAlgorithm.Add(baseData);
                    }

                    containsFillForwardData |= baseData.IsFillForward;

                    // don't add internal feed data to ticks/bars objects
                    if (baseData.DataType != MarketDataType.Auxiliary)
                    {

                        if (!packet.Configuration.IsInternalFeed)
                        {
                            // populate data dictionaries
                            switch (baseData.DataType)
                            {
                                case MarketDataType.Tick:
                                    if (ticks == null)
                                    {
                                        ticks = new Ticks(algorithmTime);
                                    }
                                    ticks.Add(baseData.Symbol, (Tick)baseData);
                                    break;

                                case MarketDataType.TradeBar:
                                    if (tradeBars == null)
                                    {
                                        tradeBars = new TradeBars(algorithmTime);
                                    }

                                    var newTradeBar = (TradeBar)baseData;
                                    TradeBar existingTradeBar;
                                    // if we have an existing bar keep the highest resolution one
                                    // e.g Hour and Minute resolution subscriptions for the same symbol
                                    // see CustomUniverseWithBenchmarkRegressionAlgorithm
                                    if (!tradeBars.TryGetValue(baseData.Symbol, out existingTradeBar)
                                        || existingTradeBar.Period > newTradeBar.Period)
                                    {
                                        tradeBars[baseData.Symbol] = newTradeBar;
                                    }
                                    break;

                                case MarketDataType.QuoteBar:
                                    if (quoteBars == null)
                                    {
                                        quoteBars = new QuoteBars(algorithmTime);
                                    }

                                    var newQuoteBar = (QuoteBar)baseData;
                                    QuoteBar existingQuoteBar;
                                    // if we have an existing bar keep the highest resolution one
                                    // e.g Hour and Minute resolution subscriptions for the same symbol
                                    // see CustomUniverseWithBenchmarkRegressionAlgorithm
                                    if (!quoteBars.TryGetValue(baseData.Symbol, out existingQuoteBar)
                                        || existingQuoteBar.Period > newQuoteBar.Period)
                                    {
                                        quoteBars[baseData.Symbol] = newQuoteBar;
                                    }
                                    break;

                                case MarketDataType.OptionChain:
                                    if (optionChains == null)
                                    {
                                        optionChains = new OptionChains(algorithmTime);
                                    }
                                    optionChains[baseData.Symbol] = (OptionChain)baseData;
                                    break;

                                case MarketDataType.FuturesChain:
                                    if (futuresChains == null)
                                    {
                                        futuresChains = new FuturesChains(algorithmTime);
                                    }
                                    futuresChains[baseData.Symbol] = (FuturesChain)baseData;
                                    break;
                            }

                            // this is data used to update consolidators
                            // do not add it if it is a Suspicious tick
                            if (tick == null || !tick.Suspicious)
                            {
                                consolidatorUpdate.Add(baseData);
                            }
                        }

                        // special handling of options data to build the option chain
                        if (symbol.SecurityType == SecurityType.Option || symbol.SecurityType == SecurityType.FutureOption)
                        {
                            // internal feeds, like open interest, will not create the chain but will update it if it exists
                            // this is because the open interest could arrive at some closed market hours in which there is no other data and we don't
                            // want to generate a chain object in this case
                            if (optionChains == null && !packet.Configuration.IsInternalFeed)
                            {
                                optionChains = new OptionChains(algorithmTime);
                            }

                            if (baseData.DataType == MarketDataType.OptionChain)
                            {
                                optionChains[baseData.Symbol] = (OptionChain)baseData;
                            }
                            else if (optionChains != null && !HandleOptionData(algorithmTime, baseData, optionChains, packet.Security, sliceFuture, optionUnderlyingUpdates))
                            {
                                continue;
                            }
                        }

                        // special handling of futures data to build the futures chain
                        if (symbol.SecurityType == SecurityType.Future)
                        {
                            // internal feeds, like open interest, will not create the chain but will update it if it exists
                            // this is because the open interest could arrive at some closed market hours in which there is no other data and we don't
                            // want to generate a chain object in this case
                            if (futuresChains == null && !packet.Configuration.IsInternalFeed)
                            {
                                futuresChains = new FuturesChains(algorithmTime);
                            }
                            if (baseData.DataType == MarketDataType.FuturesChain)
                            {
                                futuresChains[baseData.Symbol] = (FuturesChain)baseData;
                            }
                            else if (futuresChains != null && !HandleFuturesData(algorithmTime, baseData, futuresChains, packet.Security))
                            {
                                continue;
                            }
                        }

                        // this is the data used set market prices
                        // do not add it if it is a Suspicious tick
                        if (baseData is Tick tick && tick.Suspicious) continue;

                        securityUpdate.Add(baseData);

                        // option underlying security update
                        if (!packet.Configuration.IsInternalFeed)
                        {
                            optionUnderlyingUpdates[symbol] = baseData;
                        }
                    }
                    else if (!packet.Configuration.IsInternalFeed)
                    {
                        // include checks for various aux types so we don't have to construct the dictionaries in Slice
                        if ((delisting = baseData as Delisting) != null)
                        {
                            if (delistings == null)
                            {
                                delistings = new Delistings(algorithmTime);
                            }
                            delistings[symbol] = delisting;
                        }
                        else if ((dividend = baseData as Dividend) != null)
                        {
                            if (dividends == null)
                            {
                                dividends = new Dividends(algorithmTime);
                            }
                            dividends[symbol] = dividend;
                        }
                        else if ((split = baseData as Split) != null)
                        {
                            if (splits == null)
                            {
                                splits = new Splits(algorithmTime);
                            }
                            splits[symbol] = split;
                        }
                        else if ((symbolChange = baseData as SymbolChangedEvent) != null)
                        {
                            if (symbolChanges == null)
                            {
                                symbolChanges = new SymbolChangedEvents(algorithmTime);
                            }
                            // symbol changes is keyed by the requested symbol
                            symbolChanges[packet.Configuration.Symbol] = symbolChange;
                        }
                    }
                }

                if (securityUpdate.Count > 0)
                {
                    security.Add(new UpdateData<ISecurityPrice>(packet.Security, packet.Configuration.Type, securityUpdate, packet.Configuration.IsInternalFeed, containsFillForwardData));
                }
                if (consolidatorUpdate.Count > 0)
                {
                    consolidator.Add(new UpdateData<SubscriptionDataConfig>(packet.Configuration, packet.Configuration.Type, consolidatorUpdate, packet.Configuration.IsInternalFeed, containsFillForwardData));
                }
            }

            slice = new Slice(algorithmTime, allDataForAlgorithm, tradeBars ?? _emptyTradeBars, quoteBars ?? _emptyQuoteBars, ticks ?? _emptyTicks, optionChains ?? _emptyOptionChains, futuresChains ?? _emptyFuturesChains, splits ?? _emptySplits, dividends ?? _emptyDividends, delistings ?? _emptyDelistings, symbolChanges ?? _emptySymbolChangedEvents, allDataForAlgorithm.Count > 0);

            return new TimeSlice(utcDateTime, count, slice, data, security, consolidator, custom ?? _emptyCustom, changes, universeData);
        }

        private void UpdateEmptyCollections(DateTime algorithmTime)
        {
            // just in case
            _emptyTradeBars.Clear();
            _emptyQuoteBars.Clear();
            _emptyTicks.Clear();
            _emptySplits.Clear();
            _emptyDividends.Clear();
            _emptyDelistings.Clear();
            _emptyOptionChains.Clear();
            _emptyFuturesChains.Clear();
            _emptySymbolChangedEvents.Clear();

            _emptyTradeBars.Time
                = _emptyQuoteBars.Time
                = _emptyTicks.Time
                = _emptySplits.Time
                = _emptyDividends.Time
                = _emptyDelistings.Time
                = _emptyOptionChains.Time
                = _emptyFuturesChains.Time
                = _emptySymbolChangedEvents.Time = algorithmTime;
        }

        private bool HandleOptionData(DateTime algorithmTime, BaseData baseData, OptionChains optionChains, ISecurityPrice security, Lazy<Slice> sliceFuture, IReadOnlyDictionary<Symbol, BaseData> optionUnderlyingUpdates)
        {
            var symbol = baseData.Symbol;

            OptionChain chain;
            var canonical = Symbol.CreateOption(symbol.Underlying, symbol.ID.Market, default(OptionStyle), default(OptionRight), 0, SecurityIdentifier.DefaultDate);
            if (!optionChains.TryGetValue(canonical, out chain))
            {
                chain = new OptionChain(canonical, algorithmTime);
                optionChains[canonical] = chain;
            }

            // set the underlying current data point in the option chain
            if (security is IOptionPrice option)
            {
                if (option.Underlying == null)
                {
                    Log.Error($"TimeSlice.HandleOptionData(): {algorithmTime}: Option underlying is null");
                    return false;
                }

                BaseData underlyingData;
                if (!optionUnderlyingUpdates.TryGetValue(option.Underlying.Symbol, out underlyingData))
                {
                    underlyingData = option.Underlying.GetLastData();
                }

                if (underlyingData == null)
                {
                    Log.Error($"TimeSlice.HandleOptionData(): {algorithmTime}: Option underlying GetLastData returned null");
                    return false;
                }
                chain.Underlying = underlyingData;
            }

            if (baseData is OptionChainUniverseDataCollection universeData)
            {
                if (universeData.Underlying != null)
                {
                    foreach (var addedContract in chain.Contracts)
                    {
                        addedContract.Value.UnderlyingLastPrice = chain.Underlying.Price;
                    }
                }
                foreach (var contractSymbol in universeData.FilteredContracts)
                {
                    chain.FilteredContracts.Add(contractSymbol);
                }
                return false;
            }

            OptionContract contract;
            if (!chain.Contracts.TryGetValue(baseData.Symbol, out contract))
            {
                var underlyingSymbol = baseData.Symbol.Underlying;
                contract = new OptionContract(baseData.Symbol, underlyingSymbol)
                {
                    Time = baseData.EndTime,
                    LastPrice = security.Close,
                    Volume = (long)security.Volume,
                    BidPrice = security.BidPrice,
                    BidSize = (long)security.BidSize,
                    AskPrice = security.AskPrice,
                    AskSize = (long)security.AskSize,
                    OpenInterest = security.OpenInterest,
                    UnderlyingLastPrice = chain.Underlying.Price
                };

                chain.Contracts[baseData.Symbol] = contract;

                if (security is IOptionPrice option)
                {
                    contract.SetOptionPriceModel(() => option.EvaluatePriceModel(sliceFuture.Value, contract));
                }
            }

            // populate ticks and tradebars dictionaries with no aux data
            switch (baseData.DataType)
            {
                case MarketDataType.Tick:
                    var tick = (Tick)baseData;
                    chain.Ticks.Add(tick.Symbol, tick);
                    UpdateContract(contract, tick);
                    break;

                case MarketDataType.TradeBar:
                    var tradeBar = (TradeBar)baseData;
                    chain.TradeBars[symbol] = tradeBar;
                    UpdateContract(contract, tradeBar);
                    break;

                case MarketDataType.QuoteBar:
                    var quote = (QuoteBar)baseData;
                    chain.QuoteBars[symbol] = quote;
                    UpdateContract(contract, quote);
                    break;

                case MarketDataType.Base:
                    chain.AddAuxData(baseData);
                    break;
            }
            return true;
        }


        private bool HandleFuturesData(DateTime algorithmTime, BaseData baseData, FuturesChains futuresChains, ISecurityPrice security)
        {
            var symbol = baseData.Symbol;

            FuturesChain chain;
            var canonical = Symbol.Create(symbol.ID.Symbol, SecurityType.Future, symbol.ID.Market);
            if (!futuresChains.TryGetValue(canonical, out chain))
            {
                chain = new FuturesChain(canonical, algorithmTime);
                futuresChains[canonical] = chain;
            }

            if (baseData is FuturesChainUniverseDataCollection universeData)
            {
                foreach (var contractSymbol in universeData.FilteredContracts)
                {
                    chain.FilteredContracts.Add(contractSymbol);
                }
                return false;
            }

            FuturesContract contract;
            if (!chain.Contracts.TryGetValue(baseData.Symbol, out contract))
            {
                var underlyingSymbol = baseData.Symbol.Underlying;
                contract = new FuturesContract(baseData.Symbol, underlyingSymbol)
                {
                    Time = baseData.EndTime,
                    LastPrice = security.Close,
                    Volume = (long)security.Volume,
                    BidPrice = security.BidPrice,
                    BidSize = (long)security.BidSize,
                    AskPrice = security.AskPrice,
                    AskSize = (long)security.AskSize,
                    OpenInterest = security.OpenInterest
                };
                chain.Contracts[baseData.Symbol] = contract;
            }

            // populate ticks and tradebars dictionaries with no aux data
            switch (baseData.DataType)
            {
                case MarketDataType.Tick:
                    var tick = (Tick)baseData;
                    chain.Ticks.Add(tick.Symbol, tick);
                    UpdateContract(contract, tick);
                    break;

                case MarketDataType.TradeBar:
                    var tradeBar = (TradeBar)baseData;
                    chain.TradeBars[symbol] = tradeBar;
                    UpdateContract(contract, tradeBar);
                    break;

                case MarketDataType.QuoteBar:
                    var quote = (QuoteBar)baseData;
                    chain.QuoteBars[symbol] = quote;
                    UpdateContract(contract, quote);
                    break;

                case MarketDataType.Base:
                    chain.AddAuxData(baseData);
                    break;
            }
            return true;
        }

        private static void UpdateContract(OptionContract contract, QuoteBar quote)
        {
            if (quote.Ask != null && quote.Ask.Close != 0m)
            {
                contract.AskPrice = quote.Ask.Close;
                contract.AskSize = (long)quote.LastAskSize;
            }
            if (quote.Bid != null && quote.Bid.Close != 0m)
            {
                contract.BidPrice = quote.Bid.Close;
                contract.BidSize = (long)quote.LastBidSize;
            }
        }

        private static void UpdateContract(OptionContract contract, Tick tick)
        {
            if (tick.TickType == TickType.Trade)
            {
                contract.LastPrice = tick.Price;
            }
            else if (tick.TickType == TickType.Quote)
            {
                if (tick.AskPrice != 0m)
                {
                    contract.AskPrice = tick.AskPrice;
                    contract.AskSize = (long)tick.AskSize;
                }
                if (tick.BidPrice != 0m)
                {
                    contract.BidPrice = tick.BidPrice;
                    contract.BidSize = (long)tick.BidSize;
                }
            }
            else if (tick.TickType == TickType.OpenInterest)
            {
                if (tick.Value != 0m)
                {
                    contract.OpenInterest = tick.Value;
                }
            }
        }

        private static void UpdateContract(OptionContract contract, TradeBar tradeBar)
        {
            if (tradeBar.Close == 0m) return;
            contract.LastPrice = tradeBar.Close;
            contract.Volume = (long)tradeBar.Volume;
        }

        private static void UpdateContract(FuturesContract contract, QuoteBar quote)
        {
            if (quote.Ask != null && quote.Ask.Close != 0m)
            {
                contract.AskPrice = quote.Ask.Close;
                contract.AskSize = (long)quote.LastAskSize;
            }
            if (quote.Bid != null && quote.Bid.Close != 0m)
            {
                contract.BidPrice = quote.Bid.Close;
                contract.BidSize = (long)quote.LastBidSize;
            }
        }

        private static void UpdateContract(FuturesContract contract, Tick tick)
        {
            if (tick.TickType == TickType.Trade)
            {
                contract.LastPrice = tick.Price;
            }
            else if (tick.TickType == TickType.Quote)
            {
                if (tick.AskPrice != 0m)
                {
                    contract.AskPrice = tick.AskPrice;
                    contract.AskSize = (long)tick.AskSize;
                }
                if (tick.BidPrice != 0m)
                {
                    contract.BidPrice = tick.BidPrice;
                    contract.BidSize = (long)tick.BidSize;
                }
            }
            else if (tick.TickType == TickType.OpenInterest)
            {
                if (tick.Value != 0m)
                {
                    contract.OpenInterest = tick.Value;
                }
            }
        }

        private static void UpdateContract(FuturesContract contract, TradeBar tradeBar)
        {
            if (tradeBar.Close == 0m) return;
            contract.LastPrice = tradeBar.Close;
            contract.Volume = (long)tradeBar.Volume;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(384,13): warning CS0618: 'DataDictionary<TradeBar>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(385,19): warning CS0618: 'DataDictionary<QuoteBar>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(386,19): warning CS0618: 'DataDictionary<List<Tick>>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(387,19): warning CS0618: 'DataDictionary<Split>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(388,19): warning CS0618: 'DataDictionary<Dividend>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(389,19): warning CS0618: 'DataDictionary<Delisting>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(390,19): warning CS0618: 'DataDictionary<OptionChain>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(391,19): warning CS0618: 'DataDictionary<FuturesChain>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(392,19): warning CS0618: 'DataDictionary<SymbolChangedEvent>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.'
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(257,33): error CS0841: Cannot use local variable 'tick' before it is declared,D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(257,50): error CS0841: Cannot use local variable 'tick' before it is declared,D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(383,13): warning CS0618: 'DataDictionary<TradeBar>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(384,19): warning CS0618: 'DataDictionary<QuoteBar>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(385,19): warning CS0618: 'DataDictionary<List<Tick>>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(386,19): warning CS0618: 'DataDictionary<Split>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(387,19): warning CS0618: 'DataDictionary<Dividend>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(388,19): warning CS0618: 'DataDictionary<Delisting>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(389,19): warning CS0618: 'DataDictionary<OptionChain>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(390,19): warning CS0618: 'DataDictionary<FuturesChain>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(391,19): warning CS0618: 'DataDictionary<SymbolChangedEvent>.Time' is obsolete: 'The DataDictionary<T> Time property is now obsolete. All algorithms should use algorithm.Time instead.',D:\a\1\s\Engine\DataFeeds\TimeSliceFactory.cs(464,46): error CS0136: A local or parameter named 'option' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Common\Data\Consolidators\PeriodCountConsolidatorBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Runtime.CompilerServices;
using QuantConnect.Data.Market;
using Python.Runtime;

namespace QuantConnect.Data.Consolidators
{
    /// <summary>
    /// Provides a base class for consolidators that emit data based on the passing of a period of time
    /// or after seeing a max count of data points.
    /// </summary>
    /// <typeparam name="T">The input type of the consolidator</typeparam>
    /// <typeparam name="TConsolidated">The output type of the consolidator</typeparam>
    public abstract class PeriodCountConsolidatorBase<T, TConsolidated> : DataConsolidator<T>
        where T : IBaseData
        where TConsolidated : BaseData
    {
        // The SecurityIdentifier that we are consolidating for.
        private SecurityIdentifier _securityIdentifier;
        private bool _securityIdentifierIsSet;
        //The number of data updates between creating new bars.
        private readonly int? _maxCount;
        //
        private readonly IPeriodSpecification _periodSpecification;
        //The minimum timespan between creating new bars.
        private TimeSpan? _period;
        //The number of pieces of data we've accumulated since our last emit
        private int _currentCount;
        //The working bar used for aggregating the data
        private TConsolidated _workingBar;
        //The last time we emitted a consolidated bar
        private DateTime? _lastEmit;

        private PeriodCountConsolidatorBase(IPeriodSpecification periodSpecification)
        {
            _periodSpecification = periodSpecification;
            _period = _periodSpecification.Period;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the period
        /// </summary>
        /// <param name="period">The minimum span of time before emitting a consolidated bar</param>
        protected PeriodCountConsolidatorBase(TimeSpan period)
            : this(new TimeSpanPeriodSpecification(period))
        {
            _period = _periodSpecification.Period;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data
        /// </summary>
        /// <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        protected PeriodCountConsolidatorBase(int maxCount)
            : this(new BarCountPeriodSpecification())
        {
            _maxCount = maxCount;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
        /// </summary>
        /// <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        /// <param name="period">The minimum span of time before emitting a consolidated bar</param>
        protected PeriodCountConsolidatorBase(int maxCount, TimeSpan period)
            : this(new MixedModePeriodSpecification(period))
        {
            _maxCount = maxCount;
            _period = _periodSpecification.Period;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
        /// </summary>
        /// <param name="func">Func that defines the start time of a consolidated data</param>
        protected PeriodCountConsolidatorBase(Func<DateTime, CalendarInfo> func)
            : this(new FuncPeriodSpecification(func))
        {
            _period = Time.OneSecond;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
        /// </summary>
        /// <param name="pyObject">Python object that defines either a function object that defines the start time of a consolidated data or a timespan</param>
        protected PeriodCountConsolidatorBase(PyObject pyObject)
            : this(GetPeriodSpecificationFromPyObject(pyObject))
        {
        }

        /// <summary>
        /// Gets the type produced by this consolidator
        /// </summary>
        public override Type OutputType => typeof(TConsolidated);

        /// <summary>
        /// Gets a clone of the data being currently consolidated
        /// </summary>
        public override IBaseData WorkingData => _workingBar?.Clone();

        /// <summary>
        /// Event handler that fires when a new piece of data is produced. We define this as a 'new'
        /// event so we can expose it as a <typeparamref name="TConsolidated"/> instead of a <see cref="BaseData"/> instance
        /// </summary>
        public new event EventHandler<TConsolidated> DataConsolidated;

        /// <summary>
        /// Updates this consolidator with the specified data. This method is
        /// responsible for raising the DataConsolidated event
        /// In time span mode, the bar range is closed on the left and open on the right: [T, T+TimeSpan).
        /// For example, if time span is 1 minute, we have [10:00, 10:01): so data at 10:01 is not 
        /// included in the bar starting at 10:00.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when multiple symbols are being consolidated.</exception>
        /// <param name="data">The new data for the consolidator</param>
        public override void Update(T data)
        {
            if (!_securityIdentifierIsSet)
            {
                _securityIdentifierIsSet = true;
                _securityIdentifier = data.Symbol.ID;
            }
            else if (!data.Symbol.ID.Equals(_securityIdentifier))
            {
                throw new InvalidOperationException($"Consolidators can only be used with a single symbol. The previous consolidated SecurityIdentifier ({_securityIdentifier}) is not the same as in the current data ({data.Symbol.ID}).");
            }

            if (!ShouldProcess(data))
            {
                // first allow the base class a chance to filter out data it doesn't want
                // before we start incrementing counts and what not
                return;
            }

            //Decide to fire the event
            var fireDataConsolidated = false;

            // decide to aggregate data before or after firing OnDataConsolidated event
            // always aggregate before firing in counting mode
            bool aggregateBeforeFire = _maxCount.HasValue;

            if (_maxCount.HasValue)
            {
                // we're in count mode
                _currentCount++;
                if (_currentCount >= _maxCount.Value)
                {
                    _currentCount = 0;
                    fireDataConsolidated = true;
                }
            }

            if (!_lastEmit.HasValue)
            {
                // initialize this value for period computations
                _lastEmit = IsTimeBased ? DateTime.MinValue : data.Time;
            }

            if (_period.HasValue)
            {
                // we're in time span mode and initialized
                if (_workingBar != null && data.Time - _workingBar.Time >= _period.Value && GetRoundedBarTime(data.Time) > _lastEmit)
                {
                    fireDataConsolidated = true;
                }

                // special case: always aggregate before event trigger when TimeSpan is zero
                if (_period.Value == TimeSpan.Zero)
                {
                    fireDataConsolidated = true;
                    aggregateBeforeFire = true;
                }
            }

            if (aggregateBeforeFire)
            {
                if (data.Time >= _lastEmit)
                {
                    AggregateBar(ref _workingBar, data);
                }
            }

            //Fire the event
            if (fireDataConsolidated)
            {
                var workingTradeBar = _workingBar as TradeBar;
                if (workingTradeBar != null)
                {
                    // we kind of are cheating here...
                    if (_period.HasValue)
                    {
                        workingTradeBar.Period = _period.Value;
                    }
                    // since trade bar has period it aggregates this properly
                    else if (!(data is TradeBar))
                    {
                        workingTradeBar.Period = data.Time - _lastEmit.Value;
                    }
                }

                OnDataConsolidated(_workingBar);
                _lastEmit = IsTimeBased && _workingBar != null ? _workingBar.Time.Add(Period ?? TimeSpan.Zero) : data.Time;
            }

            if (!aggregateBeforeFire)
            {
                if (data.Time >= _lastEmit)
                {
                    AggregateBar(ref _workingBar, data);
                }
            }
        }

        /// <summary>
        /// Scans this consolidator to see if it should emit a bar due to time passing
        /// </summary>
        /// <param name="currentLocalTime">The current time in the local time zone (same as <see cref="BaseData.Time"/>)</param>
        public override void Scan(DateTime currentLocalTime)
        {
            if (_workingBar != null && _period.HasValue && _period.Value != TimeSpan.Zero
                && currentLocalTime - _workingBar.Time >= _period.Value && GetRoundedBarTime(currentLocalTime) > _lastEmit)
            {
                OnDataConsolidated(_workingBar);
                _lastEmit = currentLocalTime;
            }
        }

        /// <summary>
        /// Returns true if this consolidator is time-based, false otherwise
        /// </summary>
        protected bool IsTimeBased => !_maxCount.HasValue;

        /// <summary>
        /// Gets the time period for this consolidator
        /// </summary>
        protected TimeSpan? Period => _period;

        /// <summary>
        /// Determines whether or not the specified data should be processed
        /// </summary>
        /// <param name="data">The data to check</param>
        /// <returns>True if the consolidator should process this data, false otherwise</returns>
        protected virtual bool ShouldProcess(T data) => true;

        /// <summary>
        /// Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
        /// null following the event firing
        /// </summary>
        /// <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new consolidated bar</param>
        /// <param name="data">The new data</param>
        protected abstract void AggregateBar(ref TConsolidated workingBar, T data);

        /// <summary>
        /// Gets a rounded-down bar time. Called by AggregateBar in derived classes.
        /// </summary>
        /// <param name="time">The bar time to be rounded down</param>
        /// <returns>The rounded bar time</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected DateTime GetRoundedBarTime(DateTime time)
        {
            var barTime = _periodSpecification.GetRoundedBarTime(time);

            // In the case of a new bar, define the period defined at opening time
            if (_workingBar == null)
            {
                _period = _periodSpecification.Period;
            }

            return barTime;
        }

        /// <summary>
        /// Event invocator for the <see cref="DataConsolidated"/> event
        /// </summary>
        /// <param name="e">The consolidated data</param>
        protected virtual void OnDataConsolidated(TConsolidated e)
        {
            base.OnDataConsolidated(e);
            DataConsolidated?.Invoke(this, e);

            _workingBar = null;
        }

        /// <summary>
        /// Gets the period specification from the PyObject that can either represent a function object that defines the start time of a consolidated data or a timespan.
        /// </summary>
        /// <param name="pyObject">Python object that defines either a function object that defines the start time of a consolidated data or a timespan</param>
        /// <returns>IPeriodSpecification that represents the PyObject</returns>
        private static IPeriodSpecification GetPeriodSpecificationFromPyObject(PyObject pyObject)
        {
            Func<DateTime, CalendarInfo> expiryFunc;
            if (pyObject.TryConvertToDelegate(out expiryFunc))
            {
                return new FuncPeriodSpecification(expiryFunc);
            }

            using (Py.GIL())
            {
                return new TimeSpanPeriodSpecification(pyObject.As<TimeSpan>());
            }
        }

        /// <summary>
        /// Distinguishes between the different ways a consolidated data start time can be specified
        /// </summary>
        private interface IPeriodSpecification
        {
            TimeSpan? Period { get; }
            DateTime GetRoundedBarTime(DateTime time);
        }

        /// <summary>
        /// User defined the bars period using a counter
        /// </summary>
        private class BarCountPeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; } = null;

            public DateTime GetRoundedBarTime(DateTime time) => time;
        }

        /// <summary>
        /// User defined the bars period using a counter and a period (mixed mode)
        /// </summary>
        private class MixedModePeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; }

            public MixedModePeriodSpecification(TimeSpan period)
            {
                Period = period;
            }

            public DateTime GetRoundedBarTime(DateTime time) => time;
        }

        /// <summary>
        /// User defined the bars period using a time span
        /// </summary>
        private class TimeSpanPeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; }

            public TimeSpanPeriodSpecification(TimeSpan period)
            {
                Period = period;
            }

            public DateTime GetRoundedBarTime(DateTime time) =>
                Period.Value > Time.OneDay
                    ? time // #4915 For periods larger than a day, don't use a rounding schedule.
                    : time.RoundDown(Period.Value);
        }

        /// <summary>
        /// Special case for bars where the open time is defined by a function
        /// </summary>
        private class FuncPeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; private set; }

            public readonly Func<DateTime, CalendarInfo> _calendarInfoFunc;

            public FuncPeriodSpecification(Func<DateTime, CalendarInfo> expiryFunc)
            {
                if (expiryFunc(DateTime.Now).Start > DateTime.Now)
                {
                    throw new ArgumentException($"{nameof(FuncPeriodSpecification)}: Please use a function that computes a date/time in the past (e.g.: Time.StartOfWeek and Time.StartOfMonth)");
                }
                _calendarInfoFunc = expiryFunc;
            }

            public DateTime GetRoundedBarTime(DateTime time)
            {
                var calendarInfo = _calendarInfoFunc(time);
                Period = calendarInfo.Period;
                return calendarInfo.Start;
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Runtime.CompilerServices;
using QuantConnect.Data.Market;
using Python.Runtime;

namespace QuantConnect.Data.Consolidators
{
    /// <summary>
    /// Provides a base class for consolidators that emit data based on the passing of a period of time
    /// or after seeing a max count of data points.
    /// </summary>
    /// <typeparam name="T">The input type of the consolidator</typeparam>
    /// <typeparam name="TConsolidated">The output type of the consolidator</typeparam>
    public abstract class PeriodCountConsolidatorBase<T, TConsolidated> : DataConsolidator<T>
        where T : IBaseData
        where TConsolidated : BaseData
    {
        // The SecurityIdentifier that we are consolidating for.
        private SecurityIdentifier _securityIdentifier;
        private bool _securityIdentifierIsSet;
        //The number of data updates between creating new bars.
        private readonly int? _maxCount;
        //
        private readonly IPeriodSpecification _periodSpecification;
        //The minimum timespan between creating new bars.
        private TimeSpan? _period;
        //The number of pieces of data we've accumulated since our last emit
        private int _currentCount;
        //The working bar used for aggregating the data
        private TConsolidated _workingBar;
        //The last time we emitted a consolidated bar
        private DateTime? _lastEmit;

        private PeriodCountConsolidatorBase(IPeriodSpecification periodSpecification)
        {
            _periodSpecification = periodSpecification;
            _period = _periodSpecification.Period;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the period
        /// </summary>
        /// <param name="period">The minimum span of time before emitting a consolidated bar</param>
        protected PeriodCountConsolidatorBase(TimeSpan period)
            : this(new TimeSpanPeriodSpecification(period))
        {
            _period = _periodSpecification.Period;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data
        /// </summary>
        /// <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        protected PeriodCountConsolidatorBase(int maxCount)
            : this(new BarCountPeriodSpecification())
        {
            _maxCount = maxCount;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
        /// </summary>
        /// <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        /// <param name="period">The minimum span of time before emitting a consolidated bar</param>
        protected PeriodCountConsolidatorBase(int maxCount, TimeSpan period)
            : this(new MixedModePeriodSpecification(period))
        {
            _maxCount = maxCount;
            _period = _periodSpecification.Period;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
        /// </summary>
        /// <param name="func">Func that defines the start time of a consolidated data</param>
        protected PeriodCountConsolidatorBase(Func<DateTime, CalendarInfo> func)
            : this(new FuncPeriodSpecification(func))
        {
            _period = Time.OneSecond;
        }

        /// <summary>
        /// Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
        /// </summary>
        /// <param name="pyObject">Python object that defines either a function object that defines the start time of a consolidated data or a timespan</param>
        protected PeriodCountConsolidatorBase(PyObject pyObject)
            : this(GetPeriodSpecificationFromPyObject(pyObject))
        {
        }

        /// <summary>
        /// Gets the type produced by this consolidator
        /// </summary>
        public override Type OutputType => typeof(TConsolidated);

        /// <summary>
        /// Gets a clone of the data being currently consolidated
        /// </summary>
        public override IBaseData WorkingData => _workingBar?.Clone();

        /// <summary>
        /// Event handler that fires when a new piece of data is produced. We define this as a 'new'
        /// event so we can expose it as a <typeparamref name="TConsolidated"/> instead of a <see cref="BaseData"/> instance
        /// </summary>
        public new event EventHandler<TConsolidated> DataConsolidated;

        /// <summary>
        /// Updates this consolidator with the specified data. This method is
        /// responsible for raising the DataConsolidated event
        /// In time span mode, the bar range is closed on the left and open on the right: [T, T+TimeSpan).
        /// For example, if time span is 1 minute, we have [10:00, 10:01): so data at 10:01 is not 
        /// included in the bar starting at 10:00.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when multiple symbols are being consolidated.</exception>
        /// <param name="data">The new data for the consolidator</param>
        public override void Update(T data)
        {
            if (!_securityIdentifierIsSet)
            {
                _securityIdentifierIsSet = true;
                _securityIdentifier = data.Symbol.ID;
            }
            else if (!data.Symbol.ID.Equals(_securityIdentifier))
            {
                throw new InvalidOperationException($"Consolidators can only be used with a single symbol. The previous consolidated SecurityIdentifier ({_securityIdentifier}) is not the same as in the current data ({data.Symbol.ID}).");
            }

            if (!ShouldProcess(data))
            {
                // first allow the base class a chance to filter out data it doesn't want
                // before we start incrementing counts and what not
                return;
            }

            //Decide to fire the event
            var fireDataConsolidated = false;

            // decide to aggregate data before or after firing OnDataConsolidated event
            // always aggregate before firing in counting mode
            bool aggregateBeforeFire = _maxCount.HasValue;

            if (_maxCount.HasValue)
            {
                // we're in count mode
                _currentCount++;
                if (_currentCount >= _maxCount.Value)
                {
                    _currentCount = 0;
                    fireDataConsolidated = true;
                }
            }

            if (!_lastEmit.HasValue)
            {
                // initialize this value for period computations
                _lastEmit = IsTimeBased ? DateTime.MinValue : data.Time;
            }

            if (_period.HasValue)
            {
                // we're in time span mode and initialized
                if (_workingBar != null && data.Time - _workingBar.Time >= _period.Value && GetRoundedBarTime(data.Time) > _lastEmit)
                {
                    fireDataConsolidated = true;
                }

                // special case: always aggregate before event trigger when TimeSpan is zero
                if (_period.Value == TimeSpan.Zero)
                {
                    fireDataConsolidated = true;
                    aggregateBeforeFire = true;
                }
            }

            if (aggregateBeforeFire)
            {
                if (data.Time >= _lastEmit)
                {
                    AggregateBar(ref _workingBar, data);
                }
            }

            //Fire the event
            if (fireDataConsolidated)
            {
                if (_workingBar is TradeBar workingTradeBar)
                {
                    // we kind of are cheating here...
                    if (_period.HasValue)
                    {
                        workingTradeBar.Period = _period.Value;
                    }
                    // since trade bar has period it aggregates this properly
                    else if (!(data is TradeBar))
                    {
                        workingTradeBar.Period = data.Time - _lastEmit.Value;
                    }
                }

                OnDataConsolidated(_workingBar);
                _lastEmit = IsTimeBased && _workingBar != null ? _workingBar.Time.Add(Period ?? TimeSpan.Zero) : data.Time;
            }

            if (!aggregateBeforeFire)
            {
                if (data.Time >= _lastEmit)
                {
                    AggregateBar(ref _workingBar, data);
                }
            }
        }

        /// <summary>
        /// Scans this consolidator to see if it should emit a bar due to time passing
        /// </summary>
        /// <param name="currentLocalTime">The current time in the local time zone (same as <see cref="BaseData.Time"/>)</param>
        public override void Scan(DateTime currentLocalTime)
        {
            if (_workingBar != null && _period.HasValue && _period.Value != TimeSpan.Zero
                && currentLocalTime - _workingBar.Time >= _period.Value && GetRoundedBarTime(currentLocalTime) > _lastEmit)
            {
                OnDataConsolidated(_workingBar);
                _lastEmit = currentLocalTime;
            }
        }

        /// <summary>
        /// Returns true if this consolidator is time-based, false otherwise
        /// </summary>
        protected bool IsTimeBased => !_maxCount.HasValue;

        /// <summary>
        /// Gets the time period for this consolidator
        /// </summary>
        protected TimeSpan? Period => _period;

        /// <summary>
        /// Determines whether or not the specified data should be processed
        /// </summary>
        /// <param name="data">The data to check</param>
        /// <returns>True if the consolidator should process this data, false otherwise</returns>
        protected virtual bool ShouldProcess(T data) => true;

        /// <summary>
        /// Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
        /// null following the event firing
        /// </summary>
        /// <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new consolidated bar</param>
        /// <param name="data">The new data</param>
        protected abstract void AggregateBar(ref TConsolidated workingBar, T data);

        /// <summary>
        /// Gets a rounded-down bar time. Called by AggregateBar in derived classes.
        /// </summary>
        /// <param name="time">The bar time to be rounded down</param>
        /// <returns>The rounded bar time</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected DateTime GetRoundedBarTime(DateTime time)
        {
            var barTime = _periodSpecification.GetRoundedBarTime(time);

            // In the case of a new bar, define the period defined at opening time
            if (_workingBar == null)
            {
                _period = _periodSpecification.Period;
            }

            return barTime;
        }

        /// <summary>
        /// Event invocator for the <see cref="DataConsolidated"/> event
        /// </summary>
        /// <param name="e">The consolidated data</param>
        protected virtual void OnDataConsolidated(TConsolidated e)
        {
            base.OnDataConsolidated(e);
            DataConsolidated?.Invoke(this, e);

            _workingBar = null;
        }

        /// <summary>
        /// Gets the period specification from the PyObject that can either represent a function object that defines the start time of a consolidated data or a timespan.
        /// </summary>
        /// <param name="pyObject">Python object that defines either a function object that defines the start time of a consolidated data or a timespan</param>
        /// <returns>IPeriodSpecification that represents the PyObject</returns>
        private static IPeriodSpecification GetPeriodSpecificationFromPyObject(PyObject pyObject)
        {
            Func<DateTime, CalendarInfo> expiryFunc;
            if (pyObject.TryConvertToDelegate(out expiryFunc))
            {
                return new FuncPeriodSpecification(expiryFunc);
            }

            using (Py.GIL())
            {
                return new TimeSpanPeriodSpecification(pyObject.As<TimeSpan>());
            }
        }

        /// <summary>
        /// Distinguishes between the different ways a consolidated data start time can be specified
        /// </summary>
        private interface IPeriodSpecification
        {
            TimeSpan? Period { get; }
            DateTime GetRoundedBarTime(DateTime time);
        }

        /// <summary>
        /// User defined the bars period using a counter
        /// </summary>
        private class BarCountPeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; } = null;

            public DateTime GetRoundedBarTime(DateTime time) => time;
        }

        /// <summary>
        /// User defined the bars period using a counter and a period (mixed mode)
        /// </summary>
        private class MixedModePeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; }

            public MixedModePeriodSpecification(TimeSpan period)
            {
                Period = period;
            }

            public DateTime GetRoundedBarTime(DateTime time) => time;
        }

        /// <summary>
        /// User defined the bars period using a time span
        /// </summary>
        private class TimeSpanPeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; }

            public TimeSpanPeriodSpecification(TimeSpan period)
            {
                Period = period;
            }

            public DateTime GetRoundedBarTime(DateTime time) =>
                Period.Value > Time.OneDay
                    ? time // #4915 For periods larger than a day, don't use a rounding schedule.
                    : time.RoundDown(Period.Value);
        }

        /// <summary>
        /// Special case for bars where the open time is defined by a function
        /// </summary>
        private class FuncPeriodSpecification : IPeriodSpecification
        {
            public TimeSpan? Period { get; private set; }

            public readonly Func<DateTime, CalendarInfo> _calendarInfoFunc;

            public FuncPeriodSpecification(Func<DateTime, CalendarInfo> expiryFunc)
            {
                if (expiryFunc(DateTime.Now).Start > DateTime.Now)
                {
                    throw new ArgumentException($"{nameof(FuncPeriodSpecification)}: Please use a function that computes a date/time in the past (e.g.: Time.StartOfWeek and Time.StartOfMonth)");
                }
                _calendarInfoFunc = expiryFunc;
            }

            public DateTime GetRoundedBarTime(DateTime time)
            {
                var calendarInfo = _calendarInfoFunc(time);
                Period = calendarInfo.Period;
                return calendarInfo.Start;
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Common\Data\Consolidators\PeriodCountConsolidatorBase.cs(202,36): error CS8314: An expression of type 'TConsolidated' cannot be handled by a pattern of type 'TradeBar' in C# 7.0. Please use language version 7.1 or greater.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Common\Parameters\ParameterAttribute.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using QuantConnect.Logging;
using QuantConnect.Packets;

namespace QuantConnect.Parameters
{
    /// <summary>
    /// Specifies a field or property is a parameter that can be set
    /// from an <see cref="AlgorithmNodePacket.Parameters"/> dictionary
    /// </summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    public class ParameterAttribute : Attribute
    {
        /// <summary>
        /// Specifies the binding flags used by this implementation to resolve parameter attributes
        /// </summary>
        public const BindingFlags BindingFlags = System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance;

        private static readonly string ParameterAttributeNameProperty = "Name";

        /// <summary>
        /// Gets the name of this parameter
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ParameterAttribute"/> class
        /// </summary>
        /// <param name="name">The name of the parameter. If null is specified
        /// then the field or property name will be used</param>
        public ParameterAttribute(string name = null)
        {
            Name = name;
        }

        /// <summary>
        /// Uses reflections to inspect the instance for any parameter attributes.
        /// If a value is found in the parameters dictionary, it is set.
        /// </summary>
        /// <param name="parameters">The parameters dictionary</param>
        /// <param name="instance">The instance to set parameters on</param>
        public static void ApplyAttributes(Dictionary<string, string> parameters, object instance)
        {
            if (instance == null) throw new ArgumentNullException(nameof(instance));

            var type = instance.GetType();

            // get all fields/properties on the instance
            var members = type.GetFields(BindingFlags).Concat<MemberInfo>(type.GetProperties(BindingFlags));
            foreach (var memberInfo in members)
            {
                var fieldInfo = memberInfo as FieldInfo;
                var propertyInfo = memberInfo as PropertyInfo;

                // this line make static analysis a little happier, but should never actually throw
                if (fieldInfo == null && propertyInfo == null)
                {
                    throw new InvalidOperationException("Resolved member that is neither FieldInfo or PropertyInfo");
                }

                // check the member for our custom attribute
                var attribute = memberInfo.GetCustomAttribute<ParameterAttribute>();
                if (attribute == null) continue;

                // if no name is specified in the attribute then use the member name
                var parameterName = attribute.Name ?? memberInfo.Name;

                // get the parameter string value to apply to the member
                string parameterValue;
                if (!parameters.TryGetValue(parameterName, out parameterValue)) continue;

                if (string.IsNullOrEmpty(parameterValue))
                {
                    Log.Error($"ParameterAttribute.ApplyAttributes(): parameter '{parameterName}' provided value is null/empty, skipping");
                    continue;
                }

                // if it's a read-only property with a parameter value we can't really do anything, bail
                if (propertyInfo != null && !propertyInfo.CanWrite)
                {
                    var message = $"The specified property is read only: {propertyInfo.DeclaringType}.{propertyInfo.Name}";
                    throw new InvalidOperationException(message);
                }

                // resolve the member type
                var memberType = fieldInfo != null ? fieldInfo.FieldType : propertyInfo.PropertyType;

                // convert the parameter string value to the member type
                var value = parameterValue.ConvertTo(memberType);

                // set the value to the field/property
                if (fieldInfo != null)
                {
                    fieldInfo.SetValue(instance, value);
                }
                else
                {
                    propertyInfo.SetValue(instance, value);
                }
            }
        }

        /// <summary>
        /// Resolves all parameter attributes from the specified compiled assembly path
        /// </summary>
        /// <param name="assembly">The assembly to inspect</param>
        /// <returns>Parameters dictionary keyed by parameter name with a value of the member type</returns>
        public static Dictionary<string, string> GetParametersFromAssembly(Assembly assembly)
        {
            var parameters = new Dictionary<string, string>();
            foreach (var type in assembly.GetTypes())
            {
                foreach (var kvp in GetParametersFromType(type))
                {
                    parameters[kvp.Key] = kvp.Value;
                }
            }
            return parameters;
        }

        /// <summary>
        /// Resolves all parameter attributes from the specified type
        /// </summary>
        /// <param name="type">The type to inspect</param>
        /// <returns>Parameters dictionary keyed by parameter name with a value of the member type</returns>
        public static IEnumerable<KeyValuePair<string, string>> GetParametersFromType(Type type)
        {
            foreach (var field in type.GetFields(BindingFlags))
            {
                var attribute = field.GetCustomAttribute<ParameterAttribute>();
                if (attribute != null)
                {
                    var parameterName = attribute.Name ?? field.Name;
                    yield return new KeyValuePair<string, string>(parameterName, field.FieldType.GetBetterTypeName());
                }
            }

            foreach (var property in type.GetProperties(BindingFlags))
            {
                // ignore non-writeable properties
                if (!property.CanWrite) continue;
                var attribute = property.GetCustomAttribute<ParameterAttribute>();
                if (attribute != null)
                {
                    var parameterName = attribute.Name ?? property.Name;
                    yield return new KeyValuePair<string, string>(parameterName, property.PropertyType.GetBetterTypeName());
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using QuantConnect.Logging;
using QuantConnect.Packets;

namespace QuantConnect.Parameters
{
    /// <summary>
    /// Specifies a field or property is a parameter that can be set
    /// from an <see cref="AlgorithmNodePacket.Parameters"/> dictionary
    /// </summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    public class ParameterAttribute : Attribute
    {
        /// <summary>
        /// Specifies the binding flags used by this implementation to resolve parameter attributes
        /// </summary>
        public const BindingFlags BindingFlags = System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance;

        private static readonly string ParameterAttributeNameProperty = "Name";

        /// <summary>
        /// Gets the name of this parameter
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ParameterAttribute"/> class
        /// </summary>
        /// <param name="name">The name of the parameter. If null is specified
        /// then the field or property name will be used</param>
        public ParameterAttribute(string name = null)
        {
            Name = name;
        }

        /// <summary>
        /// Uses reflections to inspect the instance for any parameter attributes.
        /// If a value is found in the parameters dictionary, it is set.
        /// </summary>
        /// <param name="parameters">The parameters dictionary</param>
        /// <param name="instance">The instance to set parameters on</param>
        public static void ApplyAttributes(Dictionary<string, string> parameters, object instance)
        {
            if (instance == null) throw new ArgumentNullException(nameof(instance));

            var type = instance.GetType();

            // get all fields/properties on the instance
            var members = type.GetFields(BindingFlags).Concat<MemberInfo>(type.GetProperties(BindingFlags));
            foreach (var memberInfo in members)
            {

                // this line make static analysis a little happier, but should never actually throw
                if (fieldInfo == null && propertyInfo == null)
                {
                    throw new InvalidOperationException("Resolved member that is neither FieldInfo or PropertyInfo");
                }

                // check the member for our custom attribute
                var attribute = memberInfo.GetCustomAttribute<ParameterAttribute>();
                if (attribute == null) continue;

                // if no name is specified in the attribute then use the member name
                var parameterName = attribute.Name ?? memberInfo.Name;

                // get the parameter string value to apply to the member
                string parameterValue;
                if (!parameters.TryGetValue(parameterName, out parameterValue)) continue;

                if (string.IsNullOrEmpty(parameterValue))
                {
                    Log.Error($"ParameterAttribute.ApplyAttributes(): parameter '{parameterName}' provided value is null/empty, skipping");
                    continue;
                }

                // if it's a read-only property with a parameter value we can't really do anything, bail
                if (memberInfo is PropertyInfo propertyInfo && !propertyInfo.CanWrite)
                {
                    var message = $"The specified property is read only: {propertyInfo.DeclaringType}.{propertyInfo.Name}";
                    throw new InvalidOperationException(message);
                }

                // resolve the member type
                var memberType = memberInfo is FieldInfo fieldInfo ? fieldInfo.FieldType : propertyInfo.PropertyType;

                // convert the parameter string value to the member type
                var value = parameterValue.ConvertTo(memberType);

                // set the value to the field/property
                if (memberInfo is FieldInfo fieldInfo)
                {
                    fieldInfo.SetValue(instance, value);
                }
                else
                {
                    propertyInfo.SetValue(instance, value);
                }
            }
        }

        /// <summary>
        /// Resolves all parameter attributes from the specified compiled assembly path
        /// </summary>
        /// <param name="assembly">The assembly to inspect</param>
        /// <returns>Parameters dictionary keyed by parameter name with a value of the member type</returns>
        public static Dictionary<string, string> GetParametersFromAssembly(Assembly assembly)
        {
            var parameters = new Dictionary<string, string>();
            foreach (var type in assembly.GetTypes())
            {
                foreach (var kvp in GetParametersFromType(type))
                {
                    parameters[kvp.Key] = kvp.Value;
                }
            }
            return parameters;
        }

        /// <summary>
        /// Resolves all parameter attributes from the specified type
        /// </summary>
        /// <param name="type">The type to inspect</param>
        /// <returns>Parameters dictionary keyed by parameter name with a value of the member type</returns>
        public static IEnumerable<KeyValuePair<string, string>> GetParametersFromType(Type type)
        {
            foreach (var field in type.GetFields(BindingFlags))
            {
                var attribute = field.GetCustomAttribute<ParameterAttribute>();
                if (attribute != null)
                {
                    var parameterName = attribute.Name ?? field.Name;
                    yield return new KeyValuePair<string, string>(parameterName, field.FieldType.GetBetterTypeName());
                }
            }

            foreach (var property in type.GetProperties(BindingFlags))
            {
                // ignore non-writeable properties
                if (!property.CanWrite) continue;
                var attribute = property.GetCustomAttribute<ParameterAttribute>();
                if (attribute != null)
                {
                    var parameterName = attribute.Name ?? property.Name;
                    yield return new KeyValuePair<string, string>(parameterName, property.PropertyType.GetBetterTypeName());
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Common\Parameters\ParameterAttribute.cs(72,21): error CS0841: Cannot use local variable 'fieldInfo' before it is declared,D:\a\1\s\Common\Parameters\ParameterAttribute.cs(72,42): error CS0841: Cannot use local variable 'propertyInfo' before it is declared,D:\a\1\s\Common\Parameters\ParameterAttribute.cs(108,45): error CS0128: A local variable or function named 'fieldInfo' is already defined in this scope
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Common\Securities\SecurityCache.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Util;

namespace QuantConnect.Securities
{
    /// <summary>
    /// Base class caching caching spot for security data and any other temporary properties.
    /// </summary>
    /// <remarks>
    /// This class is virtually unused and will soon be made obsolete.
    /// This comment made in a remark to prevent obsolete errors in all users algorithms
    /// </remarks>
    public class SecurityCache
    {
        // this is used to prefer quote bar data over the tradebar data
        private DateTime _lastQuoteBarUpdate;
        private DateTime _lastOHLCUpdate;
        private BaseData _lastData;
        private IReadOnlyList<BaseData> _lastTickQuotes = new List<BaseData>();
        private IReadOnlyList<BaseData> _lastTickTrades = new List<BaseData>();
        private ConcurrentDictionary<Type, IReadOnlyList<BaseData>> _dataByType = new ConcurrentDictionary<Type, IReadOnlyList<BaseData>>();

        /// <summary>
        /// Gets the most recent price submitted to this cache
        /// </summary>
        public decimal Price { get; private set; }

        /// <summary>
        /// Gets the most recent open submitted to this cache
        /// </summary>
        public decimal Open { get; private set; }

        /// <summary>
        /// Gets the most recent high submitted to this cache
        /// </summary>
        public decimal High { get; private set; }

        /// <summary>
        /// Gets the most recent low submitted to this cache
        /// </summary>
        public decimal Low { get; private set; }

        /// <summary>
        /// Gets the most recent close submitted to this cache
        /// </summary>
        public decimal Close { get; private set; }

        /// <summary>
        /// Gets the most recent bid submitted to this cache
        /// </summary>
        public decimal BidPrice { get; private set; }

        /// <summary>
        /// Gets the most recent ask submitted to this cache
        /// </summary>
        public decimal AskPrice { get; private set; }

        /// <summary>
        /// Gets the most recent bid size submitted to this cache
        /// </summary>
        public decimal BidSize { get; private set; }

        /// <summary>
        /// Gets the most recent ask size submitted to this cache
        /// </summary>
        public decimal AskSize { get; private set; }

        /// <summary>
        /// Gets the most recent volume submitted to this cache
        /// </summary>
        public decimal Volume { get; private set; }

        /// <summary>
        /// Gets the most recent open interest submitted to this cache
        /// </summary>
        public long OpenInterest { get; private set; }

        /// <summary>
        /// Add a list of market data points to the local security cache for the current market price.
        /// </summary>
        /// <remarks>Internally uses <see cref="AddData"/> using the last data point of the provided list
        /// and it stores by type the non fill forward points using <see cref="StoreData"/></remarks>
        public void AddDataList(IReadOnlyList<BaseData> data, Type dataType, bool? containsFillForwardData = null)
        {
            var nonFillForwardData = data;
            // maintaining regression requires us to NOT cache FF data
            if (containsFillForwardData != false)
            {
                var dataFiltered = new List<BaseData>(data.Count);
                for (var i = 0; i < data.Count; i++)
                {
                    var dataPoint = data[i];
                    if (!dataPoint.IsFillForward)
                    {
                        dataFiltered.Add(dataPoint);
                    }
                }
                nonFillForwardData = dataFiltered;
            }
            if (nonFillForwardData.Count != 0)
            {
                StoreData(nonFillForwardData, dataType);
            }
            else if (dataType == typeof(OpenInterest))
            {
                StoreData(data, typeof(OpenInterest));
            }

            var last = data[data.Count - 1];

            AddDataImpl(last, cacheByType: false);
        }

        /// <summary>
        /// Add a new market data point to the local security cache for the current market price.
        /// Rules:
        ///     Don't cache fill forward data.
        ///     Always return the last observation.
        ///     If two consecutive data has the same time stamp and one is Quotebars and the other Tradebar, prioritize the Quotebar.
        /// </summary>
        public void AddData(BaseData data)
        {
            AddDataImpl(data, cacheByType: true);
        }

        private void AddDataImpl(BaseData data, bool cacheByType)
        {
            var tick = data as Tick;
            if (tick?.TickType == TickType.OpenInterest)
            {
                if (cacheByType)
                {
                    StoreDataPoint(data);
                }
                OpenInterest = (long)tick.Value;
                return;
            }

            // Only cache non fill-forward data.
            if (data.IsFillForward) return;

            if (cacheByType)
            {
                StoreDataPoint(data);
            }

            var isDefaultDataType = SubscriptionManager.IsDefaultDataType(data);

            // don't set _lastData if receive quotebar then tradebar w/ same end time. this
            // was implemented to grant preference towards using quote data in the fill
            // models and provide a level of determinism on the values exposed via the cache.
            if ((_lastData == null
              || _lastQuoteBarUpdate != data.EndTime
              || data.DataType != MarketDataType.TradeBar)
                // we will only set the default data type to preserve determinism and backwards compatibility
                && isDefaultDataType)
            {
                _lastData = data;
            }

            if (tick != null)
            {
                if (tick.Value != 0) Price = tick.Value;

                switch (tick.TickType)
                {
                    case TickType.Trade:
                        if (tick.Quantity != 0) Volume = tick.Quantity;
                        break;

                    case TickType.Quote:
                        if (tick.BidPrice != 0) BidPrice = tick.BidPrice;
                        if (tick.BidSize != 0) BidSize = tick.BidSize;

                        if (tick.AskPrice != 0) AskPrice = tick.AskPrice;
                        if (tick.AskSize != 0) AskSize = tick.AskSize;
                        break;
                }
                return;
            }

            var bar = data as IBar;
            if (bar != null)
            {
                // we will only set OHLC values using the default data type to preserve determinism and backwards compatibility.
                // Gives priority to QuoteBar over TradeBar, to be removed when default data type completely addressed GH issue 4196
                if ((_lastQuoteBarUpdate != data.EndTime || _lastOHLCUpdate != data.EndTime) && isDefaultDataType)
                {
                    _lastOHLCUpdate = data.EndTime;
                    if (bar.Open != 0) Open = bar.Open;
                    if (bar.High != 0) High = bar.High;
                    if (bar.Low != 0) Low = bar.Low;
                    if (bar.Close != 0)
                    {
                        Price = bar.Close;
                        Close = bar.Close;
                    }
                }

                var tradeBar = bar as TradeBar;
                if (tradeBar != null)
                {
                    if (tradeBar.Volume != 0) Volume = tradeBar.Volume;
                }

                var quoteBar = bar as QuoteBar;
                if (quoteBar != null)
                {
                    _lastQuoteBarUpdate = quoteBar.EndTime;
                    if (quoteBar.Ask != null && quoteBar.Ask.Close != 0) AskPrice = quoteBar.Ask.Close;
                    if (quoteBar.Bid != null && quoteBar.Bid.Close != 0) BidPrice = quoteBar.Bid.Close;
                    if (quoteBar.LastBidSize != 0) BidSize = quoteBar.LastBidSize;
                    if (quoteBar.LastAskSize != 0) AskSize = quoteBar.LastAskSize;
                }
            }
            else if (data.DataType != MarketDataType.Auxiliary)
            {
                Price = data.Price;
            }
        }

        /// <summary>
        /// Stores the specified data list in the cache WITHOUT updating any of the cache properties, such as Price
        /// </summary>
        /// <param name="data">The collection of data to store in this cache</param>
        /// <param name="dataType">The data type</param>
        public void StoreData(IReadOnlyList<BaseData> data, Type dataType)
        {
#if DEBUG // don't run this in release as we should never fail here, but it's also nice to have here as documentation of intent
            if (data.DistinctBy(d => d.GetType()).Skip(1).Any())
            {
                throw new ArgumentException(
                    "SecurityCache.StoreData data list must contain elements of the same type."
                );
            }
#endif
            if (dataType == typeof(Tick))
            {
                var tick = data[data.Count - 1] as Tick;
                switch (tick?.TickType)
                {
                    case TickType.Trade:
                        _lastTickTrades = data;
                        return;
                    case TickType.Quote:
                        _lastTickQuotes = data;
                        return;
                }
            }

            _dataByType[dataType] = data;
        }

        /// <summary>
        /// Get last data packet received for this security
        /// </summary>
        /// <returns>BaseData type of the security</returns>
        public BaseData GetData()
        {
            return _lastData;
        }

        /// <summary>
        /// Get last data packet received for this security of the specified type
        /// </summary>
        /// <typeparam name="T">The data type</typeparam>
        /// <returns>The last data packet, null if none received of type</returns>
        public T GetData<T>()
            where T : BaseData
        {
            IReadOnlyList<BaseData> list;
            if (!TryGetValue(typeof(T), out list) || list.Count == 0)
            {
                return default(T);
            }

            return list[list.Count - 1] as T;
        }

        /// <summary>
        /// Gets all data points of the specified type from the most recent time step
        /// that produced data for that type
        /// </summary>
        public IEnumerable<T> GetAll<T>()
        {
            if (typeof(T) == typeof(Tick))
            {
                return _lastTickTrades.Concat(_lastTickQuotes).Cast<T>();
            }

            IReadOnlyList<BaseData> list;
            if (!_dataByType.TryGetValue(typeof(T), out list))
            {
                return new List<T>();
            }

            return list.Cast<T>();
        }

        /// <summary>
        /// Reset cache storage and free memory
        /// </summary>
        public void Reset()
        {
            _dataByType.Clear();
            _lastTickQuotes = new List<BaseData>();
            _lastTickTrades = new List<BaseData>();
        }

        /// <summary>
        /// Gets whether or not this dynamic data instance has data stored for the specified type
        /// </summary>
        public bool HasData(Type type)
        {
            IReadOnlyList<BaseData> data;
            return TryGetValue(type, out data);
        }

        /// <summary>
        /// Gets whether or not this dynamic data instance has data stored for the specified type
        /// </summary>
        public bool TryGetValue(Type type, out IReadOnlyList<BaseData> data)
        {
            if (type == typeof(Tick))
            {
                var quote = _lastTickQuotes.LastOrDefault();
                var trade = _lastTickTrades.LastOrDefault();
                var isQuoteDefaultDataType = quote != null && SubscriptionManager.IsDefaultDataType(quote);
                var isTradeDefaultDataType = trade != null && SubscriptionManager.IsDefaultDataType(trade);

                // Currently, IsDefaultDataType returns true for both cases,
                // So we will return the list with the tick with the most recent timestamp
                if (isQuoteDefaultDataType && isTradeDefaultDataType)
                {
                    data = quote.EndTime > trade.EndTime ? _lastTickQuotes : _lastTickTrades;
                    return true;
                }

                data = isQuoteDefaultDataType ? _lastTickQuotes : _lastTickTrades;
                return data?.Count > 0;
            }

            return _dataByType.TryGetValue(type, out data);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void StoreDataPoint(BaseData data)
        {
            if (data.GetType() == typeof(Tick))
            {
                var tick = data as Tick;
                switch (tick?.TickType)
                {
                    case TickType.Trade:
                        _lastTickTrades = new List<BaseData> { tick };
                        break;
                    case TickType.Quote:
                        _lastTickQuotes = new List<BaseData> { tick };
                        break;
                }
            }
            else
            {
                // Always keep track of the last observation
                IReadOnlyList<BaseData> list;
                if (!_dataByType.TryGetValue(data.GetType(), out list))
                {
                    list = new List<BaseData> { data };
                    _dataByType[data.GetType()] = list;
                }
                else
                {
                    // we KNOW this one is actually a list, so this is safe
                    // we overwrite the zero entry so we're not constantly newing up lists
                    ((List<BaseData>)list)[0] = data;
                }
            }
        }

        /// <summary>
        /// Helper method that modifies the target security cache instance to use the
        /// type cache of the source
        /// </summary>
        /// <remarks>Will set in the source cache any data already present in the target cache</remarks>
        /// <remarks>This is useful for custom data securities which also have an underlying security,
        /// will allow both securities to access the same data by type</remarks>
        /// <param name="sourceToShare">The source cache to use</param>
        /// <param name="targetToModify">The target security cache that will be modified</param>
        public static void ShareTypeCacheInstance(SecurityCache sourceToShare, SecurityCache targetToModify)
        {
            foreach (var kvp in targetToModify._dataByType)
            {
                sourceToShare._dataByType.TryAdd(kvp.Key, kvp.Value);
            }
            targetToModify._dataByType = sourceToShare._dataByType;
            targetToModify._lastTickTrades = sourceToShare._lastTickTrades;
            targetToModify._lastTickQuotes = sourceToShare._lastTickQuotes;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Util;

namespace QuantConnect.Securities
{
    /// <summary>
    /// Base class caching caching spot for security data and any other temporary properties.
    /// </summary>
    /// <remarks>
    /// This class is virtually unused and will soon be made obsolete.
    /// This comment made in a remark to prevent obsolete errors in all users algorithms
    /// </remarks>
    public class SecurityCache
    {
        // this is used to prefer quote bar data over the tradebar data
        private DateTime _lastQuoteBarUpdate;
        private DateTime _lastOHLCUpdate;
        private BaseData _lastData;
        private IReadOnlyList<BaseData> _lastTickQuotes = new List<BaseData>();
        private IReadOnlyList<BaseData> _lastTickTrades = new List<BaseData>();
        private ConcurrentDictionary<Type, IReadOnlyList<BaseData>> _dataByType = new ConcurrentDictionary<Type, IReadOnlyList<BaseData>>();

        /// <summary>
        /// Gets the most recent price submitted to this cache
        /// </summary>
        public decimal Price { get; private set; }

        /// <summary>
        /// Gets the most recent open submitted to this cache
        /// </summary>
        public decimal Open { get; private set; }

        /// <summary>
        /// Gets the most recent high submitted to this cache
        /// </summary>
        public decimal High { get; private set; }

        /// <summary>
        /// Gets the most recent low submitted to this cache
        /// </summary>
        public decimal Low { get; private set; }

        /// <summary>
        /// Gets the most recent close submitted to this cache
        /// </summary>
        public decimal Close { get; private set; }

        /// <summary>
        /// Gets the most recent bid submitted to this cache
        /// </summary>
        public decimal BidPrice { get; private set; }

        /// <summary>
        /// Gets the most recent ask submitted to this cache
        /// </summary>
        public decimal AskPrice { get; private set; }

        /// <summary>
        /// Gets the most recent bid size submitted to this cache
        /// </summary>
        public decimal BidSize { get; private set; }

        /// <summary>
        /// Gets the most recent ask size submitted to this cache
        /// </summary>
        public decimal AskSize { get; private set; }

        /// <summary>
        /// Gets the most recent volume submitted to this cache
        /// </summary>
        public decimal Volume { get; private set; }

        /// <summary>
        /// Gets the most recent open interest submitted to this cache
        /// </summary>
        public long OpenInterest { get; private set; }

        /// <summary>
        /// Add a list of market data points to the local security cache for the current market price.
        /// </summary>
        /// <remarks>Internally uses <see cref="AddData"/> using the last data point of the provided list
        /// and it stores by type the non fill forward points using <see cref="StoreData"/></remarks>
        public void AddDataList(IReadOnlyList<BaseData> data, Type dataType, bool? containsFillForwardData = null)
        {
            var nonFillForwardData = data;
            // maintaining regression requires us to NOT cache FF data
            if (containsFillForwardData != false)
            {
                var dataFiltered = new List<BaseData>(data.Count);
                for (var i = 0; i < data.Count; i++)
                {
                    var dataPoint = data[i];
                    if (!dataPoint.IsFillForward)
                    {
                        dataFiltered.Add(dataPoint);
                    }
                }
                nonFillForwardData = dataFiltered;
            }
            if (nonFillForwardData.Count != 0)
            {
                StoreData(nonFillForwardData, dataType);
            }
            else if (dataType == typeof(OpenInterest))
            {
                StoreData(data, typeof(OpenInterest));
            }

            var last = data[data.Count - 1];

            AddDataImpl(last, cacheByType: false);
        }

        /// <summary>
        /// Add a new market data point to the local security cache for the current market price.
        /// Rules:
        ///     Don't cache fill forward data.
        ///     Always return the last observation.
        ///     If two consecutive data has the same time stamp and one is Quotebars and the other Tradebar, prioritize the Quotebar.
        /// </summary>
        public void AddData(BaseData data)
        {
            AddDataImpl(data, cacheByType: true);
        }

        private void AddDataImpl(BaseData data, bool cacheByType)
        {
            if (tick?.TickType == TickType.OpenInterest)
            {
                if (cacheByType)
                {
                    StoreDataPoint(data);
                }
                OpenInterest = (long)tick.Value;
                return;
            }

            // Only cache non fill-forward data.
            if (data.IsFillForward) return;

            if (cacheByType)
            {
                StoreDataPoint(data);
            }

            var isDefaultDataType = SubscriptionManager.IsDefaultDataType(data);

            // don't set _lastData if receive quotebar then tradebar w/ same end time. this
            // was implemented to grant preference towards using quote data in the fill
            // models and provide a level of determinism on the values exposed via the cache.
            if ((_lastData == null
              || _lastQuoteBarUpdate != data.EndTime
              || data.DataType != MarketDataType.TradeBar)
                // we will only set the default data type to preserve determinism and backwards compatibility
                && isDefaultDataType)
            {
                _lastData = data;
            }

            if (data is Tick tick)
            {
                if (tick.Value != 0) Price = tick.Value;

                switch (tick.TickType)
                {
                    case TickType.Trade:
                        if (tick.Quantity != 0) Volume = tick.Quantity;
                        break;

                    case TickType.Quote:
                        if (tick.BidPrice != 0) BidPrice = tick.BidPrice;
                        if (tick.BidSize != 0) BidSize = tick.BidSize;

                        if (tick.AskPrice != 0) AskPrice = tick.AskPrice;
                        if (tick.AskSize != 0) AskSize = tick.AskSize;
                        break;
                }
                return;
            }

            if (data is IBar bar)
            {
                // we will only set OHLC values using the default data type to preserve determinism and backwards compatibility.
                // Gives priority to QuoteBar over TradeBar, to be removed when default data type completely addressed GH issue 4196
                if ((_lastQuoteBarUpdate != data.EndTime || _lastOHLCUpdate != data.EndTime) && isDefaultDataType)
                {
                    _lastOHLCUpdate = data.EndTime;
                    if (bar.Open != 0) Open = bar.Open;
                    if (bar.High != 0) High = bar.High;
                    if (bar.Low != 0) Low = bar.Low;
                    if (bar.Close != 0)
                    {
                        Price = bar.Close;
                        Close = bar.Close;
                    }
                }
                if (bar is TradeBar tradeBar)
                {
                    if (tradeBar.Volume != 0) Volume = tradeBar.Volume;
                }
                if (bar is QuoteBar quoteBar)
                {
                    _lastQuoteBarUpdate = quoteBar.EndTime;
                    if (quoteBar.Ask != null && quoteBar.Ask.Close != 0) AskPrice = quoteBar.Ask.Close;
                    if (quoteBar.Bid != null && quoteBar.Bid.Close != 0) BidPrice = quoteBar.Bid.Close;
                    if (quoteBar.LastBidSize != 0) BidSize = quoteBar.LastBidSize;
                    if (quoteBar.LastAskSize != 0) AskSize = quoteBar.LastAskSize;
                }
            }
            else if (data.DataType != MarketDataType.Auxiliary)
            {
                Price = data.Price;
            }
        }

        /// <summary>
        /// Stores the specified data list in the cache WITHOUT updating any of the cache properties, such as Price
        /// </summary>
        /// <param name="data">The collection of data to store in this cache</param>
        /// <param name="dataType">The data type</param>
        public void StoreData(IReadOnlyList<BaseData> data, Type dataType)
        {
#if DEBUG // don't run this in release as we should never fail here, but it's also nice to have here as documentation of intent
            if (data.DistinctBy(d => d.GetType()).Skip(1).Any())
            {
                throw new ArgumentException(
                    "SecurityCache.StoreData data list must contain elements of the same type."
                );
            }
#endif
            if (dataType == typeof(Tick))
            {
                var tick = data[data.Count - 1] as Tick;
                switch (tick?.TickType)
                {
                    case TickType.Trade:
                        _lastTickTrades = data;
                        return;
                    case TickType.Quote:
                        _lastTickQuotes = data;
                        return;
                }
            }

            _dataByType[dataType] = data;
        }

        /// <summary>
        /// Get last data packet received for this security
        /// </summary>
        /// <returns>BaseData type of the security</returns>
        public BaseData GetData()
        {
            return _lastData;
        }

        /// <summary>
        /// Get last data packet received for this security of the specified type
        /// </summary>
        /// <typeparam name="T">The data type</typeparam>
        /// <returns>The last data packet, null if none received of type</returns>
        public T GetData<T>()
            where T : BaseData
        {
            IReadOnlyList<BaseData> list;
            if (!TryGetValue(typeof(T), out list) || list.Count == 0)
            {
                return default(T);
            }

            return list[list.Count - 1] as T;
        }

        /// <summary>
        /// Gets all data points of the specified type from the most recent time step
        /// that produced data for that type
        /// </summary>
        public IEnumerable<T> GetAll<T>()
        {
            if (typeof(T) == typeof(Tick))
            {
                return _lastTickTrades.Concat(_lastTickQuotes).Cast<T>();
            }

            IReadOnlyList<BaseData> list;
            if (!_dataByType.TryGetValue(typeof(T), out list))
            {
                return new List<T>();
            }

            return list.Cast<T>();
        }

        /// <summary>
        /// Reset cache storage and free memory
        /// </summary>
        public void Reset()
        {
            _dataByType.Clear();
            _lastTickQuotes = new List<BaseData>();
            _lastTickTrades = new List<BaseData>();
        }

        /// <summary>
        /// Gets whether or not this dynamic data instance has data stored for the specified type
        /// </summary>
        public bool HasData(Type type)
        {
            IReadOnlyList<BaseData> data;
            return TryGetValue(type, out data);
        }

        /// <summary>
        /// Gets whether or not this dynamic data instance has data stored for the specified type
        /// </summary>
        public bool TryGetValue(Type type, out IReadOnlyList<BaseData> data)
        {
            if (type == typeof(Tick))
            {
                var quote = _lastTickQuotes.LastOrDefault();
                var trade = _lastTickTrades.LastOrDefault();
                var isQuoteDefaultDataType = quote != null && SubscriptionManager.IsDefaultDataType(quote);
                var isTradeDefaultDataType = trade != null && SubscriptionManager.IsDefaultDataType(trade);

                // Currently, IsDefaultDataType returns true for both cases,
                // So we will return the list with the tick with the most recent timestamp
                if (isQuoteDefaultDataType && isTradeDefaultDataType)
                {
                    data = quote.EndTime > trade.EndTime ? _lastTickQuotes : _lastTickTrades;
                    return true;
                }

                data = isQuoteDefaultDataType ? _lastTickQuotes : _lastTickTrades;
                return data?.Count > 0;
            }

            return _dataByType.TryGetValue(type, out data);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void StoreDataPoint(BaseData data)
        {
            if (data.GetType() == typeof(Tick))
            {
                var tick = data as Tick;
                switch (tick?.TickType)
                {
                    case TickType.Trade:
                        _lastTickTrades = new List<BaseData> { tick };
                        break;
                    case TickType.Quote:
                        _lastTickQuotes = new List<BaseData> { tick };
                        break;
                }
            }
            else
            {
                // Always keep track of the last observation
                IReadOnlyList<BaseData> list;
                if (!_dataByType.TryGetValue(data.GetType(), out list))
                {
                    list = new List<BaseData> { data };
                    _dataByType[data.GetType()] = list;
                }
                else
                {
                    // we KNOW this one is actually a list, so this is safe
                    // we overwrite the zero entry so we're not constantly newing up lists
                    ((List<BaseData>)list)[0] = data;
                }
            }
        }

        /// <summary>
        /// Helper method that modifies the target security cache instance to use the
        /// type cache of the source
        /// </summary>
        /// <remarks>Will set in the source cache any data already present in the target cache</remarks>
        /// <remarks>This is useful for custom data securities which also have an underlying security,
        /// will allow both securities to access the same data by type</remarks>
        /// <param name="sourceToShare">The source cache to use</param>
        /// <param name="targetToModify">The target security cache that will be modified</param>
        public static void ShareTypeCacheInstance(SecurityCache sourceToShare, SecurityCache targetToModify)
        {
            foreach (var kvp in targetToModify._dataByType)
            {
                sourceToShare._dataByType.TryAdd(kvp.Key, kvp.Value);
            }
            targetToModify._dataByType = sourceToShare._dataByType;
            targetToModify._lastTickTrades = sourceToShare._lastTickTrades;
            targetToModify._lastTickQuotes = sourceToShare._lastTickQuotes;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Common\Securities\SecurityCache.cs(149,17): error CS0841: Cannot use local variable 'tick' before it is declared,D:\a\1\s\Common\Securities\SecurityCache.cs(155,38): error CS0841: Cannot use local variable 'tick' before it is declared
######################################################################


######################################################################
Nr: 5 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Tests\Common\Util\LeanDataTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using NUnit.Framework;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Util;
using Bitcoin = QuantConnect.Algorithm.CSharp.LiveTradingFeaturesAlgorithm.Bitcoin;

namespace QuantConnect.Tests.Common.Util
{
    [TestFixture]
    public class LeanDataTests
    {
        [SetUp]
        public void SetUp()
        {
            SymbolCache.Clear();
        }

        [TearDown]
        public void TearDown()
        {
            SymbolCache.Clear();
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateZipFileName(LeanDataTestParameters parameters)
        {
            var zip = LeanData.GenerateZipFileName(parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedZipFileName, zip);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateZipEntryName(LeanDataTestParameters parameters)
        {
            var entry = LeanData.GenerateZipEntryName(parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedZipEntryName, entry);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateRelativeZipFilePath(LeanDataTestParameters parameters)
        {
            var relativePath = LeanData.GenerateRelativeZipFilePath(parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedRelativeZipFilePath, relativePath);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateZipFilePath(LeanDataTestParameters parameters)
        {
            var path = LeanData.GenerateZipFilePath(Globals.DataFolder, parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedZipFilePath, path);
        }

        [Test, TestCaseSource(nameof(GetLeanDataLineTestParameters))]
        public void GenerateLine(LeanDataLineTestParameters parameters)
        {
            var line = LeanData.GenerateLine(parameters.Data, parameters.SecurityType, parameters.Resolution);
            Assert.AreEqual(parameters.ExpectedLine, line);

            if (parameters.Config.Type == typeof(QuoteBar))
            {
                Assert.AreEqual(line.Split(',').Length, 11);
            }

            if (parameters.Config.Type == typeof(TradeBar))
            {
                Assert.AreEqual(line.Split(',').Length, 6);
            }
        }

        [Test, TestCaseSource(nameof(GetLeanDataLineTestParameters))]
        public void ParsesGeneratedLines(LeanDataLineTestParameters parameters)
        {
            // ignore time zone issues here, we'll just say everything is UTC, so no conversions are performed
            var factory = (BaseData) Activator.CreateInstance(parameters.Data.GetType());
            var parsed = factory.Reader(parameters.Config, parameters.ExpectedLine, parameters.Data.Time.Date, false);

            Assert.IsInstanceOf(parameters.Config.Type, parsed);
            Assert.AreEqual(parameters.Data.Time, parsed.Time);
            Assert.AreEqual(parameters.Data.EndTime, parsed.EndTime);
            Assert.AreEqual(parameters.Data.Symbol, parsed.Symbol);
            Assert.AreEqual(parameters.Data.Value, parsed.Value);
            if (parsed is Tick)
            {
                var expected = (Tick) parameters.Data;
                var actual = (Tick) parsed;
                Assert.AreEqual(expected.Quantity, actual.Quantity);
                Assert.AreEqual(expected.BidPrice, actual.BidPrice);
                Assert.AreEqual(expected.AskPrice, actual.AskPrice);
                Assert.AreEqual(expected.BidSize, actual.BidSize);
                Assert.AreEqual(expected.AskSize, actual.AskSize);
                Assert.AreEqual(expected.Exchange, actual.Exchange);
                Assert.AreEqual(expected.SaleCondition, actual.SaleCondition);
                Assert.AreEqual(expected.Suspicious, actual.Suspicious);
            }
            else if (parsed is TradeBar)
            {
                var expected = (TradeBar) parameters.Data;
                var actual = (TradeBar) parsed;
                AssertBarsAreEqual(expected, actual);
                Assert.AreEqual(expected.Volume, actual.Volume);
            }
            else if (parsed is QuoteBar)
            {
                var expected = (QuoteBar) parameters.Data;
                var actual = (QuoteBar) parsed;
                AssertBarsAreEqual(expected.Bid, actual.Bid);
                AssertBarsAreEqual(expected.Ask, actual.Ask);
                Assert.AreEqual(expected.LastBidSize, actual.LastBidSize);
                Assert.AreEqual(expected.LastAskSize, actual.LastAskSize);
            }
        }

        [Test, TestCaseSource(nameof(GetLeanDataLineTestParameters))]
        public void GetSourceMatchesGenerateZipFilePath(LeanDataLineTestParameters parameters)
        {
            var source = parameters.Data.GetSource(parameters.Config, parameters.Data.Time.Date, false);
            var normalizedSourcePath = new FileInfo(source.Source).FullName;
            var zipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, parameters.Data.Symbol, parameters.Data.Time.Date, parameters.Resolution, parameters.TickType);
            var normalizeZipFilePath = new FileInfo(zipFilePath).FullName;
            var indexOfHash = normalizedSourcePath.LastIndexOf("#", StringComparison.Ordinal);
            if (indexOfHash > 0)
            {
                normalizedSourcePath = normalizedSourcePath.Substring(0, indexOfHash);
            }
            Assert.AreEqual(normalizeZipFilePath, normalizedSourcePath);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GetSource(LeanDataTestParameters parameters)
        {
            var factory = (BaseData)Activator.CreateInstance(parameters.BaseDataType);
            var source = factory.GetSource(parameters.Config, parameters.Date, false);
            var expected = parameters.ExpectedZipFilePath;
            if (parameters.SecurityType == SecurityType.Option || parameters.SecurityType == SecurityType.Future)
            {
                expected += "#" + parameters.ExpectedZipEntryName;
            }
            Assert.AreEqual(expected, source.Source);
        }

        [Test]
        public void GetDataType_ReturnsCorrectType()
        {
            var tickType = typeof(Tick);
            var openInterestType = typeof(OpenInterest);
            var quoteBarType = typeof(QuoteBar);
            var tradeBarType = typeof(TradeBar);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Tick, TickType.OpenInterest), tickType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Daily, TickType.OpenInterest), tickType);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Second, TickType.OpenInterest), openInterestType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Tick, TickType.OpenInterest), openInterestType);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Minute, TickType.Quote), quoteBarType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Second, TickType.Trade), quoteBarType);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Hour, TickType.Trade), tradeBarType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Tick, TickType.OpenInterest), tradeBarType);
        }

        [Test]
        public void LeanData_CanDetermineTheCorrectCommonDataTypes()
        {
            Assert.IsTrue(LeanData.IsCommonLeanDataType(typeof(OpenInterest)));
            Assert.IsTrue(LeanData.IsCommonLeanDataType(typeof(TradeBar)));
            Assert.IsTrue(LeanData.IsCommonLeanDataType(typeof(QuoteBar)));
            Assert.IsFalse(LeanData.IsCommonLeanDataType(typeof(Bitcoin)));
        }

        [Test]
        public void LeanData_GetCommonTickTypeForCommonDataTypes_ReturnsCorrectDataForTickResolution()
        {
            Assert.AreEqual(LeanData.GetCommonTickTypeForCommonDataTypes(typeof(Tick), SecurityType.Cfd), TickType.Quote);
            Assert.AreEqual(LeanData.GetCommonTickTypeForCommonDataTypes(typeof(Tick), SecurityType.Forex), TickType.Quote);
        }

        [Test]
        public void IncorrectPaths_CannotBeParsed()
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            var invalidPath = "forex/fxcm/eurusd/20160101_quote.zip";
            Assert.IsFalse(LeanData.TryParsePath(invalidPath, out symbol, out date, out resolution));

            var nonExistantPath = "Data/f/fxcm/eurusd/20160101_quote.zip";
            Assert.IsFalse(LeanData.TryParsePath(nonExistantPath, out symbol, out date, out resolution));

            var notAPath = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            Assert.IsFalse(LeanData.TryParsePath(notAPath, out symbol, out date, out resolution));

            var  emptyPath = "";
            Assert.IsFalse(LeanData.TryParsePath(emptyPath, out symbol, out date, out resolution));

            string nullPath = null;
            Assert.IsFalse(LeanData.TryParsePath(nullPath, out symbol, out date, out resolution));

            var optionsTradePath = "Data/option/u sa/minute/aapl/20140606_trade_american.zip";
            Assert.IsFalse(LeanData.TryParsePath(optionsTradePath, out symbol, out date, out resolution));
        }

        [Test]
        public void CorrectPaths_CanBeParsedCorrectly()
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            var customPath = "a/very/custom/path/forex/oanda/tick/eurusd/20170104_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(customPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.Oanda);
            Assert.AreEqual(resolution, Resolution.Tick);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "eurusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2017-01-04").Date);

            var mixedPathSeperators = @"Data//forex/fxcm\/minute//eurusd\\20160101_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(mixedPathSeperators, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.FXCM);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "eurusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-01-01").Date);

            var longRelativePath = "../../../../../../../../../Data/forex/fxcm/hour/gbpusd.zip";
            Assert.IsTrue(LeanData.TryParsePath(longRelativePath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.FXCM);
            Assert.AreEqual(resolution, Resolution.Hour);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "gbpusd");
            Assert.AreEqual(date.Date, DateTime.MinValue);

            var shortRelativePath = "Data/forex/fxcm/minute/eurusd/20160102_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(shortRelativePath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.FXCM);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "eurusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-01-02").Date);

            var dailyEquitiesPath = "Data/equity/usa/daily/aapl.zip";
            Assert.IsTrue(LeanData.TryParsePath(dailyEquitiesPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Equity);
            Assert.AreEqual(symbol.ID.Market, Market.USA);
            Assert.AreEqual(resolution, Resolution.Daily);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "aapl");
            Assert.AreEqual(date.Date, DateTime.MinValue);

            var minuteEquitiesPath = "Data/equity/usa/minute/googl/20070103_trade.zip";
            Assert.IsTrue(LeanData.TryParsePath(minuteEquitiesPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Equity);
            Assert.AreEqual(symbol.ID.Market, Market.USA);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "goog");
            Assert.AreEqual(date.Date, Parse.DateTime("2007-01-03").Date);

            var cfdPath = "Data/cfd/oanda/minute/bcousd/20160101_trade.zip";
            Assert.IsTrue(LeanData.TryParsePath(cfdPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Cfd);
            Assert.AreEqual(symbol.ID.Market, Market.Oanda);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "bcousd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-01-01").Date);
        }

        [TestCase("Data\\alternative\\estimize\\consensus\\aapl.csv", "aapl", null)]
        [TestCase("Data\\alternative\\psychsignal\\aapl\\20161007.zip", "aapl", "2016-10-07")]
        [TestCase("Data\\alternative\\sec\\aapl\\20161007_8K.zip", "aapl", "2016-10-07")]
        [TestCase("Data\\alternative\\smartinsider\\intentions\\aapl.tsv", "aapl", null)]
        [TestCase("Data\\alternative\\trading-economics\\calendar\\fdtr\\20161007.zip", "fdtr", "2016-10-07")]
        [TestCase("Data\\alternative\\ustreasury\\yieldcurverates.zip", "yieldcurverates", null)]
        public void AlternativePaths_CanBeParsedCorrectly(string path, string expectedSymbol, string expectedDate)
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            Assert.IsTrue(LeanData.TryParsePath(path, out symbol, out date, out resolution));
            Assert.AreEqual(SecurityType.Base, symbol.SecurityType);
            Assert.AreEqual(Market.USA, symbol.ID.Market);
            Assert.AreEqual(Resolution.Daily, resolution);
            Assert.AreEqual(expectedSymbol, symbol.ID.Symbol.ToLowerInvariant());
            Assert.AreEqual(expectedDate == null ? default(DateTime) : Parse.DateTime(expectedDate).Date, date);
        }

        [Test]
        public void CryptoPaths_CanBeParsedCorrectly()
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            var cryptoPath = "Data\\crypto\\gdax\\daily\\btcusd_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(cryptoPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Crypto);
            Assert.AreEqual(symbol.ID.Market, Market.GDAX);
            Assert.AreEqual(resolution, Resolution.Daily);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "btcusd");

            cryptoPath = "Data\\crypto\\gdax\\hour\\btcusd_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(cryptoPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Crypto);
            Assert.AreEqual(symbol.ID.Market, Market.GDAX);
            Assert.AreEqual(resolution, Resolution.Hour);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "btcusd");

            cryptoPath = "Data\\crypto\\gdax\\minute\\btcusd\\20161007_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(cryptoPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Crypto);
            Assert.AreEqual(symbol.ID.Market, Market.GDAX);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "btcusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-10-07").Date);
        }

        [TestCase(SecurityType.Base, "alteRNative")]
        [TestCase(SecurityType.Equity, "Equity")]
        [TestCase(SecurityType.Cfd, "Cfd")]
        [TestCase(SecurityType.Commodity, "Commodity")]
        [TestCase(SecurityType.Crypto, "Crypto")]
        [TestCase(SecurityType.Forex, "Forex")]
        [TestCase(SecurityType.Future, "Future")]
        [TestCase(SecurityType.Option, "Option")]
        [TestCase(SecurityType.FutureOption, "FutureOption")]
        public void ParsesDataSecurityType(SecurityType type, string path)
        {
            Assert.AreEqual(type, LeanData.ParseDataSecurityType(path));
        }

        [Test]
        public void SecurityTypeAsDataPath()
        {
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("alternative"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("equity"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("base"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("option"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("cfd"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("crypto"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("future"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("forex"));
        }

        [Test]
        public void OptionZipFilePathWithUnderlyingEquity()
        {
            var underlying = Symbol.Create("SPY", SecurityType.Equity, QuantConnect.Market.USA);
            var optionSymbol = Symbol.CreateOption(
                underlying,
                Market.USA,
                OptionStyle.American,
                OptionRight.Put,
                4200m,
                new DateTime(2020, 12, 31));

            var optionZipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote)
                .Replace(Path.DirectorySeparatorChar, '/');
            var optionEntryFilePath = LeanData.GenerateZipEntryName(optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote);

            Assert.AreEqual("../../../Data/option/usa/minute/spy/20200922_quote_american.zip", optionZipFilePath);
            Assert.AreEqual("20200922_spy_minute_quote_american_put_42000000_20201231.csv", optionEntryFilePath);
        }

        [TestCase("ES", "ES")]
        [TestCase("DC", "DC")]
        [TestCase("GC", "OG")]
        [TestCase("ZT", "OZT")]
        public void OptionZipFilePathWithUnderlyingFuture(string futureOptionTicker, string expectedFutureOptionTicker)
        {
            var underlying = Symbol.CreateFuture(futureOptionTicker, Market.CME, new DateTime(2021, 3, 19));
            var optionSymbol = Symbol.CreateOption(
                underlying,
                Market.CME,
                OptionStyle.American,
                OptionRight.Put,
                4200m,
                new DateTime(2021, 3, 18));

            var optionZipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote)
                .Replace(Path.DirectorySeparatorChar, '/');
            var optionEntryFilePath = LeanData.GenerateZipEntryName(optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote);

            Assert.AreEqual($"../../../Data/futureoption/cme/minute/{expectedFutureOptionTicker.ToLowerInvariant()}/{underlying.ID.Date:yyyyMMdd}/20200922_quote_american.zip", optionZipFilePath);
            Assert.AreEqual($"20200922_{expectedFutureOptionTicker.ToLowerInvariant()}_minute_quote_american_put_42000000_{optionSymbol.ID.Date:yyyyMMdd}.csv", optionEntryFilePath);
        }

        [TestCase(OptionRight.Call, 1650, 2020, 3, 26)]
        [TestCase(OptionRight.Call, 1540, 2020, 3, 26)]
        [TestCase(OptionRight.Call, 1600, 2020, 2, 25)]
        [TestCase(OptionRight.Call, 1545, 2020, 2, 25)]
        public void FutureOptionSingleZipFileContainingMultipleFuturesOptionsContracts(OptionRight right, int strike, int year, int month, int day)
        {
            var underlying = Symbol.CreateFuture("GC", Market.COMEX, new DateTime(2020, 4, 28));
            var expiry = new DateTime(year, month, day);
            var optionSymbol = Symbol.CreateOption(
                underlying,
                Market.COMEX,
                OptionStyle.American,
                right,
                (decimal)strike,
                expiry);

            var optionZipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, optionSymbol, new DateTime(2020, 1, 5), Resolution.Minute, TickType.Quote)
                .Replace(Path.DirectorySeparatorChar, '/');
            var optionEntryFilePath = LeanData.GenerateZipEntryName(optionSymbol, new DateTime(2020, 1, 5), Resolution.Minute, TickType.Quote);

            Assert.AreEqual("../../../Data/futureoption/comex/minute/og/20200428/20200105_quote_american.zip", optionZipFilePath);
            Assert.AreEqual($"20200105_og_minute_quote_american_{right.ToLower()}_{strike}0000_{expiry:yyyyMMdd}.csv", optionEntryFilePath);
        }

        private static void AssertBarsAreEqual(IBar expected, IBar actual)
        {
            if (expected == null && actual == null)
            {
                return;
            }
            if (expected == null && actual != null)
            {
                Assert.Fail("Expected null bar");
            }
            Assert.AreEqual(expected.Open, actual.Open);
            Assert.AreEqual(expected.High, actual.High);
            Assert.AreEqual(expected.Low, actual.Low);
            Assert.AreEqual(expected.Close, actual.Close);
        }

        private static TestCaseData[] GetLeanDataTestParameters()
        {
            var date = new DateTime(2016, 02, 17);
            var dateFutures = new DateTime(2018, 12, 10);

            return new List<LeanDataTestParameters>
            {
                // equity
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Tick, TickType.Trade, "20160217_trade.zip", "20160217_spy_Trade_Tick.csv", "equity/usa/tick/spy"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Second, TickType.Trade, "20160217_trade.zip", "20160217_spy_second_trade.csv", "equity/usa/second/spy"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Minute, TickType.Trade, "20160217_trade.zip", "20160217_spy_minute_trade.csv", "equity/usa/minute/spy"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Hour, TickType.Trade, "spy.zip", "spy.csv", "equity/usa/hour"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Daily, TickType.Trade, "spy.zip", "spy.csv", "equity/usa/daily"),

                // equity option trades
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Tick, TickType.Trade, "20160217_trade_american.zip", "20160217_spy_tick_trade_american_put_1920000_20160219.csv", "option/usa/tick/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Tick, TickType.Quote, "20160217_quote_american.zip", "20160217_spy_tick_quote_american_put_1920000_20160219.csv", "option/usa/tick/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Second, TickType.Trade, "20160217_trade_american.zip", "20160217_spy_second_trade_american_put_1920000_20160219.csv", "option/usa/second/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Second, TickType.Quote, "20160217_quote_american.zip", "20160217_spy_second_quote_american_put_1920000_20160219.csv", "option/usa/second/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Minute, TickType.Trade, "20160217_trade_american.zip", "20160217_spy_minute_trade_american_put_1920000_20160219.csv", "option/usa/minute/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Minute, TickType.Quote, "20160217_quote_american.zip", "20160217_spy_minute_quote_american_put_1920000_20160219.csv", "option/usa/minute/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Hour, TickType.Trade, "spy_trade_american.zip", "spy_trade_american_put_1920000_20160219.csv", "option/usa/hour"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Hour, TickType.Quote, "spy_quote_american.zip", "spy_quote_american_put_1920000_20160219.csv", "option/usa/hour"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Daily, TickType.Trade, "spy_trade_american.zip", "spy_trade_american_put_1920000_20160219.csv", "option/usa/daily"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Daily, TickType.Quote, "spy_quote_american.zip", "spy_quote_american_put_1920000_20160219.csv", "option/usa/daily"),

                // forex
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Tick, TickType.Quote, "20160217_quote.zip", "20160217_eurusd_tick_quote.csv", "forex/oanda/tick/eurusd"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Second, TickType.Quote, "20160217_quote.zip", "20160217_eurusd_second_quote.csv", "forex/oanda/second/eurusd"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Minute, TickType.Quote, "20160217_quote.zip", "20160217_eurusd_minute_quote.csv", "forex/oanda/minute/eurusd"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Hour, TickType.Quote, "eurusd.zip", "eurusd.csv", "forex/oanda/hour"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Daily, TickType.Quote, "eurusd.zip", "eurusd.csv", "forex/oanda/daily"),

                // cfd
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Tick, TickType.Quote, "20160217_quote.zip", "20160217_de10ybeur_tick_quote.csv", "cfd/fxcm/tick/de10ybeur"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Second, TickType.Quote, "20160217_quote.zip", "20160217_de10ybeur_second_quote.csv", "cfd/fxcm/second/de10ybeur"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Minute, TickType.Quote, "20160217_quote.zip", "20160217_de10ybeur_minute_quote.csv", "cfd/fxcm/minute/de10ybeur"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Hour, TickType.Quote, "de10ybeur.zip", "de10ybeur.csv", "cfd/fxcm/hour"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Daily, TickType.Quote, "de10ybeur.zip", "de10ybeur.csv", "cfd/fxcm/daily"),

                // Crypto - trades
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Tick, TickType.Trade, "20160217_trade.zip", "20160217_btcusd_tick_trade.csv", "crypto/gdax/tick/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Second, TickType.Trade, "20160217_trade.zip", "20160217_btcusd_second_trade.csv", "crypto/gdax/second/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Minute, TickType.Trade, "20160217_trade.zip", "20160217_btcusd_minute_trade.csv", "crypto/gdax/minute/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Hour, TickType.Trade, "btcusd_trade.zip", "btcusd.csv", "crypto/gdax/hour"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Daily, TickType.Trade, "btcusd_trade.zip", "btcusd.csv", "crypto/gdax/daily"),

                // Crypto - quotes
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Tick, TickType.Quote, "20160217_quote.zip", "20160217_btcusd_tick_quote.csv", "crypto/gdax/tick/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Second, TickType.Quote, "20160217_quote.zip", "20160217_btcusd_second_quote.csv", "crypto/gdax/second/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Minute, TickType.Quote, "20160217_quote.zip", "20160217_btcusd_minute_quote.csv", "crypto/gdax/minute/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Hour, TickType.Quote, "btcusd_quote.zip", "btcusd.csv", "crypto/gdax/hour"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Daily, TickType.Quote, "btcusd_quote.zip", "btcusd.csv", "crypto/gdax/daily"),

                // Futures (expiration month == contract month) - trades
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Tick, TickType.Trade, "20181210_trade.zip", "20181210_es_tick_trade_201812_20181221.csv", "future/cme/tick/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Second, TickType.Trade, "20181210_trade.zip", "20181210_es_second_trade_201812_20181221.csv", "future/cme/second/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Minute, TickType.Trade, "20181210_trade.zip", "20181210_es_minute_trade_201812_20181221.csv", "future/cme/minute/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Hour, TickType.Trade, "es_trade.zip", "es_trade_201812_20181221.csv", "future/cme/hour"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Daily, TickType.Trade, "es_trade.zip", "es_trade_201812_20181221.csv", "future/cme/daily"),

                // Futures (expiration month == contract month) - quotes
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Tick, TickType.Quote, "20181210_quote.zip", "20181210_es_tick_quote_201812_20181221.csv", "future/cme/tick/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Second, TickType.Quote, "20181210_quote.zip", "20181210_es_second_quote_201812_20181221.csv", "future/cme/second/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Minute, TickType.Quote, "20181210_quote.zip", "20181210_es_minute_quote_201812_20181221.csv", "future/cme/minute/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Hour, TickType.Quote, "es_quote.zip", "es_quote_201812_20181221.csv", "future/cme/hour"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Daily, TickType.Quote, "es_quote.zip", "es_quote_201812_20181221.csv", "future/cme/daily"),

                // Futures (expiration month == contract month) - OpenInterest
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Tick, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_es_tick_openinterest_201812_20181221.csv", "future/cme/tick/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Second, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_es_second_openinterest_201812_20181221.csv", "future/cme/second/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Minute, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_es_minute_openinterest_201812_20181221.csv", "future/cme/minute/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Hour, TickType.OpenInterest, "es_openinterest.zip", "es_openinterest_201812_20181221.csv", "future/cme/hour"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Daily, TickType.OpenInterest, "es_openinterest.zip", "es_openinterest_201812_20181221.csv", "future/cme/daily"),

                // Futures (expiration month < contract month) - trades
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Tick, TickType.Trade, "20181210_trade.zip", "20181210_cl_tick_trade_201901_20181219.csv", "future/nymex/tick/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Second, TickType.Trade, "20181210_trade.zip", "20181210_cl_second_trade_201901_20181219.csv", "future/nymex/second/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Minute, TickType.Trade, "20181210_trade.zip", "20181210_cl_minute_trade_201901_20181219.csv", "future/nymex/minute/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Hour, TickType.Trade, "cl_trade.zip", "cl_trade_201901_20181219.csv", "future/nymex/hour"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Daily, TickType.Trade, "cl_trade.zip", "cl_trade_201901_20181219.csv", "future/nymex/daily"),

                // Futures (expiration month < contract month) - quotes
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Tick, TickType.Quote, "20181210_quote.zip", "20181210_cl_tick_quote_201901_20181219.csv", "future/nymex/tick/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Second, TickType.Quote, "20181210_quote.zip", "20181210_cl_second_quote_201901_20181219.csv", "future/nymex/second/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Minute, TickType.Quote, "20181210_quote.zip", "20181210_cl_minute_quote_201901_20181219.csv", "future/nymex/minute/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Hour, TickType.Quote, "cl_quote.zip", "cl_quote_201901_20181219.csv", "future/nymex/hour"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Daily, TickType.Quote, "cl_quote.zip", "cl_quote_201901_20181219.csv", "future/nymex/daily"),

                // Futures (expiration month < contract month) - open interest
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Tick, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_cl_tick_openinterest_201901_20181219.csv", "future/nymex/tick/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Second, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_cl_second_openinterest_201901_20181219.csv", "future/nymex/second/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Minute, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_cl_minute_openinterest_201901_20181219.csv", "future/nymex/minute/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Hour, TickType.OpenInterest, "cl_openinterest.zip", "cl_openinterest_201901_20181219.csv", "future/nymex/hour"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Daily, TickType.OpenInterest, "cl_openinterest.zip", "cl_openinterest_201901_20181219.csv", "future/nymex/daily"),

            }.Select(x => new TestCaseData(x).SetName(x.Name)).ToArray();
        }

        private static TestCaseData[] GetLeanDataLineTestParameters()
        {
            var time = new DateTime(2016, 02, 18, 9, 30, 0);
            return new List<LeanDataLineTestParameters>
            {
                //equity
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.SPY, Value = 1, Quantity = 2, TickType = TickType.Trade, Exchange = "EX", SaleCondition = "SC", Suspicious = true}, SecurityType.Equity, Resolution.Tick,
                    "34200000,10000,2,EX,SC,1"),
                new LeanDataLineTestParameters(new TradeBar(time, Symbols.SPY, 1, 2, 3, 4, 5, TimeSpan.FromMinutes(1)), SecurityType.Equity, Resolution.Minute,
                    "34200000,10000,20000,30000,40000,5"),
                new LeanDataLineTestParameters(new TradeBar(time.Date, Symbols.SPY, 1, 2, 3, 4, 5, TimeSpan.FromDays(1)), SecurityType.Equity, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5"),

                // options
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.SPY_P_192_Feb19_2016, null, 0, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)) {Bid = null}, SecurityType.Option, Resolution.Minute,
                    "34200000,,,,,0,60000,70000,80000,90000,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.SPY_P_192_Feb19_2016, new Bar(1, 2, 3, 4), 5, null, 0, TimeSpan.FromDays(1)) {Ask = null}, SecurityType.Option, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5,,,,,0"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.SPY_P_192_Feb19_2016, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)), SecurityType.Option, Resolution.Minute,
                    "34200000,10000,20000,30000,40000,5,60000,70000,80000,90000,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.SPY_P_192_Feb19_2016, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromDays(1)), SecurityType.Option, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5,60000,70000,80000,90000,10"),
                new LeanDataLineTestParameters(new Tick(time, Symbols.SPY_P_192_Feb19_2016, 0, 1, 3) {Value = 2m, TickType = TickType.Quote, BidSize = 2, AskSize = 4, Exchange = "EX", Suspicious = true}, SecurityType.Option, Resolution.Tick,
                    "34200000,10000,2,30000,4,EX,1"),
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.SPY_P_192_Feb19_2016, Value = 1, Quantity = 2,TickType = TickType.Trade, Exchange = "EX", SaleCondition = "SC", Suspicious = true}, SecurityType.Option, Resolution.Tick,
                    "34200000,10000,2,EX,SC,1"),
                new LeanDataLineTestParameters(new TradeBar(time, Symbols.SPY_P_192_Feb19_2016, 1, 2, 3, 4, 5, TimeSpan.FromMinutes(1)), SecurityType.Option, Resolution.Minute,
                    "34200000,10000,20000,30000,40000,5"),
                new LeanDataLineTestParameters(new TradeBar(time.Date, Symbols.SPY_P_192_Feb19_2016, 1, 2, 3, 4, 5, TimeSpan.FromDays(1)), SecurityType.Option, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5"),

                // forex
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.EURUSD, BidPrice = 1, Value =1.5m, AskPrice = 2, TickType = TickType.Quote}, SecurityType.Forex, Resolution.Tick,
                    "34200000,1,2"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.EURUSD, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromMinutes(1)), SecurityType.Forex, Resolution.Minute, "34200000,1,2,3,4,0,1,2,3,4,0"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.EURUSD, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromDays(1)), SecurityType.Forex, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,0,1,2,3,4,0"),

                // cfd
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.DE10YBEUR, BidPrice = 1, Value = 1.5m, AskPrice = 2, TickType = TickType.Quote}, SecurityType.Cfd, Resolution.Tick,
                    "34200000,1,2"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.DE10YBEUR, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromMinutes(1)), SecurityType.Cfd, Resolution.Minute,
                    "34200000,1,2,3,4,0,1,2,3,4,0"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.DE10YBEUR, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromDays(1)), SecurityType.Cfd, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,0,1,2,3,4,0"),

                // crypto - trades
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.BTCUSD, null, 0, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)) {Bid = null}, SecurityType.Crypto, Resolution.Minute,
                    "34200000,,,,,0,6,7,8,9,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.BTCUSD, new Bar(1, 2, 3, 4), 5, null, 0, TimeSpan.FromDays(1)) {Ask = null}, SecurityType.Crypto, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,5,,,,,0"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.BTCUSD, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)), SecurityType.Crypto, Resolution.Minute,
                    "34200000,1,2,3,4,5,6,7,8,9,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.BTCUSD, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromDays(1)), SecurityType.Crypto, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,5,6,7,8,9,10"),
                new LeanDataLineTestParameters(new Tick(time, Symbols.BTCUSD, 0, 1, 3) {Value = 2m, TickType = TickType.Quote, BidSize = 2, AskSize = 4, Exchange = "gdax", Suspicious = false}, SecurityType.Crypto, Resolution.Tick,
                    "34200000,1,2,3,4"),
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.BTCUSD, Value = 1, Quantity = 2,TickType = TickType.Trade, Exchange = "gdax", Suspicious = false}, SecurityType.Crypto, Resolution.Tick,
                    "34200000,1,2"),
                new LeanDataLineTestParameters(new TradeBar(time, Symbols.BTCUSD, 1, 2, 3, 4, 5, TimeSpan.FromMinutes(1)), SecurityType.Crypto, Resolution.Minute,
                    "34200000,1,2,3,4,5"),
                new LeanDataLineTestParameters(new TradeBar(time.Date, Symbols.BTCUSD, 1, 2, 3, 4, 5, TimeSpan.FromDays(1)), SecurityType.Crypto, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,5"),

            }.Select(x => new TestCaseData(x).SetName(x.Name)).ToArray();
        }

        public class LeanDataTestParameters
        {
            public readonly string Name;
            public readonly Symbol Symbol;
            public readonly DateTime Date;
            public readonly Resolution Resolution;
            public readonly TickType TickType;
            public readonly Type BaseDataType;
            public readonly SubscriptionDataConfig Config;
            public readonly string ExpectedZipFileName;
            public readonly string ExpectedZipEntryName;
            public readonly string ExpectedRelativeZipFilePath;
            public readonly string ExpectedZipFilePath;
            public SecurityType SecurityType { get { return Symbol.ID.SecurityType; } }

            public LeanDataTestParameters(Symbol symbol, DateTime date, Resolution resolution, TickType tickType, string expectedZipFileName, string expectedZipEntryName, string expectedRelativeZipFileDirectory = "")
            {
                Symbol = symbol;
                Date = date;
                Resolution = resolution;
                TickType = tickType;
                ExpectedZipFileName = expectedZipFileName;
                ExpectedZipEntryName = expectedZipEntryName;
                ExpectedRelativeZipFilePath = Path.Combine(expectedRelativeZipFileDirectory, expectedZipFileName).Replace("/", Path.DirectorySeparatorChar.ToStringInvariant());
                ExpectedZipFilePath = Path.Combine(Globals.DataFolder, ExpectedRelativeZipFilePath);

                Name = SecurityType + "_" + resolution + "_" + symbol.Value + "_" + tickType;

                BaseDataType = resolution == Resolution.Tick ? typeof(Tick) : typeof(TradeBar);
                if (symbol.ID.SecurityType == SecurityType.Option && resolution != Resolution.Tick)
                {
                    BaseDataType = typeof(QuoteBar);
                }
                Config = new SubscriptionDataConfig(BaseDataType, symbol, resolution, TimeZones.NewYork, TimeZones.NewYork, true, false, false, false, tickType);
            }
        }

        public class LeanDataLineTestParameters
        {
            public readonly string Name;
            public readonly BaseData Data;
            public readonly SecurityType SecurityType;
            public readonly Resolution Resolution;
            public readonly string ExpectedLine;
            public readonly SubscriptionDataConfig Config;
            public readonly TickType TickType;

            public LeanDataLineTestParameters(BaseData data, SecurityType securityType, Resolution resolution, string expectedLine)
            {
                Data = data;
                SecurityType = securityType;
                Resolution = resolution;
                ExpectedLine = expectedLine;
                if (data is Tick)
                {
                    var tick = (Tick) data;
                    TickType = tick.TickType;
                }
                else if (data is TradeBar)
                {
                    TickType = TickType.Trade;
                }
                else if (data is QuoteBar)
                {
                    TickType = TickType.Quote;
                }
                else
                {
                    throw new NotImplementedException();
                }

                // override for forex/cfd
                if (data.Symbol.ID.SecurityType == SecurityType.Forex || data.Symbol.ID.SecurityType == SecurityType.Cfd)
                {
                    TickType = TickType.Quote;
                }

                Config = new SubscriptionDataConfig(Data.GetType(), Data.Symbol, Resolution, TimeZones.Utc, TimeZones.Utc, false, true, false, false, TickType);

                Name = SecurityType + "_" + data.GetType().Name;

                if (data.GetType() != typeof (Tick) || Resolution != Resolution.Tick)
                {
                    Name += "_" + Resolution;
                }

                if (data is Tick)
                {
                    Name += "_" + ((Tick) data).TickType;
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using NUnit.Framework;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Util;
using Bitcoin = QuantConnect.Algorithm.CSharp.LiveTradingFeaturesAlgorithm.Bitcoin;

namespace QuantConnect.Tests.Common.Util
{
    [TestFixture]
    public class LeanDataTests
    {
        [SetUp]
        public void SetUp()
        {
            SymbolCache.Clear();
        }

        [TearDown]
        public void TearDown()
        {
            SymbolCache.Clear();
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateZipFileName(LeanDataTestParameters parameters)
        {
            var zip = LeanData.GenerateZipFileName(parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedZipFileName, zip);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateZipEntryName(LeanDataTestParameters parameters)
        {
            var entry = LeanData.GenerateZipEntryName(parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedZipEntryName, entry);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateRelativeZipFilePath(LeanDataTestParameters parameters)
        {
            var relativePath = LeanData.GenerateRelativeZipFilePath(parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedRelativeZipFilePath, relativePath);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GenerateZipFilePath(LeanDataTestParameters parameters)
        {
            var path = LeanData.GenerateZipFilePath(Globals.DataFolder, parameters.Symbol, parameters.Date, parameters.Resolution, parameters.TickType);
            Assert.AreEqual(parameters.ExpectedZipFilePath, path);
        }

        [Test, TestCaseSource(nameof(GetLeanDataLineTestParameters))]
        public void GenerateLine(LeanDataLineTestParameters parameters)
        {
            var line = LeanData.GenerateLine(parameters.Data, parameters.SecurityType, parameters.Resolution);
            Assert.AreEqual(parameters.ExpectedLine, line);

            if (parameters.Config.Type == typeof(QuoteBar))
            {
                Assert.AreEqual(line.Split(',').Length, 11);
            }

            if (parameters.Config.Type == typeof(TradeBar))
            {
                Assert.AreEqual(line.Split(',').Length, 6);
            }
        }

        [Test, TestCaseSource(nameof(GetLeanDataLineTestParameters))]
        public void ParsesGeneratedLines(LeanDataLineTestParameters parameters)
        {
            // ignore time zone issues here, we'll just say everything is UTC, so no conversions are performed
            var factory = (BaseData) Activator.CreateInstance(parameters.Data.GetType());
            var parsed = factory.Reader(parameters.Config, parameters.ExpectedLine, parameters.Data.Time.Date, false);

            Assert.IsInstanceOf(parameters.Config.Type, parsed);
            Assert.AreEqual(parameters.Data.Time, parsed.Time);
            Assert.AreEqual(parameters.Data.EndTime, parsed.EndTime);
            Assert.AreEqual(parameters.Data.Symbol, parsed.Symbol);
            Assert.AreEqual(parameters.Data.Value, parsed.Value);
            if (parsed is Tick actual)
            {
                var expected = (Tick) parameters.Data;
                Assert.AreEqual(expected.Quantity, actual.Quantity);
                Assert.AreEqual(expected.BidPrice, actual.BidPrice);
                Assert.AreEqual(expected.AskPrice, actual.AskPrice);
                Assert.AreEqual(expected.BidSize, actual.BidSize);
                Assert.AreEqual(expected.AskSize, actual.AskSize);
                Assert.AreEqual(expected.Exchange, actual.Exchange);
                Assert.AreEqual(expected.SaleCondition, actual.SaleCondition);
                Assert.AreEqual(expected.Suspicious, actual.Suspicious);
            }
            else if (parsed is TradeBar actual)
            {
                var expected = (TradeBar) parameters.Data;
                AssertBarsAreEqual(expected, actual);
                Assert.AreEqual(expected.Volume, actual.Volume);
            }
            else if (parsed is QuoteBar actual)
            {
                var expected = (QuoteBar) parameters.Data;
                AssertBarsAreEqual(expected.Bid, actual.Bid);
                AssertBarsAreEqual(expected.Ask, actual.Ask);
                Assert.AreEqual(expected.LastBidSize, actual.LastBidSize);
                Assert.AreEqual(expected.LastAskSize, actual.LastAskSize);
            }
        }

        [Test, TestCaseSource(nameof(GetLeanDataLineTestParameters))]
        public void GetSourceMatchesGenerateZipFilePath(LeanDataLineTestParameters parameters)
        {
            var source = parameters.Data.GetSource(parameters.Config, parameters.Data.Time.Date, false);
            var normalizedSourcePath = new FileInfo(source.Source).FullName;
            var zipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, parameters.Data.Symbol, parameters.Data.Time.Date, parameters.Resolution, parameters.TickType);
            var normalizeZipFilePath = new FileInfo(zipFilePath).FullName;
            var indexOfHash = normalizedSourcePath.LastIndexOf("#", StringComparison.Ordinal);
            if (indexOfHash > 0)
            {
                normalizedSourcePath = normalizedSourcePath.Substring(0, indexOfHash);
            }
            Assert.AreEqual(normalizeZipFilePath, normalizedSourcePath);
        }

        [Test, TestCaseSource(nameof(GetLeanDataTestParameters))]
        public void GetSource(LeanDataTestParameters parameters)
        {
            var factory = (BaseData)Activator.CreateInstance(parameters.BaseDataType);
            var source = factory.GetSource(parameters.Config, parameters.Date, false);
            var expected = parameters.ExpectedZipFilePath;
            if (parameters.SecurityType == SecurityType.Option || parameters.SecurityType == SecurityType.Future)
            {
                expected += "#" + parameters.ExpectedZipEntryName;
            }
            Assert.AreEqual(expected, source.Source);
        }

        [Test]
        public void GetDataType_ReturnsCorrectType()
        {
            var tickType = typeof(Tick);
            var openInterestType = typeof(OpenInterest);
            var quoteBarType = typeof(QuoteBar);
            var tradeBarType = typeof(TradeBar);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Tick, TickType.OpenInterest), tickType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Daily, TickType.OpenInterest), tickType);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Second, TickType.OpenInterest), openInterestType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Tick, TickType.OpenInterest), openInterestType);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Minute, TickType.Quote), quoteBarType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Second, TickType.Trade), quoteBarType);

            Assert.AreEqual(LeanData.GetDataType(Resolution.Hour, TickType.Trade), tradeBarType);
            Assert.AreNotEqual(LeanData.GetDataType(Resolution.Tick, TickType.OpenInterest), tradeBarType);
        }

        [Test]
        public void LeanData_CanDetermineTheCorrectCommonDataTypes()
        {
            Assert.IsTrue(LeanData.IsCommonLeanDataType(typeof(OpenInterest)));
            Assert.IsTrue(LeanData.IsCommonLeanDataType(typeof(TradeBar)));
            Assert.IsTrue(LeanData.IsCommonLeanDataType(typeof(QuoteBar)));
            Assert.IsFalse(LeanData.IsCommonLeanDataType(typeof(Bitcoin)));
        }

        [Test]
        public void LeanData_GetCommonTickTypeForCommonDataTypes_ReturnsCorrectDataForTickResolution()
        {
            Assert.AreEqual(LeanData.GetCommonTickTypeForCommonDataTypes(typeof(Tick), SecurityType.Cfd), TickType.Quote);
            Assert.AreEqual(LeanData.GetCommonTickTypeForCommonDataTypes(typeof(Tick), SecurityType.Forex), TickType.Quote);
        }

        [Test]
        public void IncorrectPaths_CannotBeParsed()
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            var invalidPath = "forex/fxcm/eurusd/20160101_quote.zip";
            Assert.IsFalse(LeanData.TryParsePath(invalidPath, out symbol, out date, out resolution));

            var nonExistantPath = "Data/f/fxcm/eurusd/20160101_quote.zip";
            Assert.IsFalse(LeanData.TryParsePath(nonExistantPath, out symbol, out date, out resolution));

            var notAPath = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            Assert.IsFalse(LeanData.TryParsePath(notAPath, out symbol, out date, out resolution));

            var  emptyPath = "";
            Assert.IsFalse(LeanData.TryParsePath(emptyPath, out symbol, out date, out resolution));

            string nullPath = null;
            Assert.IsFalse(LeanData.TryParsePath(nullPath, out symbol, out date, out resolution));

            var optionsTradePath = "Data/option/u sa/minute/aapl/20140606_trade_american.zip";
            Assert.IsFalse(LeanData.TryParsePath(optionsTradePath, out symbol, out date, out resolution));
        }

        [Test]
        public void CorrectPaths_CanBeParsedCorrectly()
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            var customPath = "a/very/custom/path/forex/oanda/tick/eurusd/20170104_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(customPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.Oanda);
            Assert.AreEqual(resolution, Resolution.Tick);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "eurusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2017-01-04").Date);

            var mixedPathSeperators = @"Data//forex/fxcm\/minute//eurusd\\20160101_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(mixedPathSeperators, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.FXCM);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "eurusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-01-01").Date);

            var longRelativePath = "../../../../../../../../../Data/forex/fxcm/hour/gbpusd.zip";
            Assert.IsTrue(LeanData.TryParsePath(longRelativePath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.FXCM);
            Assert.AreEqual(resolution, Resolution.Hour);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "gbpusd");
            Assert.AreEqual(date.Date, DateTime.MinValue);

            var shortRelativePath = "Data/forex/fxcm/minute/eurusd/20160102_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(shortRelativePath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Forex);
            Assert.AreEqual(symbol.ID.Market, Market.FXCM);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "eurusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-01-02").Date);

            var dailyEquitiesPath = "Data/equity/usa/daily/aapl.zip";
            Assert.IsTrue(LeanData.TryParsePath(dailyEquitiesPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Equity);
            Assert.AreEqual(symbol.ID.Market, Market.USA);
            Assert.AreEqual(resolution, Resolution.Daily);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "aapl");
            Assert.AreEqual(date.Date, DateTime.MinValue);

            var minuteEquitiesPath = "Data/equity/usa/minute/googl/20070103_trade.zip";
            Assert.IsTrue(LeanData.TryParsePath(minuteEquitiesPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Equity);
            Assert.AreEqual(symbol.ID.Market, Market.USA);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "goog");
            Assert.AreEqual(date.Date, Parse.DateTime("2007-01-03").Date);

            var cfdPath = "Data/cfd/oanda/minute/bcousd/20160101_trade.zip";
            Assert.IsTrue(LeanData.TryParsePath(cfdPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Cfd);
            Assert.AreEqual(symbol.ID.Market, Market.Oanda);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "bcousd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-01-01").Date);
        }

        [TestCase("Data\\alternative\\estimize\\consensus\\aapl.csv", "aapl", null)]
        [TestCase("Data\\alternative\\psychsignal\\aapl\\20161007.zip", "aapl", "2016-10-07")]
        [TestCase("Data\\alternative\\sec\\aapl\\20161007_8K.zip", "aapl", "2016-10-07")]
        [TestCase("Data\\alternative\\smartinsider\\intentions\\aapl.tsv", "aapl", null)]
        [TestCase("Data\\alternative\\trading-economics\\calendar\\fdtr\\20161007.zip", "fdtr", "2016-10-07")]
        [TestCase("Data\\alternative\\ustreasury\\yieldcurverates.zip", "yieldcurverates", null)]
        public void AlternativePaths_CanBeParsedCorrectly(string path, string expectedSymbol, string expectedDate)
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            Assert.IsTrue(LeanData.TryParsePath(path, out symbol, out date, out resolution));
            Assert.AreEqual(SecurityType.Base, symbol.SecurityType);
            Assert.AreEqual(Market.USA, symbol.ID.Market);
            Assert.AreEqual(Resolution.Daily, resolution);
            Assert.AreEqual(expectedSymbol, symbol.ID.Symbol.ToLowerInvariant());
            Assert.AreEqual(expectedDate == null ? default(DateTime) : Parse.DateTime(expectedDate).Date, date);
        }

        [Test]
        public void CryptoPaths_CanBeParsedCorrectly()
        {
            DateTime date;
            Symbol symbol;
            Resolution resolution;

            var cryptoPath = "Data\\crypto\\gdax\\daily\\btcusd_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(cryptoPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Crypto);
            Assert.AreEqual(symbol.ID.Market, Market.GDAX);
            Assert.AreEqual(resolution, Resolution.Daily);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "btcusd");

            cryptoPath = "Data\\crypto\\gdax\\hour\\btcusd_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(cryptoPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Crypto);
            Assert.AreEqual(symbol.ID.Market, Market.GDAX);
            Assert.AreEqual(resolution, Resolution.Hour);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "btcusd");

            cryptoPath = "Data\\crypto\\gdax\\minute\\btcusd\\20161007_quote.zip";
            Assert.IsTrue(LeanData.TryParsePath(cryptoPath, out symbol, out date, out resolution));
            Assert.AreEqual(symbol.SecurityType, SecurityType.Crypto);
            Assert.AreEqual(symbol.ID.Market, Market.GDAX);
            Assert.AreEqual(resolution, Resolution.Minute);
            Assert.AreEqual(symbol.ID.Symbol.ToLowerInvariant(), "btcusd");
            Assert.AreEqual(date.Date, Parse.DateTime("2016-10-07").Date);
        }

        [TestCase(SecurityType.Base, "alteRNative")]
        [TestCase(SecurityType.Equity, "Equity")]
        [TestCase(SecurityType.Cfd, "Cfd")]
        [TestCase(SecurityType.Commodity, "Commodity")]
        [TestCase(SecurityType.Crypto, "Crypto")]
        [TestCase(SecurityType.Forex, "Forex")]
        [TestCase(SecurityType.Future, "Future")]
        [TestCase(SecurityType.Option, "Option")]
        [TestCase(SecurityType.FutureOption, "FutureOption")]
        public void ParsesDataSecurityType(SecurityType type, string path)
        {
            Assert.AreEqual(type, LeanData.ParseDataSecurityType(path));
        }

        [Test]
        public void SecurityTypeAsDataPath()
        {
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("alternative"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("equity"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("base"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("option"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("cfd"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("crypto"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("future"));
            Assert.IsTrue(LeanData.SecurityTypeAsDataPath.Contains("forex"));
        }

        [Test]
        public void OptionZipFilePathWithUnderlyingEquity()
        {
            var underlying = Symbol.Create("SPY", SecurityType.Equity, QuantConnect.Market.USA);
            var optionSymbol = Symbol.CreateOption(
                underlying,
                Market.USA,
                OptionStyle.American,
                OptionRight.Put,
                4200m,
                new DateTime(2020, 12, 31));

            var optionZipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote)
                .Replace(Path.DirectorySeparatorChar, '/');
            var optionEntryFilePath = LeanData.GenerateZipEntryName(optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote);

            Assert.AreEqual("../../../Data/option/usa/minute/spy/20200922_quote_american.zip", optionZipFilePath);
            Assert.AreEqual("20200922_spy_minute_quote_american_put_42000000_20201231.csv", optionEntryFilePath);
        }

        [TestCase("ES", "ES")]
        [TestCase("DC", "DC")]
        [TestCase("GC", "OG")]
        [TestCase("ZT", "OZT")]
        public void OptionZipFilePathWithUnderlyingFuture(string futureOptionTicker, string expectedFutureOptionTicker)
        {
            var underlying = Symbol.CreateFuture(futureOptionTicker, Market.CME, new DateTime(2021, 3, 19));
            var optionSymbol = Symbol.CreateOption(
                underlying,
                Market.CME,
                OptionStyle.American,
                OptionRight.Put,
                4200m,
                new DateTime(2021, 3, 18));

            var optionZipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote)
                .Replace(Path.DirectorySeparatorChar, '/');
            var optionEntryFilePath = LeanData.GenerateZipEntryName(optionSymbol, new DateTime(2020, 9, 22), Resolution.Minute, TickType.Quote);

            Assert.AreEqual($"../../../Data/futureoption/cme/minute/{expectedFutureOptionTicker.ToLowerInvariant()}/{underlying.ID.Date:yyyyMMdd}/20200922_quote_american.zip", optionZipFilePath);
            Assert.AreEqual($"20200922_{expectedFutureOptionTicker.ToLowerInvariant()}_minute_quote_american_put_42000000_{optionSymbol.ID.Date:yyyyMMdd}.csv", optionEntryFilePath);
        }

        [TestCase(OptionRight.Call, 1650, 2020, 3, 26)]
        [TestCase(OptionRight.Call, 1540, 2020, 3, 26)]
        [TestCase(OptionRight.Call, 1600, 2020, 2, 25)]
        [TestCase(OptionRight.Call, 1545, 2020, 2, 25)]
        public void FutureOptionSingleZipFileContainingMultipleFuturesOptionsContracts(OptionRight right, int strike, int year, int month, int day)
        {
            var underlying = Symbol.CreateFuture("GC", Market.COMEX, new DateTime(2020, 4, 28));
            var expiry = new DateTime(year, month, day);
            var optionSymbol = Symbol.CreateOption(
                underlying,
                Market.COMEX,
                OptionStyle.American,
                right,
                (decimal)strike,
                expiry);

            var optionZipFilePath = LeanData.GenerateZipFilePath(Globals.DataFolder, optionSymbol, new DateTime(2020, 1, 5), Resolution.Minute, TickType.Quote)
                .Replace(Path.DirectorySeparatorChar, '/');
            var optionEntryFilePath = LeanData.GenerateZipEntryName(optionSymbol, new DateTime(2020, 1, 5), Resolution.Minute, TickType.Quote);

            Assert.AreEqual("../../../Data/futureoption/comex/minute/og/20200428/20200105_quote_american.zip", optionZipFilePath);
            Assert.AreEqual($"20200105_og_minute_quote_american_{right.ToLower()}_{strike}0000_{expiry:yyyyMMdd}.csv", optionEntryFilePath);
        }

        private static void AssertBarsAreEqual(IBar expected, IBar actual)
        {
            if (expected == null && actual == null)
            {
                return;
            }
            if (expected == null && actual != null)
            {
                Assert.Fail("Expected null bar");
            }
            Assert.AreEqual(expected.Open, actual.Open);
            Assert.AreEqual(expected.High, actual.High);
            Assert.AreEqual(expected.Low, actual.Low);
            Assert.AreEqual(expected.Close, actual.Close);
        }

        private static TestCaseData[] GetLeanDataTestParameters()
        {
            var date = new DateTime(2016, 02, 17);
            var dateFutures = new DateTime(2018, 12, 10);

            return new List<LeanDataTestParameters>
            {
                // equity
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Tick, TickType.Trade, "20160217_trade.zip", "20160217_spy_Trade_Tick.csv", "equity/usa/tick/spy"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Second, TickType.Trade, "20160217_trade.zip", "20160217_spy_second_trade.csv", "equity/usa/second/spy"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Minute, TickType.Trade, "20160217_trade.zip", "20160217_spy_minute_trade.csv", "equity/usa/minute/spy"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Hour, TickType.Trade, "spy.zip", "spy.csv", "equity/usa/hour"),
                new LeanDataTestParameters(Symbols.SPY, date, Resolution.Daily, TickType.Trade, "spy.zip", "spy.csv", "equity/usa/daily"),

                // equity option trades
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Tick, TickType.Trade, "20160217_trade_american.zip", "20160217_spy_tick_trade_american_put_1920000_20160219.csv", "option/usa/tick/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Tick, TickType.Quote, "20160217_quote_american.zip", "20160217_spy_tick_quote_american_put_1920000_20160219.csv", "option/usa/tick/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Second, TickType.Trade, "20160217_trade_american.zip", "20160217_spy_second_trade_american_put_1920000_20160219.csv", "option/usa/second/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Second, TickType.Quote, "20160217_quote_american.zip", "20160217_spy_second_quote_american_put_1920000_20160219.csv", "option/usa/second/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Minute, TickType.Trade, "20160217_trade_american.zip", "20160217_spy_minute_trade_american_put_1920000_20160219.csv", "option/usa/minute/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Minute, TickType.Quote, "20160217_quote_american.zip", "20160217_spy_minute_quote_american_put_1920000_20160219.csv", "option/usa/minute/spy"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Hour, TickType.Trade, "spy_trade_american.zip", "spy_trade_american_put_1920000_20160219.csv", "option/usa/hour"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Hour, TickType.Quote, "spy_quote_american.zip", "spy_quote_american_put_1920000_20160219.csv", "option/usa/hour"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Daily, TickType.Trade, "spy_trade_american.zip", "spy_trade_american_put_1920000_20160219.csv", "option/usa/daily"),
                new LeanDataTestParameters(Symbols.SPY_P_192_Feb19_2016, date, Resolution.Daily, TickType.Quote, "spy_quote_american.zip", "spy_quote_american_put_1920000_20160219.csv", "option/usa/daily"),

                // forex
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Tick, TickType.Quote, "20160217_quote.zip", "20160217_eurusd_tick_quote.csv", "forex/oanda/tick/eurusd"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Second, TickType.Quote, "20160217_quote.zip", "20160217_eurusd_second_quote.csv", "forex/oanda/second/eurusd"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Minute, TickType.Quote, "20160217_quote.zip", "20160217_eurusd_minute_quote.csv", "forex/oanda/minute/eurusd"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Hour, TickType.Quote, "eurusd.zip", "eurusd.csv", "forex/oanda/hour"),
                new LeanDataTestParameters(Symbols.EURUSD, date, Resolution.Daily, TickType.Quote, "eurusd.zip", "eurusd.csv", "forex/oanda/daily"),

                // cfd
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Tick, TickType.Quote, "20160217_quote.zip", "20160217_de10ybeur_tick_quote.csv", "cfd/fxcm/tick/de10ybeur"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Second, TickType.Quote, "20160217_quote.zip", "20160217_de10ybeur_second_quote.csv", "cfd/fxcm/second/de10ybeur"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Minute, TickType.Quote, "20160217_quote.zip", "20160217_de10ybeur_minute_quote.csv", "cfd/fxcm/minute/de10ybeur"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Hour, TickType.Quote, "de10ybeur.zip", "de10ybeur.csv", "cfd/fxcm/hour"),
                new LeanDataTestParameters(Symbols.DE10YBEUR, date, Resolution.Daily, TickType.Quote, "de10ybeur.zip", "de10ybeur.csv", "cfd/fxcm/daily"),

                // Crypto - trades
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Tick, TickType.Trade, "20160217_trade.zip", "20160217_btcusd_tick_trade.csv", "crypto/gdax/tick/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Second, TickType.Trade, "20160217_trade.zip", "20160217_btcusd_second_trade.csv", "crypto/gdax/second/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Minute, TickType.Trade, "20160217_trade.zip", "20160217_btcusd_minute_trade.csv", "crypto/gdax/minute/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Hour, TickType.Trade, "btcusd_trade.zip", "btcusd.csv", "crypto/gdax/hour"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Daily, TickType.Trade, "btcusd_trade.zip", "btcusd.csv", "crypto/gdax/daily"),

                // Crypto - quotes
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Tick, TickType.Quote, "20160217_quote.zip", "20160217_btcusd_tick_quote.csv", "crypto/gdax/tick/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Second, TickType.Quote, "20160217_quote.zip", "20160217_btcusd_second_quote.csv", "crypto/gdax/second/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Minute, TickType.Quote, "20160217_quote.zip", "20160217_btcusd_minute_quote.csv", "crypto/gdax/minute/btcusd"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Hour, TickType.Quote, "btcusd_quote.zip", "btcusd.csv", "crypto/gdax/hour"),
                new LeanDataTestParameters(Symbols.BTCUSD, date, Resolution.Daily, TickType.Quote, "btcusd_quote.zip", "btcusd.csv", "crypto/gdax/daily"),

                // Futures (expiration month == contract month) - trades
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Tick, TickType.Trade, "20181210_trade.zip", "20181210_es_tick_trade_201812_20181221.csv", "future/cme/tick/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Second, TickType.Trade, "20181210_trade.zip", "20181210_es_second_trade_201812_20181221.csv", "future/cme/second/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Minute, TickType.Trade, "20181210_trade.zip", "20181210_es_minute_trade_201812_20181221.csv", "future/cme/minute/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Hour, TickType.Trade, "es_trade.zip", "es_trade_201812_20181221.csv", "future/cme/hour"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Daily, TickType.Trade, "es_trade.zip", "es_trade_201812_20181221.csv", "future/cme/daily"),

                // Futures (expiration month == contract month) - quotes
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Tick, TickType.Quote, "20181210_quote.zip", "20181210_es_tick_quote_201812_20181221.csv", "future/cme/tick/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Second, TickType.Quote, "20181210_quote.zip", "20181210_es_second_quote_201812_20181221.csv", "future/cme/second/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Minute, TickType.Quote, "20181210_quote.zip", "20181210_es_minute_quote_201812_20181221.csv", "future/cme/minute/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Hour, TickType.Quote, "es_quote.zip", "es_quote_201812_20181221.csv", "future/cme/hour"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Daily, TickType.Quote, "es_quote.zip", "es_quote_201812_20181221.csv", "future/cme/daily"),

                // Futures (expiration month == contract month) - OpenInterest
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Tick, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_es_tick_openinterest_201812_20181221.csv", "future/cme/tick/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Second, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_es_second_openinterest_201812_20181221.csv", "future/cme/second/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Minute, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_es_minute_openinterest_201812_20181221.csv", "future/cme/minute/es"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Hour, TickType.OpenInterest, "es_openinterest.zip", "es_openinterest_201812_20181221.csv", "future/cme/hour"),
                new LeanDataTestParameters(Symbols.Future_ESZ18_Dec2018, dateFutures, Resolution.Daily, TickType.OpenInterest, "es_openinterest.zip", "es_openinterest_201812_20181221.csv", "future/cme/daily"),

                // Futures (expiration month < contract month) - trades
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Tick, TickType.Trade, "20181210_trade.zip", "20181210_cl_tick_trade_201901_20181219.csv", "future/nymex/tick/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Second, TickType.Trade, "20181210_trade.zip", "20181210_cl_second_trade_201901_20181219.csv", "future/nymex/second/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Minute, TickType.Trade, "20181210_trade.zip", "20181210_cl_minute_trade_201901_20181219.csv", "future/nymex/minute/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Hour, TickType.Trade, "cl_trade.zip", "cl_trade_201901_20181219.csv", "future/nymex/hour"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Daily, TickType.Trade, "cl_trade.zip", "cl_trade_201901_20181219.csv", "future/nymex/daily"),

                // Futures (expiration month < contract month) - quotes
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Tick, TickType.Quote, "20181210_quote.zip", "20181210_cl_tick_quote_201901_20181219.csv", "future/nymex/tick/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Second, TickType.Quote, "20181210_quote.zip", "20181210_cl_second_quote_201901_20181219.csv", "future/nymex/second/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Minute, TickType.Quote, "20181210_quote.zip", "20181210_cl_minute_quote_201901_20181219.csv", "future/nymex/minute/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Hour, TickType.Quote, "cl_quote.zip", "cl_quote_201901_20181219.csv", "future/nymex/hour"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Daily, TickType.Quote, "cl_quote.zip", "cl_quote_201901_20181219.csv", "future/nymex/daily"),

                // Futures (expiration month < contract month) - open interest
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Tick, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_cl_tick_openinterest_201901_20181219.csv", "future/nymex/tick/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Second, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_cl_second_openinterest_201901_20181219.csv", "future/nymex/second/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Minute, TickType.OpenInterest, "20181210_openinterest.zip", "20181210_cl_minute_openinterest_201901_20181219.csv", "future/nymex/minute/cl"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Hour, TickType.OpenInterest, "cl_openinterest.zip", "cl_openinterest_201901_20181219.csv", "future/nymex/hour"),
                new LeanDataTestParameters(Symbols.Future_CLF19_Jan2019, dateFutures, Resolution.Daily, TickType.OpenInterest, "cl_openinterest.zip", "cl_openinterest_201901_20181219.csv", "future/nymex/daily"),

            }.Select(x => new TestCaseData(x).SetName(x.Name)).ToArray();
        }

        private static TestCaseData[] GetLeanDataLineTestParameters()
        {
            var time = new DateTime(2016, 02, 18, 9, 30, 0);
            return new List<LeanDataLineTestParameters>
            {
                //equity
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.SPY, Value = 1, Quantity = 2, TickType = TickType.Trade, Exchange = "EX", SaleCondition = "SC", Suspicious = true}, SecurityType.Equity, Resolution.Tick,
                    "34200000,10000,2,EX,SC,1"),
                new LeanDataLineTestParameters(new TradeBar(time, Symbols.SPY, 1, 2, 3, 4, 5, TimeSpan.FromMinutes(1)), SecurityType.Equity, Resolution.Minute,
                    "34200000,10000,20000,30000,40000,5"),
                new LeanDataLineTestParameters(new TradeBar(time.Date, Symbols.SPY, 1, 2, 3, 4, 5, TimeSpan.FromDays(1)), SecurityType.Equity, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5"),

                // options
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.SPY_P_192_Feb19_2016, null, 0, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)) {Bid = null}, SecurityType.Option, Resolution.Minute,
                    "34200000,,,,,0,60000,70000,80000,90000,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.SPY_P_192_Feb19_2016, new Bar(1, 2, 3, 4), 5, null, 0, TimeSpan.FromDays(1)) {Ask = null}, SecurityType.Option, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5,,,,,0"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.SPY_P_192_Feb19_2016, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)), SecurityType.Option, Resolution.Minute,
                    "34200000,10000,20000,30000,40000,5,60000,70000,80000,90000,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.SPY_P_192_Feb19_2016, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromDays(1)), SecurityType.Option, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5,60000,70000,80000,90000,10"),
                new LeanDataLineTestParameters(new Tick(time, Symbols.SPY_P_192_Feb19_2016, 0, 1, 3) {Value = 2m, TickType = TickType.Quote, BidSize = 2, AskSize = 4, Exchange = "EX", Suspicious = true}, SecurityType.Option, Resolution.Tick,
                    "34200000,10000,2,30000,4,EX,1"),
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.SPY_P_192_Feb19_2016, Value = 1, Quantity = 2,TickType = TickType.Trade, Exchange = "EX", SaleCondition = "SC", Suspicious = true}, SecurityType.Option, Resolution.Tick,
                    "34200000,10000,2,EX,SC,1"),
                new LeanDataLineTestParameters(new TradeBar(time, Symbols.SPY_P_192_Feb19_2016, 1, 2, 3, 4, 5, TimeSpan.FromMinutes(1)), SecurityType.Option, Resolution.Minute,
                    "34200000,10000,20000,30000,40000,5"),
                new LeanDataLineTestParameters(new TradeBar(time.Date, Symbols.SPY_P_192_Feb19_2016, 1, 2, 3, 4, 5, TimeSpan.FromDays(1)), SecurityType.Option, Resolution.Daily,
                    "20160218 00:00,10000,20000,30000,40000,5"),

                // forex
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.EURUSD, BidPrice = 1, Value =1.5m, AskPrice = 2, TickType = TickType.Quote}, SecurityType.Forex, Resolution.Tick,
                    "34200000,1,2"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.EURUSD, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromMinutes(1)), SecurityType.Forex, Resolution.Minute, "34200000,1,2,3,4,0,1,2,3,4,0"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.EURUSD, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromDays(1)), SecurityType.Forex, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,0,1,2,3,4,0"),

                // cfd
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.DE10YBEUR, BidPrice = 1, Value = 1.5m, AskPrice = 2, TickType = TickType.Quote}, SecurityType.Cfd, Resolution.Tick,
                    "34200000,1,2"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.DE10YBEUR, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromMinutes(1)), SecurityType.Cfd, Resolution.Minute,
                    "34200000,1,2,3,4,0,1,2,3,4,0"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.DE10YBEUR, new Bar(1, 2, 3, 4), 0, new Bar(1, 2, 3, 4), 0, TimeSpan.FromDays(1)), SecurityType.Cfd, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,0,1,2,3,4,0"),

                // crypto - trades
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.BTCUSD, null, 0, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)) {Bid = null}, SecurityType.Crypto, Resolution.Minute,
                    "34200000,,,,,0,6,7,8,9,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.BTCUSD, new Bar(1, 2, 3, 4), 5, null, 0, TimeSpan.FromDays(1)) {Ask = null}, SecurityType.Crypto, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,5,,,,,0"),
                new LeanDataLineTestParameters(new QuoteBar(time, Symbols.BTCUSD, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromMinutes(1)), SecurityType.Crypto, Resolution.Minute,
                    "34200000,1,2,3,4,5,6,7,8,9,10"),
                new LeanDataLineTestParameters(new QuoteBar(time.Date, Symbols.BTCUSD, new Bar(1, 2, 3, 4), 5, new Bar(6, 7, 8, 9), 10, TimeSpan.FromDays(1)), SecurityType.Crypto, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,5,6,7,8,9,10"),
                new LeanDataLineTestParameters(new Tick(time, Symbols.BTCUSD, 0, 1, 3) {Value = 2m, TickType = TickType.Quote, BidSize = 2, AskSize = 4, Exchange = "gdax", Suspicious = false}, SecurityType.Crypto, Resolution.Tick,
                    "34200000,1,2,3,4"),
                new LeanDataLineTestParameters(new Tick {Time = time, Symbol = Symbols.BTCUSD, Value = 1, Quantity = 2,TickType = TickType.Trade, Exchange = "gdax", Suspicious = false}, SecurityType.Crypto, Resolution.Tick,
                    "34200000,1,2"),
                new LeanDataLineTestParameters(new TradeBar(time, Symbols.BTCUSD, 1, 2, 3, 4, 5, TimeSpan.FromMinutes(1)), SecurityType.Crypto, Resolution.Minute,
                    "34200000,1,2,3,4,5"),
                new LeanDataLineTestParameters(new TradeBar(time.Date, Symbols.BTCUSD, 1, 2, 3, 4, 5, TimeSpan.FromDays(1)), SecurityType.Crypto, Resolution.Daily,
                    "20160218 00:00,1,2,3,4,5"),

            }.Select(x => new TestCaseData(x).SetName(x.Name)).ToArray();
        }

        public class LeanDataTestParameters
        {
            public readonly string Name;
            public readonly Symbol Symbol;
            public readonly DateTime Date;
            public readonly Resolution Resolution;
            public readonly TickType TickType;
            public readonly Type BaseDataType;
            public readonly SubscriptionDataConfig Config;
            public readonly string ExpectedZipFileName;
            public readonly string ExpectedZipEntryName;
            public readonly string ExpectedRelativeZipFilePath;
            public readonly string ExpectedZipFilePath;
            public SecurityType SecurityType { get { return Symbol.ID.SecurityType; } }

            public LeanDataTestParameters(Symbol symbol, DateTime date, Resolution resolution, TickType tickType, string expectedZipFileName, string expectedZipEntryName, string expectedRelativeZipFileDirectory = "")
            {
                Symbol = symbol;
                Date = date;
                Resolution = resolution;
                TickType = tickType;
                ExpectedZipFileName = expectedZipFileName;
                ExpectedZipEntryName = expectedZipEntryName;
                ExpectedRelativeZipFilePath = Path.Combine(expectedRelativeZipFileDirectory, expectedZipFileName).Replace("/", Path.DirectorySeparatorChar.ToStringInvariant());
                ExpectedZipFilePath = Path.Combine(Globals.DataFolder, ExpectedRelativeZipFilePath);

                Name = SecurityType + "_" + resolution + "_" + symbol.Value + "_" + tickType;

                BaseDataType = resolution == Resolution.Tick ? typeof(Tick) : typeof(TradeBar);
                if (symbol.ID.SecurityType == SecurityType.Option && resolution != Resolution.Tick)
                {
                    BaseDataType = typeof(QuoteBar);
                }
                Config = new SubscriptionDataConfig(BaseDataType, symbol, resolution, TimeZones.NewYork, TimeZones.NewYork, true, false, false, false, tickType);
            }
        }

        public class LeanDataLineTestParameters
        {
            public readonly string Name;
            public readonly BaseData Data;
            public readonly SecurityType SecurityType;
            public readonly Resolution Resolution;
            public readonly string ExpectedLine;
            public readonly SubscriptionDataConfig Config;
            public readonly TickType TickType;

            public LeanDataLineTestParameters(BaseData data, SecurityType securityType, Resolution resolution, string expectedLine)
            {
                Data = data;
                SecurityType = securityType;
                Resolution = resolution;
                ExpectedLine = expectedLine;
                if (data is Tick tick)
                {
                    TickType = tick.TickType;
                }
                else if (data is TradeBar)
                {
                    TickType = TickType.Trade;
                }
                else if (data is QuoteBar)
                {
                    TickType = TickType.Quote;
                }
                else
                {
                    throw new NotImplementedException();
                }

                // override for forex/cfd
                if (data.Symbol.ID.SecurityType == SecurityType.Forex || data.Symbol.ID.SecurityType == SecurityType.Cfd)
                {
                    TickType = TickType.Quote;
                }

                Config = new SubscriptionDataConfig(Data.GetType(), Data.Symbol, Resolution, TimeZones.Utc, TimeZones.Utc, false, true, false, false, TickType);

                Name = SecurityType + "_" + data.GetType().Name;

                if (data.GetType() != typeof (Tick) || Resolution != Resolution.Tick)
                {
                    Name += "_" + Resolution;
                }

                if (data is Tick tick)
                {
                    Name += "_" + tick.TickType;
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Tests\Common\Util\LeanDataTests.cs(112,41): error CS0136: A local or parameter named 'actual' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Tests\Common\Util\LeanDataTests.cs(118,41): error CS0136: A local or parameter named 'actual' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Tests\Common\Util\LeanDataTests.cs(694,34): error CS0128: A local variable or function named 'tick' is already defined in this scope,D:\a\1\s\Tests\Common\Util\LeanDataTests.cs(696,35): error CS0165: Use of unassigned local variable 'tick'
######################################################################


