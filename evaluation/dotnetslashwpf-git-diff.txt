diff --git a/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemData/SystemDataExtension.cs b/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemData/SystemDataExtension.cs
index 95ecbc5f..e3de9610 100644
--- a/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemData/SystemDataExtension.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemData/SystemDataExtension.cs
@@ -31,8 +31,7 @@ internal override bool IsDataRowView(object item)
         // return true if the value is null in the SqlTypes sense
         internal override bool IsSqlNull(object value)
         {
-            INullable nullable = value as INullable;
-            return (nullable != null && nullable.IsNull);
+            return (value is INullable nullable && nullable.IsNull);
         }
 
         // return true if the type is nullable in the SqlTypes sense
@@ -130,8 +129,7 @@ internal override object GetValue(object item, PropertyDescriptor pd, bool useFo
                 else if (pd.GetType() == s_DataRelationPropertyDescriptorType)
                 {
                     // the "suitable ADO object" is the parent DataRowView
-                    DataRowView dataRowView = item as DataRowView;
-                    if (dataRowView != null)
+                    if (item is DataRowView dataRowView)
                     {
                         new DataRowViewToRelatedViewLink(dataRowView, value);
                     }
@@ -190,9 +188,8 @@ internal override bool DetermineWhetherDBNullIsValid(object item, string columnN
                 {
                     column = table.Columns[columnName];
                 }
-                else if (arg is int)
+                else if (arg is int index)
                 {
-                    int index = (int)arg;
                     if (0 <= index && index < table.Columns.Count)
                     {
                         column = table.Columns[index];
diff --git a/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemDrawing/SystemDrawingExtension.cs b/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemDrawing/SystemDrawingExtension.cs
index bffbd336..c4d0cfb1 100644
--- a/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemDrawing/SystemDrawingExtension.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemDrawing/SystemDrawingExtension.cs
@@ -44,9 +44,8 @@ internal override bool IsMetafile(object data)
         internal override IntPtr GetHandleFromMetafile(Object data)
         {
             IntPtr hMetafile = IntPtr.Zero;
-            Metafile metafile = data as Metafile;
 
-            if (metafile != null)
+            if (data is Metafile metafile)
             {
                 // Get the Windows handle from the metafile object.
                 hMetafile = metafile.GetHenhmetafile();
@@ -90,8 +89,7 @@ internal override IntPtr GetHBitmap(object data, out int width, out int height)
         // Get a bitmap handle from a Bitmap
         internal override IntPtr GetHBitmapFromBitmap(object data)
         {
-            Bitmap bitmap = data as Bitmap;
-            return (bitmap != null) ? bitmap.GetHbitmap() : IntPtr.Zero;
+            return (data is Bitmap bitmap) ? bitmap.GetHbitmap() : IntPtr.Zero;
         }
 
         // Convert a metafile to HBitmap
@@ -133,8 +131,7 @@ internal override void SaveMetafileToImageStream(MemoryStream metafileStream, St
         // Get a bitmap from the given data (either BitmapSource or Bitmap)
         private static Bitmap GetBitmapImpl(object data)
         {
-            BitmapSource bitmapSource = data as BitmapSource;
-            if (bitmapSource != null)
+            if (data is BitmapSource bitmapSource)
             {
                 // Convert BitmapSource to System.Drawing.Bitmap to get Win32 HBITMAP.
                 BitmapEncoder bitmapEncoder;
diff --git a/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemXml/SystemXmlExtension.cs b/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemXml/SystemXmlExtension.cs
index fa40c875..3a3a192a 100644
--- a/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemXml/SystemXmlExtension.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Extensions/PresentationFramework-SystemXml/SystemXmlExtension.cs
@@ -36,8 +36,7 @@ internal override bool IsXmlNamespaceManager(object item)
         // if the item is an XmlNode, get the value corresponding to the given name
         internal override bool TryGetValueFromXmlNode(object item, string name, out object value)
         {
-            XmlNode node = item as XmlNode;
-            if (node != null)
+            if (item is XmlNode node)
             {
                 value = SelectStringValue(node, name, null);
                 return true;
@@ -52,8 +51,7 @@ internal override bool TryGetValueFromXmlNode(object item, string name, out obje
         // create a comparer for an Xml collection (if applicable)
         internal override IComparer PrepareXmlComparer(IEnumerable collection, SortDescriptionCollection sort, CultureInfo culture)
         {
-            XmlDataCollection xdc = collection as XmlDataCollection;
-            if (xdc != null)
+            if (collection is XmlDataCollection xdc)
             {
                 Invariant.Assert(sort != null);
                 return new XmlNodeComparer(sort, xdc.XmlNamespaceManager, culture);
@@ -64,8 +62,7 @@ internal override IComparer PrepareXmlComparer(IEnumerable collection, SortDescr
         // return true if parent is an empty XmlDataCollection.
         internal override bool IsEmptyXmlDataCollection(object parent)
         {
-            XmlDataCollection xdc = parent as XmlDataCollection;
-            return (xdc != null) ? xdc.Count > 0 : false;
+            return (parent is XmlDataCollection xdc) ? xdc.Count > 0 : false;
         }
 
         // when item is an XmlNode, get its tag name (using the target DO as context
@@ -87,15 +84,12 @@ internal override string GetXmlTagName(object item, DependencyObject target)
         // find a node with the given string as its InnerText
         internal override object FindXmlNodeWithInnerText(IEnumerable items, object innerText, out int index)
         {
-            string innerTextString = innerText as string;
-
-            if (innerTextString != null)
+            if (innerText is string innerTextString)
             {
                 index = 0;
                 foreach (object item in items)
                 {
-                    XmlNode node = item as XmlNode;
-                    if (node != null && node.InnerText == innerTextString)
+                    if (item is XmlNode node && node.InnerText == innerTextString)
                         return node;
                     ++index;
                 }
@@ -108,9 +102,7 @@ internal override object FindXmlNodeWithInnerText(IEnumerable items, object inne
         // get the InnerText of the given node
         internal override object GetInnerText(object item)
         {
-            XmlNode node = item as XmlNode;
-
-            if (node != null)
+            if (item is XmlNode node)
             {
                 return node.InnerText;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/MarkupCompiler.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/MarkupCompiler.cs
index aa28323c..056e18d5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/MarkupCompiler.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/MarkupCompiler.cs
@@ -579,10 +579,7 @@ private void _Compile(string relativeSourceFile, bool pass2)
                 }
 
 
-                if (SourceFileInfo != null)
-                {
-                    SourceFileInfo.CloseStream();
-                }
+                SourceFileInfo?.CloseStream();
 
                 if (bamlStream != null)
                 {
@@ -1409,7 +1406,7 @@ private string GetFullClassName(string ns, string className)
         {
             string fullClass = className;
 
-            if (ns != null && ns.Length > 0)
+            if (!string.IsNullOrEmpty(ns))
             {
                 fullClass = ns + DOT + className;
             }
@@ -1906,9 +1903,8 @@ private CodeExpression GetPropertyValueExpression(ITypeDescriptorContext ctx, Ty
         private Type GetEventHandlerType(MemberInfo memberInfo)
         {
             Type eventHandlerType = null;
-            if (memberInfo is EventInfo)
+            if (memberInfo is EventInfo ei)
             {
-                EventInfo ei = (EventInfo)memberInfo;
                 eventHandlerType = ei.EventHandlerType;
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/PathInternal.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/PathInternal.cs
index 661aa187..9871e40f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/PathInternal.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/MarkupCompiler/PathInternal.cs
@@ -364,7 +364,7 @@ public static bool DoesEndInDirectorySeparator(ReadOnlySpan<char> path)
         /// Returns true if the path ends in a directory separator.
         /// </summary>
         public static bool DoesEndInDirectorySeparator(string path)
-              => path != null && path.Length > 0 && PathInternal.IsDirectorySeparator(path[path.Length - 1]);
+              => !string.IsNullOrEmpty(path) && PathInternal.IsDirectorySeparator(path[path.Length - 1]);
         
         internal const char VolumeSeparatorChar = ':';
           // \\?\UNC\, \\.\UNC\
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/CompilerWrapper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/CompilerWrapper.cs
index 5ae45bc2..aa341759 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/CompilerWrapper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/CompilerWrapper.cs
@@ -249,9 +249,7 @@ internal bool DoCompilation(string assemblyName, string language, string rootNam
             {
                 for (int i = 0; i < _mc.ReferenceAssemblyList.Count; i++)
                 {
-                    ReferenceAssembly asmReference = _mc.ReferenceAssemblyList[i] as ReferenceAssembly;
-
-                    if (asmReference != null)
+                    if (_mc.ReferenceAssemblyList[i] is ReferenceAssembly asmReference)
                     {
                         if (String.Compare(asmReference.AssemblyName, assemblyName, StringComparison.OrdinalIgnoreCase) == 0)
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskFileService.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskFileService.cs
index 6bf2edd2..bd6a7c09 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskFileService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskFileService.cs
@@ -163,8 +163,8 @@ public byte[] GetChecksum(string fileName, Guid hashGuid)
             if (HostFileManager != null)
             {
                 object docData = HostFileManager.GetFileDocData(fileName);
-                IPersistFileCheckSum fileChecksummer = docData as IPersistFileCheckSum;
-                if (fileChecksummer != null)
+
+                if (docData is IPersistFileCheckSum fileChecksummer)
                 {
                     byte[] tempBytes = new byte[1024];
                     int actualSize;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskHelper.cs
index 527ec580..a33da4fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/MS/Internal/Tasks/TaskHelper.cs
@@ -127,7 +127,7 @@ internal static bool BooleanStringValue(string str)
         {
             bool  isBoolean = false;
 
-            if (str != null && str.Length > 0)
+            if (!string.IsNullOrEmpty(str))
             {
                 str = str.ToLower(CultureInfo.InvariantCulture);
 
@@ -150,7 +150,7 @@ internal static string GetLowerString(string str)
         {
             string lowerStr = null;
 
-            if (str != null && str.Length > 0)
+            if (!string.IsNullOrEmpty(str))
             {
                 lowerStr = str.ToLower(CultureInfo.InvariantCulture);
             }
@@ -174,7 +174,7 @@ internal static bool IsValidCultureName(string name)
                 // It means no satellite assembly will be generated, all the
                 // resource images will go to the main assembly.
                 //
-                if (name != null && name.Length > 0)
+                if (!string.IsNullOrEmpty(name))
                 {
                     CultureInfo   cl;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs
index 1ed40bfb..8d383308 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs
@@ -557,9 +557,7 @@ private void RemoveItemsByName(XmlDocument xmlProjectDoc, string sItemName)
 
             for (int i = 0; i < root.ChildNodes.Count; i++)
             {
-                XmlElement nodeGroup = root.ChildNodes[i] as XmlElement;
-
-                if (nodeGroup != null && String.Compare(nodeGroup.Name, ITEMGROUP_NAME, StringComparison.OrdinalIgnoreCase) == 0)
+                if (root.ChildNodes[i] is XmlElement nodeGroup && String.Compare(nodeGroup.Name, ITEMGROUP_NAME, StringComparison.OrdinalIgnoreCase) == 0)
                 {
                     //
                     // This is ItemGroup element.
@@ -570,9 +568,8 @@ private void RemoveItemsByName(XmlDocument xmlProjectDoc, string sItemName)
 
                         for (int j = 0; j < nodeGroup.ChildNodes.Count; j++)
                         {
-                            XmlElement nodeItem = nodeGroup.ChildNodes[j] as XmlElement;
 
-                            if (nodeItem != null && String.Compare(nodeItem.Name, sItemName, StringComparison.OrdinalIgnoreCase) == 0)
+                            if (nodeGroup.ChildNodes[j] is XmlElement nodeItem && String.Compare(nodeItem.Name, sItemName, StringComparison.OrdinalIgnoreCase) == 0)
                             {
                                 // This is the item that need to remove.
                                 // Add it into the temporary array list.
@@ -589,13 +586,12 @@ private void RemoveItemsByName(XmlDocument xmlProjectDoc, string sItemName)
                         {
                             foreach (object node in itemToRemove)
                             {
-                                XmlElement item = node as XmlElement;
 
                                 //
                                 // Remove this item from its parent node.
                                 // the parent node should be nodeGroup.
                                 //
-                                if (item != null)
+                                if (node is XmlElement item)
                                 {
                                     nodeGroup.RemoveChild(item);
                                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs
index 8f5e1412..de21c901 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/MarkupCompilePass1.cs
@@ -1312,7 +1312,7 @@ private void GenerateOutputItems( )
             //
             // Generate output items for ApplicationDefinition if it is set in the project file.
             //
-            if (ApplicationFile != null && ApplicationFile.Length > 0)
+            if (!string.IsNullOrEmpty(ApplicationFile))
             {
                 string[] appdefLocalList = null;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/UpdateManifestForBrowserApplication.cs b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/UpdateManifestForBrowserApplication.cs
index c136b200..09430b13 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/UpdateManifestForBrowserApplication.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationBuildTasks/Microsoft/Build/Tasks/Windows/UpdateManifestForBrowserApplication.cs
@@ -96,11 +96,7 @@ public override bool Execute()
                 }
                 finally
                 {
-                    if (manifestReader != null)
-                    {
-                        // Close the manifest reader
-                        manifestReader.Close();
-                    }
+                    manifestReader?.Close();
                 }
 
                 // NOTE:
@@ -130,11 +126,7 @@ public override bool Execute()
                 }
                 finally
                 {
-                    if (manifestWriter != null)
-                    {
-                        // Close the manifest writer
-                        manifestWriter.Close();
-                    }
+                    manifestWriter?.Close();
                 }
 
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/AppModel/CookieHandler.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/AppModel/CookieHandler.cs
index 8f117a38..4c212927 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/AppModel/CookieHandler.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/AppModel/CookieHandler.cs
@@ -33,8 +33,7 @@ static class CookieHandler
 {
     internal static void HandleWebRequest(WebRequest request)
     {
-        HttpWebRequest httpRequest = request as HttpWebRequest;
-        if (httpRequest != null)
+        if (request is HttpWebRequest httpRequest)
         {
             try
             {
@@ -66,8 +65,7 @@ internal static void HandleWebRequest(WebRequest request)
     /// </summary>
     internal static void HandleWebResponse(WebResponse response)
     {
-        HttpWebResponse httpResponse = response as HttpWebResponse;
-        if (httpResponse != null)
+        if (response is HttpWebResponse httpResponse)
         {
             // Not relying on httpResponse.Cookies, because the original cookie header is needed, with all
             // attributes. (A CookieCollection can be stuffed in a CookieContainer, but CookieContainer.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementProxy.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementProxy.cs
index 5a035c14..58cdf717 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementProxy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementProxy.cs
@@ -305,9 +305,9 @@ internal AutomationPeer Peer
         {
             get
             {
-                if (_peer is WeakReference)
+                if (_peer is WeakReference weakReference)
                 {
-                    AutomationPeer peer = (AutomationPeer)((WeakReference)_peer).Target;
+                    AutomationPeer peer = (AutomationPeer)weakReference.Target;
                     return peer;
                 }
                 else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementUtil.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementUtil.cs
index 702508a2..01b0d0cb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementUtil.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/ElementUtil.cs
@@ -181,9 +181,7 @@ internal static Visual GetElementFromPoint( IntPtr hwnd, Visual root, Point poin
         // Ensures that an element is enabled; throws exception otherwise
         internal static void CheckEnabled(Visual visual)
         {
-            UIElement el = visual as UIElement;
-            
-            if( el != null && ! el.IsEnabled )
+            if( visual is UIElement el && ! el.IsEnabled )
             {
                 throw new ElementNotEnabledException();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/EventMap.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/EventMap.cs
index 2dc14212..9fb8d213 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/EventMap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/EventMap.cs
@@ -279,8 +279,8 @@ private static void NotifySources()
         private static object NotifySource(Object args)
         {
             object[] argsArray = (object[])args;
-            PresentationSource source = argsArray[0] as PresentationSource;
-            if (source != null && !source.IsDisposed)
+
+            if (argsArray[0] is PresentationSource source && !source.IsDisposed)
             {
                 // setting the RootVisual to itself triggers the logic to
                 // add to the AutomationEvents list
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/SynchronizedInputAdaptor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/SynchronizedInputAdaptor.cs
index 49b72d93..b9831c08 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/SynchronizedInputAdaptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/SynchronizedInputAdaptor.cs
@@ -49,9 +49,8 @@ void ISynchronizedInputProvider.StartListening(SynchronizedInputType inputType)
             {
                 throw new ArgumentException(SR.Get(SRID.Automation_InvalidSynchronizedInputType, inputType));
             }
-            
-            UIElement e = _owner as UIElement;
-            if (e != null)
+
+            if (_owner is UIElement e)
             {
                 if (!e.StartListeningSynchronizedInput(inputType))
                 {
@@ -60,8 +59,7 @@ void ISynchronizedInputProvider.StartListening(SynchronizedInputType inputType)
             }
             else
             {
-                ContentElement ce = _owner as ContentElement;
-                if (ce != null)
+                if (_owner is ContentElement ce)
                 {
                     if (!ce.StartListeningSynchronizedInput(inputType))
                     {
@@ -84,15 +82,13 @@ void ISynchronizedInputProvider.StartListening(SynchronizedInputType inputType)
         ///</summary>
         void ISynchronizedInputProvider.Cancel()
         {
-            UIElement e = _owner as UIElement;
-            if (e != null)
+            if (_owner is UIElement e)
             {
                 e.CancelSynchronizedInput();
             }
             else
             {
-                ContentElement ce = _owner as ContentElement;
-                if (ce != null)
+                if (_owner is ContentElement ce)
                 {
                     ce.CancelSynchronizedInput();
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/TextRangeProviderWrapper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/TextRangeProviderWrapper.cs
index a53207de..04994c3b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/TextRangeProviderWrapper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Automation/TextRangeProviderWrapper.cs
@@ -208,9 +208,9 @@ static internal ITextRangeProvider WrapArgument(ITextRangeProvider argument, Aut
         // Remove the wrapper from the argument if a wrapper exists
         static internal ITextRangeProvider UnwrapArgument(ITextRangeProvider argument)
         {
-            if (argument is TextRangeProviderWrapper)
+            if (argument is TextRangeProviderWrapper textRangeProviderWrapper)
             {
-                 return ((TextRangeProviderWrapper)argument)._iface;
+                 return textRangeProviderWrapper._iface;
             }
 
             return argument;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DeferredElementTreeState.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DeferredElementTreeState.cs
index b243c332..6d2bde25 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DeferredElementTreeState.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DeferredElementTreeState.cs
@@ -30,22 +30,19 @@ public static DependencyObject GetCoreParent(DependencyObject element, DeferredE
             }
             else
             {
-                Visual v = element as Visual;
-                if(v != null)
+                if(element is Visual v)
                 {
                     parent = VisualTreeHelper.GetParent(v);
                 }
                 else
                 {
-                    ContentElement ce = element as ContentElement;
-                    if(ce != null)
+                    if(element is ContentElement ce)
                     {
                         parent = ContentOperations.GetParent(ce);
                     }
                     else
                     {
-                        Visual3D v3D = element as Visual3D;
-                        if (v3D != null)
+                        if (element is Visual3D v3D)
                         {
                             parent = VisualTreeHelper.GetParent(v3D);
                         }
@@ -91,14 +88,12 @@ public static DependencyObject GetLogicalParent(DependencyObject element, Deferr
             }
             else
             {
-                UIElement e = element as UIElement;
-                if(e != null)
+                if(element is UIElement e)
                 {
                     parent = e.GetUIParentCore();  // Overriden by FrameworkElement.
                 }
 
-                ContentElement ce = element as ContentElement;
-                if(ce != null)
+                if(element is ContentElement ce)
                 {
                     parent = ce.GetUIParentCore(); // Overriden by FrameworkContentElement.
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DpiScale2.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DpiScale2.cs
index 2bb3c47a..a1e0f056 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DpiScale2.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/DpiScale2.cs
@@ -168,13 +168,13 @@ public override bool Equals(object obj)
         {
             bool areEqual = false;
 
-            if (obj is DpiScale)
+            if (obj is DpiScale dpiScale)
             {
-                areEqual = this.Equals((DpiScale)obj);
+                areEqual = this.Equals(dpiScale);
             }
-            else if (obj is DpiScale2)
+            else if (obj is DpiScale2 dpiScale2)
             {
-                areEqual = this.Equals((DpiScale2)obj);
+                areEqual = this.Equals(dpiScale2);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSource.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSource.cs
index 5e252bff..3711f45d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSource.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSource.cs
@@ -202,9 +202,7 @@ public UnmanagedMemoryStream GetUnmanagedStream()
                     }
                 }
 
-                UnmanagedMemoryStream unmanagedStream = fontStream as UnmanagedMemoryStream;
-
-                if (unmanagedStream != null)
+                if (fontStream is UnmanagedMemoryStream unmanagedStream)
                     return unmanagedStream;
 
                 bits = StreamToByteArray(fontStream);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSourceCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSourceCollection.cs
index 65029d6e..0dddca9f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSourceCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontCache/FontSourceCollection.cs
@@ -146,8 +146,7 @@ private void SetFontSources()
 
                                     foreach (string fontValue in fontsKey.GetValueNames())
                                     {
-                                        string fileName = fontsKey.GetValue(fontValue) as string;
-                                        if (fileName != null)
+                                        if (fontsKey.GetValue(fontValue) is string fileName)
                                         {
                                             // See if the path doesn't contain any directory information.
                                             // Shell uses the same method to determine whether to prepend the path with %windir%\fonts.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontFace/MatchingStyle.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontFace/MatchingStyle.cs
index 050fdb6f..fcc89ac7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontFace/MatchingStyle.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/FontFace/MatchingStyle.cs
@@ -252,10 +252,8 @@ public override bool Equals(Object o)
                     return false;
                 }
 
-                if(o is Vector)
+                if(o is Vector vector)
                 {
-                    Vector vector = (Vector)o;
-
                     return (this == vector);
                 }
                 else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ByteRangeDownloader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ByteRangeDownloader.cs
index 381de65d..5e863507 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ByteRangeDownloader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ByteRangeDownloader.cs
@@ -588,10 +588,7 @@ private void ResponseCallback(IAsyncResult ar)
                 }
                 finally
                 {
-                    if (webResponse != null)
-                    {
-                        webResponse.Close();
-                    }
+                    webResponse?.Close();
 
                     // bytes requested are downloaded or errored out
                     //  inform the caller that these ranges are available
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/NetStream.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/NetStream.cs
index 2b6ac500..f8910763 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/NetStream.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/NetStream.cs
@@ -423,10 +423,7 @@ protected override void Dispose(bool disposing)
                             }
 
                             // Free Full Download
-                            if (_responseStream != null)
-                            {
-                                _responseStream.Close();
-                            }
+                            _responseStream?.Close();
 
                             FreeTempFile();
 #if DEBUG
@@ -1188,10 +1185,7 @@ private void ReleaseFullDownloadResources()
                     finally
                     {
                         // FreeFullDownload
-                        if (_responseStream != null)
-                        {
-                            _responseStream.Close();
-                        }
+                        _responseStream?.Close();
                     }
                 }
                 finally
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/PreloadedPackages.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/PreloadedPackages.cs
index 43faa492..c74296f8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/PreloadedPackages.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/PreloadedPackages.cs
@@ -80,8 +80,7 @@ internal static Package GetPackage(Uri uri, out bool threadSafe)
 
                 if (_packagePairs != null)
                 {
-                    PackageThreadSafePair packagePair = _packagePairs[uri] as PackageThreadSafePair;
-                    if (packagePair != null)
+                    if (_packagePairs[uri] is PackageThreadSafePair packagePair)
                     {
                         package = packagePair.Package;
                         threadSafe = packagePair.ThreadSafe;
@@ -142,10 +141,7 @@ internal static void RemovePackage(Uri uri)
 
             lock (_globalLock)
             {
-                if (_packagePairs != null)
-                {
-                    _packagePairs.Remove(uri);
-                }
+                _packagePairs?.Remove(uri);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ResponseStream.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ResponseStream.cs
index 7d9a1754..e64df0ab 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ResponseStream.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/IO/Packaging/ResponseStream.cs
@@ -242,11 +242,7 @@ protected override void Dispose(bool disposing)
                     // close the Part or NetStream
                     _innerStream.Close();
 
-                    if (_owningStream != null)
-                    {
-                        // in this case, the innerStream was the part so this is the NetStream
-                        _owningStream.Close();
-                    }
+                    _owningStream?.Close();
                 }
             }
             finally
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Ink/GestureRecognizer/NativeRecognizer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Ink/GestureRecognizer/NativeRecognizer.cs
index ed28449d..153cbddb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Ink/GestureRecognizer/NativeRecognizer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Ink/GestureRecognizer/NativeRecognizer.cs
@@ -224,9 +224,9 @@ internal static ApplicationGesture[] GetApplicationGestureArrayAndVerify(IEnumer
             }
 
             uint count = 0;
+
             //we need to make a disconnected copy
-            ICollection<ApplicationGesture> collection = applicationGestures as ICollection<ApplicationGesture>;
-            if (collection != null)
+            if (applicationGestures is ICollection<ApplicationGesture> collection)
             {
                 count = (uint)collection.Count;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media/VisualTreeUtils.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media/VisualTreeUtils.cs
index 4c7af80e..a67b95ca 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media/VisualTreeUtils.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media/VisualTreeUtils.cs
@@ -92,10 +92,7 @@ internal static void SetFlagsToRoot(DependencyObject element, bool value, Visual
             {
                 visual.SetFlagsToRoot(value, flags);
             }
-            else if (visual3D != null)
-            {
-                visual3D.SetFlagsToRoot(value, flags);
-            }
+            else visual3D?.SetFlagsToRoot(value, flags);
         }
 
         /// <summary>
@@ -135,17 +132,13 @@ internal static PointHitTestResult AsNearestPointHitTestResult(HitTestResult res
             {
                 return null;
             }
-            
-            PointHitTestResult resultAsPointHitTestResult = result as PointHitTestResult;
 
-            if (resultAsPointHitTestResult != null)
+            if (result is PointHitTestResult resultAsPointHitTestResult)
             {
                 return resultAsPointHitTestResult;
             }
 
-            RayHitTestResult resultAsRayHitTestResult = result as RayHitTestResult;
-
-            if (resultAsRayHitTestResult != null)
+            if (result is RayHitTestResult resultAsRayHitTestResult)
             {
                 Visual3D current = (Visual3D) resultAsRayHitTestResult.VisualHit;
                 Matrix3D worldTransform = Matrix3D.Identity;
@@ -167,9 +160,7 @@ internal static PointHitTestResult AsNearestPointHitTestResult(HitTestResult res
                     current = parent3D;
                 }
 
-                Viewport3DVisual viewport = current.InternalVisualParent as Viewport3DVisual;
-
-                if (viewport != null)
+                if (current.InternalVisualParent is Viewport3DVisual viewport)
                 {
                     Point4D worldPoint = ((Point4D)resultAsRayHitTestResult.PointHit) * worldTransform;
                     Point viewportPoint = viewport.WorldToViewport(worldPoint);
@@ -182,7 +173,7 @@ internal static PointHitTestResult AsNearestPointHitTestResult(HitTestResult res
                 return null;
             }
 
-            Debug.Fail(String.Format("Unhandled HitTestResult type '{0}'", result.GetType().Name));
+            Debug.Fail($"Unhandled HitTestResult type '{result.GetType().Name}'");
 
             return null;
         }
@@ -289,9 +280,7 @@ internal static bool AsVisualInternal(DependencyObject element, out Visual visua
 
             if (!(castSucceeded || element == null))
             {
-                Debug.Fail(String.Format(
-                               "'{0}' is not a Visual or Visual3D. Caller is responsible for guaranteeing that element is a Visual type.",
-                               element != null ? element.GetType() : null));
+                Debug.Fail($"'{(element != null ? element.GetType() : null)}' is not a Visual or Visual3D. Caller is responsible for guaranteeing that element is a Visual type.");
             }
 
             return castSucceeded;
@@ -323,18 +312,14 @@ internal static bool AsVisualInternal(DependencyObject element, out Visual visua
         // Common code for AsVisual and AsVisualInternal -- Don't call this.
         private static bool AsVisualHelper(DependencyObject element, out Visual visual, out Visual3D visual3D)
         {
-            Visual elementAsVisual = element as Visual;
-
-            if (elementAsVisual != null)
+            if (element is Visual elementAsVisual)
             {
                 visual = elementAsVisual;
                 visual3D = null;
                 return true;
             }
 
-            Visual3D elementAsVisual3D = element as Visual3D;
-
-            if (elementAsVisual3D != null)
+            if (element is Visual3D elementAsVisual3D)
             {
                 visual = null;
                 visual3D = elementAsVisual3D;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/GeneralTransform2DTo3DTo2D.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/GeneralTransform2DTo3DTo2D.cs
index 10c78ef9..4f6ed21d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/GeneralTransform2DTo3DTo2D.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/GeneralTransform2DTo3DTo2D.cs
@@ -198,9 +198,7 @@ private bool TryInverseTransform(Point inPoint, out Point result)
                 _geometry.RayHitTest(rayHitTestParameters, FaceType.Front);
                 rayHitTestParameters.RaiseCallback(delegate (HitTestResult rawresult)
                                                    {
-                                                       RayHitTestResult rayResult = rawresult as RayHitTestResult;
-
-                                                       if (rayResult != null)
+                                                       if (rawresult is RayHitTestResult rayResult)
                                                        {
                                                            foundIntersection = Viewport2DVisual3D.GetIntersectionInfo(rayResult, out pointHit);
                                                        }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/M3DUtil.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/M3DUtil.cs
index d46abff4..fc1a3774 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/M3DUtil.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Media3D/M3DUtil.cs
@@ -535,10 +535,7 @@ internal static Matrix3D GetWorldTransformationMatrix(Visual3D visual3DStart, ou
                 
                 Transform3D transform = (Transform3D)visual3D.GetValue(Visual3D.TransformProperty);
 
-                if (transform != null)
-                {
-                    transform.Append(ref worldTransform);
-                }
+                transform?.Append(ref worldTransform);
 
                 dependencyObject = VisualTreeHelper.GetParent(dependencyObject);      
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Resources/ResourceManagerWrapper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Resources/ResourceManagerWrapper.cs
index b461b8b0..d6d83da6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Resources/ResourceManagerWrapper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Resources/ResourceManagerWrapper.cs
@@ -191,9 +191,7 @@ private CultureInfo GetNeutralResourcesLanguage( )
             //
             CultureInfo ciNeutral = CultureInfo.InvariantCulture;
 
-            NeutralResourcesLanguageAttribute neutralLangAttr = Attribute.GetCustomAttribute(_assembly, typeof(NeutralResourcesLanguageAttribute)) as NeutralResourcesLanguageAttribute;
-
-            if (neutralLangAttr != null)
+            if (Attribute.GetCustomAttribute(_assembly, typeof(NeutralResourcesLanguageAttribute)) is NeutralResourcesLanguageAttribute neutralLangAttr)
             {
                 ciNeutral = new CultureInfo(neutralLangAttr.CultureName);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Shaping/CompositeFontFamily.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Shaping/CompositeFontFamily.cs
index dd4312b2..ee77447e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Shaping/CompositeFontFamily.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/Shaping/CompositeFontFamily.cs
@@ -224,7 +224,7 @@ IDeviceFont IFontFamily.GetDeviceFont(FontStyle style, FontWeight weight, FontSt
         {
             FamilyTypeface bestFace = FindExactFamilyTypeface(style, weight, stretch);
 
-            if (bestFace != null && bestFace.DeviceFontName != null)
+            if (bestFace?.DeviceFontName != null)
                 return bestFace;
             else
                 return null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SynchronizedInputHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SynchronizedInputHelper.cs
index 3d020a8e..052058dd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SynchronizedInputHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SynchronizedInputHelper.cs
@@ -19,22 +19,19 @@ internal static class SynchronizedInputHelper
     {
         internal static DependencyObject GetUIParentCore(DependencyObject o)
         {
-            UIElement e = o as UIElement;
-            if (e != null)
+            if (o is UIElement e)
             {
                 return e.GetUIParentCore();
             }
             else
             {
-                ContentElement ce = o as ContentElement;
-                if (ce != null)
+                if (o is ContentElement ce)
                 {
                     return ce.GetUIParentCore();
                 }
                 else
                 {
-                    UIElement3D e3D = o as UIElement3D;
-                    if (e3D != null)
+                    if (o is UIElement3D e3D)
                     {
                         return e3D.GetUIParentCore();
                     }
@@ -135,25 +132,20 @@ internal static void AddParentPreOpportunityHandler(DependencyObject o, EventRou
             DependencyObject logicalParent = SynchronizedInputHelper.GetUIParentCore(o);
             if (logicalParent != null && logicalParent != visualParent)
             {
-                UIElement e = logicalParent as UIElement;
-                if (e != null)
+                if (logicalParent is UIElement e)
                 {
                     e.AddSynchronizedInputPreOpportunityHandler(route, args);
                 }
                 else
                 {
-                    ContentElement ce = logicalParent as ContentElement;
-                    if (ce != null)
+                    if (logicalParent is ContentElement ce)
                     {
                         ce.AddSynchronizedInputPreOpportunityHandler(route, args);
                     }
                     else
                     {
                         UIElement3D e3D = logicalParent as UIElement3D;
-                        if (e3D != null)
-                        {
-                            e3D.AddSynchronizedInputPreOpportunityHandler(route, args);
-                        }
+                        e3D?.AddSynchronizedInputPreOpportunityHandler(route, args);
                     }
                 }
             }
@@ -169,28 +161,24 @@ internal static void AddHandlerToRoute(DependencyObject o, EventRoute route, Rou
         // If this handler is invoked then it indicates the element had the opportunity to handle event.
         internal static void PreOpportunityHandler(object sender, RoutedEventArgs args)
         {
-            KeyboardEventArgs kArgs = args as KeyboardEventArgs;
             // if it's the keyboard event then we have 1:1 mapping between handlers & events,
             // so no remapping required.
-            if (kArgs != null)
+            if (args is KeyboardEventArgs kArgs)
             {
                 InputManager.SynchronizedInputState = SynchronizedInputStates.HadOpportunity;
             }
             else
             {
-                TextCompositionEventArgs tArgs = args as TextCompositionEventArgs;
-                if (tArgs != null)
+                if (args is TextCompositionEventArgs tArgs)
                 {
                     InputManager.SynchronizedInputState = SynchronizedInputStates.HadOpportunity;
                 }
                 else
                 {
-                    // If this is an mouse event then we have handlers only for generic MouseDown & MouseUp events,
-                    // so we need additional logic here to decide between Mouse left and right button events.
-                    MouseButtonEventArgs mbArgs = args as MouseButtonEventArgs;
-                    if (mbArgs != null)
+                    // If this is an mouse event then we have handlers only for generic MouseDown & MouseUp events,                    // so we need additional logic here to decide between Mouse left and right button events.
+                    if (args is MouseButtonEventArgs mbArgs)
                     {
-                        Debug.Assert(mbArgs != null);
+                        Debug.Assert(args is MouseButtonEventArgs mbArgs);
                         switch (mbArgs.ChangedButton)
                         {
                             case MouseButton.Left:
@@ -219,27 +207,24 @@ internal static void PreOpportunityHandler(object sender, RoutedEventArgs args)
         // decide whether the event is handled by this element or some other element.
         internal static void PostOpportunityHandler(object sender, RoutedEventArgs args)
         {
-            KeyboardEventArgs kArgs = args as KeyboardEventArgs;
             // if it's the keyboard event then we have 1:1 mapping between handlers & events,
             // so no remapping required.
-            if (kArgs != null)
+            if (args is KeyboardEventArgs kArgs)
             {
                 InputManager.SynchronizedInputState = SynchronizedInputStates.Handled;
             }
             else
             {
-                TextCompositionEventArgs tArgs = args as TextCompositionEventArgs;
-                if (tArgs != null)
+                if (args is TextCompositionEventArgs tArgs)
                 {
                     InputManager.SynchronizedInputState = SynchronizedInputStates.Handled;
                 }
                 else
                 {
-                    // If this is an mouse event then we have handlers only for generic MouseDown & MouseUp events,
-                    // so we need additional logic here to decide between Mouse left and right button events.
-                    MouseButtonEventArgs mbArgs = args as MouseButtonEventArgs;
-                    Debug.Assert(mbArgs != null);
-                    if (mbArgs != null)
+                    // If this is an mouse event then we have handlers only for generic MouseDown & MouseUp events,                    // so we need additional logic here to decide between Mouse left and right button events.
+                    Debug.Assert(args is MouseButtonEventArgs mbArgs);
+
+                    if (args is MouseButtonEventArgs mbArgs)
                     {
                         switch (mbArgs.ChangedButton)
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SystemDrawingHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SystemDrawingHelper.cs
index 79419dcb..0a636f54 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SystemDrawingHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/SystemDrawingHelper.cs
@@ -96,10 +96,7 @@ internal static Stream GetCommentFromGifStream(Stream stream)
         internal static void SaveMetafileToImageStream(MemoryStream metafileStream, Stream imageStream)
         {
             SystemDrawingExtensionMethods extensions = AssemblyHelper.ExtensionsForSystemDrawing(force:true);
-            if (extensions != null)
-            {
-                extensions.SaveMetafileToImageStream(metafileStream, imageStream);
-            }
+            extensions?.SaveMetafileToImageStream(metafileStream, imageStream);
         }
 
         //returns bitmap snapshot of selected area
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/DrawingState.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/DrawingState.cs
index ea0d62fa..c7d36826 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/DrawingState.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/DrawingState.cs
@@ -107,10 +107,7 @@ internal void UnsetGuidelineY()
         public void Dispose()
         {
             // clear the guideline at line's baseline
-            if (_drawingContext != null)
-            {
-                _drawingContext.Pop();
-            }
+            _drawingContext?.Pop();
         }             
 
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/GenericTextProperties.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/GenericTextProperties.cs
index 35fae8e3..858c8315 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/GenericTextProperties.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/GenericTextProperties.cs
@@ -89,7 +89,7 @@ public override int GetHashCode()
         /// <returns>objects equals</returns>
         public override bool Equals(object o)
         {
-            if ((o == null) || !(o is TextRunProperties))
+            if (!(o is TextRunProperties))
             {
                 return false;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/SimpleTextLine.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/SimpleTextLine.cs
index ece3562a..9d9f2cf5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/SimpleTextLine.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/SimpleTextLine.cs
@@ -598,10 +598,7 @@ Point          origin
             int idealXRelativeToOrigin = _idealOffsetUnRounded;
             double y = origin.Y + Baseline;
 
-            if (drawingContext != null)
-            {
-                drawingContext.PushGuidelineY1(y);
-            }
+            drawingContext?.PushGuidelineY1(y);
 
             Rect boundingBox = Rect.Empty;
 
@@ -623,10 +620,7 @@ Point          origin
             }
             finally
             {
-                if (drawingContext != null)
-                {
-                    drawingContext.Pop();
-                }
+                drawingContext?.Pop();
             }
 
             if(boundingBox.IsEmpty)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/TextRunCacheImp.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/TextRunCacheImp.cs
index ad01bbea..515db62e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/TextRunCacheImp.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/TextFormatting/TextRunCacheImp.cs
@@ -295,10 +295,8 @@ internal TextSpan<CultureSpecificCharacterBufferRange> GetPrecedingText(TextSour
                 {
                     CharacterBufferRange charString = CharacterBufferRange.Empty;                    
                     CultureInfo culture = null;
-                    
-                    TextRun run = textRunSpanRider.CurrentElement as TextRun;
 
-                    if (run != null)
+                    if (textRunSpanRider.CurrentElement is TextRun run)
                     {
                         // Only TextRun containing text would have non-empty Character buffer range.
                         if ( TextRunInfo.GetRunType(run) == Plsrun.Text
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/UIElementHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/UIElementHelper.cs
index 4496a6a0..3943e95a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/UIElementHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/UIElementHelper.cs
@@ -21,8 +21,7 @@ internal static bool IsHitTestVisible(DependencyObject o)
         {
             Debug.Assert(o != null, "UIElementHelper.IsHitTestVisible called with null argument");
 
-            UIElement oAsUIElement = o as UIElement;
-            if (oAsUIElement != null)
+            if (o is UIElement oAsUIElement)
             {
                 return oAsUIElement.IsHitTestVisible;
             }
@@ -37,8 +36,7 @@ internal static bool IsVisible(DependencyObject o)
         {
             Debug.Assert(o != null, "UIElementHelper.IsVisible called with null argument");
 
-            UIElement oAsUIElement = o as UIElement;
-            if (oAsUIElement != null)
+            if (o is UIElement oAsUIElement)
             {
                 return oAsUIElement.IsVisible;
             }
@@ -105,9 +103,9 @@ internal static DependencyObject GetUIParent(DependencyObject child, bool contin
             DependencyObject myParent = null;
 
             // Try to find a UIElement parent in the visual ancestry.
-            if (child is Visual)
+            if (child is Visual visual)
             {
-                myParent = ((Visual)child).InternalVisualParent;
+                myParent = visual.InternalVisualParent;
             }
             else
             {
@@ -120,15 +118,13 @@ internal static DependencyObject GetUIParent(DependencyObject child, bool contin
             // check along the logical branch.
             if(parent == null && continuePastVisualTree)
             {
-                UIElement childAsUIElement = child as UIElement;
-                if (childAsUIElement != null)
+                if (child is UIElement childAsUIElement)
                 {
                     parent = InputElement.GetContainingInputElement(childAsUIElement.GetUIParentCore()) as DependencyObject;
                 }
                 else
                 {
-                    UIElement3D childAsUIElement3D = child as UIElement3D;
-                    if (childAsUIElement3D != null)
+                    if (child is UIElement3D childAsUIElement3D)
                     {
                         parent = InputElement.GetContainingInputElement(childAsUIElement3D.GetUIParentCore()) as DependencyObject;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/WpfWebRequestHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/WpfWebRequestHelper.cs
index 48f12444..359e92d0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/WpfWebRequestHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/MS/internal/WpfWebRequestHelper.cs
@@ -86,9 +86,8 @@ internal static WebRequest CreateRequest(Uri uri)
             throw new WebException(requestUri.ToString(), WebExceptionStatus.RequestCanceled);
             //throw new IOException(SR.Get(SRID.GetResponseFailed, requestUri.ToString()));
         }
-        
-        HttpWebRequest httpRequest = request as HttpWebRequest;
-        if (httpRequest != null)
+
+        if (request is HttpWebRequest httpRequest)
         {
             if (string.IsNullOrEmpty(httpRequest.UserAgent))
             {
@@ -121,8 +120,7 @@ internal static WebRequest CreateRequest(Uri uri)
     [FriendAccessAllowed]
     static internal void ConfigCachePolicy(WebRequest request, bool isRefresh)
     {
-        HttpWebRequest httpRequest = request as HttpWebRequest;
-        if (httpRequest != null)
+        if (request is HttpWebRequest httpRequest)
         {
             // Setting CachePolicy to the default level if it is null.
             if (request.CachePolicy == null || request.CachePolicy.Level != RequestCacheLevel.Default)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebRequest.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebRequest.cs
index e9b532a9..c9963a44 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebRequest.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebRequest.cs
@@ -495,8 +495,7 @@ private WebRequest GetRequest(bool allowPseudoRequest)
                         _webRequest = WpfWebRequestHelper.CreateRequest(_innerUri);
 
                         // special optimization for ftp - Passive mode won't return lengths on ISA servers
-                        FtpWebRequest ftpWebRequest = _webRequest as FtpWebRequest;
-                        if (ftpWebRequest != null)
+                        if (_webRequest is FtpWebRequest ftpWebRequest)
                         {
                             ftpWebRequest.UsePassive = false;  // default but allow override
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebResponse.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebResponse.cs
index 9cea47ee..c8038d2f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebResponse.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackWebResponse.cs
@@ -546,10 +546,7 @@ protected override void Dispose(bool disposing)
                             _responseAvailable.Close();     // this call can not throw an exception
 
                             // timer
-                            if (_timeoutTimer != null)
-                            {
-                                _timeoutTimer.Dispose();
-                            }
+                            _timeoutTimer?.Dispose();
 }
                         finally
                         {
@@ -919,10 +916,7 @@ private void TimeoutCallback(Object stateInfo)
                     }
 #endif
                     // clean up
-                    if (_timeoutTimer != null)
-                    {
-                        _timeoutTimer.Dispose();
-                    }
+                    _timeoutTimer?.Dispose();
                 }
                 finally
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackageStore.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackageStore.cs
index 0fd55d2f..92efb23f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackageStore.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/IO/Packaging/PackageStore.cs
@@ -136,11 +136,7 @@ public static void RemovePackage(Uri uri)
 
             lock (_globalLock)
             {
-                if (_packages != null)
-                {
-                    // If the key doesn't exist, it is no op
-                    _packages.Remove(uri);
-                }
+                _packages?.Remove(uri);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/AutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/AutomationPeer.cs
index d849acd5..e26bd128 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/AutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/AutomationPeer.cs
@@ -394,22 +394,19 @@ internal static AutomationPeer AutomationPeerFromInputElement(IInputElement focu
         {
             AutomationPeer peer = null;
 
-            UIElement uie = focusedElement as UIElement;
-            if (uie != null)
+            if (focusedElement is UIElement uie)
             {
                 peer = UIElementAutomationPeer.CreatePeerForElement(uie);
             }
             else
             {
-                ContentElement ce = focusedElement as ContentElement;
-                if (ce != null)
+                if (focusedElement is ContentElement ce)
                 {
                     peer = ContentElementAutomationPeer.CreatePeerForElement(ce);
                 }
                 else
                 {
-                    UIElement3D uie3D = focusedElement as UIElement3D;
-                    if (uie3D != null)
+                    if (focusedElement is UIElement3D uie3D)
                     {
                         peer = UIElement3DAutomationPeer.CreatePeerForElement(uie3D);
                     }
@@ -1722,8 +1719,7 @@ public AutomationPeer EventsSource
         ///</Summary>
         protected AutomationPeer PeerFromProvider(IRawElementProviderSimple provider)
         {
-            ElementProxy proxy = provider as ElementProxy;
-            if (proxy != null)
+            if (provider is ElementProxy proxy)
             {
                 return (proxy.Peer);
             }
@@ -1999,10 +1995,7 @@ internal void InvalidateAncestorsRecursive()
             if (!AncestorsInvalid)
             {
                 AncestorsInvalid = true;
-                if (EventsSource != null)
-                {
-                    EventsSource.InvalidateAncestorsRecursive();
-                }
+                EventsSource?.InvalidateAncestorsRecursive();
 
                 if (_parent != null)
                     _parent.InvalidateAncestorsRecursive();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElement3DAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElement3DAutomationPeer.cs
index 7e07bdad..63b2de29 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElement3DAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElement3DAutomationPeer.cs
@@ -107,14 +107,12 @@ private static bool iterate(DependencyObject parent, IteratorCallback callback)
                 {
                     DependencyObject child = VisualTreeHelper.GetChild(parent, i);
                     
-                    if(     child != null
-                        &&  child is UIElement 
+                    if(     child is UIElement 
                         &&  (peer = UIElementAutomationPeer.CreatePeerForElement((UIElement)child)) != null  )
                     {
                         done = callback(peer);
                     }
-                    else if ( child != null
-                        &&    child is UIElement3D
+                    else if ( child is UIElement3D
                         &&    (peer = CreatePeerForElement(((UIElement3D)child))) != null )
                     {
                         done = callback(peer);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElementAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElementAutomationPeer.cs
index 211a7450..362529df 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElementAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Automation/Peers/UIElementAutomationPeer.cs
@@ -126,14 +126,12 @@ private static bool iterate(DependencyObject parent, IteratorCallback callback)
                 {
                     DependencyObject child = VisualTreeHelper.GetChild(parent, i);
                     
-                    if(     child != null
-                        &&  child is UIElement 
+                    if(     child is UIElement 
                         &&  (peer = CreatePeerForElement((UIElement)child)) != null  )
                     {
                         done = callback(peer);
                     }
-                    else if ( child != null
-                        &&    child is UIElement3D
+                    else if ( child is UIElement3D
                         &&    (peer = UIElement3DAutomationPeer.CreatePeerForElement(((UIElement3D)child))) != null )
                     {
                         done = callback(peer);
@@ -288,8 +286,7 @@ internal static Rect CalculateVisibleBoundingRect(UIElement owner)
                    !DoubleUtil.AreClose(boundingRect.Height, 0) && 
                    !DoubleUtil.AreClose(boundingRect.Width, 0))
             {
-                Visual visualParent = parent as Visual;
-                if (visualParent != null)
+                if (parent is Visual visualParent)
                 {
                     Geometry clipGeometry = VisualTreeHelper.GetClip(visualParent);
                     if (clipGeometry != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/CultureInfoConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/CultureInfoConverter.cs
index c2153c91..5d612316 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/CultureInfoConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/CultureInfoConverter.cs
@@ -89,8 +89,7 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                                            CultureInfo cultureInfo, 
                                            object source)
         {
-            string cultureName = source as string;
-            if (cultureName != null)
+            if (source is string cultureName)
             {
                 return CultureInfo.GetCultureInfoByIetfLanguageTag(cultureName);
             }
@@ -125,8 +124,7 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                 throw new ArgumentNullException("destinationType");
             }
 
-            CultureInfo culture = value as CultureInfo;
-            if (culture != null)
+            if (value is CultureInfo culture)
             {
                 if (destinationType == typeof(string))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Diagnostics/VisualDiagnostics.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Diagnostics/VisualDiagnostics.cs
index 582610a7..e9dd5347 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Diagnostics/VisualDiagnostics.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Diagnostics/VisualDiagnostics.cs
@@ -163,15 +163,14 @@ internal static void OnVisualChildChanged(DependencyObject parent, DependencyObj
         private static int GetChildIndex(DependencyObject parent, DependencyObject child)
         {
             int index = -1;
-            Visual asVisual = child as Visual;
-            if (asVisual != null)
+
+            if (child is Visual asVisual)
             {
                 index = asVisual._parentIndex;
             }
             else
             {
-                Visual3D asVisual3D = child as Visual3D;
-                if (asVisual3D != null)
+                if (child is Visual3D asVisual3D)
                 {
                     index = asVisual3D.ParentIndex;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DragDrop.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DragDrop.cs
index 302ef317..8e8d0ff5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DragDrop.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DragDrop.cs
@@ -391,17 +391,17 @@ public static DragDropEffects DoDragDrop(DependencyObject dragSource, object dat
             RoutedEventArgs args = new RoutedEventArgs(DragDropStartedEvent, dragSource);
             
             // Raise the DragDropStarted internal event(Bubble).
-            if (dragSource is UIElement)
+            if (dragSource is UIElement uIElement)
             {
-                ((UIElement)dragSource).RaiseEvent(args);
+                uIElement.RaiseEvent(args);
             }
-            else if (dragSource is ContentElement)
+            else if (dragSource is ContentElement contentElement)
             {
-                ((ContentElement)dragSource).RaiseEvent(args);
+                contentElement.RaiseEvent(args);
             }
-            else if (dragSource is UIElement3D)
+            else if (dragSource is UIElement3D uIElement3D)
             {
-                ((UIElement3D)dragSource).RaiseEvent(args);
+                uIElement3D.RaiseEvent(args);
             }
             else
             {
@@ -422,17 +422,17 @@ public static DragDropEffects DoDragDrop(DependencyObject dragSource, object dat
             args = new RoutedEventArgs(DragDropCompletedEvent, dragSource);
             
             // Raise the DragDropCompleted internal event(Bubble).
-            if (dragSource is UIElement)
+            if (dragSource is UIElement uIElement)
             {
-                ((UIElement)dragSource).RaiseEvent(args);
+                uIElement.RaiseEvent(args);
             }
-            else if (dragSource is ContentElement)
+            else if (dragSource is ContentElement contentElement)
             {
-                ((ContentElement)dragSource).RaiseEvent(args);
+                contentElement.RaiseEvent(args);
             }
-            else if (dragSource is UIElement3D)
+            else if (dragSource is UIElement3D uIElement3D)
             {
-                ((UIElement3D)dragSource).RaiseEvent(args);
+                uIElement3D.RaiseEvent(args);
             }
             else
             {
@@ -707,17 +707,17 @@ private void RaiseQueryContinueDragEvent(QueryContinueDragEventArgs args)
             args.RoutedEvent=DragDrop.PreviewQueryContinueDragEvent;
 
             // Raise the preview QueryContinueDrag event(Tunnel).
-            if (_dragSource is UIElement)
+            if (_dragSource is UIElement uIElement)
             {
-                ((UIElement)_dragSource).RaiseEvent(args);
+                uIElement.RaiseEvent(args);
             }
-            else if (_dragSource is ContentElement)
+            else if (_dragSource is ContentElement contentElement)
             {
-                ((ContentElement)_dragSource).RaiseEvent(args);
+                contentElement.RaiseEvent(args);
             }
-            else if (_dragSource is UIElement3D)
+            else if (_dragSource is UIElement3D uIElement3D)
             {
-                ((UIElement3D)_dragSource).RaiseEvent(args);
+                uIElement3D.RaiseEvent(args);
             }
             else
             {
@@ -730,17 +730,17 @@ private void RaiseQueryContinueDragEvent(QueryContinueDragEventArgs args)
             // Raise QueryContinueDrag event(Bubble).
             if (!args.Handled)
             {
-                if (_dragSource is UIElement)
+                if (_dragSource is UIElement uIElement)
                 {
-                    ((UIElement)_dragSource).RaiseEvent(args);
+                    uIElement.RaiseEvent(args);
                 }
-                else if (_dragSource is ContentElement)
+                else if (_dragSource is ContentElement contentElement)
                 {
-                    ((ContentElement)_dragSource).RaiseEvent(args);
+                    contentElement.RaiseEvent(args);
                 }
-                else if (_dragSource is UIElement3D)
+                else if (_dragSource is UIElement3D uIElement3D)
                 {
-                    ((UIElement3D)_dragSource).RaiseEvent(args);
+                    uIElement3D.RaiseEvent(args);
                 }
                 else
                 {
@@ -764,17 +764,17 @@ private void RaiseGiveFeedbackEvent(GiveFeedbackEventArgs args)
             args.RoutedEvent=DragDrop.PreviewGiveFeedbackEvent;
 
             // Raise the preview GiveFeedback(Tunnel).
-            if (_dragSource is UIElement)
+            if (_dragSource is UIElement uIElement)
             {
-                ((UIElement)_dragSource).RaiseEvent(args);
+                uIElement.RaiseEvent(args);
             }
-            else if (_dragSource is ContentElement)
+            else if (_dragSource is ContentElement contentElement)
             {
-                ((ContentElement)_dragSource).RaiseEvent(args);
+                contentElement.RaiseEvent(args);
             }
-            else if (_dragSource is UIElement3D)
+            else if (_dragSource is UIElement3D uIElement3D)
             {
-                ((UIElement3D)_dragSource).RaiseEvent(args);
+                uIElement3D.RaiseEvent(args);
             }
             else
             {
@@ -787,17 +787,17 @@ private void RaiseGiveFeedbackEvent(GiveFeedbackEventArgs args)
             if (!args.Handled)
             {
                 // Raise GiveFeedback event(Bubble).
-                if (_dragSource is UIElement)
+                if (_dragSource is UIElement uIElement)
                 {
-                    ((UIElement)_dragSource).RaiseEvent(args);
+                    uIElement.RaiseEvent(args);
                 }
-                else if (_dragSource is ContentElement)
+                else if (_dragSource is ContentElement contentElement)
                 {
-                    ((ContentElement)_dragSource).RaiseEvent(args);
+                    contentElement.RaiseEvent(args);
                 }
-                else if (_dragSource is UIElement3D)
+                else if (_dragSource is UIElement3D uIElement3D)
                 {
-                    ((UIElement3D)_dragSource).RaiseEvent(args);
+                    uIElement3D.RaiseEvent(args);
                 }
                 else
                 {
@@ -1166,17 +1166,17 @@ private void RaiseDragEvent(RoutedEvent dragEvent, int dragDropKeyStates, ref in
             }
 
             // Raise the preview drop target events(Tunnel).
-            if (target is UIElement)
+            if (target is UIElement uIElement)
             {
-                ((UIElement)target).RaiseEvent(dragEventArgs);
+                uIElement.RaiseEvent(dragEventArgs);
             }
-            else if (target is ContentElement)
+            else if (target is ContentElement contentElement)
             {
-                ((ContentElement)target).RaiseEvent(dragEventArgs);
+                contentElement.RaiseEvent(dragEventArgs);
             }
-            else if (target is UIElement3D)
+            else if (target is UIElement3D uIElement3D)
             {
-                ((UIElement3D)target).RaiseEvent(dragEventArgs);
+                uIElement3D.RaiseEvent(dragEventArgs);
             }
             else
             {
@@ -1190,17 +1190,17 @@ private void RaiseDragEvent(RoutedEvent dragEvent, int dragDropKeyStates, ref in
                 dragEventArgs.RoutedEvent = dragEvent;
 
                 // Raise the drop target events(Bubble).
-                if (target is UIElement)
+                if (target is UIElement uIElement)
                 {
-                    ((UIElement)target).RaiseEvent(dragEventArgs);
+                    uIElement.RaiseEvent(dragEventArgs);
                 }
-                else if (target is ContentElement)
+                else if (target is ContentElement contentElement)
                 {
-                    ((ContentElement)target).RaiseEvent(dragEventArgs);
+                    contentElement.RaiseEvent(dragEventArgs);
                 }
-                else if (target is UIElement3D)
+                else if (target is UIElement3D uIElement3D)
                 {
-                    ((UIElement3D)target).RaiseEvent(dragEventArgs);
+                    uIElement3D.RaiseEvent(dragEventArgs);
                 }
                 else
                 {
@@ -1395,9 +1395,9 @@ private IDataObject GetDataObject(object data)
             // We see if data is available on the data object.
             if (data != null)
             {
-                if (data is DataObject)
+                if (data is DataObject dataObject)
                 {
-                    dataObject = (DataObject)data;
+                    dataObject = dataObject;
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Duration.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Duration.cs
index 0af60acb..fa24a69c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Duration.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Duration.cs
@@ -434,9 +434,9 @@ public override bool Equals(Object value)
             {
                 return false;
             }
-            else if (value is Duration)
+            else if (value is Duration duration)
             {
-                return Equals((Duration)value);
+                return Equals(duration);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DurationConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DurationConverter.cs
index 64dadf22..017e8565 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DurationConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/DurationConverter.cs
@@ -64,10 +64,8 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             CultureInfo cultureInfo, 
             object value)
         {
-            string stringValue = value as string;
-
             // Override the converter for sentinel values
-            if (stringValue != null)
+            if (value is string stringValue)
             {
                 stringValue = stringValue.Trim();
                 if (stringValue == "Automatic")
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventHandlersStore.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventHandlersStore.cs
index 95692165..d8eaf2c5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventHandlersStore.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventHandlersStore.cs
@@ -270,8 +270,7 @@ public bool Contains(RoutedEvent routedEvent)
         
         private static void OnEventHandlersIterationCallback(ArrayList list, int key, object value)
         {
-            RoutedEvent routedEvent = GlobalEventManager.EventFromGlobalIndex(key) as RoutedEvent;
-            if (routedEvent != null && ((FrugalObjectList<RoutedEventHandlerInfo>)value).Count > 0)
+            if (GlobalEventManager.EventFromGlobalIndex(key) is RoutedEvent routedEvent && ((FrugalObjectList<RoutedEventHandlerInfo>)value).Count > 0)
             {
                 list.Add(routedEvent);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventRoute.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventRoute.cs
index 7120dac9..e9bb1de4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventRoute.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/EventRoute.cs
@@ -540,10 +540,7 @@ internal void Clear()
             
             _routeItemList.Clear();
 
-            if (_branchNodeStack != null)
-            {
-                _branchNodeStack.Clear();
-            }
+            _branchNodeStack?.Clear();
 
             _sourceItemList.Clear();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FocusWithinProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FocusWithinProperty.cs
index 1cc0328c..98b8ec35 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FocusWithinProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FocusWithinProperty.cs
@@ -39,10 +39,7 @@ internal override void FireNotifications(UIElement uie, ContentElement ce, UIEle
             {
                 ce.RaiseIsKeyboardFocusWithinChanged(args);
             }
-            else if (uie3D != null)
-            {
-                uie3D.RaiseIsKeyboardFocusWithinChanged(args);
-            }
+            else uie3D?.RaiseIsKeyboardFocusWithinChanged(args);
         }
     }
 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FreezableCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FreezableCollection.cs
index 6f00961b..d9104eea 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FreezableCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/FreezableCollection.cs
@@ -694,16 +694,12 @@ private T Cast(object value)
         // extract it return -1.
         private int GetCount(IEnumerable<T> enumerable)
         {
-            ICollection collectionAsICollection = enumerable as ICollection;
-
-            if (collectionAsICollection != null)
+            if (enumerable is ICollection collectionAsICollection)
             {
                 return collectionAsICollection.Count;
             }
 
-            ICollection<T> enumerableAsICollectionT = enumerable as ICollection<T>;
-
-            if (enumerableAsICollectionT != null)
+            if (enumerable is ICollection<T> enumerableAsICollectionT)
             {
                 return enumerableAsICollectionT.Count;
             }
@@ -845,9 +841,7 @@ enum CloneCommonType
             {
                 T newValue = source._collection[i];
 
-                Freezable itemAsFreezable = newValue as Freezable;
-
-                if (itemAsFreezable != null)
+                if (newValue is Freezable itemAsFreezable)
                 {
                     switch (cloneType)
                     {
@@ -936,9 +930,8 @@ protected override bool FreezeCore(bool isChecking)
             for (int i = 0; i < count && canFreeze; i++)
             {
                 T item = _collection[i];
-                Freezable itemAsFreezable = item as Freezable;
 
-                if (itemAsFreezable != null)
+                if (item is Freezable itemAsFreezable)
                 {
                     canFreeze &= Freezable.Freeze(itemAsFreezable, isChecking);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/ContentElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/ContentElement.cs
index d0116fd1..7592a528 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/ContentElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/ContentElement.cs
@@ -234,10 +234,7 @@ public object GetAnimationBaseValue(DependencyProperty dp)
             {
                 AnimationStorage storage = AnimationStorage.GetStorage(this, dp);
 
-                if (storage != null)
-                {
-                    storage.EvaluateAnimatedValue(metadata, ref entry);                      
-                }
+                storage?.EvaluateAnimatedValue(metadata, ref entry);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/UIElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/UIElement.cs
index dffc1af6..8a47e8ac 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/UIElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Generated/UIElement.cs
@@ -234,10 +234,7 @@ public object GetAnimationBaseValue(DependencyProperty dp)
             {
                 AnimationStorage storage = AnimationStorage.GetStorage(this, dp);
 
-                if (storage != null)
-                {
-                    storage.EvaluateAnimatedValue(metadata, ref entry);                      
-                }
+                storage?.EvaluateAnimatedValue(metadata, ref entry);
             }
         }
 
@@ -863,17 +860,14 @@ private static void OnPreviewMouseDownThunk(object sender, MouseButtonEventArgs
         {
             if(!e.Handled)
             {
-                UIElement uie = sender as UIElement;
-
-                if (uie != null)
+                if (sender is UIElement uie)
                 {
                     uie.OnPreviewMouseDown(e);
                 }
                 else
                 {
-                    ContentElement ce = sender as ContentElement;
 
-                    if (ce != null)
+                    if (sender is ContentElement ce)
                     {
                         ce.OnPreviewMouseDown(e);
                     }
@@ -897,17 +891,14 @@ private static void OnMouseDownThunk(object sender, MouseButtonEventArgs e)
 
             if(!e.Handled)
             {
-                UIElement uie = sender as UIElement;
-
-                if (uie != null)
+                if (sender is UIElement uie)
                 {
                     uie.OnMouseDown(e);
                 }
                 else
                 {
-                    ContentElement ce = sender as ContentElement;
 
-                    if (ce != null)
+                    if (sender is ContentElement ce)
                     {
                         ce.OnMouseDown(e);
                     }
@@ -926,17 +917,14 @@ private static void OnPreviewMouseUpThunk(object sender, MouseButtonEventArgs e)
         {
             if(!e.Handled)
             {
-                UIElement uie = sender as UIElement;
-
-                if (uie != null)
+                if (sender is UIElement uie)
                 {
                     uie.OnPreviewMouseUp(e);
                 }
                 else
                 {
-                    ContentElement ce = sender as ContentElement;
 
-                    if (ce != null)
+                    if (sender is ContentElement ce)
                     {
                         ce.OnPreviewMouseUp(e);
                     }
@@ -955,17 +943,14 @@ private static void OnMouseUpThunk(object sender, MouseButtonEventArgs e)
         {
             if(!e.Handled)
             {
-                UIElement uie = sender as UIElement;
-
-                if (uie != null)
+                if (sender is UIElement uie)
                 {
                     uie.OnMouseUp(e);
                 }
                 else
                 {
-                    ContentElement ce = sender as ContentElement;
 
-                    if (ce != null)
+                    if (sender is ContentElement ce)
                     {
                         ce.OnMouseUp(e);
                     }
@@ -984,17 +969,13 @@ private static void OnPreviewMouseLeftButtonDownThunk(object sender, MouseButton
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewMouseLeftButtonDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewMouseLeftButtonDown(e);
                 }
@@ -1009,17 +990,13 @@ private static void OnMouseLeftButtonDownThunk(object sender, MouseButtonEventAr
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseLeftButtonDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseLeftButtonDown(e);
                 }
@@ -1034,17 +1011,13 @@ private static void OnPreviewMouseLeftButtonUpThunk(object sender, MouseButtonEv
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewMouseLeftButtonUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewMouseLeftButtonUp(e);
                 }
@@ -1059,17 +1032,13 @@ private static void OnMouseLeftButtonUpThunk(object sender, MouseButtonEventArgs
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseLeftButtonUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseLeftButtonUp(e);
                 }
@@ -1084,17 +1053,13 @@ private static void OnPreviewMouseRightButtonDownThunk(object sender, MouseButto
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewMouseRightButtonDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewMouseRightButtonDown(e);
                 }
@@ -1109,17 +1074,13 @@ private static void OnMouseRightButtonDownThunk(object sender, MouseButtonEventA
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseRightButtonDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseRightButtonDown(e);
                 }
@@ -1134,17 +1095,13 @@ private static void OnPreviewMouseRightButtonUpThunk(object sender, MouseButtonE
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewMouseRightButtonUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewMouseRightButtonUp(e);
                 }
@@ -1159,17 +1116,13 @@ private static void OnMouseRightButtonUpThunk(object sender, MouseButtonEventArg
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseRightButtonUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseRightButtonUp(e);
                 }
@@ -1184,17 +1137,13 @@ private static void OnPreviewMouseMoveThunk(object sender, MouseEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewMouseMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewMouseMove(e);
                 }
@@ -1209,17 +1158,13 @@ private static void OnMouseMoveThunk(object sender, MouseEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseMove(e);
                 }
@@ -1234,17 +1179,13 @@ private static void OnPreviewMouseWheelThunk(object sender, MouseWheelEventArgs
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewMouseWheel(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewMouseWheel(e);
                 }
@@ -1263,17 +1204,14 @@ private static void OnMouseWheelThunk(object sender, MouseWheelEventArgs e)
 
             if(!e.Handled)
             {
-                UIElement uie = sender as UIElement;
-
-                if (uie != null)
+                if (sender is UIElement uie)
                 {
                     uie.OnMouseWheel(e);
                 }
                 else
                 {
-                    ContentElement ce = sender as ContentElement;
 
-                    if (ce != null)
+                    if (sender is ContentElement ce)
                     {
                         ce.OnMouseWheel(e);
                     }
@@ -1289,17 +1227,13 @@ private static void OnMouseEnterThunk(object sender, MouseEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseEnter(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseEnter(e);
                 }
@@ -1314,17 +1248,13 @@ private static void OnMouseLeaveThunk(object sender, MouseEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnMouseLeave(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnMouseLeave(e);
                 }
@@ -1339,17 +1269,13 @@ private static void OnGotMouseCaptureThunk(object sender, MouseEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnGotMouseCapture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnGotMouseCapture(e);
                 }
@@ -1364,17 +1290,13 @@ private static void OnLostMouseCaptureThunk(object sender, MouseEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnLostMouseCapture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnLostMouseCapture(e);
                 }
@@ -1389,17 +1311,13 @@ private static void OnQueryCursorThunk(object sender, QueryCursorEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnQueryCursor(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnQueryCursor(e);
                 }
@@ -1414,17 +1332,13 @@ private static void OnPreviewStylusDownThunk(object sender, StylusDownEventArgs
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusDown(e);
                 }
@@ -1439,17 +1353,13 @@ private static void OnStylusDownThunk(object sender, StylusDownEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusDown(e);
                 }
@@ -1464,17 +1374,13 @@ private static void OnPreviewStylusUpThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusUp(e);
                 }
@@ -1489,17 +1395,13 @@ private static void OnStylusUpThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusUp(e);
                 }
@@ -1514,17 +1416,13 @@ private static void OnPreviewStylusMoveThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusMove(e);
                 }
@@ -1539,17 +1437,13 @@ private static void OnStylusMoveThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusMove(e);
                 }
@@ -1564,17 +1458,13 @@ private static void OnPreviewStylusInAirMoveThunk(object sender, StylusEventArgs
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusInAirMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusInAirMove(e);
                 }
@@ -1589,17 +1479,13 @@ private static void OnStylusInAirMoveThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusInAirMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusInAirMove(e);
                 }
@@ -1614,17 +1500,13 @@ private static void OnStylusEnterThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusEnter(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusEnter(e);
                 }
@@ -1639,17 +1521,13 @@ private static void OnStylusLeaveThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusLeave(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusLeave(e);
                 }
@@ -1664,17 +1542,13 @@ private static void OnPreviewStylusInRangeThunk(object sender, StylusEventArgs e
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusInRange(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusInRange(e);
                 }
@@ -1689,17 +1563,13 @@ private static void OnStylusInRangeThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusInRange(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusInRange(e);
                 }
@@ -1714,17 +1584,13 @@ private static void OnPreviewStylusOutOfRangeThunk(object sender, StylusEventArg
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusOutOfRange(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusOutOfRange(e);
                 }
@@ -1739,17 +1605,13 @@ private static void OnStylusOutOfRangeThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusOutOfRange(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusOutOfRange(e);
                 }
@@ -1764,17 +1626,13 @@ private static void OnPreviewStylusSystemGestureThunk(object sender, StylusSyste
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusSystemGesture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusSystemGesture(e);
                 }
@@ -1789,17 +1647,13 @@ private static void OnStylusSystemGestureThunk(object sender, StylusSystemGestur
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusSystemGesture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusSystemGesture(e);
                 }
@@ -1814,17 +1668,13 @@ private static void OnGotStylusCaptureThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnGotStylusCapture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnGotStylusCapture(e);
                 }
@@ -1839,17 +1689,13 @@ private static void OnLostStylusCaptureThunk(object sender, StylusEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnLostStylusCapture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnLostStylusCapture(e);
                 }
@@ -1864,17 +1710,13 @@ private static void OnStylusButtonDownThunk(object sender, StylusButtonEventArgs
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusButtonDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusButtonDown(e);
                 }
@@ -1889,17 +1731,13 @@ private static void OnStylusButtonUpThunk(object sender, StylusButtonEventArgs e
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnStylusButtonUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnStylusButtonUp(e);
                 }
@@ -1914,17 +1752,13 @@ private static void OnPreviewStylusButtonDownThunk(object sender, StylusButtonEv
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusButtonDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusButtonDown(e);
                 }
@@ -1939,17 +1773,13 @@ private static void OnPreviewStylusButtonUpThunk(object sender, StylusButtonEven
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewStylusButtonUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewStylusButtonUp(e);
                 }
@@ -1964,17 +1794,13 @@ private static void OnPreviewKeyDownThunk(object sender, KeyEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewKeyDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewKeyDown(e);
                 }
@@ -1993,17 +1819,14 @@ private static void OnKeyDownThunk(object sender, KeyEventArgs e)
 
             if(!e.Handled)
             {
-                UIElement uie = sender as UIElement;
-
-                if (uie != null)
+                if (sender is UIElement uie)
                 {
                     uie.OnKeyDown(e);
                 }
                 else
                 {
-                    ContentElement ce = sender as ContentElement;
 
-                    if (ce != null)
+                    if (sender is ContentElement ce)
                     {
                         ce.OnKeyDown(e);
                     }
@@ -2019,17 +1842,13 @@ private static void OnPreviewKeyUpThunk(object sender, KeyEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewKeyUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewKeyUp(e);
                 }
@@ -2044,17 +1863,13 @@ private static void OnKeyUpThunk(object sender, KeyEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnKeyUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnKeyUp(e);
                 }
@@ -2069,17 +1884,13 @@ private static void OnPreviewGotKeyboardFocusThunk(object sender, KeyboardFocusC
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewGotKeyboardFocus(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewGotKeyboardFocus(e);
                 }
@@ -2094,17 +1905,13 @@ private static void OnGotKeyboardFocusThunk(object sender, KeyboardFocusChangedE
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnGotKeyboardFocus(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnGotKeyboardFocus(e);
                 }
@@ -2119,17 +1926,13 @@ private static void OnPreviewLostKeyboardFocusThunk(object sender, KeyboardFocus
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewLostKeyboardFocus(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewLostKeyboardFocus(e);
                 }
@@ -2144,17 +1947,13 @@ private static void OnLostKeyboardFocusThunk(object sender, KeyboardFocusChanged
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnLostKeyboardFocus(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnLostKeyboardFocus(e);
                 }
@@ -2169,17 +1968,13 @@ private static void OnPreviewTextInputThunk(object sender, TextCompositionEventA
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewTextInput(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewTextInput(e);
                 }
@@ -2194,17 +1989,13 @@ private static void OnTextInputThunk(object sender, TextCompositionEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnTextInput(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnTextInput(e);
                 }
@@ -2259,17 +2050,13 @@ private static void OnPreviewQueryContinueDragThunk(object sender, QueryContinue
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewQueryContinueDrag(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewQueryContinueDrag(e);
                 }
@@ -2284,17 +2071,13 @@ private static void OnQueryContinueDragThunk(object sender, QueryContinueDragEve
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnQueryContinueDrag(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnQueryContinueDrag(e);
                 }
@@ -2309,17 +2092,13 @@ private static void OnPreviewGiveFeedbackThunk(object sender, GiveFeedbackEventA
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewGiveFeedback(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewGiveFeedback(e);
                 }
@@ -2334,17 +2113,13 @@ private static void OnGiveFeedbackThunk(object sender, GiveFeedbackEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnGiveFeedback(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnGiveFeedback(e);
                 }
@@ -2359,17 +2134,13 @@ private static void OnPreviewDragEnterThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewDragEnter(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewDragEnter(e);
                 }
@@ -2384,17 +2155,13 @@ private static void OnDragEnterThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnDragEnter(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnDragEnter(e);
                 }
@@ -2409,17 +2176,13 @@ private static void OnPreviewDragOverThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewDragOver(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewDragOver(e);
                 }
@@ -2434,17 +2197,13 @@ private static void OnDragOverThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnDragOver(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnDragOver(e);
                 }
@@ -2459,17 +2218,13 @@ private static void OnPreviewDragLeaveThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewDragLeave(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewDragLeave(e);
                 }
@@ -2484,17 +2239,13 @@ private static void OnDragLeaveThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnDragLeave(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnDragLeave(e);
                 }
@@ -2509,17 +2260,13 @@ private static void OnPreviewDropThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewDrop(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewDrop(e);
                 }
@@ -2534,17 +2281,13 @@ private static void OnDropThunk(object sender, DragEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnDrop(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnDrop(e);
                 }
@@ -2559,17 +2302,13 @@ private static void OnPreviewTouchDownThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewTouchDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewTouchDown(e);
                 }
@@ -2584,17 +2323,13 @@ private static void OnTouchDownThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnTouchDown(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnTouchDown(e);
                 }
@@ -2609,17 +2344,13 @@ private static void OnPreviewTouchMoveThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewTouchMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewTouchMove(e);
                 }
@@ -2634,17 +2365,13 @@ private static void OnTouchMoveThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnTouchMove(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnTouchMove(e);
                 }
@@ -2659,17 +2386,13 @@ private static void OnPreviewTouchUpThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnPreviewTouchUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnPreviewTouchUp(e);
                 }
@@ -2684,17 +2407,13 @@ private static void OnTouchUpThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnTouchUp(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnTouchUp(e);
                 }
@@ -2709,17 +2428,13 @@ private static void OnGotTouchCaptureThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnGotTouchCapture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnGotTouchCapture(e);
                 }
@@ -2734,17 +2449,13 @@ private static void OnLostTouchCaptureThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnLostTouchCapture(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnLostTouchCapture(e);
                 }
@@ -2759,17 +2470,13 @@ private static void OnTouchEnterThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnTouchEnter(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnTouchEnter(e);
                 }
@@ -2784,17 +2491,13 @@ private static void OnTouchLeaveThunk(object sender, TouchEventArgs e)
         {
             Invariant.Assert(!e.Handled, "Unexpected: Event has already been handled.");
 
-            UIElement uie = sender as UIElement;
-
-            if (uie != null)
+            if (sender is UIElement uie)
             {
                 uie.OnTouchLeave(e);
             }
             else
             {
-                ContentElement ce = sender as ContentElement;
-
-                if (ce != null)
+                if (sender is ContentElement ce)
                 {
                     ce.OnTouchLeave(e);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/IncrementalHitTester.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/IncrementalHitTester.cs
index 2c991174..6de8995f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/IncrementalHitTester.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/IncrementalHitTester.cs
@@ -269,10 +269,7 @@ private void RebuildStrokeInfoCache()
             {
                 StrokeInfo strokeInfo = _strokeInfos[x];
             
-                if (strokeInfo != null)
-                {
-                    strokeInfo.Detach();
-                }
+                strokeInfo?.Detach();
             }
 
             _strokeInfos = newStrokeInfos;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke.cs
index fd181b5b..3d145438 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke.cs
@@ -1176,8 +1176,8 @@ internal static class IEnumerablePointHelper
         internal static int GetCount(IEnumerable<Point> ienum)
         {
             Debug.Assert(ienum != null);
-            ICollection<Point> icol = ienum as ICollection<Point>;
-            if (icol != null)
+
+            if (ienum is ICollection<Point> icol)
             {
                 return icol.Count;
             }
@@ -1195,8 +1195,8 @@ internal static int GetCount(IEnumerable<Point> ienum)
         internal static Point[] GetPointArray(IEnumerable<Point> ienum)
         {
             Debug.Assert(ienum != null);
-            Point[] points = ienum as Point[];
-            if (points != null)
+
+            if (ienum is Point[] points)
             {
                 return points;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke2.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke2.cs
index 7a5e9816..ab513e5b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke2.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/Stroke2.cs
@@ -271,11 +271,7 @@ public bool HitTest(Rect bounds, int percentageWithinBounds)
             }
             finally
             {
-                if (strokeInfo != null)
-                {
-                    //detach from event handlers, or else we leak.
-                    strokeInfo.Detach();
-                }
+                strokeInfo?.Detach();
             }
         }
 
@@ -330,11 +326,7 @@ public bool HitTest(IEnumerable<Point> lassoPoints, int percentageWithinLasso)
             }
             finally
             {
-                if (strokeInfo != null)
-                {
-                    //detach from event handlers, or else we leak.
-                    strokeInfo.Detach();
-                }
+                strokeInfo?.Detach();
             }
 }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollection2.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollection2.cs
index e5189e46..230ce306 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollection2.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollection2.cs
@@ -141,11 +141,7 @@ public StrokeCollection HitTest(IEnumerable<Point> lassoPoints, int percentageWi
                     }
                     finally
                     {
-                        if (strokeInfo != null)
-                        {
-                            //detach from event handlers, or else we leak.
-                            strokeInfo.Detach();
-                        }
+                        strokeInfo?.Detach();
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollectionConverter.cs
index 51db21c9..4111d1f1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Ink/StrokeCollectionConverter.cs
@@ -82,13 +82,12 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
         {
             //we only support converting to / from a string
-            string text = value as string;
             // brianew - presharp issue
             //   diabling the warning for not using IsNullOrEmpty on the string since
             //   are using the two operations for differnt results.
 #pragma warning disable 1634, 1691
 #pragma warning disable 6507
-            if (text != null)
+            if (value is string text)
             {
                 //always return an ink object
                 //even if the string is empty
@@ -130,10 +129,8 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 throw new ArgumentNullException("destinationType");
             }
 
-
             //if someone wants to convert to a string...
-            StrokeCollection strokes = value as StrokeCollection;
-            if (strokes != null)
+            if (value is StrokeCollection strokes)
             {
                 if (destinationType == typeof(string))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/AccessKeyManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/AccessKeyManager.cs
index c1ac94d4..63a43292 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/AccessKeyManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/AccessKeyManager.cs
@@ -259,8 +259,7 @@ private ProcessKeyResult ProcessKey(List<IInputElement> targets, string key, boo
                 int chosenIndex = 0;
                 for (int i = 0; i < targets.Count; i++)
                 {
-                    UIElement target = targets[i] as UIElement;
-                    Debug.Assert(target != null, "Targets should only be UIElements");
+                    Debug.Assert(targets[i] is UIElement target, "Targets should only be UIElements");
                     if (!target.IsEnabled)
                         continue;
 
@@ -462,12 +461,11 @@ private AccessKeyInformation GetInfoForElement(IInputElement element, string key
         private PresentationSource GetSourceForElement(IInputElement element)
         {
             PresentationSource source = null;
-            DependencyObject elementDO = element as DependencyObject;
 
             // Use internal helpers to try to find the source of the element.
             // Because IInputElements can move around without notification we need to
             // look up the source every time.
-            if (elementDO != null)
+            if (element is DependencyObject elementDO)
             {
                 DependencyObject containingVisual = InputElement.GetContainingVisual(elementDO);
 
@@ -521,10 +519,10 @@ private static bool IsVisible(DependencyObject element)
             while (element != null)
             {
                 Visibility visibility;
-                UIElement uiElem = element as UIElement;
                 UIElement3D uiElem3D = element as UIElement3D;
+
                 
-                if (uiElem != null)
+                if (element is UIElement uiElem)
 
                 {
                     visibility = uiElem.Visibility;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandBindingCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandBindingCollection.cs
index 98725d64..b249d600 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandBindingCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandBindingCollection.cs
@@ -102,8 +102,7 @@ bool IList.Contains(object key)
         /// <returns></returns>
         int IList.IndexOf(object value)
         {
-            CommandBinding commandBinding = value as CommandBinding;
-            return ((commandBinding != null) ? this.IndexOf(commandBinding) : -1);
+            return ((value is CommandBinding commandBinding) ? this.IndexOf(commandBinding) : -1);
         }
 
         /// <summary>
@@ -210,8 +209,7 @@ public void AddRange(ICollection collection)
                 IEnumerator collectionEnum = collection.GetEnumerator();
                 while(collectionEnum.MoveNext()) 
                 {
-                    CommandBinding cmdBinding = collectionEnum.Current as CommandBinding;
-                    if (cmdBinding != null)
+                    if (collectionEnum.Current is CommandBinding cmdBinding)
                     {
                         _innerCBList.Add(cmdBinding);
                     }
@@ -385,8 +383,8 @@ internal ICommand FindMatch(object targetElement, InputEventArgs inputEventArgs)
             for (int i = 0; i < Count; i++)
             {
                 CommandBinding commandBinding = this[i];
-                RoutedCommand routedCommand = commandBinding.Command as RoutedCommand;
-                if (routedCommand != null)
+
+                if (commandBinding.Command is RoutedCommand routedCommand)
                 {
                     InputGestureCollection inputGestures = routedCommand.InputGesturesInternal;
                     if (inputGestures != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandDevice.cs
index d60bb605..f9314498 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandDevice.cs
@@ -55,13 +55,11 @@ public override PresentationSource ActiveSource
 
         private void PreProcessInput( object sender, PreProcessInputEventArgs e )
         {
-            InputReportEventArgs input = e.StagingItem.Input as InputReportEventArgs;
-            if (input != null)
+            if (e.StagingItem.Input is InputReportEventArgs input)
             {
                 if (input.Report.Type == InputType.Command)
                 {
-                    RawAppCommandInputReport rawAppCommandInputReport = input.Report as RawAppCommandInputReport;
-                    if (rawAppCommandInputReport != null)
+                    if (input.Report is RawAppCommandInputReport rawAppCommandInputReport)
                     {
                         // Claim the input for the Command.
                         input.Device = this;
@@ -86,14 +84,11 @@ private void PostProcessInput( object sender, ProcessInputEventArgs e )
             {
                 if (!e.StagingItem.Input.Handled)
                 {
-                    InputReportEventArgs inputReportEventArgs = e.StagingItem.Input as InputReportEventArgs;
-                    if (inputReportEventArgs != null)
+                    if (e.StagingItem.Input is InputReportEventArgs inputReportEventArgs)
                     {
-                        RawAppCommandInputReport rawAppCommandInputReport = inputReportEventArgs.Report as RawAppCommandInputReport;
-                        if (rawAppCommandInputReport != null)
+                        if (inputReportEventArgs.Report is RawAppCommandInputReport rawAppCommandInputReport)
                         {
-                            IInputElement commandTarget = e.StagingItem.Input.OriginalSource as IInputElement;
-                            if (commandTarget != null)
+                            if (e.StagingItem.Input.OriginalSource is IInputElement commandTarget)
                             {
                                 RoutedCommand command = GetRoutedCommand(rawAppCommandInputReport.AppCommand);
                                 if (command != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandManager.cs
index 26f934c8..e5a2df2f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/CommandManager.cs
@@ -389,8 +389,7 @@ internal static void TranslateInput(IInputElement targetElement, InputEventArgs
                     Type classType = targetElement.GetType();
                     while (classType != null)
                     {
-                        InputBindingCollection classInputBindings = _classInputBindings[classType] as InputBindingCollection;
-                        if (classInputBindings != null)
+                        if (_classInputBindings[classType] is InputBindingCollection classInputBindings)
                         {
                             InputBinding inputBinding = classInputBindings.FindMatch(targetElement, inputEventArgs);
                             if (inputBinding != null)
@@ -437,8 +436,7 @@ internal static void TranslateInput(IInputElement targetElement, InputEventArgs
                     Type classType = targetElement.GetType();
                     while (classType != null)
                     {
-                        CommandBindingCollection classCommandBindings = _classCommandBindings[classType] as CommandBindingCollection;
-                        if (classCommandBindings != null)
+                        if (_classCommandBindings[classType] is CommandBindingCollection classCommandBindings)
                         {
                             command = classCommandBindings.FindMatch(targetElement, inputEventArgs);
                             if (command != null)
@@ -466,8 +464,7 @@ internal static void TranslateInput(IInputElement targetElement, InputEventArgs
 
                 bool continueRouting = false;
 
-                RoutedCommand routedCommand = command as RoutedCommand;
-                if (routedCommand != null)
+                if (command is RoutedCommand routedCommand)
                 {
                     if (routedCommand.CriticalCanExecute(parameter,
                                                     target,
@@ -513,8 +510,7 @@ internal static void OnCanExecute(object sender, CanExecuteRoutedEventArgs e)
 
                 if (!e.Handled && (e.RoutedEvent == CanExecuteEvent))
                 {
-                    DependencyObject d = sender as DependencyObject;
-                    if (d != null)
+                    if (sender is DependencyObject d)
                     {
                         if (FocusManager.GetIsFocusScope(d))
                         {
@@ -548,8 +544,7 @@ internal static void OnExecuted(object sender, ExecutedRoutedEventArgs e)
 
                 if (!e.Handled && (e.RoutedEvent == ExecutedEvent))
                 {
-                    DependencyObject d = sender as DependencyObject;
-                    if (d != null)
+                    if (sender is DependencyObject d)
                     {
                         if (FocusManager.GetIsFocusScope(d))
                         {
@@ -631,8 +626,7 @@ private static void FindCommandBinding(object sender, RoutedEventArgs e, IComman
                 Type classType = sender.GetType();
                 while (classType != null)
                 {
-                    CommandBindingCollection classCommandBindings = _classCommandBindings[classType] as CommandBindingCollection;
-                    if (classCommandBindings != null)
+                    if (_classCommandBindings[classType] is CommandBindingCollection classCommandBindings)
                     {
                         int index = 0;
                         while (true)
@@ -718,8 +712,7 @@ private static void FindCommandBinding(CommandBindingCollection commandBindings,
 
         private static void TransferEvent(IInputElement newSource, CanExecuteRoutedEventArgs e)
         {
-            RoutedCommand command = e.Command as RoutedCommand;
-            if (command != null)
+            if (e.Command is RoutedCommand command)
             {
                 try
                 {
@@ -734,8 +727,7 @@ private static void TransferEvent(IInputElement newSource, CanExecuteRoutedEvent
 
         private static void TransferEvent(IInputElement newSource, ExecutedRoutedEventArgs e)
         {
-            RoutedCommand command = e.Command as RoutedCommand;
-            if (command != null)
+            if (e.Command is RoutedCommand command)
             {
                 try
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputBindingCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputBindingCollection.cs
index fc785f04..ea9e625b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputBindingCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputBindingCollection.cs
@@ -112,8 +112,7 @@ bool IList.Contains(object key)
         /// <returns>index of the item or -1 </returns>
         int IList.IndexOf(object value)
         {
-            InputBinding inputBinding = value as InputBinding;
-            return ((inputBinding != null) ? this.IndexOf(inputBinding) : -1);
+            return ((value is InputBinding inputBinding) ? this.IndexOf(inputBinding) : -1);
         }
 
         /// <summary>
@@ -279,8 +278,7 @@ public void AddRange(ICollection collection)
                 IEnumerator collectionEnum = collection.GetEnumerator();
                 while(collectionEnum.MoveNext())
                 {
-                    InputBinding inputBinding = collectionEnum.Current as InputBinding;
-                    if (inputBinding != null)
+                    if (collectionEnum.Current is InputBinding inputBinding)
                     {
                         _innerBindingList.Add(inputBinding);
                         InheritanceContextHelper.ProvideContextForObject(_owner, inputBinding);
@@ -440,10 +438,7 @@ public bool Contains(InputBinding key)
         /// <param name="index">start index in the current list to copy</param>
         public void CopyTo(InputBinding[] inputBindings, int index)
         {
-            if (_innerBindingList != null)
-            {
-                _innerBindingList.CopyTo(inputBindings, index);
-            }
+            _innerBindingList?.CopyTo(inputBindings, index);
         }
 #endregion Public
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputGestureCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputGestureCollection.cs
index 51881b04..23c173b9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputGestureCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/InputGestureCollection.cs
@@ -97,8 +97,7 @@ bool IList.Contains(object key)
         /// <returns></returns>
         int IList.IndexOf(object value)
         {
-            InputGesture inputGesture = value as InputGesture;
-            return ((inputGesture != null) ? this.IndexOf(inputGesture) : -1) ;
+            return ((value is InputGesture inputGesture) ? this.IndexOf(inputGesture) : -1) ;
         }
 
         /// <summary>
@@ -299,8 +298,7 @@ public void AddRange(ICollection collection)
                 IEnumerator collectionEnum = collection.GetEnumerator();
                 while(collectionEnum.MoveNext()) 
                 {
-                    InputGesture inputGesture = collectionEnum.Current as InputGesture;
-                    if (inputGesture != null)
+                    if (collectionEnum.Current is InputGesture inputGesture)
                     {
                         _innerGestureList.Add(inputGesture);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGesture.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGesture.cs
index 69d3bf85..9cb2d9e3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGesture.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGesture.cs
@@ -178,8 +178,7 @@ public string GetDisplayStringForCulture(CultureInfo culture)
         /// </returns>
         public override bool Matches(object targetElement, InputEventArgs inputEventArgs)
         {
-            KeyEventArgs keyEventArgs = inputEventArgs as KeyEventArgs;
-            if(keyEventArgs != null && IsDefinedKey(keyEventArgs.Key))
+            if(inputEventArgs is KeyEventArgs keyEventArgs && IsDefinedKey(keyEventArgs.Key))
             {
                 return ( ( (int)Key == (int)keyEventArgs.RealKey ) && ( this.Modifiers == Keyboard.Modifiers ) );
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureConverter.cs
index ac1456c4..511582c6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureConverter.cs
@@ -59,10 +59,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for known type
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
-                    KeyGesture keyGesture = context.Instance as KeyGesture;
-                    if (keyGesture != null)
+                    if (context.Instance is KeyGesture keyGesture)
                     {
                         return (ModifierKeysConverter.IsDefinedModifierKeys(keyGesture.Modifiers)
                                 && IsDefinedKey(keyGesture.Key));
@@ -81,9 +80,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         /// <returns></returns>
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source)
         {
-            if (source != null && source is string)
+            if (source is string s)
             {
-                string fullName = ((string)source).Trim();
+                string fullName = s.Trim();
                 if (fullName == String.Empty)
                     return new KeyGesture(Key.None);
 
@@ -148,8 +147,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
             {
                 if (value != null)
                 {
-                    KeyGesture keyGesture = value as KeyGesture;
-                    if (keyGesture != null)
+                    if (value is KeyGesture keyGesture)
                     {
                         if (keyGesture.Key == Key.None)
                             return String.Empty;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureValueSerializer.cs
index 4b31698f..516b4192 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/KeyGestureValueSerializer.cs
@@ -47,10 +47,9 @@ public override bool CanConvertFromString(string value, IValueSerializerContext
         /// <ExternalAPI/> 
         public override bool CanConvertToString(object value, IValueSerializerContext context) 
         {
-            KeyGesture keyGesture = value as KeyGesture;
 
             #pragma warning disable 6506
-            return (keyGesture != null) 
+            return (value is KeyGesture keyGesture) 
                 && ModifierKeysConverter.IsDefinedModifierKeys(keyGesture.Modifiers)
                 && KeyGestureConverter.IsDefinedKey(keyGesture.Key);
             #pragma warning restore 6506
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseActionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseActionConverter.cs
index 7289bf6d..1c68dcc3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseActionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseActionConverter.cs
@@ -60,7 +60,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for known type
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     return (MouseActionConverter.IsDefinedMouseAction((MouseAction)context.Instance));
                  }
@@ -77,9 +77,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         /// <returns></returns>
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source)
         {
-            if (source != null && source is string)
+            if (source is string s)
             {
-                string mouseActionToken = ((string)source).Trim();
+                string mouseActionToken = s.Trim();
                 mouseActionToken = mouseActionToken.ToUpper(CultureInfo.InvariantCulture);
                 if (mouseActionToken == String.Empty)
                     return MouseAction.None;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseBinding.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseBinding.cs
index dfe3c061..ee6f7194 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseBinding.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseBinding.cs
@@ -230,8 +230,7 @@ private void OnMouseGesturePropertyChanged(object sender, PropertyChangedEventAr
         {
             if (string.Compare(e.PropertyName, "MouseAction", StringComparison.Ordinal) == 0)
             {
-                MouseGesture mouseGesture = Gesture as MouseGesture;
-                if (mouseGesture != null)
+                if (Gesture is MouseGesture mouseGesture)
                 {
                     SynchronizePropertiesFromGesture(mouseGesture);
                 }
@@ -240,8 +239,7 @@ private void OnMouseGesturePropertyChanged(object sender, PropertyChangedEventAr
 
         private void CloneGesture()
         {
-            MouseGesture mouseGesture = Gesture as MouseGesture;
-            if (mouseGesture != null)
+            if (Gesture is MouseGesture mouseGesture)
             {
                 mouseGesture.PropertyChanged += new PropertyChangedEventHandler(OnMouseGesturePropertyChanged);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGesture.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGesture.cs
index b92f92b9..7e793dfd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGesture.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGesture.cs
@@ -177,8 +177,7 @@ internal static MouseAction GetMouseAction(InputEventArgs inputArgs)
         {
             MouseAction MouseAction = MouseAction.None;
 
-            MouseEventArgs mouseArgs = inputArgs as MouseEventArgs;
-            if(mouseArgs != null)
+            if(inputArgs is MouseEventArgs mouseArgs)
             {
                 if(inputArgs is MouseWheelEventArgs)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureConverter.cs
index 0b3a2ad0..0b455c90 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureConverter.cs
@@ -94,9 +94,9 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                             {
                                 object modifierKeys = modifierKeysConverter.ConvertFrom(context, culture, modifiersToken);
 
-                                if (modifierKeys != null && modifierKeys is ModifierKeys)
+                                if (modifierKeys is ModifierKeys modifierKeys)
                                 {
-                                    return new MouseGesture((MouseAction)mouseAction, (ModifierKeys)modifierKeys);
+                                    return new MouseGesture((MouseAction)mouseAction, modifierKeys);
                                 }
                             }
                         }
@@ -122,10 +122,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for known type
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
-                    MouseGesture mouseGesture = context.Instance as MouseGesture;
-                    if (mouseGesture != null)
+                    if (context.Instance is MouseGesture mouseGesture)
                     {
                         return (ModifierKeysConverter.IsDefinedModifierKeys(mouseGesture.Modifiers) 
                                && MouseActionConverter.IsDefinedMouseAction(mouseGesture.MouseAction));
@@ -153,8 +152,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (value == null)
                     return String.Empty;
 
-                MouseGesture mouseGesture = value as MouseGesture;
-                if (mouseGesture != null)
+                if (value is MouseGesture mouseGesture)
                 {
                     string strGesture = "";
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureValueSerializer.cs
index 5146921c..d7dec333 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/MouseGestureValueSerializer.cs
@@ -44,9 +44,8 @@ public override bool CanConvertFromString(string value, IValueSerializerContext
         public override bool CanConvertToString(object value, IValueSerializerContext context) 
         {
             bool result = false;
-            MouseGesture mouseGesture = value as MouseGesture;
 
-            if(mouseGesture != null)
+            if(value is MouseGesture mouseGesture)
             {
                 if(ModifierKeysConverter.IsDefinedModifierKeys(mouseGesture.Modifiers)
                    && MouseActionConverter.IsDefinedMouseAction(mouseGesture.MouseAction))
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/RoutedCommand.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/RoutedCommand.cs
index bf6a5f44..d62b4ab4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/RoutedCommand.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Command/RoutedCommand.cs
@@ -390,7 +390,6 @@ private bool ExecuteImpl(object parameter, IInputElement target, bool userInitia
             // If blocked by rights-management fall through and return false
             if ((target != null) && !IsBlockedByRM)
             {
-                UIElement targetUIElement = target as UIElement;
                 ContentElement targetAsContentElement = null;
                 UIElement3D targetAsUIElement3D = null;
 
@@ -398,8 +397,9 @@ private bool ExecuteImpl(object parameter, IInputElement target, bool userInitia
                 // Raise the regular ExecuteEvent.
                 ExecutedRoutedEventArgs args = new ExecutedRoutedEventArgs(this, parameter);
                 args.RoutedEvent = CommandManager.PreviewExecutedEvent;
+
                 
-                if (targetUIElement != null)
+                if (target is UIElement targetUIElement)
                 {
                     targetUIElement.RaiseEvent(args, userInitiated);
                 }
@@ -413,17 +413,15 @@ private bool ExecuteImpl(object parameter, IInputElement target, bool userInitia
                     else
                     {
                         targetAsUIElement3D = target as UIElement3D;
-                        if (targetAsUIElement3D != null)
-                        {
-                            targetAsUIElement3D.RaiseEvent(args, userInitiated);
-                        }
+                        targetAsUIElement3D?.RaiseEvent(args, userInitiated);
                     }                    
                 }
 
                 if (!args.Handled)
                 {
                     args.RoutedEvent = CommandManager.ExecutedEvent;
-                    if (targetUIElement != null)
+
+                    if (target is UIElement targetUIElement)
                     {
                         targetUIElement.RaiseEvent(args, userInitiated);
                     }
@@ -431,10 +429,7 @@ private bool ExecuteImpl(object parameter, IInputElement target, bool userInitia
                     {
                         targetAsContentElement.RaiseEvent(args, userInitiated);
                     }
-                    else if (targetAsUIElement3D != null)
-                    {
-                        targetAsUIElement3D.RaiseEvent(args, userInitiated);
-                    }
+                    else targetAsUIElement3D?.RaiseEvent(args, userInitiated);
                 }
 
                 return args.Handled;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/CursorConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/CursorConverter.cs
index d00bd087..2cacdd7a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/CursorConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/CursorConverter.cs
@@ -107,9 +107,9 @@ public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
         /// <returns>value that is result of conversion</returns>
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
         {
-            if (value is string)
+            if (value is string s)
             {                
-                string text = ((string)value).Trim();
+                string text = s.Trim();
 
                 if (text != String.Empty)
                 {
@@ -225,8 +225,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
 	        // If value is not a Cursor or null, it will throw GetConvertToException.
             if(destinationType == typeof(string))
             {
-                Cursor cursor = value as Cursor;
-                if (cursor != null)
+                if (value is Cursor cursor)
                 {
                     return cursor.ToString();
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/FocusManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/FocusManager.cs
index 77a3bce9..cef905db 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/FocusManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/FocusManager.cs
@@ -233,10 +233,7 @@ private static void OnFocusedElementChanged(DependencyObject d, DependencyProper
             DependencyObject oldVisual = (DependencyObject)e.OldValue;
             DependencyObject newVisual = (DependencyObject)e.NewValue;
 
-            if (oldVisual != null)
-            {
-                oldVisual.ClearValue(UIElement.IsFocusedPropertyKey);
-            }
+            oldVisual?.ClearValue(UIElement.IsFocusedPropertyKey);
 
             if (newVisual != null)
             {
@@ -338,9 +335,8 @@ private static DependencyObject GetRoot(DependencyObject element)
 
             DependencyObject parent = null;
             DependencyObject dependencyObject = element;
-            
-            ContentElement ce = element as ContentElement;
-            if (ce != null)
+
+            if (element is ContentElement ce)
                 dependencyObject = ce.GetUIParent();
             
             while (dependencyObject != null)
@@ -362,8 +358,7 @@ private static DependencyObject _GetFocusScope(DependencyObject d)
                 return d;
 
             // Step 1: Walk up the logical tree
-            UIElement uiElement = d as UIElement;
-            if (uiElement != null)
+            if (d is UIElement uiElement)
             {
                 DependencyObject logicalParent = uiElement.GetUIParentCore();
                 if (logicalParent != null)
@@ -373,8 +368,7 @@ private static DependencyObject _GetFocusScope(DependencyObject d)
             }
             else
             {
-                ContentElement ce = d as ContentElement;
-                if (ce != null)
+                if (d is ContentElement ce)
                 {
                     DependencyObject logicalParent = ce.GetUIParent(true);
                     if (logicalParent != null)
@@ -384,8 +378,7 @@ private static DependencyObject _GetFocusScope(DependencyObject d)
                 }
                 else
                 {
-                    UIElement3D uiElement3D = d as UIElement3D;
-                    if (uiElement3D != null)
+                    if (d is UIElement3D uiElement3D)
                     {
                         DependencyObject logicalParent = uiElement3D.GetUIParentCore();
                         if (logicalParent != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/InputMethod.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/InputMethod.cs
index 36d80603..8a19e8d2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/InputMethod.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/InputMethod.cs
@@ -1649,8 +1649,7 @@ private static IntPtr HwndFromInputElement(IInputElement element)
             // We allow null element.
             if (element != null)
             {
-                DependencyObject o = element as DependencyObject;
-                if (o != null)
+                if (element is DependencyObject o)
                 {
                     DependencyObject containingVisual = InputElement.GetContainingVisual(o);
                     if(containingVisual != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/KeyboardDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/KeyboardDevice.cs
index a2234754..4d323766 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/KeyboardDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/KeyboardDevice.cs
@@ -637,8 +637,7 @@ private object ReevaluateFocusCallback(object arg)
 
             if(presentationSource != null)
             {
-                IKeyboardInputProvider keyboardProvider = presentationSource.GetInputProvider(typeof(KeyboardDevice)) as IKeyboardInputProvider;
-                if(keyboardProvider != null)
+                if(presentationSource.GetInputProvider(typeof(KeyboardDevice)) is IKeyboardInputProvider keyboardProvider)
                 {
                     // Confirm with the keyboard provider for this
                     // presentation source that it has acquired focus.
@@ -731,10 +730,7 @@ private void PreNotifyInput(object sender, NotifyInputEventArgs e)
                         // we are now active.
                         _activeSource = new SecurityCriticalDataClass<PresentationSource>(keyboardInput.InputSource);
 
-                        if(toDeactivate != null)
-                        {
-                            toDeactivate.NotifyDeactivate();
-                        }
+                        toDeactivate?.NotifyDeactivate();
                     }
                 }
 
@@ -997,8 +993,7 @@ private RawKeyboardInputReport ExtractRawKeyboardInputReport(NotifyInputEventArg
         {
             RawKeyboardInputReport keyboardInput = null;
 
-            InputReportEventArgs input = e.StagingItem.Input as InputReportEventArgs;
-            if(input != null)
+            if(e.StagingItem.Input is InputReportEventArgs input)
             {
                 if(input.Report.Type == InputType.Keyboard && input.RoutedEvent == Event)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Manipulation.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Manipulation.cs
index 47a66e75..4d569940 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Manipulation.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Manipulation.cs
@@ -68,10 +68,7 @@ public static void StartInertia(UIElement element)
             }
 
             ManipulationDevice device = ManipulationDevice.GetManipulationDevice(element);
-            if (device != null)
-            {
-                device.CompleteManipulation(/* withInertia = */ true);
-            }
+            device?.CompleteManipulation( /* withInertia = */true);
         }
 
         /// <summary>
@@ -345,8 +342,7 @@ internal static UIElement FindManipulationParent(Visual visual)
         {
             while (visual != null)
             {
-                UIElement element = visual as UIElement;
-                if ((element != null) && element.IsManipulationEnabled)
+                if ((visual is UIElement element) && element.IsManipulationEnabled)
                 {
                     return element;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationDevice.cs
index d83fdd9a..f749f8b1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationDevice.cs
@@ -135,10 +135,7 @@ private void RemoveManipulationDevice()
 
             RemoveAllManipulators();
 
-            if (_manipulationDevices != null)
-            {
-                _manipulationDevices.Remove(_target);
-            }
+            _manipulationDevices?.Remove(_target);
         }
 
         private void RemoveAllManipulators()
@@ -177,10 +174,7 @@ internal void RemoveManipulator(IManipulator manipulator)
             VerifyAccess();
 
             manipulator.Updated -= OnManipulatorUpdated;
-            if (_manipulators != null)
-            {
-                _manipulators.Remove(manipulator);
-            }
+            _manipulators?.Remove(manipulator);
 
             // Removing a manipulator counts as an update
             OnManipulatorUpdated(manipulator, EventArgs.Empty);
@@ -344,8 +338,7 @@ private void PostProcessInput(object sender, ProcessInputEventArgs e)
                 RoutedEvent routedEvent = inputEventArgs.RoutedEvent;
                 if (routedEvent == Manipulation.ManipulationDeltaEvent)
                 {
-                    ManipulationDeltaEventArgs deltaEventArgs = inputEventArgs as ManipulationDeltaEventArgs;
-                    if (deltaEventArgs != null)
+                    if (inputEventArgs is ManipulationDeltaEventArgs deltaEventArgs)
                     {
                         // During deltas, see if panning feedback is needed on the window
                         ManipulationDelta unusedManipulation = deltaEventArgs.UnusedManipulation;
@@ -367,16 +360,14 @@ private void PostProcessInput(object sender, ProcessInputEventArgs e)
                 }
                 else if (routedEvent == Manipulation.ManipulationStartingEvent)
                 {
-                    ManipulationStartingEventArgs startingEventArgs = inputEventArgs as ManipulationStartingEventArgs;
-                    if (startingEventArgs != null && startingEventArgs.RequestedCancel)
+                    if (inputEventArgs is ManipulationStartingEventArgs startingEventArgs && startingEventArgs.RequestedCancel)
                     {
                         OnManipulationCancel();
                     }
                 }
                 else if (routedEvent == Manipulation.ManipulationStartedEvent)
                 {
-                    ManipulationStartedEventArgs startedEventArgs = inputEventArgs as ManipulationStartedEventArgs;
-                    if (startedEventArgs != null)
+                    if (inputEventArgs is ManipulationStartedEventArgs startedEventArgs)
                     {
                         if (startedEventArgs.RequestedComplete)
                         {
@@ -405,8 +396,7 @@ private void PostProcessInput(object sender, ProcessInputEventArgs e)
                     RemoveAllManipulators();
 
                     // Initialize inertia
-                    ManipulationInertiaStartingEventArgs inertiaEventArgs = inputEventArgs as ManipulationInertiaStartingEventArgs;
-                    if (inertiaEventArgs != null)
+                    if (inputEventArgs is ManipulationInertiaStartingEventArgs inertiaEventArgs)
                     {
                         if (inertiaEventArgs.RequestedCancel)
                         {
@@ -421,8 +411,8 @@ private void PostProcessInput(object sender, ProcessInputEventArgs e)
                 else if (routedEvent == Manipulation.ManipulationCompletedEvent)
                 {
                     _manipulationLogic.OnCompleted();
-                    ManipulationCompletedEventArgs completedEventArgs = inputEventArgs as ManipulationCompletedEventArgs;
-                    if (completedEventArgs != null)
+
+                    if (inputEventArgs is ManipulationCompletedEventArgs completedEventArgs)
                     {
                         if (completedEventArgs.RequestedCancel)
                         {
@@ -439,8 +429,7 @@ private void PostProcessInput(object sender, ProcessInputEventArgs e)
                 }
                 else if (routedEvent == Manipulation.ManipulationBoundaryFeedbackEvent)
                 {
-                    ManipulationBoundaryFeedbackEventArgs boundaryEventArgs = inputEventArgs as ManipulationBoundaryFeedbackEventArgs;
-                    if (boundaryEventArgs != null)
+                    if (inputEventArgs is ManipulationBoundaryFeedbackEventArgs boundaryEventArgs)
                     {
                         _compensateForBoundaryFeedback = boundaryEventArgs.CompensateForBoundaryFeedback;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationLogic.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationLogic.cs
index 95ff7995..165417de 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationLogic.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/ManipulationLogic.cs
@@ -512,10 +512,7 @@ private static ManipulationPivot2D ConvertPivot(ManipulationPivot pivot)
 
         internal void SetManipulationParameters(ManipulationParameters2D parameter)
         {
-            if (_manipulationProcessor != null)
-            {
-                _manipulationProcessor.SetParameters(parameter);
-            }
+            _manipulationProcessor?.SetParameters(parameter);
         }
 
         private void UpdateManipulators(ICollection<IManipulator> updatedManipulators)
@@ -528,10 +525,8 @@ private void UpdateManipulators(ICollection<IManipulator> updatedManipulators)
             _removedManipulators = _currentManipulators;
             _currentManipulators = temp;
 
-            // End the manipulation if the element is not
-            // visible anymore
-            UIElement uie = _currentContainer as UIElement;
-            if (uie != null)
+            // End the manipulation if the element is not            // visible anymore
+            if (_currentContainer is UIElement uie)
             {
                 if (!uie.IsVisible)
                 {
@@ -540,8 +535,7 @@ private void UpdateManipulators(ICollection<IManipulator> updatedManipulators)
             }
             else
             {
-                UIElement3D uie3D = _currentContainer as UIElement3D;
-                if (uie3D != null &&
+                if (_currentContainer is UIElement3D uie3D &&
                     !uie3D.IsVisible)
                 {
                     return;
@@ -620,8 +614,7 @@ private void SetContainer(IInputElement newContainer)
 
         private void SubscribeToLayoutUpdated()
         {
-            UIElement container = _currentContainer as UIElement;
-            if (container != null)
+            if (_currentContainer is UIElement container)
             {
                 container.LayoutUpdated += OnLayoutUpdated;
             }
@@ -629,8 +622,7 @@ private void SubscribeToLayoutUpdated()
 
         private void UnsubscribeFromLayoutUpdated()
         {
-            UIElement container = _currentContainer as UIElement;
-            if (container != null)
+            if (_currentContainer is UIElement container)
             {
                 container.LayoutUpdated -= OnLayoutUpdated;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/MouseDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/MouseDevice.cs
index f2c33ba1..11b38678 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/MouseDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/MouseDevice.cs
@@ -329,8 +329,7 @@ public bool Capture(IInputElement element, CaptureMode captureMode)
             }
 
             // Validate that elt is either a UIElement or a ContentElement
-            DependencyObject eltDO = element as DependencyObject;
-            if (eltDO != null && !InputElement.IsValid(element))
+            if (element is DependencyObject eltDO && !InputElement.IsValid(element))
             {
                 throw new InvalidOperationException(SR.Get(SRID.Invalid_IInputElement, eltDO.GetType()));
             }
@@ -453,8 +452,7 @@ private IMouseInputProvider FindMouseInputProviderForCursor( )
 
             while (inputProviders.MoveNext())
             {
-                IMouseInputProvider provider = inputProviders.Current as IMouseInputProvider;
-                if (provider != null )
+                if (inputProviders.Current is IMouseInputProvider provider )
                 {
                     mouseInputProvider = provider;
                     break;
@@ -915,7 +913,7 @@ public void Synchronize()
 
             // Simulate a mouse move
             PresentationSource activeSource = CriticalActiveSource;
-            if (activeSource != null && activeSource.CompositionTarget != null && !activeSource.CompositionTarget.IsDisposed)
+            if (activeSource?.CompositionTarget != null && !activeSource.CompositionTarget.IsDisposed)
             {
                 int timeStamp = Environment.TickCount;
                 Point ptClient = GetClientPosition();
@@ -1234,11 +1232,7 @@ private void PreProcessInput(object sender, PreProcessInputEventArgs e)
                     // Only process mouse input that is from our active PresentationSource.
                     else if ((_inputSource != null) && (rawMouseInputReport.InputSource == _inputSource.Value))
                     {
-                        // We need to remember the StylusDevice that generated this input.  Use the _tagStylusDevice
-                        // to store this in before we take over the inputReport Device and loose it.  Any
-                        // input reports we re-push need to preserve this too.  This is used to set the StylusDevice
-                        // property on MouseEventArgs.
-                        InputDevice inputDevice = e.StagingItem.GetData(_tagStylusDevice) as StylusDevice;
+                        // We need to remember the StylusDevice that generated this input.  Use the _tagStylusDevice                        // to store this in before we take over the inputReport Device and loose it.  Any                        // input reports we re-push need to preserve this too.  This is used to set the StylusDevice                        // property on MouseEventArgs.
 
                         if (inputDevice == null)
                         {
@@ -1260,7 +1254,7 @@ private void PreProcessInput(object sender, PreProcessInputEventArgs e)
                                 inputDevice = inputReportEventArgs.Device as StylusDevice;
                             }
 
-                            if (inputDevice != null)
+                            if (e.StagingItem.GetData(_tagStylusDevice) is StylusDevice inputDevice)
                             {
                                 e.StagingItem.SetData(_tagStylusDevice, inputDevice);
                             }
@@ -1445,10 +1439,7 @@ private void PreNotifyInput(object sender, NotifyInputEventArgs e)
                             // All mouse information is now restricted to this presentation source.
                             _inputSource = new SecurityCriticalDataClass<PresentationSource>(rawMouseInputReport.InputSource);
 
-                            if (toDeactivate != null)
-                            {
-                                toDeactivate.NotifyDeactivate();
-                            }
+                            toDeactivate?.NotifyDeactivate();
                         }
                     }
 
@@ -2085,7 +2076,7 @@ private static void GlobalHitTest(bool clientUnits, Point pt, PresentationSource
 
             // Note: this only works for HWNDs for now.
             HwndSource source = inputSource as HwndSource;
-            if (source != null && source.CompositionTarget != null && !source.IsHandleNull)
+            if (source?.CompositionTarget != null && !source.IsHandleNull)
             {
                 Point ptScreen = PointUtil.ClientToScreen(ptClient, source);
                 IntPtr hwndHit = IntPtr.Zero ;
@@ -2139,8 +2130,7 @@ private static void LocalHitTest(bool clientUnits, Point pt, PresentationSource
             // Note: this restricts us to windows with UIElement as the root (not just visuals).
             if (inputSource != null)
             {
-                UIElement root = inputSource.RootVisual as UIElement;
-                if(root != null)
+                if(inputSource.RootVisual is UIElement root)
                 {
                     Point rootPt = clientUnits ? PointUtil.ClientToRoot(pt, inputSource) : pt;
                     root.InputHitTest(rootPt, out enabledHit, out originalHit);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/StagingAreaInputItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/StagingAreaInputItem.cs
index 294367d7..ac8c03ea 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/StagingAreaInputItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/StagingAreaInputItem.cs
@@ -30,7 +30,7 @@ internal void Reset(InputEventArgs input, StagingAreaInputItem promote)
         {
             _input = input;
 
-            if(promote != null && promote._dictionary != null)
+            if(promote?._dictionary != null)
             {
                 _dictionary = (Hashtable) promote._dictionary.Clone();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRenderer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRenderer.cs
index 44cfe898..5b092038 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRenderer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRenderer.cs
@@ -584,35 +584,29 @@ void RemoveDynamicRendererVisualAndNotifyWhenDone(StrokeInfo si)
         private void NotifyAppOfDRThreadRenderComplete(StrokeInfo si)
         {
             Dispatcher dispatcher = _applicationDispatcher;
-            if (dispatcher != null)
-            {
-                // We are being called by the inking thread, so marshal over to
-                // the UI thread before handling the StrokeInfos that are done rendering.
-                dispatcher.BeginInvoke(DispatcherPriority.Send,
-                (DispatcherOperationCallback)delegate(object unused)
-                {
-                    // See if this is the one we are doing a full transition for.
-                    if (si == _renderCompleteStrokeInfo)
-                    {
-                        if (si.StrokeHV.Clip != null)
-                        {
-                            si.StrokeHV.Clip = null;
-                            NotifyOnNextRenderComplete();
-                        }
-                        else
-                        {
-                            Debug.Assert(_waitingForRenderComplete, "We were expecting to be waiting for a RenderComplete to call our OnRenderComplete, we might never reset and get flashing strokes from here on out");
-                            TransitionComplete(si); // We're done
-                        }
-                    }
-                    else
-                    {
-                        TransitionComplete(si); // We're done
-                    }
-                    return null;
-                },
-                null);
-            }
+            dispatcher?.BeginInvoke(DispatcherPriority.Send, (DispatcherOperationCallback)delegate (object unused)
+{
+    // See if this is the one we are doing a full transition for.
+    if (si == _renderCompleteStrokeInfo)
+    {
+        if (si.StrokeHV.Clip != null)
+        {
+            si.StrokeHV.Clip = null;
+            NotifyOnNextRenderComplete();
+        }
+        else
+        {
+            Debug.Assert(_waitingForRenderComplete, "We were expecting to be waiting for a RenderComplete to call our OnRenderComplete, we might never reset and get flashing strokes from here on out");
+            TransitionComplete(si); // We're done
+        }
+    }
+    else
+    {
+        TransitionComplete(si); // We're done
+    }
+
+    return null;
+}, null);
         }
 
 
@@ -845,54 +839,48 @@ void RenderPackets(StylusPointCollection stylusPoints,  StrokeInfo si)
                     Dispatcher drDispatcher = renderingThread != null ? renderingThread.ThreadDispatcher : null;
 
                     // Only try to render if we get a ref on the rendering thread.
-                    if (drDispatcher != null)
-                    {
-                        // We are on a pen thread so marshal this call to our inking thread.
-                        drDispatcher.BeginInvoke(DispatcherPriority.Send,
-                        (DispatcherOperationCallback) delegate(object unused)
-                        {
-                            SolidColorBrush fillBrush = si.FillBrush;
+                    drDispatcher?.BeginInvoke(DispatcherPriority.Send, (DispatcherOperationCallback)delegate (object unused)
+{
+    SolidColorBrush fillBrush = si.FillBrush;
+    // Make sure this stroke is not aborted
+    if (fillBrush != null)
+    {
+        // See if we need to create a new container visual for the stroke.
+        if (si.StrokeRTICV == null)
+        {
+            // Create new container visual for this stroke and add our incremental rendering visual to it.
+            si.StrokeRTICV = new ContainerVisual();
+            // two incrementally rendered stroke segments blend together
+            // at the rendering point location, thus the alpha value at those locations are higher than the set value.
+            // This is like you draw two strokes using static rendeer and the intersection part becomes darker.
+            // Set the opacity of the RootContainerVisual of the whole incremental stroke as color.A/255.0 and override
+            // the alpha value of the color we send to mil for rendering.
+            if (!si.DrawingAttributes.IsHighlighter)
+            {
+                si.StrokeRTICV.Opacity = si.Opacity;
+            }
 
-                            // Make sure this stroke is not aborted
-                            if (fillBrush != null)
-                            {
-                                // See if we need to create a new container visual for the stroke.
-                                if (si.StrokeRTICV == null)
-                                {
-                                    // Create new container visual for this stroke and add our incremental rendering visual to it.
-                                    si.StrokeRTICV = new ContainerVisual();
-
-                                    // two incrementally rendered stroke segments blend together
-                                    // at the rendering point location, thus the alpha value at those locations are higher than the set value.
-                                    // This is like you draw two strokes using static rendeer and the intersection part becomes darker.
-                                    // Set the opacity of the RootContainerVisual of the whole incremental stroke as color.A/255.0 and override
-                                    // the alpha value of the color we send to mil for rendering.
-                                    if (!si.DrawingAttributes.IsHighlighter)
-                                    {
-                                        si.StrokeRTICV.Opacity = si.Opacity;
-                                    }
-                                    ((ContainerVisual)si.StrokeHV.VisualTarget.RootVisual).Children.Add(si.StrokeRTICV);
-                                }
-                                
-                                // Create new visual and render the geometry into it
-                                DrawingVisual visual = new DrawingVisual();
-                                DrawingContext drawingContext = visual.RenderOpen();
-                                try
-                                {
-                                    OnDraw(drawingContext, stylusPoints, strokeGeometry, fillBrush);
-                                }
-                                finally
-                                {
-                                    drawingContext.Close();
-                                }
-                                // Add it to the visual tree
-                                si.StrokeRTICV.Children.Add(visual);
-                            }
-                
-                            return null;
-                        },
-                        null);
-                    }
+            ((ContainerVisual)si.StrokeHV.VisualTarget.RootVisual).Children.Add(si.StrokeRTICV);
+        }
+
+        // Create new visual and render the geometry into it
+        DrawingVisual visual = new DrawingVisual();
+        DrawingContext drawingContext = visual.RenderOpen();
+        try
+        {
+            OnDraw(drawingContext, stylusPoints, strokeGeometry, fillBrush);
+        }
+        finally
+        {
+            drawingContext.Close();
+        }
+
+        // Add it to the visual tree
+        si.StrokeRTICV.Children.Add(visual);
+    }
+
+    return null;
+}, null);
                 }
             }
         }
@@ -1173,25 +1161,18 @@ private void DestroyRealTimeVisuals()
                 DynamicRendererThreadManager renderingThread = _renderingThread; // keep ref to keep it alive in this routine
                 Dispatcher drDispatcher = renderingThread != null ? renderingThread.ThreadDispatcher : null;
 
-                if (drDispatcher != null)
-                {
-                    drDispatcher.BeginInvoke(DispatcherPriority.Send,
-                    (DispatcherOperationCallback)delegate(object unused)
-                    {
-                        _renderCompleteDRThreadStrokeInfoList.Clear();
-                        
-                        drDispatcher = renderingThread.ThreadDispatcher;
-                        
-                        if (drDispatcher != null && _waitingForDRThreadRenderComplete)
-                        {
-                            MediaContext.From(drDispatcher).RenderComplete -= _onDRThreadRenderComplete;
-                        }
-                        _waitingForDRThreadRenderComplete = false;
-                
-                        return null;
-                    },
-                    null);
-                }
+                drDispatcher?.BeginInvoke(DispatcherPriority.Send, (DispatcherOperationCallback)delegate (object unused)
+{
+    _renderCompleteDRThreadStrokeInfoList.Clear();
+    drDispatcher = renderingThread.ThreadDispatcher;
+    if (drDispatcher != null && _waitingForDRThreadRenderComplete)
+    {
+        MediaContext.From(drDispatcher).RenderComplete -= _onDRThreadRenderComplete;
+    }
+
+    _waitingForDRThreadRenderComplete = false;
+    return null;
+}, null);
 
                 // Make sure to free up inking thread ref to ensure thread shuts down properly.
                 _renderingThread = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRendererThreadManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRendererThreadManager.cs
index 74ef3dff..e59eea94 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRendererThreadManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/DynamicRendererThreadManager.cs
@@ -261,7 +261,7 @@ void Dispose(bool disposing)
                         if (e.NativeErrorCode != 1400) // ERROR_INVALID_WINDOW_HANDLE
                         {
                             // This is an unlocalized string but it only prints on the Debug Console
-                            Debug.WriteLine(String.Format("Dispatcher.CriticalInvokeShutdown() Failed.  Error={0}", e.NativeErrorCode));
+                            Debug.WriteLine($"Dispatcher.CriticalInvokeShutdown() Failed.  Error={e.NativeErrorCode}");
                         }
                     }
                     finally
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusDevice.cs
index 8757e256..ac7afbce 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusDevice.cs
@@ -350,9 +350,8 @@ internal static IInputElement GlobalHitTest(PresentationSource inputSource, Poin
         internal static GeneralTransform GetElementTransform(IInputElement relativeTo)
         {
             GeneralTransform elementTransform = Transform.Identity;
-            DependencyObject doRelativeTo = relativeTo as DependencyObject;
 
-            if (doRelativeTo != null)
+            if (relativeTo is DependencyObject doRelativeTo)
             {
                 Visual visualFirstAncestor = VisualTreeHelper.GetContainingVisual2D(InputElement.GetContainingVisual(doRelativeTo));
                 Visual visualRoot = VisualTreeHelper.GetContainingVisual2D(InputElement.GetRootVisual(doRelativeTo));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusLogic.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusLogic.cs
index b95ad4d3..d8b5a87d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusLogic.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Common/StylusLogic.cs
@@ -377,14 +377,8 @@ protected void ReadSystemConfig()
             }
             finally
             {
-                if (stylusKey != null)
-                {
-                    stylusKey.Close();
-                }
-                if (touchKey != null)
-                {
-                    touchKey.Close();
-                }
+                stylusKey?.Close();
+                touchKey?.Close();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusDevice.cs
index a684599e..dae717ad 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusDevice.cs
@@ -571,9 +571,8 @@ internal override bool Capture(IInputElement element, CaptureMode captureMode)
             }
 
             // Validate that element is either a UIElement or a ContentElement
-            DependencyObject doStylusCapture = element as DependencyObject;
 
-            if (doStylusCapture != null && !InputElement.IsValid(element))
+            if (element is DependencyObject doStylusCapture && !InputElement.IsValid(element))
             {
                 throw new InvalidOperationException(SR.Get(SRID.Invalid_IInputElement, doStylusCapture.GetType()));
             }
@@ -1051,8 +1050,7 @@ internal void ChangeStylusCapture(IInputElement stylusCapture, CaptureMode captu
 
                 if (stylusCapture != null)
                 {
-                    UIElement uiElement = InputElement.GetContainingUIElement(stylusCapture as DependencyObject) as UIElement;
-                    if (uiElement != null)
+                    if (InputElement.GetContainingUIElement(stylusCapture as DependencyObject) is UIElement uiElement)
                     {
                         PresentationSource source = PresentationSource.CriticalFromVisual(uiElement as Visual);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusPlugInManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusPlugInManager.cs
index 0e86a28c..2b78ec00 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusPlugInManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Pointer/PointerStylusPlugInManager.cs
@@ -260,9 +260,8 @@ internal void VerifyStylusPlugInCollectionTarget(RawStylusInputReport rawStylusI
             bool updateEventPoints = false;
 
             // Make sure we use UIElement for target if non NULL and hit ContentElement.
-            UIElement newTarget = InputElement.GetContainingUIElement(rawStylusInputReport.StylusDevice.DirectlyOver as DependencyObject) as UIElement;
 
-            if (newTarget != null)
+            if (InputElement.GetContainingUIElement(rawStylusInputReport.StylusDevice.DirectlyOver as DependencyObject) is UIElement newTarget)
             {
                 targetPIC = FindPlugInCollection(newTarget);
             }
@@ -374,8 +373,7 @@ internal StylusPlugInCollection InvokeStylusPluginCollectionForMouse(RawStylusIn
             // Find new target plugin collection
             if (directlyOver != null)
             {
-                UIElement uiElement = InputElement.GetContainingUIElement(directlyOver as DependencyObject) as UIElement;
-                if (uiElement != null)
+                if (InputElement.GetContainingUIElement(directlyOver as DependencyObject) is UIElement uiElement)
                 {
                     newPlugInCollection = FindPlugInCollection(uiElement);
                 }
@@ -537,7 +535,7 @@ internal static void InvokePlugInsForMouse(ProcessInputEventArgs e)
                     mouseDevice = InputManager.UnsecureCurrent.PrimaryMouseDevice;
 
                     // Mouse set directly over to null when truly deactivating.
-                    if (mouseDevice == null || mouseDevice.DirectlyOver != null)
+                    if (mouseDevice?.DirectlyOver != null)
                         return;
 
                     leftButtonDown = mouseDevice.LeftButton == MouseButtonState.Pressed;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenContexts.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenContexts.cs
index 9b2577b6..aaa57380 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenContexts.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenContexts.cs
@@ -364,8 +364,7 @@ internal StylusPlugInCollection InvokeStylusPluginCollectionForMouse(RawStylusIn
                 // Find new target plugin collection
                 if (directlyOver != null)
                 {
-                    UIElement uiElement = InputElement.GetContainingUIElement(directlyOver as DependencyObject) as UIElement;
-                    if (uiElement != null)
+                    if (InputElement.GetContainingUIElement(directlyOver as DependencyObject) is UIElement uiElement)
                     {
                         newPlugInCollection = FindPlugInCollection(uiElement);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThread.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThread.cs
index 9f52699c..e38343c1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThread.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThread.cs
@@ -52,10 +52,7 @@ internal void Dispose()
         void DisposeHelper()
         {
             // NOTE: PenThreadWorker deals with already being disposed logic.
-            if (_penThreadWorker != null)
-            {
-                _penThreadWorker.Dispose();
-            }
+            _penThreadWorker?.Dispose();
             GC.KeepAlive(this);
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs
index 7f18965a..317a4eca 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/PenThreadWorker.cs
@@ -1015,9 +1015,8 @@ internal bool AddPenContext(PenContext penContext)
             {
                 if (_penContexts[i].IsAlive)
                 {
-                    PenContext pc = _penContexts[i].Target as PenContext;
                     // We only need to ref if we have a penContext.
-                    if (pc != null)
+                    if (_penContexts[i].Target is PenContext pc)
                     {
                         penContextRefs.Add(pc);
                     }
@@ -1043,7 +1042,7 @@ internal bool AddPenContext(PenContext penContext)
                 {
                     PenContext pc = penContextRefs[i];
                     // We'd have hole in our array if this ever happened.
-                    Debug.Assert(pc != null && pc.CommHandle != IntPtr.Zero);
+                    Debug.Assert(_penContexts[i].Target is PenContext pc && pc.CommHandle != IntPtr.Zero);
                     _handles[i] = pc.CommHandle; // Add to array.
                     _pimcContexts[i] = pc._pimcContext.Value;
                     _penContexts[i] = new WeakReference(pc);
@@ -1074,11 +1073,10 @@ internal bool RemovePenContext(PenContext penContext)
             {
                 if (_penContexts[i].IsAlive)
                 {
-                    PenContext pc = _penContexts[i].Target as PenContext;
                     // See if we should keep this PenContext.  
                     // We keep if not GC'd and not the removing one (except if it is 
                     // in range where we need to wait till it goes out of range).
-                    if (pc != null && (pc != penContext || pc.IsInRange(0)))
+                    if (_penContexts[i].Target is PenContext pc && (pc != penContext || pc.IsInRange(0)))
                     {
                         penContextRefs.Add(pc);
                     }
@@ -1097,7 +1095,7 @@ internal bool RemovePenContext(PenContext penContext)
             {
                 PenContext pc = penContextRefs[i];
                 // We'd have hole in our array if this ever happened.
-                Debug.Assert(pc != null && pc.CommHandle != IntPtr.Zero);
+                Debug.Assert(_penContexts[i].Target is PenContext pc && pc.CommHandle != IntPtr.Zero);
                 _handles[i] = pc.CommHandle; // Add to array.
                 _pimcContexts[i] = pc._pimcContext.Value;
                 _penContexts[i] = new WeakReference(pc);
@@ -1228,19 +1226,10 @@ internal void ThreadProc()
                         }
                         if (evt != PenEventTimeout)
                         {
-                            // dispatch the event
-#if TRACEPTW
-                            Debug.WriteLine (String.Format("PenThreadWorker::ThreadProc - FireEvent [evt={0}, stylusId={1}]", evt, stylusPointerId));
-#endif
-                            
-                            // This comment addresses and IndexOutOfRangeException in PenThreadWorker which is related and likely caused by the above.
-                            // This index is safe as long as there are no corruption issues within PenIMC.  There have been
-                            // instances of IndexOutOfRangeExceptions from this code but this should not occur in practice.
-                            // If this throws, check that the handles list generated in CPimcContext::GetPenEventMultiple
-                            // is not corrupted (it has appropriate wait handles and does not point to invalid memory).
-                            PenContext penContext = _penContexts[iHandleEvt].Target as PenContext;
+                            // dispatch the event#if TRACEPTW
+                            // This comment addresses and IndexOutOfRangeException in PenThreadWorker which is related and likely caused by the above.                            // This index is safe as long as there are no corruption issues within PenIMC.  There have been                            // instances of IndexOutOfRangeExceptions from this code but this should not occur in practice.                            // If this throws, check that the handles list generated in CPimcContext::GetPenEventMultiple                            // is not corrupted (it has appropriate wait handles and does not point to invalid memory).
                             // If we get an event from a GC'd PenContext then just ignore.
-                            if (penContext != null)
+                            if (_penContexts[iHandleEvt].Target is PenContext penContext)
                             {
                                 FireEvent(penContext, evt, stylusPointerId, cPackets, cbPacket, pPackets);
                                 penContext = null;
@@ -1257,8 +1246,7 @@ internal void ThreadProc()
                             // we are doing this to compinsate for drivers that send a move after they send a outofrange
                             for (int i = 0; i < _penContexts.Length; i++)
                             {
-                                PenContext penContext = _penContexts[i].Target as PenContext;
-                                if (penContext != null)
+                                if (_penContexts[iHandleEvt].Target is PenContext penContext)
                                 {
                                     // we send 0 as the stulyspointerId to trigger code in PenContext::FirePenOutOfRange
                                     penContext.FirePenOutOfRange(0, Environment.TickCount);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispLogic.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispLogic.cs
index f6f29da2..b09a7bd0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispLogic.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispLogic.cs
@@ -338,8 +338,7 @@ internal object InputManagerProcessInput(object oInput)
 
             // StylusDevice could have been disposed internally here.
             // We should check StylusDevice.IsValid property. 
-            if (rawStylusInputReport != null
-                && rawStylusInputReport.StylusDevice != null
+            if (rawStylusInputReport?.StylusDevice != null
                 && rawStylusInputReport.StylusDevice.IsValid)
             {
                 rawStylusInputReport.IsQueued = false;
@@ -468,9 +467,7 @@ private void PreProcessInput(object sender, PreProcessInputEventArgs e)
             {
                 if (e.StagingItem.Input.RoutedEvent == InputManager.PreviewInputReportEvent)
                 {
-                    InputReportEventArgs input = e.StagingItem.Input as InputReportEventArgs;
-
-                    if (input != null && !input.Handled)
+                    if (e.StagingItem.Input is InputReportEventArgs input && !input.Handled)
                     {
                         // See if we are in a DragDrop operation.  If so set our internal flag
                         // which stops us from promoting Stylus or Mouse events!
@@ -643,10 +640,8 @@ private void PreProcessInput(object sender, PreProcessInputEventArgs e)
                                         if ((actions & RawMouseActions.Button1Press) != 0 && CurrentStylusDevice != null &&
                                             !CurrentStylusDevice.InAir)
                                         {
-                                            // We can only Activate the window without flashing the tray icon for it when
-                                            // we are processing an Input message.  So we defer it till we see the mouse down.
-                                            HwndSource hwndSource = mouseInputReport.InputSource as HwndSource;
-                                            IntPtr hwnd = hwndSource != null ? hwndSource.CriticalHandle : IntPtr.Zero;
+                                            // We can only Activate the window without flashing the tray icon for it when                                            // we are processing an Input message.  So we defer it till we see the mouse down.
+                                            IntPtr hwnd = mouseInputReport.InputSource is HwndSource hwndSource ? hwndSource.CriticalHandle : IntPtr.Zero;
 
                                             // If we see a stylusdown and we are not the foreground window
                                             // and there's no capture then make sure we get activated.
@@ -1534,7 +1529,7 @@ private static bool IsTouchPromotionEvent(StylusEventArgs stylusEventArgs)
 
         private static bool IsTouchStylusDevice(WispStylusDevice stylusDevice)
         {
-            return (stylusDevice != null && stylusDevice.TabletDevice != null &&
+            return (stylusDevice?.TabletDevice != null &&
                 stylusDevice.TabletDevice.Type == TabletDeviceType.Touch);
         }
 
@@ -1682,8 +1677,7 @@ internal void PromoteStoredItemsToMouse(WispStylusTouchDevice touchDevice)
                     // input report call StylusDevice's PlaybackCachedDownInputReport OR else
                     // call PromoteMainToMouse method.
                     StagingAreaInputItem stagingItem = storedItems[i];
-                    InputReportEventArgs inputReportArgs = stagingItem.Input as InputReportEventArgs;
-                    if (inputReportArgs != null &&
+                    if (stagingItem.Input is InputReportEventArgs inputReportArgs &&
                         inputReportArgs.Report.Type == InputType.Mouse &&
                         !(inputReportArgs.Device is StylusDevice))
                     {
@@ -1725,8 +1719,7 @@ private void PromoteMainToMouse(StagingAreaInputItem stagingItem)
         {
             if (!stagingItem.Input.Handled)
             {
-                StylusEventArgs stylusArgs = stagingItem.Input as StylusEventArgs;
-                if (stylusArgs != null)
+                if (stagingItem.Input is StylusEventArgs stylusArgs)
                 {
                     WispStylusDevice stylusDevice = stylusArgs.StylusDevice.As<WispStylusDevice>();
 
@@ -1838,7 +1831,7 @@ void CallPlugInsForMouse(ProcessInputEventArgs e)
                     mouseDevice = _inputManager.Value.PrimaryMouseDevice;
 
                     // Mouse set directly over to null when truly deactivating.
-                    if (mouseDevice == null || mouseDevice.DirectlyOver != null)
+                    if (mouseDevice?.DirectlyOver != null)
                         return;
 
                     leftButtonDown = mouseDevice.LeftButton == MouseButtonState.Pressed;
@@ -2636,8 +2629,7 @@ private void VerifyStylusPlugInCollectionTarget(RawStylusInputReport rawStylusIn
             bool updateEventPoints = false;
 
             // Make sure we use UIElement for target if non NULL and hit ContentElement.
-            UIElement newTarget = InputElement.GetContainingUIElement(rawStylusInputReport.StylusDevice.DirectlyOver as DependencyObject) as UIElement;
-            if (newTarget != null)
+            if (InputElement.GetContainingUIElement(rawStylusInputReport.StylusDevice.DirectlyOver as DependencyObject) is UIElement newTarget)
             {
                 targetPIC = rawStylusInputReport.PenContext.Contexts.FindPlugInCollection(newTarget);
             }
@@ -2907,7 +2899,7 @@ private static bool InWindowClientRect(Point ptClient, PresentationSource inputS
 
             // Note: this only works for HWNDs for now.
             HwndSource source = inputSource as HwndSource;
-            if (source != null && source.CompositionTarget != null && !source.IsHandleNull)
+            if (source?.CompositionTarget != null && !source.IsHandleNull)
             {
                 Point ptScreen = PointUtil.ClientToScreen(ptClient, source);
                 IntPtr hwndHit = IntPtr.Zero;
@@ -3232,8 +3224,7 @@ internal bool ShouldConsiderStylusInRange(RawMouseInputReport mouseInputReport)
             if (Math.Abs(unchecked(timestamp - _lastInRangeTime)) <= 500)
                 return true;
 
-            HwndSource hwndSource = mouseInputReport.InputSource as HwndSource;
-            if (hwndSource != null)
+            if (mouseInputReport.InputSource is HwndSource hwndSource)
             {
                 PenContexts penContexts = GetPenContextsFromHwnd(hwndSource);
                 if (penContexts != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusDevice.cs
index bf933843..2a25f0e4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusDevice.cs
@@ -274,23 +274,17 @@ internal override bool Capture(IInputElement element, CaptureMode captureMode)
             }
 
             // Validate that element is either a UIElement or a ContentElement
-            DependencyObject doStylusCapture = element as DependencyObject;
-            if (doStylusCapture != null && !InputElement.IsValid(element))
+            if (element is DependencyObject doStylusCapture && !InputElement.IsValid(element))
             {
                 throw new InvalidOperationException(SR.Get(SRID.Invalid_IInputElement, doStylusCapture.GetType()));
             }
 
-            if (doStylusCapture != null)
-            {
-                doStylusCapture.VerifyAccess();
-            }
+            doStylusCapture?.VerifyAccess();
 
             bool success = false;
 
             // The element we are capturing to must be both enabled and visible.
-
-            UIElement e = element as UIElement;
-            if (e != null)
+            if (element is UIElement e)
             {
                 if (e.IsVisible || e.IsEnabled)
                 {
@@ -299,8 +293,7 @@ internal override bool Capture(IInputElement element, CaptureMode captureMode)
             }
             else
             {
-                ContentElement ce = element as ContentElement;
-                if (ce != null)
+                if (element is ContentElement ce)
                 {
                     if (ce.IsEnabled) // There is no IsVisible property for ContentElement
                     {
@@ -609,8 +602,7 @@ internal void ChangeStylusCapture(IInputElement stylusCapture, CaptureMode captu
                         _stylusCapturePlugInCollection = null;
                         if (stylusCapture != null)
                         {
-                            UIElement uiElement = InputElement.GetContainingUIElement(stylusCapture as DependencyObject) as UIElement;
-                            if (uiElement != null)
+                            if (InputElement.GetContainingUIElement(stylusCapture as DependencyObject) is UIElement uiElement)
                             {
                                 PresentationSource source = PresentationSource.CriticalFromVisual(uiElement as Visual);
 
@@ -1539,8 +1531,7 @@ private PresentationSource DetermineValidSource(PresentationSource inputSource,
                     DependencyObject containingVisual = InputElement.GetContainingVisual(_stylusCapture as DependencyObject);
                     PresentationSource capturedSource = PresentationSource.CriticalFromVisual(containingVisual);
 
-                    if (capturedSource != null &&
-                        capturedSource.CompositionTarget != null &&
+                    if (capturedSource?.CompositionTarget != null &&
                         !capturedSource.CompositionTarget.IsDisposed)
                     {
                         newSource = capturedSource; // Good new source to use!
@@ -1637,7 +1628,7 @@ private void UpdateStateForSystemGesture(SystemGesture gesture, RawStylusSystemG
                     // element you really flicked on.
 
                     // Only route the flick if we have data we can send.
-                    if (report != null && report.InputSource != null && _eventStylusPoints != null && _eventStylusPoints.Count > 0)
+                    if (report?.InputSource != null && _eventStylusPoints != null && _eventStylusPoints.Count > 0)
                     {
                         StylusPoint stylusPoint = _eventStylusPoints[_eventStylusPoints.Count - 1];
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusTouchDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusTouchDevice.cs
index d373c9d4..d559d3c0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusTouchDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispStylusTouchDevice.cs
@@ -106,10 +106,7 @@ protected override void OnManipulationEnded(bool cancel)
                 // rest of this touch cycle.
                 PromotingToOther = false;
             }
-            if (_storedStagingAreaItems != null)
-            {
-                _storedStagingAreaItems.Clear();
-            }
+            _storedStagingAreaItems?.Clear();
         }
 
         /// <summary>
@@ -137,10 +134,7 @@ protected override void OnActivateImpl()
 
         protected override void OnDeactivateImpl()
         {
-            if (_storedStagingAreaItems != null)
-            {
-                _storedStagingAreaItems.Clear();
-            }
+            _storedStagingAreaItems?.Clear();
 
             if (ActiveDeviceCount == 0)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDevice.cs
index 749549c5..30767b87 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDevice.cs
@@ -356,10 +356,7 @@ internal void DisposeOrDeferDisposal()
                 StylusDeviceCollection styluses = _stylusDeviceCollection;
                 _stylusDeviceCollection = null;
 
-                if (styluses != null)
-                {
-                    styluses.Dispose();
-                }
+                styluses?.Dispose();
 
                 _penThread = null;
                 _isDisposalPending = false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDeviceCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDeviceCollection.cs
index ca4a52e0..3df0579c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDeviceCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/Stylus/Wisp/WispTabletDeviceCollection.cs
@@ -113,8 +113,7 @@ private static bool IsWisptisRegistered()
 
             if (key != null)
             {
-                string sValDefault = valDefault as string;
-                if (sValDefault != null && sValDefault.LastIndexOf(valueToSearchFor, StringComparison.OrdinalIgnoreCase) != -1)
+                if (valDefault is string sValDefault && sValDefault.LastIndexOf(valueToSearchFor, StringComparison.OrdinalIgnoreCase) != -1)
                 {
                     fRegistered = true;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextCompositionManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextCompositionManager.cs
index 53471219..732456b5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextCompositionManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextCompositionManager.cs
@@ -645,10 +645,8 @@ private void PostProcessInput(object sender, ProcessInputEventArgs e)
                 }
             }
 
-            
             // Raw to StartComposition.
-            InputReportEventArgs input = e.StagingItem.Input as InputReportEventArgs;
-            if(input != null)
+            if(e.StagingItem.Input is InputReportEventArgs input)
             {
                 if(input.Report.Type == InputType.Text && input.RoutedEvent == InputManager.InputReportEvent)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextServicesContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextServicesContext.cs
index 6366dc24..9e34fb24 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextServicesContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TextServicesContext.cs
@@ -347,10 +347,7 @@ private void SetFocusOnDim(UnsafeNativeMethods.ITfDocumentMgr dim)
         {
             UnsafeNativeMethods.ITfThreadMgr threadmgr = ThreadManager;
 
-            if (threadmgr != null)
-            {
-                threadmgr.SetFocus(dim);
-            }
+            threadmgr?.SetFocus(dim);
         }
 
         // Start the transitory extestion for Cicero Level1/Level2 composition window support.
@@ -393,11 +390,7 @@ private void StopTransitoryExtension()
             {
                 UnsafeNativeMethods.ITfSource source;
                 source = _defaultTextStore.DocumentManager as UnsafeNativeMethods.ITfSource;
-                if (source != null)
-                {
-                    // DocumentManager only supports ITfSource on Longhorn, XP does not support it
-                    source.UnadviseSink(_defaultTextStore.TransitoryExtensionSinkCookie);
-                }
+                source?.UnadviseSink(_defaultTextStore.TransitoryExtensionSinkCookie);
                 _defaultTextStore.TransitoryExtensionSinkCookie = UnsafeNativeMethods.TF_INVALID_COOKIE;
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TouchDevice.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TouchDevice.cs
index b7fab0bd..92463fdd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TouchDevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Input/TouchDevice.cs
@@ -220,17 +220,14 @@ private IInputElement CriticalHitTest(Point point, bool isSynchronize)
                                 IInputElement ieTest = over;
                                 while ((ieTest != null) && (ieTest != _captured))
                                 {
-                                    UIElement eTest = ieTest as UIElement;
-
-                                    if (eTest != null)
+                                    if (ieTest is UIElement eTest)
                                     {
                                         ieTest = InputElement.GetContainingInputElement(eTest.GetUIParent(true));
                                     }
                                     else
                                     {
-                                        ContentElement ceTest = ieTest as ContentElement;
 
-                                        if (ceTest != null)
+                                        if (ieTest is ContentElement ceTest)
                                         {
                                             ieTest = InputElement.GetContainingInputElement(ceTest.GetUIParent(true));
                                         }
@@ -1064,8 +1061,7 @@ private RoutedEvent PromotePreviewToMain(RoutedEvent routedEvent, out bool forMa
 
         private UIElement GetManipulatableElement()
         {
-            UIElement element = InputElement.GetContainingUIElement(_directlyOver as DependencyObject) as UIElement;
-            if (element != null)
+            if (InputElement.GetContainingUIElement(_directlyOver as DependencyObject) is UIElement element)
             {
                 element = Manipulation.FindManipulationParent(element);
             }
@@ -1090,8 +1086,7 @@ private void PromoteMainToManipulation(UIElement manipulatableElement, TouchEven
             }
             else if ((routedEvent == Touch.GotTouchCaptureEvent) && !PromotingToManipulation)
             {
-                UIElement element = _captured as UIElement;
-                if (element != null && element.IsManipulationEnabled)
+                if (_captured is UIElement element && element.IsManipulationEnabled)
                 {
                     // When touch gets capture and if the captured element
                     // is manipulable, then add it as a manipulator to
@@ -1104,9 +1099,9 @@ private void PromoteMainToManipulation(UIElement manipulatableElement, TouchEven
             }
             else if ((routedEvent == Touch.LostTouchCaptureEvent) && PromotingToManipulation && _manipulatingElement != null)
             {
-                UIElement element = _manipulatingElement.Target as UIElement;
                 _manipulatingElement = null;
-                if (element != null)
+
+                if (_captured is UIElement element)
                 {
                     // When touch loses capture, remove it as a manipulator.
                     Manipulation.TryRemoveManipulator(element, this);
@@ -1140,10 +1135,7 @@ private static void AddActiveDevice(TouchDevice device)
 
         private static void RemoveActiveDevice(TouchDevice device)
         {
-            if (_activeDevices != null)
-            {
-                _activeDevices.Remove(device);
-            }
+            _activeDevices?.Remove(device);
         }
 
         internal static TouchPointCollection GetTouchPoints(IInputElement relativeTo)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndMouseInputProvider.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndMouseInputProvider.cs
index 99dc4847..d7a4cc5e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndMouseInputProvider.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndMouseInputProvider.cs
@@ -220,9 +220,8 @@ int IMouseInputProvider.GetIntermediatePoints(IInputElement relativeTo, Point[]
                 if (points != null && relativeTo != null)
                 {
                     DependencyObject containingVisual = InputElement.GetContainingVisual(relativeTo as DependencyObject);
-                    HwndSource inputSource = PresentationSource.FromDependencyObject(containingVisual) as HwndSource;
 
-                    if (inputSource != null)
+                    if (PresentationSource.FromDependencyObject(containingVisual) is HwndSource inputSource)
                     {
                         int nVirtualWidth  = UnsafeNativeMethods.GetSystemMetrics(SM.CXVIRTUALSCREEN);
                         int nVirtualHeight = UnsafeNativeMethods.GetSystemMetrics(SM.CYVIRTUALSCREEN);
@@ -302,11 +301,7 @@ int IMouseInputProvider.GetIntermediatePoints(IInputElement relativeTo, Point[]
 
                             // Translate the point from the root to the visual.
                             GeneralTransform gDown = inputSource.RootVisual.TransformToDescendant(VisualTreeHelper.GetContainingVisual2D(containingVisual));
-                            if (gDown != null)
-                            {
-                                //  should we throw if the point could not be transformed?
-                                gDown.TryTransform(currentPosition, out currentPosition);
-                            }
+                            gDown?.TryTransform(currentPosition, out currentPosition);
 
                             points[cpt++] = currentPosition;
                         }
@@ -1136,7 +1131,7 @@ private bool IsOurWindow(IntPtr hwnd)
                 // is under the mouse (even though they are reported to the window
                 // with keyboard focus)
                 MouseDevice mouse = _site.Value.CriticalInputManager.PrimaryMouseDevice;
-                if (mouse != null && mouse.CriticalActiveSource != null)
+                if (mouse?.CriticalActiveSource != null)
                 {
                     source = mouse.CriticalActiveSource;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndSource.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndSource.cs
index 6d5a542e..c9e5ac92 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndSource.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndSource.cs
@@ -603,9 +603,9 @@ private Visual RootVisualInternal
 
                     if(oldRoot != null)
                     {
-                        if(oldRoot is UIElement)
+                        if(oldRoot is UIElement uIElement)
                         {
-                            ((UIElement)oldRoot).LayoutUpdated -= new EventHandler(OnLayoutUpdated);
+                            uIElement.LayoutUpdated -= new EventHandler(OnLayoutUpdated);
                         }
 
                         UIElement.PropagateSuspendLayout(oldRoot);
@@ -687,8 +687,7 @@ internal static HwndSource CriticalFromHwnd(IntPtr hwnd)
             HwndSource hwndSource = null;
             foreach (PresentationSource source in PresentationSource.CriticalCurrentSources)
             {
-                HwndSource test = source as HwndSource;
-                if (test != null && test.CriticalHandle == hwnd)
+                if (source is HwndSource test && test.CriticalHandle == hwnd)
                 {
                     // Don't hand out a disposed source.
                     if (!test.IsDisposed)
@@ -796,9 +795,7 @@ internal override void OnLeaveMenuMode()
         /// </summary>
         private void OnLayoutUpdated(object obj, EventArgs args)
         {
-            UIElement root = _rootVisual.Value as UIElement;
-
-            if(root != null)
+            if(_rootVisual.Value is UIElement root)
             {
                 Size newSize = root.RenderSize;
                 if (   _previousSize == null
@@ -912,8 +909,7 @@ private NativeMethods.RECT AdjustWindowSize(Size newSize)
         // nearest int.  Otherwise round the size up to the next int.
         private void RoundDeviceSize(ref Point size)
         {
-            UIElement root = _rootVisual.Value as UIElement;
-            if (root != null && root.SnapsToDevicePixels)
+            if (_rootVisual.Value is UIElement root && root.SnapsToDevicePixels)
             {
                 size = new Point(DoubleUtil.DoubleToInt(size.X), DoubleUtil.DoubleToInt(size.Y));
             }
@@ -1974,8 +1970,7 @@ protected virtual bool TabIntoCore(TraversalRequest request)
                 throw new ArgumentNullException("request");
             }
 
-            UIElement root =_rootVisual.Value as UIElement;
-            if(root != null)
+            if(_rootVisual.Value is UIElement root)
             {
                 // atanask:
                 // request.Mode == FocusNavigationDirection.First will navigate to the fist tabstop including root
@@ -2375,7 +2370,6 @@ internal bool CriticalTranslateAccelerator(ref MSG msg, ModifierKeys modifiers)
 
                 bool hasFocus = HasFocus;
                 IKeyboardInputSink focusSink = (hasFocus || IsInExclusiveMenuMode) ? null : ChildSinkWithFocus;
-                IInputElement focusElement = focusSink as IInputElement;
                 // focusElement may be null, in which case Target is just "focus", but we use it only if it's an
                 // element within this HwndSource. It is possible that someone calls IKIS.TranslateAccelerator()
                 // on a nested HwndSource while the focus is somewhere entirely outside.
@@ -2386,7 +2380,8 @@ internal bool CriticalTranslateAccelerator(ref MSG msg, ModifierKeys modifiers)
                 if (focusElement == null && hasFocus)
                 {
                     focusElement = Keyboard.PrimaryDevice.FocusedElement;
-                    if (focusElement != null &&
+
+                    if (focusSink is IInputElement focusElement &&
                         PresentationSource.CriticalFromVisual((DependencyObject)focusElement) != this)
                     {
                         focusElement = null;
@@ -2396,7 +2391,7 @@ internal bool CriticalTranslateAccelerator(ref MSG msg, ModifierKeys modifiers)
                 try {
                     Keyboard.PrimaryDevice.ForceTarget = focusSink as IInputElement;
 
-                    if (focusElement != null)
+                    if (focusSink is IInputElement focusElement)
                     {
                         KeyEventArgs tunnelArgs = new KeyEventArgs(Keyboard.PrimaryDevice, this, msg.time, key);
                         tunnelArgs.ScanCode = scanCode;
@@ -2412,7 +2407,8 @@ internal bool CriticalTranslateAccelerator(ref MSG msg, ModifierKeys modifiers)
                         bubbleArgs.ScanCode = scanCode;
                         bubbleArgs.IsExtendedKey = isExtendedKey;
                         bubbleArgs.RoutedEvent=keyEvent;
-                        if(focusElement != null)
+
+                        if(focusSink is IInputElement focusElement)
                         {
                             focusElement.RaiseEvent(bubbleArgs);
                             handled = bubbleArgs.Handled;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndTarget.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndTarget.cs
index e6b3ead0..100d650c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndTarget.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/InterOp/HwndTarget.cs
@@ -1426,10 +1426,7 @@ internal static AutomationPeer EnsureAutomationPeer(Visual root, IntPtr handle)
                 peer = UIElementAutomationPeer.GetRootAutomationPeer(root, handle);
             }
 
-            if (peer != null)
-            {
-                peer.AddToAutomationEventList();
-            }
+            peer?.AddToAutomationEventList();
 
             return peer;
         }
@@ -1812,8 +1809,8 @@ private void RecursiveUpdateDpiFlagAndInvalidateMeasure(DependencyObject d, DpiR
                     RecursiveUpdateDpiFlagAndInvalidateMeasure(child, args);
                 }
             }
-            Visual visual = d as Visual;
-            if (visual != null)
+
+            if (d is Visual visual)
             {
                 visual.SetDpiScaleVisualFlags(args);
                 UIElement element = d as UIElement;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/LayoutManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/LayoutManager.cs
index 8aa71599..11bd8439 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/LayoutManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/LayoutManager.cs
@@ -577,8 +577,7 @@ internal override void invalidate(UIElement e)
         private static DispatcherOperationCallback _updateCallback = new DispatcherOperationCallback(UpdateLayoutCallback);
         private static object UpdateLayoutCallback(object arg)
         {
-            ContextLayoutManager ContextLayoutManager = arg as ContextLayoutManager;
-            if(ContextLayoutManager != null)
+            if(arg is ContextLayoutManager ContextLayoutManager)
                 ContextLayoutManager.UpdateLayout();
             return null;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Markup/XmlLanguageConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Markup/XmlLanguageConverter.cs
index eef09383..3c02847e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Markup/XmlLanguageConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Markup/XmlLanguageConverter.cs
@@ -82,8 +82,7 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                                            CultureInfo cultureInfo, 
                                            object source)
         {
-            string ietfLanguageTag = source as string;
-            if (ietfLanguageTag != null)
+            if (source is string ietfLanguageTag)
             {
                 return XmlLanguage.GetLanguage(ietfLanguageTag);
             }
@@ -118,8 +117,7 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                 throw new ArgumentNullException("destinationType");
             }
 
-            XmlLanguage xmlLanguage = value as XmlLanguage;
-            if (xmlLanguage != null)
+            if (value is XmlLanguage xmlLanguage)
             {
                 if (destinationType == typeof(string))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Animatable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Animatable.cs
index 207eae85..aff320df 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Animatable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Animatable.cs
@@ -51,13 +51,12 @@ public new Animatable Clone()
         internal void PropertyChanged(DependencyProperty dp)
         {
             AnimationStorage animationStorage = AnimationStorage.GetStorage(this, dp);
-            IndependentAnimationStorage independentAnimationStorage = animationStorage as IndependentAnimationStorage;
 
             // If this property is independently animated and currently has
             // animations all we need to do is update the animation resource
             // that represents this property value. Otherwise we need to invalidate
             // and and eventually update this whole object.
-            if (independentAnimationStorage != null)
+            if (animationStorage is IndependentAnimationStorage independentAnimationStorage)
             {
                 independentAnimationStorage.InvalidateResource();
             }
@@ -84,10 +83,7 @@ internal virtual void AddRefOnChannelAnimations(DUCE.Channel channel)
 
                     DUCE.IResource storage = storageObject as DUCE.IResource;
 
-                    if (storage != null)
-                    {
-                        storage.AddRefOnChannel(channel);
-                    }
+                    storage?.AddRefOnChannel(channel);
                 }
             }
         }
@@ -109,10 +105,7 @@ internal virtual void ReleaseOnChannelAnimations(DUCE.Channel channel)
 
                     DUCE.IResource storage = storageObject as DUCE.IResource;
 
-                    if (storage != null)
-                    {
-                        storage.ReleaseOnChannel(channel);
-                    }
+                    storage?.ReleaseOnChannel(channel);
                 }
             }
         }
@@ -170,18 +163,12 @@ internal virtual void ReleaseOnChannelAnimations(DUCE.Channel channel)
         // overloads.
         internal void AddRefResource(DUCE.IResource resource, DUCE.Channel channel)
         {
-            if (resource != null)
-            {
-                resource.AddRefOnChannel(channel);
-            }
+            resource?.AddRefOnChannel(channel);
         }
 
         internal void ReleaseResource(DUCE.IResource resource, DUCE.Channel channel)
         {
-            if (resource != null)
-            {
-                resource.ReleaseOnChannel(channel);
-            }
+            resource?.ReleaseOnChannel(channel);
         }
 
         #endregion LocalProperty/CachedValue stuff
@@ -347,9 +334,7 @@ internal bool IsBaseValueDefault(DependencyProperty dp)
         /// </summary>
         internal void RegisterForAsyncUpdateResource()
         {
-            DUCE.IResource resource = this as DUCE.IResource;
-
-            if (resource != null)
+            if (this is DUCE.IResource resource)
             {
                 if ((Dispatcher != null) && Animatable_IsResourceInvalidationNecessary)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/AnimationStorage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/AnimationStorage.cs
index c8299ea8..4a168030 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/AnimationStorage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/AnimationStorage.cs
@@ -123,9 +123,7 @@ internal void Initialize(DependencyObject d, DependencyProperty dp)
             Debug.Assert(_dependencyObject == null);
             Debug.Assert(_dependencyProperty == null);
 
-            Animatable a = d as Animatable;
-
-            if (a != null)
+            if (d is Animatable a)
             {
                 _dependencyObject = a.GetWeakReference();
             }
@@ -214,20 +212,14 @@ internal void WritePostscript()
                     // newly animated property will be passed across to the UCE.
                     Animatable a = d as Animatable;
 
-                    if (a != null)
-                    {
-                        a.RegisterForAsyncUpdateResource();
-                    }
+                    a?.RegisterForAsyncUpdateResource();
 
-                    // If this AnimationStorage is a resource, add it to the
-                    // channel now.
-                    DUCE.IResource animationResource = this as DUCE.IResource;
+                    // If this AnimationStorage is a resource, add it to the                    // channel now.
 
-                    if (animationResource != null)
+                    if (this is DUCE.IResource animationResource)
                     {
-                        DUCE.IResource targetResource = d as DUCE.IResource;
 
-                        if (targetResource != null)
+                        if (d is DUCE.IResource targetResource)
                         {
                             using (CompositionEngineLock.Acquire())
                             {
@@ -253,15 +245,11 @@ internal void WritePostscript()
 
                 if (IsEmpty)
                 {
-                    // If this AnimationStorage is a resource, release it from
-                    // the channel now.
-                    DUCE.IResource animationResource = this as DUCE.IResource;
+                    // If this AnimationStorage is a resource, release it from                    // the channel now.
 
-                    if (animationResource != null)
+                    if (this is DUCE.IResource animationResource)
                     {
-                        DUCE.IResource targetResource = d as DUCE.IResource;
-
-                        if (targetResource != null)
+                        if (d is DUCE.IResource targetResource)
                         {
                             using (CompositionEngineLock.Acquire())
                             {
@@ -285,10 +273,7 @@ internal void WritePostscript()
                     // across to the UCE.
                     Animatable a = d as Animatable;
 
-                    if (a != null)
-                    {
-                        a.RegisterForAsyncUpdateResource();
-                    }
+                    a?.RegisterForAsyncUpdateResource();
 
                     animatedPropertyMap[_dependencyProperty.GlobalIndex] = DependencyProperty.UnsetValue;
 
@@ -410,8 +395,7 @@ private void OnCurrentTimeInvalidated(object sender, EventArgs args)
                         value = oldEntry.ModifiedValue.BaseValue;
                         if (oldEntry.IsDeferredReference)
                         {
-                            DeferredReference dr = value as DeferredReference;
-                            if (dr != null)
+                            if (value is DeferredReference dr)
                             {
                                 value = dr.GetValue(newEntry.BaseValueSourceInternal);
                             }
@@ -424,8 +408,7 @@ private void OnCurrentTimeInvalidated(object sender, EventArgs args)
                             value = oldEntry.ModifiedValue.ExpressionValue;
                             if (oldEntry.IsDeferredReference)
                             {
-                                DeferredReference dr = value as DeferredReference;
-                                if (dr != null)
+                                if (value is DeferredReference dr)
                                 {
                                     value = dr.GetValue(newEntry.BaseValueSourceInternal);
                                 }
@@ -1036,9 +1019,7 @@ private void ClearAnimations()
                 return false;
             }
 
-            UIPropertyMetadata uiMetadata = dp.GetMetadata(d.DependencyObjectType) as UIPropertyMetadata;
-
-            if (   uiMetadata != null
+            if (   dp.GetMetadata(d.DependencyObjectType) is UIPropertyMetadata uiMetadata
                 && uiMetadata.IsAnimationProhibited)
             {
                 return false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Clock.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Clock.cs
index 4d8135f0..d6d2a3fc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Clock.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Clock.cs
@@ -589,8 +589,7 @@ internal virtual void AddNullPointToCurrentIntervals()
             ClockGroup clockGroup = clock as ClockGroup;
 
             if (   clock._parent != null
-                || (   clockGroup != null
-                    && clockGroup.InternalChildren != null ))
+                || (   clockGroup?.InternalChildren != null ))
             {
                 // The derived class is trying to fool us -- we require a new,
                 // fresh, unassociated clock here
@@ -3718,13 +3717,7 @@ private void NotifyNewEarliestFutureActivity()
                 current = current._parent;  
             }
 
-            if (_timeManager != null)
-            {
-                // If we get here from within a Tick, this will force MediaContext to perform another subsequent Tick
-                // on the TimeManager.  This will apply the requested interactive operations, so their results will
-                // immediately become visible.
-                _timeManager.SetDirty();
-            }
+            _timeManager?.SetDirty();
         }
 
 
@@ -3843,10 +3836,7 @@ private void UpdateNeedsTicksWhenActive()
         // This wrapper is invoked anytime we invalidate the _beginTime
         private void UpdateSyncBeginTime()
         {
-            if (_syncData != null)
-            {
-                _syncData.UpdateClockBeginTime();
-            }
+            _syncData?.UpdateClockBeginTime();
         }
 
         private void VerifyNeedsTicksWhenActive()
@@ -4287,9 +4277,8 @@ internal void BuildInfoRecursive(System.Text.StringBuilder builder, int depth)
             BuildInfo(builder, depth, false);
 
             // Recurse into the children
-            ClockGroup thisGroup = this as ClockGroup;
 
-            if (thisGroup != null)
+            if (this is ClockGroup thisGroup)
             {
                 depth++;
                 List<Clock> children = thisGroup.InternalChildren;
@@ -4323,10 +4312,7 @@ internal void RootBuildInfoRecursive(System.Text.StringBuilder builder)
             {
                 Clock child = (Clock)children[index].Target;
 
-                if (child != null)
-                {
-                    child.BuildInfoRecursive(builder, 1);
-                }
+                child?.BuildInfoRecursive(builder, 1);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ClockGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ClockGroup.cs
index 6a64356d..4522f99a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ClockGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ClockGroup.cs
@@ -264,9 +264,9 @@ internal void ComputeTreeStateRoot()
 
                 if (current.NeedsPostfixTraversal)
                 {
-                    if (current is ClockGroup)
+                    if (current is ClockGroup clockGroup)
                     {
-                        ((ClockGroup)current).ComputeTreeStatePostfix();
+                        clockGroup.ComputeTreeStatePostfix();
                     }
                     current.ApplyDesiredFrameRateToNextTick();  // Apply the effects of DFR on each root as needed
                     current.NeedsPostfixTraversal = false;  // Reset the flag
@@ -297,8 +297,7 @@ private void ComputeTreeStatePostfix()
                 {
                     if (_children[c].NeedsPostfixTraversal)  // Traverse deeper if this is part of the visited tree subset
                     {
-                        ClockGroup group = _children[c] as ClockGroup;
-                        Debug.Assert(group != null);  // We should only have this flag set for ClockGroups
+                        Debug.Assert(_children[c] is ClockGroup group);  // We should only have this flag set for ClockGroups
 
                         group.ComputeTreeStatePostfix();
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Animatable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Animatable.cs
index 992f1405..e311881b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Animatable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Animatable.cs
@@ -241,10 +241,7 @@ public object GetAnimationBaseValue(DependencyProperty dp)
             {
                 AnimationStorage storage = AnimationStorage.GetStorage(this, dp);
 
-                if (storage != null)
-                {
-                    storage.EvaluateAnimatedValue(metadata, ref entry);                      
-                }
+                storage?.EvaluateAnimatedValue(metadata, ref entry);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/BooleanAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/BooleanAnimationUsingKeyFrames.cs
index 913366a7..f9f37b82 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/BooleanAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/BooleanAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            BooleanKeyFrame keyFrame = child as BooleanKeyFrame;
-
-            if (keyFrame != null)
+            if (child is BooleanKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ByteAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ByteAnimationUsingKeyFrames.cs
index 60b9a33c..f264bcf2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ByteAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ByteAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            ByteKeyFrame keyFrame = child as ByteKeyFrame;
-
-            if (keyFrame != null)
+            if (child is ByteKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/CharAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/CharAnimationUsingKeyFrames.cs
index 3a42a03d..93675453 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/CharAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/CharAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            CharKeyFrame keyFrame = child as CharKeyFrame;
-
-            if (keyFrame != null)
+            if (child is CharKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ColorAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ColorAnimationUsingKeyFrames.cs
index b5311f5e..1a6e1855 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ColorAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ColorAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            ColorKeyFrame keyFrame = child as ColorKeyFrame;
-
-            if (keyFrame != null)
+            if (child is ColorKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DecimalAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DecimalAnimationUsingKeyFrames.cs
index 3ec24e59..dab5809d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DecimalAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DecimalAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            DecimalKeyFrame keyFrame = child as DecimalKeyFrame;
-
-            if (keyFrame != null)
+            if (child is DecimalKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DoubleAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DoubleAnimationUsingKeyFrames.cs
index 29083018..1d589690 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DoubleAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/DoubleAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            DoubleKeyFrame keyFrame = child as DoubleKeyFrame;
-
-            if (keyFrame != null)
+            if (child is DoubleKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int16AnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int16AnimationUsingKeyFrames.cs
index dce8677f..20a453b0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int16AnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int16AnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            Int16KeyFrame keyFrame = child as Int16KeyFrame;
-
-            if (keyFrame != null)
+            if (child is Int16KeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int32AnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int32AnimationUsingKeyFrames.cs
index d4ec1409..ea6faaa1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int32AnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int32AnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            Int32KeyFrame keyFrame = child as Int32KeyFrame;
-
-            if (keyFrame != null)
+            if (child is Int32KeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int64AnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int64AnimationUsingKeyFrames.cs
index 5b90b9b9..938c56c7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int64AnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Int64AnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            Int64KeyFrame keyFrame = child as Int64KeyFrame;
-
-            if (keyFrame != null)
+            if (child is Int64KeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/MatrixAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/MatrixAnimationUsingKeyFrames.cs
index e71db6e1..0c0f9c1c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/MatrixAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/MatrixAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            MatrixKeyFrame keyFrame = child as MatrixKeyFrame;
-
-            if (keyFrame != null)
+            if (child is MatrixKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ObjectAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ObjectAnimationUsingKeyFrames.cs
index b5774bef..a91b7f10 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ObjectAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/ObjectAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            ObjectKeyFrame keyFrame = child as ObjectKeyFrame;
-
-            if (keyFrame != null)
+            if (child is ObjectKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Point3DAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Point3DAnimationUsingKeyFrames.cs
index 5b7ca01c..14b771cd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Point3DAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Point3DAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            Point3DKeyFrame keyFrame = child as Point3DKeyFrame;
-
-            if (keyFrame != null)
+            if (child is Point3DKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/PointAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/PointAnimationUsingKeyFrames.cs
index 53ae08ee..3baa7afd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/PointAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/PointAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            PointKeyFrame keyFrame = child as PointKeyFrame;
-
-            if (keyFrame != null)
+            if (child is PointKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/QuaternionAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/QuaternionAnimationUsingKeyFrames.cs
index 60a2211f..d7598369 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/QuaternionAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/QuaternionAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            QuaternionKeyFrame keyFrame = child as QuaternionKeyFrame;
-
-            if (keyFrame != null)
+            if (child is QuaternionKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/RectAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/RectAnimationUsingKeyFrames.cs
index 9ce973e2..0b12f24a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/RectAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/RectAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            RectKeyFrame keyFrame = child as RectKeyFrame;
-
-            if (keyFrame != null)
+            if (child is RectKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Rotation3DAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Rotation3DAnimationUsingKeyFrames.cs
index ba3775d3..db140862 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Rotation3DAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Rotation3DAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            Rotation3DKeyFrame keyFrame = child as Rotation3DKeyFrame;
-
-            if (keyFrame != null)
+            if (child is Rotation3DKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SingleAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SingleAnimationUsingKeyFrames.cs
index 32ea6fe0..8ada28ec 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SingleAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SingleAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            SingleKeyFrame keyFrame = child as SingleKeyFrame;
-
-            if (keyFrame != null)
+            if (child is SingleKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SizeAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SizeAnimationUsingKeyFrames.cs
index 2ecf97ca..6606e6ea 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SizeAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/SizeAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            SizeKeyFrame keyFrame = child as SizeKeyFrame;
-
-            if (keyFrame != null)
+            if (child is SizeKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/StringAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/StringAnimationUsingKeyFrames.cs
index 37dd960e..0ef85764 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/StringAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/StringAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            StringKeyFrame keyFrame = child as StringKeyFrame;
-
-            if (keyFrame != null)
+            if (child is StringKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Vector3DAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Vector3DAnimationUsingKeyFrames.cs
index 668afa88..77fb9bcb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Vector3DAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/Vector3DAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            Vector3DKeyFrame keyFrame = child as Vector3DKeyFrame;
-
-            if (keyFrame != null)
+            if (child is Vector3DKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/VectorAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/VectorAnimationUsingKeyFrames.cs
index 70d63443..46ead87d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/VectorAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Generated/VectorAnimationUsingKeyFrames.cs
@@ -231,9 +231,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            VectorKeyFrame keyFrame = child as VectorKeyFrame;
-
-            if (keyFrame != null)
+            if (child is VectorKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeySplineConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeySplineConverter.cs
index 4e8b0e0b..22881ebf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeySplineConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeySplineConverter.cs
@@ -102,9 +102,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             object value, 
             Type destinationType)
         {
-            KeySpline keySpline = value as KeySpline;
-
-            if (keySpline != null && destinationType != null)
+            if (value is KeySpline keySpline && destinationType != null)
             {
                 if (destinationType == typeof(InstanceDescriptor))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTime.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTime.cs
index 40515294..db526d85 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTime.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTime.cs
@@ -177,8 +177,7 @@ public bool Equals(KeyTime value)
         /// </summary>
         public override bool Equals(object value)
         {
-            if (   value == null
-                || !(value is KeyTime))
+            if (   !(value is KeyTime))
             {
                 return false;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTimeConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTimeConverter.cs
index eecb78bb..c3ee1dd4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTimeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/KeyTimeConverter.cs
@@ -74,9 +74,7 @@ public class KeyTimeConverter : TypeConverter
             CultureInfo cultureInfo, 
             object value)
         {
-            string stringValue = value as string;
-
-            if (stringValue != null)
+            if (value is string stringValue)
             {
                 stringValue = stringValue.Trim();
 
@@ -138,11 +136,8 @@ public class KeyTimeConverter : TypeConverter
             object value, 
             Type destinationType)
         {
-            if (   value != null
-                && value is KeyTime)
+            if (   value is KeyTime keyTime)
             {
-                KeyTime keyTime = (KeyTime)value;
-
                 if (destinationType == typeof(InstanceDescriptor))
                 {
                     MemberInfo mi;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ParallelTimeline.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ParallelTimeline.cs
index 04927362..7a3f1396 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ParallelTimeline.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/ParallelTimeline.cs
@@ -90,9 +90,7 @@ protected override Duration GetNaturalDurationCore(Clock clock)
         {
             Duration simpleDuration = TimeSpan.Zero;
 
-            ClockGroup clockGroup = clock as ClockGroup;
-
-            if (clockGroup != null)
+            if (clock is ClockGroup clockGroup)
             {
                 List<Clock> children = clockGroup.InternalChildren;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehavior.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehavior.cs
index 97eb8748..29dc5b0f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehavior.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehavior.cs
@@ -170,9 +170,9 @@ public TimeSpan Duration
         /// <returns>true if value is a RepeatBehavior and is equal to this instance; otherwise false.</returns>
         public override bool Equals(Object value)
         {
-            if (value is RepeatBehavior)
+            if (value is RepeatBehavior repeatBehavior)
             {
-                return this.Equals((RepeatBehavior)value);
+                return this.Equals(repeatBehavior);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehaviorConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehaviorConverter.cs
index 4e64b104..39adbcf6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehaviorConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/RepeatBehaviorConverter.cs
@@ -70,9 +70,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             CultureInfo cultureInfo, 
             object value)
         {
-            string stringValue = value as string;
-
-            if (stringValue != null)
+            if (value is string stringValue)
             {
                 stringValue = stringValue.Trim();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Subtree.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Subtree.cs
index afb99ab7..686f0569 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Subtree.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Subtree.cs
@@ -84,8 +84,7 @@ public bool MoveNext()
                     // Start with the root's first child
                     if (_rootClock != null)
                     {
-                        ClockGroup rootClockGroup = _rootClock as ClockGroup;
-                        if (rootClockGroup != null)
+                        if (_rootClock is ClockGroup rootClockGroup)
                         {
                             _currentClock = rootClockGroup.FirstChild;
                         }
@@ -344,13 +343,12 @@ public bool MoveNext()
             else if (_timelineStack.Count > 0)
             {
                 // Only TimelineGroup can have children
-                TimelineGroup timelineGroup = _timelineStack.Peek() as TimelineGroup;
 
                 // The next timeline is possibly the first child of the current timeline
                 // If we have children move to the first one, unless we were
                 // asked to skip the subtree
                 if (  ((_flags & SubtreeFlag.SkipSubtree) == 0) 
-                    && timelineGroup != null 
+                    && _timelineStack.Peek() is TimelineGroup timelineGroup 
                     && (children = timelineGroup.Children) != null
                     && children.Count > 0
                     )
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimeManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimeManager.cs
index 5a2a876d..4e32d9a4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimeManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimeManager.cs
@@ -631,10 +631,7 @@ private void RaiseEnqueuedEvents()
                 WeakReference instance = _eventQueue.Dequeue();
                 Clock clock = (Clock)instance.Target;
 
-                if (clock != null)
-                {
-                    clock.RaiseAccumulatedEvents();
-                }
+                clock?.RaiseAccumulatedEvents();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Timeline.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Timeline.cs
index 8b40e4bf..1336f56c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Timeline.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/Timeline.cs
@@ -1044,9 +1044,8 @@ internal void BuildInfoRecursive(System.Text.StringBuilder builder, int depth)
 
             // Recurse into the children
             depth++;
-            TimelineGroup timelineGroup = this as TimelineGroup;
 
-            if (timelineGroup != null)
+            if (this is TimelineGroup timelineGroup)
             {
                 TimelineCollection children = timelineGroup.Children;
                 if (children != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimelineClockCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimelineClockCollection.cs
index 95beead2..e7015583 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimelineClockCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Animation/TimelineClockCollection.cs
@@ -129,19 +129,12 @@ public bool Contains(Clock item)
         /// </param>
         public void CopyTo(Clock[] array, int index)
         {
-//             _owner.VerifyAccess();
-
-            ClockGroup clockGroup = _owner as ClockGroup;
 
-            if (clockGroup != null)
+            if (_owner is ClockGroup clockGroup)
             {
                 List<Clock> list = clockGroup.InternalChildren;
 
-                if (list != null)
-                {
-                    // Get free parameter validation from Array.Copy
-                    list.CopyTo(array, index);
-                }
+                list?.CopyTo(array, index);
             }
 
             // Need to perform parameter validation in the list == null case
@@ -166,9 +159,8 @@ IEnumerator<Clock> IEnumerable<Clock>.GetEnumerator()
 //             _owner.VerifyAccess();
 
             List<Clock> list = null;
-            ClockGroup clockGroup = _owner as ClockGroup;
 
-            if (clockGroup != null)
+            if (_owner is ClockGroup clockGroup)
             {
                 list = clockGroup.InternalChildren;
             }
@@ -401,7 +393,7 @@ public bool MoveNext()
 
                 ClockGroup clockGroup = _owner as ClockGroup;
 
-                if (clockGroup != null && clockGroup.InternalChildren != null)
+                if (clockGroup?.InternalChildren != null)
                 {
                     throw new InvalidOperationException(SR.Get(SRID.Timing_EnumeratorInvalidated));
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/BitmapCacheBrush.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/BitmapCacheBrush.cs
index e5376755..dbd3076e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/BitmapCacheBrush.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/BitmapCacheBrush.cs
@@ -158,18 +158,12 @@ void ICyclicBrush.RenderForCyclicBrush(DUCE.Channel channel, bool skipChannelChe
         // to be specialized for Visual which doesn't implement DUCE.IResource
         internal void AddRefResource(Visual visual, DUCE.Channel channel)
         {
-            if (visual != null)
-            {
-                visual.AddRefOnChannelForCyclicBrush(this, channel);
-            }
+            visual?.AddRefOnChannelForCyclicBrush(this, channel);
         }
 
         internal void ReleaseResource(Visual visual, DUCE.Channel channel)
         {
-            if (visual != null)
-            {
-                visual.ReleaseOnChannelForCyclicBrush(this, channel);
-            }
+            visual?.ReleaseOnChannelForCyclicBrush(this, channel);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetrics.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetrics.cs
index c185b381..96013791 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetrics.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetrics.cs
@@ -284,12 +284,11 @@ public double BottomSideBearing
         /// </summary>
         public override bool Equals(object obj)
         {
-            CharacterMetrics other = obj as CharacterMetrics;
 
             // Suppress PRESharp warning that other can be null; apparently PRESharp
             // doesn't understand short circuit evaluation of operator &&.
             #pragma warning disable 6506
-            return other != null &&
+            return obj is CharacterMetrics other &&
                 other._blackBoxWidth == _blackBoxWidth &&
                 other._blackBoxHeight == _blackBoxHeight &&
                 other._leftSideBearing == _leftSideBearing &&
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetricsDictionary.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetricsDictionary.cs
index 7bb86126..fbbbc23c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetricsDictionary.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CharacterMetricsDictionary.cs
@@ -203,8 +203,7 @@ void SC.ICollection.CopyTo(Array array, int index)
             if (Count > array.Length - index)
                 throw new ArgumentException(SR.Get(SRID.Collection_CopyTo_NumberOfElementsExceedsArrayLength, index, "array"));
 
-            SC.DictionaryEntry[] typedArray = array as SC.DictionaryEntry[];
-            if (typedArray != null)
+            if (array is SC.DictionaryEntry[] typedArray)
             {
                 // it's an array of the exact type
                 foreach (KeyValuePair<int, CharacterMetrics> item in this)
@@ -325,9 +324,9 @@ bool SC.IDictionary.Contains(object key)
 
         void SC.IDictionary.Remove(object key)
         {
-            if (key is int)
+            if (key is int i)
             {
-                RemoveValue((int)key, null);
+                RemoveValue(i, null);
             }
         }
         #endregion
@@ -509,16 +508,15 @@ internal static int ConvertKey(object key)
 
             int value;
 
-            string s = key as string;
-            if (s != null)
+            if (key is string s)
             {
                 int i = 0;
                 if (!FontFamilyMap.ParseHexNumber(s, ref i, out value) || i < s.Length)
                     throw new ArgumentException(SR.Get(SRID.CannotConvertStringToType, s, "int"), "key");
             }
-            else if (key is int)
+            else if (key is int i)
             {
-                value = (int)key;
+                value = i;
             }
             else
             {
@@ -533,8 +531,7 @@ internal static int ConvertKey(object key)
 
         private CharacterMetrics ConvertValue(object value)
         {
-            CharacterMetrics metrics = value as CharacterMetrics;
-            if (metrics != null)
+            if (value is CharacterMetrics metrics)
                 return metrics;
 
             if (value != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Color.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Color.cs
index 637ac105..2578328a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Color.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Color.cs
@@ -699,10 +699,8 @@ public bool Equals(Color color)
         /// <returns>Whether or not the two colors are equal</returns>
         public override bool Equals(object o)
         {
-            if (o is Color)
+            if (o is Color color)
             {
-                Color color = (Color)o;
-
                 return (this == color);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/BrushValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/BrushValueSerializer.cs
index 27850ba4..c91df68c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/BrushValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/BrushValueSerializer.cs
@@ -92,9 +92,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Brush)
+            if (value is Brush instance)
             {
-                Brush instance = (Brush) value;
                 // When invoked by the serialization engine we can convert to string only for some instances
                 #pragma warning suppress 6506 // instance is obviously not null
                 if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/CacheModeValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/CacheModeValueSerializer.cs
index 2b20f352..0d8c7573 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/CacheModeValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/CacheModeValueSerializer.cs
@@ -92,9 +92,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is CacheMode)
+            if (value is CacheMode instance)
             {
-                CacheMode instance = (CacheMode) value;
                 // When invoked by the serialization engine we can convert to string only for some instances
                 #pragma warning suppress 6506 // instance is obviously not null
                 if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/DoubleCollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/DoubleCollectionValueSerializer.cs
index 692b6557..23ce95f1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/DoubleCollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/DoubleCollectionValueSerializer.cs
@@ -89,10 +89,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is DoubleCollection)
+            if (value is DoubleCollection instance)
             {
-                DoubleCollection instance = (DoubleCollection) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/GeometryValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/GeometryValueSerializer.cs
index 62db5654..937efd39 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/GeometryValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/GeometryValueSerializer.cs
@@ -92,9 +92,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Geometry)
+            if (value is Geometry instance)
             {
-                Geometry instance = (Geometry) value;
                 // When invoked by the serialization engine we can convert to string only for some instances
                 #pragma warning suppress 6506 // instance is obviously not null
                 if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/Int32CollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/Int32CollectionValueSerializer.cs
index 6bda836c..16c0d3ec 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/Int32CollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/Int32CollectionValueSerializer.cs
@@ -89,10 +89,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Int32Collection)
+            if (value is Int32Collection instance)
             {
-                Int32Collection instance = (Int32Collection) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PathFigureCollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PathFigureCollectionValueSerializer.cs
index eb6fc870..0f8d9708 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PathFigureCollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PathFigureCollectionValueSerializer.cs
@@ -92,9 +92,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is PathFigureCollection)
+            if (value is PathFigureCollection instance)
             {
-                PathFigureCollection instance = (PathFigureCollection) value;
                 // When invoked by the serialization engine we can convert to string only for some instances
                 #pragma warning suppress 6506 // instance is obviously not null
                 if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PointCollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PointCollectionValueSerializer.cs
index 7d51826a..2a8d986f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PointCollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/PointCollectionValueSerializer.cs
@@ -89,10 +89,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is PointCollection)
+            if (value is PointCollection instance)
             {
-                PointCollection instance = (PointCollection) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/TransformValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/TransformValueSerializer.cs
index ff4962a0..fd2ef607 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/TransformValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/TransformValueSerializer.cs
@@ -92,9 +92,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Transform)
+            if (value is Transform instance)
             {
-                Transform instance = (Transform) value;
                 // When invoked by the serialization engine we can convert to string only for some instances
                 #pragma warning suppress 6506 // instance is obviously not null
                 if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/VectorCollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/VectorCollectionValueSerializer.cs
index 83601e0d..2e2e305c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/VectorCollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Converters/Generated/VectorCollectionValueSerializer.cs
@@ -89,10 +89,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is VectorCollection)
+            if (value is VectorCollection instance)
             {
-                VectorCollection instance = (VectorCollection) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CultureSpecificStringDictionary.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CultureSpecificStringDictionary.cs
index d0668caf..709c2e77 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CultureSpecificStringDictionary.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/CultureSpecificStringDictionary.cs
@@ -169,8 +169,7 @@ void SC.ICollection.CopyTo(Array array, int index)
             if (_innerDictionary.Count > array.Length - index)
                 throw new ArgumentException(SR.Get(SRID.Collection_CopyTo_NumberOfElementsExceedsArrayLength, index, "array"));
 
-            SC.DictionaryEntry[] typedArray = array as SC.DictionaryEntry[];
-            if (typedArray != null)
+            if (array is SC.DictionaryEntry[] typedArray)
             {
                 // it's an array of the exact type
                 foreach (KeyValuePair<XmlLanguage, string> item in _innerDictionary)
@@ -353,12 +352,10 @@ private XmlLanguage ConvertKey(object key)
         // Convert a key to an XmlLanguage, and return null on failure
         private XmlLanguage TryConvertKey(object key)
         {
-            XmlLanguage language = key as XmlLanguage;
-            if (language != null)
+            if (key is XmlLanguage language)
                 return language;
 
-            string name = key as string;
-            if (name != null)
+            if (key is string name)
                 return XmlLanguage.GetLanguage(name);
 
             return null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingServices.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingServices.cs
index 271a6367..c0622b2d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingServices.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingServices.cs
@@ -87,23 +87,9 @@ internal static DrawingGroup DrawingGroupFromRenderData(RenderData renderData)
 
             DrawingContext dc = drawingGroup.Open();
 
-            //
-            // Create a DrawingGroup from the RenderData by walking
-            // the RenderData & having it forward it's base value's
-            // and animations to DrawingGroup
-            //
-
-            //
-            // The Drawing tree we're about to produce should not be an inheritance context,
-            // since that would place all mutable Freezables in the render data into shared
-            // state, which would in turn case them to lose their inheritance context entirely.
-            // This is controlled by setting "CanBeInheritanceContext" to false on the
-            // DrawingContext which will then be applied to all new objects it creates.
-            //
-
-            DrawingDrawingContext ddc = dc as DrawingDrawingContext;
+            //            // Create a DrawingGroup from the RenderData by walking            // the RenderData & having it forward it's base value's            // and animations to DrawingGroup            //            //            // The Drawing tree we're about to produce should not be an inheritance context,            // since that would place all mutable Freezables in the render data into shared            // state, which would in turn case them to lose their inheritance context entirely.            // This is controlled by setting "CanBeInheritanceContext" to false on the            // DrawingContext which will then be applied to all new objects it creates.            //
 
-            if (ddc != null)
+            if (dc is DrawingDrawingContext ddc)
             {
                 ddc.CanBeInheritanceContext = false;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingVisual.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingVisual.cs
index f0a17199..4d8a62ec 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingVisual.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/DrawingVisual.cs
@@ -125,11 +125,7 @@ internal override void RenderClose(IDrawingContent newContent)
             // Prepare the new content.
             // 
 
-            if (newContent != null)
-            {
-                // Propagate notification handlers.
-                newContent.PropagateChangedHandler(ContentsChangedHandler, true /* adding */);                
-            }
+            newContent?.PropagateChangedHandler(ContentsChangedHandler, true /* adding */);
 
             _content = newContent;
 
@@ -210,10 +206,7 @@ internal void WalkContent(DrawingContextWalker walker)
         {
             VerifyAPIReadOnly();
 
-            if (_content != null)
-            {
-                _content.WalkContent(walker);
-            }
+            _content?.WalkContent(walker);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/PixelShader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/PixelShader.cs
index 83ede498..2fbe7e24 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/PixelShader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/PixelShader.cs
@@ -121,10 +121,7 @@ private void UriSourcePropertyChangedHook(DependencyPropertyChangedEventArgs e)
             }
             finally
             {
-                if (stream != null)
-                {
-                    stream.Dispose();
-                }
+                stream?.Dispose();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/ShaderEffect.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/ShaderEffect.cs
index d7b8a191..20734f48 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/ShaderEffect.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Effects/ShaderEffect.cs
@@ -279,10 +279,7 @@ protected static PropertyChangedCallback PixelShaderConstantCallback(int floatRe
                 (obj, args) =>
                 {
                     ShaderEffect eff = obj as ShaderEffect;
-                    if (eff != null)
-                    {
-                        eff.UpdateShaderConstant(args.Property, args.NewValue, floatRegisterIndex);
-                    }
+                    eff?.UpdateShaderConstant(args.Property, args.NewValue, floatRegisterIndex);
                 };
         }
 
@@ -308,8 +305,7 @@ protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerR
             return
                 (obj, args) =>
                 {
-                    ShaderEffect eff = obj as ShaderEffect;
-                    if (eff != null)
+                    if (obj is ShaderEffect eff)
                     {
                         if (args.IsAValueChange)
                         {
@@ -782,10 +778,7 @@ internal override DUCE.ResourceHandle AddRefOnChannelCore(DUCE.Channel channel)
                             SamplerData ss = ssn.Value;
 
                             DUCE.IResource brush = ss._brush as DUCE.IResource;
-                            if (brush != null)
-                            {
-                                brush.AddRefOnChannel(channel);
-                            }
+                            brush?.AddRefOnChannel(channel);
                         }
                     }
                 }
@@ -822,10 +815,7 @@ internal override void ReleaseOnChannelCore(DUCE.Channel channel)
                             SamplerData ss = ssn.Value;
 
                             DUCE.IResource brush = ss._brush as DUCE.IResource;
-                            if (brush != null)
-                            {
-                                brush.ReleaseOnChannel(channel);
-                            }
+                            brush?.ReleaseOnChannel(channel);
                         }
                     }
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyConverter.cs
index a5de25f4..54a8a649 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyConverter.cs
@@ -65,7 +65,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
                     // Suppress PRESharp warning that fontFamily can be null; apparently PRESharp
                     // doesn't understand short circuit evaluation of operator &&.
 #pragma warning suppress 56506
-                    return fontFamily != null && fontFamily.Source != null && fontFamily.Source.Length != 0;
+                    return fontFamily?.Source != null && fontFamily.Source.Length != 0;
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyValueSerializer.cs
index 9c25984d..4640bff9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FontFamilyValueSerializer.cs
@@ -54,7 +54,7 @@ public override bool CanConvertToString(object value, IValueSerializerContext co
             // Suppress PRESharp warning that fontFamily can be null; apparently PRESharp
             // doesn't understand short circuit evaluation of operator &&.
 #pragma warning suppress 56506
-            return fontFamily != null && fontFamily.Source != null && fontFamily.Source.Length != 0;           
+            return fontFamily?.Source != null && fontFamily.Source.Length != 0;           
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FormattedText.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FormattedText.cs
index 6648abfd..5b32ff24 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FormattedText.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/FormattedText.cs
@@ -1948,8 +1948,7 @@ int textSourceCharacterIndex
         #region private methods
         private void CombineGeometryRecursive(Drawing drawing, ref GeometryGroup accumulatedGeometry)
         {
-            DrawingGroup group = drawing as DrawingGroup;
-            if (group != null)
+            if (drawing is DrawingGroup group)
             {
                 // recursively go down for DrawingGroup
                 foreach (Drawing child in group.Children)
@@ -1959,8 +1958,7 @@ private void CombineGeometryRecursive(Drawing drawing, ref GeometryGroup accumul
             }
             else 
             {
-                GlyphRunDrawing glyphRunDrawing = drawing as GlyphRunDrawing;
-                if (glyphRunDrawing != null)
+                if (drawing is GlyphRunDrawing glyphRunDrawing)
                 {
                     // process glyph run
                     GlyphRun glyphRun = glyphRunDrawing.GlyphRun;
@@ -1981,16 +1979,14 @@ private void CombineGeometryRecursive(Drawing drawing, ref GeometryGroup accumul
                 }
                 else
                 {
-                    GeometryDrawing geometryDrawing = drawing as GeometryDrawing;
-                    if (geometryDrawing != null)
+                    if (drawing is GeometryDrawing geometryDrawing)
                     {
                         // process geometry (i.e. TextDecoration on the line)
                         Geometry geometry = geometryDrawing.Geometry;
                          
                         if (geometry != null)
                         {              
-                            LineGeometry lineGeometry = geometry as LineGeometry;
-                            if (lineGeometry != null)
+                            if (geometry is LineGeometry lineGeometry)
                             {
                                 // For TextDecoration drawn by DrawLine(), the geometry is a LineGeometry which has no 
                                 // bounding area. So this line won't show up. Work aroud it by increase the Bounding rect 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/BrushConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/BrushConverter.cs
index 2992c50b..de1af6de 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/BrushConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/BrushConverter.cs
@@ -77,7 +77,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for some instances
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     if (!(context.Instance is Brush))
                     {
@@ -116,9 +116,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Brush.Parse(source, context);
             }
@@ -149,7 +147,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (destinationType == typeof(string))
                 {
                     // When invoked by the serialization engine we can convert to string only for some instances
-                    if (context != null && context.Instance != null)
+                    if (context?.Instance != null)
                     {
                         #pragma warning suppress 6506 // instance is obviously not null
                         if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/CacheModeConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/CacheModeConverter.cs
index 1ccc1a9e..563afdfd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/CacheModeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/CacheModeConverter.cs
@@ -77,7 +77,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for some instances
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     if (!(context.Instance is CacheMode))
                     {
@@ -116,9 +116,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return CacheMode.Parse(source);
             }
@@ -149,7 +147,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (destinationType == typeof(string))
                 {
                     // When invoked by the serialization engine we can convert to string only for some instances
-                    if (context != null && context.Instance != null)
+                    if (context?.Instance != null)
                     {
                         #pragma warning suppress 6506 // instance is obviously not null
                         if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollection.cs
index 7e413752..28ee28e0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollection.cs
@@ -335,9 +335,9 @@ int IList.Add(object value)
 
         bool IList.Contains(object value)
         {
-            if (value is double)
+            if (value is double d)
             {
-                return Contains((double)value);
+                return Contains(d);
             }
 
             return false;
@@ -345,9 +345,9 @@ bool IList.Contains(object value)
 
         int IList.IndexOf(object value)
         {
-            if (value is double)
+            if (value is double d)
             {
-                return IndexOf((double)value);
+                return IndexOf(d);
             }
 
             return -1;
@@ -361,9 +361,9 @@ void IList.Insert(int index, object value)
 
         void IList.Remove(object value)
         {
-            if (value is double)
+            if (value is double d)
             {
-                Remove((double)value);
+                Remove(d);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollectionConverter.cs
index 67bdd5d3..6e45c19d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DoubleCollectionConverter.cs
@@ -102,9 +102,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return DoubleCollection.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingContextWalker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingContextWalker.cs
index 6560c152..31f91191 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingContextWalker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingContextWalker.cs
@@ -345,10 +345,7 @@ internal abstract partial class DrawingContextWalker : DrawingContext
         public override void DrawDrawing(
             Drawing drawing)
         {
-            if (drawing != null)
-            {
-                drawing.WalkCurrentValue(this);
-            }
+            drawing?.WalkCurrentValue(this);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingGroup.cs
index 4df39e62..b9db6630 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/DrawingGroup.cs
@@ -148,8 +148,7 @@ private static void ChildrenPropertyChanged(DependencyObject d, DependencyProper
                             int count = newCollection.Count;
                             for (int i = 0; i < count; i++)
                             {
-                                DUCE.IResource resource = newCollection.Internal_GetItem(i) as DUCE.IResource;
-                                Debug.Assert(resource != null);
+                                Debug.Assert(newCollection.Internal_GetItem(i) is DUCE.IResource resource);
                                 resource.AddRefOnChannel(channel);
                             }
                         }
@@ -159,8 +158,7 @@ private static void ChildrenPropertyChanged(DependencyObject d, DependencyProper
                             int count = oldCollection.Count;
                             for (int i = 0; i < count; i++)
                             {
-                                DUCE.IResource resource = oldCollection.Internal_GetItem(i) as DUCE.IResource;
-                                Debug.Assert(resource != null);
+                                Debug.Assert(newCollection.Internal_GetItem(i) is DUCE.IResource resource);
                                 resource.ReleaseOnChannel(channel);
                             }
                         }
@@ -713,10 +711,7 @@ private void ChildrenItemInserted(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource addResource = item as DUCE.IResource;
-                        if (addResource != null)
-                        {
-                            addResource.AddRefOnChannel(channel);
-                        }
+                        addResource?.AddRefOnChannel(channel);
 
                         UpdateResource(channel, true /* skip on channel check */);
                     }
@@ -743,10 +738,7 @@ private void ChildrenItemRemoved(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource releaseResource = item as DUCE.IResource;
-                        if (releaseResource != null)
-                        {
-                            releaseResource.ReleaseOnChannel(channel);
-                        }
+                        releaseResource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryConverter.cs
index b8264ce4..67849f37 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryConverter.cs
@@ -77,7 +77,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for some instances
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     if (!(context.Instance is Geometry))
                     {
@@ -116,9 +116,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Geometry.Parse(source);
             }
@@ -149,7 +147,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (destinationType == typeof(string))
                 {
                     // When invoked by the serialization engine we can convert to string only for some instances
-                    if (context != null && context.Instance != null)
+                    if (context?.Instance != null)
                     {
                         #pragma warning suppress 6506 // instance is obviously not null
                         if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryGroup.cs
index cec65890..c0e2e1e9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/GeometryGroup.cs
@@ -155,8 +155,7 @@ private static void ChildrenPropertyChanged(DependencyObject d, DependencyProper
                             int count = newCollection.Count;
                             for (int i = 0; i < count; i++)
                             {
-                                DUCE.IResource resource = newCollection.Internal_GetItem(i) as DUCE.IResource;
-                                Debug.Assert(resource != null);
+                                Debug.Assert(newCollection.Internal_GetItem(i) is DUCE.IResource resource);
                                 resource.AddRefOnChannel(channel);
                             }
                         }
@@ -166,8 +165,7 @@ private static void ChildrenPropertyChanged(DependencyObject d, DependencyProper
                             int count = oldCollection.Count;
                             for (int i = 0; i < count; i++)
                             {
-                                DUCE.IResource resource = oldCollection.Internal_GetItem(i) as DUCE.IResource;
-                                Debug.Assert(resource != null);
+                                Debug.Assert(newCollection.Internal_GetItem(i) is DUCE.IResource resource);
                                 resource.ReleaseOnChannel(channel);
                             }
                         }
@@ -381,10 +379,7 @@ private void ChildrenItemInserted(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource addResource = item as DUCE.IResource;
-                        if (addResource != null)
-                        {
-                            addResource.AddRefOnChannel(channel);
-                        }
+                        addResource?.AddRefOnChannel(channel);
 
                         UpdateResource(channel, true /* skip on channel check */);
                     }
@@ -411,10 +406,7 @@ private void ChildrenItemRemoved(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource releaseResource = item as DUCE.IResource;
-                        if (releaseResource != null)
-                        {
-                            releaseResource.ReleaseOnChannel(channel);
-                        }
+                        releaseResource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32Collection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32Collection.cs
index 25ee437c..dddbf4be 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32Collection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32Collection.cs
@@ -335,9 +335,9 @@ int IList.Add(object value)
 
         bool IList.Contains(object value)
         {
-            if (value is int)
+            if (value is int i)
             {
-                return Contains((int)value);
+                return Contains(i);
             }
 
             return false;
@@ -345,9 +345,9 @@ bool IList.Contains(object value)
 
         int IList.IndexOf(object value)
         {
-            if (value is int)
+            if (value is int i)
             {
-                return IndexOf((int)value);
+                return IndexOf(i);
             }
 
             return -1;
@@ -361,9 +361,9 @@ void IList.Insert(int index, object value)
 
         void IList.Remove(object value)
         {
-            if (value is int)
+            if (value is int i)
             {
-                Remove((int)value);
+                Remove(i);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32CollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32CollectionConverter.cs
index eb0f3427..0be773fc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32CollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/Int32CollectionConverter.cs
@@ -102,9 +102,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Int32Collection.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PathFigureCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PathFigureCollectionConverter.cs
index 2e8847c8..0260cd1c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PathFigureCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PathFigureCollectionConverter.cs
@@ -77,7 +77,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for some instances
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     if (!(context.Instance is PathFigureCollection))
                     {
@@ -116,9 +116,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return PathFigureCollection.Parse(source);
             }
@@ -149,7 +147,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (destinationType == typeof(string))
                 {
                     // When invoked by the serialization engine we can convert to string only for some instances
-                    if (context != null && context.Instance != null)
+                    if (context?.Instance != null)
                     {
                         #pragma warning suppress 6506 // instance is obviously not null
                         if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollection.cs
index 36af23ed..80a0869a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollection.cs
@@ -335,9 +335,9 @@ int IList.Add(object value)
 
         bool IList.Contains(object value)
         {
-            if (value is Point)
+            if (value is Point point)
             {
-                return Contains((Point)value);
+                return Contains(point);
             }
 
             return false;
@@ -345,9 +345,9 @@ bool IList.Contains(object value)
 
         int IList.IndexOf(object value)
         {
-            if (value is Point)
+            if (value is Point point)
             {
-                return IndexOf((Point)value);
+                return IndexOf(point);
             }
 
             return -1;
@@ -361,9 +361,9 @@ void IList.Insert(int index, object value)
 
         void IList.Remove(object value)
         {
-            if (value is Point)
+            if (value is Point point)
             {
-                Remove((Point)value);
+                Remove(point);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollectionConverter.cs
index 69515716..32af7131 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/PointCollectionConverter.cs
@@ -102,9 +102,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return PointCollection.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformConverter.cs
index 8a479e27..475facd1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformConverter.cs
@@ -77,7 +77,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for some instances
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     if (!(context.Instance is Transform))
                     {
@@ -116,9 +116,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Transform.Parse(source);
             }
@@ -149,7 +147,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (destinationType == typeof(string))
                 {
                     // When invoked by the serialization engine we can convert to string only for some instances
-                    if (context != null && context.Instance != null)
+                    if (context?.Instance != null)
                     {
                         #pragma warning suppress 6506 // instance is obviously not null
                         if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformGroup.cs
index 06917c4a..7008a114 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/TransformGroup.cs
@@ -337,10 +337,7 @@ private void ChildrenItemInserted(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource addResource = item as DUCE.IResource;
-                        if (addResource != null)
-                        {
-                            addResource.AddRefOnChannel(channel);
-                        }
+                        addResource?.AddRefOnChannel(channel);
 
                         UpdateResource(channel, true /* skip on channel check */);
                     }
@@ -367,10 +364,7 @@ private void ChildrenItemRemoved(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource releaseResource = item as DUCE.IResource;
-                        if (releaseResource != null)
-                        {
-                            releaseResource.ReleaseOnChannel(channel);
-                        }
+                        releaseResource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollection.cs
index cddc8865..fc090681 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollection.cs
@@ -335,9 +335,9 @@ int IList.Add(object value)
 
         bool IList.Contains(object value)
         {
-            if (value is Vector)
+            if (value is Vector vector)
             {
-                return Contains((Vector)value);
+                return Contains(vector);
             }
 
             return false;
@@ -345,9 +345,9 @@ bool IList.Contains(object value)
 
         int IList.IndexOf(object value)
         {
-            if (value is Vector)
+            if (value is Vector vector)
             {
-                return IndexOf((Vector)value);
+                return IndexOf(vector);
             }
 
             return -1;
@@ -361,9 +361,9 @@ void IList.Insert(int index, object value)
 
         void IList.Remove(object value)
         {
-            if (value is Vector)
+            if (value is Vector vector)
             {
-                Remove((Vector)value);
+                Remove(vector);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollectionConverter.cs
index 681c6ac5..e705d708 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Generated/VectorCollectionConverter.cs
@@ -102,9 +102,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return VectorCollection.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Geometry.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Geometry.cs
index f2709b69..ccaa16eb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Geometry.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Geometry.cs
@@ -411,10 +411,7 @@ internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance
                 double[] dashArray = null;
 
                 // If we have a pen, populate the CMD struct
-                if (pen != null)
-                {
-                    pen.GetBasicPenData(&penData, out dashArray);
-                }
+                pen?.GetBasicPenData(&penData, out dashArray);
 
                 fixed (byte* pbPathData = pathData.SerializedData)
                 {
@@ -464,10 +461,7 @@ internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance
             MIL_PEN_DATA penData;
             double[] dashArray = null;
 
-            if (pen != null)
-            {
-                pen.GetBasicPenData(&penData, out dashArray);
-            }
+            pen?.GetBasicPenData(&penData, out dashArray);
 
             fixed (double *dashArrayFixed = dashArray)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/HitTestWithGeometryDrawingContextWalker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/HitTestWithGeometryDrawingContextWalker.cs
index 0097ebc8..57c17ea6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/HitTestWithGeometryDrawingContextWalker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/HitTestWithGeometryDrawingContextWalker.cs
@@ -345,17 +345,17 @@ public override void Pop()
 
             object currentModifier = _modifierStack.Pop();
 
-            if (currentModifier is TransformModifierNode)
+            if (currentModifier is TransformModifierNode transformModifierNode)
             {
-                _currentTransform = ((TransformModifierNode)currentModifier)._transform;
+                _currentTransform = transformModifierNode._transform;
 
                 // Since the drawing context starts out with no transform and no clip,
                 // the first element pushed on the stack will always be null.
                 Debug.Assert((_modifierStack.Count > 0) || (_currentTransform == null));
             }
-            else if (currentModifier is ClipModifierNode)
+            else if (currentModifier is ClipModifierNode clipModifierNode)
             {
-                _currentClip = ((ClipModifierNode)currentModifier)._clip;
+                _currentClip = clipModifierNode._clip;
 
                 // Since the drawing context starts out with no transform and no clip,
                 // the first element pushed on the stack will always be null.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageBrush.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageBrush.cs
index e5ad01b8..1f0f7b8e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageBrush.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageBrush.cs
@@ -66,8 +66,8 @@ protected override void GetContentBounds(out Rect contentBounds)
             // Note, only implemented for DrawingImages.
 
             contentBounds = Rect.Empty;
-            DrawingImage di = ImageSource as DrawingImage;
-            if (di != null)
+
+            if (ImageSource is DrawingImage di)
             {
                 Drawing drawing = di.Drawing;
                 if (drawing != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceConverter.cs
index 2c3c2695..9a6edcf9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceConverter.cs
@@ -65,7 +65,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for some instances
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     if (!(context.Instance is ImageSource))
                     {
@@ -119,10 +119,8 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                         null
                         );
                 }
-                else if (value is byte[])
+                else if (value is byte[] bytes)
                 {
-                    byte[] bytes = (byte[])value;
-
                     if (bytes != null)
                     {
                         Stream memStream = null;
@@ -147,10 +145,8 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                             );
                     }
                 }
-                else if (value is Stream)
+                else if (value is Stream stream)
                 {
-                    Stream stream = (Stream)value;
-
                     return BitmapFrame.Create(
                         stream,
                         BitmapCreateOptions.None,
@@ -169,16 +165,13 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                         throw new NullReferenceException();
                     }
 
-                    IProvideValueTarget ipvt = context?.GetService(typeof(IProvideValueTarget)) as IProvideValueTarget;
-                    if (ipvt != null)
+                    if (context?.GetService(typeof(IProvideValueTarget))is IProvideValueTarget ipvt)
                     {
-                        IProvidePropertyFallback ippf = ipvt.TargetObject as IProvidePropertyFallback;
-                        DependencyProperty dp = ipvt.TargetProperty as DependencyProperty;
                         // We only want to call IPPF.SetValue if the target can handle it.
                         // We need to check for non DP scenarios (This is currently an internal interface used
                         //             only by Image so it's okay for now)
 
-                        if (ippf != null && dp != null && ippf.CanProvidePropertyFallback(dp.Name))
+                        if (ipvt.TargetObject is IProvidePropertyFallback ippf && ipvt.TargetProperty is DependencyProperty dp && ippf.CanProvidePropertyFallback(dp.Name))
                         {
                             return ippf.ProvidePropertyFallback(dp.Name, e);
                         }
@@ -213,7 +206,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 if (destinationType == typeof(string))
                 {
                     // When invoked by the serialization engine we can convert to string only for some instances
-                    if (context != null && context.Instance != null)
+                    if (context?.Instance != null)
                     {
                         #pragma warning disable 6506
                         if (!instance.CanSerializeToString())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceValueSerializer.cs
index 1d14d980..5d262561 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/ImageSourceValueSerializer.cs
@@ -38,9 +38,8 @@ public override bool CanConvertFromString(string value, IValueSerializerContext
         /// </summary>
         public override bool CanConvertToString(object value, IValueSerializerContext context)
         {
-            ImageSource imageSource = value as ImageSource;
             #pragma warning disable 6506
-            return imageSource != null && imageSource.CanSerializeToString();
+            return value is ImageSource imageSource && imageSource.CanSerializeToString();
             #pragma warning restore 6506
         }
 
@@ -69,8 +68,7 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            ImageSource imageSource = value as ImageSource;
-            if (imageSource != null)
+            if (value is ImageSource imageSource)
                 return imageSource.ConvertToString(null,  System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
             else
                 return base.ConvertToString(value, context);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDecoder.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDecoder.cs
index e7b500be..308976c4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDecoder.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDecoder.cs
@@ -1365,11 +1365,9 @@ private static System.IO.Stream GetSeekableStream(System.IO.Stream bitmapStream)
 
             if (uri != null)
             {
-                WeakReference weakRef = ImagingCache.CheckDecoderCache(uri) as WeakReference;
-                if (weakRef != null)
+                if (ImagingCache.CheckDecoderCache(uri) is WeakReference weakRef)
                 {
-                    BitmapDecoder bitmapDecoder = weakRef.Target as BitmapDecoder;
-                    if ((bitmapDecoder != null) && bitmapDecoder.CheckAccess())
+                    if ((weakRef.Target is BitmapDecoder bitmapDecoder) && bitmapDecoder.CheckAccess())
                     {
                         lock (bitmapDecoder.SyncObject)
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDownload.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDownload.cs
index a51d8c40..8a01946a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDownload.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapDownload.cs
@@ -323,8 +323,7 @@ private static void ReadCallback(IAsyncResult result)
                     // Fire download progress & completion event for each decoder
                     foreach (WeakReference decoderReference in entry.decoders)
                     {
-                        LateBoundBitmapDecoder decoder = decoderReference.Target as LateBoundBitmapDecoder;
-                        if (decoder != null)
+                        if (decoderReference.Target is LateBoundBitmapDecoder decoder)
                         {
                             //
                             // Marshal events to UI thread
@@ -372,8 +371,7 @@ private static void ReadCallback(IAsyncResult result)
                             // Fire download progress event for each decoder
                             foreach (WeakReference decoderReference in entry.decoders)
                             {
-                                LateBoundBitmapDecoder decoder = decoderReference.Target as LateBoundBitmapDecoder;
-                                if (decoder != null)
+                                if (decoderReference.Target is LateBoundBitmapDecoder decoder)
                                 {
                                     //
                                     // Marshal events to UI thread
@@ -428,8 +426,7 @@ Exception e
                 // Fire download completion event for each decoder
                 foreach (WeakReference decoderReference in entry.decoders)
                 {
-                    LateBoundBitmapDecoder decoder = decoderReference.Target as LateBoundBitmapDecoder;
-                    if (decoder != null)
+                    if (decoderReference.Target is LateBoundBitmapDecoder decoder)
                     {
                         MarshalEvents(
                             decoder,
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapEncoder.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapEncoder.cs
index 9b54cdec..11cadbd2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapEncoder.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapEncoder.cs
@@ -744,10 +744,8 @@ out outSourceHandle
                 // Set the metadata
                 if (_supportsFrameMetadata)
                 {
-                    BitmapMetadata metadata = frame.Metadata as BitmapMetadata;
-
                     // If the frame has metadata associated with a different container format, then we ignore it.
-                    if (metadata != null && metadata.GuidFormat == ContainerFormat)
+                    if (frame.Metadata is BitmapMetadata metadata && metadata.GuidFormat == ContainerFormat)
                     {
                         SafeMILHandle /* IWICMetadataQueryWriter */ metadataHandle = new SafeMILHandle();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapFrameDecode.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapFrameDecode.cs
index d4288874..9cad3ee0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapFrameDecode.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapFrameDecode.cs
@@ -295,10 +295,7 @@ public override InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter()
         {
             ReadPreamble();
 
-            if (_decoder != null)
-            {
-                _decoder.CheckOriginalWritable();
-            }
+            _decoder?.CheckOriginalWritable();
 
             // Demand Site Of Origin on the URI before usage of metadata.
             CheckIfSiteOfOrigin();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapImage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapImage.cs
index eb4bbfdd..d3ae1ca9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapImage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapImage.cs
@@ -251,9 +251,7 @@ private BitmapImage CheckCache(Uri uri)
         {
             if (uri != null)
             {
-                WeakReference bitmapWeakReference = ImagingCache.CheckImageCache(uri) as WeakReference;
-
-                if (bitmapWeakReference != null)
+                if (ImagingCache.CheckImageCache(uri) is WeakReference bitmapWeakReference)
                 {
                     BitmapImage bitmapImage = (bitmapWeakReference.Target as BitmapImage);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapMetadata.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapMetadata.cs
index f5b1c180..7fb4de2e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapMetadata.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/BitmapMetadata.cs
@@ -320,10 +320,7 @@ out pIMetadataWriter
                             }
                             finally
                             {
-                                if (pIMetadataReader != null)
-                                {
-                                    pIMetadataReader.Dispose();
-                                }
+                                pIMetadataReader?.Dispose();
                                 if (pIMetadataWriter != IntPtr.Zero)
                                 {
                                     #pragma warning suppress 6031 // Return value ignored on purpose.
@@ -1065,8 +1062,7 @@ public void SetQuery(String query, object value)
 
                 if (propVar.RequiresSyncObject)
                 {
-                    BitmapMetadata metadata = value as BitmapMetadata;
-                    Invariant.Assert(metadata != null);
+                    Invariant.Assert(value is BitmapMetadata metadata);
 
                     #pragma warning suppress 6506 // Invariant.Assert(metadata != null);
                     metadata.VerifyAccess();
@@ -1143,10 +1139,7 @@ ref propVar
                     {
                         BitmapMetadata metadata = objValue as BitmapMetadata;
 
-                        if (metadata != null)
-                        {
-                            metadata.Freeze();
-                        }
+                        metadata?.Freeze();
                     }
 
                     return objValue;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/CroppedBitmap.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/CroppedBitmap.cs
index af4cc693..f7c1eab7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/CroppedBitmap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/CroppedBitmap.cs
@@ -147,10 +147,7 @@ internal override void FinalizeCreation()
                 }
                 finally
                 {
-                    if (wicClipper != null)
-                    {
-                        wicClipper.Close();
-                    }
+                    wicClipper?.Close();
                 }
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/FormatConvertedBitmap.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/FormatConvertedBitmap.cs
index 652dfe11..0fcb0757 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/FormatConvertedBitmap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/FormatConvertedBitmap.cs
@@ -162,10 +162,7 @@ internal override void FinalizeCreation()
                 }
                 finally
                 {
-                    if (wicFormatter != null)
-                    {
-                        wicFormatter.Close();
-                    }
+                    wicFormatter?.Close();
                 }
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/ImagingCache.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/ImagingCache.cs
index 55d40149..739eec5e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/ImagingCache.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/ImagingCache.cs
@@ -90,8 +90,7 @@ private static void AddToCache(Uri uri, object obj, Hashtable table)
                     foreach (DictionaryEntry de in table)
                     {
                         // if the value is a WeakReference that has been GC'd, remove it
-                        WeakReference weakRef = de.Value as WeakReference;
-                        if ((weakRef != null) && (weakRef.Target == null))
+                        if ((de.Value is WeakReference weakRef) && (weakRef.Target == null))
                         {
                             al.Add(de.Key);
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/PropVariant.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/PropVariant.cs
index b6b7e792..51a1a52e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/PropVariant.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Imaging/PropVariant.cs
@@ -396,19 +396,19 @@ internal void Init(object value)
                     varType = (ushort)VarEnum.VT_UI8;
                     ulVal = (UInt64)value;
                 }
-                else if (value is float)
+                else if (value is float f)
                 {
                     varType = (ushort)VarEnum.VT_R4;
-                    fltVal = (float)value;
+                    fltVal = f;
                 }
-                else if (value is double)
+                else if (value is double d)
                 {
                     varType = (ushort)VarEnum.VT_R8;
-                    dblVal = (double)value;
+                    dblVal = d;
                 }
-                else if (value is Guid)
+                else if (value is Guid guid)
                 {
-                    byte[] guid = ((Guid)value).ToByteArray();
+                    byte[] guid = guid.ToByteArray();
                     varType = (ushort)VarEnum.VT_CLSID;
                     pclsidVal = Marshal.AllocCoTaskMem(guid.Length);
                     Marshal.Copy(guid, 0, pclsidVal, guid.Length);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Knowncolors.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Knowncolors.cs
index 92bd8c51..d53f826d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Knowncolors.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Knowncolors.cs
@@ -175,7 +175,7 @@ static KnownColors()
             Array knownColorValues = Enum.GetValues(typeof(KnownColor));
             foreach (KnownColor colorValue in knownColorValues)
             {
-                string aRGBString = String.Format("#{0,8:X8}", (uint)colorValue);
+                string aRGBString = $"#{(uint)colorValue:X8}";
                 s_knownArgbColors[aRGBString] = colorValue;
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/MediaContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/MediaContext.cs
index 832a8ec0..8e137356 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/MediaContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/MediaContext.cs
@@ -371,10 +371,7 @@ private object InvalidateRenderMode(object dontCare)
             {
                 HwndTarget hwndTarget = target as HwndTarget;
 
-                if (hwndTarget != null)
-                {
-                    hwndTarget.InvalidateRenderMode();
-                }
+                hwndTarget?.InvalidateRenderMode();
             }
 
             return null;
@@ -2092,10 +2089,7 @@ private void Render(ICompositionTarget resizedCompositionTarget)
                 // will wait until we have presented before committing this channel
                 //
 
-                if (Channel != null)
-                {
-                    Channel.CloseBatch();
-                }
+                Channel?.CloseBatch();
 
                 _needToCommitChannel = true;
                 _commitPendingAfterRender = true;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/PathGeometry.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/PathGeometry.cs
index 51d0d42a..7aac1b44 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/PathGeometry.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/PathGeometry.cs
@@ -702,10 +702,7 @@ public void Clear()
         {
             PathFigureCollection figures = Figures;
 
-            if (figures != null)
-            {
-                figures.Clear();
-            }
+            figures?.Clear();
         }
         #endregion
 
@@ -797,10 +794,7 @@ public override Rect Bounds
                 double[] dashArray = null;
 
                 // If we have a pen, populate the CMD struct
-                if (pen != null)
-                {
-                    pen.GetBasicPenData(&penData, out dashArray);
-                }
+                pen?.GetBasicPenData(&penData, out dashArray);
 
                 MilMatrix3x2D worldMatrix3X2 = CompositionResourceManager.MatrixToMilMatrix3x2D(ref worldMatrix);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Pen.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Pen.cs
index c7aa3601..387e9260 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Pen.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Pen.cs
@@ -124,10 +124,7 @@ internal unsafe void GetBasicPenData(MIL_PEN_DATA* pData, out double[] dashArray
                 pData->MiterLimit = MiterLimit;
             }
 
-            if (DashStyle != null)
-            {
-                DashStyle.GetDashData(pData, out dashArray);
-            }
+            DashStyle?.GetDashData(pData, out dashArray);
         }
  
         internal bool DoesNotContainGaps
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RectangleGeometry.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RectangleGeometry.cs
index 3abf8d26..25c1af61 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RectangleGeometry.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RectangleGeometry.cs
@@ -141,9 +141,7 @@ public override Rect Bounds
 
         internal override bool AreClose(Geometry geometry)
         {
-            RectangleGeometry rectGeometry2 = geometry as RectangleGeometry;
-
-            if (rectGeometry2 != null)
+            if (geometry is RectangleGeometry rectGeometry2)
             {
                 RectangleGeometry rectGeometry1 = this;
                 Rect rect1 = rectGeometry1.Rect;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RenderData.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RenderData.cs
index 473e1ddb..f02c195e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RenderData.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RenderData.cs
@@ -249,8 +249,7 @@ public void PropagateChangedHandler(EventHandler handler, bool adding)
 
             for (int i = 0, count = _dependentResources.Count; i < count; i++)
             {
-                Freezable freezableResource = _dependentResources[i] as Freezable;
-                if (freezableResource != null)
+                if (_dependentResources[i] is Freezable freezableResource)
                 {
                     // Ideally, we would call OFPC(null, freezable) in AddDependentResource
                     // but RenderData never removes resources so nothing would ever remove
@@ -268,11 +267,9 @@ public void PropagateChangedHandler(EventHandler handler, bool adding)
                 }
                 else
                 {
-                    // If it's not a Freezable it may be an AnimationClockResource, which we
-                    // also need to handle.
-                    AnimationClockResource clockResource = _dependentResources[i] as AnimationClockResource;
+                    // If it's not a Freezable it may be an AnimationClockResource, which we                    // also need to handle.
 
-                    if (clockResource != null)
+                    if (_dependentResources[i] is AnimationClockResource clockResource)
                     {
                         // if it is a clock, it better not be a Freezable too or we'll
                         // end up firing the handler twice
@@ -351,10 +348,7 @@ DUCE.ResourceHandle DUCE.IResource.AddRefOnChannel(DUCE.Channel channel)
                     {
                         DUCE.IResource resource = _dependentResources[i] as DUCE.IResource;
 
-                        if (resource != null)
-                        {
-                            resource.AddRefOnChannel(channel);
-                        }
+                        resource?.AddRefOnChannel(channel);
                     }
 
                     UpdateResource(channel);
@@ -379,10 +373,7 @@ void DUCE.IResource.ReleaseOnChannel(DUCE.Channel channel)
                     {
                         DUCE.IResource resource = _dependentResources[i] as DUCE.IResource;
 
-                        if (resource != null)
-                        {
-                            resource.ReleaseOnChannel(channel);
-                        }
+                        resource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RequestCachePolicyConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RequestCachePolicyConverter.cs
index 944ecb84..6aaccae4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RequestCachePolicyConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/RequestCachePolicyConverter.cs
@@ -119,8 +119,7 @@ public override object ConvertFrom(ITypeDescriptorContext td, System.Globalizati
                 throw new ArgumentNullException("destinationType");
             }
 
-            HttpRequestCachePolicy httpPolicy = value as HttpRequestCachePolicy;
-            if(httpPolicy != null)
+            if(value is HttpRequestCachePolicy httpPolicy)
             {
                 if (destinationType == typeof(string))
                 {
@@ -134,8 +133,7 @@ public override object ConvertFrom(ITypeDescriptorContext td, System.Globalizati
             }
 
             //if it's not an HttpRequestCachePolicy, try a regular RequestCachePolicy
-            RequestCachePolicy policy = value as RequestCachePolicy;
-            if (policy != null)
+            if (value is RequestCachePolicy policy)
             {
                 if (destinationType == typeof(string))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/SafeMILHandle.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/SafeMILHandle.cs
index a36ceeb3..ffde8416 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/SafeMILHandle.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/SafeMILHandle.cs
@@ -41,10 +41,7 @@ internal SafeMILHandle(IntPtr handle) : base(true)
         /// </summary>
         internal void UpdateEstimatedSize(long estimatedSize)
         {
-            if (_gcPressure != null)
-            {
-                _gcPressure.Release();
-            }
+            _gcPressure?.Release();
 
             //
             // estimatedSize may be 0 for small images with fewer than 8 bits per pixel,
@@ -61,10 +58,7 @@ internal void UpdateEstimatedSize(long estimatedSize)
         internal void CopyMemoryPressure(SafeMILHandle original)
         {
             _gcPressure = original._gcPressure;
-            if (_gcPressure != null)
-            {
-                _gcPressure.AddRef();
-            }
+            _gcPressure?.AddRef();
         }
 
         protected override bool ReleaseHandle()
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Typeface.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Typeface.cs
index cc24eb75..a764c705 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Typeface.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Typeface.cs
@@ -780,13 +780,11 @@ ref canonicalStretch
             }
 
             // If it's a named font, map all occurrences of the same name to one cached IFontFamily.
-            if (sourceFontFamily != null && sourceFontFamily.Source != null)
+            if (sourceFontFamily?.Source != null)
             {
-                // We lookup in the cache to see if there is cached IFontFamily instance of the source FontFamily. Otherwise, 
-                // this IFontFamily value is added to the TypefaceMetrics cache. 
-                IFontFamily cachedValue = TypefaceMetricsCache.ReadonlyLookup(sourceFontFamily.FamilyIdentifier) as IFontFamily;
+                // We lookup in the cache to see if there is cached IFontFamily instance of the source FontFamily. Otherwise,                 // this IFontFamily value is added to the TypefaceMetrics cache. 
                 
-                if (cachedValue != null)
+                if (TypefaceMetricsCache.ReadonlyLookup(sourceFontFamily.FamilyIdentifier) is IFontFamily cachedValue)
                 {
                     firstFontFamily = cachedValue;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Visual.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Visual.cs
index b752c4a5..c4a9b2c9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Visual.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/Visual.cs
@@ -1947,9 +1947,7 @@ internal HitTestResult HitTest(Point point, bool include2DOn3D)
 
             Precompute();
 
-            PointHitTestParameters pointParams = hitTestParameters as PointHitTestParameters;
-
-            if (pointParams != null)
+            if (hitTestParameters is PointHitTestParameters pointParams)
             {
                 // Because we call dynamic code during the hit testing walk we need to back up
                 // the original hit point in case the user's delegate throws an exception so that
@@ -1975,9 +1973,7 @@ internal HitTestResult HitTest(Point point, bool include2DOn3D)
             }
             else
             {
-                GeometryHitTestParameters geometryParams = hitTestParameters as GeometryHitTestParameters;
-
-                if (geometryParams != null)
+                if (hitTestParameters is GeometryHitTestParameters geometryParams)
                 {
                     // Because we call dynamic code during the hit testing walk we need to ensure
                     // that if the user's delegate throws an exception we restore the original
@@ -4188,17 +4184,14 @@ public bool IsDescendantOf(DependencyObject ancestor)
 
             while ((current != null) && (current != ancestor))
             {
-                Visual currentAsVisual = current as Visual;
-
-                if (currentAsVisual != null)
+                if (current is Visual currentAsVisual)
                 {
                     current = currentAsVisual._parent;
                 }
                 else
                 {
-                    Visual3D currentAsVisual3D = current as Visual3D;
 
-                    if (currentAsVisual3D != null)
+                    if (current is Visual3D currentAsVisual3D)
                     {
                         current = currentAsVisual3D.InternalVisualParent;
                     }
@@ -4267,8 +4260,7 @@ internal DependencyObject FindFirstAncestorWithFlagsAnd(VisualFlags flag)
                 current = parent as Visual;
                 if (current == null)
                 {
-                    Visual3D parentAsVisual3D = parent as Visual3D;
-                    if (parentAsVisual3D != null)
+                    if (parent is Visual3D parentAsVisual3D)
                     {
                         return parentAsVisual3D.FindFirstAncestorWithFlagsAnd(flag);
                     }
@@ -4540,8 +4532,7 @@ private GeneralTransform InternalTransformToAncestor(Visual ancestor, bool inver
 
             while ((VisualTreeHelper.GetParent(g) != null) && (g != ancestor))
             {
-                Visual gAsVisual = g as Visual;
-                if (gAsVisual != null)
+                if (g is Visual gAsVisual)
                 {
                     if (gAsVisual.CheckFlagsAnd(VisualFlags.NodeHasEffect))
                     {
@@ -4648,10 +4639,7 @@ private GeneralTransform InternalTransformToAncestor(Visual ancestor, bool inver
                 }
 
                 // group can be null if it does not have an inverse
-                if (group != null)
-                {
-                    group.Freeze();
-                }
+                group?.Freeze();
 
                 // Initialize out params
                 generalTransform = group;
@@ -5021,10 +5009,7 @@ internal void RecursiveSetDpiScaleVisualFlags(DpiRecursiveChangeArgs args)
             for (int i = 0; i < count; i++)
             {
                 Visual cv = InternalGetVisualChild(i);
-                if (cv != null)
-                {
-                    cv.RecursiveSetDpiScaleVisualFlags(args);
-                }
+                cv?.RecursiveSetDpiScaleVisualFlags(args);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/VisualBrush.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/VisualBrush.cs
index e7b3268a..bf37b8ab 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/VisualBrush.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/VisualBrush.cs
@@ -159,18 +159,12 @@ void ICyclicBrush.RenderForCyclicBrush(DUCE.Channel channel, bool skipChannelChe
         // to be specialized for Visual which doesn't implement DUCE.IResource
         internal void AddRefResource(Visual visual, DUCE.Channel channel)
         {
-            if (visual != null)
-            {
-                visual.AddRefOnChannelForCyclicBrush(this, channel);
-            }
+            visual?.AddRefOnChannelForCyclicBrush(this, channel);
         }
 
         internal void ReleaseResource(Visual visual, DUCE.Channel channel)
         {
-            if (visual != null)
-            {
-                visual.ReleaseOnChannelForCyclicBrush(this, channel);
-            }
+            visual?.ReleaseOnChannelForCyclicBrush(this, channel);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterBufferReference.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterBufferReference.cs
index 9aa88ea1..3f04f43e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterBufferReference.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterBufferReference.cs
@@ -120,9 +120,9 @@ public override int GetHashCode()
         /// <param name="obj"> The object to test. </param>
         public override bool Equals(object obj)
         {
-            if (obj is CharacterBufferReference)
+            if (obj is CharacterBufferReference characterBufferReference)
             {
-                return Equals((CharacterBufferReference)obj);
+                return Equals(characterBufferReference);
             }
             return false;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterString.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterString.cs
index 77649e98..21257334 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterString.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/CharacterString.cs
@@ -187,9 +187,9 @@ public override int GetHashCode()
         /// <param name="obj"> The object to test </param>
         public override bool Equals(object obj)
         {
-            if (obj is CharacterBufferRange)
+            if (obj is CharacterBufferRange characterBufferRange)
             {
-                return Equals((CharacterBufferRange)obj);
+                return Equals(characterBufferRange);
             }
             return false;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/NumberSubstitution.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/NumberSubstitution.cs
index f782687c..93377a5e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/NumberSubstitution.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/NumberSubstitution.cs
@@ -279,12 +279,11 @@ public override int GetHashCode()
         /// same properties as this object, and false otherwise.</returns>
         public override bool Equals(object obj)
         {
-            NumberSubstitution sub = obj as NumberSubstitution;
 
             // Suppress PRESharp warning that sub can be null; apparently PRESharp
             // doesn't understand short circuit evaluation of operator &&.
             #pragma warning disable 6506
-            return sub != null &&
+            return obj is NumberSubstitution sub &&
                 _source == sub._source &&
                 _substitution == sub._substitution &&
                 (_cultureOverride == null ? (sub._cultureOverride == null) : (_cultureOverride.Equals(sub._cultureOverride)));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/TextRunCache.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/TextRunCache.cs
index 10253223..5cfee3cb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/TextRunCache.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media/textformatting/TextRunCache.cs
@@ -51,14 +51,7 @@ public sealed class TextRunCache
             int     removal
             )
         {
-            if(_imp != null)
-            {
-                _imp.Change(
-                    textSourceCharacterIndex,
-                    addition,
-                    removal
-                    );
-            }
+            _imp?.Change(textSourceCharacterIndex, addition, removal);
         }
 
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Matrix3DValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Matrix3DValueSerializer.cs
index 3e690330..40640292 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Matrix3DValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Matrix3DValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Matrix3D)
+            if (value is Matrix3D instance)
             {
-                Matrix3D instance = (Matrix3D) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DCollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DCollectionValueSerializer.cs
index e15ee125..fb0f2ecf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DCollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DCollectionValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Point3DCollection)
+            if (value is Point3DCollection instance)
             {
-                Point3DCollection instance = (Point3DCollection) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DValueSerializer.cs
index 142cd55c..4b484253 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point3DValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Point3D)
+            if (value is Point3D instance)
             {
-                Point3D instance = (Point3D) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point4DValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point4DValueSerializer.cs
index 9df1cb86..2182ba7e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point4DValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Point4DValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Point4D)
+            if (value is Point4D instance)
             {
-                Point4D instance = (Point4D) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/QuaternionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/QuaternionValueSerializer.cs
index 12527cfb..0d30a5f7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/QuaternionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/QuaternionValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Quaternion)
+            if (value is Quaternion instance)
             {
-                Quaternion instance = (Quaternion) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Rect3DValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Rect3DValueSerializer.cs
index f1ce866d..a70f74e4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Rect3DValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Rect3DValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Rect3D)
+            if (value is Rect3D instance)
             {
-                Rect3D instance = (Rect3D) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Size3DValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Size3DValueSerializer.cs
index 8d836188..4fd2e7dc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Size3DValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Size3DValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Size3D)
+            if (value is Size3D instance)
             {
-                Size3D instance = (Size3D) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DCollectionValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DCollectionValueSerializer.cs
index 883db0da..c1de8851 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DCollectionValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DCollectionValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Vector3DCollection)
+            if (value is Vector3DCollection instance)
             {
-                Vector3DCollection instance = (Vector3DCollection) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DValueSerializer.cs
index 0ca5d42d..e43120ca 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Converters/Generated/Vector3DValueSerializer.cs
@@ -85,10 +85,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Vector3D)
+            if (value is Vector3D instance)
             {
-                Vector3D instance = (Vector3D) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/MaterialGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/MaterialGroup.cs
index 0c24d179..88d26be0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/MaterialGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/MaterialGroup.cs
@@ -144,8 +144,7 @@ private static void ChildrenPropertyChanged(DependencyObject d, DependencyProper
                             int count = newCollection.Count;
                             for (int i = 0; i < count; i++)
                             {
-                                DUCE.IResource resource = newCollection.Internal_GetItem(i) as DUCE.IResource;
-                                Debug.Assert(resource != null);
+                                Debug.Assert(newCollection.Internal_GetItem(i) is DUCE.IResource resource);
                                 resource.AddRefOnChannel(channel);
                             }
                         }
@@ -155,8 +154,7 @@ private static void ChildrenPropertyChanged(DependencyObject d, DependencyProper
                             int count = oldCollection.Count;
                             for (int i = 0; i < count; i++)
                             {
-                                DUCE.IResource resource = oldCollection.Internal_GetItem(i) as DUCE.IResource;
-                                Debug.Assert(resource != null);
+                                Debug.Assert(newCollection.Internal_GetItem(i) is DUCE.IResource resource);
                                 resource.ReleaseOnChannel(channel);
                             }
                         }
@@ -333,10 +331,7 @@ private void ChildrenItemInserted(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource addResource = item as DUCE.IResource;
-                        if (addResource != null)
-                        {
-                            addResource.AddRefOnChannel(channel);
-                        }
+                        addResource?.AddRefOnChannel(channel);
 
                         UpdateResource(channel, true /* skip on channel check */);
                     }
@@ -363,10 +358,7 @@ private void ChildrenItemRemoved(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource releaseResource = item as DUCE.IResource;
-                        if (releaseResource != null)
-                        {
-                            releaseResource.ReleaseOnChannel(channel);
-                        }
+                        releaseResource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Matrix3DConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Matrix3DConverter.cs
index 4595866c..5bd78701 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Matrix3DConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Matrix3DConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Matrix3D.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Model3DGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Model3DGroup.cs
index 8f222d49..9c4e0552 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Model3DGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Model3DGroup.cs
@@ -354,10 +354,7 @@ private void ChildrenItemInserted(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource addResource = item as DUCE.IResource;
-                        if (addResource != null)
-                        {
-                            addResource.AddRefOnChannel(channel);
-                        }
+                        addResource?.AddRefOnChannel(channel);
 
                         UpdateResource(channel, true /* skip on channel check */);
                     }
@@ -384,10 +381,7 @@ private void ChildrenItemRemoved(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource releaseResource = item as DUCE.IResource;
-                        if (releaseResource != null)
-                        {
-                            releaseResource.ReleaseOnChannel(channel);
-                        }
+                        releaseResource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollection.cs
index aa0e15ba..ec469e51 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollection.cs
@@ -331,9 +331,9 @@ int IList.Add(object value)
 
         bool IList.Contains(object value)
         {
-            if (value is Point3D)
+            if (value is Point3D point3D)
             {
-                return Contains((Point3D)value);
+                return Contains(point3D);
             }
 
             return false;
@@ -341,9 +341,9 @@ bool IList.Contains(object value)
 
         int IList.IndexOf(object value)
         {
-            if (value is Point3D)
+            if (value is Point3D point3D)
             {
-                return IndexOf((Point3D)value);
+                return IndexOf(point3D);
             }
 
             return -1;
@@ -357,9 +357,9 @@ void IList.Insert(int index, object value)
 
         void IList.Remove(object value)
         {
-            if (value is Point3D)
+            if (value is Point3D point3D)
             {
-                Remove((Point3D)value);
+                Remove(point3D);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollectionConverter.cs
index c00b10be..ef5bc200 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DCollectionConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Point3DCollection.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DConverter.cs
index 00810d3e..599ce0dc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point3DConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Point3D.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point4DConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point4DConverter.cs
index 7144b4e7..63ae924c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point4DConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Point4DConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Point4D.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/QuaternionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/QuaternionConverter.cs
index 1543637c..6a462a6a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/QuaternionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/QuaternionConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Quaternion.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Rect3DConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Rect3DConverter.cs
index 13613c8b..19b9fc12 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Rect3DConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Rect3DConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Rect3D.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Size3DConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Size3DConverter.cs
index 96944064..7723fc82 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Size3DConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Size3DConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Size3D.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Transform3DGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Transform3DGroup.cs
index 85fa1026..4a8f3f6b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Transform3DGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Transform3DGroup.cs
@@ -333,10 +333,7 @@ private void ChildrenItemInserted(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource addResource = item as DUCE.IResource;
-                        if (addResource != null)
-                        {
-                            addResource.AddRefOnChannel(channel);
-                        }
+                        addResource?.AddRefOnChannel(channel);
 
                         UpdateResource(channel, true /* skip on channel check */);
                     }
@@ -363,10 +360,7 @@ private void ChildrenItemRemoved(object sender, object item)
 
                         // We're on a channel, which means our dependents are also on the channel.
                         DUCE.IResource releaseResource = item as DUCE.IResource;
-                        if (releaseResource != null)
-                        {
-                            releaseResource.ReleaseOnChannel(channel);
-                        }
+                        releaseResource?.ReleaseOnChannel(channel);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollection.cs
index 4ef06ea1..8c1d1189 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollection.cs
@@ -331,9 +331,9 @@ int IList.Add(object value)
 
         bool IList.Contains(object value)
         {
-            if (value is Vector3D)
+            if (value is Vector3D vector3D)
             {
-                return Contains((Vector3D)value);
+                return Contains(vector3D);
             }
 
             return false;
@@ -341,9 +341,9 @@ bool IList.Contains(object value)
 
         int IList.IndexOf(object value)
         {
-            if (value is Vector3D)
+            if (value is Vector3D vector3D)
             {
-                return IndexOf((Vector3D)value);
+                return IndexOf(vector3D);
             }
 
             return -1;
@@ -357,9 +357,9 @@ void IList.Insert(int index, object value)
 
         void IList.Remove(object value)
         {
-            if (value is Vector3D)
+            if (value is Vector3D vector3D)
             {
-                Remove((Vector3D)value);
+                Remove(vector3D);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollectionConverter.cs
index 80938e8d..c4dba554 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DCollectionConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Vector3DCollection.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DConverter.cs
index cf1dcfc1..4b1ba007 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Vector3DConverter.cs
@@ -98,9 +98,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Vector3D.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Visual3D.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Visual3D.cs
index a83eaf73..c8314995 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Visual3D.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Generated/Visual3D.cs
@@ -241,10 +241,7 @@ public object GetAnimationBaseValue(DependencyProperty dp)
             {
                 AnimationStorage storage = AnimationStorage.GetStorage(this, dp);
 
-                if (storage != null)
-                {
-                    storage.EvaluateAnimatedValue(metadata, ref entry);                      
-                }
+                storage?.EvaluateAnimatedValue(metadata, ref entry);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/RayHitTestParameters.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/RayHitTestParameters.cs
index ea7b13c4..dd1f6779 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/RayHitTestParameters.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/RayHitTestParameters.cs
@@ -128,9 +128,8 @@ public Vector3D Direction
                 RayHitTestResult result = results[i];
 
                 result.SetDistanceToRayOrigin(result.DistanceToRayOrigin + distanceAdjustment);
-                
-                Viewport2DVisual3D viewport2DVisual3D = result.VisualHit as Viewport2DVisual3D;
-                if (viewport2DVisual3D != null)
+
+                if (result.VisualHit is Viewport2DVisual3D viewport2DVisual3D)
                 {
                     Point intersectionPoint;
                     Visual viewport2DVisual3DChild = viewport2DVisual3D.Visual;
@@ -191,10 +190,7 @@ internal void GetLocalLine(out Point3D origin, out Vector3D direction)
 
         internal void ClearResults()
         {
-            if (results != null)
-            {
-                results.Clear();
-            }
+            results?.Clear();
         }
 
         #endregion Internal Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport2DVisual3D.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport2DVisual3D.cs
index a273d5e9..4399e6c3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport2DVisual3D.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport2DVisual3D.cs
@@ -185,8 +185,7 @@ internal static bool GetIntersectionInfo(RayHitTestResult rayHitResult, out Poin
             outputPoint = new Point();
 
             // try to cast to a RaymeshGeometry3DHitTestResult
-            RayMeshGeometry3DHitTestResult rayMeshResult = rayHitResult as RayMeshGeometry3DHitTestResult;
-            if (rayMeshResult != null)
+            if (rayHitResult is RayMeshGeometry3DHitTestResult rayMeshResult)
             {
                 // we can now extract the mesh and visual for the object we hit
                 MeshGeometry3D geom = rayMeshResult.MeshHit;
@@ -486,37 +485,32 @@ private void SwapInCyclicBrush(Material material)
             {
                 Material currMaterial = materialStack.Pop();
 
-                if (currMaterial is DiffuseMaterial)
+                if (currMaterial is DiffuseMaterial diffMaterial)
                 {
-                    DiffuseMaterial diffMaterial = (DiffuseMaterial)currMaterial;
                     if ((Boolean)diffMaterial.GetValue(Viewport2DVisual3D.IsVisualHostMaterialProperty))
                     {
                         diffMaterial.Brush = internalBrush;
                         numMaterialsSwapped++;
                     }
                 }
-                else if (currMaterial is EmissiveMaterial)
+                else if (currMaterial is EmissiveMaterial emmMaterial)
                 {
-                    EmissiveMaterial emmMaterial = (EmissiveMaterial)currMaterial;
                     if ((Boolean)emmMaterial.GetValue(Viewport2DVisual3D.IsVisualHostMaterialProperty))
                     {
                         emmMaterial.Brush = internalBrush;
                         numMaterialsSwapped++;
                     }
                 }
-                else if (currMaterial is SpecularMaterial)
+                else if (currMaterial is SpecularMaterial specMaterial)
                 {
-                    SpecularMaterial specMaterial = (SpecularMaterial)currMaterial;
                     if ((Boolean)specMaterial.GetValue(Viewport2DVisual3D.IsVisualHostMaterialProperty))
                     {
                         specMaterial.Brush = internalBrush;
                         numMaterialsSwapped++;
                     }
                 }
-                else if (currMaterial is MaterialGroup)
+                else if (currMaterial is MaterialGroup matGroup)
                 {
-                    MaterialGroup matGroup = (MaterialGroup)currMaterial;
-
                     // the IsVisualHostMaterialProperty should not be set on a MaterialGroup - verify that
                     if ((Boolean)matGroup.GetValue(Viewport2DVisual3D.IsVisualHostMaterialProperty))
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport3DVisual.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport3DVisual.cs
index 8386e577..0e49eaf7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport3DVisual.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Viewport3DVisual.cs
@@ -346,10 +346,7 @@ void IVisual3DContainer.AddChild(Visual3D child)
             child.SetParent(this);
 
             // set the inheritance context so databinding, etc... work
-            if (_inheritanceContextForChildren != null)
-            {
-                _inheritanceContextForChildren.ProvideSelfAsInheritanceContext(child, null);
-            }
+            _inheritanceContextForChildren?.ProvideSelfAsInheritanceContext(child, null);
 
             SetFlagsOnAllChannels(true, VisualProxyFlags.IsContentDirty);
 
@@ -399,10 +396,7 @@ void IVisual3DContainer.RemoveChild(Visual3D child)
             child.SetParent(/* newParent = */ (Visual) null);  // CS0121: Call is ambigious without casting null to Visual.
 
             // remove the inheritance context
-            if (_inheritanceContextForChildren != null)
-            {
-                _inheritanceContextForChildren.RemoveSelfAsInheritanceContext(child, null);
-            }
+            _inheritanceContextForChildren?.RemoveSelfAsInheritanceContext(child, null);
 
             //
             // Remove the child on all channels this visual is marshalled to.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Visual3D.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Visual3D.cs
index c12cbf34..8f9effde 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Visual3D.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/Media3D/Visual3D.cs
@@ -654,9 +654,7 @@ internal bool DoesRayHitSubgraphBounds(RayHitTestParameters rayParams)
 
             VerifyAPIReadWrite();
 
-            RayHitTestParameters rayParams = hitTestParameters as RayHitTestParameters;
-
-            if (rayParams != null)
+            if (hitTestParameters is RayHitTestParameters rayParams)
             {
                 // In case the user is reusing the same RayHitTestParameters
                 rayParams.ClearResults();
@@ -1701,14 +1699,10 @@ private GeneralTransform3D InternalTransformToAncestor(Visual3D ancestor, bool i
 
             while ((VisualTreeHelper.GetParent(g) != null) && (g != ancestor))
             {
-                Visual3D gAsVisual3D = g as Visual3D;
-                if (gAsVisual3D != null)
+                if (g is Visual3D gAsVisual3D)
                 {
                     Transform3D transform = gAsVisual3D.Transform;
-                    if (transform != null)
-                    {
-                        transform.Append(ref m);
-                    }
+                    transform?.Append(ref m);
 
                     lastVisual3D = gAsVisual3D;
                     g = VisualTreeHelper.GetParent(gAsVisual3D);
@@ -1783,10 +1777,7 @@ private GeneralTransform3D InternalTransformToAncestor(Visual3D ancestor, bool i
                 }
             }
 
-            if (finalTransform != null)
-            {
-                finalTransform.Freeze();
-            }
+            finalTransform?.Freeze();
 
             return finalTransform;
         }
@@ -2090,12 +2081,11 @@ internal bool CheckFlagsOr(VisualFlags flags)
                 // continue the walk in 2D.
                 if (e._3DParent == null)
                 {
-                    Viewport3DVisual viewport = e.InternalVisualParent as Viewport3DVisual;
 
                     Debug.Assert((viewport == null) == (e.InternalVisualParent == null),
                         "Viewport3DVisual is the only supported 2D parent of a 3D visual.");
 
-                    if(viewport != null)
+                    if(e.InternalVisualParent is Viewport3DVisual viewport)
                     {
                         // We must notify the 2D visual that its contents have changed.
                         // This will cause the 2D visual to set it's content dirty flag
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseCaptureWithinProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseCaptureWithinProperty.cs
index fb046006..68dceb68 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseCaptureWithinProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseCaptureWithinProperty.cs
@@ -39,10 +39,7 @@ internal override void FireNotifications(UIElement uie, ContentElement ce, UIEle
             {
                 ce.RaiseIsMouseCaptureWithinChanged(args);
             }
-            else if (uie3D != null)
-            {
-                uie3D.RaiseIsMouseCaptureWithinChanged(args);
-            }
+            else uie3D?.RaiseIsMouseCaptureWithinChanged(args);
         }
     }
 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseOverProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseOverProperty.cs
index 4fc9c7fb..7d7612f1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseOverProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/MouseOverProperty.cs
@@ -57,10 +57,7 @@ internal override void FireNotifications(UIElement uie, ContentElement ce, UIEle
                 {
                     ce.RaiseEvent(mouseEventArgs);
                 }
-                else if (uie3D != null)
-                {
-                    uie3D.RaiseEvent(mouseEventArgs);
-                }
+                else uie3D?.RaiseEvent(mouseEventArgs);
             }
         }
     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/PresentationSource.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/PresentationSource.cs
index 5a167579..45b7b398 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/PresentationSource.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/PresentationSource.cs
@@ -446,36 +446,21 @@ protected void RootChanged(Visual oldRoot, Visual newRoot)
             }
             
             // Always set the SourceProperty on the new root.
-            if (newRoot != null)
-            {
-                newRoot.SetValue(RootSourceProperty, new SecurityCriticalDataForMultipleGetAndSet<PresentationSource>(this));
-            }
+            newRoot?.SetValue(RootSourceProperty, new SecurityCriticalDataForMultipleGetAndSet<PresentationSource>(this));
 
             UIElement oldRootUIElement = oldRoot as UIElement;
             UIElement newRootUIElement = newRoot as UIElement;
 
             // The IsVisible property can only be true if root visual is connected to a presentation source.
             // For Read-Only force-inherited properties, use a private update method.
-            if(oldRootUIElement != null)
-            {
-                oldRootUIElement.UpdateIsVisibleCache();
-            }
-            if(newRootUIElement != null)
-            {
-                newRootUIElement.UpdateIsVisibleCache();
-            }
+            oldRootUIElement?.UpdateIsVisibleCache();
+            newRootUIElement?.UpdateIsVisibleCache();
 
             // Broadcast the Unloaded event starting at the old root visual
-            if (oldRootUIElement != null)
-            {
-                oldRootUIElement.OnPresentationSourceChanged(false);
-            }
+            oldRootUIElement?.OnPresentationSourceChanged(false);
 
             // Broadcast the Loaded event starting at the root visual
-            if (newRootUIElement != null)
-            {
-                newRootUIElement.OnPresentationSourceChanged(true);
-            }
+            newRootUIElement?.OnPresentationSourceChanged(true);
 
             // To fire PresentationSourceChanged when the RootVisual changes;
             // rather than simulate a "parent" pointer change, we just walk the
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/ReverseInheritProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/ReverseInheritProperty.cs
index 2b15e1cc..ea125485 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/ReverseInheritProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/ReverseInheritProperty.cs
@@ -266,10 +266,7 @@ private static void SetFlag(UIElement uie, ContentElement ce, UIElement3D uie3D,
             {
                 ce.WriteFlag(flag, value);
             }
-            else if (uie3D != null)
-            {
-                uie3D.WriteFlag(flag, value);
-            }
+            else uie3D?.WriteFlag(flag, value);
         }
 
         /////////////////////////////////////////////////////////////////////
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/RoutedEventHandlerInfo.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/RoutedEventHandlerInfo.cs
index c8dc909a..d0f63943 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/RoutedEventHandlerInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/RoutedEventHandlerInfo.cs
@@ -88,7 +88,7 @@ internal void InvokeHandler(object target, RoutedEventArgs routedEventArgs)
         /// </summary>
         public override bool Equals(object obj)
         {
-            if (obj == null || !(obj is RoutedEventHandlerInfo))
+            if (!(obj is RoutedEventHandlerInfo))
                 return false;
 
             return Equals((RoutedEventHandlerInfo)obj);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusCaptureWithinProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusCaptureWithinProperty.cs
index 704e652a..c14cbf1c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusCaptureWithinProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusCaptureWithinProperty.cs
@@ -39,10 +39,7 @@ internal override void FireNotifications(UIElement uie, ContentElement ce, UIEle
             {
                 ce.RaiseIsStylusCaptureWithinChanged(args);
             }
-            else if (uie3D != null)
-            {
-                uie3D.RaiseIsStylusCaptureWithinChanged(args);
-            }
+            else uie3D?.RaiseIsStylusCaptureWithinChanged(args);
         }
     }
 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusOverProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusOverProperty.cs
index 43ae2406..323d4e37 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusOverProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/StylusOverProperty.cs
@@ -49,10 +49,7 @@ internal override void FireNotifications(UIElement uie, ContentElement ce, UIEle
             {
                 ce.RaiseEvent(stylusEventArgs);
             }
-            else if (uie3D != null)
-            {
-                uie3D.RaiseEvent(stylusEventArgs);
-            }
+            else uie3D?.RaiseEvent(stylusEventArgs);
         }
     }
 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement.cs
index 5ffd0310..ade6ec45 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement.cs
@@ -1445,9 +1445,7 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
 
                 if (!InputElement.IsUIElement(parent) && !InputElement.IsUIElement3D(parent))
                 {
-                    Visual parentAsVisual = parent as Visual;
-
-                    if (parentAsVisual != null)
+                    if (parent is Visual parentAsVisual)
                     {
                         // We are being plugged into a non-UIElement visual. This
                         // means that our parent doesn't play by the same rules we
@@ -1460,9 +1458,8 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                     }
                     else
                     {
-                        Visual3D parentAsVisual3D = parent as Visual3D;
 
-                        if (parentAsVisual3D != null)
+                        if (parent is Visual3D parentAsVisual3D)
                         {
                             // We are being plugged into a non-UIElement visual. This
                             // means that our parent doesn't play by the same rules we
@@ -1496,13 +1493,13 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                     // means that our parent didn't play by the same rules we
                     // do, so we started track changes to our ancestors in
                     // order to bridge the gap.  Now we can stop.
-                    if (oldParent is Visual)
+                    if (oldParent is Visual visual)
                     {
-                        ((Visual) oldParent).VisualAncestorChanged -= new AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
+                        visual.VisualAncestorChanged -= new AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
                     }
-                    else if (oldParent is Visual3D)
+                    else if (oldParent is Visual3D visual3D)
                     {
-                        ((Visual3D) oldParent).VisualAncestorChanged -= new AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
+                        visual3D.VisualAncestorChanged -= new AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
                     }
 
                     // Try to find a UIElement ancestor to use for coersion.
@@ -1672,7 +1669,6 @@ internal static void BuildRouteHelper(DependencyObject e, EventRoute route, Rout
             // Route via visual tree
             if (args.RoutedEvent.RoutingStrategy == RoutingStrategy.Direct)
             {
-                UIElement uiElement = e as UIElement;
                 ContentElement contentElement = null;
                 UIElement3D uiElement3D = null;
 
@@ -1687,7 +1683,7 @@ internal static void BuildRouteHelper(DependencyObject e, EventRoute route, Rout
                 }
 
                 // Add this element to route
-                if (uiElement != null)
+                if (e is UIElement uiElement)
                 {
                     uiElement.AddToEventRoute(route, args);
                 }
@@ -1695,10 +1691,7 @@ internal static void BuildRouteHelper(DependencyObject e, EventRoute route, Rout
                 {
                     contentElement.AddToEventRoute(route, args);
                 }
-                else if (uiElement3D != null)
-                {
-                    uiElement3D.AddToEventRoute(route, args);
-                }
+                else uiElement3D?.AddToEventRoute(route, args);
             }
             else
             {
@@ -1706,7 +1699,6 @@ internal static void BuildRouteHelper(DependencyObject e, EventRoute route, Rout
 
                 while (e != null)
                 {
-                    UIElement uiElement = e as UIElement;
                     ContentElement contentElement = null;
                     UIElement3D uiElement3D = null;
 
@@ -1729,7 +1721,8 @@ internal static void BuildRouteHelper(DependencyObject e, EventRoute route, Rout
 
                     // Allow the element to adjust source
                     object newSource = null;
-                    if (uiElement != null)
+
+                    if (e is UIElement uiElement)
                     {
                         newSource = uiElement.AdjustEventSource(args);
                     }
@@ -1750,7 +1743,8 @@ internal static void BuildRouteHelper(DependencyObject e, EventRoute route, Rout
 
                     // Invoke BuildRouteCore
                     bool continuePastVisualTree = false;
-                                        if (uiElement != null)
+
+                                        if (e is UIElement uiElement)
                     {
                         //Add a Synchronized input pre-opportunity handler just before the class and instance handlers
                         uiElement.AddSynchronizedInputPreOpportunityHandler(route, args);
@@ -1901,22 +1895,19 @@ internal static void AddHandler(DependencyObject d, RoutedEvent routedEvent, Del
 
             Debug.Assert(routedEvent != null, "RoutedEvent must not be null");
 
-            UIElement uiElement = d as UIElement;
-            if (uiElement != null)
+            if (d is UIElement uiElement)
             {
                 uiElement.AddHandler(routedEvent, handler);
             }
             else
             {
-                ContentElement contentElement = d as ContentElement;
-                if (contentElement != null)
+                if (d is ContentElement contentElement)
                 {
                     contentElement.AddHandler(routedEvent, handler);
                 }
                 else
                 {
-                    UIElement3D uiElement3D = d as UIElement3D;
-                    if (uiElement3D != null)
+                    if (d is UIElement3D uiElement3D)
                     {
                         uiElement3D.AddHandler(routedEvent, handler);
                     }
@@ -1941,22 +1932,19 @@ internal static void RemoveHandler(DependencyObject d, RoutedEvent routedEvent,
 
             Debug.Assert(routedEvent != null, "RoutedEvent must not be null");
 
-            UIElement uiElement = d as UIElement;
-            if (uiElement != null)
+            if (d is UIElement uiElement)
             {
                 uiElement.RemoveHandler(routedEvent, handler);
             }
             else
             {
-                ContentElement contentElement = d as ContentElement;
-                if (contentElement != null)
+                if (d is ContentElement contentElement)
                 {
                     contentElement.RemoveHandler(routedEvent, handler);
                 }
                 else
                 {
-                    UIElement3D uiElement3D = d as UIElement3D;
-                    if (uiElement3D != null)
+                    if (d is UIElement3D uiElement3D)
                     {
                         uiElement3D.RemoveHandler(routedEvent, handler);
                     }
@@ -2068,8 +2056,7 @@ internal void InputHitTest(Point pt, out IInputElement enabledHit, out IInputEle
             enabledHit = null;
             while (candidate != null)
             {
-                IContentHost contentHost = candidate as IContentHost;
-                if (contentHost != null)
+                if (candidate is IContentHost contentHost)
                 {
                     // Do not call IContentHost.InputHitTest if the containing UIElement
                     // is not enabled.
@@ -2087,8 +2074,7 @@ internal void InputHitTest(Point pt, out IInputElement enabledHit, out IInputEle
                     }
                 }
 
-                UIElement element = candidate as UIElement;
-                if (element != null)
+                if (candidate is UIElement element)
                 {
                     if (rawHit == null)
                     {
@@ -2104,8 +2090,7 @@ internal void InputHitTest(Point pt, out IInputElement enabledHit, out IInputEle
                     }
                 }
 
-                UIElement3D element3D = candidate as UIElement3D;
-                if (element3D != null)
+                if (candidate is UIElement3D element3D)
                 {
                     if (rawHit == null)
                     {
@@ -3192,11 +3177,7 @@ internal override void RenderClose(IDrawingContent newContent)
             // Prepare the new content.
             //
 
-            if (newContent != null)
-            {
-                // Propagate notification handlers.
-                newContent.PropagateChangedHandler(ContentsChangedHandler, true /* adding */);
-            }
+            newContent?.PropagateChangedHandler(ContentsChangedHandler, true /* adding */);
 
             _drawingContent = newContent;
 
@@ -3274,10 +3255,7 @@ internal void WalkContent(DrawingContextWalker walker)
         {
             VerifyAPIReadOnly();
 
-            if (_drawingContent != null)
-            {
-                _drawingContent.WalkContent(walker);
-            }
+            _drawingContent?.WalkContent(walker);
         }
 
         /// <summary>
@@ -4267,12 +4245,10 @@ internal static void InvalidateForceInheritPropertyOnChildren(Visual v, Dependen
             {
                 DependencyObject child = v.InternalGet2DOr3DVisualChild(iChild);
 
-                Visual vChild = child as Visual;
-                if (vChild != null)
+                if (child is Visual vChild)
                 {
-                    UIElement element = vChild as UIElement;
 
-                    if (element != null)
+                    if (vChild is UIElement element)
                     {
                         if(property == IsVisibleProperty)
                         {
@@ -4295,13 +4271,11 @@ internal static void InvalidateForceInheritPropertyOnChildren(Visual v, Dependen
                 }
                 else
                 {
-                    Visual3D v3DChild = child as Visual3D;
 
-                    if (v3DChild != null)
+                    if (child is Visual3D v3DChild)
                     {
-                        UIElement3D element3D = v3DChild as UIElement3D;
 
-                        if(element3D != null)
+                        if(v3DChild is UIElement3D element3D)
                         {
                             if(property == IsVisibleProperty)
                             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement3D.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement3D.cs
index f6761dfe..c690dc5f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement3D.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/UIElement3D.cs
@@ -150,9 +150,7 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
 
                 if (!InputElement.IsUIElement(parent) && !InputElement.IsUIElement3D(parent))
                 {
-                    Visual parentAsVisual = parent as Visual;
-
-                    if (parentAsVisual != null)
+                    if (parent is Visual parentAsVisual)
                     {
                         // We are being plugged into a non-UIElement visual. This
                         // means that our parent doesn't play by the same rules we
@@ -162,9 +160,8 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                     }
                     else
                     {
-                        Visual3D parentAsVisual3D = parent as Visual3D;
 
-                        if (parentAsVisual3D != null)
+                        if (parent is Visual3D parentAsVisual3D)
                         {
                             // We are being plugged into a non-UIElement visual. This
                             // means that our parent doesn't play by the same rules we
@@ -198,13 +195,13 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                     // means that our parent didn't play by the same rules we
                     // do, so we started track changes to our ancestors in
                     // order to bridge the gap.  Now we can stop.
-                    if (oldParent is Visual)
+                    if (oldParent is Visual visual)
                     {
-                        ((Visual)oldParent).VisualAncestorChanged -= new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
+                        visual.VisualAncestorChanged -= new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
                     }
-                    else if (oldParent is Visual3D)
+                    else if (oldParent is Visual3D visual3D)
                     {
-                        ((Visual3D)oldParent).VisualAncestorChanged -= new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
+                        visual3D.VisualAncestorChanged -= new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged_ForceInherit);
                     }
 
                     // Try to find a UIElement ancestor to use for coersion.
@@ -1378,10 +1375,7 @@ internal static void InvalidateForceInheritPropertyOnChildren(Visual3D v, Depend
                 DependencyObject vChild = v.InternalGet2DOr3DVisualChild(iChild);
                 if (vChild != null)
                 {
-                    UIElement element = vChild as UIElement;
-                    UIElement3D element3D = vChild as UIElement3D;
-
-                    if (element3D != null)
+                    if (vChild is UIElement3D element3D)
                     {
                         if (property == IsVisibleProperty)
                         {
@@ -1396,7 +1390,7 @@ internal static void InvalidateForceInheritPropertyOnChildren(Visual3D v, Depend
                             element3D.CoerceValue(property);
                         }
                     }
-                    else if (element != null)
+                    else if (vChild is UIElement element)
                     {
                         if (property == IsVisibleProperty)
                         {
@@ -1414,9 +1408,9 @@ internal static void InvalidateForceInheritPropertyOnChildren(Visual3D v, Depend
                     else
                     {
                         // We have to "walk through" non-UIElement visuals.
-                        if (vChild is Visual)
+                        if (vChild is Visual visual)
                         {
-                            ((Visual)vChild).InvalidateForceInheritPropertyOnChildren(property);
+                            visual.InvalidateForceInheritPropertyOnChildren(property);
                         }
                         else
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/clipboard.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/clipboard.cs
index 9f30b4b1..7bbff7a5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/clipboard.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/clipboard.cs
@@ -409,7 +409,7 @@ public static bool IsCurrent(IDataObject data)
 
             bReturn = false;
 
-            if (data is IComDataObject)
+            if (data is IComDataObject iComDataObject)
             {
                 int hr;
 
@@ -419,7 +419,7 @@ public static bool IsCurrent(IDataObject data)
 
                 while (true)
                 {
-                    hr = OleServicesContext.CurrentOleServicesContext.OleIsCurrentClipboard((IComDataObject)data);
+                    hr = OleServicesContext.CurrentOleServicesContext.OleIsCurrentClipboard(iComDataObject);
 
                     if (NativeMethods.Succeeded(hr) || (--i == 0))
                     {
@@ -510,13 +510,13 @@ internal static void CriticalSetDataObject(object data, bool copy)
 
             IComDataObject dataObject;
 
-            if (data is DataObject)
+            if (data is DataObject dataObject)
             {
-                dataObject = (DataObject)data;
+                dataObject = dataObject;
             }
-            else if (data is IComDataObject)
+            else if (data is IComDataObject iComDataObject)
             {
-                dataObject = (IComDataObject)data;
+                dataObject = iComDataObject;
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/dataobject.cs b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/dataobject.cs
index 870cf156..fc73b375 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/dataobject.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationCore/System/Windows/dataobject.cs
@@ -637,9 +637,9 @@ public void SetText(string textData, TextDataFormat format)
         /// <returns></returns>
         int IComDataObject.DAdvise(ref FORMATETC pFormatetc, ADVF advf, IAdviseSink pAdvSink, out int pdwConnection)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                return ((OleConverter)_innerData).OleDataObject.DAdvise(ref pFormatetc, advf, pAdvSink, out pdwConnection);
+                return oleConverter.OleDataObject.DAdvise(ref pFormatetc, advf, pAdvSink, out pdwConnection);
             }
             pdwConnection = 0;
             return (NativeMethods.E_NOTIMPL);
@@ -650,9 +650,9 @@ int IComDataObject.DAdvise(ref FORMATETC pFormatetc, ADVF advf, IAdviseSink pAdv
         /// </summary>
         void IComDataObject.DUnadvise(int dwConnection)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                ((OleConverter)_innerData).OleDataObject.DUnadvise(dwConnection);
+                oleConverter.OleDataObject.DUnadvise(dwConnection);
                 return;
             }
 
@@ -665,9 +665,9 @@ void IComDataObject.DUnadvise(int dwConnection)
         /// </summary>
         int IComDataObject.EnumDAdvise(out IEnumSTATDATA enumAdvise)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                return ((OleConverter)_innerData).OleDataObject.EnumDAdvise(out enumAdvise);
+                return oleConverter.OleDataObject.EnumDAdvise(out enumAdvise);
             }
             enumAdvise = null;
             return (OLE_E_ADVISENOTSUPPORTED);
@@ -678,9 +678,9 @@ int IComDataObject.EnumDAdvise(out IEnumSTATDATA enumAdvise)
         // </summary>
         IEnumFORMATETC IComDataObject.EnumFormatEtc(DATADIR dwDirection)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                return ((OleConverter)_innerData).OleDataObject.EnumFormatEtc(dwDirection);
+                return oleConverter.OleDataObject.EnumFormatEtc(dwDirection);
             }
             if (dwDirection == DATADIR.DATADIR_GET)
             {
@@ -706,9 +706,9 @@ int IComDataObject.GetCanonicalFormatEtc(ref FORMATETC pformatetcIn, out FORMATE
                 return DV_E_LINDEX;
             }
 
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                return ((OleConverter)_innerData).OleDataObject.GetCanonicalFormatEtc(ref pformatetcIn, out pformatetcOut);
+                return oleConverter.OleDataObject.GetCanonicalFormatEtc(ref pformatetcIn, out pformatetcOut);
             }
 
             return DATA_S_SAMEFORMATETC;
@@ -719,9 +719,9 @@ int IComDataObject.GetCanonicalFormatEtc(ref FORMATETC pformatetcIn, out FORMATE
         /// </summary>
         void IComDataObject.GetData(ref FORMATETC formatetc, out STGMEDIUM medium)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                ((OleConverter)_innerData).OleDataObject.GetData(ref formatetc, out medium);
+                oleConverter.OleDataObject.GetData(ref formatetc, out medium);
                 return;
             }
 
@@ -811,9 +811,9 @@ void IComDataObject.GetDataHere(ref FORMATETC formatetc, ref STGMEDIUM medium)
         /// </summary>
         int IComDataObject.QueryGetData(ref FORMATETC formatetc)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                return ((OleConverter)_innerData).OleDataObject.QueryGetData(ref formatetc);
+                return oleConverter.OleDataObject.QueryGetData(ref formatetc);
             }
             if (formatetc.dwAspect == DVASPECT.DVASPECT_CONTENT)
             {
@@ -849,9 +849,9 @@ int IComDataObject.QueryGetData(ref FORMATETC formatetc)
         /// </summary>
         void IComDataObject.SetData(ref FORMATETC pFormatetcIn, ref STGMEDIUM pmedium, bool fRelease)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                ((OleConverter)_innerData).OleDataObject.SetData(ref pFormatetcIn, ref pmedium, fRelease);
+                oleConverter.OleDataObject.SetData(ref pFormatetcIn, ref pmedium, fRelease);
                 return;
             }
 
@@ -1333,9 +1333,9 @@ internal static string[] GetMappedFormats(string format)
         /// </summary>
         private int OleGetDataUnrestricted(ref FORMATETC formatetc, ref STGMEDIUM medium, bool doNotReallocate)
         {
-            if (_innerData is OleConverter)
+            if (_innerData is OleConverter oleConverter)
             {
-                ((OleConverter)_innerData).OleDataObject.GetDataHere(ref formatetc, ref medium);
+                oleConverter.OleDataObject.GetDataHere(ref formatetc, ref medium);
 
                 return NativeMethods.S_OK;
             }
@@ -1555,9 +1555,9 @@ private int GetDataIntoOleStructsByTypeMedimHGlobal(string format, object data,
 
             hr = NativeMethods.E_FAIL;
 
-            if (data is Stream)
+            if (data is Stream stream)
             {
-                hr = SaveStreamToHandle(medium.unionmember, (Stream)data, doNotReallocate);
+                hr = SaveStreamToHandle(medium.unionmember, stream, doNotReallocate);
             }
             else if (IsFormatEqual(format, DataFormats.Html)
                 || IsFormatEqual(format, DataFormats.Xaml))
@@ -1659,9 +1659,7 @@ private int GetDataIntoOleStructsByTypeMedimIStream(string format, object data,
                 // If the format is ISF, we should copy the data from the managed stream to the COM IStream object.
                 if ( format == System.Windows.Ink.StrokeCollection.InkSerializedFormat )
                 {
-                    Stream inkStream = data as Stream;
-
-                    if ( inkStream != null )
+                    if ( data is Stream inkStream )
                     {
                         IntPtr size = (IntPtr)inkStream.Length;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/DataIdProcessor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/DataIdProcessor.cs
index 8821b801..8c74daac 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/DataIdProcessor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/DataIdProcessor.cs
@@ -132,8 +132,8 @@ public override IList<IAttachedAnnotation> PostProcessNode(DependencyObject node
             if (!fetchAsBatch && !childrenCalledProcessAnnotations && dataId != DependencyProperty.UnsetValue)
             {
                 FrameworkElement nodeParent = null;
-                FrameworkElement feNode = node as FrameworkElement;
-                if (feNode != null)
+
+                if (node is FrameworkElement feNode)
                 {
                     nodeParent = feNode.Parent as FrameworkElement;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/FixedTextSelectionProcessor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/FixedTextSelectionProcessor.cs
index 306295ef..774380fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/FixedTextSelectionProcessor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/FixedTextSelectionProcessor.cs
@@ -270,19 +270,15 @@ public override Object ResolveLocatorPart(ContentLocatorPart locatorPart, Depend
                 throw new ArgumentNullException("startNode");
 
             DocumentPage docPage = null;
-            FixedPage page = startNode as FixedPage;
 
-            if (page != null)
+            if (startNode is FixedPage page)
             {
                 docPage = GetDocumentPage(page);
             }
             else
             {
-                // If we were passed a DPV because we are walking the visual tree,
-                // extract the DocumentPage from it;  its TextView will be used to
-                // turn coordinates into text positions
-                DocumentPageView dpv = startNode as DocumentPageView;
-                if (dpv != null)
+                // If we were passed a DPV because we are walking the visual tree,                // extract the DocumentPage from it;  its TextView will be used to                // turn coordinates into text positions
+                if (startNode is DocumentPageView dpv)
                 {
                     docPage = dpv.DocumentPage as FixedDocumentPage;
                     if (docPage == null)
@@ -413,16 +409,12 @@ private DocumentPage GetDocumentPage(FixedPage page)
             Invariant.Assert(page != null);
 
             DocumentPage docPage = null;
-            PageContent content = page.Parent as PageContent;
-            if (content != null)
+
+            if (page.Parent is PageContent content)
             {
                 FixedDocument document = content.Parent as FixedDocument;
-
-                // If the document is part of a FixedDocumentSequence then we want to get the 
-                // FixedDocumentSequenceDocumentPage for the FixedPage (cause its TextView is 
-                // the one we want to use).
-                FixedDocumentSequence sequence = document.Parent as FixedDocumentSequence;
-                if (sequence != null)
+                // If the document is part of a FixedDocumentSequence then we want to get the                 // FixedDocumentSequenceDocumentPage for the FixedPage (cause its TextView is                 // the one we want to use).
+                if (document.Parent is FixedDocumentSequence sequence)
                 {
                     docPage = sequence.GetPage(document, document.GetIndexOfPage(page));
                 }
@@ -447,17 +439,15 @@ private IList<TextSegment> CheckSelection(object selection)
 
             IList<TextSegment> textSegments = null;
             ITextPointer start = null;
-            ITextRange textRange = selection as ITextRange;
 
-            if (textRange != null)
+            if (selection is ITextRange textRange)
             {
                 start = textRange.Start;
                 textSegments = textRange.TextSegments;
             }
             else
             {
-                TextAnchor anchor = selection as TextAnchor;
-                if (anchor != null)
+                if (selection is TextAnchor anchor)
                 {
                     start = anchor.Start;
                     textSegments = anchor.TextSegments;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/PathNode.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/PathNode.cs
index 1ff7bf6c..e84410a0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/PathNode.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/PathNode.cs
@@ -239,9 +239,8 @@ internal static DependencyObject GetParent(DependencyObject node)
                 if (parent == null)
                 {
                     // Try for Visual parent
-                    Visual visual = current as Visual;
 
-                    if (visual != null)
+                    if (current is Visual visual)
                     {
                         // This is a Visual node, get parent
                         parent = VisualTreeHelper.GetParent(visual);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/TextSelectionProcessor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/TextSelectionProcessor.cs
index 45a99e50..1e2438c4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/TextSelectionProcessor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Anchoring/TextSelectionProcessor.cs
@@ -472,8 +472,8 @@ private ITextContainer GetTextContainer(DependencyObject startNode)
             Debug.Assert(startNode != null);
 
             ITextContainer textContainer = null;
-            IServiceProvider serviceProvider = startNode as IServiceProvider;
-            if (serviceProvider != null)
+
+            if (startNode is IServiceProvider serviceProvider)
             {
                 textContainer = serviceProvider.GetService(typeof(ITextContainer)) as ITextContainer;
             }
@@ -481,8 +481,7 @@ private ITextContainer GetTextContainer(DependencyObject startNode)
             if (textContainer == null)
             {
                 // Special case for TextBox which doesn't implement IServiceProvider
-                TextBoxBase textBox = startNode as TextBoxBase;
-                if (textBox != null)
+                if (startNode is TextBoxBase textBox)
                 {
                     textContainer = textBox.TextContainer;
                 }
@@ -509,8 +508,7 @@ private bool GetNodesStartAndEnd(DependencyObject startNode, out ITextPointer st
             else
             {
                 // Special case for TextElement which doesn't expose its TextContainer
-                TextElement textElement = startNode as TextElement;
-                if (textElement != null)
+                if (startNode is TextElement textElement)
                 {
                     start = textElement.ContentStart;
                     end = textElement.ContentEnd;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/AdornerPresentationContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/AdornerPresentationContext.cs
index 884eead0..88ca1da7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/AdornerPresentationContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/AdornerPresentationContext.cs
@@ -211,9 +211,8 @@ public override void RemoveFromHost(IAnnotationComponent component, bool reorder
                 foundAdorner.RemoveChildren();
 
                 // now get rid of reference from presentation context of annotation component to annotation adorner
-                AdornerPresentationContext p = component.PresentationContext as AdornerPresentationContext;
 
-                if (p != null) p.ResetInternalAnnotationAdorner();
+                if (component.PresentationContext is AdornerPresentationContext p) p.ResetInternalAnnotationAdorner();
 
                 // finally get rid of reference from annotation component to presentation context
                 component.PresentationContext = null;
@@ -275,9 +274,7 @@ public override void SendToBack(IAnnotationComponent component)
         /// <returns>True if the objects are equal. False otherwise.</returns>
         public override bool Equals(object o)
         {
-            AdornerPresentationContext p = o as AdornerPresentationContext;
-
-            if (p != null)
+            if (o is AdornerPresentationContext p)
             {
                 return (p._adornerLayer == this._adornerLayer);
             }
@@ -386,9 +383,7 @@ private AnnotationAdorner FindAnnotationAdorner(IAnnotationComponent component)
 
             foreach (Adorner adorner in _adornerLayer.GetAdorners(component.AnnotatedElement))
             {
-                AnnotationAdorner annotationAdorner = adorner as AnnotationAdorner;
-
-                if (annotationAdorner != null && annotationAdorner.AnnotationComponent == component) return annotationAdorner;
+                if (adorner is AnnotationAdorner annotationAdorner && annotationAdorner.AnnotationComponent == component) return annotationAdorner;
             }
 
             return null;
@@ -411,8 +406,8 @@ private List<AnnotationAdorner> GetTopAnnotationAdorners(int level, IAnnotationC
             for (int i = 0; i < count; i++)
             {
                 DependencyObject child = VisualTreeHelper.GetChild(_adornerLayer, i);
-                AnnotationAdorner adorner = child as AnnotationAdorner;
-                if (adorner != null)
+
+                if (child is AnnotationAdorner adorner)
                 {
                     IAnnotationComponent childComponent = adorner.AnnotationComponent;
                     if ((childComponent != component) &&
@@ -470,8 +465,8 @@ private static int GetNextZOrder(AdornerLayer adornerLayer, int level)
             for (int i = 0; i < count; i++)
             {
                 DependencyObject child = VisualTreeHelper.GetChild(adornerLayer, i);
-                AnnotationAdorner adorner = child as AnnotationAdorner;
-                if (adorner != null)
+
+                if (child is AnnotationAdorner adorner)
                 {
                     if ((GetComponentLevel(adorner.AnnotationComponent) == level) &&
                         (adorner.AnnotationComponent.ZOrder >= res))
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/MarkedHighlightComponent.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/MarkedHighlightComponent.cs
index decc3ed5..c0d38320 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/MarkedHighlightComponent.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Component/MarkedHighlightComponent.cs
@@ -656,7 +656,7 @@ private void UnregisterComponent()
         /// </summary>
         private void UpdateGeometry()
         {
-            if ((HighlightAnchor == null) || !(HighlightAnchor is IHighlightRange))
+            if (!(HighlightAnchor is IHighlightRange))
             {
                 throw new Exception(SR.Get(SRID.UndefinedHighlightAnchor));
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Storage/StoreAnnotationsMap.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Storage/StoreAnnotationsMap.cs
index 934fcc83..d47350c9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Storage/StoreAnnotationsMap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Annotations/Storage/StoreAnnotationsMap.cs
@@ -130,8 +130,7 @@ public void RemoveAnnotation(Guid id)
                 {
                     foreach (ContentLocatorBase locator in resource.ContentLocators)
                     {
-                        ContentLocator ContentLocator = locator as ContentLocator;
-                        if (ContentLocator != null)
+                        if (locator is ContentLocator ContentLocator)
                         {
                             if (ContentLocator.StartsWith(anchorLocator))
                             {
@@ -140,8 +139,7 @@ public void RemoveAnnotation(Guid id)
                         }
                         else
                         {
-                            ContentLocatorGroup ContentLocatorGroup = locator as ContentLocatorGroup;
-                            if (ContentLocatorGroup != null)
+                            if (locator is ContentLocatorGroup ContentLocatorGroup)
                             {
                                 foreach (ContentLocator list in ContentLocatorGroup.Locators)
                                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/AssemblyFilter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/AssemblyFilter.cs
index 4c8d9bd7..bd51e8bc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/AssemblyFilter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/AssemblyFilter.cs
@@ -80,7 +80,7 @@ private string AssemblyNameWithFileVersion(Assembly a)
             StringBuilder sb = new StringBuilder(a.FullName);
 
             fileVersionInfo = FileVersionInfo.GetVersionInfo(a.Location);
-            if (fileVersionInfo != null && fileVersionInfo.ProductVersion != null)
+            if (fileVersionInfo?.ProductVersion != null)
             {
                 sb.Append(FILEVERSION_STRING + fileVersionInfo.ProductVersion);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/JournalNavigationScope.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/JournalNavigationScope.cs
index 1feeb2dc..3495ee79 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/JournalNavigationScope.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/JournalNavigationScope.cs
@@ -333,10 +333,7 @@ internal bool NavigateToEntry(JournalEntry entry)
 
         internal void AbortJournalNavigation()
         {
-            if (_journal != null)
-            {
-                _journal.AbortJournalNavigation();
-            }
+            _journal?.AbortJournalNavigation();
         }
 
         internal INavigatorBase FindTarget(string name)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/Journaling.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/Journaling.cs
index 93f4cd27..d3448a0d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/Journaling.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/AppModel/Journaling.cs
@@ -705,10 +705,7 @@ private void InitializeComponent(PageFunctionBase pageFunction)
         {
             // Need to explicitly add a call to InitializeComponent() for Page
             IComponentConnector iComponentConnector = pageFunction as IComponentConnector;
-            if (iComponentConnector != null)
-            {
-                iComponentConnector.InitializeComponent();
-            }
+            iComponentConnector?.InitializeComponent();
         }
 
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Commands/CommandHelpers.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Commands/CommandHelpers.cs
index bc9a1e52..fc074012 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Commands/CommandHelpers.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Commands/CommandHelpers.cs
@@ -124,8 +124,7 @@ internal static bool CanExecuteCommandSource(ICommandSource commandSource)
                 object parameter = commandSource.CommandParameter;
                 IInputElement target = commandSource.CommandTarget;
 
-                RoutedCommand routed = command as RoutedCommand;
-                if (routed != null)
+                if (command is RoutedCommand routed)
                 {
                     if (target == null)
                     {
@@ -161,8 +160,7 @@ internal static void CriticalExecuteCommandSource(ICommandSource commandSource,
                 object parameter = commandSource.CommandParameter;
                 IInputElement target = commandSource.CommandTarget;
 
-                RoutedCommand routed = command as RoutedCommand;
-                if (routed != null)
+                if (command is RoutedCommand routed)
                 {
                     if (target == null)
                     {
@@ -182,8 +180,7 @@ internal static void CriticalExecuteCommandSource(ICommandSource commandSource,
         // This allows a caller to override its ICommandSource values (used by Button and ScrollBar)
         internal static void ExecuteCommand(ICommand command, object parameter, IInputElement target)
         {
-            RoutedCommand routed = command as RoutedCommand;
-            if (routed != null)
+            if (command is RoutedCommand routed)
             {
                 if (routed.CanExecute(parameter, target))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/ConnectionPointCookie.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/ConnectionPointCookie.cs
index 729710ea..f233d02e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/ConnectionPointCookie.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/ConnectionPointCookie.cs
@@ -26,10 +26,8 @@ internal class ConnectionPointCookie
         internal ConnectionPointCookie(object source, object sink, Type eventInterface)
         {
             Exception ex = null;
-            if (source is UnsafeNativeMethods.IConnectionPointContainer)
+            if (source is UnsafeNativeMethods.IConnectionPointContainer cpc)
             {
-                UnsafeNativeMethods.IConnectionPointContainer cpc = (UnsafeNativeMethods.IConnectionPointContainer)source;
-
                 try
                 {
                     Guid tmp = eventInterface.GUID;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasFeedbackAdorner.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasFeedbackAdorner.cs
index 34f413ef..6728b4a8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasFeedbackAdorner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasFeedbackAdorner.cs
@@ -119,9 +119,8 @@ private void OnBoundsUpdated(Rect rect)
                 {
                     InvalidateMeasure();
                     InvalidateVisual(); //ensure re-rendering
-                    UIElement parent = ((UIElement)VisualTreeHelper.GetParent(this)) as UIElement;
 
-                    if (parent != null)
+                    if (((UIElement)VisualTreeHelper.GetParent(this))is UIElement parent)
                     {
                         ((UIElement)VisualTreeHelper.GetParent(this)).InvalidateArrange();
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasInnerCanvas.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasInnerCanvas.cs
index b75175ab..3a12eab2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasInnerCanvas.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/InkCanvasInnerCanvas.cs
@@ -58,10 +58,8 @@ protected internal override void OnVisualChildrenChanged(DependencyObject visual
         {
             base.OnVisualChildrenChanged(visualAdded, visualRemoved);
 
-            UIElement removedElement = visualRemoved as UIElement;
-
             // If there is an element being removed, we should make sure to update our selected elements list..
-            if (removedElement != null)
+            if (visualRemoved is UIElement removedElement)
             {
                 InkCanvas.InkCanvasSelection.RemoveElement(removedElement);
             }
@@ -258,15 +256,14 @@ internal UIElement HitTestOnElements(Point point)
             // Now find out which element is hit if there is a result.
             if (hitTestResult != null)
             {
-                Visual visual = hitTestResult.VisualHit as Visual;
-                System.Windows.Media.Media3D.Visual3D visual3D = hitTestResult.VisualHit as System.Windows.Media.Media3D.Visual3D;
 
                 DependencyObject currentObject = null;
-                if (visual != null)
+
+                if (hitTestResult.VisualHit is Visual visual)
                 {
                     currentObject = visual;
                 }
-                else if (visual3D != null)
+                else if (hitTestResult.VisualHit is System.Windows.Media.Media3D.Visual3D visual3D)
                 {
                     currentObject = visual3D;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/StickyNote/StickyNoteAnnotations.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/StickyNote/StickyNoteAnnotations.cs
index 2383138c..f6bec065 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/StickyNote/StickyNoteAnnotations.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/StickyNote/StickyNoteAnnotations.cs
@@ -120,7 +120,7 @@ public static void UpdateAnnotation(XmlToken token, StickyNoteControl snc, SNCAn
             try
             {
                 service = AnnotationService.GetService(((IAnnotationComponent)snc).AnnotatedElement);
-                if (service != null && service.Store != null)
+                if (service?.Store != null)
                 {
                     autoFlush = service.Store.AutoFlush;
                     // Temporarily turn off autoflush until we are done
@@ -151,7 +151,7 @@ public static void UpdateAnnotation(XmlToken token, StickyNoteControl snc, SNCAn
             }
             finally
             {
-                if (service != null && service.Store != null)
+                if (service?.Store != null)
                 {
                     // If auto flush was true before, setting it to true again should cause a flush.
                     service.Store.AutoFlush = autoFlush;
@@ -1383,8 +1383,7 @@ private void OnRequestBringIntoView(Object sender, RequestBringIntoViewEventArgs
             Debug.Assert(((IAnnotationComponent)this).AnnotatedElement != null, "undefined annotated element");
             FrameworkElement target = ((IAnnotationComponent)this).AnnotatedElement as FrameworkElement;
 
-            DocumentPageHost host = target as DocumentPageHost;
-            if (host != null)
+            if (target is DocumentPageHost host)
             {
                 target = host.PageVisual as FrameworkElement;
             }
@@ -1396,8 +1395,7 @@ private void OnRequestBringIntoView(Object sender, RequestBringIntoViewEventArgs
             }
 
             //if target is IScrollInfo - check if we are within the viewport
-            IScrollInfo scrollInfo = target as IScrollInfo;
-            if (scrollInfo != null)
+            if (target is IScrollInfo scrollInfo)
             {
                 Rect bounds = StickyNoteBounds;
                 Rect viewport = new Rect(0, 0, scrollInfo.ViewportWidth, scrollInfo.ViewportHeight);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/TemplatedAdorner.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/TemplatedAdorner.cs
index 1256a53a..4b17dd12 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/TemplatedAdorner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Controls/TemplatedAdorner.cs
@@ -163,10 +163,7 @@ protected override Size ArrangeOverride(Size size)
 
             finalSize = base.ArrangeOverride(size);
 
-            if (_child != null)
-            {
-                _child.Arrange(new Rect(new Point(), finalSize));
-            }
+            _child?.Arrange(new Rect(new Point(), finalSize));
             return finalSize;
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/BindingExpressionUncommonField.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/BindingExpressionUncommonField.cs
index a500324d..9c024b28 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/BindingExpressionUncommonField.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/BindingExpressionUncommonField.cs
@@ -27,10 +27,7 @@ internal new void SetValue(DependencyObject instance, BindingExpression bindingE
         internal new void ClearValue(DependencyObject instance)
         {
             BindingExpression bindingExpr = GetValue(instance);
-            if (bindingExpr != null)
-            {
-                bindingExpr.Detach();
-            }
+            bindingExpr?.Detach();
             base.ClearValue(instance);
         }
     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CLRBindingWorker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CLRBindingWorker.cs
index ae5e9c45..e3336a02 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CLRBindingWorker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CLRBindingWorker.cs
@@ -205,10 +205,7 @@ internal override void AttachDataItem()
         internal override void DetachDataItem()
         {
             PW.DetachFromRootItem();
-            if (XmlWorker != null)
-            {
-                XmlWorker.DetachDataItem();
-            }
+            XmlWorker?.DetachDataItem();
 
             // cancel any pending async requests.  If it has already completed,
             // but is now waiting in the dispatcher queue, it will be ignored because
@@ -351,10 +348,7 @@ internal void NewValueAvailable(bool dependencySourcesChanged, bool initialValue
             // this method is called when the last item in the path is replaced.
             // BindingGroup also wants to know about this.
             BindingGroup bindingGroup = parent.BindingGroup;
-            if (bindingGroup != null)
-            {
-                bindingGroup.UpdateTable(parent);
-            }
+            bindingGroup?.UpdateTable(parent);
 
             if (dependencySourcesChanged)
             {
@@ -414,10 +408,7 @@ internal void OnSourcePropertyChanged(object o, string propName)
                     if (ParentBindingExpression.TargetWantsCrossThreadNotifications)
                     {
                         LiveShapingItem lsi = TargetElement as LiveShapingItem;
-                        if (lsi != null)
-                        {
-                            lsi.OnCrossThreadPropertyChange(TargetProperty);
-                        }
+                        lsi?.OnCrossThreadPropertyChange(TargetProperty);
                     }
 
                     Engine.Marshal(
@@ -547,10 +538,7 @@ internal void ReportRawValueErrors(int k, object item, object info)
         internal void ReportBadXPath(TraceEventType traceType)
         {
             XmlBindingWorker xmlWorker = XmlWorker;
-            if (xmlWorker != null)
-            {
-                xmlWorker.ReportBadXPath(traceType);
-            }
+            xmlWorker?.ReportBadXPath(traceType);
         }
 
         //------------------------------------------------------
@@ -636,10 +624,7 @@ void RequestAsyncGetValue(object item, int level)
 
             // abandon any previous request
             AsyncGetValueRequest pendingGetValueRequest = (AsyncGetValueRequest)GetValue(Feature.PendingGetValueRequest, null);
-            if (pendingGetValueRequest != null)
-            {
-                pendingGetValueRequest.Cancel();
-            }
+            pendingGetValueRequest?.Cancel();
 
             // issue the new request
             pendingGetValueRequest =
@@ -666,10 +651,7 @@ static object OnCompleteGetValueCallback(AsyncDataRequest adr)
             ClrBindingWorker worker = (ClrBindingWorker)request.Args[0];
 
             DataBindEngine engine = worker.Engine;
-            if (engine != null) // could be null if binding has been detached
-            {
-                engine.Marshal(CompleteGetValueLocalCallback, request);
-            }
+            engine?.Marshal(CompleteGetValueLocalCallback, request);
 
             return null;
         }
@@ -720,10 +702,7 @@ void RequestAsyncSetValue(object item, object value)
 
             // abandon any previous request
             AsyncSetValueRequest pendingSetValueRequest = (AsyncSetValueRequest)GetValue(Feature.PendingSetValueRequest, null);
-            if (pendingSetValueRequest != null)
-            {
-                pendingSetValueRequest.Cancel();
-            }
+            pendingSetValueRequest?.Cancel();
 
             // issue the new request
             pendingSetValueRequest =
@@ -748,10 +727,7 @@ static object OnCompleteSetValueCallback(AsyncDataRequest adr)
             ClrBindingWorker worker = (ClrBindingWorker)request.Args[0];
 
             DataBindEngine engine = worker.Engine;
-            if (engine != null) // could be null if binding has been detached
-            {
-                engine.Marshal(CompleteSetValueLocalCallback, request);
-            }
+            engine?.Marshal(CompleteSetValueLocalCallback, request);
 
             return null;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupInternal.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupInternal.cs
index c844a542..98c81718 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupInternal.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupInternal.cs
@@ -196,8 +196,7 @@ internal int Remove(object item, bool returnLeafIndex)
                     index = LeafIndexFromItem(null, localIndex);
                 }
 
-                CollectionViewGroupInternal subGroup = item as CollectionViewGroupInternal;
-                if (subGroup != null)
+                if (item is CollectionViewGroupInternal subGroup)
                 {
                     subGroup.Clear();
 
@@ -237,18 +236,12 @@ internal void Clear()
                 for (int i = 0, n = ProtectedItems.Count; i < n; ++i)
                 {
                     CollectionViewGroupInternal subGroup = ProtectedItems[i] as CollectionViewGroupInternal;
-                    if (subGroup != null)
-                    {
-                        subGroup.Clear();
-                    }
+                    subGroup?.Clear();
                 }
             }
 
             ProtectedItems.Clear();
-            if (_nameToGroupMap != null)
-            {
-                _nameToGroupMap.Clear();
-            }
+            _nameToGroupMap?.Clear();
         }
 
         // return the index of the given item within the list of leaves governed
@@ -258,8 +251,7 @@ internal int LeafIndexOf(object item)
             int leaves = 0;         // number of leaves we've passed over so far
             for (int k = 0, n = Items.Count; k < n; ++k)
             {
-                CollectionViewGroupInternal subgroup = Items[k] as CollectionViewGroupInternal;
-                if (subgroup != null)
+                if (Items[k] is CollectionViewGroupInternal subgroup)
                 {
                     int subgroupIndex = subgroup.LeafIndexOf(item);
                     if (subgroupIndex < 0)
@@ -328,8 +320,7 @@ internal object LeafAt(int index)
         {
             for (int k = 0, n = Items.Count; k < n; ++k)
             {
-                CollectionViewGroupInternal subgroup = Items[k] as CollectionViewGroupInternal;
-                if (subgroup != null)
+                if (Items[k] is CollectionViewGroupInternal subgroup)
                 {
                     // current item is a group - either drill in, or skip over
                     if (index < subgroup.ItemCount)
@@ -398,18 +389,11 @@ protected virtual int FindIndex(object item, object seed, IComparer comparer, in
                 if (comparer != null)
                 {
                     IListComparer ilc = comparer as IListComparer;
-                    if (ilc != null)
-                    {
-                        // reset the IListComparer before each search.  This cannot be done
-                        // any less frequently (e.g. in Root.AddToSubgroups), due to the
-                        // possibility that the item may appear in more than one subgroup.
-                        ilc.Reset();
-                    }
+                    ilc?.Reset();
 
                     for (index = low; index < high; ++index)
                     {
-                        CollectionViewGroupInternal subgroup = ProtectedItems[index] as CollectionViewGroupInternal;
-                        object seed1 = (subgroup != null) ? subgroup.SeedItem : ProtectedItems[index];
+                        object seed1 = (ProtectedItems[index] is CollectionViewGroupInternal subgroup) ? subgroup.SeedItem : ProtectedItems[index];
                         if (seed1 == DependencyProperty.UnsetValue)
                             continue;
                         if (comparer.Compare(seed, seed1) < 0)
@@ -554,8 +538,7 @@ private void RemoveSubgroupFromMap(CollectionViewGroupInternal subgroup)
             // Search for the subgroup in the map.
             foreach (object key in _nameToGroupMap.Keys)
             {
-                WeakReference weakRef = _nameToGroupMap[key] as WeakReference;
-                if (weakRef != null &&
+                if (_nameToGroupMap[key] is WeakReference weakRef &&
                     weakRef.Target == subgroup)
                 {
                     keyToBeRemoved = key;
@@ -581,9 +564,9 @@ internal CollectionViewGroupInternal GetSubgroupFromMap(object nameKey)
                     // use null name place holder.
                     nameKey = _nullGroupNameKey;
                 }
+
                 // Find and return the subgroup
-                WeakReference weakRef = _nameToGroupMap[nameKey] as WeakReference;
-                if (weakRef != null)
+                if (_nameToGroupMap[nameKey] is WeakReference weakRef)
                 {
                     return (weakRef.Target as CollectionViewGroupInternal);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupRoot.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupRoot.cs
index 67b3a896..a74c9467 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupRoot.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewGroupRoot.cs
@@ -202,10 +202,8 @@ internal void MoveWithinSubgroups(object item, LiveShapingItem lsi, IList list,
 
         protected override int FindIndex(object item, object seed, IComparer comparer, int low, int high)
         {
-            // root group needs to adjust the bounds of the search to exclude the
-            // placeholder and new item (if any)
-            IEditableCollectionView iecv = _view as IEditableCollectionView;
-            if (iecv != null)
+            // root group needs to adjust the bounds of the search to exclude the            // placeholder and new item (if any)
+            if (_view is IEditableCollectionView iecv)
             {
                 if (iecv.NewItemPlaceholderPosition == NewItemPlaceholderPosition.AtBeginning)
                 {
@@ -485,10 +483,7 @@ void AddToSubgroups(object item, LiveShapingItem lsi, CollectionViewGroupInterna
             if (name == UseAsItemDirectly)
             {
                 // the item belongs to the group itself (not to any subgroups)
-                if (lsi != null)
-                {
-                    lsi.AddParentGroup(group);
-                }
+                lsi?.AddParentGroup(group);
 
                 if (loading)
                 {
@@ -662,11 +657,10 @@ void MoveWithinSubgroup(object item, CollectionViewGroupInternal group, IList li
         object GetGroupNameKey(object name, CollectionViewGroupInternal group)
         {
             object groupNameKey = name;
-            PropertyGroupDescription pgd = group.GroupBy as PropertyGroupDescription;
-            if (pgd != null)
+
+            if (group.GroupBy is PropertyGroupDescription pgd)
             {
-                string nameStr = name as string;
-                if (nameStr != null)
+                if (name is string nameStr)
                 {
                     if (pgd.StringComparison == StringComparison.OrdinalIgnoreCase ||
                         pgd.StringComparison == StringComparison.InvariantCultureIgnoreCase)
@@ -780,8 +774,7 @@ void RemoveItemFromSubgroupsByExhaustiveSearch(CollectionViewGroupInternal group
                 // (loop runs backwards in case an entire group is deleted)
                 for (int k = group.Items.Count - 1; k >= 0; --k)
                 {
-                    CollectionViewGroupInternal subgroup = group.Items[k] as CollectionViewGroupInternal;
-                    if (subgroup != null)
+                    if (group.Items[k] is CollectionViewGroupInternal subgroup)
                     {
                         RemoveItemFromSubgroupsByExhaustiveSearch(subgroup, item);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewProxy.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewProxy.cs
index 6ca0b8b8..54191fa8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewProxy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CollectionViewProxy.cs
@@ -171,10 +171,7 @@ public override ReadOnlyObservableCollection<object> Groups
         public override void Refresh()
         {
             IndexedEnumerable indexer = (IndexedEnumerable)Interlocked.Exchange(ref _indexer, null);
-            if (indexer != null)
-            {
-                indexer.Invalidate();
-            }
+            indexer?.Invalidate();
 
             ProxiedView.Refresh();
         }
@@ -370,8 +367,7 @@ public override void DetachFromSourceCollection()
                 _view.CurrentChanging -= new CurrentChangingEventHandler(_OnCurrentChanging);
                 _view.CurrentChanged -= new EventHandler(_OnCurrentChanged);
 
-                INotifyPropertyChanged ipc = _view as INotifyPropertyChanged;
-                if (ipc != null)
+                if (_view is INotifyPropertyChanged ipc)
                     ipc.PropertyChanged -= new PropertyChangedEventHandler(_OnPropertyChanged);
 
                 _view = null;
@@ -445,8 +441,7 @@ bool IEditableCollectionView.CanAddNew
         /// </summary>
         object IEditableCollectionView.AddNew()
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 return ecv.AddNew();
             }
@@ -464,8 +459,7 @@ object IEditableCollectionView.AddNew()
         /// </summary>
         void IEditableCollectionView.CommitNew()
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.CommitNew();
             }
@@ -481,8 +475,7 @@ void IEditableCollectionView.CommitNew()
         /// </summary>
         void IEditableCollectionView.CancelNew()
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.CancelNew();
             }
@@ -562,8 +555,7 @@ bool IEditableCollectionView.CanRemove
         /// </summary>
         void IEditableCollectionView.RemoveAt(int index)
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.RemoveAt(index);
             }
@@ -578,8 +570,7 @@ void IEditableCollectionView.RemoveAt(int index)
         /// </summary>
         void IEditableCollectionView.Remove(object item)
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.Remove(item);
             }
@@ -602,8 +593,7 @@ void IEditableCollectionView.Remove(object item)
         /// </summary>
         void IEditableCollectionView.EditItem(object item)
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.EditItem(item);
             }
@@ -619,8 +609,7 @@ void IEditableCollectionView.EditItem(object item)
         /// </summary>
         void IEditableCollectionView.CommitEdit()
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.CommitEdit();
             }
@@ -636,8 +625,7 @@ void IEditableCollectionView.CommitEdit()
         /// </summary>
         void IEditableCollectionView.CancelEdit()
         {
-            IEditableCollectionView ecv = ProxiedView as IEditableCollectionView;
-            if (ecv != null)
+            if (ProxiedView is IEditableCollectionView ecv)
             {
                 ecv.CancelEdit();
             }
@@ -743,8 +731,7 @@ bool IEditableCollectionViewAddNewItem.CanAddNewItem
         /// </summary>
         object IEditableCollectionViewAddNewItem.AddNewItem(object newItem)
         {
-            IEditableCollectionViewAddNewItem ani = ProxiedView as IEditableCollectionViewAddNewItem;
-            if (ani != null)
+            if (ProxiedView is IEditableCollectionViewAddNewItem ani)
             {
                 return ani.AddNewItem(newItem);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CompositeCollectionView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CompositeCollectionView.cs
index f98576cf..8dfe963b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CompositeCollectionView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/CompositeCollectionView.cs
@@ -838,10 +838,7 @@ internal override bool HasReliableHashCodes()
         internal override void GetCollectionChangedSources(int level, Action<int, object, bool?, List<string>> format, List<string> sources)
         {
             format(level, this, false, sources);
-            if (_collection != null)
-            {
-                _collection.GetCollectionChangedSources(level + 1, format, sources);
-            }
+            _collection?.GetCollectionChangedSources(level + 1, format, sources);
         }
 
         #endregion
@@ -1601,10 +1598,7 @@ public void Dispose()
             private void DisposeContainerEnumerator()
             {
                 IDisposable d = _containerEnumerator as IDisposable;
-                if (d != null)
-                {
-                    d.Dispose();
-                }
+                d?.Dispose();
 
                 _containerEnumerator = null;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DataBindEngine.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DataBindEngine.cs
index a7108a64..b4f43149 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DataBindEngine.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DataBindEngine.cs
@@ -422,8 +422,7 @@ internal object GetValue(object item, PropertyDescriptor pd, bool indexerIsNext)
         // give the value cache first chance at handling property changes
         internal void RegisterForCacheChanges(object item, object descriptor)
         {
-            PropertyDescriptor pd = descriptor as PropertyDescriptor;
-            if (item != null && pd != null && ValueTable.ShouldCache(item, pd))
+            if (item != null && descriptor is PropertyDescriptor pd && ValueTable.ShouldCache(item, pd))
             {
                 _valueTable.RegisterForChanges(item, pd, this);
             }
@@ -629,10 +628,7 @@ private void OnShutDown()
                 foreach (object o in asyncDispatchers.Keys)
                 {
                     IAsyncDataDispatcher dispatcher = o as IAsyncDataDispatcher;
-                    if (dispatcher != null)
-                    {
-                        dispatcher.CancelAllRequests();
-                    }
+                    dispatcher?.CancelAllRequests();
                 }
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DefaultValueConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DefaultValueConverter.cs
index f93c7a46..9cc60e70 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DefaultValueConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/DefaultValueConverter.cs
@@ -181,7 +181,7 @@ internal static TypeConverter GetConverter(Type type)
         {
             TypeConverter typeConverter = null;
             WpfKnownType knownType = XamlReader.BamlSharedSchemaContext.GetKnownXamlType(type) as WpfKnownType;
-            if (knownType != null && knownType.TypeConverter != null)
+            if (knownType?.TypeConverter != null)
             {
                 typeConverter = knownType.TypeConverter.ConverterInstance;
             }
@@ -199,9 +199,8 @@ internal static TypeConverter GetConverter(Type type)
         internal static object TryParse(object o, Type targetType, CultureInfo culture)
         {
             object result = DependencyProperty.UnsetValue;
-            string stringValue = o as String;
 
-            if (stringValue != null)
+            if (o is String stringValue)
             {
                 try
                 {
@@ -663,9 +662,8 @@ internal class ListSourceConverter : IValueConverter
         public object Convert(object o, Type type, object parameter, CultureInfo culture)
         {
             IList il = null;
-            IListSource ils = o as IListSource;
 
-            if (ils != null)
+            if (o is IListSource ils)
             {
                 il = ils.GetList();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/EnumerableCollectionView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/EnumerableCollectionView.cs
index 38a0738e..502f4402 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/EnumerableCollectionView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/EnumerableCollectionView.cs
@@ -554,10 +554,7 @@ void LoadSnapshotCore(IEnumerable source)
 
             // we're done with an enumerator - dispose it
             IDisposable id = ie as IDisposable;
-            if (id != null)
-            {
-                id.Dispose();
-            }
+            id?.Dispose();
         }
 
         // if the IEnumerable has changed, bring the snapshot up to date.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/IndexedEnumerable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/IndexedEnumerable.cs
index c06b7cf0..988347ab 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/IndexedEnumerable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/IndexedEnumerable.cs
@@ -466,10 +466,7 @@ private void InvalidateEnumerator()
         private void DisposeEnumerator(ref IEnumerator ie)
         {
             IDisposable d = ie as IDisposable;
-            if (d != null)
-            {
-                d.Dispose();
-            }
+            d?.Dispose();
 
             ie = null;
         }
@@ -774,10 +771,7 @@ object IEnumerator.Current
             public void Dispose()
             {
                 IDisposable d = _enumerator as IDisposable;
-                if (d != null)
-                {
-                    d.Dispose();
-                }
+                d?.Dispose();
                 _enumerator = null;
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingItem.cs
index 1fd02cf4..d254037a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingItem.cs
@@ -135,8 +135,7 @@ internal void SetBinding(string path, DependencyProperty dp, bool oneTime = fals
                 else if (!oneTime)
                 {
                     // when the path is empty, react to any property change
-                    INotifyPropertyChanged inpc = Item as INotifyPropertyChanged;
-                    if (inpc != null)
+                    if (Item is INotifyPropertyChanged inpc)
                     {
                         PropertyChangedEventManager.AddHandler(inpc, OnPropertyChanged, String.Empty);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingList.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingList.cs
index 629daa62..e342918d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingList.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/LiveShapingList.cs
@@ -187,15 +187,13 @@ internal void SetLiveShapingProperties(LiveShapingFlags flags)
                 {
                     // if no explicit list, use the group description properties
                     groupingProperties = new Collection<string>();
-                    ICollectionView icv = View as ICollectionView;
-                    ObservableCollection<GroupDescription> groupDescriptions = (icv != null) ? icv.GroupDescriptions : null;
+                    ObservableCollection<GroupDescription> groupDescriptions = (View is ICollectionView icv) ? icv.GroupDescriptions : null;
 
                     if (groupDescriptions != null)
                     {
                         foreach (GroupDescription gd in groupDescriptions)
                         {
-                            PropertyGroupDescription pgd = gd as PropertyGroupDescription;
-                            if (pgd != null)
+                            if (gd is PropertyGroupDescription pgd)
                             {
                                 groupingProperties.Add(pgd.PropertyName);
                             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ObjectRef.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ObjectRef.cs
index e2d7740a..56a10c99 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ObjectRef.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ObjectRef.cs
@@ -151,7 +151,7 @@ internal override object GetObject(DependencyObject d, ObjectRefArgs args)
             {
                 // look in container's template (if any) first
                 FrameworkElement fe = d as FrameworkElement;
-                if (fe != null && fe.TemplateInternal != null)
+                if (fe?.TemplateInternal != null)
                 {
                     o = Helper.FindNameInTemplate(_name, d);
 
@@ -223,8 +223,7 @@ internal override object GetObject(DependencyObject d, ObjectRefArgs args)
                     // the (visual) parent - a panel.
                     if (dd == null)
                     {
-                        Panel panel = fo.FrameworkParent.DO as Panel;
-                        if (panel != null && panel.IsItemsHost)
+                        if (fo.FrameworkParent.DO is Panel panel && panel.IsItemsHost)
                         {
                             dd = panel;
                         }
@@ -237,8 +236,7 @@ internal override object GetObject(DependencyObject d, ObjectRefArgs args)
                     // parent ContentControl imposes a barrier, e.g. Frame)
                     if (dd == null && scopeOwner == null)
                     {
-                        ContentControl cc = LogicalTreeHelper.GetParent(fo.DO) as ContentControl;
-                        if (cc != null && cc.Content == fo.DO && cc.InheritanceBehavior == InheritanceBehavior.Default)
+                        if (LogicalTreeHelper.GetParent(fo.DO) is ContentControl cc && cc.Content == fo.DO && cc.InheritanceBehavior == InheritanceBehavior.Default)
                         {
                             dd = cc;
                         }
@@ -372,9 +370,8 @@ internal override object GetObject(DependencyObject d, ObjectRefArgs args)
         internal override object GetDataObject(DependencyObject d, ObjectRefArgs args)
         {
             object o = GetDataObjectImpl(d, args);
-            DependencyObject el = o as DependencyObject;
 
-            if (el != null && ReturnsDataContext)
+            if (o is DependencyObject el && ReturnsDataContext)
             {
                 // for generated wrappers, use the ItemForContainer property instead
                 // of DataContext, since it's always set by the generator
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/PropertyPathWorker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/PropertyPathWorker.cs
index d12d2d9b..92cb5ecd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/PropertyPathWorker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/PropertyPathWorker.cs
@@ -370,10 +370,7 @@ internal void SetValue(object item, object value)
                     {
                         ((DependencyObject)item).SetValue(dp, value);
                     }
-                    else if (dpa != null)
-                    {
-                        dpa.SetValue(item, value);
-                    }
+                    else dpa?.SetValue(item, value);
                     break;
 
                 case SourceValueType.Indexer:
@@ -731,8 +728,7 @@ private void ReplaceItem(int k, object newO, object parent)
                 // handle INotifyDataErrorInfo
                 if (IsDynamic && _host.ValidatesOnNotifyDataErrors)
                 {
-                    INotifyDataErrorInfo indei = oldO as INotifyDataErrorInfo;
-                    if (indei != null)
+                    if (oldO is INotifyDataErrorInfo indei)
                     {
                         ErrorsChangedEventManager.RemoveHandler(indei, OnErrorsChanged);
                     }
@@ -912,8 +908,7 @@ private void ReplaceItem(int k, object newO, object parent)
                 // handle INotifyDataErrorInfo
                 if (_host.ValidatesOnNotifyDataErrors)
                 {
-                    INotifyDataErrorInfo indei = newO as INotifyDataErrorInfo;
-                    if (indei != null)
+                    if (oldO is INotifyDataErrorInfo indei)
                     {
                         if (IsDynamic)
                         {
@@ -1209,8 +1204,7 @@ private void GetInfo(int k, object item, ref SourceValueState svs)
 
                         for (int jj = 0; jj < defaultMembers.Length; ++jj)
                         {
-                            PropertyInfo pi = defaultMembers[jj] as PropertyInfo;
-                            if (pi != null)
+                            if (defaultMembers[jj] is PropertyInfo pi)
                             {
                                 if (MatchIndexerParameters(pi, aryInfo, args, isIList))
                                 {
@@ -1270,16 +1264,13 @@ private void GetInfo(int k, object item, ref SourceValueState svs)
                 StringBuilder sb = new StringBuilder();
 
                 if (!Object.Equals(info, svs.info))
-                    sb.AppendLine(String.Format("  Info is wrong: expected '{0}' got '{1}'",
-                                    info, svs.info));
+                    sb.AppendLine($"  Info is wrong: expected '{info}' got '{svs.info}'");
 
                 if (sourceType != svs.type)
-                    sb.AppendLine(String.Format("  Type is wrong: expected '{0}' got '{1}'",
-                                    sourceType, svs.type));
+                    sb.AppendLine($"  Type is wrong: expected '{sourceType}' got '{svs.type}'");
 
                 if (item != BindingExpression.GetReference(svs.item))
-                    sb.AppendLine(String.Format("  Item is wrong: expected '{0}' got '{1}'",
-                                    item, BindingExpression.GetReference(svs.item)));
+                    sb.AppendLine($"  Item is wrong: expected '{item}' got '{BindingExpression.GetReference(svs.item)}'");
 
                 int len1 = (args != null) ? args.Length : 0;
                 int len2 = (svs.args != null) ? svs.args.Length : 0;
@@ -1289,20 +1280,17 @@ private void GetInfo(int k, object item, ref SourceValueState svs)
                     {
                         if (!Object.Equals(args[i], svs.args[i]))
                         {
-                            sb.AppendLine(String.Format("  args[{0}] is wrong:  expected '{1}' got '{2}'",
-                                    i, args[i], svs.args[i]));
+                            sb.AppendLine($"  args[{i}] is wrong:  expected '{args[i]}' got '{svs.args[i]}'");
                         }
                     }
                 }
                 else
-                    sb.AppendLine(String.Format("  Args are wrong: expected length '{0}' got length '{1}'",
-                                    len1, len2));
+                    sb.AppendLine($"  Args are wrong: expected length '{len1}' got length '{len2}'");
 
                 if (sb.Length > 0)
                 {
                     Debug.Assert(false,
-                        String.Format("Accessor cache returned incorrect result for ({0},{1},{2})\n{3}",
-                            SVI[k].type, newType.Name, SVI[k].name, sb.ToString()));
+                        $"Accessor cache returned incorrect result for ({SVI[k].type},{newType.Name},{SVI[k].name})\n{sb.ToString()}");
                 }
 
                 return;
@@ -1535,10 +1523,9 @@ private object RawValue(int k)
             if (item != BindingExpression.NullDataItem && info != null && !(item == null && info != DependencyProperty.UnsetValue))
             {
                 object o = DependencyProperty.UnsetValue;
-                DependencyProperty dp = info as DependencyProperty;
 
                 // if the binding is async, post a request to get the value
-                if (!(dp != null || SVI[k].type == SourceValueType.Direct))
+                if (!(info is DependencyProperty dp || SVI[k].type == SourceValueType.Direct))
                 {
                     if (_host != null && _host.AsyncGet(item, k))
                     {
@@ -1590,10 +1577,7 @@ private object RawValue(int k)
                 return o;
             }
 
-            if (_host != null)
-            {
-                _host.ReportRawValueErrors(k, item, info);
-            }
+            _host?.ReportRawValueErrors(k, item, info);
 
             return DependencyProperty.UnsetValue;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/SortFieldComparer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/SortFieldComparer.cs
index 890ea5f1..fd5af945 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/SortFieldComparer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/SortFieldComparer.cs
@@ -147,9 +147,9 @@ struct SortPropertyInfo
 
             internal object GetValue(object o)
             {
-                if (o is CachedValueItem)
+                if (o is CachedValueItem cachedValueItem)
                 {
-                    return GetValueFromCVI((CachedValueItem)o);
+                    return GetValueFromCVI(cachedValueItem);
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ValueTable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ValueTable.cs
index 0df94e82..1eef75fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ValueTable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ValueTable.cs
@@ -110,8 +110,7 @@ internal object GetValue(object item, PropertyDescriptor pd, bool indexerIsNext)
                     if (SystemDataHelper.IsDataSetCollectionProperty(pd))
                     {
                         // we stored a weak reference - decode it now
-                        WeakReference wr = value as WeakReference;
-                        if (wr != null)
+                        if (value is WeakReference wr)
                         {
                             value = wr.Target;
                         }
@@ -167,8 +166,7 @@ internal void RegisterForChanges(object item, PropertyDescriptor pd, DataBindEng
             if (value == null)
             {
                 // new entry needed - add a listener
-                INotifyPropertyChanged inpc = item as INotifyPropertyChanged;
-                if (inpc != null)
+                if (item is INotifyPropertyChanged inpc)
                 {
                     PropertyChangedEventManager.AddHandler(inpc, OnPropertyChanged, pd.Name);
                 }
@@ -334,8 +332,7 @@ public override bool Equals(object o)
                 if (o == this)
                     return true;    // this allows deletion of stale keys
 
-                ValueTableKey that = o as ValueTableKey;
-                if (that != null)
+                if (o is ValueTableKey that)
                 {
                     object item = this.Item;
                     PropertyDescriptor descriptor = this.PropertyDescriptor;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ViewManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ViewManager.cs
index 471e1440..3dbd1a5d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ViewManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Data/ViewManager.cs
@@ -178,9 +178,8 @@ public override int GetHashCode()
 
         public override bool Equals(object o)
         {
-            if (o is WeakRefKey)
+            if (o is WeakRefKey ck)
             {
-                WeakRefKey ck = (WeakRefKey)o;
                 object c1 = Target;
                 object c2 = ck.Target;
 
@@ -657,10 +656,7 @@ CollectionRecord EnsureCollectionRecord(object collection, Func<object, object>
                 {
                     ViewRecord vr = (ViewRecord)de.Value;
                     CollectionView cv = vr.View as CollectionView;
-                    if (cv != null)
-                    {
-                        cv.SetAllowsCrossThreadChanges(isSynchronized);
-                    }
+                    cv?.SetAllowsCrossThreadChanges(isSynchronized);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/DataStreams.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/DataStreams.cs
index 4ebbd3ef..f546c09c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/DataStreams.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/DataStreams.cs
@@ -184,8 +184,7 @@ private void SaveState(object node)
                     }
                 }
 
-                IJournalState customJournalingObject = node as IJournalState;
-                if (customJournalingObject != null)
+                if (node is IJournalState customJournalingObject)
                 {
                     object customState = customJournalingObject.GetJournalState(JournalReason.NewContentNavigation);
                     if (customState != null)
@@ -286,10 +285,7 @@ private void LoadState(object node)
                     //  B. If the loose xaml file has been changed since the journal data was created
                     //
                     //
-                    if (customJournalingObject != null)
-                    {
-                        customJournalingObject.RestoreJournalState(state);
-                    }
+                    customJournalingObject?.RestoreJournalState(state);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/FrameworkObject.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/FrameworkObject.cs
index 42340204..e935af24 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/FrameworkObject.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/FrameworkObject.cs
@@ -899,8 +899,7 @@ private FrameworkObject GetRawPreferVisualParent()
             }
             else if (_do != null)
             {
-                Visual visual = _do as Visual;
-                visualParent = (visual != null) ? VisualTreeHelper.GetParent(visual) : null;
+                visualParent = (_do is Visual visual) ? VisualTreeHelper.GetParent(visual) : null;
             }
             else
             {
@@ -924,8 +923,7 @@ private FrameworkObject GetRawPreferVisualParent()
             }
             else if (_do != null)
             {
-                ContentElement ce = _do as ContentElement;
-                logicalParent = (ce != null) ? ContentOperations.GetParent(ce) : null;
+                logicalParent = (_do is ContentElement ce) ? ContentOperations.GetParent(ce) : null;
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceDeserializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceDeserializer.cs
index f97f7882..b13cd169 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceDeserializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceDeserializer.cs
@@ -219,11 +219,11 @@ private BamlTree LoadBamlImp(Stream bamlSteam)
                                         // we autonumber properties that have occurrences larger than 1
                                         object occurrence = propertyOccurrences[_reader.Name];
                                         int index = 2;
-                                        if (occurrence is BamlPropertyNode)
+                                        if (occurrence is BamlPropertyNode bamlPropertyNode)
                                         {
                                             // start numbering this property as the 2nd occurrence is encountered
                                             // the value stores the 1st occurrence of the property at this point
-                                            ((BamlPropertyNode)occurrence).Index = 1;
+                                            bamlPropertyNode.Index = 1;
                                         }
                                         else
                                         {
@@ -336,8 +336,7 @@ private void PopStack()
                 // pop properties from property inheritance stack as well
                 foreach (BamlTreeNode child in node.Children)
                 {
-                    BamlStartComplexPropertyNode propertyNode = child as BamlStartComplexPropertyNode;
-                    if (propertyNode != null)
+                    if (child is BamlStartComplexPropertyNode propertyNode)
                     {
                         PopPropertyFromStack(propertyNode.PropertyName);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceSerializer.cs
index 5325e1c9..9f9b3516 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlResourceSerializer.cs
@@ -58,7 +58,7 @@ Stream output
             )
         {
             Debug.Assert(output != null, "The output stream given is null");
-            Debug.Assert(tree != null && tree.Root != null, "The tree to be serialized is null.");
+            Debug.Assert(tree?.Root != null, "The tree to be serialized is null.");
 
             _writer = new BamlWriter(output);
             _bamlTreeStack = new Stack<BamlTreeNode>();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeMap.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeMap.cs
index 45b647d3..2c570c85 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeMap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeMap.cs
@@ -654,7 +654,7 @@ private static XmlElement FindElementByID(XmlDocument doc, string uid)
         {
             // Have considered using XPATH. However, XPATH doesn't have a way to escape single quote within 
             // single quotes, here we iterate through the document by ourselves            
-            if (doc != null && doc.DocumentElement != null)
+            if (doc?.DocumentElement != null)
             {
                 foreach (XmlNode node in doc.DocumentElement.ChildNodes)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeUpdater.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeUpdater.cs
index ddd673f4..cb827af3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeUpdater.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/BamlTreeUpdater.cs
@@ -31,7 +31,7 @@ internal static class BamlTreeUpdater
             BamlLocalizationDictionary dictionary
             )
         {
-            Debug.Assert(tree != null && tree.Root != null, "Empty Tree!");
+            Debug.Assert(tree?.Root != null, "Empty Tree!");
             Debug.Assert(treeMap != null, "Empty map!");
             Debug.Assert(dictionary != null, "Empty dictionary");
 
@@ -440,8 +440,8 @@ BamlTreeUpdateMap bamlTreeMap
             try
             {
                 doc.LoadXml(xmlContent.ToString());
-                XmlElement root = doc.FirstChild as XmlElement;
-                if (root != null && root.HasChildNodes)
+
+                if (doc.FirstChild is XmlElement root && root.HasChildNodes)
                 {
                     for (int i = 0; i < root.ChildNodes.Count && succeed; i++)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/LocalizableResourceBuilder.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/LocalizableResourceBuilder.cs
index 0e718226..3d6627d1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/LocalizableResourceBuilder.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Globalization/LocalizableResourceBuilder.cs
@@ -435,10 +435,8 @@ LocalizabilityAttribute localizabilityFromSource
 
             if (inheritableAttribute == null)
             {
-                // if ancestor's inheritable value isn't resolved yet, we recursively 
-                // resolve it here.
-                BamlStartElementNode elementNode = ancestor as BamlStartElementNode;
-                if (elementNode != null)
+                // if ancestor's inheritable value isn't resolved yet, we recursively                 // resolve it here.
+                if (ancestor is BamlStartElementNode elementNode)
                 {
                     string formattingTag;
                     GetLocalizabilityForElementNode(elementNode, out inheritableAttribute, out formattingTag);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Helper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Helper.cs
index a45d7b9d..d75b6d35 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Helper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Helper.cs
@@ -545,10 +545,7 @@ internal static Size ArrangeElementWithSingleChild(UIElement element, Size arran
         {
             UIElement child = (VisualTreeHelper.GetChildrenCount(element) > 0) ? VisualTreeHelper.GetChild(element, 0) as UIElement : null;
 
-            if (child != null)
-            {
-                child.Arrange(new Rect(arrangeSize));
-            }
+            child?.Arrange(new Rect(arrangeSize));
 
             return arrangeSize;
         }
@@ -847,10 +844,7 @@ internal static void ClearItemValue(DependencyObject owner, object item, int dpI
             Debug.Assert(item != null);
             List<KeyValuePair<int, object>> itemValues = null;
 
-            if (itemValueStorage != null)
-            {
-                itemValueStorage.TryGetValue(item, out itemValues);
-            }
+            itemValueStorage?.TryGetValue(item, out itemValues);
 
             return itemValues;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/XamlFilter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/XamlFilter.cs
index df0ef286..1ae571bd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/XamlFilter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/XamlFilter.cs
@@ -326,7 +326,7 @@ internal string DumpElementTable()
             string result = "";
             for (int i = 0; i < length; ++i)
             {
-                result += string.Format("{0}: [{1} -> {2}]\n", i, keyList[i], valueList[i]);
+                result += $"{i}: [{keyList[i]} -> {valueList[i]}]\n";
             }
             return result;
         }
@@ -607,7 +607,7 @@ private IndexingContentUnit HandleElementStart()
                 && (_attributesToIgnore & AttributesToIgnore.Title) == 0 )
             {
                 title = GetPropertyAsAttribute(elementDescriptor.TitleProp);
-                if (title != null && title.Length > 0)
+                if (!string.IsNullOrEmpty(title))
                 {
                     // Leave the reader in its present state, but return the title as a block chunk,
                     // and mark this attribute as processed.
@@ -625,7 +625,7 @@ private IndexingContentUnit HandleElementStart()
                 && (_attributesToIgnore & AttributesToIgnore.Content) == 0 )
             {
                 content = GetPropertyAsAttribute(elementDescriptor.ContentProp);
-                if (content != null && content.Length > 0)
+                if (!string.IsNullOrEmpty(content))
                 {
                     // Leave the reader in its present state, but mark the content attribute
                     // as processed.
@@ -814,10 +814,7 @@ private IndexingContentUnit ProcessFixedPage()
         ///</summary>
         private void CreateXmlReader()
         {
-            if (_xamlReader != null)
-            {
-                _xamlReader.Close();
-            }
+            _xamlReader?.Close();
             _xamlReader = new XmlTextReader(_xamlStream);
             // Do not return pretty-pretting spacing between tags as data.
             ((XmlTextReader)_xamlReader).WhitespaceHandling = WhitespaceHandling.Significant;
@@ -828,10 +825,7 @@ private void CreateXmlReader()
 
         private void EnsureXmlReaderIsClosed()
         {
-            if (_xamlReader != null)
-            {
-                _xamlReader.Close();                
-            }
+            _xamlReader?.Close();
         }
 
         ///<summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/indexingfiltermarshaler.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/indexingfiltermarshaler.cs
index aaf0caaa..514f0172 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/indexingfiltermarshaler.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/indexingfiltermarshaler.cs
@@ -191,19 +191,19 @@ internal static IntPtr MarshalPropVariant(Object obj)
             {
                 PROPVARIANT v;
 
-                if (obj is string)
+                if (obj is string s)
                 {
-                    pszVal = Marshal.StringToCoTaskMemAnsi((string)obj);
+                    pszVal = Marshal.StringToCoTaskMemAnsi(s);
                     
                     v = new PROPVARIANT();
                     v.vt = VARTYPE.VT_LPSTR;
                     v.union.pszVal = pszVal;
                 }
-                else if (obj is DateTime)
+                else if (obj is DateTime dateTime)
                 {
                     v = new PROPVARIANT();
                     v.vt = VARTYPE.VT_FILETIME;
-                    long longFileTime = ((DateTime)obj).ToFileTime();
+                    long longFileTime = dateTime.ToFileTime();
                     v.union.filetime.dwLowDateTime = (Int32)longFileTime;
                     v.union.filetime.dwHighDateTime = (Int32)((longFileTime >> 32) & 0xFFFFFFFF);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/xmlglyphRunInfo.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/xmlglyphRunInfo.cs
index 5c905dc2..a672fa54 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/xmlglyphRunInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/IO/Packaging/xmlglyphRunInfo.cs
@@ -169,7 +169,7 @@ internal override uint LanguageID
                          currentNode = (currentNode.ParentNode as XmlElement))
                     {
                         string languageString = currentNode.GetAttribute(_xmlLangAttribute);
-                        if (languageString != null && languageString.Length > 0)
+                        if (!string.IsNullOrEmpty(languageString))
                         {
                             // We need to handle languageString "und" specially. 
                             // we should set language ID to zero. 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/EditingCoordinator.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/EditingCoordinator.cs
index c98369ca..11f7008a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/EditingCoordinator.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/EditingCoordinator.cs
@@ -616,10 +616,7 @@ private void PushEditingBehavior(EditingBehavior newEditingBehavior)
             EditingBehavior behavior = ActiveEditingBehavior;
 
             // Deactivate the previous behavior
-            if ( behavior != null )
-            {
-                behavior.Deactivate();
-            }
+            behavior?.Deactivate();
 
             // Activate the new behavior.
             _activationStack.Push(newEditingBehavior);
@@ -744,7 +741,7 @@ internal void OnInkCanvasDeviceDown(object sender, InputEventArgs args)
                 {
                     InputDevice capturedDevice = null;
                     // Capture the stylus (if mouse event make sure to use stylus if generated by a stylus)
-                    if ( mouseButtonEventArgs != null && mouseButtonEventArgs.StylusDevice != null )
+                    if ( mouseButtonEventArgs?.StylusDevice != null )
                     {
                         capturedDevice = mouseButtonEventArgs.StylusDevice;
                         resetDynamicRenderer = true;
@@ -801,7 +798,7 @@ private void OnInkCanvasDeviceMove<TEventArgs>(object sender, TEventArgs args)
                     {
                         // Make sure we ignore stylus generated mouse events.
                         MouseEventArgs mouseEventArgs = args as MouseEventArgs;
-                        if ( mouseEventArgs != null && mouseEventArgs.StylusDevice != null )
+                        if ( mouseEventArgs?.StylusDevice != null )
                         {
                             return;
                         }
@@ -889,11 +886,7 @@ internal void OnInkCanvasDeviceUp(object sender, InputEventArgs args)
                 {
                     // The follow code raises variety editing events.
                     // The out-side code could throw exception in the their handlers. We use try/finally block to protect our status.
-                    if ( ActiveEditingBehavior != null )
-                    {
-                        // Commit the current editing.
-                        ActiveEditingBehavior.Commit(true);
-                    }
+                    ActiveEditingBehavior?.Commit(true);
                 }
                 finally
                 {
@@ -967,10 +960,7 @@ private void InitializeCapture(InputDevice inputDevice, IStylusEditing stylusEdi
                 {
                     // Reset the dynamic renderer for InkCollectionBehavior
                     InkCollectionBehavior inkCollectionBehavior = stylusEditingBehavior as InkCollectionBehavior;
-                    if ( inkCollectionBehavior != null )
-                    {
-                        inkCollectionBehavior.ResetDynamicRenderer();
-                    }
+                    inkCollectionBehavior?.ResetDynamicRenderer();
                 }
 
                 stylusEditingBehavior.AddStylusPoints(stylusPoints, userInitiated);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/ISFClipboardData.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/ISFClipboardData.cs
index 2538286f..dfac8a7f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/ISFClipboardData.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/ISFClipboardData.cs
@@ -84,11 +84,11 @@ protected override void DoCopy(IDataObject dataObject)
         protected override void DoPaste(IDataObject dataObject)
         {
             // Check if we have ink data
-            MemoryStream stream = dataObject.GetData(StrokeCollection.InkSerializedFormat) as MemoryStream;
 
             StrokeCollection newStrokes = null;
             bool fSucceeded = false;
-            if ( stream != null && stream != Stream.Null )
+
+            if ( dataObject.GetData(StrokeCollection.InkSerializedFormat) is MemoryStream stream && stream != Stream.Null )
             {
                 try
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/LassoHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/LassoHelper.cs
index c15fa4c4..45ffd3a8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/LassoHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/LassoHelper.cs
@@ -154,10 +154,7 @@ private void AddLassoPoint(Point lassoPoint)
             }
             finally
             {
-                if (dc != null)
-                {
-                    dc.Close();
-                }
+                dc?.Close();
             }
 
             // Add the new visual to the container.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/PenCursorManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/PenCursorManager.cs
index b96341d3..70c10e25 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/PenCursorManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/PenCursorManager.cs
@@ -266,10 +266,7 @@ private static DrawingVisual CreateCursorDrawingVisual(Drawing drawing, int widt
             }
             finally
             {
-                if ( dc != null )
-                {
-                    dc.Close();
-                }
+                dc?.Close();
             }
 
             return drawingVisual;
@@ -421,10 +418,7 @@ private static Drawing CreatePenDrawing(DrawingAttributes drawingAttributes, boo
             }
             finally
             {
-                if ( dc != null )
-                {
-                    dc.Close();
-                }
+                dc?.Close();
             }
 
             return penDrawing;
@@ -540,10 +534,7 @@ private static Drawing CreateStrokeEraserDrawing()
             }
             finally
             {
-                if ( dc != null )
-                {
-                    dc.Close();
-                }
+                dc?.Close();
             }
 
             return drawingGroup;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/XamlClipboardData.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/XamlClipboardData.cs
index 2ca03e10..4f13746e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/XamlClipboardData.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Ink/XamlClipboardData.cs
@@ -100,8 +100,7 @@ protected override void DoPaste(IDataObject dataObject)
 
             if ( !String.IsNullOrEmpty(xml) )
             {
-                UIElement element = XamlReader.Load(new System.Xml.XmlTextReader(new System.IO.StringReader(xml)), useRestrictiveXamlReader: true) as UIElement;
-                if (element != null)
+                if (XamlReader.Load(new System.Xml.XmlTextReader(new System.IO.StringReader(xml)), useRestrictiveXamlReader: true) is UIElement element)
                 {
                     ElementList.Add(element);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/LayoutDump.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/LayoutDump.cs
index 6f075dbc..9c59179a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/LayoutDump.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/LayoutDump.cs
@@ -199,9 +199,9 @@ internal static void AddDocumentPageDumpHandler(Type type, DumpCustomDocumentPag
         // ------------------------------------------------------------------
         internal static void DumpVisual(XmlTextWriter writer, Visual visual, Visual parent)
         {
-            if (visual is UIElement)
+            if (visual is UIElement uIElement)
             {
-                DumpUIElement(writer, (UIElement)visual, parent, false);
+                DumpUIElement(writer, uIElement, parent, false);
             }
             else
             {
@@ -696,33 +696,33 @@ private static void DumpParagraphResults(XmlTextWriter writer, string tagName, R
                 {
                     ParagraphResult paragraph = paragraphs[index];
 
-                    if (paragraph is TextParagraphResult)
+                    if (paragraph is TextParagraphResult textParagraphResult)
                     {
-                        DumpTextParagraphResult(writer, (TextParagraphResult)paragraph, visualParent);
+                        DumpTextParagraphResult(writer, textParagraphResult, visualParent);
                     }
-                    else if (paragraph is ContainerParagraphResult)
+                    else if (paragraph is ContainerParagraphResult containerParagraphResult)
                     {
-                        DumpContainerParagraphResult(writer, (ContainerParagraphResult)paragraph, visualParent);
+                        DumpContainerParagraphResult(writer, containerParagraphResult, visualParent);
                     }
-                    else if (paragraph is TableParagraphResult)
+                    else if (paragraph is TableParagraphResult tableParagraphResult)
                     {
-                        DumpTableParagraphResult(writer, (TableParagraphResult)paragraph, visualParent);
+                        DumpTableParagraphResult(writer, tableParagraphResult, visualParent);
                     }
-                    else if (paragraph is FloaterParagraphResult)
+                    else if (paragraph is FloaterParagraphResult floaterParagraphResult)
                     {
-                        DumpFloaterParagraphResult(writer, (FloaterParagraphResult)paragraph, visualParent);
+                        DumpFloaterParagraphResult(writer, floaterParagraphResult, visualParent);
                     }
-                    else if (paragraph is UIElementParagraphResult)
+                    else if (paragraph is UIElementParagraphResult uIElementParagraphResult)
                     {
-                        DumpUIElementParagraphResult(writer, (UIElementParagraphResult)paragraph, visualParent);
+                        DumpUIElementParagraphResult(writer, uIElementParagraphResult, visualParent);
                     }
-                    else if (paragraph is FigureParagraphResult)
+                    else if (paragraph is FigureParagraphResult figureParagraphResult)
                     {
-                        DumpFigureParagraphResult(writer, (FigureParagraphResult)paragraph, visualParent);
+                        DumpFigureParagraphResult(writer, figureParagraphResult, visualParent);
                     }
-                    else if (paragraph is SubpageParagraphResult)
+                    else if (paragraph is SubpageParagraphResult subpageParagraphResult)
                     {
-                        DumpSubpageParagraphResult(writer, (SubpageParagraphResult)paragraph, visualParent);
+                        DumpSubpageParagraphResult(writer, subpageParagraphResult, visualParent);
                     }
                 }
                 writer.WriteEndElement();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Printing/Win32PrintDialog.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Printing/Win32PrintDialog.cs
index 3bc27a70..988c16a7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Printing/Win32PrintDialog.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Printing/Win32PrintDialog.cs
@@ -110,7 +110,7 @@ internal partial class Win32PrintDialog
                     string message = System.Windows.SR.Get(System.Windows.SRID.PrintDialogInstallPrintSupportMessageBox);
                     string caption = System.Windows.SR.Get(System.Windows.SRID.PrintDialogInstallPrintSupportCaption);
 
-                    bool isRtlCaption = caption != null && caption.Length > 0 && caption[0] == RightToLeftMark;
+                    bool isRtlCaption = !string.IsNullOrEmpty(caption) && caption[0] == RightToLeftMark;
                     System.Windows.MessageBoxOptions mbOptions = isRtlCaption ? System.Windows.MessageBoxOptions.RtlReading : System.Windows.MessageBoxOptions.None;
 
                     int type =
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/BreakRecordTable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/BreakRecordTable.cs
index d5fac2cd..ac3afd08 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/BreakRecordTable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/BreakRecordTable.cs
@@ -384,7 +384,7 @@ private void DisposePages(int start, int count)
             {
                 Invariant.Assert(_breakRecords[index] != null, "Invalid BreakRecordTable entry.");
                 pageRef = _breakRecords[index].DocumentPage;
-                if (pageRef != null && pageRef.Target != null)
+                if (pageRef?.Target != null)
                 {
                     ((FlowDocumentPage)pageRef.Target).Dispose();
                 }
@@ -411,7 +411,7 @@ private void InvalidateBreakRecords(int start, int count)
                 Invariant.Assert(_breakRecords[index] != null, "Invalid BreakRecordTable entry.");
                 // Dispose Page and BreakRecord before removing the entry.
                 pageRef = _breakRecords[index].DocumentPage;
-                if (pageRef != null && pageRef.Target != null)
+                if (pageRef?.Target != null)
                 {
                     ((FlowDocumentPage)pageRef.Target).Dispose();
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/CellParagraph.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/CellParagraph.cs
index 96984bd0..d61ca856 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/CellParagraph.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/CellParagraph.cs
@@ -104,7 +104,7 @@ internal CellParagraph(DependencyObject element, StructuralCache structuralCache
             {
                 if (PTS.ToBoolean(fEmptyOK))
                 {
-                    if (cellParaClient != null)     { cellParaClient.Dispose(); }
+                    cellParaClient?.Dispose();
                     if (pfsbrkcellOut != IntPtr.Zero)
                     {
                         PTS.Validate(PTS.FsDestroySubpageBreakRecord(cellParaClient.PtsContext.Context, pfsbrkcellOut), cellParaClient.PtsContext);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/ContainerParagraph.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/ContainerParagraph.cs
index 73193f73..c8a7ab81 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/ContainerParagraph.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/ContainerParagraph.cs
@@ -403,10 +403,7 @@ public override void Dispose()
                             dcpPara += para.Cch;
                             para = para.Next;
                         }
-                        if (para != null)
-                        {
-                            para.SetUpdateInfo(PTS.FSKCHANGE.fskchInside, false);
-                        }
+                        para?.SetUpdateInfo(PTS.FSKCHANGE.fskchInside, false);
                     }
                     else
                     {
@@ -1199,7 +1196,7 @@ private void BuildUpdateRecord()
 
             // Disconnect obsolete paragraphs
             ur = _ur;
-            while (ur != null && ur.FirstPara != null)
+            while (ur?.FirstPara != null)
             {
                 BaseParagraph paraInvalid = null;
                 if (ur.ChangeType == PTS.FSKCHANGE.fskchInside)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParaClient.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParaClient.cs
index 0fdd1943..90305f58 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParaClient.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParaClient.cs
@@ -50,10 +50,7 @@ public override void Dispose()
                 SubpageHandle = IntPtr.Zero;
             }
 
-            if(_pageContext != null)
-            {
-                _pageContext.RemoveFloatingParaClient(this);
-            }
+            _pageContext?.RemoveFloatingParaClient(this);
 
             base.Dispose();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParagraph.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParagraph.cs
index 7cd2ff88..f5d2b072 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParagraph.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FigureParagraph.cs
@@ -422,10 +422,7 @@ public override void Dispose()
         // ------------------------------------------------------------------
         internal override void ClearUpdateInfo()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.ClearUpdateInfo();
-            }
+            _mainTextSegment?.ClearUpdateInfo();
             base.ClearUpdateInfo();
         }
 
@@ -455,10 +452,7 @@ internal override bool InvalidateStructure(int startPosition)
         // ------------------------------------------------------------------
         internal override void InvalidateFormatCache()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.InvalidateFormatCache();
-            }
+            _mainTextSegment?.InvalidateFormatCache();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParaClient.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParaClient.cs
index 1a6ba65a..e3541dbb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParaClient.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParaClient.cs
@@ -53,10 +53,7 @@ internal FloaterParaClient(FloaterParagraph paragraph)
         // ------------------------------------------------------------------
         public override void Dispose()
         {
-            if(_pageContext != null)
-            {
-                _pageContext.RemoveFloatingParaClient(this);
-            }
+            _pageContext?.RemoveFloatingParaClient(this);
 
             base.Dispose();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParagraph.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParagraph.cs
index d65d7eb8..3437b0e3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParagraph.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FloaterParagraph.cs
@@ -590,10 +590,7 @@ public override void Dispose()
         // ------------------------------------------------------------------
         internal override void ClearUpdateInfo()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.ClearUpdateInfo();
-            }
+            _mainTextSegment?.ClearUpdateInfo();
             base.ClearUpdateInfo();
         }
 
@@ -623,10 +620,7 @@ internal override bool InvalidateStructure(int startPosition)
         // ------------------------------------------------------------------
         internal override void InvalidateFormatCache()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.InvalidateFormatCache();
-            }
+            _mainTextSegment?.InvalidateFormatCache();
         }
 
         /// <summary>
@@ -791,9 +785,9 @@ private HorizontalAlignment HorizontalAlignment
         {
             get
             {
-                if(Element is Floater)
+                if(Element is Floater floater)
                 {
-                    return ((Floater)Element).HorizontalAlignment;
+                    return floater.HorizontalAlignment;
                 }
 
                 Figure figure = (Figure) Element;
@@ -862,9 +856,9 @@ private WrapDirection WrapDirection
         //-------------------------------------------------------------------
         private double CalculateWidth(double spaceAvailable)
         {
-            if(Element is Floater)
+            if(Element is Floater floater)
             {
-                return (double)((Floater)Element).Width;
+                return (double)floater.Width;
             }
             else
             {
@@ -897,9 +891,9 @@ private bool IsFloaterRejected(bool fAtMaxWidth, double availableSpace)
             {
                 return false;
             }
-            else if(Element is Figure)
+            else if(Element is Figure figure)
             {
-                FigureLength figureLength = ((Figure)Element).Width;
+                FigureLength figureLength = figure.Width;
                 if(figureLength.IsAuto)
                 {
                     return false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FlowDocumentPage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FlowDocumentPage.cs
index 4aee5ede..535ec165 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FlowDocumentPage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/FlowDocumentPage.cs
@@ -328,9 +328,9 @@ internal ReadOnlyCollection<Rect> GetRectanglesCore(ContentElement child, bool i
                     // Element exists within this Page, calculate its length
                     int elementStartOffset = _structuralCache.TextContainer.Start.GetOffsetToPosition(elementStart);
                     int elementLength = 1;
-                    if (child is TextElement)
+                    if (child is TextElement textElement)
                     {
-                        TextPointer elementEnd = new TextPointer(((TextElement)child).ElementEnd);
+                        TextPointer elementEnd = new TextPointer(textElement.ElementEnd);
                         elementLength = elementStart.GetOffsetToPosition(elementEnd);
                     }
 
@@ -825,10 +825,7 @@ private void Dispose(bool disposing)
                     }
 
                     // Dispose PTS page
-                    if (_ptsPage != null)
-                    {
-                        _ptsPage.Dispose();
-                    }
+                    _ptsPage?.Dispose();
                 }
                 try
                 {
@@ -904,10 +901,7 @@ private void OnBeforeFormatPage()
         //-------------------------------------------------------------------
         private void OnAfterFormatPage()
         {
-            if (_textView != null)
-            {
-                _textView.Invalidate();
-            }
+            _textView?.Invalidate();
             _visualNeedsUpdate = true;
         }
 
@@ -1037,10 +1031,7 @@ private void DestroyVisualLinks(ContainerVisual visual)
         /// </summary>
         private void ValidateTextView()
         {
-            if (_textView != null)
-            {
-                _textView.OnUpdated();
-            }
+            _textView?.OnUpdated();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Line.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Line.cs
index 07bb9c1a..500fb647 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Line.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Line.cs
@@ -73,10 +73,7 @@ public override void Dispose()
             Debug.Assert(_line != null, "Line has been already disposed.");
             try
             {
-                if (_line != null)
-                {
-                    _line.Dispose();
-                }
+                _line?.Dispose();
             }
             finally
             {
@@ -306,13 +303,13 @@ internal void Format(FormattingContext ctx, int dcp, int width, int trackWidth,
                     foreach (TextSpan<TextRun> textSpan in _runs)
                     {
                         TextRun run = (TextRun)textSpan.Value;
-                        if (run is InlineObjectRun)
+                        if (run is InlineObjectRun inlineObjectRun)
                         {
-                            inlineObjects.Add(new InlineObject(dcpRun, ((InlineObjectRun)run).UIElementIsland, (TextParagraph)_paraClient.Paragraph));
+                            inlineObjects.Add(new InlineObject(dcpRun, inlineObjectRun.UIElementIsland, (TextParagraph)_paraClient.Paragraph));
                         }
-                        else if (run is FloatingRun)
+                        else if (run is FloatingRun floatingRun)
                         {
-                            if (((FloatingRun)run).Figure)
+                            if (floatingRun.Figure)
                             {
                                 _hasFigures = true;
                             }
@@ -414,9 +411,8 @@ internal ContainerVisual CreateVisual()
                     foreach (TextSpan<TextRun> textSpan in runs)
                     {
                         TextRun run = (TextRun)textSpan.Value;
-                        if (run is InlineObjectRun)
+                        if (run is InlineObjectRun inlineObject)
                         {
-                            InlineObjectRun inlineObject = (InlineObjectRun)run;
                             FlowDirection flowDirection;
                             Rect rect = GetBoundsFromPosition(dcpRun, run.Length, out flowDirection);
                             Debug.Assert(DoubleUtil.GreaterThanOrClose(rect.Width, 0), "Negative inline object's width.");
@@ -945,13 +941,13 @@ internal PTS.FSFLRES FormattingResult
                 // Since there are Newline characters in the line, do more expensive and
                 // accurate check.
                 TextRun run = ((TextSpan<TextRun>)_runs[_runs.Count - 1]).Value as TextRun;
-                if (run is ParagraphBreakRun)
+                if (run is ParagraphBreakRun paragraphBreakRun)
                 {
-                    formatResult = ((ParagraphBreakRun)run).BreakReason;
+                    formatResult = paragraphBreakRun.BreakReason;
                 }
-                else if (run is LineBreakRun)
+                else if (run is LineBreakRun lineBreakRun)
                 {
-                    formatResult = ((LineBreakRun)run).BreakReason;
+                    formatResult = lineBreakRun.BreakReason;
                 }
                 return formatResult;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/LineBreakRecord.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/LineBreakRecord.cs
index f9191e87..f6a11fd3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/LineBreakRecord.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/LineBreakRecord.cs
@@ -37,10 +37,7 @@ internal LineBreakRecord(PtsContext ptsContext, TextLineBreak textLineBreak) : b
         /// </summary>
         public override void Dispose()
         {
-            if(_textLineBreak != null)
-            {
-                _textLineBreak.Dispose();
-            }
+            _textLineBreak?.Dispose();
 
             base.Dispose();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/MbpInfo.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/MbpInfo.cs
index c817b255..03d0a703 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/MbpInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/MbpInfo.cs
@@ -112,9 +112,9 @@ private MbpInfo(TextElement block)
         private static void ResolveAutoMargin(MbpInfo mbp, DependencyObject o, double lineHeight)
         {
             Thickness defaultMargin;
-            if (o is Paragraph)
+            if (o is Paragraph paragraph)
             {
-                DependencyObject parent = ((Paragraph)o).Parent;
+                DependencyObject parent = paragraph.Parent;
                 if (parent is ListItem || parent is TableCell || parent is AnchoredBlock)
                 {
                     defaultMargin = new Thickness(0);
@@ -153,9 +153,9 @@ private static void ResolveAutoPadding(MbpInfo mbp, DependencyObject o, double l
             {
                 defaultPadding = new Thickness(0.5 * lineHeight);
             }
-            else if (o is List)
+            else if (o is List list)
             {
-                defaultPadding = ListMarkerSourceInfo.CalculatePadding((List)o, lineHeight, pixelsPerDip);
+                defaultPadding = ListMarkerSourceInfo.CalculatePadding(list, lineHeight, pixelsPerDip);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalBreakSession.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalBreakSession.cs
index 187507c5..2067aa0a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalBreakSession.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalBreakSession.cs
@@ -44,15 +44,9 @@ public override void Dispose()
         {
             try
             {
-                if(_textParagraphCache != null)
-                {
-                    _textParagraphCache.Dispose();
-                }
-
-                if(_optimalTextSource != null)
-                {
-                    _optimalTextSource.Dispose();
-                }
+                _textParagraphCache?.Dispose();
+
+                _optimalTextSource?.Dispose();
             }
             finally
             {
@@ -106,10 +100,7 @@ internal LineBreakpoint(OptimalBreakSession optimalBreakSession, TextBreakpoint
         /// </summary>
         public override void Dispose()
         {
-            if(_textBreakpoint != null)
-            {
-                _textBreakpoint.Dispose();
-            }
+            _textBreakpoint?.Dispose();
 
             base.Dispose();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalTextSource.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalTextSource.cs
index 07cef9a0..f6c0f5a2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalTextSource.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/OptimalTextSource.cs
@@ -208,13 +208,13 @@ internal PTS.FSFLRES GetFormatResultForBreakpoint(int dcp, TextBreakpoint textBr
                 
                 if (run != null && ((dcpRun + run.Length) >= (dcp + textBreakpoint.Length)))
                 {
-                    if (run is ParagraphBreakRun)
+                    if (run is ParagraphBreakRun paragraphBreakRun)
                     {
-                        formatResult = ((ParagraphBreakRun)run).BreakReason;
+                        formatResult = paragraphBreakRun.BreakReason;
                     }
-                    else if (run is LineBreakRun)
+                    else if (run is LineBreakRun lineBreakRun)
                     {
-                        formatResult = ((LineBreakRun)run).BreakReason;
+                        formatResult = lineBreakRun.BreakReason;
                     }
                     break;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PageVisual.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PageVisual.cs
index a28ab2c1..831eb564 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PageVisual.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PageVisual.cs
@@ -112,8 +112,7 @@ internal void ClearDrawingContext()
         /// </summary>
         IInputElement IContentHost.InputHitTest(Point point)
         {
-            IContentHost host = _owner.Target as IContentHost;
-            if (host != null)
+            if (_owner.Target is IContentHost host)
             {
                 return host.InputHitTest(point);
             }
@@ -125,8 +124,7 @@ IInputElement IContentHost.InputHitTest(Point point)
         /// </summary>
         ReadOnlyCollection<Rect> IContentHost.GetRectangles(ContentElement child)
         {
-            IContentHost host = _owner.Target as IContentHost;
-            if (host != null)
+            if (_owner.Target is IContentHost host)
             {
                 return host.GetRectangles(child);
             }
@@ -155,10 +153,7 @@ IEnumerator<IInputElement> IContentHost.HostedElements
         void IContentHost.OnChildDesiredSizeChanged(UIElement child)
         {
             IContentHost host = _owner.Target as IContentHost;
-            if (host != null)
-            {
-                host.OnChildDesiredSizeChanged(child);
-            }
+            host?.OnChildDesiredSizeChanged(child);
         }
 
         #endregion IContentHost Members
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsCache.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsCache.cs
index 9c65339e..e2be6f70 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsCache.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsCache.cs
@@ -118,8 +118,7 @@ internal static bool IsDisposed()
             Dispatcher dispatcher = Dispatcher.CurrentDispatcher;
             if (dispatcher != null)
             {
-                PtsCache ptsCache = Dispatcher.CurrentDispatcher.PtsCache as PtsCache;
-                if (ptsCache != null)
+                if (Dispatcher.CurrentDispatcher.PtsCache is PtsCache ptsCache)
                 {
                     disposed = (ptsCache._disposed == 1);
                 }
@@ -312,8 +311,7 @@ private void DestroyPTSContexts()
             int index = 0;
             while (index < _contextPool.Count)
             {
-                PtsContext ptsContext = _contextPool[index].Owner.Target as PtsContext;
-                if (ptsContext != null)
+                if (_contextPool[index].Owner.Target is PtsContext ptsContext)
                 {
                     Invariant.Assert(_contextPool[index].PtsHost.Context == ptsContext.Context, "PTS Context mismatch.");
                     _contextPool[index].Owner = new WeakReference(null);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsContext.cs
index 91b1e27a..2a616619 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsContext.cs
@@ -138,9 +138,9 @@ public void Dispose()
                                 for (int i = 0; i < _unmanagedHandles.Length; ++i)
                                 {
                                     Object objDbg = _unmanagedHandles[i].Obj;
-                                    if (objDbg is TextParagraph)
+                                    if (objDbg is TextParagraph textParagraph)
                                     {
-                                        List<AttachedObject> attachedObjects = ((TextParagraph)objDbg).AttachedObjectDbg;
+                                        List<AttachedObject> attachedObjects = textParagraph.AttachedObjectDbg;
                                         if (attachedObjects != null)
                                         {
                                             foreach (AttachedObject attachedObject in attachedObjects)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsHost.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsHost.cs
index d31c88d2..4086928b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsHost.cs
@@ -1326,8 +1326,8 @@ internal IntPtr Context
             {
                 TextParagraph para = PtsContext.HandleToObject(nmp) as TextParagraph;
                 PTS.ValidateHandle(para);
-                Line line = PtsContext.HandleToObject(pfslineLast) as Line;
-                if(line != null)
+
+                if(PtsContext.HandleToObject(pfslineLast) is Line line)
                 {
                     PTS.ValidateHandle(line);
                     para.FormatBottomText(iArea, fswdir, line, dvrLine, out pmcsclientOut);
@@ -1734,8 +1734,7 @@ out iLineVariantBest
             int fserr = PTS.fserrNone;
             try
             {
-                Line line = PtsContext.HandleToObject(pfsline) as Line;
-                if(line != null)
+                if(PtsContext.HandleToObject(pfsline) is Line line)
                 {
                     PTS.ValidateHandle(line);
                     line.GetDvrSuppressibleBottomSpace(out dvrSuppressible);
@@ -2174,8 +2173,7 @@ out iLineVariantBest
             int fserr = PTS.fserrNone;
             try
             {
-                Line line = PtsContext.HandleToObject(pfsline) as Line;
-                if(line != null)
+                if(PtsContext.HandleToObject(pfsline) is Line line)
                 {
                     PTS.ValidateHandle(line);
                     FigureParagraph paraFigure = PtsContext.HandleToObject(nmpFigure) as FigureParagraph;
@@ -4098,10 +4096,7 @@ out iLineVariantBest
             try
             {
                 CellParaClient cellParaClient = PtsContext.HandleToObject(pfsCell) as CellParaClient;
-                if (cellParaClient != null)
-                {
-                    cellParaClient.Dispose();
-                }
+                cellParaClient?.Dispose();
             }
             catch (Exception e)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsPage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsPage.cs
index 56fccdb4..c285163a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsPage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/PtsPage.cs
@@ -750,10 +750,7 @@ private void OnBeforeFormatPage(bool finitePage, bool incremental)
             _pageContextOfThisPage.PageRect = new PTS.FSRECT(new Rect(_section.StructuralCache.CurrentFormatContext.PageSize));
 
             // Ensure we have no background work pending
-            if (_backgroundFormatOperation != null)
-            {
-                _backgroundFormatOperation.Abort();
-            }
+            _backgroundFormatOperation?.Abort();
 
             if (!_finitePage)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Section.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Section.cs
index 4b68b02a..7b0f2695 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Section.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/Section.cs
@@ -420,10 +420,7 @@ public override void Dispose()
         /// </summary>
         internal void InvalidateFormatCache()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.InvalidateFormatCache();
-            }
+            _mainTextSegment?.InvalidateFormatCache();
         }
 
         /// <summary>
@@ -431,10 +428,7 @@ internal void InvalidateFormatCache()
         /// </summary>
         internal void ClearUpdateInfo()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.ClearUpdateInfo();
-            }
+            _mainTextSegment?.ClearUpdateInfo();
         }
 
         /// <summary>
@@ -469,10 +463,7 @@ internal void DestroyStructure()
         /// </summary>
         internal void UpdateSegmentLastFormatPositions()
         {
-            if(_mainTextSegment != null)
-            {
-                _mainTextSegment.UpdateLastFormatPositions();
-            }
+            _mainTextSegment?.UpdateLastFormatPositions();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/SubpageParagraph.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/SubpageParagraph.cs
index 47296386..9de1e1c9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/SubpageParagraph.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/SubpageParagraph.cs
@@ -645,10 +645,7 @@ public override void Dispose()
         // ------------------------------------------------------------------
         internal override void ClearUpdateInfo()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.ClearUpdateInfo();
-            }
+            _mainTextSegment?.ClearUpdateInfo();
             base.ClearUpdateInfo();
         }
 
@@ -678,10 +675,7 @@ internal override bool InvalidateStructure(int startPosition)
         // ------------------------------------------------------------------
         internal override void InvalidateFormatCache()
         {
-            if (_mainTextSegment != null)
-            {
-                _mainTextSegment.InvalidateFormatCache();
-            }
+            _mainTextSegment?.InvalidateFormatCache();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/TextParaClient.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/TextParaClient.cs
index 2cf57328..a62b56ad 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/TextParaClient.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/TextParaClient.cs
@@ -1331,7 +1331,7 @@ protected override void OnArrange()
                         BaseParaClient paraClient = PtsContext.HandleToObject(attachedObjectDesc.pfsparaclient) as BaseParaClient;
                         PTS.ValidateHandle(paraClient);
 
-                        if(paraClient is FloaterParaClient)
+                        if(paraClient is FloaterParaClient floaterParaClient)
                         {
                             PTS.FSFLOATERDETAILS floaterDetails;
                             PTS.Validate(PTS.FsQueryFloaterDetails(PtsContext.Context, attachedObjectDesc.pfspara, out floaterDetails));
@@ -1343,9 +1343,9 @@ protected override void OnArrange()
                                 PTS.Validate(PTS.FsTransformRectangle(PTS.FlowDirectionToFswdir(ThisFlowDirection), ref pageRect, ref rectFloater, PTS.FlowDirectionToFswdir(PageFlowDirection), out rectFloater));
                             }
 
-                            ((FloaterParaClient)paraClient).ArrangeFloater(rectFloater, _rect, PTS.FlowDirectionToFswdir(ThisFlowDirection), _pageContext);
+                            floaterParaClient.ArrangeFloater(rectFloater, _rect, PTS.FlowDirectionToFswdir(ThisFlowDirection), _pageContext);
                         }
-                        else if(paraClient is FigureParaClient)
+                        else if(paraClient is FigureParaClient figureParaClient)
                         {
                             PTS.FSFIGUREDETAILS figureDetails;
                             PTS.Validate(PTS.FsQueryFigureObjectDetails(PtsContext.Context, attachedObjectDesc.pfspara, out figureDetails));
@@ -1357,7 +1357,7 @@ protected override void OnArrange()
                                 PTS.Validate(PTS.FsTransformRectangle(PTS.FlowDirectionToFswdir(ThisFlowDirection), ref pageRect, ref rectFigure, PTS.FlowDirectionToFswdir(PageFlowDirection), out rectFigure));
                             }
 
-                            ((FigureParaClient)paraClient).ArrangeFigure(rectFigure, _rect, PTS.FlowDirectionToFswdir(ThisFlowDirection), _pageContext);
+                            figureParaClient.ArrangeFigure(rectFigure, _rect, PTS.FlowDirectionToFswdir(ThisFlowDirection), _pageContext);
                         }
                         else
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/UIElementParagraph.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/UIElementParagraph.cs
index b9712623..dfa4aac6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/UIElementParagraph.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/UIElementParagraph.cs
@@ -134,10 +134,7 @@ internal override bool InvalidateStructure(int startPosition)
                     dvr += mcsNew.Margin;
                 }
             }
-            if (mcsNew != null)
-            {
-                mcsNew.Dispose();
-            }
+            mcsNew?.Dispose();
         }
 
         //-------------------------------------------------------------------
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/linebase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/linebase.cs
index 4265a9d0..0d1c915c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/linebase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/PtsHost/linebase.cs
@@ -311,14 +311,14 @@ protected TextRun HandleEmbeddedObject(int dcp, StaticTextPointer position)
 
             TextRun run = null;
             DependencyObject embeddedObject = position.GetAdjacentElement(LogicalDirection.Forward) as DependencyObject;
-            if (embeddedObject is UIElement)
+            if (embeddedObject is UIElement uIElement)
             {
                 // Extract the aggregated properties into something that the textrun can use.
                 TextRunProperties textProps = new TextProperties(embeddedObject, position, true /* inline objects */, true /* get background */,
                     _paraClient.Paragraph.StructuralCache.TextFormatterHost.PixelsPerDip);
 
                 // Create inline object run.
-                run = new InlineObjectRun(TextContainerHelper.EmbeddedObjectLength, (UIElement)embeddedObject, textProps, _paraClient.Paragraph as TextParagraph);
+                run = new InlineObjectRun(TextContainerHelper.EmbeddedObjectLength, uIElement, textProps, _paraClient.Paragraph as TextParagraph);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/ComplexLine.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/ComplexLine.cs
index 569380a6..87708aae 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/ComplexLine.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/ComplexLine.cs
@@ -528,14 +528,14 @@ private TextRun HandleInlineObject(StaticTextPointer position, int dcp)
 
             TextRun run = null;
             DependencyObject element = position.GetAdjacentElement(LogicalDirection.Forward) as DependencyObject;
-            if (element is UIElement)
+            if (element is UIElement uIElement)
             {
                 //  Need to Handle visibility collapsed.
 
                 TextRunProperties textProps = new TextProperties(element, position, true /* inline objects */, true /* get background */, PixelsPerDip);
 
                 // Create object run.
-                run = new InlineObject(dcp, TextContainerHelper.EmbeddedObjectLength, (UIElement)element, textProps, _owner);
+                run = new InlineObject(dcp, TextContainerHelper.EmbeddedObjectLength, uIElement, textProps, _owner);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/DynamicPropertyReader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/DynamicPropertyReader.cs
index 266a4d9d..d3f4697f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/DynamicPropertyReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/DynamicPropertyReader.cs
@@ -159,8 +159,7 @@ private static object GetCollectionValue(DependencyObject element, DependencyPro
         // ------------------------------------------------------------------
         internal static bool GetKeepTogether(DependencyObject element)
         {
-            Paragraph p = element as Paragraph;
-            return (p != null) ? p.KeepTogether : false;
+            return (element is Paragraph p) ? p.KeepTogether : false;
         }
 
         // ------------------------------------------------------------------
@@ -168,8 +167,7 @@ internal static bool GetKeepTogether(DependencyObject element)
         // ------------------------------------------------------------------
         internal static bool GetKeepWithNext(DependencyObject element)
         {
-            Paragraph p = element as Paragraph;
-            return (p != null) ? p.KeepWithNext : false;
+            return (element is Paragraph p) ? p.KeepWithNext : false;
         }
 
         // ------------------------------------------------------------------
@@ -177,8 +175,7 @@ internal static bool GetKeepWithNext(DependencyObject element)
         // ------------------------------------------------------------------
         internal static int GetMinWidowLines(DependencyObject element)
         {
-            Paragraph p = element as Paragraph;
-            return (p != null) ? p.MinWidowLines : 0;
+            return (element is Paragraph p) ? p.MinWidowLines : 0;
         }
 
         // ------------------------------------------------------------------
@@ -186,8 +183,7 @@ internal static int GetMinWidowLines(DependencyObject element)
         // ------------------------------------------------------------------
         internal static int GetMinOrphanLines(DependencyObject element)
         {
-            Paragraph p = element as Paragraph;
-            return (p != null) ? p.MinOrphanLines : 0;
+            return (element is Paragraph p) ? p.MinOrphanLines : 0;
         }
 
         #endregion Block Properties
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/LineProperties.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/LineProperties.cs
index 23fcf65f..0be72025 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/LineProperties.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/LineProperties.cs
@@ -143,9 +143,9 @@ public override double LineHeight
                 _textWrapping = (TextWrapping)contentHost.GetValue(TextBlock.TextWrappingProperty);
                 _textTrimming = (TextTrimming)contentHost.GetValue(TextBlock.TextTrimmingProperty);
             }
-            else if (contentHost is FlowDocument)
+            else if (contentHost is FlowDocument flowDocument)
             {
-                _textWrapping = ((FlowDocument)contentHost).TextWrapping;
+                _textWrapping = flowDocument.TextWrapping;
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/TextProperties.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/TextProperties.cs
index 2ca23e4a..187c50a0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/TextProperties.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Text/TextProperties.cs
@@ -256,8 +256,7 @@ private static TypographyProperties GetTypographyProperties(DependencyObject ele
         {
             Debug.Assert(element != null);
 
-            TextBlock tb = element as TextBlock;
-            if (tb != null)
+            if (element is TextBlock tb)
             {
                 if(!tb.IsTypographyDefaultValue)
                 {
@@ -269,8 +268,7 @@ private static TypographyProperties GetTypographyProperties(DependencyObject ele
                 }
             }
 
-            TextBox textBox = element as TextBox;
-            if (textBox != null)
+            if (element is TextBox textBox)
             {
                 if (!textBox.IsTypographyDefaultValue)
                 {
@@ -282,14 +280,12 @@ private static TypographyProperties GetTypographyProperties(DependencyObject ele
                 }
             }
 
-            TextElement te = element as TextElement;
-            if (te != null)
+            if (element is TextElement te)
             {
                 return te.TypographyPropertiesGroup;
             }
 
-            FlowDocument fd = element as FlowDocument;
-            if (fd != null)
+            if (element is FlowDocument fd)
             {
                return fd.TypographyPropertiesGroup;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/TraceData.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/TraceData.cs
index 0b2e379f..05e3274f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/TraceData.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/TraceData.cs
@@ -98,9 +98,9 @@ static public void OnTrace( AvTraceBuilder traceBuilder, object[] parameters, in
             for( int i = start; i < parameters.Length; i++ )
             {
                 object o = parameters[i];
-                string s = o as string;
                 traceBuilder.Append(" ");
-                if (s != null)
+
+                if (o is string s)
                 {
                     traceBuilder.Append(s);
                 }
@@ -191,8 +191,7 @@ static public void DescribeSourceObject(AvTraceBuilder traceBuilder, object o)
             }
             else
             {
-                FrameworkElement fe = o as FrameworkElement;
-                if (fe != null)
+                if (o is FrameworkElement fe)
                 {
                     traceBuilder.AppendFormat("'{0}' (Name='{1}')", fe.GetType().Name, fe.Name);
                 }
@@ -256,16 +255,13 @@ static public string Identify(object o)
             if (type.IsPrimitive || type.IsEnum)
                 return Format("'{0}'", o);
 
-            string s = o as String;
-            if (s != null)
+            if (o is String s)
                 return Format("'{0}'", AvTrace.AntiFormat(s));
 
-            NamedObject n = o as NamedObject;
-            if (n != null)
+            if (o is NamedObject n)
                 return AvTrace.AntiFormat(n.ToString());
 
-            ICollection ic = o as ICollection;
-            if (ic != null)
+            if (o is ICollection ic)
                 return Format("{0} (hash={1} Count={2})", type.Name, AvTrace.GetHashCodeHelper(o), ic.Count);
 
             return Format("{0} (hash={1})", type.Name, AvTrace.GetHashCodeHelper(o));
@@ -285,16 +281,15 @@ static public string IdentifyWeakEvent(Type type)
 
         static public string IdentifyAccessor(object accessor)
         {
-            DependencyProperty dp = accessor as DependencyProperty;
-            if (dp != null)
+            if (accessor is DependencyProperty dp)
                 return Format("{0}({1})", dp.GetType().Name, dp.Name);
+;
 
-            PropertyInfo pi = accessor as PropertyInfo;;
-            if (pi != null)
+            if (accessor is PropertyInfo pi)
                 return Format("{0}({1})", pi.GetType().Name, pi.Name);
+;
 
-            PropertyDescriptor pd = accessor as PropertyDescriptor;;
-            if (pd != null)
+            if (accessor is PropertyDescriptor pd)
                 return Format("{0}({1})", pd.GetType().Name, pd.Name);
 
             return Identify(accessor);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Utility/BindUriHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Utility/BindUriHelper.cs
index 102eca47..016cfa4b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Utility/BindUriHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/Utility/BindUriHelper.cs
@@ -125,8 +125,7 @@ static internal Uri GetUriToNavigate(DependencyObject element, Uri baseUri, Uri
                 // and use its CurrentSource.
                 if (element != null)
                 {
-                    INavigator navigator = element as INavigator;
-                    if (navigator != null)
+                    if (element is INavigator navigator)
                     {
                         currentSource = navigator.CurrentSource;
                     }
@@ -179,7 +178,7 @@ static internal string GetFragment(Uri uri)
             }
 
             frag = workuri.Fragment;
-            if (frag != null && frag.Length > 0)
+            if (!string.IsNullOrEmpty(frag))
             {
                 // take off the pound
                 fragment = frag.Substring(1);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakDictionary.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakDictionary.cs
index 8ec74fe4..7ca10a6c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakDictionary.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakDictionary.cs
@@ -79,8 +79,7 @@ public IEnumerator<KeyType> GetEnumerator()
                 IWeakHashtable hashTable = Dict._hashTable;
                 foreach (object obj in hashTable.Keys)
                 {
-                    KeyType key = hashTable.UnwrapKey(obj) as KeyType;
-                    if (key != null)
+                    if (hashTable.UnwrapKey(obj) is KeyType key)
                     {
                         yield return key;
                     }
@@ -166,8 +165,7 @@ public IEnumerator<ValueType> GetEnumerator()
                 IWeakHashtable hashTable = Dict._hashTable;
                 foreach (object obj in hashTable.Keys)
                 {
-                    KeyType key = hashTable.UnwrapKey(obj) as KeyType;
-                    if (key != null)
+                    if (hashTable.UnwrapKey(obj) is KeyType key)
                     {
                         yield return (ValueType)hashTable[obj];
                     }
@@ -345,8 +343,7 @@ public bool Remove(KeyValuePair<TKey, TValue> item)
         {
             foreach (object obj in _hashTable.Keys)
             {
-                TKey key = _hashTable.UnwrapKey(obj) as TKey;
-                if (key != null)
+                if (_hashTable.UnwrapKey(obj) is TKey key)
                 {
                     yield return new KeyValuePair<TKey, TValue>(key, (TValue)_hashTable[obj]);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakHashSet.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakHashSet.cs
index 7c28bfdc..1f4b598c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakHashSet.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakHashSet.cs
@@ -96,11 +96,9 @@ public IEnumerator<T> GetEnumerator()
         {
             foreach (object key in _hashTable.Keys)
             {
-                WeakHashtable.EqualityWeakReference objRef = key as WeakHashtable.EqualityWeakReference;
-                if (objRef != null)
+                if (key is WeakHashtable.EqualityWeakReference objRef)
                 {
-                    T obj = objRef.Target as T;
-                    if (obj != null)
+                    if (objRef.Target is T obj)
                     {
                         yield return obj;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakObjectHashtable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakObjectHashtable.cs
index 940bef3a..74a2526c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakObjectHashtable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/WeakObjectHashtable.cs
@@ -57,8 +57,7 @@ private void WrapKey(ref object key)
 
         public object UnwrapKey(object key)
         {
-            EqualityWeakReference keyRef = key as EqualityWeakReference;
-            return (keyRef != null) ? keyRef.Target : key;
+            return (key is EqualityWeakReference keyRef) ? keyRef.Target : key;
         }
 
         /// <devdoc>
@@ -106,8 +105,7 @@ private void ScavengeKeys()
                 ArrayList cleanupList = null;
                 foreach (object o in Keys)
                 {
-                    EqualityWeakReference wr = o as EqualityWeakReference;
-                    if (wr != null && !wr.IsAlive)
+                    if (o is EqualityWeakReference wr && !wr.IsAlive)
                     {
                         if (cleanupList == null)
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/Application/DocumentApplicationJournalEntry.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/Application/DocumentApplicationJournalEntry.cs
index e6353a63..1de2db26 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/Application/DocumentApplicationJournalEntry.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/Application/DocumentApplicationJournalEntry.cs
@@ -76,20 +76,19 @@ public override void Replay(NavigationService navigationService, NavigationMode
             if (docViewer != null)
             {
                 // Set the new state on the DocumentViewer
-                if (_state is DocumentApplicationState)
+                if (_state is DocumentApplicationState documentApplicationState)
                 {
-                    docViewer.StoredDocumentApplicationState = (DocumentApplicationState)_state;
+                    docViewer.StoredDocumentApplicationState = documentApplicationState;
                 }
 
                 // Check that a Document exists.
                 if (navigationService.Content != null)
                 {
-                    IDocumentPaginatorSource document = navigationService.Content as IDocumentPaginatorSource;
 
                     // If the document has already been paginated (could happen in the
                     // case of a fragment navigation), then set the DocumentViewer to the
                     // new state that was set.
-                    if ((document != null) && (document.DocumentPaginator.IsPageCountValid))
+                    if ((navigationService.Content is IDocumentPaginatorSource document) && (document.DocumentPaginator.IsPageCountValid))
                     {
                         docViewer.SetUIToStoredState();
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ColumnResult.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ColumnResult.cs
index ce633808..034b7f7e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ColumnResult.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ColumnResult.cs
@@ -157,17 +157,17 @@ internal ReadOnlyCollection<ParagraphResult> Paragraphs
                     }
                     else
                     {
-                        if (_subpage is FigureParaClient)
+                        if (_subpage is FigureParaClient figureParaClient)
                         {
-                            _paragraphs = ((FigureParaClient)_subpage).GetParagraphResultsFromColumn(_columnHandle, _columnOffset, out _hasTextContent);
+                            _paragraphs = figureParaClient.GetParagraphResultsFromColumn(_columnHandle, _columnOffset, out _hasTextContent);
                         }
-                        else if (_subpage is FloaterParaClient)
+                        else if (_subpage is FloaterParaClient floaterParaClient)
                         {
-                            _paragraphs = ((FloaterParaClient)_subpage).GetParagraphResultsFromColumn(_columnHandle, _columnOffset, out _hasTextContent);
+                            _paragraphs = floaterParaClient.GetParagraphResultsFromColumn(_columnHandle, _columnOffset, out _hasTextContent);
                         }
-                        else if (_subpage is SubpageParaClient)
+                        else if (_subpage is SubpageParaClient subpageParaClient)
                         {
-                            _paragraphs = ((SubpageParaClient)_subpage).GetParagraphResultsFromColumn(_columnHandle, _columnOffset, out _hasTextContent);
+                            _paragraphs = subpageParaClient.GetParagraphResultsFromColumn(_columnHandle, _columnOffset, out _hasTextContent);
                         }
                         else
                         {
@@ -234,17 +234,17 @@ private void EnsureTextContentRange()
                 }
                 else
                 {
-                    if (_subpage is FigureParaClient)
+                    if (_subpage is FigureParaClient figureParaClient)
                     {
-                        _contentRange = ((FigureParaClient)_subpage).GetTextContentRangeFromColumn(_columnHandle);
+                        _contentRange = figureParaClient.GetTextContentRangeFromColumn(_columnHandle);
                     }
-                    else if (_subpage is FloaterParaClient)
+                    else if (_subpage is FloaterParaClient floaterParaClient)
                     {
-                        _contentRange = ((FloaterParaClient)_subpage).GetTextContentRangeFromColumn(_columnHandle);
+                        _contentRange = floaterParaClient.GetTextContentRangeFromColumn(_columnHandle);
                     }
-                    else if (_subpage is SubpageParaClient)
+                    else if (_subpage is SubpageParaClient subpageParaClient)
                     {
-                        _contentRange = ((SubpageParaClient)_subpage).GetTextContentRangeFromColumn(_columnHandle);
+                        _contentRange = subpageParaClient.GetTextContentRangeFromColumn(_columnHandle);
                     }
                     else
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ContentHostHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ContentHostHelper.cs
index 9213b5f7..dd77e026 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ContentHostHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ContentHostHelper.cs
@@ -46,17 +46,17 @@ internal static IContentHost FindContentHost(ContentElement contentElement)
 
             // If the ContentElement is a TextElement, retrieve IContentHost form the owner
             // of TextContainer.
-            if (contentElement is TextElement)
+            if (contentElement is TextElement textElement)
             {
-                textContainer = ((TextElement)contentElement).TextContainer;
+                textContainer = textElement.TextContainer;
                 parent = textContainer.Parent;
-                if (parent is IContentHost) // TextBlock
+                if (parent is IContentHost iContentHost) // TextBlock
                 {
-                    ich = (IContentHost)parent;
+                    ich = iContentHost;
                 }
-                else if (parent is FlowDocument) // Viewers
+                else if (parent is FlowDocument flowDocument) // Viewers
                 {
-                    ich = GetICHFromFlowDocument((TextElement)contentElement, (FlowDocument)parent);
+                    ich = GetICHFromFlowDocument((TextElement)contentElement, flowDocument);
                 }
                 else if (textContainer.TextView != null && textContainer.TextView.RenderScope is IContentHost)
                 {
@@ -149,9 +149,9 @@ private static void FindDocumentPageViews(Visual root, List<DocumentPageView> pa
             Invariant.Assert(root != null);
             Invariant.Assert(pageViews != null);
 
-            if (root is DocumentPageView)
+            if (root is DocumentPageView documentPageView)
             {
-                pageViews.Add((DocumentPageView)root);
+                pageViews.Add(documentPageView);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGrid.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGrid.cs
index 6db6670a..538fdb33 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGrid.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGrid.cs
@@ -2061,9 +2061,9 @@ private void QueueUpdateDocumentLayout(DocumentLayout layout)
         /// <returns></returns>
         private object UpdateDocumentLayoutDelegate(object layout)
         {
-            if (layout is DocumentLayout)
+            if (layout is DocumentLayout documentLayout)
             {
-                UpdateDocumentLayout((DocumentLayout)layout);
+                UpdateDocumentLayout(documentLayout);
             }
             // Decrease the count of pending DocumentLayout delegates
             _documentLayoutsPending--;
@@ -2194,10 +2194,7 @@ private void SetVerticalOffsetInternal(double offset)
         private void UpdateTextView()
         {
             MultiPageTextView tv = TextView as MultiPageTextView;
-            if (tv != null)
-            {
-                tv.OnPageLayoutChanged();
-            }
+            tv?.OnPageLayoutChanged();
         }
 
         /// <summary>
@@ -2295,10 +2292,7 @@ private void InvalidateChildMeasure()
             {
                 UIElement page = _childrenCollection[i] as UIElement;
 
-                if (page != null)
-                {
-                    page.InvalidateMeasure();
-                }
+                page?.InvalidateMeasure();
             }
         }
 
@@ -2516,15 +2510,9 @@ private void Initialize()
         /// </summary>
         private void InvalidateDocumentScrollInfo()
         {
-            if (ScrollOwner != null)
-            {
-                ScrollOwner.InvalidateScrollInfo();
-            }
+            ScrollOwner?.InvalidateScrollInfo();
 
-            if (DocumentViewerOwner != null)
-            {
-                DocumentViewerOwner.InvalidateDocumentScrollInfo();
-            }
+            DocumentViewerOwner?.InvalidateDocumentScrollInfo();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridContextMenu.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridContextMenu.cs
index 743f050d..eab17f60 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridContextMenu.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridContextMenu.cs
@@ -58,7 +58,7 @@ private static void OnDocumentViewerContextMenuOpening(object sender, ContextMen
             if (e.CursorLeft == KeyboardInvokedSentinel)
             {
                 DocumentViewer dv = sender as DocumentViewer;
-                if (dv != null && dv.ScrollViewer != null)
+                if (dv?.ScrollViewer != null)
                 {
                     OnContextMenuOpening(dv.ScrollViewer.Content, e);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridPage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridPage.cs
index bf524e5d..6a7a1d64 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridPage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentGridPage.cs
@@ -395,10 +395,7 @@ protected void Dispose()
 
                 //Dispose our DocumentPageView.
                 IDisposable dpv = _documentPageView as IDisposable;
-                if (dpv != null)
-                {
-                    dpv.Dispose();
-                }
+                dpv?.Dispose();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageHost.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageHost.cs
index 2139b92e..bf834084 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageHost.cs
@@ -45,12 +45,8 @@ internal DocumentPageHost()
 
         internal static void DisconnectPageVisual(Visual pageVisual)
         {
-            // There might be a case where a visual associated with a page was 
-            // inserted to a visual tree before. It got removed later, but GC did not
-            // destroy its parent yet. To workaround this case always check for the parent
-            // of page visual and disconnect it, when necessary.
-            Visual currentParent = VisualTreeHelper.GetParent(pageVisual) as Visual;
-            if (currentParent != null)
+            // There might be a case where a visual associated with a page was             // inserted to a visual tree before. It got removed later, but GC did not            // destroy its parent yet. To workaround this case always check for the parent            // of page visual and disconnect it, when necessary.
+            if (VisualTreeHelper.GetParent(pageVisual) is Visual currentParent)
             {
                 ContainerVisual pageVisualHost = currentParent as ContainerVisual;
                 if (pageVisualHost == null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageTextView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageTextView.cs
index 55696168..9b20c6e0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageTextView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentPageTextView.cs
@@ -46,9 +46,9 @@ internal DocumentPageTextView(DocumentPageView owner, ITextContainer textContain
             _page = owner.DocumentPageInternal;
             _textContainer = textContainer;
             // Retrive inner TextView
-            if (_page is IServiceProvider)
+            if (_page is IServiceProvider iServiceProvider)
             {
-                _pageTextView = ((IServiceProvider)_page).GetService(typeof(ITextView)) as ITextView;
+                _pageTextView = iServiceProvider.GetService(typeof(ITextView)) as ITextView;
             }
             if (_pageTextView != null)
             {
@@ -72,9 +72,9 @@ internal DocumentPageTextView(FlowDocumentView owner, ITextContainer textContain
             _page = owner.DocumentPage;
             _textContainer = textContainer;
             // Retrive inner TextView
-            if (_page is IServiceProvider)
+            if (_page is IServiceProvider iServiceProvider)
             {
-                _pageTextView = ((IServiceProvider)_page).GetService(typeof(ITextView)) as ITextView;
+                _pageTextView = iServiceProvider.GetService(typeof(ITextView)) as ITextView;
             }
             if (_pageTextView != null)
             {
@@ -343,18 +343,18 @@ internal override bool Contains(ITextPointer position)
         internal void OnPageConnected()
         {
             OnPageDisconnected();
-            if (_owner is DocumentPageView)
+            if (_owner is DocumentPageView documentPageView)
             {
-                _page = ((DocumentPageView)_owner).DocumentPageInternal;
+                _page = documentPageView.DocumentPageInternal;
             }
-            else if (_owner is FlowDocumentView)
+            else if (_owner is FlowDocumentView flowDocumentView)
             {
-                _page = ((FlowDocumentView)_owner).DocumentPage;
+                _page = flowDocumentView.DocumentPage;
             }
 
-            if (_page is IServiceProvider)
+            if (_page is IServiceProvider iServiceProvider)
             {
-                _pageTextView = ((IServiceProvider)_page).GetService(typeof(ITextView)) as ITextView;
+                _pageTextView = iServiceProvider.GetService(typeof(ITextView)) as ITextView;
             }
             if (_pageTextView != null)
             {
@@ -454,7 +454,7 @@ internal override void ThrottleBackgroundTasksForUserInput()
         {
             FlowDocumentView owner = _owner as FlowDocumentView;
 
-            if (owner != null && owner.Document != null)
+            if (owner?.Document != null)
             {
                 owner.Document.StructuralCache.ThrottleBackgroundFormatting();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentViewerHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentViewerHelper.cs
index 7ad8abb6..c2e93735 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentViewerHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/DocumentViewerHelper.cs
@@ -340,7 +340,7 @@ internal static void KeyDownHelper(KeyEventArgs e, DependencyObject findToolBarH
                 if (e.Key == Key.Left || e.Key == Key.Right || e.Key == Key.Up || e.Key == Key.Down)
                 {
                     DependencyObject focusedElement = Keyboard.FocusedElement as DependencyObject;
-                    if (focusedElement != null && focusedElement is Visual &&
+                    if (focusedElement is Visual &&
                         VisualTreeHelper.IsAncestorOf(findToolBarHost, focusedElement))
                     {
                         FocusNavigationDirection direction = KeyboardNavigation.KeyToTraversalDirection(e.Key);
@@ -348,7 +348,7 @@ internal static void KeyDownHelper(KeyEventArgs e, DependencyObject findToolBarH
                         // If PredictedFocus is within FindToolBar, move the focus to PredictedFocus and handle
                         // the event. Otherwise do not handle the event and let the viewer to do 
                         // its default logic.
-                        if (predictedFocus != null && predictedFocus is IInputElement &&
+                        if (predictedFocus is IInputElement &&
                             VisualTreeHelper.IsAncestorOf(findToolBarHost, focusedElement))
                         {
                             ((IInputElement)predictedFocus).Focus();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/FlowDocumentView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/FlowDocumentView.cs
index 262f877b..e0f8044d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/FlowDocumentView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/FlowDocumentView.cs
@@ -159,10 +159,7 @@ protected sealed override Size ArrangeOverride(Size arrangeSize)
                     // Connect to visual tree.
                     if (_pageVisual != _formatter.DocumentPage.Visual)
                     {
-                        if (_textView != null)
-                        {
-                            _textView.OnPageConnected();
-                        }
+                        _textView?.OnPageConnected();
                         if (_pageVisual != null)
                         {
                             RemoveVisualChild(_pageVisual);
@@ -186,10 +183,7 @@ protected sealed override Size ArrangeOverride(Size arrangeSize)
                 {
                     if (_pageVisual != null)
                     {
-                        if (_textView != null)
-                        {
-                            _textView.OnPageDisconnected();
-                        }
+                        _textView?.OnPageDisconnected();
                         RemoveVisualChild(_pageVisual);
                         _pageVisual = null;
                     }
@@ -388,10 +382,7 @@ private void HandleFormatterSuspended(object sender, EventArgs e)
             // Disconnect any content associated with the formatter.
             if (_pageVisual != null && !_suspendLayout)
             {
-                if (_textView != null)
-                {
-                    _textView.OnPageDisconnected();
-                }
+                _textView?.OnPageDisconnected();
                 RemoveVisualChild(_pageVisual);
                 _pageVisual = null;
             }
@@ -429,10 +420,7 @@ private void HandleFormatterSuspended(object sender, EventArgs e)
         /// </summary>
         void IScrollInfo.LineUp()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineUp(this);
-            }
+            _scrollData?.LineUp(this);
         }
 
         /// <summary>
@@ -440,10 +428,7 @@ void IScrollInfo.LineUp()
         /// </summary>
         void IScrollInfo.LineDown()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineDown(this);
-            }
+            _scrollData?.LineDown(this);
         }
 
         /// <summary>
@@ -451,10 +436,7 @@ void IScrollInfo.LineDown()
         /// </summary>
         void IScrollInfo.LineLeft()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineLeft(this);
-            }
+            _scrollData?.LineLeft(this);
         }
 
         /// <summary>
@@ -462,10 +444,7 @@ void IScrollInfo.LineLeft()
         /// </summary>
         void IScrollInfo.LineRight()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineRight(this);
-            }
+            _scrollData?.LineRight(this);
         }
 
         /// <summary>
@@ -473,10 +452,7 @@ void IScrollInfo.LineRight()
         /// </summary>
         void IScrollInfo.PageUp()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageUp(this);
-            }
+            _scrollData?.PageUp(this);
         }
 
         /// <summary>
@@ -484,10 +460,7 @@ void IScrollInfo.PageUp()
         /// </summary>
         void IScrollInfo.PageDown()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageDown(this);
-            }
+            _scrollData?.PageDown(this);
         }
 
         /// <summary>
@@ -495,10 +468,7 @@ void IScrollInfo.PageDown()
         /// </summary>
         void IScrollInfo.PageLeft()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageLeft(this);
-            }
+            _scrollData?.PageLeft(this);
         }
 
         /// <summary>
@@ -506,10 +476,7 @@ void IScrollInfo.PageLeft()
         /// </summary>
         void IScrollInfo.PageRight()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageRight(this);
-            }
+            _scrollData?.PageRight(this);
         }
 
         /// <summary>
@@ -517,10 +484,7 @@ void IScrollInfo.PageRight()
         /// </summary>
         void IScrollInfo.MouseWheelUp()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelUp(this);
-            }
+            _scrollData?.MouseWheelUp(this);
         }
 
         /// <summary>
@@ -528,10 +492,7 @@ void IScrollInfo.MouseWheelUp()
         /// </summary>
         void IScrollInfo.MouseWheelDown()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelDown(this);
-            }
+            _scrollData?.MouseWheelDown(this);
         }
 
         /// <summary>
@@ -539,10 +500,7 @@ void IScrollInfo.MouseWheelDown()
         /// </summary>
         void IScrollInfo.MouseWheelLeft()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelLeft(this);
-            }
+            _scrollData?.MouseWheelLeft(this);
         }
 
         /// <summary>
@@ -550,10 +508,7 @@ void IScrollInfo.MouseWheelLeft()
         /// </summary>
         void IScrollInfo.MouseWheelRight()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelRight(this);
-            }
+            _scrollData?.MouseWheelRight(this);
         }
 
         /// <summary>
@@ -561,10 +516,7 @@ void IScrollInfo.MouseWheelRight()
         /// </summary>
         void IScrollInfo.SetHorizontalOffset(double offset)
         {
-            if (_scrollData != null)
-            {
-                _scrollData.SetHorizontalOffset(this, offset);
-            }
+            _scrollData?.SetHorizontalOffset(this, offset);
         }
 
         /// <summary>
@@ -572,10 +524,7 @@ void IScrollInfo.SetHorizontalOffset(double offset)
         /// </summary>
         void IScrollInfo.SetVerticalOffset(double offset)
         {
-            if (_scrollData != null)
-            {
-                _scrollData.SetVerticalOffset(this, offset);
-            }
+            _scrollData?.SetVerticalOffset(this, offset);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/IFlowDocumentViewer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/IFlowDocumentViewer.cs
index 0ffd14df..e8cdae61 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/IFlowDocumentViewer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/IFlowDocumentViewer.cs
@@ -217,8 +217,7 @@ private bool IsValidTextSelectionForDocument(ITextSelection textSelection, FlowD
         /// </summary>
         private object SetTextSelection(object arg)
         {
-            ITextSelection newTextSelection = arg as ITextSelection;
-            if (newTextSelection != null && Document != null && IsValidTextSelectionForDocument(newTextSelection, Document))
+            if (arg is ITextSelection newTextSelection && Document != null && IsValidTextSelectionForDocument(newTextSelection, Document))
             {
                 ITextSelection textSelection = Document.StructuralCache.TextContainer.TextSelection;
                 if (textSelection != null)
@@ -260,10 +259,7 @@ private object SetTextSelection(object arg)
         /// </summary>
         void IFlowDocumentViewer.PreviousPage()
         {
-            if (ScrollViewer != null)
-            {
-                ScrollViewer.PageUp();
-            }
+            ScrollViewer?.PageUp();
         }
 
         /// <summary>
@@ -271,10 +267,7 @@ void IFlowDocumentViewer.PreviousPage()
         /// </summary>
         void IFlowDocumentViewer.NextPage()
         {
-            if (ScrollViewer != null)
-            {
-                ScrollViewer.PageDown();
-            }
+            ScrollViewer?.PageDown();
         }
 
         /// <summary>
@@ -282,10 +275,7 @@ void IFlowDocumentViewer.NextPage()
         /// </summary>
         void IFlowDocumentViewer.FirstPage()
         {
-            if (ScrollViewer != null)
-            {
-                ScrollViewer.ScrollToHome();
-            }
+            ScrollViewer?.ScrollToHome();
         }
 
         /// <summary>
@@ -293,10 +283,7 @@ void IFlowDocumentViewer.FirstPage()
         /// </summary>
         void IFlowDocumentViewer.LastPage()
         {
-            if (ScrollViewer != null)
-            {
-                ScrollViewer.ScrollToEnd();
-            }
+            ScrollViewer?.ScrollToEnd();
         }
 
         /// <summary>
@@ -553,9 +540,7 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
         /// </summary>
         private object SetTextSelection(object arg)
         {
-            ITextSelection newTextSelection = arg as ITextSelection;
-            FlowDocument flowDocument = Document as FlowDocument;
-            if (newTextSelection != null && flowDocument != null &&
+            if (arg is ITextSelection newTextSelection && Document is FlowDocument flowDocument &&
                 newTextSelection.AnchorPosition != null &&
                 newTextSelection.AnchorPosition.TextContainer == flowDocument.StructuralCache.TextContainer)
             {
@@ -900,7 +885,7 @@ static ReaderTwoPageViewer()
         /// </summary>
         private static object CoerceCanGoToNextPage(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is ReaderTwoPageViewer);
+            Invariant.Assert(d is ReaderTwoPageViewer);
 
             ReaderTwoPageViewer viewer = (ReaderTwoPageViewer)d;
             return (viewer.MasterPageNumber < viewer.PageCount - 1);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/MultiPageTextView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/MultiPageTextView.cs
index 7325ce04..fcd316f0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/MultiPageTextView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/MultiPageTextView.cs
@@ -345,12 +345,11 @@ internal override void BringPositionIntoViewAsync(ITextPointer position, object
             }
             else
             {
-                if (position is ContentPosition)
+                if (position is ContentPosition contentPosition)
                 {
-                    DynamicDocumentPaginator documentPaginator = _viewer.Document.DocumentPaginator as DynamicDocumentPaginator;
-                    if (documentPaginator != null)
+                    if (_viewer.Document.DocumentPaginator is DynamicDocumentPaginator documentPaginator)
                     {
-                        pageNumber = documentPaginator.GetPageNumber((ContentPosition)position) + 1;
+                        pageNumber = documentPaginator.GetPageNumber(contentPosition) + 1;
                         if (_viewer.CanGoToPage(pageNumber))
                         {
                             _viewer.GoToPage(pageNumber);
@@ -421,15 +420,15 @@ internal override void BringPointIntoViewAsync(Point point, object userState)
                     // transformed completely?
                     transform.TryTransform(point, out point);
                     bringIntoViewPending = false;
-                    if (_viewer is FlowDocumentPageViewer)
+                    if (_viewer is FlowDocumentPageViewer flowDocumentPageViewer)
                     {
                         // Special handling for FlowDocumentPageViewer
-                        bringIntoViewPending = ((FlowDocumentPageViewer)_viewer).BringPointIntoView(point);
+                        bringIntoViewPending = flowDocumentPageViewer.BringPointIntoView(point);
                     }
-                    else if (_viewer is DocumentViewer)
+                    else if (_viewer is DocumentViewer documentViewer)
                     {
                         // Special handling for DocumentViewer
-                        bringIntoViewPending = ((DocumentViewer)_viewer).BringPointIntoView(point);
+                        bringIntoViewPending = documentViewer.BringPointIntoView(point);
                     }
                     else
                     {
@@ -533,31 +532,31 @@ internal override void CancelAsync(object userState)
 
             if (_pendingRequest != null)
             {
-                if (_pendingRequest is BringLineIntoViewRequest)
+                if (_pendingRequest is BringLineIntoViewRequest bringLineIntoViewRequest)
                 {
-                    lineRequest = (BringLineIntoViewRequest)_pendingRequest;
+                    lineRequest = bringLineIntoViewRequest;
                     OnBringLineIntoViewCompleted(new BringLineIntoViewCompletedEventArgs(
                         lineRequest.Position, lineRequest.SuggestedX, lineRequest.Count,
                         lineRequest.NewPosition, lineRequest.NewSuggestedX, lineRequest.Count - lineRequest.NewCount,
                         false, null, true, lineRequest.UserState));
                 }
-                else if (_pendingRequest is BringPageIntoViewRequest)
+                else if (_pendingRequest is BringPageIntoViewRequest bringPageIntoViewRequest)
                 {
-                    pageRequest = (BringPageIntoViewRequest)_pendingRequest;
+                    pageRequest = bringPageIntoViewRequest;
                     OnBringPageIntoViewCompleted(new BringPageIntoViewCompletedEventArgs(
                         pageRequest.Position, pageRequest.SuggestedOffset, pageRequest.Count,
                         pageRequest.NewPosition, pageRequest.NewSuggestedOffset, pageRequest.Count - pageRequest.NewCount,
                         false, null, true, pageRequest.UserState));
                 }
-                else if (_pendingRequest is BringPointIntoViewRequest)
+                else if (_pendingRequest is BringPointIntoViewRequest bringPointIntoViewRequest)
                 {
-                    pointRequest = (BringPointIntoViewRequest)_pendingRequest;
+                    pointRequest = bringPointIntoViewRequest;
                     OnBringPointIntoViewCompleted(new BringPointIntoViewCompletedEventArgs(
                         pointRequest.Point, pointRequest.Position, false, null, true, pointRequest.UserState));
                 }
-                else if (_pendingRequest is BringPositionIntoViewRequest)
+                else if (_pendingRequest is BringPositionIntoViewRequest bringPositionIntoViewRequest)
                 {
-                    positionRequest = (BringPositionIntoViewRequest)_pendingRequest;
+                    positionRequest = bringPositionIntoViewRequest;
                     OnBringPositionIntoViewCompleted(new BringPositionIntoViewCompletedEventArgs(
                         positionRequest.Position, false, null, true, positionRequest.UserState));
                 }
@@ -1366,9 +1365,9 @@ private object OnUpdatedWorker(object o)
 
             if (this.IsValid && _pendingRequest != null)
             {
-                if (_pendingRequest is BringLineIntoViewRequest)
+                if (_pendingRequest is BringLineIntoViewRequest bringLineIntoViewRequest)
                 {
-                    lineRequest = (BringLineIntoViewRequest)_pendingRequest;
+                    lineRequest = bringLineIntoViewRequest;
 
                     // Try to find TextView for DocumentPageView with stored page number.
                     pageTextView = GetTextViewFromPageNumber(lineRequest.NewPageNumber);
@@ -1427,9 +1426,9 @@ private object OnUpdatedWorker(object o)
                         OnBringLineIntoViewCompleted(lineRequest);
                     }
                 }
-                else if (_pendingRequest is BringPageIntoViewRequest)
+                else if (_pendingRequest is BringPageIntoViewRequest bringPageIntoViewRequest)
                 {
-                    pageRequest = (BringPageIntoViewRequest)_pendingRequest;
+                    pageRequest = bringPageIntoViewRequest;
 
                     // Try to find TextView for DocumentPageView with stored page number.
                     pageTextView = GetTextViewFromPageNumber(pageRequest.NewPageNumber);
@@ -1474,9 +1473,9 @@ private object OnUpdatedWorker(object o)
                         OnBringPageIntoViewCompleted(pageRequest);
                     }
                 }
-                else if (_pendingRequest is BringPointIntoViewRequest)
+                else if (_pendingRequest is BringPointIntoViewRequest bringPointIntoViewRequest)
                 {
-                    pointRequest = (BringPointIntoViewRequest)_pendingRequest;
+                    pointRequest = bringPointIntoViewRequest;
 
                     pageTextView = GetTextViewFromPoint(pointRequest.Point, true);
                     if (pageTextView != null)
@@ -1487,9 +1486,9 @@ private object OnUpdatedWorker(object o)
                     }
                     OnBringPointIntoViewCompleted(pointRequest);
                 }
-                else if (_pendingRequest is BringPositionIntoViewRequest)
+                else if (_pendingRequest is BringPositionIntoViewRequest bringPositionIntoViewRequest)
                 {
-                    positionRequest = (BringPositionIntoViewRequest)_pendingRequest;
+                    positionRequest = bringPositionIntoViewRequest;
                     positionRequest.Succeeded = positionRequest.Position.HasValidLayout;
                     OnBringPositionIntoViewCompleted(positionRequest);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ScrollData.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ScrollData.cs
index 21f64116..4be97f3b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ScrollData.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/ScrollData.cs
@@ -137,10 +137,7 @@ internal void SetHorizontalOffset(UIElement owner, double offset)
             {
                 _offset.X = offset;
                 owner.InvalidateArrange();
-                if (_scrollOwner != null)
-                {
-                    _scrollOwner.InvalidateScrollInfo();
-                }
+                _scrollOwner?.InvalidateScrollInfo();
             }
         }
 
@@ -159,10 +156,7 @@ internal void SetVerticalOffset(UIElement owner, double offset)
             {
                 _offset.Y = offset;
                 owner.InvalidateArrange();
-                if (_scrollOwner != null)
-                {
-                    _scrollOwner.InvalidateScrollInfo();
-                }
+                _scrollOwner?.InvalidateScrollInfo();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextBoxView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextBoxView.cs
index 8a52c111..00fbd8b9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextBoxView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextBoxView.cs
@@ -75,10 +75,7 @@ object IServiceProvider.GetService(Type serviceType)
         /// </summary>
         void IScrollInfo.LineUp()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineUp(this);
-            }
+            _scrollData?.LineUp(this);
         }
 
         /// <summary>
@@ -86,10 +83,7 @@ void IScrollInfo.LineUp()
         /// </summary>
         void IScrollInfo.LineDown()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineDown(this);
-            }
+            _scrollData?.LineDown(this);
         }
 
         /// <summary>
@@ -97,10 +91,7 @@ void IScrollInfo.LineDown()
         /// </summary>
         void IScrollInfo.LineLeft()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineLeft(this);
-            }
+            _scrollData?.LineLeft(this);
         }
 
         /// <summary>
@@ -108,10 +99,7 @@ void IScrollInfo.LineLeft()
         /// </summary>
         void IScrollInfo.LineRight()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.LineRight(this);
-            }
+            _scrollData?.LineRight(this);
         }
 
         /// <summary>
@@ -119,10 +107,7 @@ void IScrollInfo.LineRight()
         /// </summary>
         void IScrollInfo.PageUp()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageUp(this);
-            }
+            _scrollData?.PageUp(this);
         }
 
         /// <summary>
@@ -130,10 +115,7 @@ void IScrollInfo.PageUp()
         /// </summary>
         void IScrollInfo.PageDown()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageDown(this);
-            }
+            _scrollData?.PageDown(this);
         }
 
         /// <summary>
@@ -141,10 +123,7 @@ void IScrollInfo.PageDown()
         /// </summary>
         void IScrollInfo.PageLeft()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageLeft(this);
-            }
+            _scrollData?.PageLeft(this);
         }
 
         /// <summary>
@@ -152,10 +131,7 @@ void IScrollInfo.PageLeft()
         /// </summary>
         void IScrollInfo.PageRight()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.PageRight(this);
-            }
+            _scrollData?.PageRight(this);
         }
 
         /// <summary>
@@ -163,10 +139,7 @@ void IScrollInfo.PageRight()
         /// </summary>
         void IScrollInfo.MouseWheelUp()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelUp(this);
-            }
+            _scrollData?.MouseWheelUp(this);
         }
 
         /// <summary>
@@ -174,10 +147,7 @@ void IScrollInfo.MouseWheelUp()
         /// </summary>
         void IScrollInfo.MouseWheelDown()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelDown(this);
-            }
+            _scrollData?.MouseWheelDown(this);
         }
 
         /// <summary>
@@ -185,10 +155,7 @@ void IScrollInfo.MouseWheelDown()
         /// </summary>
         void IScrollInfo.MouseWheelLeft()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelLeft(this);
-            }
+            _scrollData?.MouseWheelLeft(this);
         }
 
         /// <summary>
@@ -196,10 +163,7 @@ void IScrollInfo.MouseWheelLeft()
         /// </summary>
         void IScrollInfo.MouseWheelRight()
         {
-            if (_scrollData != null)
-            {
-                _scrollData.MouseWheelRight(this);
-            }
+            _scrollData?.MouseWheelRight(this);
         }
 
         /// <summary>
@@ -207,10 +171,7 @@ void IScrollInfo.MouseWheelRight()
         /// </summary>
         void IScrollInfo.SetHorizontalOffset(double offset)
         {
-            if (_scrollData != null)
-            {
-                _scrollData.SetHorizontalOffset(this, offset);
-            }
+            _scrollData?.SetHorizontalOffset(this, offset);
         }
 
         /// <summary>
@@ -218,10 +179,7 @@ void IScrollInfo.SetHorizontalOffset(double offset)
         /// </summary>
         void IScrollInfo.SetVerticalOffset(double offset)
         {
-            if (_scrollData != null)
-            {
-                _scrollData.SetVerticalOffset(this, offset);
-            }
+            _scrollData?.SetVerticalOffset(this, offset);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextContainerHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextContainerHelper.cs
index 259e8b12..e0726cba 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextContainerHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextContainerHelper.cs
@@ -325,9 +325,9 @@ internal static List<AutomationPeer> GetAutomationPeersFromRange(ITextPointer st
                 {
                     // Get adjacent element and try to retrive AutomationPeer for it.
                     element = start.GetAdjacentElement(LogicalDirection.Forward);
-                    if (element is ContentElement)
+                    if (element is ContentElement contentElement)
                     {
-                        peer = ContentElementAutomationPeer.CreatePeerForElement((ContentElement)element);
+                        peer = ContentElementAutomationPeer.CreatePeerForElement(contentElement);
                         // If AutomationPeer has been retrieved, add it to the collection.
                         // And skip entire element.
                         if (peer != null)
@@ -346,11 +346,11 @@ internal static List<AutomationPeer> GetAutomationPeersFromRange(ITextPointer st
                 {
                     // Get adjacent element and try to retrive AutomationPeer for it.
                     element = start.GetAdjacentElement(LogicalDirection.Forward);
-                    if (element is UIElement)
+                    if (element is UIElement uIElement)
                     {
                         if (ownerContentStart == null || IsImmediateAutomationChild(start, ownerContentStart))
                         {
-                            peer = UIElementAutomationPeer.CreatePeerForElement((UIElement)element);
+                            peer = UIElementAutomationPeer.CreatePeerForElement(uIElement);
                             // If AutomationPeer has been retrieved, add it to the collection.
                             if (peer != null)
                             {
@@ -362,9 +362,9 @@ internal static List<AutomationPeer> GetAutomationPeersFromRange(ITextPointer st
                             }
                         }
                     }
-                    else if (element is ContentElement)
+                    else if (element is ContentElement contentElement)
                     {
-                        peer = ContentElementAutomationPeer.CreatePeerForElement((ContentElement)element);
+                        peer = ContentElementAutomationPeer.CreatePeerForElement(contentElement);
                         // If AutomationPeer has been retrieved, add it to the collection.
                         if (peer != null)
                         {
@@ -407,13 +407,13 @@ internal static bool IsImmediateAutomationChild(ITextPointer elementStart, IText
                 }
                 AutomationPeer peer = null;
                 object element = position.GetAdjacentElement(LogicalDirection.Forward);
-                if (element is UIElement)
+                if (element is UIElement uIElement)
                 {
-                    peer = UIElementAutomationPeer.CreatePeerForElement((UIElement)element);
+                    peer = UIElementAutomationPeer.CreatePeerForElement(uIElement);
                 }
-                else if (element is ContentElement)
+                else if (element is ContentElement contentElement)
                 {
-                    peer = ContentElementAutomationPeer.CreatePeerForElement((ContentElement)element);
+                    peer = ContentElementAutomationPeer.CreatePeerForElement(contentElement);
                 }
                 if (peer != null)
                 {
@@ -478,13 +478,13 @@ internal static AutomationPeer GetEnclosingAutomationPeer(ITextPointer start, IT
                 if (ancestorsStart[depth - 1] == ancestorsEnd[depth - 1])
                 {
                     element = ancestorsStart[depth - 1];
-                    if (element is UIElement)
+                    if (element is UIElement uIElement)
                     {
-                        peer = UIElementAutomationPeer.CreatePeerForElement((UIElement)element);
+                        peer = UIElementAutomationPeer.CreatePeerForElement(uIElement);
                     }
-                    else if (element is ContentElement)
+                    else if (element is ContentElement contentElement)
                     {
-                        peer = ContentElementAutomationPeer.CreatePeerForElement((ContentElement)element);
+                        peer = ContentElementAutomationPeer.CreatePeerForElement(contentElement);
                     }
                     if (peer != null)
                     {
@@ -541,9 +541,9 @@ internal static ITextPointer GetContentStart(ITextContainer textContainer, Depen
             // If the element is a TextElement, return the beginning of its content.
             // Otherwise assume that element is the host of text content and return
             // the beginning of TextContainer.
-            if (element is TextElement)
+            if (element is TextElement textElement)
             {
-                textPointer = ((TextElement)element).ContentStart;
+                textPointer = textElement.ContentStart;
             }
             else
             {
@@ -563,9 +563,9 @@ internal static int GetElementLength(ITextContainer textContainer, DependencyObj
             // For TextElement return its length including edges.
             // Otherwise assume that this is host of TextContainer and return the
             // length of TextContainer.
-            if (element is TextElement)
+            if (element is TextElement textElement)
             {
-                length = ((TextElement)element).SymbolCount;
+                length = textElement.SymbolCount;
             }
             else
             {
@@ -604,8 +604,8 @@ internal static ITextPointer GetTextPointerForEmbeddedObject(FrameworkElement em
         {
             // Likely the embedded element is hosted by some TextElement, like InlineUIContainer or BlockUIContainer
             ITextPointer position;
-            TextElement uiContainer = embeddedObject.Parent as TextElement;
-            if (uiContainer != null)
+
+            if (embeddedObject.Parent is TextElement uiContainer)
             {
                 position = uiContainer.ContentStart;
             }
@@ -703,9 +703,8 @@ internal static int GetCPFromEmbeddedObject(UIElement embeddedObject, ElementEdg
         {
             Invariant.Assert(edge == ElementEdge.BeforeStart || edge == ElementEdge.AfterEnd, "Cannot retrieve CP from the content of embedded object.");
             int cp = -1;
-            if (embeddedObject is FrameworkElement)
+            if (embeddedObject is FrameworkElement fe)
             {
-                FrameworkElement fe = (FrameworkElement)embeddedObject;
                 //likely the embedded element is hosted by some TextElement, like InlineUIContainer or BlockUIContainer
                 if (fe.Parent is TextElement)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextDocumentView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextDocumentView.cs
index 4f8a47b2..254dc717 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextDocumentView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextDocumentView.cs
@@ -201,9 +201,8 @@ internal override Geometry GetTightBoundingGeometryFromTextPositions(ITextPointe
         private Rect CalculateViewportRect()
         {
             Rect visibleRect = Rect.Empty;
-            if (RenderScope is IScrollInfo)
+            if (RenderScope is IScrollInfo scrollInfo)
             {
-                IScrollInfo scrollInfo = (IScrollInfo)RenderScope;
                 if (scrollInfo.ViewportWidth != 0 && scrollInfo.ViewportHeight != 0)
                 {
                     visibleRect = new Rect(scrollInfo.HorizontalOffset, scrollInfo.VerticalOffset, scrollInfo.ViewportWidth, scrollInfo.ViewportHeight);
@@ -749,10 +748,10 @@ private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point p
             // b) TextParagraph - hittest line collection.
             // c) TableParagraph - hittest in table
             // d) Other paragraphs - return position before/after paragraph element.
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 // a) ContainerParagraph - hittest colleciton of nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                 // Paragraphs collection may be null in case of empty List element,
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
@@ -772,10 +771,10 @@ private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point p
                     }
                 }
             }
-            else if (paragraph is TextParagraphResult)
+            else if (paragraph is TextParagraphResult textParagraphResult)
             {
                 // b) TextParagraph - hittest line collection.
-                ReadOnlyCollection<LineResult> lines = ((TextParagraphResult)paragraph).Lines;
+                ReadOnlyCollection<LineResult> lines = textParagraphResult.Lines;
                 Invariant.Assert(lines != null, "Lines collection is null");
                 if (!((TextParagraphResult)paragraph).HasTextContent)
                 {
@@ -786,9 +785,9 @@ private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point p
                     position = TextParagraphView.GetTextPositionFromPoint(lines, point, snapToText);
                 }
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
-                ReadOnlyCollection<ParagraphResult> rowParagraphs = ((TableParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> rowParagraphs = tableParagraphResult.Paragraphs;
                 Invariant.Assert(rowParagraphs != null, "Paragraph collection is null.");
 
                 int index = GetParagraphFromPoint(rowParagraphs, point, snapToText);
@@ -818,10 +817,9 @@ private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point p
                     }
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
                 // Subpage implies new coordinate system.
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 point.X -= subpageParagraphResult.ContentOffset.X;
                 point.Y -= subpageParagraphResult.ContentOffset.Y;
 
@@ -832,9 +830,8 @@ private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point p
             {
                 ReadOnlyCollection<ColumnResult> columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements;
-                if (paragraph is FloaterParagraphResult)
+                if (paragraph is FloaterParagraphResult floaterParagraphResult)
                 {
-                    FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                     columns = floaterParagraphResult.Columns;
                     nestedFloatingElements = floaterParagraphResult.FloatingElements;
                     TransformToSubpage(ref point, floaterParagraphResult.ContentOffset);
@@ -861,8 +858,7 @@ private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point p
             }
             else if (paragraph is UIElementParagraphResult)
             {
-                BlockUIContainer blockUIContainer = paragraph.Element as BlockUIContainer;
-                if (blockUIContainer != null)
+                if (paragraph.Element is BlockUIContainer blockUIContainer)
                 {
                     position = null;
                     if (paragraphBox.Contains(point) || snapToText)
@@ -1008,10 +1004,10 @@ private CellInfo GetCellInfoFromPoint(ParagraphResult paragraph, Point point, Ta
         {
             // Figure out which paragraph is the closest to the input pixel position.
             CellInfo cellInfo = null;
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 // a) ContainerParagraph - hittest colleciton of nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                 // Paragraphs collection may be empty, but should never be null
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null");
                 if (nestedParagraphs.Count > 0)
@@ -1019,9 +1015,9 @@ private CellInfo GetCellInfoFromPoint(ParagraphResult paragraph, Point point, Ta
                     cellInfo = GetCellInfoFromPoint(nestedParagraphs, _emptyParagraphCollection, point, tableFilter);
                 }
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((TableParagraphResult)paragraph).GetParagraphsFromPoint(point, false);
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = tableParagraphResult.GetParagraphsFromPoint(point, false);
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null");
                 if (nestedParagraphs.Count > 0)
                 {
@@ -1032,41 +1028,29 @@ private CellInfo GetCellInfoFromPoint(ParagraphResult paragraph, Point point, Ta
                     cellInfo = ((TableParagraphResult)paragraph).GetCellInfoFromPoint(point);
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
                 // Subpage implies new coordinate system.
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 point.X -= subpageParagraphResult.ContentOffset.X;
                 point.Y -= subpageParagraphResult.ContentOffset.Y;
 
                 // WOOT! COLUMNS!
                 cellInfo = GetCellInfoFromPoint(subpageParagraphResult.Columns, subpageParagraphResult.FloatingElements, point, tableFilter);
-                if (cellInfo != null)
-                {
-                    cellInfo.Adjust(new Point(subpageParagraphResult.ContentOffset.X, subpageParagraphResult.ContentOffset.Y));
-                }
+                cellInfo?.Adjust(new Point(subpageParagraphResult.ContentOffset.X, subpageParagraphResult.ContentOffset.Y));
             }
-            else if (paragraph is FigureParagraphResult)
+            else if (paragraph is FigureParagraphResult figureParagraphResult)
             {
                 // Subpage implies new coordinate system.
-                FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                 TransformToSubpage(ref point, figureParagraphResult.ContentOffset);
                 cellInfo = GetCellInfoFromPoint(figureParagraphResult.Columns, figureParagraphResult.FloatingElements, point, tableFilter);
-                if (cellInfo != null)
-                {
-                    cellInfo.Adjust(new Point(figureParagraphResult.ContentOffset.X, figureParagraphResult.ContentOffset.Y));
-                }
+                cellInfo?.Adjust(new Point(figureParagraphResult.ContentOffset.X, figureParagraphResult.ContentOffset.Y));
             }
-            else if (paragraph is FloaterParagraphResult)
+            else if (paragraph is FloaterParagraphResult floaterParagraphResult)
             {
                 // Subpage implies new coordinate system.
-                FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                 TransformToSubpage(ref point, floaterParagraphResult.ContentOffset);
                 cellInfo = GetCellInfoFromPoint(floaterParagraphResult.Columns, floaterParagraphResult.FloatingElements, point, tableFilter);
-                if (cellInfo != null)
-                {
-                    cellInfo.Adjust(new Point(floaterParagraphResult.ContentOffset.X, floaterParagraphResult.ContentOffset.Y));
-                }
+                cellInfo?.Adjust(new Point(floaterParagraphResult.ContentOffset.X, floaterParagraphResult.ContentOffset.Y));
             }
 
             if (tableFilter != null && cellInfo != null && cellInfo.Cell.Table != tableFilter)
@@ -1153,14 +1137,14 @@ private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointe
             // a) ContainerParagraph - get rectangle from nested paragraphs.
             // b) TextParagraph - get rectangle from text paragraph's content.
             // c) TableParagraph - get rectangle from nested paras
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 rect = GetRectangleFromEdge(paragraph, position);
 
                 if (rect == Rect.Empty)
                 {
                     // a) ContainerParagraph - check collection of nested paragraphs.
-                    ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                    ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                     Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
 
                     if (nestedParagraphs.Count > 0)
@@ -1169,11 +1153,11 @@ private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointe
                     }
                 }
             }
-            else if (paragraph is TextParagraphResult)
+            else if (paragraph is TextParagraphResult textParagraphResult)
             {
-                rect = ((TextParagraphResult)paragraph).GetRectangleFromTextPosition(position);
+                rect = textParagraphResult.GetRectangleFromTextPosition(position);
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
                 // c) TableParagraph - get rectangle from nested paras
 
@@ -1181,7 +1165,7 @@ private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointe
 
                 if (rect == Rect.Empty)
                 {
-                    ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((TableParagraphResult)paragraph).GetParagraphsFromPosition(position);
+                    ReadOnlyCollection<ParagraphResult> nestedParagraphs = tableParagraphResult.GetParagraphsFromPosition(position);
                     Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                     if (nestedParagraphs.Count > 0)
                     {
@@ -1193,10 +1177,9 @@ private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointe
                     }
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
                 // Subpage implies new coordinate system.
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 rect = GetRectangleFromTextPosition(subpageParagraphResult.Columns, subpageParagraphResult.FloatingElements, position);
                 if (rect != Rect.Empty)
                 {
@@ -1204,9 +1187,8 @@ private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointe
                     rect.Y += subpageParagraphResult.ContentOffset.Y;
                 }
             }
-            else if (paragraph is FloaterParagraphResult)
+            else if (paragraph is FloaterParagraphResult floaterParagraphResult)
             {
-                FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = floaterParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = floaterParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Columns collection is null.");
@@ -1218,9 +1200,8 @@ private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointe
                     TransformFromSubpage(ref rect, floaterParagraphResult.ContentOffset);
                 }
             }
-            else if (paragraph is FigureParagraphResult)
+            else if (paragraph is FigureParagraphResult figureParagraphResult)
             {
-                FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Columns collection is null.");
@@ -1487,10 +1468,10 @@ private bool IsAtCaretUnitBoundary(ParagraphResult paragraph, ITextPointer posit
         {
             bool isAtCaretUnitBoundary = false;
 
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 // a) ContainerParagraph - go to collection of nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                 // Paragraphs collection may be null in case of empty List.
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
@@ -1498,23 +1479,22 @@ private bool IsAtCaretUnitBoundary(ParagraphResult paragraph, ITextPointer posit
                     isAtCaretUnitBoundary = IsAtCaretUnitBoundary(nestedParagraphs, _emptyParagraphCollection, position);
                 }
             }
-            else if (paragraph is TextParagraphResult)
+            else if (paragraph is TextParagraphResult textParagraphResult)
             {
                 // b) TextParagraph - search inside it
-                isAtCaretUnitBoundary = ((TextParagraphResult)paragraph).IsAtCaretUnitBoundary(position);
+                isAtCaretUnitBoundary = textParagraphResult.IsAtCaretUnitBoundary(position);
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((TableParagraphResult)paragraph).GetParagraphsFromPosition(position);
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = tableParagraphResult.GetParagraphsFromPosition(position);
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
                 {
                     isAtCaretUnitBoundary = IsAtCaretUnitBoundary(nestedParagraphs, _emptyParagraphCollection, position);
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = subpageParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = subpageParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1524,9 +1504,8 @@ private bool IsAtCaretUnitBoundary(ParagraphResult paragraph, ITextPointer posit
                     isAtCaretUnitBoundary = IsAtCaretUnitBoundary(columns, nestedFloatingElements, position);
                 }
             }
-            else if (paragraph is FigureParagraphResult)
+            else if (paragraph is FigureParagraphResult figureParagraphResult)
             {
-                FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1536,9 +1515,8 @@ private bool IsAtCaretUnitBoundary(ParagraphResult paragraph, ITextPointer posit
                     isAtCaretUnitBoundary = IsAtCaretUnitBoundary(columns, nestedFloatingElements, position);
                 }
             }
-            else if (paragraph is FloaterParagraphResult)
+            else if (paragraph is FloaterParagraphResult floaterParagraphResult)
             {
-                FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = floaterParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = floaterParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1613,10 +1591,10 @@ private ITextPointer GetNextCaretUnitPosition(ReadOnlyCollection<ParagraphResult
         private ITextPointer GetNextCaretUnitPosition(ParagraphResult paragraph, ITextPointer position, LogicalDirection direction)
         {
             ITextPointer nextCaretPosition = position;
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 // a) ContainerParagraph - go to collection of nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                 // Paragraphs collection may be null in case of empty List.
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
@@ -1625,23 +1603,22 @@ private ITextPointer GetNextCaretUnitPosition(ParagraphResult paragraph, ITextPo
                 }
                 // Else: Illegal call from outside TextView, return same position
             }
-            else if (paragraph is TextParagraphResult)
+            else if (paragraph is TextParagraphResult textParagraphResult)
             {
                 // b) TextParagraph - search inside it
-                nextCaretPosition = ((TextParagraphResult)paragraph).GetNextCaretUnitPosition(position, direction);
+                nextCaretPosition = textParagraphResult.GetNextCaretUnitPosition(position, direction);
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((TableParagraphResult)paragraph).GetParagraphsFromPosition(position);
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = tableParagraphResult.GetParagraphsFromPosition(position);
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
                 {
                     nextCaretPosition = GetNextCaretUnitPosition(nestedParagraphs, _emptyParagraphCollection, position, direction);
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = subpageParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = subpageParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1651,9 +1628,8 @@ private ITextPointer GetNextCaretUnitPosition(ParagraphResult paragraph, ITextPo
                     nextCaretPosition = GetNextCaretUnitPosition(columns, nestedFloatingElements, position, direction);
                 }
             }
-            else if (paragraph is FigureParagraphResult)
+            else if (paragraph is FigureParagraphResult figureParagraphResult)
             {
-                FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1663,9 +1639,8 @@ private ITextPointer GetNextCaretUnitPosition(ParagraphResult paragraph, ITextPo
                     nextCaretPosition = GetNextCaretUnitPosition(columns, nestedFloatingElements, position, direction);
                 }
             }
-            else if (paragraph is FloaterParagraphResult)
+            else if (paragraph is FloaterParagraphResult floaterParagraphResult)
             {
-                FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = floaterParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = floaterParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1737,10 +1712,10 @@ private ITextPointer GetBackspaceCaretUnitPosition(ReadOnlyCollection<ParagraphR
         private ITextPointer GetBackspaceCaretUnitPosition(ParagraphResult paragraph, ITextPointer position)
         {
             ITextPointer backspaceCaretPosition = position;
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 // a) ContainerParagraph - go to collection of nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                 // Paragraphs collection may be null in case of empty List.
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
@@ -1748,23 +1723,22 @@ private ITextPointer GetBackspaceCaretUnitPosition(ParagraphResult paragraph, IT
                     backspaceCaretPosition = GetBackspaceCaretUnitPosition(nestedParagraphs, _emptyParagraphCollection, position);
                 }
             }
-            else if (paragraph is TextParagraphResult)
+            else if (paragraph is TextParagraphResult textParagraphResult)
             {
                 // b) TextParagraph - search inside it
-                backspaceCaretPosition = ((TextParagraphResult)paragraph).GetBackspaceCaretUnitPosition(position);
+                backspaceCaretPosition = textParagraphResult.GetBackspaceCaretUnitPosition(position);
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((TableParagraphResult)paragraph).GetParagraphsFromPosition(position);
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = tableParagraphResult.GetParagraphsFromPosition(position);
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
                 {
                     backspaceCaretPosition = GetBackspaceCaretUnitPosition(nestedParagraphs, _emptyParagraphCollection, position);
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = subpageParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = subpageParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1774,9 +1748,8 @@ private ITextPointer GetBackspaceCaretUnitPosition(ParagraphResult paragraph, IT
                     backspaceCaretPosition = GetBackspaceCaretUnitPosition(columns, nestedFloatingElements, position);
                 }
             }
-            else if (paragraph is FigureParagraphResult)
+            else if (paragraph is FigureParagraphResult figureParagraphResult)
             {
-                FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -1786,9 +1759,8 @@ private ITextPointer GetBackspaceCaretUnitPosition(ParagraphResult paragraph, IT
                     backspaceCaretPosition = GetBackspaceCaretUnitPosition(columns, nestedFloatingElements, position);
                 }
             }
-            else if (paragraph is FloaterParagraphResult)
+            else if (paragraph is FloaterParagraphResult floaterParagraphResult)
             {
-                FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = floaterParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = floaterParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -2313,10 +2285,10 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
             // b) TextParagraph - find line index of a line containing input text position 
             //    and then return its range.
             // c) TableParagraph - process nested paragraphs.
-            if (paragraph is ContainerParagraphResult)
+            if (paragraph is ContainerParagraphResult containerParagraphResult)
             {
                 // a) ContainerParagraph - process nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                 // Paragraphs collection may be null in case of empty List.
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
@@ -2324,11 +2296,11 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
                     lineRange = GetLineRangeFromPosition(nestedParagraphs, _emptyParagraphCollection, position);
                 }
             }
-            else if (paragraph is TextParagraphResult)
+            else if (paragraph is TextParagraphResult textParagraphResult)
             {
                 // b) TextParagraph - find line index of a line containing input text position 
                 //    and then return its range.
-                ReadOnlyCollection<LineResult> lines = ((TextParagraphResult)paragraph).Lines;
+                ReadOnlyCollection<LineResult> lines = textParagraphResult.Lines;
                 Invariant.Assert(lines != null, "Lines collection is null");
                 if (!((TextParagraphResult)paragraph).HasTextContent)
                 {
@@ -2346,10 +2318,10 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
                     lineRange = new TextSegment(lines[lineIndex].StartPosition, lines[lineIndex].GetContentEndPosition(), true);
                 }
             }
-            else if (paragraph is TableParagraphResult)
+            else if (paragraph is TableParagraphResult tableParagraphResult)
             {
                 // c) TableParagraph - process nested paragraphs.
-                ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((TableParagraphResult)paragraph).GetParagraphsFromPosition(position);
+                ReadOnlyCollection<ParagraphResult> nestedParagraphs = tableParagraphResult.GetParagraphsFromPosition(position);
                 // Paragraphs collection may be null in case of empty List.
                 Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                 if (nestedParagraphs.Count > 0)
@@ -2357,9 +2329,8 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
                     lineRange = GetLineRangeFromPosition(nestedParagraphs, _emptyParagraphCollection, position);
                 }
             }
-            else if (paragraph is SubpageParagraphResult)
+            else if (paragraph is SubpageParagraphResult subpageParagraphResult)
             {
-                SubpageParagraphResult subpageParagraphResult = (SubpageParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = subpageParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = subpageParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -2369,9 +2340,8 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
                     lineRange = GetLineRangeFromPosition(columns, nestedFloatingElements, position);
                 }
             }
-            else if (paragraph is FigureParagraphResult)
+            else if (paragraph is FigureParagraphResult figureParagraphResult)
             {
-                FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -2381,9 +2351,8 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
                     lineRange = GetLineRangeFromPosition(columns, nestedFloatingElements, position);
                 }
             }
-            else if (paragraph is FloaterParagraphResult)
+            else if (paragraph is FloaterParagraphResult floaterParagraphResult)
             {
-                FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                 ReadOnlyCollection<ColumnResult> columns = floaterParagraphResult.Columns;
                 ReadOnlyCollection<ParagraphResult> nestedFloatingElements = floaterParagraphResult.FloatingElements;
                 Invariant.Assert(columns != null, "Column collection is null.");
@@ -2396,8 +2365,7 @@ private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPoi
             else if (paragraph is UIElementParagraphResult)
             {
                 // UIElement paragraph result - return content range between BlockUIContainer.ContentStart and ContentEnd
-                BlockUIContainer blockUIContainer = paragraph.Element as BlockUIContainer;
-                if (blockUIContainer != null)
+                if (paragraph.Element is BlockUIContainer blockUIContainer)
                 {
                     lineRange = new TextSegment(blockUIContainer.ContentStart.CreatePointer(LogicalDirection.Forward), blockUIContainer.ContentEnd.CreatePointer(LogicalDirection.Backward));
                 }
@@ -2675,10 +2643,9 @@ private ITextPointer GetPositionAtNextLineInFloatingElements(ReadOnlyCollection<
                 Invariant.Assert(paragraphIndex < floatingElements.Count);
                 paragraph = floatingElements[paragraphIndex];
                 Invariant.Assert(paragraph is FigureParagraphResult || paragraph is FloaterParagraphResult);
-                if (paragraph is FigureParagraphResult)
+                if (paragraph is FigureParagraphResult figureParagraphResult)
                 {
                     double newSuggestedX;
-                    FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                     ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                     ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                     Invariant.Assert(columns != null, "Column collection is null.");
@@ -2897,8 +2864,8 @@ private ITextPointer GetPositionAtNextLineFromSiblingPara(ReadOnlyCollection<Par
                     {
                         // We need to get a position in this paragraph
                         Rect paragraphBox = paragraphs[paragraphIndex].LayoutBox;
-                        BlockUIContainer blockUIContainer = paragraphs[paragraphIndex].Element as BlockUIContainer;
-                        if (blockUIContainer != null)
+
+                        if (paragraphs[paragraphIndex].Element is BlockUIContainer blockUIContainer)
                         {
                             if (DoubleUtil.LessThanOrClose(suggestedX, paragraphBox.Width / 2))
                             {
@@ -3135,9 +3102,8 @@ private bool GetGlyphRunsFromParagraphs(List<GlyphRun> glyphRuns, ITextPointer s
             for (int index = 0; index < paragraphs.Count; index++)
             {
                 ParagraphResult paragraph = paragraphs[index];
-                if (paragraph is TextParagraphResult)
+                if (paragraph is TextParagraphResult tpr)
                 {
-                    TextParagraphResult tpr = (TextParagraphResult)paragraph;
                     if (start.CompareTo(tpr.EndPosition) < 0 && end.CompareTo(tpr.StartPosition) > 0)
                     {
                         ITextPointer startRange = start.CompareTo(tpr.StartPosition) < 0 ? tpr.StartPosition : start;
@@ -3151,9 +3117,9 @@ private bool GetGlyphRunsFromParagraphs(List<GlyphRun> glyphRuns, ITextPointer s
                         break;
                     }
                 }
-                else if (paragraph is ContainerParagraphResult)
+                else if (paragraph is ContainerParagraphResult containerParagraphResult)
                 {
-                    ReadOnlyCollection<ParagraphResult> nestedParagraphs = ((ContainerParagraphResult)paragraph).Paragraphs;
+                    ReadOnlyCollection<ParagraphResult> nestedParagraphs = containerParagraphResult.Paragraphs;
                     Invariant.Assert(nestedParagraphs != null, "Paragraph collection is null.");
                     if (nestedParagraphs.Count > 0)
                     {
@@ -3192,9 +3158,8 @@ private void GetGlyphRunsFromFloatingElements(List<GlyphRun> glyphRuns, ITextPoi
                 {
                     success = true;
                     ITextPointer endThisPara = end.CompareTo(paragraph.EndPosition) < 0 ? end : paragraph.EndPosition;
-                    if (paragraph is FigureParagraphResult)
+                    if (paragraph is FigureParagraphResult figureParagraphResult)
                     {
-                        FigureParagraphResult figureParagraphResult = (FigureParagraphResult)paragraph;
                         ReadOnlyCollection<ColumnResult> columns = figureParagraphResult.Columns;
                         ReadOnlyCollection<ParagraphResult> nestedFloatingElements = figureParagraphResult.FloatingElements;
                         Invariant.Assert(columns != null, "Column collection is null.");
@@ -3204,9 +3169,8 @@ private void GetGlyphRunsFromFloatingElements(List<GlyphRun> glyphRuns, ITextPoi
                             GetGlyphRuns(glyphRuns, start, endThisPara, columns, nestedFloatingElements);
                         }
                     }
-                    else if (paragraph is FloaterParagraphResult)
+                    else if (paragraph is FloaterParagraphResult floaterParagraphResult)
                     {
-                        FloaterParagraphResult floaterParagraphResult = (FloaterParagraphResult)paragraph;
                         ReadOnlyCollection<ColumnResult> columns = floaterParagraphResult.Columns;
                         ReadOnlyCollection<ParagraphResult> nestedFloatingElements = floaterParagraphResult.FloatingElements;
                         Invariant.Assert(columns != null, "Column collection is null.");
@@ -3476,9 +3440,7 @@ private static void TransformFromSubpage(Geometry geometry, Vector subpageOffset
         /// </returns>
         private Rect GetRectangleFromEdge(ParagraphResult paragraphResult, ITextPointer textPointer)
         {
-            TextElement textElement = paragraphResult.Element as TextElement;
-
-            if (textElement != null)
+            if (paragraphResult.Element is TextElement textElement)
             {
                 if (textPointer.LogicalDirection == LogicalDirection.Forward && textPointer.CompareTo(textElement.ElementStart) == 0)
                 {
@@ -3506,8 +3468,7 @@ private Rect GetRectangleFromEdge(ParagraphResult paragraphResult, ITextPointer
         /// </returns>
         private Rect GetRectangleFromContentEdge(ParagraphResult paragraphResult, ITextPointer textPointer)
         {
-            TextElement textElement = paragraphResult.Element as TextElement;
-            if (textElement != null)
+            if (paragraphResult.Element is TextElement textElement)
             {
                 // We enable this only for BlockUIContainer, it would be wrong to return layout box Rect from other elements' Content start/end
                 Invariant.Assert(textElement is BlockUIContainer, "Expecting BlockUIContainer");
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextViewBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextViewBase.cs
index 8647e23d..bfb39c58 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextViewBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/MS/Internal/documents/TextViewBase.cs
@@ -135,8 +135,7 @@ internal virtual ReadOnlyCollection<GlyphRun> GetGlyphRuns(ITextPointer start, I
         /// </remarks>
         internal static void BringRectIntoViewMinimally(ITextView textView, Rect rect)
         {
-            IScrollInfo isi = textView.RenderScope as IScrollInfo;
-            if (isi != null)
+            if (textView.RenderScope is IScrollInfo isi)
             {
                 // Initialize the viewport
                 Rect viewport = new Rect(isi.HorizontalOffset, isi.VerticalOffset, isi.ViewportWidth, isi.ViewportHeight);
@@ -152,8 +151,7 @@ internal static void BringRectIntoViewMinimally(ITextView textView, Rect rect)
                 isi.SetVerticalOffset(minY);
 
                 // Adjust rect to reflect changes and allow outer IScrollInfos to react
-                FrameworkElement frameworkParent = FrameworkElement.GetFrameworkParent(textView.RenderScope) as FrameworkElement;
-                if (frameworkParent != null)
+                if (FrameworkElement.GetFrameworkParent(textView.RenderScope) is FrameworkElement frameworkParent)
                 {
                     if (isi.ViewportWidth > 0)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/Microsoft/Win32/CommonDialog.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/Microsoft/Win32/CommonDialog.cs
index e159c106..ab74482c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/Microsoft/Win32/CommonDialog.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/Microsoft/Win32/CommonDialog.cs
@@ -122,10 +122,7 @@ public virtual Nullable<bool> ShowDialog()
             }
             finally
             {
-                if (tempParentHwnd != null)
-                {
-                    tempParentHwnd.Dispose();
-                }
+                tempParentHwnd?.Dispose();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationDocumentPaginator.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationDocumentPaginator.cs
index bca3d30b..f5933a36 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationDocumentPaginator.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationDocumentPaginator.cs
@@ -494,10 +494,7 @@ public IInputElement InputHitTest(Point point)
             /// </summary>
             public void OnChildDesiredSizeChanged(UIElement child)
             {
-                if (_basePage != null)
-                {
-                    _basePage.OnChildDesiredSizeChanged(child);
-                }
+                _basePage?.OnChildDesiredSizeChanged(child);
             }
 
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationResource.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationResource.cs
index 7a1f4847..3c69605b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationResource.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationResource.cs
@@ -157,10 +157,7 @@ public void WriteXml(XmlWriter writer)
             {
                 foreach (XmlElement content in _contents)
                 {
-                    if (content != null)
-                    {
-                        content.WriteTo(writer);
-                    }
+                    content?.WriteTo(writer);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationService.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationService.cs
index 6f87ab7b..920144a8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/AnnotationService.cs
@@ -1577,8 +1577,8 @@ private void FullyResolveAnchor(IAttachedAnnotation attachedAnnotation)
             bool isFlow = false;
             FrameworkElement viewer = this.Root as FrameworkElement;
 
-            if (viewer is DocumentViewerBase)
-                isFlow = ((DocumentViewerBase)viewer).Document is FlowDocument;
+            if (viewer is DocumentViewerBase documentViewerBase)
+                isFlow = documentViewerBase.Document is FlowDocument;
             else if ((viewer is FlowDocumentScrollViewer) || (viewer is FlowDocumentReader))
                 isFlow = true;
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/LocatorPartList.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/LocatorPartList.cs
index a4ef18cf..45b434dc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/LocatorPartList.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/LocatorPartList.cs
@@ -417,8 +417,7 @@ internal override ContentLocatorBase Merge(ContentLocatorBase other)
             if (other == null)
                 return this;
 
-            ContentLocatorGroup locatorGroup = other as ContentLocatorGroup;
-            if (locatorGroup != null)
+            if (other is ContentLocatorGroup locatorGroup)
             {
                 ContentLocatorGroup newGroup = new ContentLocatorGroup();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/Storage/XmlStreamStore.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/Storage/XmlStreamStore.cs
index 9ff797e2..bc79891c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/Storage/XmlStreamStore.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Annotations/Storage/XmlStreamStore.cs
@@ -559,7 +559,7 @@ protected override void OnStoreContentChanged(StoreContentChangedEventArgs e)
         /// <exception cref="ArgumentException">queryExpression is empty string</exception>
         private List<Guid> FindAnnotationIds(string queryExpression)
         {
-            Invariant.Assert(queryExpression != null && queryExpression.Length > 0,
+            Invariant.Assert(!string.IsNullOrEmpty(queryExpression),
                           "Invalid query expression");
 
             Guid annId;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Application.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Application.cs
index 275a575c..30a9a1bd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Application.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Application.cs
@@ -1598,15 +1598,9 @@ internal virtual void DoShutdown()
                 // this will always be null in the browser hosted case since we we don't
                 // support Activate, Deactivate, and SessionEnding events in the
                 // browser scenario and thus we never create this hwndsource.
-                if (_parkingHwnd != null)
-                {
-                    _parkingHwnd.Dispose();
-                }
+                _parkingHwnd?.Dispose();
 
-                if (_events != null)
-                {
-                    _events.Dispose();
-                }
+                _events?.Dispose();
 
                 PreloadedPackages.Clear();
                 AppSecurityManager.ClearSecurityManager();
@@ -2342,7 +2336,7 @@ private static bool IsComponentBeingLoadedFromOuterLoadBaml(Uri curComponentUri)
                 //
                 NestedBamlLoadInfo loadBamlSyncInfo = s_NestedBamlLoadInfo.Peek() as NestedBamlLoadInfo;
 
-                if (loadBamlSyncInfo != null && loadBamlSyncInfo.BamlUri != null &&
+                if (loadBamlSyncInfo?.BamlUri != null &&
                     loadBamlSyncInfo.BamlStream != null &&
                     BindUriHelper.DoSchemeAndHostMatch(loadBamlSyncInfo.BamlUri, curComponentUri))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ButtonBaseAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ButtonBaseAutomationPeer.cs
index d5c2a3f6..f483db42 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ButtonBaseAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ButtonBaseAutomationPeer.cs
@@ -34,8 +34,7 @@ override protected string GetAcceleratorKeyCore()
             string acceleratorKey = base.GetAcceleratorKeyCore();
             if (acceleratorKey == string.Empty)
             {
-                RoutedUICommand uiCommand = ((ButtonBase)Owner).Command as RoutedUICommand;
-                if (uiCommand != null && !string.IsNullOrEmpty(uiCommand.Text))
+                if (((ButtonBase)Owner).Command is RoutedUICommand uiCommand && !string.IsNullOrEmpty(uiCommand.Text))
                 {
                     acceleratorKey = uiCommand.Text;
                 }
@@ -50,8 +49,8 @@ protected override string GetAutomationIdCore()
            if (string.IsNullOrEmpty(result))
            {
                ButtonBase owner = (ButtonBase)Owner;
-               RoutedCommand command = owner.Command as RoutedCommand;
-               if (command != null)
+
+               if (owner.Command is RoutedCommand command)
                {
                    string commandName = command.Name;
                    if (!string.IsNullOrEmpty(commandName))
@@ -79,8 +78,7 @@ override protected string GetNameCore()
             }
             else
             {
-                RoutedUICommand uiCommand = bb.Command as RoutedUICommand;
-                if (uiCommand != null && !string.IsNullOrEmpty(uiCommand.Text))
+                if (bb.Command is RoutedUICommand uiCommand && !string.IsNullOrEmpty(uiCommand.Text))
                 {
                     result = uiCommand.Text;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/CalendarAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/CalendarAutomationPeer.cs
index e47c08b0..8584278e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/CalendarAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/CalendarAutomationPeer.cs
@@ -151,8 +151,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                 }
                 else
                 {
-                    Button owningButton = child as Button;
-                    if (owningButton != null && owningButton.DataContext is DateTime)
+                    if (child is Button owningButton && owningButton.DataContext is DateTime)
                     {
                         date = (DateTime)owningButton.DataContext;
                         peer = GetOrCreateDateTimeAutomationPeer(date, OwningCalendar.DisplayMode, /*addParentInfo*/ false);
@@ -268,8 +267,7 @@ private DateTimeAutomationPeer GetPeerFromWeakRefStorage(DateTimeCalendarModePai
 
             if (weakRefEP != null)
             {
-                ElementProxy provider = weakRefEP.Target as ElementProxy;
-                if (provider != null)
+                if (weakRefEP.Target is ElementProxy provider)
                 {
                     returnPeer = PeerFromProvider(provider as IRawElementProviderSimple) as DateTimeAutomationPeer;
                     if (returnPeer == null)
@@ -300,10 +298,7 @@ internal void RaiseSelectionEvents(SelectionChangedEventArgs e)
             if (AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementSelected) && numSelected == 1 && numAdded == 1)
             {
                 DateTimeAutomationPeer peer = GetOrCreateDateTimeAutomationPeer((DateTime)e.AddedItems[0], CalendarMode.Month);
-                if (peer != null)
-                {
-                    peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
-                }
+                peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
             }
             else
             {
@@ -312,10 +307,7 @@ internal void RaiseSelectionEvents(SelectionChangedEventArgs e)
                     foreach (DateTime date in e.AddedItems)
                     {
                         DateTimeAutomationPeer peer = GetOrCreateDateTimeAutomationPeer(date, CalendarMode.Month);
-                        if (peer != null)
-                        {
-                            peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
-                        }
+                        peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
                     }
                 }
             }
@@ -325,10 +317,7 @@ internal void RaiseSelectionEvents(SelectionChangedEventArgs e)
                 foreach (DateTime date in e.RemovedItems)
                 {
                     DateTimeAutomationPeer peer = GetOrCreateDateTimeAutomationPeer(date, CalendarMode.Month);
-                    if (peer != null)
-                    {
-                        peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
-                    }
+                    peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
                 }
             }
         }
@@ -388,9 +377,8 @@ IRawElementProviderSimple IGridProvider.GetItem(int row, int column)
                     if (childRow == row && childColumn == column)
                     {
                         object dataContext = (child as FrameworkElement).DataContext;
-                        if (dataContext is DateTime)
+                        if (dataContext is DateTime date)
                         {
-                            DateTime date = (DateTime)dataContext;
                             AutomationPeer peer = GetOrCreateDateTimeAutomationPeer(date, OwningCalendar.DisplayMode);
                             return ProviderFromPeer(peer);
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ContentTextAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ContentTextAutomationPeer.cs
index 6213b0fe..e385ffb3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ContentTextAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ContentTextAutomationPeer.cs
@@ -40,13 +40,13 @@ internal DependencyObject ElementFromProvider(IRawElementProviderSimple provider
         {
             DependencyObject element = null;
             AutomationPeer peer = PeerFromProvider(provider);
-            if (peer is UIElementAutomationPeer)
+            if (peer is UIElementAutomationPeer uIElementAutomationPeer)
             {
-                element = ((UIElementAutomationPeer)peer).Owner;
+                element = uIElementAutomationPeer.Owner;
             }
-            else if (peer is ContentElementAutomationPeer)
+            else if (peer is ContentElementAutomationPeer contentElementAutomationPeer)
             {
-                element = ((ContentElementAutomationPeer)peer).Owner;
+                element = contentElementAutomationPeer.Owner;
             }
             return element;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridAutomationPeer.cs
index cb8553bb..382791f3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridAutomationPeer.cs
@@ -99,8 +99,8 @@ public override object GetPattern(PatternInterface patternInterface)
                         if (scrollViewer != null)
                         {
                             AutomationPeer scrollPeer = UIElementAutomationPeer.CreatePeerForElement(scrollViewer);
-                            IScrollProvider scrollProvider = scrollPeer as IScrollProvider;
-                            if (scrollPeer != null && scrollProvider != null)
+
+                            if (scrollPeer != null && scrollPeer is IScrollProvider scrollProvider)
                             {
                                 scrollPeer.EventsSource = this;
                                 return scrollProvider;
@@ -159,8 +159,7 @@ IRawElementProviderSimple IGridProvider.GetItem(int row, int column)
                 this.OwningDataGrid.ScrollIntoView(item, dataGridColumn);
                 this.OwningDataGrid.UpdateLayout();
 
-                DataGridItemAutomationPeer itemPeer = this.FindOrCreateItemAutomationPeer(item) as DataGridItemAutomationPeer;
-                if (itemPeer != null)
+                if (this.FindOrCreateItemAutomationPeer(item) is DataGridItemAutomationPeer itemPeer)
                 {
                     DataGridCellItemAutomationPeer cellItemPeer = itemPeer.GetOrCreateCellItemPeer(dataGridColumn);
                     if (cellItemPeer != null)
@@ -248,8 +247,7 @@ IRawElementProviderSimple[] ITableProvider.GetColumnHeaders()
                 DataGridColumnHeadersPresenter dataGridColumnHeadersPresenter = this.OwningDataGrid.ColumnHeadersPresenter;
                 if (dataGridColumnHeadersPresenter != null)
                 {
-                    DataGridColumnHeadersPresenterAutomationPeer dataGridColumnHeadersPresenterPeer = dataGridColumnHeadersPresenter.GetAutomationPeer()  as DataGridColumnHeadersPresenterAutomationPeer;
-                    if (dataGridColumnHeadersPresenterPeer != null)
+                    if (dataGridColumnHeadersPresenter.GetAutomationPeer() is DataGridColumnHeadersPresenterAutomationPeer dataGridColumnHeadersPresenterPeer)
                     {
                         for (int i = 0; i < this.OwningDataGrid.Columns.Count; i++)
                         {
@@ -317,8 +315,7 @@ private DataGridCellItemAutomationPeer GetCellItemPeer(DataGridCellInfo cellInfo
         {
             if (cellInfo.IsValid)
             {
-                DataGridItemAutomationPeer dataGridItemAutomationPeer = FindOrCreateItemAutomationPeer(cellInfo.Item) as DataGridItemAutomationPeer;
-                if (dataGridItemAutomationPeer != null)
+                if (FindOrCreateItemAutomationPeer(cellInfo.Item) is DataGridItemAutomationPeer dataGridItemAutomationPeer)
                 {
                     return dataGridItemAutomationPeer.GetOrCreateCellItemPeer(cellInfo.Column);
                 }
@@ -337,10 +334,7 @@ internal void RaiseAutomationCellSelectedEvent(SelectedCellsChangedEventArgs e)
                 this.OwningDataGrid.SelectedCells.Count == 1 && e.AddedCells.Count == 1)
             {
                 DataGridCellItemAutomationPeer cellPeer = GetCellItemPeer(e.AddedCells[0]);
-                if (cellPeer != null)
-                {
-                    cellPeer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
-                }
+                cellPeer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
             }
             else
             {
@@ -350,10 +344,7 @@ internal void RaiseAutomationCellSelectedEvent(SelectedCellsChangedEventArgs e)
                     for (i = 0; i < e.AddedCells.Count; i++)
                     {
                         DataGridCellItemAutomationPeer cellPeer = GetCellItemPeer(e.AddedCells[i]);
-                        if (cellPeer != null)
-                        {
-                            cellPeer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
-                        }
+                        cellPeer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
                     }
                 }
 
@@ -362,10 +353,7 @@ internal void RaiseAutomationCellSelectedEvent(SelectedCellsChangedEventArgs e)
                     for (i = 0; i < e.RemovedCells.Count; i++)
                     {
                         DataGridCellItemAutomationPeer cellPeer = GetCellItemPeer(e.RemovedCells[i]);
-                        if (cellPeer != null)
-                        {
-                            cellPeer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
-                        }
+                        cellPeer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
                     }
                 }
             }
@@ -376,24 +364,17 @@ internal void RaiseAutomationCellSelectedEvent(SelectedCellsChangedEventArgs e)
         internal void RaiseAutomationRowInvokeEvents(DataGridRow row)
         {
             DataGridItemAutomationPeer dataGridItemAutomationPeer = FindOrCreateItemAutomationPeer(row.Item) as DataGridItemAutomationPeer;
-            if (dataGridItemAutomationPeer != null)
-            {
-                dataGridItemAutomationPeer.RaiseAutomationEvent(AutomationEvents.InvokePatternOnInvoked);
-            }
+            dataGridItemAutomationPeer?.RaiseAutomationEvent(AutomationEvents.InvokePatternOnInvoked);
         }
 
         // This method is called from DataGrid.OnBeginningEdit/OnCommittingEdit/OnCancelingEdit
         // Raises Invoked event when cell begin/cancel/commit edit
         internal void RaiseAutomationCellInvokeEvents(DataGridColumn column, DataGridRow row)
         {
-            DataGridItemAutomationPeer dataGridItemAutomationPeer = FindOrCreateItemAutomationPeer(row.Item) as DataGridItemAutomationPeer;
-            if (dataGridItemAutomationPeer != null)
+            if (FindOrCreateItemAutomationPeer(row.Item) is DataGridItemAutomationPeer dataGridItemAutomationPeer)
             {
                 DataGridCellItemAutomationPeer cellPeer = dataGridItemAutomationPeer.GetOrCreateCellItemPeer(column);
-                if (cellPeer != null)
-                {
-                    cellPeer.RaiseAutomationEvent(AutomationEvents.InvokePatternOnInvoked);
-                }
+                cellPeer?.RaiseAutomationEvent(AutomationEvents.InvokePatternOnInvoked);
             }
         }
 
@@ -410,10 +391,7 @@ internal void RaiseAutomationSelectionEvents(SelectionChangedEventArgs e)
                 numSelected == 1 && numAdded == 1)
             {
                 ItemAutomationPeer peer = FindOrCreateItemAutomationPeer(this.OwningDataGrid.SelectedItem);
-                if (peer != null)
-                {
-                    peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
-                }
+                peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
             }
             else
             {
@@ -423,10 +401,7 @@ internal void RaiseAutomationSelectionEvents(SelectionChangedEventArgs e)
                     for (i = 0; i < e.AddedItems.Count; i++)
                     {
                         ItemAutomationPeer peer = FindOrCreateItemAutomationPeer(e.AddedItems[i]);
-                        if (peer != null)
-                        {
-                            peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
-                        }
+                        peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
                     }
                 }
 
@@ -435,10 +410,7 @@ internal void RaiseAutomationSelectionEvents(SelectionChangedEventArgs e)
                     for (i = 0; i < e.RemovedItems.Count; i++)
                     {
                         ItemAutomationPeer peer = FindOrCreateItemAutomationPeer(e.RemovedItems[i]);
-                        if (peer != null)
-                        {
-                            peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
-                        }
+                        peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
                     }
                 }
             }
@@ -456,8 +428,7 @@ private void AddSelectedCells(List<IRawElementProviderSimple> cellProviders)
             {
                 foreach (DataGridCellInfo cellInfo in this.OwningDataGrid.SelectedCells)
                 {
-                    DataGridItemAutomationPeer itemPeer = this.FindOrCreateItemAutomationPeer(cellInfo.Item) as DataGridItemAutomationPeer;
-                    if (itemPeer != null)
+                    if (this.FindOrCreateItemAutomationPeer(cellInfo.Item) is DataGridItemAutomationPeer itemPeer)
                     {
                         IRawElementProviderSimple provider = ProviderFromPeer(itemPeer.GetOrCreateCellItemPeer(cellInfo.Column));
                         if (provider != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridCellItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridCellItemAutomationPeer.cs
index 9466211a..c2066ef3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridCellItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridCellItemAutomationPeer.cs
@@ -484,10 +484,7 @@ override internal bool IsDataItemAutomationPeer()
         override internal void AddToParentProxyWeakRefCache()
         {
             DataGridItemAutomationPeer owningItemPeer = this.OwningItemPeer;
-            if (owningItemPeer != null)
-            {
-                owningItemPeer.AddProxyToWeakRefStorage(this.ElementProxyWeakReference, this);
-            }
+            owningItemPeer?.AddProxyToWeakRefStorage(this.ElementProxyWeakReference, this);
         }
 
 
@@ -545,8 +542,7 @@ IRawElementProviderSimple[] ITableItemProvider.GetColumnHeaderItems()
                 (this.OwningDataGrid.HeadersVisibility & DataGridHeadersVisibility.Column) == DataGridHeadersVisibility.Column &&
                 this.OwningDataGrid.ColumnHeadersPresenter != null)
             {
-                DataGridColumnHeadersPresenterAutomationPeer columnHeadersPresenterPeer = UIElementAutomationPeer.CreatePeerForElement(this.OwningDataGrid.ColumnHeadersPresenter) as DataGridColumnHeadersPresenterAutomationPeer;
-                if (columnHeadersPresenterPeer != null)
+                if (UIElementAutomationPeer.CreatePeerForElement(this.OwningDataGrid.ColumnHeadersPresenter) is DataGridColumnHeadersPresenterAutomationPeer columnHeadersPresenterPeer)
                 {
                     AutomationPeer dataGridColumnHeaderPeer = columnHeadersPresenterPeer.FindOrCreateItemAutomationPeer(_column);
                     if (dataGridColumnHeaderPeer != null)
@@ -567,8 +563,8 @@ IRawElementProviderSimple[] ITableItemProvider.GetRowHeaderItems()
                 (this.OwningDataGrid.HeadersVisibility & DataGridHeadersVisibility.Row) == DataGridHeadersVisibility.Row)
             {
                 DataGridAutomationPeer dataGridAutomationPeer = UIElementAutomationPeer.CreatePeerForElement(this.OwningDataGrid) as DataGridAutomationPeer;
-                DataGridItemAutomationPeer dataGridItemAutomationPeer = dataGridAutomationPeer.FindOrCreateItemAutomationPeer(Item) as DataGridItemAutomationPeer;
-                if (dataGridItemAutomationPeer != null)
+
+                if (dataGridAutomationPeer.FindOrCreateItemAutomationPeer(Item) is DataGridItemAutomationPeer dataGridItemAutomationPeer)
                 {
                     AutomationPeer rowHeaderAutomationPeer = dataGridItemAutomationPeer.RowHeaderAutomationPeer;
                     if (rowHeaderAutomationPeer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeaderItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeaderItemAutomationPeer.cs
index 0940a19e..3131c28b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeaderItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeaderItemAutomationPeer.cs
@@ -118,8 +118,7 @@ protected override bool IsContentElementCore()
         #region IInvokeProvider
         void IInvokeProvider.Invoke()
         {
-            UIElementAutomationPeer wrapperPeer = GetWrapperPeer() as UIElementAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is UIElementAutomationPeer wrapperPeer)
             {
                 ((DataGridColumnHeader)wrapperPeer.Owner).Invoke();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeadersPresenterAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeadersPresenterAutomationPeer.cs
index 09c2cd62..d55b20c6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeadersPresenterAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridColumnHeadersPresenterAutomationPeer.cs
@@ -88,9 +88,9 @@ protected override List<AutomationPeer> GetChildrenCore()
                 foreach (object item in childItems)
                 {
                     DataGridColumn dataItem;
-                    if (item is DataGridColumnHeader)
+                    if (item is DataGridColumnHeader dataGridColumnHeader)
                     {
-                        dataItem = ((DataGridColumnHeader) item).Column;
+                        dataItem = dataGridColumnHeader.Column;
                     }
                     else
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridItemAutomationPeer.cs
index f4a6c966..dd00d064 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridItemAutomationPeer.cs
@@ -423,8 +423,8 @@ internal List<AutomationPeer> GetCellItemPeers()
 
             IList childItems = null;
             bool usingItemsHost = false;
-            DataGridRow row = GetWrapper() as DataGridRow;
-            if (row != null)
+
+            if (GetWrapper() is DataGridRow row)
             {
                 if (row.CellsPresenter != null)
                 {
@@ -524,8 +524,7 @@ private DataGridCellItemAutomationPeer GetPeerFromWeakRefStorage(object column)
             WeakReference weakRefEP = WeakRefElementProxyStorage[column];
             if (weakRefEP != null)
             {
-                ElementProxy provider = weakRefEP.Target as ElementProxy;
-                if (provider != null)
+                if (weakRefEP.Target is ElementProxy provider)
                 {
                     returnPeer = PeerFromProvider(provider as IRawElementProviderSimple) as DataGridCellItemAutomationPeer;
                     if (returnPeer == null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridRowAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridRowAutomationPeer.cs
index 50e1ac33..b8a553bd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridRowAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DataGridRowAutomationPeer.cs
@@ -59,7 +59,7 @@ protected override List<AutomationPeer> GetChildrenCore()
         {
             // see whether the DataGridRow uses the standard control template
             DataGridCellsPresenter cellsPresenter = OwningDataGridRow.CellsPresenter;
-            if (cellsPresenter != null && cellsPresenter.ItemsHost != null)
+            if (cellsPresenter?.ItemsHost != null)
             {
                 // this is the normal case
                 List<AutomationPeer> children = new List<AutomationPeer>(3);
@@ -72,8 +72,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                 }
 
                 // Step 2: Add all cells
-                DataGridItemAutomationPeer itemPeer = this.EventsSource as DataGridItemAutomationPeer;
-                if (itemPeer != null)
+                if (this.EventsSource is DataGridItemAutomationPeer itemPeer)
                 {
                     children.AddRange(itemPeer.GetCellItemPeers());
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DatePickerAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DatePickerAutomationPeer.cs
index c3ca89fc..17d8c626 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DatePickerAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DatePickerAutomationPeer.cs
@@ -93,8 +93,7 @@ protected override List<AutomationPeer> GetChildrenCore()
             
             if (OwningDatePicker.IsDropDownOpen && OwningDatePicker.Calendar != null)
             {
-                CalendarAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(OwningDatePicker.Calendar) as CalendarAutomationPeer;
-                if (peer != null)
+                if (UIElementAutomationPeer.CreatePeerForElement(OwningDatePicker.Calendar) is CalendarAutomationPeer peer)
                 {
                     children.Add(peer);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DateTimeAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DateTimeAutomationPeer.cs
index 6ed7fd6a..b6233d1c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DateTimeAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DateTimeAutomationPeer.cs
@@ -882,10 +882,7 @@ override internal bool IsDataItemAutomationPeer()
         override internal void AddToParentProxyWeakRefCache()
         {
             CalendarAutomationPeer owningCalendarPeer = FrameworkElementAutomationPeer.CreatePeerForElement(OwningCalendar) as CalendarAutomationPeer;
-            if (owningCalendarPeer != null)
-            {
-                owningCalendarPeer.AddProxyToWeakRefStorage(this.ElementProxyWeakReference, this);
-            }
+            owningCalendarPeer?.AddProxyToWeakRefStorage(this.ElementProxyWeakReference, this);
         }
 
         #region Private Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentAutomationPeer.cs
index 63df16cb..7399071e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentAutomationPeer.cs
@@ -29,9 +29,9 @@ public class DocumentAutomationPeer : ContentTextAutomationPeer
         public DocumentAutomationPeer(FrameworkContentElement owner)
             : base(owner)
         {
-            if (owner is IServiceProvider)
+            if (owner is IServiceProvider iServiceProvider)
             {
-                _textContainer = ((IServiceProvider)owner).GetService(typeof(ITextContainer)) as ITextContainer;
+                _textContainer = iServiceProvider.GetService(typeof(ITextContainer)) as ITextContainer;
                 if (_textContainer != null)
                 {
                     _textPattern = new TextAdaptor(this, _textContainer);
@@ -79,10 +79,9 @@ public override object GetPattern(PatternInterface patternInterface)
             {
                 if (_textPattern == null)
                 {
-                    if (Owner is IServiceProvider)
+                    if (Owner is IServiceProvider iServiceProvider)
                     {
-                        ITextContainer textContainer = ((IServiceProvider)Owner).GetService(typeof(ITextContainer)) as ITextContainer;
-                        if (textContainer != null)
+                        if (iServiceProvider.GetService(typeof(ITextContainer)) is ITextContainer textContainer)
                         {
                             _textPattern = new TextAdaptor(this, textContainer);
                         }
@@ -141,8 +140,7 @@ protected override Rect GetBoundingRectangleCore()
             Rect boundingRect = CalculateBoundingRect(false, out uiScope);
             if (boundingRect != Rect.Empty && uiScope != null)
             {
-                HwndSource hwndSource = PresentationSource.CriticalFromVisual(uiScope) as HwndSource;
-                if (hwndSource != null)
+                if (PresentationSource.CriticalFromVisual(uiScope) is HwndSource hwndSource)
                 {
                     boundingRect = PointUtil.ElementToRoot(boundingRect, uiScope, hwndSource);
                     boundingRect = PointUtil.RootToClient(boundingRect, hwndSource);
@@ -162,8 +160,7 @@ protected override Point GetClickablePointCore()
             Rect boundingRect = CalculateBoundingRect(true, out uiScope);
             if (boundingRect != Rect.Empty && uiScope != null)
             {
-                HwndSource hwndSource = PresentationSource.CriticalFromVisual(uiScope) as HwndSource;
-                if (hwndSource != null)
+                if (PresentationSource.CriticalFromVisual(uiScope) is HwndSource hwndSource)
                 {
                     boundingRect = PointUtil.ElementToRoot(boundingRect, uiScope, hwndSource);
                     boundingRect = PointUtil.RootToClient(boundingRect, hwndSource);
@@ -216,10 +213,9 @@ private Rect CalculateBoundingRect(bool clipToVisible, out UIElement uiScope)
         {
             uiScope = null;
             Rect boundingRect = Rect.Empty;
-            if (Owner is IServiceProvider)
+            if (Owner is IServiceProvider iServiceProvider)
             {
-                ITextContainer textContainer = ((IServiceProvider)Owner).GetService(typeof(ITextContainer)) as ITextContainer;
-                ITextView textView = (textContainer != null) ? textContainer.TextView : null;
+                ITextView textView = (iServiceProvider.GetService(typeof(ITextContainer)) is ITextContainer textContainer) ? textContainer.TextView : null;
                 if (textView != null)
                 {
                     // Make sure TextView is updated
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerAutomationPeer.cs
index dfabbc11..462135c0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerAutomationPeer.cs
@@ -57,7 +57,7 @@ override public object GetPattern(PatternInterface patternInterface)
                 {
                     // Get a reference to ScrollViewer's AutomationPeer.
                     AutomationPeer scrollPeer = UIElementAutomationPeer.CreatePeerForElement(owner.ScrollViewer);
-                    if (scrollPeer != null && scrollPeer is IScrollProvider)
+                    if (scrollPeer is IScrollProvider)
                     {
                         scrollPeer.EventsSource = this;
                         returnValue = scrollPeer;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerBaseAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerBaseAutomationPeer.cs
index 84526b9d..a2bedf46 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerBaseAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/DocumentViewerBaseAutomationPeer.cs
@@ -69,10 +69,7 @@ protected override List<AutomationPeer> GetChildrenCore()
             AutomationPeer documentPeer = GetDocumentAutomationPeer();
             if (_documentPeer != documentPeer)
             {
-                if (_documentPeer != null)
-                {
-                    _documentPeer.OnDisconnected();
-                }
+                _documentPeer?.OnDisconnected();
                 _documentPeer = documentPeer as DocumentAutomationPeer;
             }
             if (documentPeer != null)
@@ -113,13 +110,13 @@ private AutomationPeer GetDocumentAutomationPeer()
             IDocumentPaginatorSource document = ((DocumentViewerBase)Owner).Document;
             if (document != null)
             {
-                if (document is UIElement)
+                if (document is UIElement uIElement)
                 {
-                    documentPeer = UIElementAutomationPeer.CreatePeerForElement((UIElement)document);
+                    documentPeer = UIElementAutomationPeer.CreatePeerForElement(uIElement);
                 }
-                else if (document is ContentElement)
+                else if (document is ContentElement contentElement)
                 {
-                    documentPeer = ContentElementAutomationPeer.CreatePeerForElement((ContentElement)document);
+                    documentPeer = ContentElementAutomationPeer.CreatePeerForElement(contentElement);
                 }
             }
             return documentPeer;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentReaderAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentReaderAutomationPeer.cs
index e8cfd93a..5b6d158c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentReaderAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentReaderAutomationPeer.cs
@@ -64,10 +64,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                 AutomationPeer documentPeer = ContentElementAutomationPeer.CreatePeerForElement(document);
                 if (_documentPeer != documentPeer)
                 {
-                    if (_documentPeer != null)
-                    {
-                        _documentPeer.OnDisconnected();
-                    }
+                    _documentPeer?.OnDisconnected();
                     _documentPeer = documentPeer as DocumentAutomationPeer;
                 }
                 if (documentPeer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentScrollViewerAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentScrollViewerAutomationPeer.cs
index 1392f312..c74ef598 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentScrollViewerAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FlowDocumentScrollViewerAutomationPeer.cs
@@ -42,7 +42,7 @@ public override object GetPattern(PatternInterface patternInterface)
                 if (owner.ScrollViewer != null)
                 {
                     AutomationPeer scrollPeer = UIElementAutomationPeer.CreatePeerForElement(owner.ScrollViewer);
-                    if (scrollPeer != null && scrollPeer is IScrollProvider)
+                    if (scrollPeer is IScrollProvider)
                     {
                         scrollPeer.EventsSource = this;
                         returnValue = scrollPeer;
@@ -94,10 +94,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                     AutomationPeer documentPeer = ContentElementAutomationPeer.CreatePeerForElement(document);
                     if (_documentPeer != documentPeer)
                     {
-                        if (_documentPeer != null)
-                        {
-                            _documentPeer.OnDisconnected();
-                        }
+                        _documentPeer?.OnDisconnected();
                         _documentPeer = documentPeer as DocumentAutomationPeer;
                     }
                     if (documentPeer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkContentElementAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkContentElementAutomationPeer.cs
index 03760435..aaf8793d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkContentElementAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkContentElementAutomationPeer.cs
@@ -60,8 +60,7 @@ protected override string GetHelpTextCore()
                     result = toolTip as string;
                     if (string.IsNullOrEmpty(result))
                     {
-                        FrameworkElement toolTipElement = toolTip as FrameworkElement;
-                        if (toolTipElement != null)
+                        if (toolTip is FrameworkElement toolTipElement)
                             result = toolTipElement.GetPlainText();
                     }
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkElementAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkElementAutomationPeer.cs
index e58910a9..d1276598 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkElementAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/FrameworkElementAutomationPeer.cs
@@ -77,8 +77,7 @@ protected override string GetHelpTextCore()
                     result = toolTip as string;
                     if (string.IsNullOrEmpty(result))
                     {
-                        FrameworkElement toolTipElement = toolTip as FrameworkElement;
-                        if (toolTipElement != null)
+                        if (toolTip is FrameworkElement toolTipElement)
                             result = toolTipElement.GetPlainText();
                     }
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewAutomationPeer.cs
index cb55e3a3..57066d8f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewAutomationPeer.cs
@@ -217,10 +217,7 @@ IRawElementProviderSimple IGridProvider.GetItem(int row, int column)
             if (lvi == null)
             {
                 VirtualizingPanel itemsHost = _listview.ItemsHost as VirtualizingPanel;
-                if (itemsHost != null)
-                {
-                    itemsHost.BringIndexIntoView(row);
-                }
+                itemsHost?.BringIndexIntoView(row);
 
                 lvi = _listview.ItemContainerGenerator.ContainerFromIndex(row) as ListViewItem;
 
@@ -275,10 +272,7 @@ private void OnColumnCollectionChanged(object sender, NotifyCollectionChangedEve
             {
                 ListViewAutomationPeer peer = UIElementAutomationPeer.FromElement(_listview) as ListViewAutomationPeer;
                 Invariant.Assert(peer != null);
-                if (peer != null)
-                {
-                    peer.RaisePropertyChangedEvent(GridPatternIdentifiers.ColumnCountProperty, _oldColumnsCount, _owner.Columns.Count);
-                }
+                peer?.RaisePropertyChangedEvent(GridPatternIdentifiers.ColumnCountProperty, _oldColumnsCount, _owner.Columns.Count);
             }
 
             _oldColumnsCount = _owner.Columns.Count;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewCellAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewCellAutomationPeer.cs
index 9bb7c5b7..ec48170e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewCellAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewCellAutomationPeer.cs
@@ -110,8 +110,7 @@ IRawElementProviderSimple[] ITableItemProvider.GetRowHeaderItems()
 
         IRawElementProviderSimple[] ITableItemProvider.GetColumnHeaderItems()
         {
-            ListView listview = _listviewAP.Owner as ListView;
-            if (listview != null && listview.View is GridView)
+            if (_listviewAP.Owner is ListView listview && listview.View is GridView)
             {
                 GridView gridview = listview.View as GridView;
                 if (gridview.HeaderRowPresenter != null && gridview.HeaderRowPresenter.ActualColumnHeaders.Count > Column)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewColumnHeaderAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewColumnHeaderAutomationPeer.cs
index 05b48e92..d29c2a66 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewColumnHeaderAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewColumnHeaderAutomationPeer.cs
@@ -99,8 +99,7 @@ void ITransformProvider.Resize(double width, double height)
                 throw new ArgumentOutOfRangeException("height");
             }
 
-            GridViewColumnHeader header = Owner as GridViewColumnHeader;
-            if (header != null)
+            if (Owner is GridViewColumnHeader header)
             {
                 if (header.Column != null)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewHeaderRowPresenterAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewHeaderRowPresenterAutomationPeer.cs
index 56e509ad..966b7af6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewHeaderRowPresenterAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewHeaderRowPresenterAutomationPeer.cs
@@ -60,10 +60,9 @@ protected override List<AutomationPeer> GetChildrenCore()
                 //We need to remove them from the tree
                 foreach (AutomationPeer peer in list)
                 {
-                    if (peer is UIElementAutomationPeer)
+                    if (peer is UIElementAutomationPeer uIElementAutomationPeer)
                     {
-                        GridViewColumnHeader header = ((UIElementAutomationPeer)peer).Owner as GridViewColumnHeader;
-                        if (header != null && header.Role == GridViewColumnHeaderRole.Normal)
+                        if (uIElementAutomationPeer.Owner is GridViewColumnHeader header && header.Role == GridViewColumnHeaderRole.Normal)
                         {
                             //Because GVHRP uses inverse sequence to store column headers, we need to use insert here
                             newList.Insert(0, peer);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewItemAutomationPeer.cs
index 9d1076b6..2adf1056 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GridViewItemAutomationPeer.cs
@@ -52,11 +52,9 @@ protected override List<AutomationPeer> GetChildrenCore()
             Invariant.Assert(listview != null);
             object item = Item;
 
-            ListViewItem lvi = listview.ItemContainerGenerator.ContainerFromItem(item) as ListViewItem;
-            if (lvi != null)
+            if (listview.ItemContainerGenerator.ContainerFromItem(item) is ListViewItem lvi)
             {
-                GridViewRowPresenter rowPresenter = GridViewAutomationPeer.FindVisualByType(lvi, typeof(GridViewRowPresenter)) as GridViewRowPresenter;
-                if (rowPresenter != null)
+                if (GridViewAutomationPeer.FindVisualByType(lvi, typeof(GridViewRowPresenter)) is GridViewRowPresenter rowPresenter)
                 {
                     Hashtable oldChildren = _dataChildren; //cache the old ones for possible reuse
                     _dataChildren = new Hashtable(rowPresenter.ActualCells.Count);
@@ -70,13 +68,13 @@ protected override List<AutomationPeer> GetChildrenCore()
                         GridViewCellAutomationPeer peer = (oldChildren == null ? null : (GridViewCellAutomationPeer)oldChildren[ele]);
                         if (peer == null)
                         {
-                            if (ele is ContentPresenter)
+                            if (ele is ContentPresenter contentPresenter)
                             {
-                                peer = new GridViewCellAutomationPeer((ContentPresenter)ele, _listviewAP);
+                                peer = new GridViewCellAutomationPeer(contentPresenter, _listviewAP);
                             }
-                            else if (ele is TextBlock)
+                            else if (ele is TextBlock textBlock)
                             {
-                                peer = new GridViewCellAutomationPeer((TextBlock)ele, _listviewAP);
+                                peer = new GridViewCellAutomationPeer(textBlock, _listviewAP);
                             }
                             else
                             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GroupItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GroupItemAutomationPeer.cs
index ef36a6c3..647f0aa7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GroupItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/GroupItemAutomationPeer.cs
@@ -109,7 +109,7 @@ override public object GetPattern(PatternInterface patternInterface)
                 if(groupItem.Expander != null)
                 {
                     AutomationPeer expanderPeer = UIElementAutomationPeer.CreatePeerForElement(groupItem.Expander);
-                    if(expanderPeer != null && expanderPeer is IExpandCollapseProvider)
+                    if(expanderPeer is IExpandCollapseProvider)
                     {
                         expanderPeer.EventsSource = this;
                         return (IExpandCollapseProvider)expanderPeer;
@@ -184,10 +184,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                                     if (itemsControlAP.RecentlyRealizedPeers.Count > 0 && this.AncestorsInvalid)
                                     {
                                         GroupItemAutomationPeer groupItemPeer = peer as GroupItemAutomationPeer;
-                                        if (groupItemPeer != null)
-                                        {
-                                            groupItemPeer.InvalidateGroupItemPeersContainingRecentlyRealizedPeers(itemsControlAP.RecentlyRealizedPeers);
-                                        }
+                                        groupItemPeer?.InvalidateGroupItemPeersContainingRecentlyRealizedPeers(itemsControlAP.RecentlyRealizedPeers);
                                     }
                                 }
                                 else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemAutomationPeer.cs
index d8f951ae..019fb742 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemAutomationPeer.cs
@@ -79,8 +79,7 @@ override public object GetPattern(PatternInterface patternInterface)
             }
             else if(patternInterface == PatternInterface.SynchronizedInput)
             {
-                UIElementAutomationPeer peer = GetWrapperPeer() as UIElementAutomationPeer;
-                if(peer != null)
+                if(GetWrapperPeer() is UIElementAutomationPeer peer)
                 {
                     return peer.GetPattern(patternInterface);
                 }
@@ -120,8 +119,8 @@ virtual internal AutomationPeer GetWrapperPeer()
                 wrapperPeer = UIElementAutomationPeer.CreatePeerForElement(wrapper);
                 if(wrapperPeer == null) //fall back to default peer if there is no specific one
                 {
-                    if(wrapper is FrameworkElement)
-                        wrapperPeer = new FrameworkElementAutomationPeer((FrameworkElement)wrapper);
+                    if(wrapper is FrameworkElement frameworkElement)
+                        wrapperPeer = new FrameworkElementAutomationPeer(frameworkElement);
                     else
                         wrapperPeer = new UIElementAutomationPeer(wrapper);
                 }
@@ -156,10 +155,7 @@ override internal bool IsDataItemAutomationPeer()
         override internal void AddToParentProxyWeakRefCache()
         {
             ItemsControlAutomationPeer itemsControlAutomationPeer = ItemsControlAutomationPeer;
-            if(itemsControlAutomationPeer != null)
-            {
-                itemsControlAutomationPeer.AddProxyToWeakRefStorage(this.ElementProxyWeakReference, this);
-            }
+            itemsControlAutomationPeer?.AddProxyToWeakRefStorage(this.ElementProxyWeakReference, this);
         }
 
         /// <summary>
@@ -492,8 +488,7 @@ protected override string GetNameCore()
             if (string.IsNullOrEmpty(name) && item != null)
             {
                 // For FE we can't use ToString as that provides extraneous information than just the plain text
-                FrameworkElement fe = item as FrameworkElement;
-                if(fe != null)
+                if(item is FrameworkElement fe)
                   name = fe.GetPlainText();
 
                 if(string.IsNullOrEmpty(name))
@@ -658,8 +653,8 @@ private object RawItem
         internal void ReuseForItem(object item)
         {
             System.Diagnostics.Debug.Assert(Object.Equals(item, Item), "ItemPeer reuse for an unequal item is not supported");
-            ItemWeakReference iwr = _item as ItemWeakReference;
-            if (iwr != null)
+
+            if (_item is ItemWeakReference iwr)
             {
                 if (!Object.ReferenceEquals(item, iwr.Target))
                 {
@@ -696,8 +691,7 @@ virtual internal void RealizeCore()
             ItemsControlAutomationPeer itemsControlAutomationPeer = ItemsControlAutomationPeer;
             if (itemsControlAutomationPeer != null)
             {
-                ItemsControl parent = itemsControlAutomationPeer.Owner as ItemsControl;
-                if (parent != null)
+                if (itemsControlAutomationPeer.Owner is ItemsControl parent)
                 {
                     if (parent.ItemContainerGenerator.Status == GeneratorStatus.ContainersGenerated)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemsControlAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemsControlAutomationPeer.cs
index df43ac5f..01252255 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemsControlAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ItemsControlAutomationPeer.cs
@@ -41,7 +41,7 @@ override public object GetPattern(PatternInterface patternInterface)
                 if(owner.ScrollHost != null)
                 {
                     AutomationPeer scrollPeer = UIElementAutomationPeer.CreatePeerForElement(owner.ScrollHost);
-                    if(scrollPeer != null && scrollPeer is IScrollProvider)
+                    if(scrollPeer is IScrollProvider)
                     {
                         scrollPeer.EventsSource = this;
                         return (IScrollProvider)scrollPeer;
@@ -106,10 +106,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                             if (_recentlyRealizedPeers != null && _recentlyRealizedPeers.Count > 0 && this.AncestorsInvalid)
                             {
                                 GroupItemAutomationPeer groupItemPeer = peer as GroupItemAutomationPeer;
-                                if (groupItemPeer != null)
-                                {
-                                    groupItemPeer.InvalidateGroupItemPeersContainingRecentlyRealizedPeers(_recentlyRealizedPeers);
-                                }
+                                groupItemPeer?.InvalidateGroupItemPeersContainingRecentlyRealizedPeers(_recentlyRealizedPeers);
                             }
                         }
                         else
@@ -225,10 +222,7 @@ internal ItemAutomationPeer ReusePeerForItem(ItemAutomationPeer peer, object ite
                 }
             }
 
-            if (peer != null)
-            {
-                peer.ReuseForItem(item);
-            }
+            peer?.ReuseForItem(item);
 
             return peer;
         }
@@ -392,10 +386,7 @@ protected virtual internal ItemAutomationPeer FindOrCreateItemAutomationPeer(obj
             {
                 peer = CreateItemAutomationPeer(item);
 
-                if (peer != null)
-                {
-                    peer.TrySetParentInfo(this);
-                }
+                peer?.TrySetParentInfo(this);
             }
 
             if (peer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ListBoxItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ListBoxItemAutomationPeer.cs
index eeaa2739..63f9e2d0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ListBoxItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/ListBoxItemAutomationPeer.cs
@@ -54,8 +54,7 @@ override public object GetPattern(PatternInterface patternInterface)
         ///For ComboBoxItem for which peer is this element only, scrolling should happen when the pop-up is expanded.
         internal override void RealizeCore()
         {
-            ComboBox parent = ItemsControlAutomationPeer.Owner as ComboBox;
-            if (parent != null)
+            if (ItemsControlAutomationPeer.Owner is ComboBox parent)
             {
                 IExpandCollapseProvider iecp = (IExpandCollapseProvider)UIElementAutomationPeer.FromElement(parent) as ComboBoxAutomationPeer;
                 if (iecp.ExpandCollapseState != ExpandCollapseState.Expanded)
@@ -66,13 +65,11 @@ internal override void RealizeCore()
 
         void IScrollItemProvider.ScrollIntoView()
         {
-            ListBox parent = ItemsControlAutomationPeer.Owner as ListBox;
-            if (parent != null)
+            if (ItemsControlAutomationPeer.Owner is ListBox parent)
                 parent.ScrollIntoView(Item);
             else
             {
-                ComboBoxAutomationPeer parentPeer = ItemsControlAutomationPeer as ComboBoxAutomationPeer;
-                if(parentPeer != null)
+                if(ItemsControlAutomationPeer is ComboBoxAutomationPeer parentPeer)
                     parentPeer.ScrollItemIntoView(Item);
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/MenuItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/MenuItemAutomationPeer.cs
index 0cf50a7b..02da173d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/MenuItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/MenuItemAutomationPeer.cs
@@ -185,8 +185,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                     children = new List<AutomationPeer>(items.Count);
                     for (int i = 0; i < items.Count; i++)
                     {
-                        UIElement uiElement = owner.ItemContainerGenerator.ContainerFromIndex(i) as UIElement;
-                        if (uiElement != null)
+                        if (owner.ItemContainerGenerator.ContainerFromIndex(i) is UIElement uiElement)
                         {
                             AutomationPeer peer = UIElementAutomationPeer.FromElement(uiElement);
                             if (peer == null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/SelectorAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/SelectorAutomationPeer.cs
index ead34ff2..5a4d9fe7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/SelectorAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/SelectorAutomationPeer.cs
@@ -75,8 +75,7 @@ internal static new object GetSupportedPropertyValueInternal(AutomationPeer item
         {
             if (SelectionItemPatternIdentifiers.IsSelectedProperty.Id == propertyId)
             {
-                ISelectionItemProvider selectionItem = itemPeer.GetPattern(PatternInterface.SelectionItem) as ISelectionItemProvider;
-                if (selectionItem != null)
+                if (itemPeer.GetPattern(PatternInterface.SelectionItem) is ISelectionItemProvider selectionItem)
                     return selectionItem.IsSelected;
                 else
                     return null;
@@ -105,8 +104,7 @@ internal static new object GetSupportedPropertyValueInternal(AutomationPeer item
 
                 for(int i=0; i<count; i++)
                 {
-                    SelectorItemAutomationPeer peer = FindOrCreateItemAutomationPeer(owner._selectedItems[i].Item) as SelectorItemAutomationPeer;
-                    if(peer != null)
+                    if(FindOrCreateItemAutomationPeer(owner._selectedItems[i].Item) is SelectorItemAutomationPeer peer)
                     {
                         selectedProviders.Add(ProviderFromPeer(peer));
                     }
@@ -159,10 +157,7 @@ internal void RaiseSelectionEvents(SelectionChangedEventArgs e)
             if (numSelected == 1 && numAdded == 1)
             {
                 SelectorItemAutomationPeer peer = FindOrCreateItemAutomationPeer(owner._selectedItems[0].Item) as SelectorItemAutomationPeer;
-                if(peer != null)
-                {
-                    peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
-                }
+                peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
             }
             else
             {
@@ -180,20 +175,14 @@ internal void RaiseSelectionEvents(SelectionChangedEventArgs e)
                     {
                         SelectorItemAutomationPeer peer = FindOrCreateItemAutomationPeer(e.AddedItems[i]) as SelectorItemAutomationPeer;
 
-                        if (peer != null)
-                        {
-                            peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
-                        }
+                        peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementAddedToSelection);
                     }
 
                     for (i = 0; i < numRemoved; i++)
                     {
                         SelectorItemAutomationPeer peer = FindOrCreateItemAutomationPeer(e.RemovedItems[i]) as SelectorItemAutomationPeer;
 
-                        if (peer != null)
-                        {
-                            peer.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
-                        }
+                        peer?.RaiseAutomationEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/StatusBarAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/StatusBarAutomationPeer.cs
index 03927f0d..6ce38ecc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/StatusBarAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/StatusBarAutomationPeer.cs
@@ -43,8 +43,8 @@ protected override AutomationControlType GetAutomationControlTypeCore()
         protected override List<AutomationPeer> GetChildrenCore()
         {
             List<AutomationPeer> list = new List<AutomationPeer>();
-            ItemsControl itemscontrol = Owner as ItemsControl;
-            if (itemscontrol != null)
+
+            if (Owner is ItemsControl itemscontrol)
             {
                 foreach (object obj in itemscontrol.Items)
                 {
@@ -55,9 +55,8 @@ protected override List<AutomationPeer> GetChildrenCore()
                     }
                     else
                     {
-                        StatusBarItem item = itemscontrol.ItemContainerGenerator.ContainerFromItem(obj) as StatusBarItem;
 
-                        if (item != null)
+                        if (itemscontrol.ItemContainerGenerator.ContainerFromItem(obj) is StatusBarItem item)
                         {
                             //If the item is a string or TextBlock or StatusBarItem
                             //StatusBarItemAutomationPeer will be created to show the text
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TabItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TabItemAutomationPeer.cs
index 85258f47..30560ccc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TabItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TabItemAutomationPeer.cs
@@ -46,8 +46,7 @@ override protected string GetNameCore()
             string result = base.GetNameCore();
             if (!string.IsNullOrEmpty(result))
             {
-                TabItem tabItem = GetWrapper() as TabItem;
-                if ((tabItem != null) && (tabItem.Header is string))
+                if ((GetWrapper() is TabItem tabItem) && (tabItem.Header is string))
                 {
                     return AccessText.RemoveAccessKeyMarker(result);
                 }
@@ -64,11 +63,9 @@ protected override List<AutomationPeer> GetChildrenCore()
             List<AutomationPeer> headerChildren = base.GetChildrenCore();
 
             // Only if the TabItem is selected we need to add its visual children
-            TabItem tabItem = GetWrapper() as TabItem;
-            if (tabItem != null && tabItem.IsSelected)
+            if (GetWrapper() is TabItem tabItem && tabItem.IsSelected)
             {
-                TabControl parentTabControl = ItemsControlAutomationPeer.Owner as TabControl;
-                if (parentTabControl != null)
+                if (ItemsControlAutomationPeer.Owner is TabControl parentTabControl)
                 {
                     ContentPresenter contentHost = parentTabControl.SelectedContentPresenter;
                     if (contentHost != null)
@@ -93,9 +90,7 @@ void ISelectionItemProvider.RemoveFromSelection()
         {
             if (!IsEnabled())
                 throw new ElementNotEnabledException();
-
-            TabItem tabItem = GetWrapper() as TabItem;
-            if ((tabItem != null) && tabItem.IsSelected)
+            if ((GetWrapper() is TabItem tabItem) && tabItem.IsSelected)
             {
                 throw new InvalidOperationException(SR.Get(SRID.UIA_OperationCannotBePerformed));
             }
@@ -105,9 +100,9 @@ void ISelectionItemProvider.RemoveFromSelection()
         /// as done for controls like ListBox doesn't make sense for TabControl.
         internal override void RealizeCore()
         {
-            ISelectionItemProvider selectionItemProvider = this as ISelectionItemProvider;
             Selector parentSelector = (Selector)(ItemsControlAutomationPeer.Owner);
-            if (parentSelector != null && selectionItemProvider != null)
+
+            if (parentSelector != null && this is ISelectionItemProvider selectionItemProvider)
             {
                 if (parentSelector.CanSelectMultiple)
                     selectionItemProvider.AddToSelection();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TextAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TextAutomationPeer.cs
index f18a6e05..a816edd8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TextAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TextAutomationPeer.cs
@@ -65,13 +65,13 @@ internal DependencyObject ElementFromProvider(IRawElementProviderSimple provider
         {
             DependencyObject element = null;
             AutomationPeer peer = PeerFromProvider(provider);
-            if (peer is UIElementAutomationPeer)
+            if (peer is UIElementAutomationPeer uIElementAutomationPeer)
             {
-                element = ((UIElementAutomationPeer)peer).Owner;
+                element = uIElementAutomationPeer.Owner;
             }
-            else if (peer is ContentElementAutomationPeer)
+            else if (peer is ContentElementAutomationPeer contentElementAutomationPeer)
             {
-                element = ((ContentElementAutomationPeer)peer).Owner;
+                element = contentElementAutomationPeer.Owner;
             }
             return element;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewAutomationPeer.cs
index ff923297..93e9a6ef 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewAutomationPeer.cs
@@ -52,7 +52,7 @@ override public object GetPattern(PatternInterface patternInterface)
                 if(owner.ScrollHost != null)
                 {
                     AutomationPeer scrollPeer = UIElementAutomationPeer.CreatePeerForElement(owner.ScrollHost);
-                    if(scrollPeer != null && scrollPeer is IScrollProvider)
+                    if(scrollPeer is IScrollProvider)
                     {
                         scrollPeer.EventsSource = this;
                         return (IScrollProvider)scrollPeer;
@@ -83,8 +83,7 @@ protected override List<AutomationPeer> GetChildrenCore()
                     children = new List<AutomationPeer>(items.Count);
                     for (int i = 0; i < items.Count; i++)
                     {
-                        TreeViewItem treeViewItem = owner.ItemContainerGenerator.ContainerFromIndex(i) as TreeViewItem;
-                        if (treeViewItem != null)
+                        if (owner.ItemContainerGenerator.ContainerFromIndex(i) is TreeViewItem treeViewItem)
                         {
                             ItemAutomationPeer peer = oldChildren[items[i]];
                             if (peer == null)
@@ -141,8 +140,7 @@ internal override object GetSupportedPropertyValue(ItemAutomationPeer itemPeer,
         {
             if (SelectionItemPatternIdentifiers.IsSelectedProperty.Id == propertyId)
             {
-                ISelectionItemProvider selectionItem = itemPeer.GetPattern(PatternInterface.SelectionItem) as ISelectionItemProvider;
-                if (selectionItem != null)
+                if (itemPeer.GetPattern(PatternInterface.SelectionItem) is ISelectionItemProvider selectionItem)
                     return selectionItem.IsSelected;
                 else
                     return null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewDataItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewDataItemAutomationPeer.cs
index def30efb..e999a845 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewDataItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewDataItemAutomationPeer.cs
@@ -55,8 +55,7 @@ override public object GetPattern(PatternInterface patternInterface)
             }
             else if ((patternInterface == PatternInterface.ItemContainer) || (patternInterface == PatternInterface.SynchronizedInput))
             {
-                TreeViewItemAutomationPeer treeViewItemAutomationPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-                if (treeViewItemAutomationPeer != null)
+                if (GetWrapperPeer() is TreeViewItemAutomationPeer treeViewItemAutomationPeer)
                 {
                     if(patternInterface == PatternInterface.SynchronizedInput)
                     {
@@ -77,10 +76,7 @@ override internal AutomationPeer GetWrapperPeer()
         {
             AutomationPeer wrapperPeer = base.GetWrapperPeer();
             TreeViewItemAutomationPeer treeViewItemWrapperPeer = wrapperPeer as TreeViewItemAutomationPeer;
-            if (treeViewItemWrapperPeer != null)
-            {
-                treeViewItemWrapperPeer.AddDataPeerInfo(this);
-            }
+            treeViewItemWrapperPeer?.AddDataPeerInfo(this);
             
             return wrapperPeer;
         }
@@ -127,8 +123,7 @@ override internal void RealizeCore()
         ///
         void IExpandCollapseProvider.Expand()
         {
-            TreeViewItemAutomationPeer wrapperPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is TreeViewItemAutomationPeer wrapperPeer)
             {
                 IExpandCollapseProvider iExpandCollapseProvider = wrapperPeer as IExpandCollapseProvider;
                 iExpandCollapseProvider.Expand();
@@ -140,8 +135,7 @@ void IExpandCollapseProvider.Expand()
         ///
         void IExpandCollapseProvider.Collapse()
         {
-            TreeViewItemAutomationPeer wrapperPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is TreeViewItemAutomationPeer wrapperPeer)
             {
                 IExpandCollapseProvider iExpandCollapseProvider = wrapperPeer as IExpandCollapseProvider;
                 iExpandCollapseProvider.Collapse();
@@ -184,8 +178,7 @@ internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue)
         /// </summary>
         void ISelectionItemProvider.Select()
         {
-            TreeViewItemAutomationPeer wrapperPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is TreeViewItemAutomationPeer wrapperPeer)
             {
                 ISelectionItemProvider iSelectionItemProvider = wrapperPeer as ISelectionItemProvider;
                 iSelectionItemProvider.Select();
@@ -199,8 +192,7 @@ void ISelectionItemProvider.Select()
         /// </summary>
         void ISelectionItemProvider.AddToSelection()
         {
-            TreeViewItemAutomationPeer wrapperPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is TreeViewItemAutomationPeer wrapperPeer)
             {
                 ISelectionItemProvider iSelectionItemProvider = wrapperPeer as ISelectionItemProvider;
                 iSelectionItemProvider.AddToSelection();
@@ -214,8 +206,7 @@ void ISelectionItemProvider.AddToSelection()
         /// </summary>
         void ISelectionItemProvider.RemoveFromSelection()
         {
-            TreeViewItemAutomationPeer wrapperPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is TreeViewItemAutomationPeer wrapperPeer)
             {
                 ISelectionItemProvider iSelectionItemProvider = wrapperPeer as ISelectionItemProvider;
                 iSelectionItemProvider.RemoveFromSelection();
@@ -264,8 +255,7 @@ IRawElementProviderSimple ISelectionItemProvider.SelectionContainer
 
         void IScrollItemProvider.ScrollIntoView()
         {
-            TreeViewItemAutomationPeer wrapperPeer = GetWrapperPeer() as TreeViewItemAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is TreeViewItemAutomationPeer wrapperPeer)
             {
                 IScrollItemProvider iScrollItemProvider = wrapperPeer as IScrollItemProvider;
                 iScrollItemProvider.ScrollIntoView();
@@ -305,14 +295,12 @@ private void RecursiveScrollIntoView()
 
             if (itemsControlAutomationPeer != null)
             {
-                TreeViewItemAutomationPeer treeViewItemAutomationPeer = itemsControlAutomationPeer as TreeViewItemAutomationPeer;
-                if (treeViewItemAutomationPeer != null && (treeViewItemAutomationPeer as IExpandCollapseProvider).ExpandCollapseState == ExpandCollapseState.Collapsed)
+                if (itemsControlAutomationPeer is TreeViewItemAutomationPeer treeViewItemAutomationPeer && (treeViewItemAutomationPeer as IExpandCollapseProvider).ExpandCollapseState == ExpandCollapseState.Collapsed)
                 {
                     (treeViewItemAutomationPeer as IExpandCollapseProvider).Expand();
                 }
 
-                ItemsControl parent = itemsControlAutomationPeer.Owner as ItemsControl;
-                if (parent != null)
+                if (itemsControlAutomationPeer.Owner is ItemsControl parent)
                 {
                     if (parent.ItemContainerGenerator.Status == GeneratorStatus.ContainersGenerated)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewItemAutomationPeer.cs
index a6d3b567..594777d1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Automation/Peers/TreeViewItemAutomationPeer.cs
@@ -66,8 +66,7 @@ protected override List<AutomationPeer> GetChildrenCore()
             ItemPeersStorage<ItemAutomationPeer> oldChildren = ItemPeers; //cache the old ones for possible reuse
             ItemPeers = new ItemPeersStorage<ItemAutomationPeer>();
 
-            TreeViewItem owner = Owner as TreeViewItem;
-            if (owner != null)
+            if (Owner is TreeViewItem owner)
             {
                 iterate(this, owner,
                     (IteratorCallback)delegate(AutomationPeer peer)
@@ -97,8 +96,7 @@ private static bool iterate(TreeViewItemAutomationPeer logicalParentAp, Dependen
                 {
                     DependencyObject child = VisualTreeHelper.GetChild(parent, i);
 
-                    if (child != null
-                        && child is UIElement)
+                    if (child is UIElement uIElement)
                     {
                         if (child is TreeViewItem)
                         {
@@ -139,7 +137,7 @@ private static bool iterate(TreeViewItemAutomationPeer logicalParentAp, Dependen
                         }
                         else
                         {
-                            peer = CreatePeerForElement((UIElement)child);
+                            peer = CreatePeerForElement(uIElement);
 
                             if (peer != null)
                                 done = callback(peer);
@@ -181,10 +179,7 @@ protected override internal ItemAutomationPeer FindOrCreateItemAutomationPeer(ob
             {
                 peer = CreateItemAutomationPeer(item);
 
-                if(peer != null)
-                {
-                    peer.TrySetParentInfo(parentPeer);
-                }
+                peer?.TrySetParentInfo(parentPeer);
             }
 
             if(peer != null)
@@ -221,8 +216,7 @@ internal override object GetSupportedPropertyValue(ItemAutomationPeer itemPeer,
         {
             if (SelectionItemPatternIdentifiers.IsSelectedProperty.Id == propertyId)
             {
-                ISelectionItemProvider selectionItem = itemPeer.GetPattern(PatternInterface.SelectionItem) as ISelectionItemProvider;
-                if (selectionItem != null)
+                if (itemPeer.GetPattern(PatternInterface.SelectionItem) is ISelectionItemProvider selectionItem)
                     return selectionItem.IsSelected;
                 else
                     return null;
@@ -240,8 +234,7 @@ override protected ItemAutomationPeer CreateItemAutomationPeer(object item)
         override internal IDisposable UpdateChildren()
         {
             // To ensure that the Updation of children should be initiated from DataPeer so as to have the right parent value stored for children
-            TreeViewDataItemAutomationPeer dataPeer = EventsSource as TreeViewDataItemAutomationPeer;
-            if(dataPeer != null)
+            if(EventsSource is TreeViewDataItemAutomationPeer dataPeer)
                 dataPeer.UpdateChildrenInternal(AutomationInteropProvider.ItemsInvalidateLimit);
             else
                 UpdateChildrenInternal(AutomationInteropProvider.ItemsInvalidateLimit);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ComponentResourceKey.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ComponentResourceKey.cs
index 41d82aa4..fdced530 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ComponentResourceKey.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ComponentResourceKey.cs
@@ -110,9 +110,7 @@ public object ResourceId
         /// <returns>True if the objects are equal. False otherwise.</returns>
         public override bool Equals(object o)
         {
-            ComponentResourceKey key = o as ComponentResourceKey;
-
-            if (key != null)
+            if (o is ComponentResourceKey key)
             {
                 return ((key._typeInTargetAssembly != null) ? key._typeInTargetAssembly.Equals(this._typeInTargetAssembly) : (this._typeInTargetAssembly == null)) &&
                     ((key._resourceId != null) ? key._resourceId.Equals(this._resourceId) : (this._resourceId == null));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Condition.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Condition.cs
index 73371a4c..1e33a968 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Condition.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Condition.cs
@@ -277,9 +277,7 @@ public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExte
             {
                 throw new ArgumentNullException(nameof(eventArgs));
             }
-
-            Condition condition = targetObject as Condition;
-            if (condition != null && eventArgs.Member.Name == "Binding" && eventArgs.MarkupExtension is BindingBase)
+            if (targetObject is Condition condition && eventArgs.Member.Name == "Binding" && eventArgs.MarkupExtension is BindingBase)
             {
                 condition.Binding = eventArgs.MarkupExtension as BindingBase;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AVElementHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AVElementHelper.cs
index 986b4912..23a2733e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AVElementHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AVElementHelper.cs
@@ -96,9 +96,7 @@ internal AVElementHelper(MediaElement element)
         /// </summary>
         internal static AVElementHelper GetHelper(DependencyObject d)
         {
-            MediaElement mediaElement = d as MediaElement;
-
-            if (mediaElement != null)
+            if (d is MediaElement mediaElement)
             {
                 return mediaElement.Helper;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AccessText.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AccessText.cs
index d4d56f4c..2ed48d11 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AccessText.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/AccessText.cs
@@ -450,8 +450,7 @@ protected sealed override Size ArrangeOverride(Size arrangeSize)
 
         internal static bool HasCustomSerialization(object o)
         {
-            Run accessKey = o as Run;
-            return accessKey != null && HasCustomSerializationStorage.GetValue(accessKey);
+            return o is Run accessKey && HasCustomSerializationStorage.GetValue(accessKey);
         }
 
         #endregion Internal methods
@@ -541,8 +540,7 @@ protected override Visual GetVisualChild(int index)
         // Provides custom serialization for this element
         internal static void SerializeCustom(XmlWriter xmlWriter, object o)
         {
-            Run inlineScope = o as Run;
-            if (inlineScope != null)
+            if (o is Run inlineScope)
             {
                 xmlWriter.WriteString(AccessKeyMarker + inlineScope.Text);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Calendar.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Calendar.cs
index e7b7e713..fc406188 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Calendar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Calendar.cs
@@ -1053,10 +1053,7 @@ internal void OnSelectedDatesCollectionChanged(SelectionChangedEventArgs e)
                     AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection))
                 {
                     CalendarAutomationPeer peer = FrameworkElementAutomationPeer.FromElement(this) as CalendarAutomationPeer;
-                    if (peer != null)
-                    {
-                        peer.RaiseSelectionEvents(e);
-                    }
+                    peer?.RaiseSelectionEvents(e);
                 }
 
                 CoerceFromSelection();
@@ -1216,10 +1213,7 @@ private void OnSelectedYearChanged(DateTime? selectedYear)
 
         internal void FocusDate(DateTime date)
         {
-            if (MonthControl != null)
-            {
-                MonthControl.FocusDate(date);
-            }
+            MonthControl?.FocusDate(date);
         }
 
         
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarBlackoutDatesCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarBlackoutDatesCollection.cs
index 0f6c3b40..8d3464f5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarBlackoutDatesCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarBlackoutDatesCollection.cs
@@ -283,8 +283,7 @@ private void UnRegisterItem(CalendarDateRange item)
         /// <param name="e"></param>
         private void Item_Changing(object sender, CalendarDateRangeChangingEventArgs e)
         {
-            CalendarDateRange item = sender as CalendarDateRange;
-            if (item != null)
+            if (sender is CalendarDateRange item)
             {
                 if (!IsValid(e.Start, e.End))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarSelectionChangedEventArgs.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarSelectionChangedEventArgs.cs
index 842c84a0..f49254e9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarSelectionChangedEventArgs.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CalendarSelectionChangedEventArgs.cs
@@ -30,8 +30,7 @@ internal class CalendarSelectionChangedEventArgs : SelectionChangedEventArgs
 
         protected override void InvokeEventHandler(Delegate genericHandler, object genericTarget)
         {
-            EventHandler<SelectionChangedEventArgs> handler = genericHandler as EventHandler<SelectionChangedEventArgs>;
-            if (handler != null)
+            if (genericHandler is EventHandler<SelectionChangedEventArgs> handler)
             {
                 handler(genericTarget, this);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Canvas.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Canvas.cs
index 5f64b580..bfd39360 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Canvas.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Canvas.cs
@@ -193,11 +193,9 @@ public static void SetBottom(UIElement element, double length)
         //because those flags only work for FrameworkElements
         private static void OnPositioningChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            UIElement uie = d as UIElement;
-            if(uie != null)
+            if(d is UIElement uie)
             {
-                Canvas p = VisualTreeHelper.GetParent(uie) as Canvas;
-                if(p != null)
+                if(VisualTreeHelper.GetParent(uie) is Canvas p)
                     p.InvalidateArrange();
             }
          }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBox.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBox.cs
index ad06fe9e..e2aee964 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBox.cs
@@ -223,10 +223,7 @@ private static void OnIsDropDownOpenChanged(DependencyObject d, DependencyProper
 
             // Fire accessibility event
             ComboBoxAutomationPeer peer = UIElementAutomationPeer.FromElement(comboBox) as ComboBoxAutomationPeer;
-            if(peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent(oldValue, newValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent(oldValue, newValue);
 
             if (newValue)
             {
@@ -581,8 +578,7 @@ protected override void OnSelectionChanged(SelectionChangedEventArgs e)
                 ||  AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementAddedToSelection)
                 ||  AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection)   )
             {
-                ComboBoxAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(this) as ComboBoxAutomationPeer;
-                if (peer != null)
+                if (UIElementAutomationPeer.CreatePeerForElement(this) is ComboBoxAutomationPeer peer)
                     peer.RaiseSelectionEvents(e);
             }
         }
@@ -624,10 +620,9 @@ private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedE
         {
             ComboBox cb = (ComboBox)d;
 
-            ComboBoxAutomationPeer peer = UIElementAutomationPeer.FromElement(cb) as ComboBoxAutomationPeer;
             // Raise the propetyChangeEvent for Value if Automation Peer exist, the new Value must
             // be the one in SelctionBoxItem(selected value is the one user will care about)
-            if (peer != null)
+            if (UIElementAutomationPeer.FromElement(cb) is ComboBoxAutomationPeer peer)
                 peer.RaiseValuePropertyChangedEvent((string)e.OldValue, (string)e.NewValue);
 
             cb.TextUpdated((string)e.NewValue, false);
@@ -733,8 +728,7 @@ private void TextUpdated(string newText, bool textBoxUpdated)
                                     // it doesn't get confused with the IME's undo stack.
                                     MS.Internal.Documents.UndoManager undoManager =
                                         EditableTextBoxSite.TextContainer.UndoManager;
-                                    if (undoManager != null &&
-                                        undoManager.OpenedUnit != null &&
+                                    if (undoManager?.OpenedUnit != null &&
                                         undoManager.OpenedUnit.GetType() != typeof(TextParentUndoUnit))
                                     {
                                         _updateTextBoxOperation = Dispatcher.BeginInvoke(DispatcherPriority.Normal,
@@ -874,11 +868,9 @@ private void UpdateSelectionBoxItem()
             DataTemplate itemTemplate = ItemTemplate;
             string stringFormat = ItemStringFormat;
 
-            // if Items contains an explicit ContentControl, use its content instead
-            // (this handles the case of ComboBoxItem)
-            ContentControl contentControl = item as ContentControl;
+            // if Items contains an explicit ContentControl, use its content instead            // (this handles the case of ComboBoxItem)
 
-            if (contentControl != null)
+            if (item is ContentControl contentControl)
             {
                 item = contentControl.Content;
                 itemTemplate = contentControl.ContentTemplate;
@@ -893,12 +885,9 @@ private void UpdateSelectionBoxItem()
 
             if (itemTemplate == null && ItemTemplateSelector == null && stringFormat == null)
             {
-                // if the item is a logical element it cannot be displayed directly in
-                // the selection box because it already belongs to the tree (in the dropdown box).
-                // Instead, try to extract some useful text from the visual.
-                DependencyObject logicalElement = item as DependencyObject;
+                // if the item is a logical element it cannot be displayed directly in                // the selection box because it already belongs to the tree (in the dropdown box).                // Instead, try to extract some useful text from the visual.
 
-                if (logicalElement != null)
+                if (item is DependencyObject logicalElement)
                 {
                     // If the item is a UIElement, create a copy using a visual brush
                     _clonedElement = logicalElement as UIElement;
@@ -1742,10 +1731,9 @@ private static void OnPreviewMouseButtonDown(object sender, MouseButtonEventArgs
 
             if (comboBox.IsEditable)
             {
-                Visual originalSource = e.OriginalSource as Visual;
                 Visual textBox = comboBox.EditableTextBoxSite;
 
-                if (originalSource != null && textBox != null
+                if (e.OriginalSource is Visual originalSource && textBox != null
                     && textBox.IsAncestorOf(originalSource))
                 {
                     if (comboBox.IsDropDownOpen && !comboBox.StaysOpenOnEdit)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBoxItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBoxItem.cs
index f9cb8c00..a2b89a8d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBoxItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ComboBoxItem.cs
@@ -108,10 +108,7 @@ protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e)
 
             ComboBox parent = ParentComboBox;
 
-            if (parent != null)
-            {
-                parent.NotifyComboBoxItemMouseDown(this);
-            }
+            parent?.NotifyComboBoxItemMouseDown(this);
 
             base.OnMouseLeftButtonDown(e);
         }
@@ -126,10 +123,7 @@ protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e)
 
             ComboBox parent = ParentComboBox;
 
-            if (parent != null)
-            {
-                parent.NotifyComboBoxItemMouseUp(this);
-            }
+            parent?.NotifyComboBoxItemMouseUp(this);
 
             base.OnMouseLeftButtonUp(e);
         }
@@ -144,10 +138,7 @@ protected override void OnMouseEnter(MouseEventArgs e)
 
             ComboBox parent = ParentComboBox;
 
-            if (parent != null)
-            {
-                parent.NotifyComboBoxItemEnter(this);
-            }
+            parent?.NotifyComboBoxItemEnter(this);
 
             base.OnMouseEnter(e);
         }
@@ -194,10 +185,7 @@ protected override void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e)
             
             ComboBox parent = ParentComboBox;
 
-            if (parent != null)
-            {
-                parent.NotifyComboBoxItemEnter(this);
-            }
+            parent?.NotifyComboBoxItemEnter(this);
 
             base.OnGotKeyboardFocus(e);
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContentControl.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContentControl.cs
index c34a1eb8..79c686a1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContentControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContentControl.cs
@@ -110,8 +110,7 @@ internal static string ContentObjectToString(object content)
         {
             if (content != null)
             {
-                FrameworkElement feContent = content as FrameworkElement;
-                if (feContent != null)
+                if (content is FrameworkElement feContent)
                 {
                     return feContent.GetPlainText();
                 }
@@ -276,8 +275,7 @@ protected virtual void OnContentChanged(object oldContent, object newContent)
             if (ContentIsNotLogical)
                 return;
 
-            DependencyObject d = newContent as DependencyObject;
-            if (d != null)
+            if (newContent is DependencyObject d)
             {
                 DependencyObject logicalParent = LogicalTreeHelper.GetParent(d);
                 if (logicalParent != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContextMenuService.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContextMenuService.cs
index 8bac47e3..36aac6f9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContextMenuService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ContextMenuService.cs
@@ -456,8 +456,7 @@ private static void OnContextMenuOpening(object sender, ContextMenuEventArgs e)
         {
             if (e.TargetElement == null)
             {
-                DependencyObject o = sender as DependencyObject;
-                if (o != null)
+                if (sender is DependencyObject o)
                 {
                     if (ContextMenuIsEnabled(o))
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Control.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Control.cs
index 65ccf6b4..c9a46b7e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Control.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Control.cs
@@ -683,10 +683,7 @@ internal static void OnVisualStatePropertyChanged(DependencyObject d, Dependency
             // Due to inherited properties, its safer not to cast to control because this might get fired for
             // non-controls.
             var control = d as Control;
-            if (control != null)
-            {
-                control.UpdateVisualState();
-            }
+            control?.UpdateVisualState();
         }
 
         /// <summary>
@@ -727,10 +724,7 @@ protected override Size ArrangeOverride(Size arrangeBounds)
             if (count>0)
             {
                 UIElement child = (UIElement)(this.GetVisualChild(0));
-                if (child != null)
-                {
-                    child.Arrange(new Rect(arrangeBounds));
-                }
+                child?.Arrange(new Rect(arrangeBounds));
             }
             return arrangeBounds;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CustomDictionarySources.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CustomDictionarySources.cs
index 9a03b512..e8c535f9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CustomDictionarySources.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/CustomDictionarySources.cs
@@ -102,10 +102,7 @@ void IList<Uri>.Insert(int index, Uri item)
             ValidateUri(item);
             _uriList.Insert(index, item);
             
-            if (Speller != null)
-            {
-                Speller.OnDictionaryUriAdded(item);
-            }
+            Speller?.OnDictionaryUriAdded(item);
         }
 
         void IList<Uri>.RemoveAt(int index)
@@ -113,10 +110,7 @@ void IList<Uri>.RemoveAt(int index)
             Uri uri = _uriList[index];
             _uriList.RemoveAt(index);
             
-            if (Speller != null)
-            {
-                Speller.OnDictionaryUriRemoved(uri);
-            }
+            Speller?.OnDictionaryUriRemoved(uri);
         }
 
         /// <summary>
@@ -165,19 +159,13 @@ void ICollection<Uri>.Add(Uri item)
                 _uriList.Add(item);
             }
 
-            if (Speller != null)
-            {
-                Speller.OnDictionaryUriAdded(item);
-            }
+            Speller?.OnDictionaryUriAdded(item);
         }
 
         void ICollection<Uri>.Clear()
         {
             _uriList.Clear();
-            if (Speller != null)
-            {
-                Speller.OnDictionaryUriCollectionCleared();
-            }
+            Speller?.OnDictionaryUriCollectionCleared();
         }
 
         bool ICollection<Uri>.Contains(Uri item)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGrid.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGrid.cs
index 08f5e11b..618706d4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGrid.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGrid.cs
@@ -620,10 +620,7 @@ internal void NotifyPropertyChanged(DependencyObject d, string propertyName, Dep
                         if (row != null)
                         {
                             var cellsPresenter = row.CellsPresenter;
-                            if (cellsPresenter != null)
-                            {
-                                cellsPresenter.InvalidateDataGridCellsPanelMeasureAndArrange();
-                            }
+                            cellsPresenter?.InvalidateDataGridCellsPanelMeasureAndArrange();
                         }
                     }
                 }
@@ -1163,10 +1160,7 @@ internal static object DelayedOnLoadingRowDetails(object arg)
             var row = (DataGridRow)arg;
             var dataGrid = row.DataGridOwner;
 
-            if (dataGrid != null)
-            {
-                dataGrid.OnLoadingRowDetailsWrapper(row);
-            }
+            dataGrid?.OnLoadingRowDetailsWrapper(row);
 
             return null;
         }
@@ -1350,10 +1344,7 @@ public void ClearDetailsVisibilityForItem(object item)
             _itemAttachedStorage.ClearValue(item, DataGridRow.DetailsVisibilityProperty);
 
             var row = (DataGridRow)ItemContainerGenerator.ContainerFromItem(item);
-            if (row != null)
-            {
-                row.ClearValue(DataGridRow.DetailsVisibilityProperty);
-            }
+            row?.ClearValue(DataGridRow.DetailsVisibilityProperty);
         }
 
         internal DataGridItemAttachedStorage ItemAttachedStorage
@@ -2262,10 +2253,7 @@ protected virtual void OnExecutedBeginEdit(ExecutedRoutedEventArgs e)
                         EditRowItem(cell.RowDataItem);
 
                         var bindingGroup = cell.RowOwner.BindingGroup;
-                        if (bindingGroup != null)
-                        {
-                            bindingGroup.BeginEdit();
-                        }
+                        bindingGroup?.BeginEdit();
 
                         _editingRowInfo = ItemInfoFromContainer(cell.RowOwner);
                     }
@@ -2455,10 +2443,7 @@ protected virtual void OnRowEditEnding(DataGridRowEditEndingEventArgs e)
             if (AutomationPeer.ListenerExists(AutomationEvents.InvokePatternOnInvoked))
             {
                 DataGridAutomationPeer peer = DataGridAutomationPeer.FromElement(this) as DataGridAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseAutomationRowInvokeEvents(e.Row);
-                }
+                peer?.RaiseAutomationRowInvokeEvents(e.Row);
             }
         }
 
@@ -2482,10 +2467,7 @@ protected virtual void OnCellEditEnding(DataGridCellEditEndingEventArgs e)
             if (AutomationPeer.ListenerExists(AutomationEvents.InvokePatternOnInvoked))
             {
                 DataGridAutomationPeer peer = DataGridAutomationPeer.FromElement(this) as DataGridAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseAutomationCellInvokeEvents(e.Column, e.Row);
-                }
+                peer?.RaiseAutomationCellInvokeEvents(e.Column, e.Row);
             }
         }
 
@@ -2552,10 +2534,7 @@ protected virtual void OnExecutedCancelEdit(ExecutedRoutedEventArgs e)
                     if (cancelAllowed)
                     {
                         var bindingGroup = cell.RowOwner.BindingGroup;
-                        if (bindingGroup != null)
-                        {
-                            bindingGroup.CancelEdit();
-                        }
+                        bindingGroup?.CancelEdit();
 
                         CancelRowItem();
                     }
@@ -2954,18 +2933,12 @@ private static void OnCurrentCellChanged(DependencyObject d, DependencyPropertyC
 
                     if (oldCellContainer != cell)
                     {
-                        if (oldCellContainer != null)
-                        {
-                            oldCellContainer.NotifyCurrentCellContainerChanged();
-                        }
+                        oldCellContainer?.NotifyCurrentCellContainerChanged();
 
                         cell.NotifyCurrentCellContainerChanged();
                     }
                 }
-                else if  (oldCellContainer != null)
-                {
-                    oldCellContainer.NotifyCurrentCellContainerChanged();
-                }
+                else oldCellContainer?.NotifyCurrentCellContainerChanged();
             }
 
             dataGrid.OnCurrentCellChanged(EventArgs.Empty);
@@ -3127,10 +3100,7 @@ protected virtual void OnBeginningEdit(DataGridBeginningEditEventArgs e)
             if (AutomationPeer.ListenerExists(AutomationEvents.InvokePatternOnInvoked))
             {
                 DataGridAutomationPeer peer = DataGridAutomationPeer.FromElement(this) as DataGridAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseAutomationCellInvokeEvents(e.Column, e.Row);
-                }
+                peer?.RaiseAutomationCellInvokeEvents(e.Column, e.Row);
             }
         }
 
@@ -3812,10 +3782,7 @@ private void UpdateNewItemPlaceholder(bool isAddingNewItem)
 
             // Make sure the newItemPlaceholderRow reflects the correct visiblity
             DataGridRow newItemPlaceholderRow = (DataGridRow)ItemContainerGenerator.ContainerFromItem(CollectionView.NewItemPlaceholder);
-            if (newItemPlaceholderRow != null)
-            {
-                newItemPlaceholderRow.CoerceValue(VisibilityProperty);
-            }
+            newItemPlaceholderRow?.CoerceValue(VisibilityProperty);
         }
 
         private void SetCurrentItemToPlaceholder()
@@ -4314,10 +4281,7 @@ protected virtual void OnSelectedCellsChanged(SelectedCellsChangedEventArgs e)
                 AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection))
             {
                 DataGridAutomationPeer peer = DataGridAutomationPeer.FromElement(this) as DataGridAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseAutomationCellSelectedEvent(e);
-                }
+                peer?.RaiseAutomationCellSelectedEvent(e);
             }
         }
 
@@ -4567,10 +4531,7 @@ protected override void OnSelectionChanged(SelectionChangedEventArgs e)
                 AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection))
             {
                 DataGridAutomationPeer peer = DataGridAutomationPeer.FromElement(this) as DataGridAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseAutomationSelectionEvents(e);
-                }
+                peer?.RaiseAutomationSelectionEvents(e);
             }
 
             base.OnSelectionChanged(e);
@@ -4653,10 +4614,7 @@ private void UpdateIsSelected(VirtualizedCellInfoCollection cells, bool isSelect
                         foreach (DataGridCellInfo cellInfo in cells)
                         {
                             DataGridCell cell = TryFindCell(cellInfo);
-                            if (cell != null)
-                            {
-                                cell.SyncIsSelected(isSelected);
-                            }
+                            cell?.SyncIsSelected(isSelected);
                         }
                     }
                 }
@@ -4965,10 +4923,7 @@ private void MakeFullRowSelection(ItemInfo info, bool allowsExtendSelect, bool a
                                 }
 
                                 IDisposable d = enumerator as IDisposable;
-                                if (d != null)
-                                {
-                                    d.Dispose();
-                                }
+                                d?.Dispose();
 
                                 _selectedCells.AddRegion(startIndex, 0, endIndex - startIndex + 1, _columns.Count);
                             }
@@ -6019,10 +5974,7 @@ private void OnEnterKeyDown(KeyEventArgs e)
                             // When the new item jumped to the bottom, CurrentCell doesn't actually change,
                             // but there is a new container.
                             currentCellContainer = CurrentCellContainer;
-                            if (currentCellContainer != null)
-                            {
-                                currentCellContainer.Focus();
-                            }
+                            currentCellContainer?.Focus();
                         }
                     }
                 }
@@ -6237,10 +6189,7 @@ private void OnPageUpOrDownKeyDown(KeyEventArgs e)
                             }
                         }
                     }
-                    else if (targetElement != null)
-                    {
-                        targetElement.Focus();
-                    }
+                    else targetElement?.Focus();
                 }
             }
         }
@@ -6894,10 +6843,7 @@ public void TrackValue()
                             if (dataGridItemAutomationPeer != null)
                             {
                                 DataGridCellItemAutomationPeer cellPeer = dataGridItemAutomationPeer.GetOrCreateCellItemPeer(column);
-                                if (cellPeer != null)
-                                {
-                                    cellPeer.RaisePropertyChangedEvent(ValuePatternIdentifiers.ValueProperty, _value, newValue);
-                                }
+                                cellPeer?.RaisePropertyChangedEvent(ValuePatternIdentifiers.ValueProperty, _value, newValue);
                             }
                         }
                     }
@@ -7595,10 +7541,7 @@ private void ClearSortDescriptionsOnItemsSourceChange()
             Items.SortDescriptions.Clear();
             _sortingStarted = false;
             List<int> groupingSortDescriptionIndices = GroupingSortDescriptionIndices;
-            if (groupingSortDescriptionIndices != null)
-            {
-                groupingSortDescriptionIndices.Clear();
-            }
+            groupingSortDescriptionIndices?.Clear();
             foreach (DataGridColumn column in Columns)
             {
                 column.SortDirection = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridBoundColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridBoundColumn.cs
index a0e7a83a..cc4f69ee 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridBoundColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridBoundColumn.cs
@@ -211,8 +211,7 @@ public override BindingBase ClipboardContentBinding
         /// <param name="propertyName"></param>
         protected internal override void RefreshCellContent(FrameworkElement element, string propertyName)
         {
-            DataGridCell cell = element as DataGridCell;
-            if (cell != null)
+            if (element is DataGridCell cell)
             {
                 bool isCellEditing = cell.IsEditing;
                 if ((string.Compare(propertyName, "Binding", StringComparison.Ordinal) == 0) ||
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCell.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCell.cs
index 6358bf00..6f1d2d90 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCell.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCell.cs
@@ -179,10 +179,7 @@ public DataGridColumn Column
         private static void OnColumnChanged(object sender, DependencyPropertyChangedEventArgs e)
         {
             DataGridCell cell = sender as DataGridCell;
-            if (cell != null)
-            {
-                cell.OnColumnChanged((DataGridColumn)e.OldValue, (DataGridColumn)e.NewValue);
-            }
+            cell?.OnColumnChanged((DataGridColumn)e.OldValue, (DataGridColumn)e.NewValue);
         }
 
         /// <summary>
@@ -580,11 +577,7 @@ internal void BeginEdit(RoutedEventArgs e)
             IsEditing = true;
 
             DataGridColumn column = Column;
-            if (column != null)
-            {
-                // Ask the column to store the original value
-                column.BeginEdit(Content as FrameworkElement, e);
-            }
+            column?.BeginEdit(Content as FrameworkElement, e);
 
             RaisePreparingCellForEdit(e);
         }
@@ -594,11 +587,7 @@ internal void CancelEdit()
             Debug.Assert(IsEditing, "Should not call CancelEdit when IsEditing is false.");
 
             DataGridColumn column = Column;
-            if (column != null)
-            {
-                // Ask the column to restore the original value
-                column.CancelEdit(Content as FrameworkElement);
-            }
+            column?.CancelEdit(Content as FrameworkElement);
 
             IsEditing = false;
         }
@@ -672,13 +661,7 @@ private static void OnIsSelectedChanged(object sender, DependencyPropertyChanged
             if (!cell._syncingIsSelected)
             {
                 DataGrid dataGrid = cell.DataGridOwner;
-                if (dataGrid != null)
-                {
-                    // Notify the DataGrid that a cell's IsSelected property changed
-                    // in case it was done programmatically instead of by the
-                    // DataGrid itself.
-                    dataGrid.CellIsSelectedChanged(cell, isSelected);
-                }
+                dataGrid?.CellIsSelectedChanged(cell, isSelected);
             }
 
             cell.RaiseSelectionChangedEvent(isSelected);
@@ -930,11 +913,7 @@ private void OnAnyMouseLeftButtonDown(MouseButtonEventArgs e)
                 }
 
                 DataGrid dataGridOwner = DataGridOwner;
-                if (dataGridOwner != null)
-                {
-                    // Let the DataGrid process selection
-                    dataGridOwner.HandleSelectionForCellInput(this, /* startDragging = */ Mouse.Captured == null, /* allowsExtendSelect = */ true, /* allowsMinimalSelect = */ true);
-                }
+                dataGridOwner?.HandleSelectionForCellInput(this, /* startDragging = */ Mouse.Captured == null, /* allowsExtendSelect = */ true, /* allowsMinimalSelect = */ true);
 
                 e.Handled = true;
             }
@@ -992,10 +971,7 @@ protected override void OnMouseUp(MouseButtonEventArgs e)
         private void SendInputToColumn(InputEventArgs e)
         {
             var column = Column;
-            if (column != null)
-            {
-                column.OnInput(e);
-            }
+            column?.OnInput(e);
         }
 
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellInfo.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellInfo.cs
index 4a971c53..83defd22 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellInfo.cs
@@ -158,9 +158,9 @@ public DataGridColumn Column
         /// </summary>
         public override bool Equals(object obj)
         {
-            if (obj is DataGridCellInfo)
+            if (obj is DataGridCellInfo dataGridCellInfo)
             {
-                return EqualsImpl((DataGridCellInfo)obj);
+                return EqualsImpl(dataGridCellInfo);
             }
 
             return false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellsPanel.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellsPanel.cs
index 521845cd..3e62009a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellsPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCellsPanel.cs
@@ -1320,10 +1320,7 @@ private void FinishArrange(ArrangeState arrangeState)
 
             // Add the clip on new child to be clipped for the sake of frozen columns.
             _clippedChildForFrozenBehaviour = arrangeState.NewClippedChild;
-            if (_clippedChildForFrozenBehaviour != null)
-            {
-                _clippedChildForFrozenBehaviour.CoerceValue(ClipProperty);
-            }
+            _clippedChildForFrozenBehaviour?.CoerceValue(ClipProperty);
         }
 
         private void SetDataGridCellPanelWidth(IList children, double newWidth)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCheckBoxColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCheckBoxColumn.cs
index 7b6bedfe..a826a132 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCheckBoxColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridCheckBoxColumn.cs
@@ -111,12 +111,10 @@ private CheckBox GenerateCheckBox(bool isEditing, DataGridCell cell)
 
         protected internal override void RefreshCellContent(FrameworkElement element, string propertyName)
         {
-            DataGridCell cell = element as DataGridCell;
-            if (cell != null &&
+            if (element is DataGridCell cell &&
                 string.Compare(propertyName, "IsThreeState", StringComparison.Ordinal) == 0)
             {
-                var checkBox = cell.Content as CheckBox;
-                if (checkBox != null)
+                if (cell.Content is CheckBox checkBox)
                 {
                     checkBox.IsThreeState = IsThreeState;
                 }
@@ -159,8 +157,7 @@ public bool IsThreeState
         /// <returns>The unedited value of the cell.</returns>
         protected override object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs)
         {
-            CheckBox checkBox = editingElement as CheckBox;
-            if (checkBox != null)
+            if (editingElement is CheckBox checkBox)
             {
                 checkBox.Focus();
                 bool? uneditedValue = checkBox.IsChecked;
@@ -189,8 +186,7 @@ internal override void OnInput(InputEventArgs e)
 
         private static bool IsMouseLeftButtonDown(RoutedEventArgs e)
         {
-            MouseButtonEventArgs mouseArgs = e as MouseButtonEventArgs;
-            return (mouseArgs != null) &&
+            return (e is MouseButtonEventArgs mouseArgs) &&
                    (mouseArgs.ChangedButton == MouseButton.Left) &&
                    (mouseArgs.ButtonState == MouseButtonState.Pressed);
         }
@@ -204,8 +200,7 @@ private static bool IsMouseOver(CheckBox checkBox, RoutedEventArgs e)
 
         private static bool IsSpaceKeyDown(RoutedEventArgs e)
         {
-            KeyEventArgs keyArgs = e as KeyEventArgs;
-            return (keyArgs != null) &&
+            return (e is KeyEventArgs keyArgs) &&
                     keyArgs.RoutedEvent == Keyboard.KeyDownEvent && 
                    ((keyArgs.KeyStates & KeyStates.Down) == KeyStates.Down) &&
                    (keyArgs.Key == Key.Space);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridClipboardCellContent.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridClipboardCellContent.cs
index 825ddbf2..4f2602aa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridClipboardCellContent.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridClipboardCellContent.cs
@@ -59,9 +59,9 @@ public object Content
         public override bool Equals(object data)
         {
             DataGridClipboardCellContent clipboardCellContent;
-            if (data is DataGridClipboardCellContent)
+            if (data is DataGridClipboardCellContent dataGridClipboardCellContent)
             {
-                clipboardCellContent = (DataGridClipboardCellContent)data;
+                clipboardCellContent = dataGridClipboardCellContent;
                             
                 return 
                     (_column == clipboardCellContent._column) &&
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumn.cs
index bb773912..f76426ca 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumn.cs
@@ -879,10 +879,7 @@ internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChange
                 // to the targets that need notification.
                 DataGridColumn column = (DataGridColumn)d;
                 DataGrid dataGridOwner = column.DataGridOwner;
-                if (dataGridOwner != null)
-                {
-                    dataGridOwner.NotifyPropertyChanged(d, e, target);
-                }
+                dataGridOwner?.NotifyPropertyChanged(d, e, target);
             }
         }
 
@@ -892,10 +889,7 @@ internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChange
         /// <param name="propertyName"></param>
         protected void NotifyPropertyChanged(string propertyName)
         {
-            if (DataGridOwner != null)
-            {
-                DataGridOwner.NotifyPropertyChanged(this, propertyName, new DependencyPropertyChangedEventArgs(), DataGridNotificationTarget.RefreshCellContent);
-            }
+            DataGridOwner?.NotifyPropertyChanged(this, propertyName, new DependencyPropertyChangedEventArgs(), DataGridNotificationTarget.RefreshCellContent);
         }
 
         /// <summary>
@@ -1160,7 +1154,7 @@ public bool IsAutoGenerated
         /// <returns></returns>
         internal static DataGridColumn CreateDefaultColumn(ItemPropertyInfo itemProperty)
         {
-            Debug.Assert(itemProperty != null && itemProperty.PropertyType != null, "itemProperty and/or its PropertyType member cannot be null");
+            Debug.Assert(itemProperty?.PropertyType != null, "itemProperty and/or its PropertyType member cannot be null");
 
             DataGridColumn dataGridColumn = null;
             DataGridComboBoxColumn comboBoxColumn = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnCollection.cs
index 29576126..4d4ded45 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnCollection.cs
@@ -1057,10 +1057,7 @@ internal void InvalidateAverageColumnWidth()
             // size of the row presenter
             VirtualizingStackPanel vsp = (DataGridOwner == null) ? null :
                     DataGridOwner.InternalItemsHost as VirtualizingStackPanel;
-            if (vsp != null)
-            {
-                vsp.ResetMaximumDesiredSize();
-            }
+            vsp?.ResetMaximumDesiredSize();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnFloatingHeader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnFloatingHeader.cs
index 52cd3d84..b6667456 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnFloatingHeader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnFloatingHeader.cs
@@ -45,8 +45,7 @@ private static void OnWidthChanged(DependencyObject d, DependencyPropertyChanged
             double width = (double)e.NewValue;
             if (header._visualBrushCanvas != null && !DoubleUtil.IsNaN(width))
             {
-                VisualBrush brush = header._visualBrushCanvas.Background as VisualBrush;
-                if (brush != null)
+                if (header._visualBrushCanvas.Background is VisualBrush brush)
                 {
                     Rect viewBox = brush.Viewbox;
                     brush.Viewbox = new Rect(viewBox.X, viewBox.Y, width - header.GetVisualCanvasMarginX(), viewBox.Height);
@@ -72,8 +71,7 @@ private static void OnHeightChanged(DependencyObject d, DependencyPropertyChange
             double height = (double)e.NewValue;
             if (header._visualBrushCanvas != null && !DoubleUtil.IsNaN(height))
             {
-                VisualBrush brush = header._visualBrushCanvas.Background as VisualBrush;
-                if (brush != null)
+                if (header._visualBrushCanvas.Background is VisualBrush brush)
                 {
                     Rect viewBox = brush.Viewbox;
                     brush.Viewbox = new Rect(viewBox.X, viewBox.Y, viewBox.Width, height - header.GetVisualCanvasMarginY());
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnHeaderCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnHeaderCollection.cs
index a613b338..1d9ef13a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnHeaderCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridColumnHeaderCollection.cs
@@ -249,9 +249,7 @@ private static object[] HeadersFromColumns(IList columns)
 
             for (int i = 0; i < columns.Count; i++)
             {
-                DataGridColumn column = columns[i] as DataGridColumn;
-
-                if (column != null)
+                if (columns[i] is DataGridColumn column)
                 {
                     headers[i] = column.Header;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridComboBoxColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridComboBoxColumn.cs
index db498105..e324e73f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridComboBoxColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridComboBoxColumn.cs
@@ -410,8 +410,7 @@ public string SelectedValuePath
 
         protected internal override void RefreshCellContent(FrameworkElement element, string propertyName)
         {
-            DataGridCell cell = element as DataGridCell;
-            if (cell != null)
+            if (element is DataGridCell cell)
             {
                 bool isCellEditing = cell.IsEditing;
                 if ((string.Compare(propertyName, "ElementStyle", StringComparison.Ordinal) == 0 && !isCellEditing) ||
@@ -537,8 +536,7 @@ private void ApplyColumnProperties(ComboBox comboBox)
         /// <returns>The unedited value of the cell.</returns>
         protected override object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs)
         {
-            ComboBox comboBox = editingElement as ComboBox;
-            if (comboBox != null)
+            if (editingElement is ComboBox comboBox)
             {
                 comboBox.Focus();
                 object originalValue = GetComboBoxSelectionValue(comboBox);
@@ -563,7 +561,7 @@ protected override object PrepareCellForEdit(FrameworkElement editingElement, Ro
         protected override void CancelCellEdit(FrameworkElement editingElement, object uneditedValue)
         {
             ComboBox cb = editingElement as ComboBox;
-            if (cb != null && cb.EditableTextBoxSite != null)
+            if (cb?.EditableTextBoxSite != null)
             {
                 DataGridHelper.CacheFlowDirection(cb.EditableTextBoxSite, cb.Parent as DataGridCell);
                 DataGridHelper.CacheFlowDirection(cb, cb.Parent as DataGridCell);
@@ -580,7 +578,7 @@ protected override void CancelCellEdit(FrameworkElement editingElement, object u
         protected override bool CommitCellEdit(FrameworkElement editingElement)
         {
             ComboBox cb = editingElement as ComboBox;
-            if (cb != null && cb.EditableTextBoxSite != null)
+            if (cb?.EditableTextBoxSite != null)
             {
                 DataGridHelper.CacheFlowDirection(cb.EditableTextBoxSite, cb.Parent as DataGridCell);
                 DataGridHelper.CacheFlowDirection(cb, cb.Parent as DataGridCell);
@@ -599,8 +597,7 @@ internal override void OnInput(InputEventArgs e)
 
         private static bool IsComboBoxOpeningInputEvent(RoutedEventArgs e)
         {
-            KeyEventArgs keyArgs = e as KeyEventArgs;
-            if ((keyArgs != null) && keyArgs.RoutedEvent == Keyboard.KeyDownEvent && ((keyArgs.KeyStates & KeyStates.Down) == KeyStates.Down))
+            if ((e is KeyEventArgs keyArgs) && keyArgs.RoutedEvent == Keyboard.KeyDownEvent && ((keyArgs.KeyStates & KeyStates.Down) == KeyStates.Down))
             {
                 bool isAltDown = (keyArgs.KeyboardDevice.Modifiers & ModifierKeys.Alt) == ModifierKeys.Alt;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHelper.cs
index 6f2763e5..37a222cc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHelper.cs
@@ -159,8 +159,7 @@ private static bool TestTarget(DataGridNotificationTarget target, DataGridNotifi
 
             while (parent != null)
             {
-                T correctlyTyped = parent as T;
-                if (correctlyTyped != null)
+                if (parent is T correctlyTyped)
                 {
                     return correctlyTyped;
                 }
@@ -176,8 +175,7 @@ private static bool TestTarget(DataGridNotificationTarget target, DataGridNotifi
             UIElement parent = element;
             while (parent != null)
             {
-                T correctlyTyped = parent as T;
-                if (correctlyTyped != null)
+                if (parent is T correctlyTyped)
                 {
                     return correctlyTyped;
                 }
@@ -199,8 +197,7 @@ public static bool TreeHasFocusAndTabStop(DependencyObject element)
                 return false;
             }
 
-            UIElement uielement = element as UIElement;
-            if (uielement != null)
+            if (element is UIElement uielement)
             {
                 if (uielement.Focusable && KeyboardNavigation.GetIsTabStop(uielement))
                 {
@@ -209,8 +206,7 @@ public static bool TreeHasFocusAndTabStop(DependencyObject element)
             }
             else
             {
-                ContentElement contentElement = element as ContentElement;
-                if (contentElement != null && contentElement.Focusable && KeyboardNavigation.GetIsTabStop(contentElement))
+                if (element is ContentElement contentElement && contentElement.Focusable && KeyboardNavigation.GetIsTabStop(contentElement))
                 {
                     return true;
                 }
@@ -484,22 +480,19 @@ internal static bool IsOneWay(BindingBase bindingBase)
             }
 
             // If it is a standard Binding, then check if it's Mode is OneWay
-            Binding binding = bindingBase as Binding;
-            if (binding != null)
+            if (bindingBase is Binding binding)
             {
                 return binding.Mode == BindingMode.OneWay;
             }
 
             // A multi-binding can be OneWay as well
-            MultiBinding multiBinding = bindingBase as MultiBinding;
-            if (multiBinding != null)
+            if (bindingBase is MultiBinding multiBinding)
             {
                 return multiBinding.Mode == BindingMode.OneWay;
             }
 
             // A priority binding is a list of bindings, if any are OneWay, we'll call it OneWay
-            PriorityBinding priBinding = bindingBase as PriorityBinding;
-            if (priBinding != null)
+            if (bindingBase is PriorityBinding priBinding)
             {
                 Collection<BindingBase> subBindings = priBinding.Bindings;
                 int count = subBindings.Count;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHyperlinkColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHyperlinkColumn.cs
index f0ef78d9..01da8264 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHyperlinkColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridHyperlinkColumn.cs
@@ -112,8 +112,7 @@ private void ApplyContentBinding(DependencyObject target, DependencyProperty pro
         /// <param name="propertyName"></param>
         protected internal override void RefreshCellContent(FrameworkElement element, string propertyName)
         {
-            DataGridCell cell = element as DataGridCell;
-            if (cell != null && !cell.IsEditing)
+            if (element is DataGridCell cell && !cell.IsEditing)
             {
                 if (string.Compare(propertyName, "ContentBinding", StringComparison.Ordinal) == 0)
                 {
@@ -121,11 +120,9 @@ protected internal override void RefreshCellContent(FrameworkElement element, st
                 }
                 else if (string.Compare(propertyName, "TargetName", StringComparison.Ordinal) == 0)
                 {
-                    TextBlock outerBlock = cell.Content as TextBlock;
-                    if (outerBlock != null && outerBlock.Inlines.Count > 0)
+                    if (cell.Content is TextBlock outerBlock && outerBlock.Inlines.Count > 0)
                     {
-                        Hyperlink link = outerBlock.Inlines.FirstInline as Hyperlink;
-                        if (link != null)
+                        if (outerBlock.Inlines.FirstInline is Hyperlink link)
                         {
                             link.TargetName = TargetName;
                         }
@@ -216,15 +213,13 @@ protected override FrameworkElement GenerateEditingElement(DataGridCell cell, ob
         /// <returns>The unedited value of the cell.</returns>
         protected override object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs)
         {
-            TextBox textBox = editingElement as TextBox;
-            if (textBox != null)
+            if (editingElement is TextBox textBox)
             {
                 textBox.Focus();
 
                 string originalValue = textBox.Text;
 
-                TextCompositionEventArgs textArgs = editingEventArgs as TextCompositionEventArgs;
-                if (textArgs != null)
+                if (editingEventArgs is TextCompositionEventArgs textArgs)
                 {
                     // If text input started the edit, then replace the text with what was typed.
                     string inputText = textArgs.Text;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLength.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLength.cs
index 22b188a2..92c280cd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLength.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLength.cs
@@ -157,9 +157,8 @@ public DataGridLength(double value, DataGridLengthUnitType type, double desiredV
         /// and unit type as oCompare.</returns>
         public override bool Equals(object obj)
         {
-            if (obj is DataGridLength)
+            if (obj is DataGridLength l)
             {
-                DataGridLength l = (DataGridLength)obj;
                 return this == l;
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLengthConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLengthConverter.cs
index e19e6b4c..e240b975 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLengthConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridLengthConverter.cs
@@ -73,8 +73,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
         {
             if (value != null)
             {
-                string stringSource = value as string;
-                if (stringSource != null)
+                if (value is string stringSource)
                 {
                     // Convert from string
                     return ConvertFromString(stringSource, culture);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridRow.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridRow.cs
index 1835b8f2..de7ad70a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridRow.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridRow.cs
@@ -601,10 +601,7 @@ internal void OnRowResizeReset()
         protected internal virtual void OnColumnsChanged(ObservableCollection<DataGridColumn> columns, NotifyCollectionChangedEventArgs e)
         {
             DataGridCellsPresenter cellsPresenter = CellsPresenter;
-            if (cellsPresenter != null)
-            {
-                cellsPresenter.OnColumnsChanged(columns, e);
-            }
+            cellsPresenter?.OnColumnsChanged(columns, e);
         }
 
         #endregion
@@ -717,9 +714,8 @@ private static object OnCoerceDetailsVisibility(DependencyObject d, object baseV
                 row.DataGridOwner,
                 DataGrid.RowDetailsVisibilityModeProperty);
 
-            if (visibility is DataGridRowDetailsVisibilityMode)
+            if (visibility is DataGridRowDetailsVisibilityMode visibilityMode)
             {
-                var visibilityMode = (DataGridRowDetailsVisibilityMode)visibility;
                 var hasDetailsTemplate = row.DetailsTemplate != null || row.DetailsTemplateSelector != null;
                 var isRealItem = row.Item != CollectionView.NewItemPlaceholder;
                 switch (visibilityMode)
@@ -937,10 +933,7 @@ internal void NotifyPropertyChanged(DependencyObject d, string propertyName, Dep
 
             if (DataGridHelper.ShouldNotifyDetailsPresenter(target))
             {
-                if (DetailsPresenter != null)
-                {
-                    DetailsPresenter.NotifyPropertyChanged(d, e);
-                }
+                DetailsPresenter?.NotifyPropertyChanged(d, e);
             }
 
             if (DataGridHelper.ShouldNotifyCellsPresenter(target) ||
@@ -948,10 +941,7 @@ internal void NotifyPropertyChanged(DependencyObject d, string propertyName, Dep
                 DataGridHelper.ShouldRefreshCellContent(target))
             {
                 DataGridCellsPresenter cellsPresenter = CellsPresenter;
-                if (cellsPresenter != null)
-                {
-                    cellsPresenter.NotifyPropertyChanged(d, propertyName, e, target);
-                }
+                cellsPresenter?.NotifyPropertyChanged(d, propertyName, e, target);
             }
 
             if (DataGridHelper.ShouldNotifyRowHeaders(target) && RowHeader != null)
@@ -1014,15 +1004,9 @@ private void SyncProperties(bool forcePrepareCells)
                 RestoreAttachedItemValue(cellsPresenter, DataGridCellsPresenter.HeightProperty);
             }
 
-            if (DetailsPresenter != null)
-            {
-                DetailsPresenter.SyncProperties();
-            }
+            DetailsPresenter?.SyncProperties();
 
-            if (RowHeader != null)
-            {
-                RowHeader.SyncProperties();
-            }
+            RowHeader?.SyncProperties();
         }
 
         #endregion
@@ -1090,17 +1074,10 @@ private static void OnIsSelectedChanged(object sender, DependencyPropertyChanged
             DataGrid grid = row.DataGridOwner;
             if (grid != null && row.DataContext != null)
             {
-                DataGridAutomationPeer gridPeer = UIElementAutomationPeer.FromElement(grid) as DataGridAutomationPeer;
-                if (gridPeer != null)
+                if (UIElementAutomationPeer.FromElement(grid) is DataGridAutomationPeer gridPeer)
                 {
                     DataGridItemAutomationPeer rowItemPeer = gridPeer.FindOrCreateItemAutomationPeer(row.DataContext) as DataGridItemAutomationPeer;
-                    if (rowItemPeer != null)
-                    {
-                        rowItemPeer.RaisePropertyChangedEvent(
-                            System.Windows.Automation.SelectionItemPatternIdentifiers.IsSelectedProperty,
-                            (bool)e.OldValue,
-                            isSelected);
-                    }
+                    rowItemPeer?.RaisePropertyChangedEvent(System.Windows.Automation.SelectionItemPatternIdentifiers.IsSelectedProperty, (bool)e.OldValue, isSelected);
                 }
             }
 
@@ -1250,10 +1227,7 @@ protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutoma
         internal void ScrollCellIntoView(int index)
         {
             DataGridCellsPresenter cellsPresenter = CellsPresenter;
-            if (cellsPresenter != null)
-            {
-                cellsPresenter.ScrollCellIntoView(index);
-            }
+            cellsPresenter?.ScrollCellIntoView(index);
         }
 
         #endregion
@@ -1266,10 +1240,7 @@ internal void ScrollCellIntoView(int index)
         protected override Size ArrangeOverride(Size arrangeBounds)
         {
             DataGrid dataGrid = DataGridOwner;
-            if (dataGrid != null)
-            {
-                dataGrid.QueueInvalidateCellsPanelHorizontalOffset();
-            }
+            dataGrid?.QueueInvalidateCellsPanelHorizontalOffset();
 
             return base.ArrangeOverride(arrangeBounds);
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTemplateColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTemplateColumn.cs
index ad747964..92123d79 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTemplateColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTemplateColumn.cs
@@ -206,8 +206,7 @@ protected override FrameworkElement GenerateEditingElement(DataGridCell cell, ob
         /// <param name="propertyName"></param>
         protected internal override void RefreshCellContent(FrameworkElement element, string propertyName)
         {
-            DataGridCell cell = element as DataGridCell;
-            if (cell != null)
+            if (element is DataGridCell cell)
             {
                 bool isCellEditing = cell.IsEditing;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTextColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTextColumn.cs
index 9c383fdf..562f175b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTextColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DataGridTextColumn.cs
@@ -121,13 +121,10 @@ private void SyncProperties(FrameworkElement e)
 
         protected internal override void RefreshCellContent(FrameworkElement element, string propertyName)
         {
-            DataGridCell cell = element as DataGridCell;
-
-            if (cell != null)
+            if (element is DataGridCell cell)
             {
-                FrameworkElement textElement = cell.Content as FrameworkElement;
 
-                if (textElement != null)
+                if (cell.Content is FrameworkElement textElement)
                 {
                     switch (propertyName)
                     {
@@ -165,15 +162,13 @@ protected internal override void RefreshCellContent(FrameworkElement element, st
         /// <returns>The unedited value of the cell.</returns>
         protected override object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs)
         {
-            TextBox textBox = editingElement as TextBox;
-            if (textBox != null)
+            if (editingElement is TextBox textBox)
             {
                 textBox.Focus();
 
                 string originalValue = textBox.Text;
 
-                TextCompositionEventArgs textArgs = editingEventArgs as TextCompositionEventArgs;
-                if (textArgs != null)
+                if (editingEventArgs is TextCompositionEventArgs textArgs)
                 {
                     // If text input started the edit, then replace the text with what was typed.
                     string inputText = ConvertTextForEdit(textArgs.Text);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DatePicker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DatePicker.cs
index 009fb5f1..73f38125 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DatePicker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DatePicker.cs
@@ -468,9 +468,8 @@ private static void OnSelectedDateChanged(DependencyObject d, DependencyProperty
 
             dp.OnSelectedDateChanged(new CalendarSelectionChangedEventArgs(DatePicker.SelectedDateChangedEvent, removedItems, addedItems));
 
-            DatePickerAutomationPeer peer = UIElementAutomationPeer.FromElement(dp) as DatePickerAutomationPeer;
             // Raise the propetyChangeEvent for Value if Automation Peer exist
-            if (peer != null)
+            if (UIElementAutomationPeer.FromElement(dp) is DatePickerAutomationPeer peer)
             {
                 string addedDateString = addedDate.HasValue ? dp.DateTimeToString(addedDate.Value) : "";
                 string removedDateString = removedDate.HasValue ? dp.DateTimeToString(removedDate.Value) : "";
@@ -575,9 +574,7 @@ private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedE
 
             if (!dp.IsHandlerSuspended(DatePicker.TextProperty))
             {
-                string newValue = e.NewValue as string;
-
-                if (newValue != null)
+                if (e.NewValue is string newValue)
                 {
                     if (dp._textBox != null)
                     {
@@ -873,17 +870,13 @@ private void SetIsHandlerSuspended(DependencyProperty property, bool value)
             }
             else
             {
-                if (_isHandlerSuspended != null)
-                {
-                    _isHandlerSuspended.Remove(property);
-                }
+                _isHandlerSuspended?.Remove(property);
             }
         }
 
         private void PopUp_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
         {
-            Popup popup = sender as Popup;
-            if (popup != null && !popup.StaysOpen)
+            if (sender is Popup popup && !popup.StaysOpen)
             {
                 if (this._dropDownButton != null)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DateTimeHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DateTimeHelper.cs
index 4fd5a874..19119d51 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DateTimeHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DateTimeHelper.cs
@@ -135,7 +135,7 @@ internal static DateTimeFormatInfo GetDateFormat(CultureInfo culture)
                 
                 foreach (System.Globalization.Calendar cal in culture.OptionalCalendars)
                 {
-                    if (cal is GregorianCalendar) 
+                    if (cal is GregorianCalendar gregorianCalendar) 
                     {
                         // Return the first Gregorian calendar with CalendarType == Localized
                         // Otherwise return the first Gregorian calendar
@@ -144,7 +144,7 @@ internal static DateTimeFormatInfo GetDateFormat(CultureInfo culture)
                             foundCal = cal as GregorianCalendar;
                         }
                         
-                        if (((GregorianCalendar)cal).CalendarType == GregorianCalendarTypes.Localized)
+                        if (gregorianCalendar.CalendarType == GregorianCalendarTypes.Localized)
                         {
                             foundCal = cal as GregorianCalendar;
                             break;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Decorator.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Decorator.cs
index a0156060..b8fb40aa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Decorator.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Decorator.cs
@@ -209,10 +209,7 @@ protected override Size MeasureOverride(Size constraint)
         protected override Size ArrangeOverride(Size arrangeSize)
         {
             UIElement child = Child;
-            if (child != null)
-            {
-                child.Arrange(new Rect(arrangeSize));
-            }
+            child?.Arrange(new Rect(arrangeSize));
             return (arrangeSize);
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DeferredTextReference.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DeferredTextReference.cs
index b806cdd1..3187fcfc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DeferredTextReference.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DeferredTextReference.cs
@@ -44,10 +44,7 @@ internal override object GetValue(BaseValueSourceInternal valueSource)
             string s = TextRangeBase.GetTextInternal(_textContainer.Start, _textContainer.End);
 
             TextBox tb = _textContainer.Parent as TextBox;
-            if (tb != null)
-            {
-                tb.OnDeferredTextReferenceResolved(this, s);
-            }
+            tb?.OnDeferredTextReferenceResolved(this, s);
 
             return s;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DefinitionBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DefinitionBase.cs
index 20c1f8ff..23da8b17 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DefinitionBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DefinitionBase.cs
@@ -121,7 +121,7 @@ internal void OnBeforeLayout(Grid grid)
             LayoutWasUpdated = true;
 
             //  defer verification for shared definitions
-            if (_sharedState != null)   {   _sharedState.EnsureDeferredValidation(grid);    }
+            _sharedState?.EnsureDeferredValidation(grid);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DockPanel.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DockPanel.cs
index 8be59c9c..46316f57 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DockPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DockPanel.cs
@@ -124,14 +124,11 @@ public static void SetDock(UIElement element, Dock dock)
 
         private static void OnDockChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            UIElement uie = d as UIElement; //it may be anyting, like FlowDocument... bug 1237275
-            if(uie != null)
+ //it may be anyting, like FlowDocument... bug 1237275
+            if(d is UIElement uie)
             {
                 DockPanel p = VisualTreeHelper.GetParent(uie) as DockPanel;
-                if(p != null)
-                {
-                    p.InvalidateMeasure();
-                }
+                p?.InvalidateMeasure();
             }
         }
         
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DocumentViewer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DocumentViewer.cs
index c1531e11..b4fa1007 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DocumentViewer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/DocumentViewer.cs
@@ -135,10 +135,7 @@ public void FitToMaxPagesAcross(int pagesAcross)
         {
             if (ValidateMaxPagesAcross(pagesAcross))
             {
-                if (_documentScrollInfo != null)
-                {
-                    _documentScrollInfo.FitColumns(pagesAcross);
-                }
+                _documentScrollInfo?.FitColumns(pagesAcross);
             }
             else
             {
@@ -932,10 +929,7 @@ protected override void OnBringIntoView(DependencyObject element, Rect rect, int
         protected override void OnPreviousPageCommand()
         {
             //Scroll to the previous row.
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.ScrollToPreviousRow();
-            }
+            _documentScrollInfo?.ScrollToPreviousRow();
         }
 
         /// <summary>
@@ -944,10 +938,7 @@ protected override void OnPreviousPageCommand()
         protected override void OnNextPageCommand()
         {
             //Scroll to the previous row.
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.ScrollToNextRow();
-            }
+            _documentScrollInfo?.ScrollToNextRow();
         }
 
         /// <summary>
@@ -956,10 +947,7 @@ protected override void OnNextPageCommand()
         protected override void OnFirstPageCommand()
         {
             //Scroll to the top of the document.
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.MakePageVisible( 0 );
-            }
+            _documentScrollInfo?.MakePageVisible(0);
         }
 
         /// <summary>
@@ -968,10 +956,7 @@ protected override void OnFirstPageCommand()
         protected override void OnLastPageCommand()
         {
             //Scroll to the bottom of the document.
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.MakePageVisible( PageCount - 1 );
-            }
+            _documentScrollInfo?.MakePageVisible(PageCount - 1);
         }
 
         /// <summary>
@@ -998,10 +983,7 @@ protected override void OnGoToPageCommand(int pageNumber)
         /// </summary>
         protected virtual void OnViewThumbnailsCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.ViewThumbnails();
-            }
+            _documentScrollInfo?.ViewThumbnails();
         }
 
         /// <summary>
@@ -1009,10 +991,7 @@ protected virtual void OnViewThumbnailsCommand()
         /// </summary>
         protected virtual void OnFitToWidthCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.FitToPageWidth();
-            }
+            _documentScrollInfo?.FitToPageWidth();
         }
 
         /// <summary>
@@ -1020,10 +999,7 @@ protected virtual void OnFitToWidthCommand()
         /// </summary>
         protected virtual void OnFitToHeightCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.FitToPageHeight();
-            }
+            _documentScrollInfo?.FitToPageHeight();
         }
 
         /// <summary>
@@ -1031,10 +1007,7 @@ protected virtual void OnFitToHeightCommand()
         /// </summary>
         protected virtual void OnFitToMaxPagesAcrossCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.FitColumns(MaxPagesAcross);
-            }
+            _documentScrollInfo?.FitColumns(MaxPagesAcross);
         }
 
         /// <summary>
@@ -1045,10 +1018,7 @@ protected virtual void OnFitToMaxPagesAcrossCommand(int pagesAcross)
         {
             if (ValidateMaxPagesAcross(pagesAcross))
             {
-                if (_documentScrollInfo != null)
-                {
-                    _documentScrollInfo.FitColumns(pagesAcross);
-                }
+                _documentScrollInfo?.FitColumns(pagesAcross);
             }
             else
             {
@@ -1082,10 +1052,7 @@ protected override void OnKeyDown(KeyEventArgs e)
         /// </summary>
         protected virtual void OnScrollPageUpCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.PageUp();
-            }
+            _documentScrollInfo?.PageUp();
         }
 
         /// <summary>
@@ -1093,10 +1060,7 @@ protected virtual void OnScrollPageUpCommand()
         /// </summary>
         protected virtual void OnScrollPageDownCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.PageDown();
-            }
+            _documentScrollInfo?.PageDown();
         }
 
         /// <summary>
@@ -1104,10 +1068,7 @@ protected virtual void OnScrollPageDownCommand()
         /// </summary>
         protected virtual void OnScrollPageLeftCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.PageLeft();
-            }
+            _documentScrollInfo?.PageLeft();
         }
 
         /// <summary>
@@ -1115,10 +1076,7 @@ protected virtual void OnScrollPageLeftCommand()
         /// </summary>
         protected virtual void OnScrollPageRightCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.PageRight();
-            }
+            _documentScrollInfo?.PageRight();
         }
 
         /// <summary>
@@ -1126,10 +1084,7 @@ protected virtual void OnScrollPageRightCommand()
         /// </summary>
         protected virtual void OnMoveUpCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.LineUp();
-            }
+            _documentScrollInfo?.LineUp();
         }
 
         /// <summary>
@@ -1137,10 +1092,7 @@ protected virtual void OnMoveUpCommand()
         /// </summary>
         protected virtual void OnMoveDownCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.LineDown();
-            }
+            _documentScrollInfo?.LineDown();
         }
 
         /// <summary>
@@ -1148,10 +1100,7 @@ protected virtual void OnMoveDownCommand()
         /// </summary>
         protected virtual void OnMoveLeftCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.LineLeft();
-            }
+            _documentScrollInfo?.LineLeft();
         }
 
         /// <summary>
@@ -1159,10 +1108,7 @@ protected virtual void OnMoveLeftCommand()
         /// </summary>
         protected virtual void OnMoveRightCommand()
         {
-            if (_documentScrollInfo != null)
-            {
-                _documentScrollInfo.LineRight();
-            }
+            _documentScrollInfo?.LineRight();
         }
 
         /// <summary>
@@ -1374,9 +1320,7 @@ internal void InvalidatePageViewsInternal()
         /// <returns>Whether operation is pending or not.</returns>
         internal bool BringPointIntoView(Point point)
         {
-            FrameworkElement grid = _documentScrollInfo as FrameworkElement;
-
-            if (grid != null)
+            if (_documentScrollInfo is FrameworkElement grid)
             {
                 //Calculate the bounds of the DocumentGrid relative to the bounds of DocumentViewer
                 Transform tr = this.TransformToDescendant(grid) as Transform;
@@ -1959,16 +1903,16 @@ private static void DoFitToMaxPagesAcross(DocumentViewer dv, object data)
                 bool isValidArg = true;
 
                 // If data is an int, then cast
-                if (data is int)
+                if (data is int i)
                 {
-                    columnValue = (int)data;
+                    columnValue = i;
                 }
                 // If args.Data is a string, then parse
-                else if (data is string)
+                else if (data is string s)
                 {
                     try
                     {
-                        columnValue = System.Convert.ToInt32((string)data, CultureInfo.CurrentCulture);
+                        columnValue = System.Convert.ToInt32(s, CultureInfo.CurrentCulture);
                     }
                     // Catch only the expected parse exceptions
                     catch (ArgumentNullException)
@@ -2076,10 +2020,8 @@ private void CreateIDocumentScrollInfo()
                 _documentScrollInfo = new DocumentGrid();
                 _documentScrollInfo.DocumentViewerOwner = this;
 
-                //If IDocumentScrollInfo is a FrameworkElement we can give it a
-                //Name for automation.
-                FrameworkElement fe = _documentScrollInfo as FrameworkElement;
-                if (fe != null)
+                //If IDocumentScrollInfo is a FrameworkElement we can give it a                //Name for automation.
+                if (_documentScrollInfo is FrameworkElement fe)
                 {
                     fe.Name = "DocumentGrid";
                     fe.Focusable = false;
@@ -2153,13 +2095,10 @@ private void FindContentHost()
         /// </summary>
         private void InstantiateFindToolBar()
         {
-            //First, find the correct place to insert toolbar.
-
-            // Location is defined by named element, FindToolbarHost.
-            ContentControl findHost = this.Template.FindName(_findToolBarHostName, this) as ContentControl;
+            //First, find the correct place to insert toolbar.            // Location is defined by named element, FindToolbarHost.
 
             // Only create and hook up the toolbar, if we found a place to put it.
-            if (findHost != null)
+            if (this.Template.FindName(_findToolBarHostName, this) is ContentControl findHost)
             {
                if( _findToolbar == null )
                {
@@ -2205,10 +2144,7 @@ private void OnFindInvoked(object sender, EventArgs e)
                         //will be made visible after it's made.
                         this.Focus();
 
-                        if (_documentScrollInfo != null)
-                        {
-                            _documentScrollInfo.MakeSelectionVisible();
-                        }
+                        _documentScrollInfo?.MakeSelectionVisible();
 
                         //Put the focus back on the Find Toolbar's TextBox to search again.
                         _findToolbar.GoToTextBox();
@@ -2254,10 +2190,7 @@ private void OnFindInvoked(object sender, EventArgs e)
         /// </summary>
         private void GoToFind()
         {
-            if (_findToolbar != null)
-            {
-                _findToolbar.GoToTextBox();
-            }
+            _findToolbar?.GoToTextBox();
         }
 
 
@@ -2353,10 +2286,8 @@ private static bool DoubleValue_Validate(object value)
             bool ok;
 
             // Ensure value is double
-            if (value is double)
+            if (value is double checkValue)
             {
-                double checkValue = (double)value;
-
                 // Check if double is within an assumed range
                 if ((double.IsNaN(checkValue)) ||
                     (double.IsInfinity(checkValue)))
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Expander.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Expander.cs
index 2eb72959..83b281db 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Expander.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Expander.cs
@@ -134,10 +134,7 @@ private static void OnIsExpandedChanged(DependencyObject d, DependencyPropertyCh
 
             // Fire accessibility event
             ExpanderAutomationPeer peer = UIElementAutomationPeer.FromElement(ep) as ExpanderAutomationPeer;
-            if(peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent(!newValue, newValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent(!newValue, newValue);
 
             if (newValue)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentReader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentReader.cs
index c1d49d90..9a6031c3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentReader.cs
@@ -694,10 +694,7 @@ protected virtual void OnFindCommand()
         /// </summary>
         protected virtual void OnPrintCommand()
         {
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.Print();
-            }
+            CurrentViewer?.Print();
         }
 
         /// <summary>
@@ -705,10 +702,7 @@ protected virtual void OnPrintCommand()
         /// </summary>
         protected virtual void OnCancelPrintCommand()
         {
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.CancelPrint();
-            }
+            CurrentViewer?.CancelPrint();
         }
 
         /// <summary>
@@ -958,13 +952,13 @@ protected virtual void SwitchViewingModeCore(FlowDocumentReaderViewingMode viewi
                     // or to the current viewer.
                     if (isKeyboardFocusWithin)
                     {
-                        if (focusedElement is UIElement)
+                        if (focusedElement is UIElement uIElement)
                         {
-                            ((UIElement)focusedElement).Focus();
+                            uIElement.Focus();
                         }
-                        else if (focusedElement is ContentElement)
+                        else if (focusedElement is ContentElement contentElement)
                         {
-                            ((ContentElement)focusedElement).Focus();
+                            contentElement.Focus();
                         }
                         else
                         {
@@ -994,7 +988,7 @@ private bool IsFocusWithinDocument()
                 // walk up logical tree to find if the focused element is within
                 // the document.
                 FrameworkElement fe = focusedElement as FrameworkElement;
-                if (fe != null && fe.TemplatedParent != null)
+                if (fe?.TemplatedParent != null)
                 {
                     focusedElement = fe.TemplatedParent;
                 }
@@ -1046,10 +1040,7 @@ private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument)
             }
 
             // Attach document to the current viewer.
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.SetDocument(newDocument);
-            }
+            CurrentViewer?.SetDocument(newDocument);
 
             // Document invalidation invalidates following properties:
             //      - PageCount
@@ -1070,10 +1061,7 @@ private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument)
 
             // Document is also represented as Automation child. Need to invalidate peer to force update.
             FlowDocumentReaderAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as FlowDocumentReaderAutomationPeer;
-            if (peer != null)
-            {
-                peer.InvalidatePeer();
-            }
+            peer?.InvalidatePeer();
         }
 
         /// <summary>
@@ -1081,7 +1069,7 @@ private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument)
         /// </summary>
         private void DetachViewer(IFlowDocumentViewer viewer)
         {
-            Invariant.Assert(viewer != null && viewer is FrameworkElement);
+            Invariant.Assert(viewer is FrameworkElement);
             FrameworkElement feViewer = (FrameworkElement)viewer;
             // Clear property bindings.
             BindingOperations.ClearBinding(feViewer, ZoomProperty);
@@ -1104,7 +1092,7 @@ private void DetachViewer(IFlowDocumentViewer viewer)
         /// </summary>
         private void AttachViewer(IFlowDocumentViewer viewer)
         {
-            Invariant.Assert(viewer != null && viewer is FrameworkElement);
+            Invariant.Assert(viewer is FrameworkElement);
             FrameworkElement feViewer = (FrameworkElement)viewer;
             // Set document
             viewer.SetDocument(Document);
@@ -1264,14 +1252,13 @@ private void OnViewerPrintCompleted(object sender, EventArgs e)
         private bool ConvertToViewingMode(object value, out FlowDocumentReaderViewingMode mode)
         {
             bool success;
-            if (value is FlowDocumentReaderViewingMode)
+            if (value is FlowDocumentReaderViewingMode flowDocumentReaderViewingMode)
             {
-                mode = (FlowDocumentReaderViewingMode)value;
+                mode = flowDocumentReaderViewingMode;
                 success = true;
             }
-            else if (value is String)
+            else if (value is String str)
             {
-                String str = (String)value;
                 if (str == FlowDocumentReaderViewingMode.Page.ToString())
                 {
                     mode = FlowDocumentReaderViewingMode.Page;
@@ -1522,10 +1509,7 @@ private void TrySwitchViewingMode(object parameter)
         /// </summary>
         private void OnPreviousPageCommand()
         {
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.PreviousPage();
-            }
+            CurrentViewer?.PreviousPage();
         }
 
         /// <summary>
@@ -1533,10 +1517,7 @@ private void OnPreviousPageCommand()
         /// </summary>
         private void OnNextPageCommand()
         {
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.NextPage();
-            }
+            CurrentViewer?.NextPage();
         }
 
         /// <summary>
@@ -1544,10 +1525,7 @@ private void OnNextPageCommand()
         /// </summary>
         private void OnFirstPageCommand()
         {
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.FirstPage();
-            }
+            CurrentViewer?.FirstPage();
         }
 
         /// <summary>
@@ -1555,10 +1533,7 @@ private void OnFirstPageCommand()
         /// </summary>
         private void OnLastPageCommand()
         {
-            if (CurrentViewer != null)
-            {
-                CurrentViewer.LastPage();
-            }
+            CurrentViewer?.LastPage();
         }
 
         /// <summary>
@@ -1578,9 +1553,9 @@ private void OnFindInvoked(object sender, EventArgs e)
                 // In order to show current text selection TextEditor requires Focus to be set on the UIScope.
                 // If there embedded controls, it may happen that embedded control currently has focus and find
                 // was invoked through hotkeys. To support this case we manually move focus to the appropriate element.
-                if (CurrentViewer != null && CurrentViewer is UIElement)
+                if (CurrentViewer is UIElement uIElement)
                 {
-                    ((UIElement)CurrentViewer).Focus();
+                    uIElement.Focus();
                 }
 
                 findResult = DocumentViewerHelper.Find(findToolBar, textEditor, textEditor.TextView, textEditor.TextView);
@@ -1589,10 +1564,7 @@ private void OnFindInvoked(object sender, EventArgs e)
                 if ((findResult != null) && (!findResult.IsEmpty))
                 {
                     // Bring find result into view.
-                    if (CurrentViewer != null)
-                    {
-                        CurrentViewer.ShowFindResult(findResult);
-                    }
+                    CurrentViewer?.ShowFindResult(findResult);
                 }
                 else
                 {
@@ -1637,7 +1609,7 @@ private static void KeyDownHandler(object sender, KeyEventArgs e)
         /// </summary>
         private static void ViewingModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
             if (viewer.CanSwitchToViewingMode((FlowDocumentReaderViewingMode)e.NewValue))
             {
@@ -1650,10 +1622,7 @@ private static void ViewingModeChanged(DependencyObject d, DependencyPropertyCha
 
             // Fire automation events if automation is active.
             FlowDocumentReaderAutomationPeer peer = UIElementAutomationPeer.FromElement(viewer) as FlowDocumentReaderAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseCurrentViewChangedEvent((FlowDocumentReaderViewingMode)e.NewValue, (FlowDocumentReaderViewingMode)e.OldValue);
-            }
+            peer?.RaiseCurrentViewChangedEvent((FlowDocumentReaderViewingMode)e.NewValue, (FlowDocumentReaderViewingMode)e.OldValue);
         }
 
         /// <summary>
@@ -1672,7 +1641,7 @@ private static bool IsValidViewingMode(object o)
         /// </summary>
         private static void ViewingModeEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             // Cannot disable all viewing modes.
@@ -1691,10 +1660,7 @@ private static void ViewingModeEnabledChanged(DependencyObject d, DependencyProp
 
             // Fire automation events if automation is active.
             FlowDocumentReaderAutomationPeer peer = UIElementAutomationPeer.FromElement(viewer) as FlowDocumentReaderAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseSupportedViewsChangedEvent(e);
-            }
+            peer?.RaiseSupportedViewsChangedEvent(e);
         }
 
         /// <summary>
@@ -1702,7 +1668,7 @@ private static void ViewingModeEnabledChanged(DependencyObject d, DependencyProp
         /// </summary>
         private static void IsFindEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             // Update the toolbar with our current state.
@@ -1723,7 +1689,7 @@ private static void IsFindEnabledChanged(DependencyObject d, DependencyPropertyC
         /// </summary>
         private static void IsPrintEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             // Since IsPrintEnabled state is used to determine CanExecute state, we must invalidate that state.
@@ -1735,7 +1701,7 @@ private static void IsPrintEnabledChanged(DependencyObject d, DependencyProperty
         /// </summary>
         private static void DocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
             viewer.DocumentChanged((FlowDocument)e.OldValue, (FlowDocument)e.NewValue);
 
@@ -1748,7 +1714,7 @@ private static void DocumentChanged(DependencyObject d, DependencyPropertyChange
         /// </summary>
         private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
             if (!DoubleUtil.AreClose((double)e.OldValue, (double)e.NewValue))
             {
@@ -1763,7 +1729,7 @@ private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEve
         /// </summary>
         private static object CoerceZoom(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             double zoom = (double)value;
@@ -1788,7 +1754,7 @@ private static object CoerceZoom(DependencyObject d, object value)
         /// </summary>
         private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             viewer.CoerceValue(ZoomProperty);
@@ -1800,7 +1766,7 @@ private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChanged
         /// </summary>
         private static object CoerceMaxZoom(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             double min = viewer.MinZoom;
@@ -1812,7 +1778,7 @@ private static object CoerceMaxZoom(DependencyObject d, object value)
         /// </summary>
         private static void MinZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentReader);
+            Invariant.Assert(d is FlowDocumentReader);
             FlowDocumentReader viewer = (FlowDocumentReader)d;
 
             viewer.CoerceValue(MaxZoomProperty);
@@ -1841,10 +1807,7 @@ private static void UpdateCaretElement(DependencyObject d, DependencyPropertyCha
             if (reader.Selection != null)
             {
                 CaretElement caretElement = reader.Selection.CaretElement;
-                if (caretElement != null)
-                {
-                    caretElement.InvalidateVisual();
-                }
+                caretElement?.InvalidateVisual();
             }
         }
 
@@ -1877,7 +1840,7 @@ private TextEditor TextEditor
             {
                 TextEditor textEditor = null;
                 IFlowDocumentViewer currentViewer = CurrentViewer;
-                if (currentViewer != null && currentViewer.TextSelection != null)
+                if (currentViewer?.TextSelection != null)
                 {
                     textEditor = currentViewer.TextSelection.TextEditor;
                 }
@@ -2013,8 +1976,7 @@ CustomJournalStateInternal IJournalState.GetJournalState(JournalReason journalRe
             IFlowDocumentViewer viewer = CurrentViewer;
             if (viewer != null)
             {
-                TextPointer contentPosition = viewer.ContentPosition as TextPointer;
-                if (contentPosition != null)
+                if (viewer.ContentPosition is TextPointer contentPosition)
                 {
                     cp = contentPosition.Offset;
                     cpDirection = contentPosition.LogicalDirection;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentScrollViewer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentScrollViewer.cs
index 62a73e41..055c9a4c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentScrollViewer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/FlowDocumentScrollViewer.cs
@@ -552,10 +552,7 @@ protected virtual void OnPrintCommand()
                 if (docWriter != null && ia != null)
                 {
                     // Suspend layout on FlowDocumentView.
-                    if (RenderScope != null)
-                    {
-                        RenderScope.SuspendLayout();
-                    }
+                    RenderScope?.SuspendLayout();
 
                     // Store the current state of the document in the PrintingState
                     paginator = ((IDocumentPaginatorSource)Document).DocumentPaginator as FlowDocumentPaginator;
@@ -795,19 +792,10 @@ protected internal override IEnumerator LogicalChildren
         /// </summary>
         internal override bool BuildRouteCore(EventRoute route, RoutedEventArgs args)
         {
-            // If FlowDocumentScrollViewer is used as embedded viewer (in FlowDocumentReader),
-            // it is not part of logical tree, so default logic in FE to re-add logical
-            // tree from branched node does not work here.
-            // But before FlowDocumentScrollViewer is added to the event route, logical
-            // ancestors up to Document need to be added to the route. Otherwise
-            // content will not have a chance to react to events first.
-            // This breaks navigation cursor management logic, because TextEditor attached
-            // to FlowDocumentScrollViewer handles those events first.
-            DependencyObject document = this.Document as DependencyObject;
-            if (document != null && LogicalTreeHelper.GetParent(document) != this)
-            {
-                DependencyObject branchNode = route.PeekBranchNode() as DependencyObject;
-                if (branchNode != null && DocumentViewerHelper.IsLogicalDescendent(branchNode, document))
+            // If FlowDocumentScrollViewer is used as embedded viewer (in FlowDocumentReader),            // it is not part of logical tree, so default logic in FE to re-add logical            // tree from branched node does not work here.            // But before FlowDocumentScrollViewer is added to the event route, logical            // ancestors up to Document need to be added to the route. Otherwise            // content will not have a chance to react to events first.            // This breaks navigation cursor management logic, because TextEditor attached            // to FlowDocumentScrollViewer handles those events first.
+            if (this.Document is DependencyObject document && LogicalTreeHelper.GetParent(document) != this)
+            {
+                if (route.PeekBranchNode() is DependencyObject branchNode && DocumentViewerHelper.IsLogicalDescendent(branchNode, document))
                 {
                     // Add intermediate ContentElements to the route.
                     FrameworkElement.AddIntermediateElementsToRoute(
@@ -821,8 +809,7 @@ internal override bool InvalidateAutomationAncestorsCore(Stack<DependencyObject>
         {
             bool continueInvalidation = true;
 
-            DependencyObject document = this.Document as DependencyObject;
-            if (document != null && LogicalTreeHelper.GetParent(document) != this)
+            if (this.Document is DependencyObject document && LogicalTreeHelper.GetParent(document) != this)
             {
                 DependencyObject branchNode = (branchNodeStack.Count > 0) ? branchNodeStack.Peek() : null;
                 if (branchNode != null && DocumentViewerHelper.IsLogicalDescendent(branchNode, document))
@@ -841,8 +828,7 @@ internal override bool InvalidateAutomationAncestorsCore(Stack<DependencyObject>
         /// </summary>
         internal object BringContentPositionIntoView(object arg)
         {
-            ITextPointer contentPosition = arg as ITextPointer;
-            if (contentPosition != null)
+            if (arg is ITextPointer contentPosition)
             {
                 ITextView textView = GetTextView();
                 if (textView != null && textView.IsValid && textView.RenderScope is IScrollInfo && contentPosition.TextContainer == textView.TextContainer)
@@ -1054,10 +1040,7 @@ private void ClearPrintingState()
             if (_printingState != null)
             {
                 // Resume layout on FlowDocumentView.
-                if (RenderScope != null)
-                {
-                    RenderScope.ResumeLayout();
-                }
+                RenderScope?.ResumeLayout();
 
                 // Enable TextSelection, if it was previously enabled.
                 if (_printingState.IsSelectionEnabled)
@@ -1100,7 +1083,7 @@ private void HandleRequestBringIntoView(RequestBringIntoViewEventArgs args)
             UIElement targetUIElement;
             Rect targetRect = Rect.Empty;
 
-            if (args != null && args.TargetObject != null && Document != null)
+            if (args?.TargetObject != null && Document != null)
             {
                 document = Document;
 
@@ -1110,10 +1093,7 @@ private void HandleRequestBringIntoView(RequestBringIntoViewEventArgs args)
                 // This supports navigating from baseURI#anchor to just baseURI.
                 if (args.TargetObject == document)
                 {
-                    if (_contentHost != null)
-                    {
-                        _contentHost.ScrollToHome();
-                    }
+                    _contentHost?.ScrollToHome();
                     args.Handled = true; // Mark the event as handled.
                 }
                 else if (args.TargetObject is UIElement)
@@ -1268,10 +1248,7 @@ private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument)
 
             // Document is also represented as Automation child. Need to invalidate peer to force update.
             FlowDocumentScrollViewerAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as FlowDocumentScrollViewerAutomationPeer;
-            if (peer != null)
-            {
-                peer.InvalidatePeer();
-            }
+            peer?.InvalidatePeer();
         }
 
         /// <summary>
@@ -1281,9 +1258,9 @@ private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument)
         private ITextView GetTextView()
         {
             ITextView textView = null;
-            if (RenderScope is IServiceProvider)
+            if (RenderScope is IServiceProvider iServiceProvider)
             {
-                textView = (ITextView)((IServiceProvider)RenderScope).GetService(typeof(ITextView));
+                textView = (ITextView)iServiceProvider.GetService(typeof(ITextView));
             }
             return textView;
         }
@@ -1622,7 +1599,7 @@ private static Rect MakeVisible(IScrollInfo scrollInfo, Visual visual, Rect rect
         /// </summary>
         private static void DocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             ((FlowDocumentScrollViewer)d).DocumentChanged((FlowDocument)e.OldValue, (FlowDocument)e.NewValue);
 
             // Since Document state is used to determine CanExecute state, we must invalidate that state.
@@ -1634,7 +1611,7 @@ private static void DocumentChanged(DependencyObject d, DependencyPropertyChange
         /// </summary>
         private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
             if (!DoubleUtil.AreClose((double)e.OldValue, (double)e.NewValue))
             {
@@ -1652,7 +1629,7 @@ private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEve
         /// </summary>
         private static object CoerceZoom(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
 
             double zoom = (double)value;
@@ -1677,7 +1654,7 @@ private static object CoerceZoom(DependencyObject d, object value)
         /// </summary>
         private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
 
             viewer.CoerceValue(ZoomProperty);
@@ -1689,7 +1666,7 @@ private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChanged
         /// </summary>
         private static object CoerceMaxZoom(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
 
             double min = viewer.MinZoom;
@@ -1701,7 +1678,7 @@ private static object CoerceMaxZoom(DependencyObject d, object value)
         /// </summary>
         private static void MinZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
 
             viewer.CoerceValue(MaxZoomProperty);
@@ -1727,9 +1704,9 @@ private static bool ZoomValidateValue(object o)
         /// <param name="args">RequestBringIntoViewEventArgs indicates the element and region to scroll into view.</param>
         private static void HandleRequestBringIntoView(object sender, RequestBringIntoViewEventArgs args)
         {
-            if (sender != null && sender is FlowDocumentScrollViewer)
+            if (sender is FlowDocumentScrollViewer flowDocumentScrollViewer)
             {
-                ((FlowDocumentScrollViewer)sender).HandleRequestBringIntoView(args);
+                flowDocumentScrollViewer.HandleRequestBringIntoView(args);
             }
         }
 
@@ -1738,7 +1715,7 @@ private static void HandleRequestBringIntoView(object sender, RequestBringIntoVi
         /// </summary>
         private static void IsSelectionEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
 
             viewer.AttachTextEditor();
@@ -1749,7 +1726,7 @@ private static void IsSelectionEnabledChanged(DependencyObject d, DependencyProp
         /// </summary>
         private static void IsToolBarVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentScrollViewer);
+            Invariant.Assert(d is FlowDocumentScrollViewer);
             FlowDocumentScrollViewer viewer = (FlowDocumentScrollViewer)d;
 
             if (viewer._toolBarHost != null)
@@ -1768,10 +1745,7 @@ private static void UpdateCaretElement(DependencyObject d, DependencyPropertyCha
             if (viewer.Selection != null)
             {
                 CaretElement caretElement = viewer.Selection.CaretElement;
-                if (caretElement != null)
-                {
-                    caretElement.InvalidateVisual();
-                }
+                caretElement?.InvalidateVisual();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Frame.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Frame.cs
index 81f0014f..3891daf5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Frame.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Frame.cs
@@ -214,13 +214,10 @@ NavigationService IDownloader.Downloader
         /// <param name="args"></param>
         protected virtual void OnContentRendered(EventArgs args)
         {
-            // After the content is rendered we want to check if there is an element that needs to be focused
-            // If there is - set focus to it
-            DependencyObject doContent = Content as DependencyObject;
-            if (doContent != null)
+            // After the content is rendered we want to check if there is an element that needs to be focused            // If there is - set focus to it
+            if (Content is DependencyObject doContent)
             {
-                IInputElement focusedElement = FocusManager.GetFocusedElement(doContent) as IInputElement;
-                if (focusedElement != null)
+                if (FocusManager.GetFocusedElement(doContent) is IInputElement focusedElement)
                     focusedElement.Focus();
             }
 
@@ -608,12 +605,7 @@ private void PostContentRendered()
         {
             // Post the firing of ContentRendered as Input priority work item so
             // that ContentRendered will be fired after render query empties.
-            if (_contentRenderedCallback != null)
-            {
-                // Content was changed again before the previous rendering completed (or at least
-                // before the Dispatcher got to Input priority callbacks).
-                _contentRenderedCallback.Abort();
-            }
+            _contentRenderedCallback?.Abort();
             _contentRenderedCallback = Dispatcher.BeginInvoke(DispatcherPriority.Input,
                                    (DispatcherOperationCallback) delegate (object unused)
                                    {
@@ -655,11 +647,9 @@ private void OnNavigateJournal(object sender, ExecutedRoutedEventArgs e)
             Debug.Assert(sender == this && _ownJournalScope != null);
 
             // The following checks are needed because anyone could send the NavigateJournal command.
-            FrameworkElement journalEntryUIElem = e.Parameter as FrameworkElement;
-            if (journalEntryUIElem != null)
+            if (e.Parameter is FrameworkElement journalEntryUIElem)
             {
-                JournalEntry je = journalEntryUIElem.DataContext as JournalEntry;
-                if (je != null)
+                if (journalEntryUIElem.DataContext is JournalEntry je)
                 {
                     if (_ownJournalScope.NavigateToEntry(je))
                     {
@@ -1213,10 +1203,7 @@ internal override void PrepareForSerialization()
                         Debug.Assert(JournalEntry.GetType().IsSerializable);
                     }
                 }
-                if (Journal != null)
-                {
-                    Journal.PruneKeepAliveEntries();
-                }
+                Journal?.PruneKeepAliveEntries();
             }
         };
 
@@ -1284,13 +1271,7 @@ internal override void OnPreApplyTemplate()
         {
             base.OnPreApplyTemplate();
 
-            if (_ownJournalScope != null)
-            {
-                // This causes the Journal instance to be created. BackStackProperty and ForwardStackProperty
-                // should be set before the navigation chrome data-binds to them but after any Journal is
-                // restored from FramePersistState.
-                _ownJournalScope.EnsureJournal();
-            }
+            _ownJournalScope?.EnsureJournal();
         }
 
         // Invalidate resources on the frame content if the content isn't
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Grid.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Grid.cs
index c18d6230..d339f23a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Grid.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Grid.cs
@@ -705,10 +705,7 @@ protected override Size ArrangeOverride(Size arrangeSize)
                     for (int i = 0, count = children.Count; i < count; ++i)
                     {
                         UIElement child = children[i];
-                        if (child != null)
-                        {
-                            child.Arrange(new Rect(arrangeSize));
-                        }
+                        child?.Arrange(new Rect(arrangeSize));
                     }
                 }
                 else
@@ -750,10 +747,7 @@ protected override Size ArrangeOverride(Size arrangeSize)
 
                     //  update render bound on grid lines renderer visual
                     GridLinesRenderer gridLinesRenderer = EnsureGridLinesRenderer();
-                    if (gridLinesRenderer != null)
-                    {
-                        gridLinesRenderer.UpdateRenderBounds(arrangeSize);
-                    }
+                    gridLinesRenderer?.UpdateRenderBounds(arrangeSize);
                 }
             }
             finally
@@ -2914,8 +2908,7 @@ private void SetValid()
         public bool ShouldSerializeColumnDefinitions()
         {
             ExtendedData extData = ExtData;
-            return (    extData != null
-                    &&  extData.ColumnDefinitions != null
+            return (    extData?.ColumnDefinitions != null
                     &&  extData.ColumnDefinitions.Count > 0   );
         }
 
@@ -2926,8 +2919,7 @@ public bool ShouldSerializeColumnDefinitions()
         public bool ShouldSerializeRowDefinitions()
         {
             ExtendedData extData = ExtData;
-            return (    extData != null
-                    &&  extData.RowDefinitions != null
+            return (    extData?.RowDefinitions != null
                     &&  extData.RowDefinitions.Count > 0  );
         }
 
@@ -3013,8 +3005,7 @@ private static void OnCellAttachedPropertyChanged(DependencyObject d, Dependency
             if (child != null)
             {
                 Grid grid = VisualTreeHelper.GetParent(child) as Grid;
-                if (    grid != null
-                    &&  grid.ExtData != null
+                if (    grid?.ExtData != null
                     &&  grid.ListenToNotifications  )
                 {
                     grid.CellsStructureDirty = true;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridSplitter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridSplitter.cs
index be040ce9..6d95118a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridSplitter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridSplitter.cs
@@ -490,10 +490,8 @@ private void RemovePreviewAdorner()
         // Initialize the data needed for resizing
         private void InitializeData(bool ShowsPreview)
         {
-            Grid grid = Parent as Grid;
-
             // If not in a grid or can't resize, do nothing
-            if (grid != null)
+            if (Parent is Grid grid)
             {
                 // Setup data used for resizing
                 _resizeData = new ResizeData();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridView.cs
index de90b2ea..e775acf0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridView.cs
@@ -53,9 +53,7 @@ void IAddChild.AddChild(object column)
         /// </summary>
         protected virtual void AddChild(object column)
         {
-            GridViewColumn c = column as GridViewColumn;
-
-            if (c != null)
+            if (column is GridViewColumn c)
             {
                 Columns.Add(c);
             }
@@ -198,14 +196,11 @@ public static void SetColumnCollection(DependencyObject element, GridViewColumnC
         [EditorBrowsable(EditorBrowsableState.Never)]
         public static bool ShouldSerializeColumnCollection(DependencyObject obj)
         {
-            ListViewItem listViewItem = obj as ListViewItem;
-            if (listViewItem != null)
+            if (obj is ListViewItem listViewItem)
             {
-                ListView listView = listViewItem.ParentSelector as ListView;
-                if (listView != null)
+                if (listViewItem.ParentSelector is ListView listView)
                 {
-                    GridView gridView = listView.View as GridView;
-                    if (gridView != null)
+                    if (listView.View is GridView gridView)
                     {
                         // if GridViewColumnCollection attached on ListViewItem is Details.Columns, it should't be serialized.
                         GridViewColumnCollection localValue = listViewItem.ReadLocalValue(ColumnCollectionProperty) as GridViewColumnCollection;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumn.cs
index 93e1b9fb..f2871cb5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumn.cs
@@ -493,9 +493,7 @@ internal void OnThemeChanged()
         {
             if (Header != null)
             {
-                DependencyObject d = Header as DependencyObject;
-
-                if (d != null)
+                if (Header is DependencyObject d)
                 {
                     FrameworkElement fe;
                     FrameworkContentElement fce;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnCollection.cs
index 77f2f58b..b3229c3d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnCollection.cs
@@ -230,9 +230,7 @@ private void OnInternalCollectionChanged()
 
         private void ColumnPropertyChanged(object sender, PropertyChangedEventArgs e)
         {
-            GridViewColumn column = sender as GridViewColumn;
-
-            if (_internalCollectionChanged != null && column != null)
+            if (_internalCollectionChanged != null && sender is GridViewColumn column)
             {
                 _internalCollectionChanged(this, new GridViewColumnCollectionChangedEventArgs(column, e.PropertyName));
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnHeader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnHeader.cs
index e10c6247..5d0329bb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnHeader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewColumnHeader.cs
@@ -387,10 +387,7 @@ internal void CheckWidthForPreviousHeaderGripper()
                 hideGripperRightHalf = DoubleUtil.LessThan(ActualWidth, _headerGripper.Width);
             }
 
-            if (_previousHeader != null)
-            {
-                _previousHeader.HideGripperRightHalf(hideGripperRightHalf);
-            }
+            _previousHeader?.HideGripperRightHalf(hideGripperRightHalf);
 
             UpdateGripperCursor();
         }
@@ -562,10 +559,7 @@ private static void PropertyChanged(DependencyObject d, DependencyPropertyChange
                         header.SetFlag(flag, false);
 
                         GridViewHeaderRowPresenter headerRowPresenter = header.Parent as GridViewHeaderRowPresenter;
-                        if (headerRowPresenter != null)
-                        {
-                            headerRowPresenter.UpdateHeaderProperty(header, e.Property);
-                        }
+                        headerRowPresenter?.UpdateHeaderProperty(header, e.Property);
                     }
                 }
             }
@@ -624,8 +618,7 @@ private void HideGripperRightHalf(bool hide)
             if (_headerGripper != null)
             {
                 // hide gripper's right half by setting Parent.ClipToBounds=true
-                FrameworkElement gripperContainer = _headerGripper.Parent as FrameworkElement;
-                if (gripperContainer != null)
+                if (_headerGripper.Parent is FrameworkElement gripperContainer)
                 {
                     gripperContainer.ClipToBounds = hide;
                 }
@@ -644,10 +637,7 @@ private void OnColumnHeaderGripperDragStarted(object sender, DragStartedEventArg
         private void MakeParentGotFocus()
         {
             GridViewHeaderRowPresenter headerRP = this.Parent as GridViewHeaderRowPresenter;
-            if (headerRP != null)
-            {
-                headerRP.MakeParentItemsControlGotFocus();
-            }
+            headerRP?.MakeParentItemsControlGotFocus();
         }
 
         // Resize the header
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewHeaderRowPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewHeaderRowPresenter.cs
index 8824f5c3..23744202 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewHeaderRowPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewHeaderRowPresenter.cs
@@ -749,7 +749,7 @@ internal void MakeParentItemsControlGotFocus()
             {
                 // send focus to item.
                 ListBox parent = _itemsControl as ListBox;
-                if (parent != null && parent.LastActionItem != null)
+                if (parent?.LastActionItem != null)
                 {
                     parent.LastActionItem.Focus();
                 }
@@ -945,10 +945,7 @@ private GridViewColumnHeader CreateAndInsertHeader(GridViewColumn column, int in
                             {
                                 // case 2
                                 GridViewColumnHeader parentAsGVCH = parent as GridViewColumnHeader;
-                                if (parentAsGVCH != null)
-                                {
-                                    parentAsGVCH.ClearValue(ContentControl.ContentProperty);
-                                }
+                                parentAsGVCH?.ClearValue(ContentControl.ContentProperty);
                             }
                         }
                     }
@@ -1063,7 +1060,7 @@ private void RenewEvents()
 
             //Set GridViewHeaderRowPresenter to ListView
             ListView lv = _itemsControl as ListView;
-            if (lv != null && lv.View != null && lv.View is GridView)
+            if (lv?.View != null && lv.View is GridView)
             {
                 ((GridView)lv.View).HeaderRowPresenter = this;
             }
@@ -1522,10 +1519,7 @@ private void StartHeaderDrag()
             _draggingSrcHeader.SuppressClickEvent = true;
 
             // lock Columns during header dragging
-            if (Columns != null)
-            {
-                Columns.BlockWrite();
-            }
+            Columns?.BlockWrite();
 
             // Remove the old floating header,
             // then create & add the new one per the source header's type
@@ -1551,10 +1545,7 @@ private void FinishHeaderDrag(bool isCancel)
             _indicator.Visibility = Visibility.Hidden;
 
             // unlock Columns during header dragging
-            if (Columns != null)
-            {
-                Columns.UnblockWrite();
-            }
+            Columns?.UnblockWrite();
 
             // if cancelled, do nothing
             if (!isCancel)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewRowPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewRowPresenter.cs
index 6e437148..0145309f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewRowPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GridViewRowPresenter.cs
@@ -309,8 +309,7 @@ internal override void OnColumnPropertyChanged(GridViewColumn column, string pro
                 // Priority: DisplayMemberBinding > CellTemplate > CellTemplateSelector
                 else if (GridViewColumn.c_DisplayMemberBindingName.Equals(propertyName))
                 {
-                    FrameworkElement cell = InternalChildren[index] as FrameworkElement;
-                    if (cell != null)
+                    if (InternalChildren[index] is FrameworkElement cell)
                     {
                         BindingBase binding = column.DisplayMemberBinding;
                         if (binding != null && cell is TextBlock)
@@ -325,8 +324,7 @@ internal override void OnColumnPropertyChanged(GridViewColumn column, string pro
                 }
                 else
                 {
-                    ContentPresenter cp = InternalChildren[index] as ContentPresenter;
-                    if (cp != null)
+                    if (InternalChildren[index] is ContentPresenter cp)
                     {
                         if (GridViewColumn.CellTemplateProperty.Name.Equals(propertyName))
                         {
@@ -447,12 +445,9 @@ private void FindViewPort()
 
             if (_viewItem != null)
             {
-                ItemsControl itemsControl = ItemsControl.ItemsControlFromItemContainer(_viewItem) as ItemsControl;
-
-                if (itemsControl != null)
+                if (ItemsControl.ItemsControlFromItemContainer(_viewItem) is ItemsControl itemsControl)
                 {
-                    ScrollViewer scrollViewer = itemsControl.ScrollHost as ScrollViewer;
-                    if (scrollViewer != null)
+                    if (itemsControl.ScrollHost is ScrollViewer scrollViewer)
                     {
                         // check if Virtualizing Panel do works
                         if (itemsControl.ItemsHost is VirtualizingPanel &&
@@ -641,7 +636,6 @@ private void UpdateCells()
             ContentPresenter cellAsCP;
             FrameworkElement cell;
             UIElementCollection children = InternalChildren;
-            ContentControl parent = TemplatedParent as ContentControl;
 
             for (int i = 0; i < children.Count; i++)
             {
@@ -657,7 +651,7 @@ private void UpdateCells()
                     cell.DataContext = Content;
                 }
 
-                if (parent != null)
+                if (TemplatedParent is ContentControl parent)
                 {
                     cell.VerticalAlignment = parent.VerticalContentAlignment;
                     cell.HorizontalAlignment = parent.HorizontalContentAlignment;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GroupItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GroupItem.cs
index 1da4bd4d..ba92d8cf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GroupItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/GroupItem.cs
@@ -74,7 +74,7 @@ public override void OnApplyTemplate()
         private static void OnExpanded(object sender, RoutedEventArgs e)
         {
             GroupItem groupItem = sender as GroupItem;
-            if (groupItem != null && groupItem._expander != null && groupItem._expander.IsExpanded)
+            if (groupItem?._expander != null && groupItem._expander.IsExpanded)
             {
                 ItemsControl itemsControl = groupItem.ParentItemsControl;
                 if (itemsControl != null && VirtualizingPanel.GetIsVirtualizing(itemsControl) && VirtualizingPanel.GetVirtualizationMode(itemsControl) == VirtualizationMode.Recycling)
@@ -123,7 +123,7 @@ protected override Size ArrangeOverride(Size arrangeSize)
         internal override string GetPlainText()
         {
             System.Windows.Data.CollectionViewGroup cvg = Content as System.Windows.Data.CollectionViewGroup;
-            if (cvg != null && cvg.Name != null)
+            if (cvg?.Name != null)
             {
                 return cvg.Name.ToString();
             }
@@ -255,10 +255,7 @@ internal void ClearItemContainer(object item, ItemsControl parentItemsControl)
                 // the ItemValueStorage DP for this container.
 
                 VirtualizingPanel vp = _itemsHost as VirtualizingPanel;
-                if (vp != null)
-                {
-                    vp.OnClearChildrenInternal();
-                }
+                vp?.OnClearChildrenInternal();
 
                 Generator.RemoveAllInternal(true /*saveRecycleQueue*/);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/HeaderedItemsControl.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/HeaderedItemsControl.cs
index 7563548b..aeb602ae 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/HeaderedItemsControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/HeaderedItemsControl.cs
@@ -421,10 +421,8 @@ void PrepareHierarchy(object item, ItemsControl parentItemsControl)
                 }
             }
 
-            // if the effective template is a HierarchicalDataTemplate, forward
-            // the special properties
-            HierarchicalDataTemplate hTemplate = headerTemplate as HierarchicalDataTemplate;
-            if (hTemplate != null)
+            // if the effective template is a HierarchicalDataTemplate, forward            // the special properties
+            if (headerTemplate is HierarchicalDataTemplate hTemplate)
             {
                 bool templateMatches = (ItemTemplate == parentItemsControl.ItemTemplate);
                 bool containerStyleMatches = (ItemContainerStyle == parentItemsControl.ItemContainerStyle);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Image.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Image.cs
index c4afe5e3..fdb95192 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Image.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Image.cs
@@ -466,9 +466,7 @@ private static void OnSourceChanged(DependencyObject d, DependencyPropertyChange
                 UpdateBaseUri(d, newValue);
 
                 image.DetachBitmapSourceEvents();
-
-                BitmapSource newBitmapSource = newValue as BitmapSource;
-                if (newBitmapSource != null && newBitmapSource.CheckAccess() && !newBitmapSource.IsFrozen)
+                if (newValue is BitmapSource newBitmapSource && newBitmapSource.CheckAccess() && !newBitmapSource.IsFrozen)
                 {
                     image.AttachBitmapSourceEvents(newBitmapSource);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/InkPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/InkPresenter.cs
index 25f013d3..3b1f8b18 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/InkPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/InkPresenter.cs
@@ -215,10 +215,7 @@ protected override Size ArrangeOverride(Size arrangeSize)
             // We arrange our child as what Decorator does 
             // exceopt we are using the available size computed from our cached measure size.
             UIElement child = Child;
-            if ( child != null )
-            {
-                child.Arrange(new Rect(availableSize));
-            } 
+            child?.Arrange(new Rect(availableSize)); 
             
             return arrangeSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemCollection.cs
index 3c39b347..338b97fb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemCollection.cs
@@ -256,10 +256,7 @@ public void Clear()
                 throw new InvalidOperationException(SR.Get(SRID.ItemsSourceInUse));
             }
 
-            if (_internalView != null)
-            {
-                _internalView.Clear();
-            }
+            _internalView?.Clear();
             ModelParent.ClearValue(ItemsControl.HasItemsPropertyKey);
         }
 
@@ -937,8 +934,7 @@ bool    IEditableCollectionView.CanAddNew
         /// </summary>
         object  IEditableCollectionView.AddNew()
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 return ecv.AddNew();
             }
@@ -956,8 +952,7 @@ object  IEditableCollectionView.AddNew()
         /// </summary>
         void    IEditableCollectionView.CommitNew()
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.CommitNew();
             }
@@ -973,8 +968,7 @@ void    IEditableCollectionView.CommitNew()
         /// </summary>
         void    IEditableCollectionView.CancelNew()
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.CancelNew();
             }
@@ -1054,8 +1048,7 @@ bool    IEditableCollectionView.CanRemove
         /// </summary>
         void    IEditableCollectionView.RemoveAt(int index)
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.RemoveAt(index);
             }
@@ -1070,8 +1063,7 @@ void    IEditableCollectionView.RemoveAt(int index)
         /// </summary>
         void    IEditableCollectionView.Remove(object item)
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.Remove(item);
             }
@@ -1094,8 +1086,7 @@ void    IEditableCollectionView.Remove(object item)
         /// </summary>
         void    IEditableCollectionView.EditItem(object item)
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.EditItem(item);
             }
@@ -1111,8 +1102,7 @@ void    IEditableCollectionView.EditItem(object item)
         /// </summary>
         void    IEditableCollectionView.CommitEdit()
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.CommitEdit();
             }
@@ -1128,8 +1118,7 @@ void    IEditableCollectionView.CommitEdit()
         /// </summary>
         void    IEditableCollectionView.CancelEdit()
         {
-            IEditableCollectionView ecv = _collectionView as IEditableCollectionView;
-            if (ecv != null)
+            if (_collectionView is IEditableCollectionView ecv)
             {
                 ecv.CancelEdit();
             }
@@ -1235,8 +1224,7 @@ bool    IEditableCollectionViewAddNewItem.CanAddNewItem
         /// </summary>
         object  IEditableCollectionViewAddNewItem.AddNewItem(object newItem)
         {
-            IEditableCollectionViewAddNewItem ani = _collectionView as IEditableCollectionViewAddNewItem;
-            if (ani != null)
+            if (_collectionView is IEditableCollectionViewAddNewItem ani)
             {
                 return ani.AddNewItem(newItem);
             }
@@ -1595,10 +1583,7 @@ internal IEnumerator LogicalChildren
         internal override void GetCollectionChangedSources(int level, Action<int, object, bool?, List<string>> format, List<string> sources)
         {
             format(level, this, false, sources);
-            if (_collectionView != null)
-            {
-                _collectionView.GetCollectionChangedSources(level+1, format, sources);
-            }
+            _collectionView?.GetCollectionChangedSources(level + 1, format, sources);
         }
 
 
@@ -1781,8 +1766,7 @@ void ApplySortFilterAndGroup()
                 }
             }
 
-            ICollectionViewLiveShaping cvls = _collectionView as ICollectionViewLiveShaping;
-            if (cvls != null)
+            if (_collectionView is ICollectionViewLiveShaping cvls)
             {
                 if (MyIsLiveSorting != null && cvls.CanChangeLiveSorting)
                 {
@@ -1818,8 +1802,7 @@ void HookCollectionView(CollectionView view)
                 CollectionChangedEventManager.AddHandler(group, OnInnerGroupDescriptionsChanged);
             }
 
-            ICollectionViewLiveShaping iclvs = view as ICollectionViewLiveShaping;
-            if (iclvs != null)
+            if (view is ICollectionViewLiveShaping iclvs)
             {
                 ObservableCollection<string> liveSortingProperties = iclvs.LiveSortingProperties;
                 if (liveSortingProperties != null)
@@ -1860,8 +1843,7 @@ void UnhookCollectionView(CollectionView view)
                 CollectionChangedEventManager.RemoveHandler(group, OnInnerGroupDescriptionsChanged);
             }
 
-            ICollectionViewLiveShaping iclvs = view as ICollectionViewLiveShaping;
-            if (iclvs != null)
+            if (view is ICollectionViewLiveShaping iclvs)
             {
                 ObservableCollection<string> liveSortingProperties = iclvs.LiveSortingProperties;
                 if (liveSortingProperties != null)
@@ -1883,8 +1865,7 @@ void UnhookCollectionView(CollectionView view)
             }
 
             // cancel any pending AddNew or EditItem transactions
-            IEditableCollectionView iev = _collectionView as IEditableCollectionView;
-            if (iev != null)
+            if (_collectionView is IEditableCollectionView iev)
             {
                 if (iev.IsAddingNew)
                 {
@@ -2078,8 +2059,7 @@ private void LiveSortingChanged(object sender, NotifyCollectionChangedEventArgs
                 return;
 
             // if we have an inner collection view, keep its LiveSortingProperties collection in sync
-            ICollectionViewLiveShaping icvls = _collectionView as ICollectionViewLiveShaping;
-            if (icvls != null)
+            if (_collectionView is ICollectionViewLiveShaping icvls)
             {
                 using (LiveSortingMonitor.Enter())
                 {
@@ -2097,8 +2077,7 @@ private void OnInnerLiveSortingChanged(object sender, NotifyCollectionChangedEve
                 return;
 
             // keep this ItemColl.LiveSortingProperties in sync with inner collection view's
-            ICollectionViewLiveShaping icvls = _collectionView as ICollectionViewLiveShaping;
-            if (icvls != null)
+            if (_collectionView is ICollectionViewLiveShaping icvls)
             {
                 using (LiveSortingMonitor.Enter())
                 {
@@ -2117,8 +2096,7 @@ private void LiveFilteringChanged(object sender, NotifyCollectionChangedEventArg
                 return;
 
             // if we have an inner collection view, keep its LiveFilteringProperties collection in sync
-            ICollectionViewLiveShaping icvls = _collectionView as ICollectionViewLiveShaping;
-            if (icvls != null)
+            if (_collectionView is ICollectionViewLiveShaping icvls)
             {
                 using (LiveFilteringMonitor.Enter())
                 {
@@ -2136,8 +2114,7 @@ private void OnInnerLiveFilteringChanged(object sender, NotifyCollectionChangedE
                 return;
 
             // keep this ItemColl.LiveFilteringProperties in sync with inner collection view's
-            ICollectionViewLiveShaping icvls = _collectionView as ICollectionViewLiveShaping;
-            if (icvls != null)
+            if (_collectionView is ICollectionViewLiveShaping icvls)
             {
                 using (LiveFilteringMonitor.Enter())
                 {
@@ -2156,8 +2133,7 @@ private void LiveGroupingChanged(object sender, NotifyCollectionChangedEventArgs
                 return;
 
             // if we have an inner collection view, keep its LiveGroupingProperties collection in sync
-            ICollectionViewLiveShaping icvls = _collectionView as ICollectionViewLiveShaping;
-            if (icvls != null)
+            if (_collectionView is ICollectionViewLiveShaping icvls)
             {
                 using (LiveGroupingMonitor.Enter())
                 {
@@ -2175,8 +2151,7 @@ private void OnInnerLiveGroupingChanged(object sender, NotifyCollectionChangedEv
                 return;
 
             // keep this ItemColl.LiveGroupingProperties in sync with inner collection view's
-            ICollectionViewLiveShaping icvls = _collectionView as ICollectionViewLiveShaping;
-            if (icvls != null)
+            if (_collectionView is ICollectionViewLiveShaping icvls)
             {
                 using (LiveGroupingMonitor.Enter())
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsControl.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsControl.cs
index 76eefa9d..db3aabc7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsControl.cs
@@ -490,10 +490,7 @@ protected virtual void OnItemTemplateChanged(DataTemplate oldItemTemplate, DataT
         {
             CheckTemplateSource();
 
-            if (_itemContainerGenerator != null)
-            {
-                _itemContainerGenerator.Refresh();
-            }
+            _itemContainerGenerator?.Refresh();
         }
 
 
@@ -718,10 +715,7 @@ protected virtual void OnItemContainerStyleChanged(Style oldItemContainerStyle,
         {
             Helper.CheckStyleAndStyleSelector("ItemContainer", ItemContainerStyleProperty, ItemContainerStyleSelectorProperty, this);
 
-            if (_itemContainerGenerator != null)
-            {
-                _itemContainerGenerator.Refresh();
-            }
+            _itemContainerGenerator?.Refresh();
         }
 
 
@@ -966,10 +960,7 @@ public bool ShouldSerializeGroupStyle()
 
         private void OnGroupStyleChanged(object sender, NotifyCollectionChangedEventArgs e)
         {
-            if (_itemContainerGenerator != null)
-            {
-                _itemContainerGenerator.Refresh();
-            }
+            _itemContainerGenerator?.Refresh();
         }
 
 
@@ -1012,10 +1003,7 @@ private static void OnGroupStyleSelectorChanged(DependencyObject d, DependencyPr
         /// <param name="newGroupStyleSelector">The new value of the GroupStyleSelector property.</param>
         protected virtual void OnGroupStyleSelectorChanged(GroupStyleSelector oldGroupStyleSelector, GroupStyleSelector newGroupStyleSelector)
         {
-            if (_itemContainerGenerator != null)
-            {
-                _itemContainerGenerator.Refresh();
-            }
+            _itemContainerGenerator?.Refresh();
         }
 
         /// <summary>
@@ -1403,10 +1391,7 @@ void IGeneratorHost.PrepareItemContainer(DependencyObject container, object item
             }
 
             TreeViewItem treeViewItem = container as TreeViewItem;
-            if (treeViewItem != null)
-            {
-                treeViewItem.PrepareItemContainer(item, this);
-            }
+            treeViewItem?.PrepareItemContainer(item, this);
         }
 
         /// <summary>
@@ -1428,10 +1413,7 @@ void IGeneratorHost.ClearContainerForItem(DependencyObject container, object ite
                 ClearContainerForItemOverride(container, item);
 
                 TreeViewItem treeViewItem = container as TreeViewItem;
-                if (treeViewItem != null)
-                {
-                    treeViewItem.ClearItemContainer(item, this);
-                }
+                treeViewItem?.ClearItemContainer(item, this);
             }
             else
             {
@@ -1527,10 +1509,7 @@ public override void BeginInit()
         {
             base.BeginInit();
 
-            if (_items != null)
-            {
-                _items.BeginInit();
-            }
+            _items?.BeginInit();
         }
 
         /// <summary>
@@ -1540,10 +1519,7 @@ public override void EndInit()
         {
             if (IsInitPending)
             {
-                if (_items != null)
-                {
-                    _items.EndInit();
-                }
+                _items?.EndInit();
 
                 base.EndInit();
             }
@@ -1709,10 +1685,7 @@ protected override void OnKeyDown(KeyEventArgs e)
                 {
                     TextSearch instance = TextSearch.EnsureInstance(this);
 
-                    if (instance != null)
-                    {
-                        instance.DeleteLastCharacter();
-                    }
+                    instance?.DeleteLastCharacter();
                 }
             }
         }
@@ -1846,10 +1819,7 @@ internal object OnBringItemIntoView(ItemInfo info)
                 }
 
                 VirtualizingPanel itemsHost = ItemsHost as VirtualizingPanel;
-                if (itemsHost != null)
-                {
-                    itemsHost.BringIndexIntoView(info.Index);
-                }
+                itemsHost?.BringIndexIntoView(info.Index);
             }
 
             return null;
@@ -2525,7 +2495,7 @@ private FrameworkElement FindEndFocusableLeafContainer(Panel itemsHost, bool las
                         else
                         {
                             GroupItem groupItem = fe as GroupItem;
-                            if (groupItem != null && groupItem.ItemsHost != null)
+                            if (groupItem?.ItemsHost != null)
                             {
                                 result = FindEndFocusableLeafContainer(groupItem.ItemsHost, last);
                             }
@@ -2883,7 +2853,7 @@ private bool NavigateToFirstItemOnCurrentPage(object startingItem, FocusNavigati
                     }
                 }
 
-                if (returnItem != null && returnItem is CollectionViewGroupInternal)
+                if (returnItem is CollectionViewGroupInternal)
                 {
                     firstElement = currentElement;
                 }
@@ -3788,10 +3758,7 @@ internal ItemInfo LeaseItemInfo(ItemInfo info, bool ensureIndex=false)
         // refresh an ItemInfo
         internal void RefreshItemInfo(ItemInfo info)
         {
-            if (info != null)
-            {
-                info.Refresh(ItemContainerGenerator);
-            }
+            info?.Refresh(ItemContainerGenerator);
         }
 
         [DebuggerDisplay("Index: {Index}  Item: {Item}")]
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsPresenter.cs
index 2714476a..6fe4c7d0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ItemsPresenter.cs
@@ -289,10 +289,7 @@ private void OnPanelChanged(object sender, EventArgs e)
                 // If our logical parent is a ScrollViewer then the visual parent is a ScrollContentPresenter.
                 ScrollContentPresenter scp = VisualTreeHelper.GetParent(this) as ScrollContentPresenter;
 
-                if (scp != null)
-                {
-                    scp.HookupScrollingComponents();
-                }
+                scp?.HookupScrollingComponents();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Label.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Label.cs
index 9e87c074..0ac63952 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Label.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Label.cs
@@ -125,10 +125,7 @@ private static void OnTargetChanged(DependencyObject d, DependencyPropertyChange
                 }
             }
 
-            if (newElement != null)
-            {
-                newElement.SetValue(LabeledByProperty, label);
-            }
+            newElement?.SetValue(LabeledByProperty, label);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBox.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBox.cs
index cb1026a3..162bf309 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBox.cs
@@ -844,10 +844,7 @@ private void MakeAnchorSelection(ListBoxItem actionItem, bool clearCurrent)
                 }
 
                 IDisposable d = enumerator as IDisposable;
-                if (d != null)
-                {
-                    d.Dispose();
-                }
+                d?.Dispose();
             }
             finally
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBoxItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBoxItem.cs
index 3a818976..a9c795fa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBoxItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListBoxItem.cs
@@ -94,10 +94,7 @@ private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyCh
             bool isSelected = (bool) e.NewValue;
 
             Selector parentSelector = listItem.ParentSelector;
-            if (parentSelector != null)
-            {
-                parentSelector.RaiseIsSelectedChangedAutomationEvent(listItem, isSelected);
-            }
+            parentSelector?.RaiseIsSelectedChangedAutomationEvent(listItem, isSelected);
 
             if (isSelected)
             {
@@ -280,10 +277,7 @@ private void HandleMouseButtonDown(MouseButton mouseButton)
             if (Selector.UiGetIsSelectable(this) && Focus())
             {
                 ListBox parent = ParentListBox;
-                if (parent != null)
-                {
-                    parent.NotifyListItemClicked(this, mouseButton);
-                }
+                parent?.NotifyListItemClicked(this, mouseButton);
             }
         }
 
@@ -354,10 +348,7 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
 
             // If earlier, we decided to set focus to the old parent ListBox, do it here
             // after calling base so that the state for IsKeyboardFocusWithin is updated correctly.
-            if (oldItemsControl != null)
-            {
-                oldItemsControl.Focus();
-            }
+            oldItemsControl?.Focus();
         }
 
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListView.cs
index 629a09bf..274362ef 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ListView.cs
@@ -105,8 +105,7 @@ private static void OnViewChanged(DependencyObject d, DependencyPropertyChangedE
             listView._previousView = newView;
 
             //Switch ViewAutomationPeer in ListViewAutomationPeer
-            ListViewAutomationPeer lvPeer = UIElementAutomationPeer.FromElement(listView) as ListViewAutomationPeer;
-            if (lvPeer != null)
+            if (UIElementAutomationPeer.FromElement(listView) is ListViewAutomationPeer lvPeer)
             {
                 if (lvPeer.ViewAutomationPeer != null)
                 {
@@ -150,8 +149,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         {
             base.PrepareContainerForItemOverride(element, item);
 
-            ListViewItem lvi = element as ListViewItem;
-            if (lvi != null)
+            if (element is ListViewItem lvi)
             {
                 ViewBase view = View;
                 if (view != null)
@@ -201,7 +199,7 @@ protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e)
             base.OnItemsChanged(e);
 
             ListViewAutomationPeer lvPeer = UIElementAutomationPeer.FromElement(this) as ListViewAutomationPeer;
-            if (lvPeer != null && lvPeer.ViewAutomationPeer != null)
+            if (lvPeer?.ViewAutomationPeer != null)
             {
                 lvPeer.ViewAutomationPeer.ItemsChanged(e);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Menu.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Menu.cs
index e81b88ae..dbe75bf0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Menu.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Menu.cs
@@ -248,8 +248,8 @@ protected override void OnTextInput(TextCompositionEventArgs e)
                 // We need to exit menu mode because it holds capture and prevents
                 // the system menu from showing.
                 IsMenuMode = false;
-                System.Windows.Interop.HwndSource source = PresentationSource.CriticalFromVisual(this) as System.Windows.Interop.HwndSource;
-                if (source != null)
+
+                if (PresentationSource.CriticalFromVisual(this) is System.Windows.Interop.HwndSource source)
                 {
                     source.ShowSystemMenu();
                     e.Handled = true;
@@ -280,9 +280,8 @@ protected override void HandleMouseButton(MouseButtonEventArgs e)
             // element whose TemplatedParent is the Menu.
             if (IsMenuMode)
             {
-                FrameworkElement element = e.OriginalSource as FrameworkElement;
 
-                if ((element != null && (element == this || element.TemplatedParent == this)))
+                if ((e.OriginalSource is FrameworkElement element && (element == this || element.TemplatedParent == this)))
                 {
                     IsMenuMode = false;
                     e.Handled = true;
@@ -297,15 +296,8 @@ internal override bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArg
 
             if (itemNavigateArgs.DeviceUsed is KeyboardDevice)
             {
-                // If the item is a TopLevelHeader then when you navigate onto it, the submenu will open
-                // and we should select the first item in the submenu.  The parent MenuItem will take care
-                // of opening the submenu but doesn't know whether focus changed because of a mouse action
-                // or a keyboard action.  Help out by focusing the first thing in the new submenu.
-
-                // Assume that KeyboardNavigation.Current.Navigate moved focus onto the element onto which
-                // it navigated.
-                MenuItem newSelection = info.Container as MenuItem;
-                if (newSelection != null
+                // If the item is a TopLevelHeader then when you navigate onto it, the submenu will open                // and we should select the first item in the submenu.  The parent MenuItem will take care                // of opening the submenu but doesn't know whether focus changed because of a mouse action                // or a keyboard action.  Help out by focusing the first thing in the new submenu.                // Assume that KeyboardNavigation.Current.Navigate moved focus onto the element onto which                // it navigated.
+                if (info.Container is MenuItem newSelection
                     && newSelection.Role == MenuItemRole.TopLevelHeader
                     && newSelection.IsSubmenuOpen)
                 {
@@ -351,9 +343,7 @@ private bool OnEnterMenuMode(object sender, EventArgs e)
                 // Give focus to the first possible element in the ItemsControl
                 for (int i = 0; i < Items.Count; i++)
                 {
-                    MenuItem menuItem = ItemContainerGenerator.ContainerFromIndex(i) as MenuItem;
-
-                    if (menuItem != null && !(Items[i] is Separator))
+                    if (ItemContainerGenerator.ContainerFromIndex(i) is MenuItem menuItem && !(Items[i] is Separator))
                     {
                         if (menuItem.Focus())
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/MenuItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/MenuItem.cs
index 18b01f43..621c35ee 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/MenuItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/MenuItem.cs
@@ -597,8 +597,7 @@ private static void OnIsSubmenuOpenChanged(DependencyObject d, DependencyPropert
             menuItem.StopTimer(ref menuItem._openHierarchyTimer);
             menuItem.StopTimer(ref menuItem._closeHierarchyTimer);
 
-            MenuItemAutomationPeer peer = UIElementAutomationPeer.FromElement(menuItem) as MenuItemAutomationPeer;
-            if (peer != null)
+            if (UIElementAutomationPeer.FromElement(menuItem) is MenuItemAutomationPeer peer)
             {
                 peer.ResetChildrenCache();
                 peer.RaiseExpandCollapseAutomationEvent(oldValue, newValue);
@@ -624,8 +623,7 @@ private static void OnIsSubmenuOpenChanged(DependencyObject d, DependencyPropert
                 // Force update of CanExecute when opening menu.
                 for (int i = 0; i < menuItem.Items.Count; i++)
                 {
-                    MenuItem subItem = menuItem.ItemContainerGenerator.ContainerFromIndex(i) as MenuItem;
-                    if (subItem != null && MenuItem.GetBoolField(subItem, BoolField.CanExecuteInvalid))
+                    if (menuItem.ItemContainerGenerator.ContainerFromIndex(i) is MenuItem subItem && MenuItem.GetBoolField(subItem, BoolField.CanExecuteInvalid))
                     {
                         subItem.UpdateCanExecute();
                     }
@@ -1038,9 +1036,8 @@ private static void OnIsSelectedChanged(object sender, RoutedPropertyChangedEven
             if (sender != e.OriginalSource)
             {
                 MenuItem menuItem = (MenuItem)sender;
-                MenuItem source = e.OriginalSource as MenuItem;
 
-                if (source != null)
+                if (e.OriginalSource is MenuItem source)
                 {
                     if (e.NewValue)
                     {
@@ -1127,8 +1124,7 @@ private static object CoerceInputGestureText(DependencyObject d, object value)
                     // Search for the first key gesture
                     for (int i = 0; i < col.Count; i++)
                     {
-                        KeyGesture keyGesture = ((IList)col)[i] as KeyGesture;
-                        if (keyGesture != null)
+                        if (((IList)col)[i] is KeyGesture keyGesture)
                         {
                             return keyGesture.GetDisplayStringForCulture(CultureInfo.CurrentCulture);
                         }
@@ -1305,11 +1301,9 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         /// </summary>
         internal static void PrepareMenuItem(DependencyObject element, object item)
         {
-            MenuItem menuItem = element as MenuItem;
-            if (menuItem != null)
+            if (element is MenuItem menuItem)
             {
-                ICommand command = item as ICommand;
-                if (command != null)
+                if (item is ICommand command)
                 {
                     if (!menuItem.HasNonDefaultValue(CommandProperty))
                     {
@@ -1324,8 +1318,7 @@ internal static void PrepareMenuItem(DependencyObject element, object item)
             }
             else
             {
-                Separator separator = item as Separator;
-                if (separator != null)
+                if (item is Separator separator)
                 {
                     bool hasModifiers;
                     BaseValueSourceInternal vs = separator.GetValueSource(StyleProperty, null, out hasModifiers);
@@ -1570,17 +1563,9 @@ private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs
                 }
                 else
                 {
-                    // This case handles when you have some non-MenuItem in a menu that can be
-                    // the target of access keys, like a Button.
+                    // This case handles when you have some non-MenuItem in a menu that can be                    // the target of access keys, like a Button.                    // MenuItems are a scope for all access keys which are outside of themselves.                    // e.Source is the logical element in which the event was raised.                    // If we can walk from the source to ourselves, then we are not correct                    // scope of this access key; some parent should be.
 
-                    // MenuItems are a scope for all access keys which are outside of themselves.
-                    // e.Source is the logical element in which the event was raised.
-                    // If we can walk from the source to ourselves, then we are not correct
-                    // scope of this access key; some parent should be.
-
-                    DependencyObject source = e.Source as DependencyObject;
-
-                    while (source != null)
+                    while (e.Source is DependencyObject source)
                     {
                         // If we walk up to this Menuitem, we are not the scope.
                         if (source == menuItem)
@@ -1588,10 +1573,8 @@ private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs
                             break;
                         }
 
-                        UIElement uiElement = source as UIElement;
-
                         // If we walk up to an item which is one of our children, we are their scope.
-                        if ((uiElement != null) && (ItemsControlFromItemContainer(uiElement) == menuItem))
+                        if ((source is UIElement uiElement) && (ItemsControlFromItemContainer(uiElement) == menuItem))
                         {
                             isScope = true;
                             break;
@@ -1646,8 +1629,7 @@ protected override void OnMouseLeave(MouseEventArgs  e)
         protected override void OnMouseMove(MouseEventArgs e)
         {
             // Ignore any mouse moves on ourselves while the popup is opening.
-            MenuItem parent = ItemsControl.ItemsControlFromItemContainer(this) as MenuItem;
-            if (parent != null &&
+            if (ItemsControl.ItemsControlFromItemContainer(this) is MenuItem parent &&
                 MenuItem.GetBoolField(parent, BoolField.MouseEnterOnMouseMove))
             {
                 MenuItem.SetBoolField(parent, BoolField.MouseEnterOnMouseMove, false);
@@ -1798,10 +1780,7 @@ private void MouseLeaveInMenuMode(MenuItemRole role)
                         if (IsKeyboardFocusWithin)
                         {
                             ItemsControl parent = ItemsControl.ItemsControlFromItemContainer(this);
-                            if (parent != null)
-                            {
-                                parent.Focus();
-                            }
+                            parent?.Focus();
                         }
                     }
                     else
@@ -2182,9 +2161,7 @@ private void SetMenuMode(bool menuMode)
         {
             Debug.Assert(Role == MenuItemRole.TopLevelHeader || Role == MenuItemRole.TopLevelItem, "MenuItem was not top-level");
 
-            MenuBase parentMenu = LogicalParent as MenuBase;
-
-            if (parentMenu != null)
+            if (LogicalParent is MenuBase parentMenu)
             {
                 if (parentMenu.IsMenuMode != menuMode)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Page.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Page.cs
index ddec5994..fa0ab026 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Page.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Page.cs
@@ -621,10 +621,7 @@ protected override Size ArrangeOverride(Size arrangeBounds)
             {
                 UIElement child = this.GetVisualChild(0) as UIElement;
 
-                if (child != null)
-                {
-                    child.Arrange(new Rect(new Point(), arrangeBounds));
-                }
+                child?.Arrange(new Rect(new Point(), arrangeBounds));
             }
             return arrangeBounds;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PasswordBox.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PasswordBox.cs
index 2d0d60c1..4c9b37fe 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PasswordBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PasswordBox.cs
@@ -487,8 +487,7 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
 
             if (this.RenderScope != null)
             {
-                FrameworkPropertyMetadata fmetadata = e.Property.GetMetadata(typeof(PasswordBox)) as FrameworkPropertyMetadata;
-                if (fmetadata != null)
+                if (e.Property.GetMetadata(typeof(PasswordBox)) is FrameworkPropertyMetadata fmetadata)
                 {
                     if (e.IsAValueChange || e.IsASubPropertyChange)
                     {
@@ -952,9 +951,8 @@ private void SetRenderScopeToContentHost(TextBoxView renderScope)
 
             // Add renderScope as a child of ContentHostTemplateName
             _renderScope = renderScope;
-            if (_passwordBoxContentHost is ScrollViewer)
+            if (_passwordBoxContentHost is ScrollViewer scrollViewer)
             {
-                ScrollViewer scrollViewer = (ScrollViewer)_passwordBoxContentHost;
                 if (scrollViewer.Content != null)
                 {
                     throw new NotSupportedException(SR.Get(SRID.TextBoxScrollViewerMarkedAsTextBoxContentMustHaveNoContent));
@@ -964,9 +962,8 @@ private void SetRenderScopeToContentHost(TextBoxView renderScope)
                     scrollViewer.Content = _renderScope;
                 }
             }
-            else if (_passwordBoxContentHost is Decorator)
+            else if (_passwordBoxContentHost is Decorator decorator)
             {
-                Decorator decorator = (Decorator)_passwordBoxContentHost;
                 if (decorator.Child != null)
                 {
                     throw new NotSupportedException(SR.Get(SRID.TextBoxDecoratorMarkedAsTextBoxContentMustHaveNoContent));
@@ -998,9 +995,9 @@ private void SetRenderScopeToContentHost(TextBoxView renderScope)
             FrameworkElement element = _renderScope;
             while (element != this && element != null)  // checking both just to be safe
             {
-                if (element is Border)
+                if (element is Border border)
                 {
-                    _border = (Border)element;
+                    _border = border;
                 }
                 element = element.Parent as FrameworkElement;
             }
@@ -1013,13 +1010,13 @@ private void ClearContentHost()
 
             // Render scope has been created by us,
             // so we need to extract if from visual tree.
-            if (_passwordBoxContentHost is ScrollViewer)
+            if (_passwordBoxContentHost is ScrollViewer scrollViewer)
             {
-                ((ScrollViewer)_passwordBoxContentHost).Content = null;
+                scrollViewer.Content = null;
             }
-            else if (_passwordBoxContentHost is Decorator)
+            else if (_passwordBoxContentHost is Decorator decorator)
             {
-                ((Decorator)_passwordBoxContentHost).Child = null;
+                decorator.Child = null;
             }
             else
             {
@@ -1117,9 +1114,9 @@ private static void OnPaddingChanged(DependencyObject d, DependencyPropertyChang
             {
                 // translate this change into inner property set on ScrollViewer
                 object padding = passwordBox.GetValue(Control.PaddingProperty);
-                if (padding is Thickness)
+                if (padding is Thickness thickness)
                 {
-                    passwordBox.ScrollViewer.Padding = (Thickness)padding;
+                    passwordBox.ScrollViewer.Padding = thickness;
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PopupControlService.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PopupControlService.cs
index 7a512f3b..05b7fe5f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PopupControlService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/PopupControlService.cs
@@ -538,10 +538,7 @@ private void RaiseToolTipClosingEvent(bool reset)
                         if (isOpen)
                         {
                             IInputElement element = o as IInputElement;
-                            if (element != null)
-                            {
-                                element.RaiseEvent(new ToolTipEventArgs(false));
-                            }
+                            element?.RaiseEvent(new ToolTipEventArgs(false));
                         }
                     }
                     finally
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CalendarItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CalendarItem.cs
index 29cc92bb..0d674911 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CalendarItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CalendarItem.cs
@@ -353,8 +353,7 @@ internal IEnumerable<CalendarDayButton> GetCalendarDayButtons()
                 UIElementCollection dayButtonsHost = MonthView.Children;
                 for (int childIndex = COLS; childIndex < count; childIndex++)
                 {
-                    CalendarDayButton b = dayButtonsHost[childIndex] as CalendarDayButton;
-                    if (b != null)
+                    if (dayButtonsHost[childIndex] is CalendarDayButton b)
                     {
                         yield return b;
                     }
@@ -436,8 +435,7 @@ private IEnumerable<CalendarButton> GetCalendarButtons()
         {
             foreach (UIElement element in this.YearView.Children)
             {
-                CalendarButton b = element as CalendarButton;
-                if (b != null)
+                if (element is CalendarButton b)
                 {
                     yield return b;
                 }
@@ -494,8 +492,7 @@ private int GetDecadeForDecadeMode(DateTime selectedYear)
 
                 if (count > 0)
                 {
-                    CalendarButton child = yearViewChildren[0] as CalendarButton;
-                    if (child != null &&
+                    if (yearViewChildren[0] is CalendarButton child &&
                         child.DataContext is DateTime &&
                         ((DateTime)child.DataContext).Year == selectedYear.Year)
                     {
@@ -505,8 +502,7 @@ private int GetDecadeForDecadeMode(DateTime selectedYear)
 
                 if (count > 1)
                 {
-                    CalendarButton child = yearViewChildren[count - 1] as CalendarButton;
-                    if (child != null &&
+                    if (yearViewChildren[0] is CalendarButton child &&
                         child.DataContext is DateTime &&
                         ((DateTime)child.DataContext).Year == selectedYear.Year)
                     {
@@ -872,8 +868,7 @@ private void FinishSelection(DateTime selectedDate)
 
         private void Month_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
         {
-            CalendarButton b = sender as CalendarButton;
-            if (b != null)
+            if (sender is CalendarButton b)
             {
                 this._isMonthPressed = true;
                 Mouse.Capture(this, CaptureMode.SubTree);
@@ -887,8 +882,7 @@ private void Month_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
 
         private void Month_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
         {
-            CalendarButton b = sender as CalendarButton;
-            if (b != null && this.Owner != null)
+            if (sender is CalendarButton b && this.Owner != null)
             {
                 this.Owner.OnCalendarButtonPressed(b, true);
             }
@@ -896,8 +890,7 @@ private void Month_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
 
         private void Month_MouseEnter(object sender, MouseEventArgs e)
         {
-            CalendarButton b = sender as CalendarButton;
-            if (b != null)
+            if (sender is CalendarButton b)
             {
                 if (this._isMonthPressed && this.Owner != null)
                 {
@@ -908,8 +901,7 @@ private void Month_MouseEnter(object sender, MouseEventArgs e)
 
         private void Month_Clicked(object sender, RoutedEventArgs e)
         {
-            CalendarButton b = sender as CalendarButton;
-            if (b != null)
+            if (sender is CalendarButton b)
             {
                 this.Owner.OnCalendarButtonPressed(b, true);
             }
@@ -1022,9 +1014,8 @@ private void SetMonthModeDayTitles()
                 
                 for (int childIndex = 0; childIndex < COLS; childIndex++)
                 {
-                    FrameworkElement daytitle = _monthView.Children[childIndex] as FrameworkElement;
                     
-                    if (daytitle != null && shortestDayNames != null && shortestDayNames.Length > 0)
+                    if (_monthView.Children[childIndex] is FrameworkElement daytitle && shortestDayNames != null && shortestDayNames.Length > 0)
                     {
                         if (this.Owner != null)
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CustomPopupPlacement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CustomPopupPlacement.cs
index 0c48bcaf..63bb3963 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CustomPopupPlacement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/CustomPopupPlacement.cs
@@ -83,9 +83,8 @@ public PopupPrimaryAxis PrimaryAxis
         /// <returns>True if equivalent. False otherwise.</returns>
         public override bool Equals(object o)
         {
-            if (o is CustomPopupPlacement)
+            if (o is CustomPopupPlacement placement)
             {
-                CustomPopupPlacement placement = (CustomPopupPlacement)o;
                 return (placement._primaryAxis == _primaryAxis) && (placement._point == _point);
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridCellsPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridCellsPresenter.cs
index 6b9fe395..81eb3e83 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridCellsPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridCellsPresenter.cs
@@ -113,10 +113,8 @@ internal void SyncProperties(bool forcePrepareCells)
             // This is a convenient way to walk through all cells and force them to call CoerceValue(StyleProperty)
             NotifyPropertyChanged(this, new DependencyPropertyChangedEventArgs(DataGrid.CellStyleProperty, null, null), DataGridNotificationTarget.Cells);
 
-            // We may have missed an Add / Remove of a column from the grid (DataGridRow.OnColumnsChanged)
-            // Sync the MultipleCopiesCollection count and update the Column on changed cells
-            MultipleCopiesCollection cellItems = ItemsSource as MultipleCopiesCollection;
-            if (cellItems != null)
+            // We may have missed an Add / Remove of a column from the grid (DataGridRow.OnColumnsChanged)            // Sync the MultipleCopiesCollection count and update the Column on changed cells
+            if (ItemsSource is MultipleCopiesCollection cellItems)
             {
                 DataGridCell cell;
                 ObservableCollection<DataGridColumn> columns = dataGridOwner.Columns;
@@ -137,11 +135,8 @@ internal void SyncProperties(bool forcePrepareCells)
                 {
                     dirtyCount = newColumnCount;
                 }
-
-                // if the DataGridCellsPanel missed out on some column virtualization
-                // activity while the row was virtualized, it needs to be measured
-                DataGridCellsPanel cellsPanel = InternalItemsHost as DataGridCellsPanel;
-                if (cellsPanel != null)
+                // if the DataGridCellsPanel missed out on some column virtualization                // activity while the row was virtualized, it needs to be measured
+                if (InternalItemsHost is DataGridCellsPanel cellsPanel)
                 {
                     if (cellsPanel.HasCorrectRealizedColumns)
                     {
@@ -345,10 +340,7 @@ protected internal virtual void OnColumnsChanged(ObservableCollection<DataGridCo
         {
             // Update the ItemsSource for the cells
             MultipleCopiesCollection cellItems = ItemsSource as MultipleCopiesCollection;
-            if (cellItems != null)
-            {
-                cellItems.MirrorCollectionChange(e);
-            }
+            cellItems?.MirrorCollectionChange(e);
 
             // For a reset event the only thing the MultipleCopiesCollection can do is set its count to 0.
             Debug.Assert(
@@ -542,7 +534,7 @@ private void InvalidateDataGridCellsPanelMeasureAndArrangeImpl(bool invalidateMe
                 if(invalidateMeasureUptoRowsPresenter)
                 {
                     DataGrid dataGrid = DataGridOwner;
-                    if(dataGrid != null && dataGrid.InternalItemsHost != null)
+                    if(dataGrid?.InternalItemsHost != null)
                     {
                         Helper.InvalidateMeasureOnPath(_internalItemsHost, dataGrid.InternalItemsHost, false/*duringMeasure*/, true/*includePathEnd*/);
                     }
@@ -583,8 +575,7 @@ internal Panel InternalItemsHost
         /// <param name="index"></param>
         internal void ScrollCellIntoView(int index)
         {
-            DataGridCellsPanel itemsHost = InternalItemsHost as DataGridCellsPanel;
-            if (itemsHost != null)
+            if (InternalItemsHost is DataGridCellsPanel itemsHost)
             {
                 itemsHost.InternalBringIndexIntoView(index);
                 return;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeader.cs
index 63114185..b8155682 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeader.cs
@@ -197,10 +197,7 @@ private static void OnDisplayIndexChanged(DependencyObject d, DependencyProperty
                 {
                     header.SetLeftGripperVisibility();
                     DataGridColumnHeader nextColumnHeader = dataGrid.ColumnHeaderFromDisplayIndex(header.DisplayIndex + 1);
-                    if (nextColumnHeader != null)
-                    {
-                        nextColumnHeader.SetLeftGripperVisibility(column.CanUserResize);
-                    }
+                    nextColumnHeader?.SetLeftGripperVisibility(column.CanUserResize);
                 }
             }
         }
@@ -365,7 +362,7 @@ private void OnGripperDoubleClicked(object sender, MouseButtonEventArgs e)
         {
             DataGridColumnHeader header = HeaderToResize(sender);
 
-            if (header != null && header.Column != null)
+            if (header?.Column != null)
             {
                 // DataGridLength is a struct, so setting to Auto resets desired and display widths to 0.0.
                 header.Column.Width = DataGridLength.Auto;
@@ -553,10 +550,7 @@ private void SetNextHeaderLeftGripperVisibility(bool canUserResize)
                 if (dataGrid.ColumnFromDisplayIndex(index).IsVisible)
                 {
                     DataGridColumnHeader nextHeader = dataGrid.ColumnHeaderFromDisplayIndex(index);
-                    if (nextHeader != null)
-                    {
-                        nextHeader.SetLeftGripperVisibility(canUserResize);
-                    }
+                    nextHeader?.SetLeftGripperVisibility(canUserResize);
                     break;
                 }
             }
@@ -763,10 +757,7 @@ protected override void OnClick()
                 if (AutomationPeer.ListenerExists(AutomationEvents.InvokePatternOnInvoked))
                 {
                     AutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(this);
-                    if (peer != null)
-                    {
-                        peer.RaiseAutomationEvent(AutomationEvents.InvokePatternOnInvoked);
-                    }
+                    peer?.RaiseAutomationEvent(AutomationEvents.InvokePatternOnInvoked);
                 }
 
                 base.OnClick();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeadersPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeadersPresenter.cs
index e3a3cb87..05a9460e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeadersPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridColumnHeadersPresenter.cs
@@ -77,8 +77,7 @@ public override void OnApplyTemplate()
                 grid.ColumnHeadersPresenter = this;
                 DataGridHelper.TransferProperty(this, VirtualizingPanel.IsVirtualizingProperty);
 
-                DataGridColumnHeader fillerColumnHeader = GetTemplateChild(ElementFillerColumnHeader) as DataGridColumnHeader;
-                if (fillerColumnHeader != null)
+                if (GetTemplateChild(ElementFillerColumnHeader) is DataGridColumnHeader fillerColumnHeader)
                 {
                     DataGridHelper.TransferProperty(fillerColumnHeader, DataGridColumnHeader.StyleProperty);
                     DataGridHelper.TransferProperty(fillerColumnHeader, DataGridColumnHeader.HeightProperty);
@@ -224,9 +223,7 @@ internal bool IsItemItsOwnContainerInternal(object item)
         /// <param name="item">The item that the container represents.</param>
         protected override void PrepareContainerForItemOverride(DependencyObject element, object item)
         {
-            DataGridColumnHeader header = element as DataGridColumnHeader;
-
-            if (header != null)
+            if (element is DataGridColumnHeader header)
             {
                 DataGridColumn column = ColumnFromContainer(header);
                 Debug.Assert(column != null, "We shouldn't have generated this column header if we don't have a column.");
@@ -252,11 +249,10 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         /// <param name="item">The data item that the container represented.</param>
         protected override void ClearContainerForItemOverride(DependencyObject element, object item)
         {
-            DataGridColumnHeader header = element as DataGridColumnHeader;
 
             base.ClearContainerForItemOverride(element, item);
 
-            if (header != null)
+            if (element is DataGridColumnHeader header)
             {
                 header.Tracker.StopTracking(ref _headerTrackingRoot);
                 header.ClearHeader();
@@ -334,10 +330,7 @@ internal void NotifyPropertyChanged(DependencyObject d, string propertyName, Dep
             {
                 if (e.Property == DataGridColumn.HeaderProperty)
                 {
-                    if (HeaderCollection != null)
-                    {
-                        HeaderCollection.NotifyHeaderPropertyChanged(column, e);
-                    }
+                    HeaderCollection?.NotifyHeaderPropertyChanged(column, e);
                 }
                 else
                 {
@@ -355,10 +348,7 @@ internal void NotifyPropertyChanged(DependencyObject d, string propertyName, Dep
                         (e.Property == DataGrid.ColumnHeaderStyleProperty || e.Property == DataGrid.ColumnHeaderHeightProperty) )
                     {
                         DataGridColumnHeader fillerColumnHeader = GetTemplateChild(ElementFillerColumnHeader) as DataGridColumnHeader;
-                        if (fillerColumnHeader != null)
-                        {
-                            fillerColumnHeader.NotifyPropertyChanged(d, e);
-                        }
+                        fillerColumnHeader?.NotifyPropertyChanged(d, e);
                     }
                 }
             }
@@ -825,10 +815,7 @@ private void FinishColumnHeaderDrag(bool isCancel)
             {
                 _columnHeaderDragIndicator.Visibility = Visibility.Collapsed;
                 DataGridColumnFloatingHeader floatingHeader = _columnHeaderDragIndicator as DataGridColumnFloatingHeader;
-                if (floatingHeader != null)
-                {
-                    floatingHeader.ClearHeader();
-                }
+                floatingHeader?.ClearHeader();
 
                 RemoveVisualChild(_columnHeaderDragIndicator);
             }
@@ -836,8 +823,8 @@ private void FinishColumnHeaderDrag(bool isCancel)
             if (_columnHeaderDropLocationIndicator != null)
             {
                 _columnHeaderDropLocationIndicator.Visibility = Visibility.Collapsed;
-                DataGridColumnDropSeparator separator = _columnHeaderDropLocationIndicator as DataGridColumnDropSeparator;
-                if (separator != null)
+
+                if (_columnHeaderDropLocationIndicator is DataGridColumnDropSeparator separator)
                 {
                     separator.ReferenceHeader = null;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowHeader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowHeader.cs
index cdbb2118..d19065fb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowHeader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowHeader.cs
@@ -295,10 +295,8 @@ internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChange
                 this.InvalidateMeasure();
                 this.InvalidateArrange();
 
-                // If the DataGrid has not run layout the headers parent may not position the cells correctly when the header size changes.
-                // This will cause the cells to be out of sync with the columns. To avoid this we will force a layout of the headers parent panel.
-                var parent = this.Parent as UIElement;
-                if (parent != null)
+                // If the DataGrid has not run layout the headers parent may not position the cells correctly when the header size changes.                // This will cause the cells to be out of sync with the columns. To avoid this we will force a layout of the headers parent panel.
+                if (this.Parent is UIElement parent)
                 {
                     parent.InvalidateMeasure();
                     parent.InvalidateArrange();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowsPresenter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowsPresenter.cs
index 6bf07496..306ac90e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowsPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DataGridRowsPresenter.cs
@@ -51,13 +51,8 @@ protected override void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItem
                 DataGrid dataGrid = Owner;
                 if (dataGrid != null)
                 {
-                    // ItemsHost should be the "root" element which has
-                    // IsItemsHost = true on it.  In the case of grouping,
-                    // IsItemsHost is true on all panels which are generating
-                    // content.  Thus, we care only about the panel which
-                    // is generating content for the ItemsControl.
-                    IItemContainerGenerator generator = dataGrid.ItemContainerGenerator as IItemContainerGenerator;
-                    if (generator != null && generator == generator.GetItemContainerGeneratorForPanel(this))
+                    // ItemsHost should be the "root" element which has                    // IsItemsHost = true on it.  In the case of grouping,                    // IsItemsHost is true on all panels which are generating                    // content.  Thus, we care only about the panel which                    // is generating content for the ItemsControl.
+                    if (dataGrid.ItemContainerGenerator is IItemContainerGenerator generator && generator == generator.GetItemContainerGeneratorForPanel(this))
                     {
                         dataGrid.InternalItemsHost = this;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DatePickerTextBox.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DatePickerTextBox.cs
index c9fff7ac..fd61d136 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DatePickerTextBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DatePickerTextBox.cs
@@ -175,8 +175,7 @@ private void OnWatermarkChanged()
         {
             if (elementContent != null)
             {
-                Control watermarkControl = this.Watermark as Control;
-                if (watermarkControl != null)
+                if (this.Watermark is Control watermarkControl)
                 {
                     watermarkControl.IsTabStop = false;
                     watermarkControl.IsHitTestVisible = false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentPageView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentPageView.cs
index 21b32396..2d56c38c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentPageView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentPageView.cs
@@ -517,7 +517,7 @@ protected object GetService(Type serviceType)
 
             // No service is available if the Content does not provide
             // any services.
-            if (_documentPaginator != null && _documentPaginator is IServiceProvider)
+            if (_documentPaginator is IServiceProvider iServiceProvider)
             {
                 // Following services are available:
                 // (1) TextView - wrapper for TextView exposed by the current page.
@@ -526,8 +526,7 @@ protected object GetService(Type serviceType)
                 {
                     if (_textView == null)
                     {
-                        ITextContainer tc = ((IServiceProvider)_documentPaginator).GetService(typeof(ITextContainer)) as ITextContainer;
-                        if (tc != null)
+                        if (iServiceProvider.GetService(typeof(ITextContainer)) is ITextContainer tc)
                         {
                             _textView = new DocumentPageTextView(this, tc);
                         }
@@ -791,10 +790,7 @@ private object OnTransformChanged(object arg)
         private void OnPageConnected()
         {
             _newPageConnected = false;
-            if (_textView != null)
-            {
-                _textView.OnPageConnected();
-            }
+            _textView?.OnPageConnected();
             if (this.PageConnected != null && _documentPage != null)
             {
                 this.PageConnected(this, EventArgs.Empty);
@@ -806,10 +802,7 @@ private void OnPageConnected()
         /// </summary>
         private void OnPageDisconnected()
         {
-            if (_textView != null)
-            {
-                _textView.OnPageDisconnected();
-            }
+            _textView?.OnPageDisconnected();
             if (this.PageDisconnected != null)
             {
                 this.PageDisconnected(this, EventArgs.Empty);
@@ -847,9 +840,9 @@ private void DisposeCurrentPage()
                 {
                     _documentPage.PageDestroyed -= new EventHandler(HandlePageDestroyed);                    
                 }
-                if (_documentPage is IDisposable)
+                if (_documentPage is IDisposable iDisposable)
                 {
-                    ((IDisposable)_documentPage).Dispose();
+                    iDisposable.Dispose();
                 }
                 _documentPage = null;               
 
@@ -869,9 +862,9 @@ private void DisposeAsyncPage()
                 {
                     _documentPageAsync.PageDestroyed -= new EventHandler(HandleAsyncPageDestroyed);                    
                 }
-                if (_documentPageAsync is IDisposable)
+                if (_documentPageAsync is IDisposable iDisposable)
                 {
-                    ((IDisposable)_documentPageAsync).Dispose();
+                    iDisposable.Dispose();
                 }                
                 _documentPageAsync = null;
             }
@@ -931,9 +924,9 @@ private DocumentViewerBase GetHostViewer()
                 visualParent = VisualTreeHelper.GetParent(this) as Visual;
                 while (visualParent != null)
                 {
-                    if (visualParent is DocumentViewerBase)
+                    if (visualParent is DocumentViewerBase documentViewerBase)
                     {
-                        hostViewer = (DocumentViewerBase)visualParent;
+                        hostViewer = documentViewerBase;
                         break;
                     }
                     visualParent = VisualTreeHelper.GetParent(visualParent) as Visual;
@@ -948,7 +941,7 @@ private DocumentViewerBase GetHostViewer()
         /// </summary>
         private static void OnPageNumberChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is DocumentPageView);
+            Invariant.Assert(d is DocumentPageView);
             ((DocumentPageView)d).OnPageContentChanged();
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentViewerBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentViewerBase.cs
index a6311632..7f95b515 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentViewerBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/DocumentViewerBase.cs
@@ -626,10 +626,7 @@ protected virtual void OnPrintCommand()
         protected virtual void OnCancelPrintCommand()
         {
 #if !DONOTREFPRINTINGASMMETA
-            if (_documentWriter != null)
-            {
-                _documentWriter.CancelAsync();
-            }
+            _documentWriter?.CancelAsync();
 #endif // DONOTREFPRINTINGASMMETA
         }
 
@@ -712,7 +709,7 @@ internal ITextRange Find(FindToolBar findToolBar)
         {
             ITextView masterPageTextView = null;
             DocumentPageView masterPage = GetMasterPageView();
-            if (masterPage != null && masterPage is IServiceProvider)
+            if (masterPage is IServiceProvider)
             {
                 masterPageTextView = ((IServiceProvider)masterPage).GetService(typeof(ITextView)) as ITextView;
             }
@@ -791,7 +788,7 @@ private ITextPointer GetMasterPageTextPointer(bool startOfPage)
             ITextView textView = null;
             DocumentPageView masterPage = GetMasterPageView();
 
-            if (masterPage != null && masterPage is IServiceProvider)
+            if (masterPage is IServiceProvider)
             {
                 textView = ((IServiceProvider)masterPage).GetService(typeof(ITextView)) as ITextView;
                 if (textView != null && textView.IsValid)
@@ -867,10 +864,7 @@ private void UpdatePageViews()
 
                 // Collection of DocumentPageView has been changed. Need to update
                 // TextView, if one already exists.
-                if (_textView != null)
-                {
-                    _textView.OnPagesUpdated();
-                }
+                _textView?.OnPagesUpdated();
 
                 // DocumentPageViews collection has been changed. Notify all listeners
                 // and/or derived classes about this fact.
@@ -1034,11 +1028,7 @@ private void AttachTextEditor()
                 _textView = null;
             }
 
-            if (service != null)
-            {
-                // Must be enabled - otherwise it won't be on the tree
-                service.Disable();
-            }
+            service?.Disable();
 
             // If new Document supports TextEditor, create one.
             // If the Document is already attached to TextEditor (TextSelection != null), 
@@ -1055,10 +1045,7 @@ private void AttachTextEditor()
             }
 
             // Re-enable the service in order to register on the new TextView
-            if (service != null)
-            {
-                service.Enable(service.Store);
-            }
+            service?.Enable(service.Store);
         }
 
         /// <summary>
@@ -1141,7 +1128,7 @@ private void HandleRequestBringIntoView(RequestBringIntoViewEventArgs args)
             DynamicDocumentPaginator documentPaginator;
             Rect targetRect = Rect.Empty;
 
-            if (args != null && args.TargetObject != null && _document is DependencyObject)
+            if (args?.TargetObject != null && _document is DependencyObject)
             {
                 // If the passed in object is a logical child of DocumentViewer's Document,
                 // attempt to make it visible now.
@@ -1163,7 +1150,7 @@ private void HandleRequestBringIntoView(RequestBringIntoViewEventArgs args)
                         // walk up logical tree to find if the focused element is within
                         // the document.
                         FrameworkElement fe = child as FrameworkElement;
-                        if (fe != null && fe.TemplatedParent != null)
+                        if (fe?.TemplatedParent != null)
                         {
                             child = fe.TemplatedParent;
                         }
@@ -1344,10 +1331,7 @@ private void DocumentChanged(IDocumentPaginatorSource oldDocument, IDocumentPagi
                 }
 
                 DependencyObject depObj = oldDocument as DependencyObject;
-                if (depObj != null)
-                {
-                    depObj.ClearValue(PathNode.HiddenParentProperty);
-                }
+                depObj?.ClearValue(PathNode.HiddenParentProperty);
             }
 
             // If DocumentViewer was created through style, then do not modify
@@ -1427,10 +1411,7 @@ private void DocumentChanged(IDocumentPaginatorSource oldDocument, IDocumentPagi
 
             // Document is also represented as Automation child. Need to invalidate peer to force update.
             DocumentViewerBaseAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as DocumentViewerBaseAutomationPeer;
-            if (peer != null)
-            {
-                peer.InvalidatePeer();
-            }
+            peer?.InvalidatePeer();
 
             // Respond to Document change - update state that is affected by this change.
             OnDocumentChanged();
@@ -1611,7 +1592,7 @@ private static void ExecutedRoutedEventHandler(object target, ExecutedRoutedEven
         /// <param name="args">RequestBringIntoViewEventArgs indicates the element and region to scroll into view.</param>
         private static void HandleRequestBringIntoView(object sender, RequestBringIntoViewEventArgs args)
         {
-            if (sender != null && sender is DocumentViewerBase)
+            if (sender is DocumentViewerBase)
             {
                 ((DocumentViewerBase)sender).HandleRequestBringIntoView(args);
             }
@@ -1622,7 +1603,7 @@ private static void HandleRequestBringIntoView(object sender, RequestBringIntoVi
         /// </summary>
         private static void DocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is DocumentViewerBase);
+            Invariant.Assert(d is DocumentViewerBase);
             ((DocumentViewerBase) d).DocumentChanged((IDocumentPaginatorSource) e.OldValue, (IDocumentPaginatorSource) e.NewValue);
 
             // Since Document state is used to determine CanExecute state, we must invalidate that state.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/GridViewRowPresenterBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/GridViewRowPresenterBase.cs
index 315894d4..d34b92aa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/GridViewRowPresenterBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/GridViewRowPresenterBase.cs
@@ -332,9 +332,7 @@ bool IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventA
         /// </summary>
         private void ColumnCollectionChanged(object sender, NotifyCollectionChangedEventArgs arg)
         {
-            GridViewColumnCollectionChangedEventArgs e = arg as GridViewColumnCollectionChangedEventArgs;
-
-            if (e != null
+            if (arg is GridViewColumnCollectionChangedEventArgs e
                 && IsPresenterVisualReady)// if and only if rowpresenter's visual is ready, shall rowpresenter go ahead process the event.
             {
                 // Property of one column changed
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationConstraints.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationConstraints.cs
index 25bf9dbe..f6ddd30f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationConstraints.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationConstraints.cs
@@ -101,9 +101,8 @@ public Rect Viewport
         /// and Viewport as oCompare.</returns>
         override public bool Equals(object oCompare)
         {
-            if (oCompare is HierarchicalVirtualizationConstraints)
+            if (oCompare is HierarchicalVirtualizationConstraints constraints)
             {
-                HierarchicalVirtualizationConstraints constraints = (HierarchicalVirtualizationConstraints)oCompare;
                 return (this == constraints);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationHeaderDesiredSizes.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationHeaderDesiredSizes.cs
index 9c23c82f..b3f6ff61 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationHeaderDesiredSizes.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationHeaderDesiredSizes.cs
@@ -84,9 +84,8 @@ public Size PixelSize
         /// and pixel sizes as oCompare.</returns>
         override public bool Equals(object oCompare)
         {
-            if (oCompare is HierarchicalVirtualizationHeaderDesiredSizes)
+            if (oCompare is HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes)
             {
-                HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes = (HierarchicalVirtualizationHeaderDesiredSizes)oCompare;
                 return (this == headerDesiredSizes);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationItemDesiredSizes.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationItemDesiredSizes.cs
index d0f3d1a5..d67c415b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationItemDesiredSizes.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/HierarchicalVirtualizationItemDesiredSizes.cs
@@ -175,9 +175,8 @@ public Size PixelSizeAfterViewport
         /// and pixel sizes as oCompare.</returns>
         override public bool Equals(object oCompare)
         {
-            if (oCompare is HierarchicalVirtualizationItemDesiredSizes)
+            if (oCompare is HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes)
             {
-                HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes = (HierarchicalVirtualizationItemDesiredSizes)oCompare;
                 return (this == itemDesiredSizes);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/IItemContainerGenerator.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/IItemContainerGenerator.cs
index b532809d..640181d7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/IItemContainerGenerator.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/IItemContainerGenerator.cs
@@ -160,9 +160,8 @@ public override string ToString()
         // This is required by FxCop.
         public override bool Equals(object o)
         {
-            if (o is GeneratorPosition)
+            if (o is GeneratorPosition that)
             {
-                GeneratorPosition that = (GeneratorPosition)o;
                 return  this._index == that._index &&
                         this._offset == that._offset;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Popup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Popup.cs
index 66e4b076..b9af3eed 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Popup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Popup.cs
@@ -1133,8 +1133,8 @@ private void EstablishPopupCapture(bool isRestoringCapture=false)
                 (!StaysOpen))
             {
                 IInputElement capturedElement = Mouse.Captured;
-                PopupRoot parentPopupRoot = capturedElement as PopupRoot;
-                if (parentPopupRoot != null)
+
+                if (capturedElement is PopupRoot parentPopupRoot)
                 {
                     if (isRestoringCapture)
                     {
@@ -1190,10 +1190,7 @@ private void ReleasePopupCapture()
                     {
                         // restore capture to popup we took it from, if there was one
                         Popup parentPopup = parentPopupRoot.Parent as Popup;
-                        if (parentPopup != null)
-                        {
-                            parentPopup.EstablishPopupCapture(isRestoringCapture:true);
-                        }
+                        parentPopup?.EstablishPopupCapture(isRestoringCapture: true);
                     }
                 }
                 _cacheValid[(int)CacheBits.CaptureEngaged] = false;
@@ -2377,11 +2374,8 @@ private Point[] GetChildInterestPoints(PlacementMode placement)
 
             Point[] interestPoints = InterestPointsFromRect(new Rect(new Point(), child.RenderSize));
 
-
-            UIElement target = GetTarget() as UIElement;
-
             // Popup positioning is based on the PlacementTarget or the Placement mode
-            if (target != null && !IsAbsolutePlacementMode(placement))
+            if (GetTarget() is UIElement target && !IsAbsolutePlacementMode(placement))
             {
                 // In scenarios where the flow direction is different between the
                 // child and target, the child rect should be treated as it is flipped
@@ -2981,9 +2975,8 @@ internal bool IsWindowAlive()
             internal Point ClientToScreen(Visual rootVisual, Point clientPoint)
             {
                 // Get the HwndSource of the target element.
-                HwndSource targetWindow = PopupSecurityHelper.GetPresentationSource(rootVisual) as HwndSource;
 
-                if (targetWindow != null)
+                if (PopupSecurityHelper.GetPresentationSource(rootVisual) is HwndSource targetWindow)
                 {
                     return PointUtil.ToPoint(ClientToScreen(targetWindow, clientPoint));
                 }
@@ -3028,9 +3021,7 @@ internal NativeMethods.POINT GetMouseCursorPos(Visual targetVisual)
                         hwndSource = PopupSecurityHelper.GetPresentationSource(targetVisual) as HwndSource;
                     }
 
-                    IInputElement relativeTarget = targetVisual as IInputElement;
-
-                    if (relativeTarget != null)
+                    if (targetVisual is IInputElement relativeTarget)
                     {
                         Point pt = Mouse.GetPosition(relativeTarget);
 
@@ -3245,15 +3236,12 @@ private static Visual FindMainTreeVisual(Visual v)
                 {
                     root = dependencyObject;
 
-                    PopupRoot popupRoot = dependencyObject as PopupRoot;
-                    if (popupRoot != null)
+                    if (dependencyObject is PopupRoot popupRoot)
                     {
                         dependencyObject= popupRoot.Parent;
-
                         // Look for the placement target of the popup
-                        Popup popup = dependencyObject as Popup;
 
-                        if (popup != null)
+                        if (dependencyObject is Popup popup)
                         {
                             UIElement target = popup.PlacementTarget;
                             if (target != null)
@@ -3288,13 +3276,12 @@ private static Visual FindMainTreeVisual(Visual v)
                     // before querying for the presentation source.
                     mainTreeVisual = FindMainTreeVisual(placementTarget);
                 }
-
                 // get visual's PresentationSource
-                HwndSource hwndSource = PopupSecurityHelper.GetPresentationSource(mainTreeVisual) as HwndSource;
 
                 // get parent handle
                 IntPtr parent = IntPtr.Zero;
-                if (hwndSource != null)
+
+                if (PopupSecurityHelper.GetPresentationSource(mainTreeVisual) is HwndSource hwndSource)
                 {
                     parent = PopupSecurityHelper.GetHandle(hwndSource);
                 }
@@ -3429,8 +3416,7 @@ internal void ForceMsaaToUiaBridge(PopupRoot popupRoot)
             {
                 if (Handle != IntPtr.Zero && (UnsafeNativeMethods.IsWinEventHookInstalled(NativeMethods.EVENT_OBJECT_FOCUS) || UnsafeNativeMethods.IsWinEventHookInstalled(NativeMethods.EVENT_OBJECT_STATECHANGE)))
                 {
-                    PopupRootAutomationPeer popupRootAutomationPeer = UIElementAutomationPeer.CreatePeerForElement(popupRoot) as PopupRootAutomationPeer;
-                    if (popupRootAutomationPeer != null)
+                    if (UIElementAutomationPeer.CreatePeerForElement(popupRoot) is PopupRootAutomationPeer popupRootAutomationPeer)
                     {
                         if (popupRootAutomationPeer.Hwnd == IntPtr.Zero)
                             popupRootAutomationPeer.Hwnd = Handle;
@@ -3529,8 +3515,7 @@ internal static bool IsPerMonitorDpiScalingActive
             /// </summary>
             private static NativeMethods.POINTSTRUCT? GetPlacementTargetOriginInScreenCoordinates(Popup popup)
             {
-                var target = popup?.GetTarget() as UIElement;
-                if (target != null)
+                if (popup?.GetTarget()is UIElement target)
                 {
                     var rootVisual = Popup.GetRootVisual(target);
                     var targetToClientTransform = Popup.TransformToClient(target, rootVisual);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RangeBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RangeBase.cs
index 4d68bd15..a9fe6218 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RangeBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RangeBase.cs
@@ -103,10 +103,7 @@ private static void OnMinimumChanged(DependencyObject d, DependencyPropertyChang
             RangeBase ctrl = (RangeBase) d;
 
             RangeBaseAutomationPeer peer = UIElementAutomationPeer.FromElement(ctrl) as RangeBaseAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseMinimumPropertyChangedEvent((double)e.OldValue, (double)e.NewValue);
-            }
+            peer?.RaiseMinimumPropertyChangedEvent((double)e.OldValue, (double)e.NewValue);
 
             ctrl.CoerceValue(MaximumProperty);
             ctrl.CoerceValue(ValueProperty);
@@ -167,10 +164,7 @@ private static void OnMaximumChanged(DependencyObject d, DependencyPropertyChang
             RangeBase ctrl = (RangeBase) d;
 
             RangeBaseAutomationPeer peer = UIElementAutomationPeer.FromElement(ctrl) as RangeBaseAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseMaximumPropertyChangedEvent((double)e.OldValue, (double)e.NewValue);
-            }
+            peer?.RaiseMaximumPropertyChangedEvent((double)e.OldValue, (double)e.NewValue);
 
             ctrl.CoerceValue(ValueProperty);
             ctrl.OnMaximumChanged((double) e.OldValue, (double) e.NewValue);
@@ -240,10 +234,7 @@ private static void OnValueChanged(DependencyObject d, DependencyPropertyChanged
             RangeBase ctrl = (RangeBase)d;
 
             RangeBaseAutomationPeer peer = UIElementAutomationPeer.FromElement(ctrl) as RangeBaseAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseValuePropertyChangedEvent((double)e.OldValue, (double)e.NewValue);
-            }
+            peer?.RaiseValuePropertyChangedEvent((double)e.OldValue, (double)e.NewValue);
 
             ctrl.OnValueChanged((double) e.OldValue, (double) e.NewValue);
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RepeatButton.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RepeatButton.cs
index d7f2b250..39f66481 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RepeatButton.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/RepeatButton.cs
@@ -133,10 +133,7 @@ private void StartTimer()
         /// </summary>
         private void StopTimer()
         {
-            if (_timer != null)
-            {
-                _timer.Stop();
-            }
+            _timer?.Stop();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ResizeGrip.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ResizeGrip.cs
index e790cd6d..db89cb86 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ResizeGrip.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ResizeGrip.cs
@@ -87,10 +87,7 @@ private void OnWindowServiceChanged(Window oldWindow, Window newWindow)
                 oldWindow.ClearResizeGripControl(this);
             }
 
-            if (newWindow != null)
-            {
-                newWindow.SetResizeGripControl(this);
-            }
+            newWindow?.SetResizeGripControl(this);
         }
 
         #region DTypeThemeStyleKey
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Selector.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Selector.cs
index 8f0b232f..97fa2717 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Selector.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Selector.cs
@@ -1011,13 +1011,12 @@ protected override void ClearContainerForItemOverride(DependencyObject element,
         internal void RaiseIsSelectedChangedAutomationEvent(DependencyObject container, bool isSelected)
         {
             SelectorAutomationPeer selectorPeer = UIElementAutomationPeer.FromElement(this) as SelectorAutomationPeer;
-            if (selectorPeer != null && selectorPeer.ItemPeers != null)
+            if (selectorPeer?.ItemPeers != null)
             {
                 object item = GetItemOrContainerFromContainer(container);
                 if (item != null)
                 {
-                    SelectorItemAutomationPeer itemPeer = selectorPeer.ItemPeers[item] as SelectorItemAutomationPeer;
-                    if (itemPeer != null)
+                    if (selectorPeer.ItemPeers[item] is SelectorItemAutomationPeer itemPeer)
                         itemPeer.RaiseAutomationIsSelectedChanged(isSelected);
                 }
             }
@@ -1332,11 +1331,9 @@ protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChanged
             }
             else
             {
-                DependencyObject currentFocus = Keyboard.FocusedElement as DependencyObject;
-                if (currentFocus != null)
+                if (Keyboard.FocusedElement is DependencyObject currentFocus)
                 {
-                    UIElement root = KeyboardNavigation.GetVisualRoot(this) as UIElement;
-                    if (root != null && root.IsKeyboardFocusWithin)
+                    if (KeyboardNavigation.GetVisualRoot(this) is UIElement root && root.IsKeyboardFocusWithin)
                     {
                         if (FocusManager.GetFocusScope(currentFocus) != FocusManager.GetFocusScope(this))
                         {
@@ -1811,9 +1808,7 @@ private bool InfoGetIsSelected(ItemInfo info)
             // once we are able to force generation, we shouldn't have to do this
             if (IsItemItsOwnContainerOverride(info.Item))
             {
-                DependencyObject element = info.Item as DependencyObject;
-
-                if (element != null)
+                if (info.Item is DependencyObject element)
                 {
                     return (bool)element.GetValue(Selector.IsSelectedProperty);
                 }
@@ -1843,9 +1838,7 @@ private void ItemSetIsSelected(ItemInfo info, bool value)
                 object item = info.Item;
                 if (IsItemItsOwnContainerOverride(item))
                 {
-                    DependencyObject element = item as DependencyObject;
-
-                    if (element != null)
+                    if (item is DependencyObject element)
                     {
                         if (GetIsSelected(element) != value)
                         {
@@ -2713,10 +2706,7 @@ public void Add(object item, DependencyObject container, int index)
 
             public void Add(ItemInfo info)
             {
-                if (_set != null)
-                {
-                    _set.Add(info, info);
-                }
+                _set?.Add(info, info);
                 _list.Add(info);
 
                 if (info.IsResolved)    ++_resolvedCount;
@@ -2797,10 +2787,7 @@ public bool Contains(ItemInfo e)
             public void Clear()
             {
                 _list.Clear();
-                if (_set != null)
-                {
-                    _set.Clear();
-                }
+                _set?.Clear();
 
                 _resolvedCount = _unresolvedCount = 0;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/StatusBar.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/StatusBar.cs
index cb0d3710..e685fbaf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/StatusBar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/StatusBar.cs
@@ -139,8 +139,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         {
             base.PrepareContainerForItemOverride(element, item);
 
-            Separator separator = element as Separator;
-            if (separator != null)
+            if (element is Separator separator)
             {
                 bool hasModifiers;
                 BaseValueSourceInternal vs = separator.GetValueSource(StyleProperty, null, out hasModifiers);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TextBoxBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TextBoxBase.cs
index a3fa2724..058acbae 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TextBoxBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TextBoxBase.cs
@@ -1083,10 +1083,7 @@ protected override void OnPreviewKeyDown(KeyEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnPreviewKeyDown(e);
-            }
+            _textEditor?.OnPreviewKeyDown(e);
         }
 
         /// <summary>
@@ -1101,10 +1098,7 @@ protected override void OnKeyDown(KeyEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnKeyDown(e);
-            }
+            _textEditor?.OnKeyDown(e);
         }
 
         /// <summary>
@@ -1119,10 +1113,7 @@ protected override void OnKeyUp(KeyEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnKeyUp(e);
-            }
+            _textEditor?.OnKeyUp(e);
         }
 
         /// <summary>
@@ -1137,10 +1128,7 @@ protected override void OnTextInput(TextCompositionEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnTextInput(e);
-            }
+            _textEditor?.OnTextInput(e);
         }
 
         /// <summary>
@@ -1155,10 +1143,7 @@ protected override void OnMouseDown(MouseButtonEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnMouseDown(e);
-            }
+            _textEditor?.OnMouseDown(e);
         }
 
         /// <summary>
@@ -1173,10 +1158,7 @@ protected override void OnMouseMove(MouseEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnMouseMove(e);
-            }
+            _textEditor?.OnMouseMove(e);
         }
 
         /// <summary>
@@ -1191,10 +1173,7 @@ protected override void OnMouseUp(MouseButtonEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnMouseUp(e);
-            }
+            _textEditor?.OnMouseUp(e);
         }
 
         /// <summary>
@@ -1209,10 +1188,7 @@ protected override void OnQueryCursor(QueryCursorEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnQueryCursor(e);
-            }
+            _textEditor?.OnQueryCursor(e);
         }
 
         /// <summary>
@@ -1227,10 +1203,7 @@ protected override void OnQueryContinueDrag(QueryContinueDragEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnQueryContinueDrag(e);
-            }
+            _textEditor?.OnQueryContinueDrag(e);
         }
 
         /// <summary>
@@ -1245,10 +1218,7 @@ protected override void OnGiveFeedback(GiveFeedbackEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnGiveFeedback(e);
-            }
+            _textEditor?.OnGiveFeedback(e);
         }
 
         /// <summary>
@@ -1263,10 +1233,7 @@ protected override void OnDragEnter(DragEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnDragEnter(e);
-            }
+            _textEditor?.OnDragEnter(e);
         }
 
         /// <summary>
@@ -1281,10 +1248,7 @@ protected override void OnDragOver(DragEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnDragOver(e);
-            }
+            _textEditor?.OnDragOver(e);
         }
 
         /// <summary>
@@ -1299,10 +1263,7 @@ protected override void OnDragLeave(DragEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnDragLeave(e);
-            }
+            _textEditor?.OnDragLeave(e);
         }
 
         /// <summary>
@@ -1317,10 +1278,7 @@ protected override void OnDrop(DragEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnDrop(e);
-            }
+            _textEditor?.OnDrop(e);
         }
 
         /// <summary>
@@ -1336,10 +1294,7 @@ protected override void OnContextMenuOpening(ContextMenuEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnContextMenuOpening(e);
-            }
+            _textEditor?.OnContextMenuOpening(e);
         }
 
         /// <summary>
@@ -1354,10 +1309,7 @@ protected override void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnGotKeyboardFocus(e);
-            }
+            _textEditor?.OnGotKeyboardFocus(e);
         }
 
         /// <summary>
@@ -1372,10 +1324,7 @@ protected override void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnLostKeyboardFocus(e);
-            }
+            _textEditor?.OnLostKeyboardFocus(e);
         }
 
         /// <summary>
@@ -1391,10 +1340,7 @@ protected override void OnLostFocus(RoutedEventArgs e)
                 return;
             }
 
-            if (_textEditor != null)
-            {
-                _textEditor.OnLostFocus(e);
-            }
+            _textEditor?.OnLostFocus(e);
         }
 
         // Allocates the initial render scope for this control.
@@ -1541,10 +1487,7 @@ internal TextPointer GetTextPositionFromPointInternal(Point point, bool snapToTe
             // Transform to content coordinates.
             GeneralTransform transform = this.TransformToDescendant(this.RenderScope);
 
-            if (transform != null)
-            {
-                transform.TryTransform(point, out point);
-            }
+            transform?.TryTransform(point, out point);
 
             if (TextEditor.GetTextView(this.RenderScope).Validate(point))
             {
@@ -1597,10 +1540,7 @@ internal bool GetRectangleFromTextPosition(TextPointer position, out Rect rect)
                 // Transform to RichTextBox control coordinates.
                 offset = new Point(0, 0);
                 GeneralTransform transform = this.TransformToDescendant(this.RenderScope);
-                if (transform != null)
-                {
-                    transform.TryTransform(offset, out offset);
-                }
+                transform?.TryTransform(offset, out offset);
                 rect.X -= offset.X;
                 rect.Y -= offset.Y;
             }
@@ -1684,9 +1624,9 @@ internal override void AddToEventRouteCore(EventRoute route, RoutedEventArgs arg
             Visual visual = this.RenderScope;
             while (visual != this && visual != null)
             {
-                if (visual is UIElement)
+                if (visual is UIElement uIElement)
                 {
-                    ((UIElement)visual).AddToEventRoute(route, args);
+                    uIElement.AddToEventRoute(route, args);
                 }
                 visual = VisualTreeHelper.GetParent(visual) as Visual;
             }
@@ -1986,10 +1926,8 @@ private void SetRenderScopeToContentHost()
 
             // Add renderScope as a child of ContentHostTemplateName
             _renderScope = renderScope;
-            if (_textBoxContentHost is ScrollViewer)
+            if (_textBoxContentHost is ScrollViewer scrollViewer)
             {
-                ScrollViewer scrollViewer = (ScrollViewer)_textBoxContentHost;
-
                 if (scrollViewer.Content != null)
                 {
                     _renderScope = null;
@@ -2002,9 +1940,8 @@ private void SetRenderScopeToContentHost()
                     scrollViewer.Content = _renderScope; // this may replace old render scope in case of upgrade scenario in TextBox
                 }
             }
-            else if (_textBoxContentHost is Decorator)
+            else if (_textBoxContentHost is Decorator decorator)
             {
-                Decorator decorator = (Decorator)_textBoxContentHost;
                 if (decorator.Child != null)
                 {
                     _renderScope = null;
@@ -2044,13 +1981,13 @@ private void ClearContentHost()
 
             // Render scope has been created by us,
             // so we need to extract if from visual tree.
-            if (_textBoxContentHost is ScrollViewer)
+            if (_textBoxContentHost is ScrollViewer scrollViewer)
             {
-                ((ScrollViewer)_textBoxContentHost).Content = null;
+                scrollViewer.Content = null;
             }
-            else if (_textBoxContentHost is Decorator)
+            else if (_textBoxContentHost is Decorator decorator)
             {
-                ((Decorator)_textBoxContentHost).Child = null;
+                decorator.Child = null;
             }
             else
             {
@@ -2132,7 +2069,7 @@ internal static void OnScrollViewerPropertyChanged(DependencyObject d, Dependenc
         {
             TextBoxBase textBox = d as TextBoxBase;
 
-            if (textBox != null && textBox.ScrollViewer != null)
+            if (textBox?.ScrollViewer != null)
             {
                 object value = e.NewValue;
                 if (value == DependencyProperty.UnsetValue)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TickBar.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TickBar.cs
index aafca780..c967edc0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TickBar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/TickBar.cs
@@ -690,8 +690,7 @@ internal override void OnPreApplyTemplate()
         {
             base.OnPreApplyTemplate();
 
-            Slider parent = TemplatedParent as Slider;
-            if (parent != null)
+            if (TemplatedParent is Slider parent)
             {
                 BindToTemplatedParent(TicksProperty, Slider.TicksProperty);
                 BindToTemplatedParent(TickFrequencyProperty, Slider.TickFrequencyProperty);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToggleButton.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToggleButton.cs
index 639c87d8..96a421d9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToggleButton.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToggleButton.cs
@@ -172,10 +172,7 @@ private static void OnIsCheckedChanged(DependencyObject d, DependencyPropertyCha
             //doing soft casting here because the peer can be that of RadioButton and it is not derived from
             //ToggleButtonAutomationPeer - specifically to avoid implementing TogglePattern
             ToggleButtonAutomationPeer peer = UIElementAutomationPeer.FromElement(button) as ToggleButtonAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseToggleStatePropertyChangedEvent(oldValue, newValue);
-            }
+            peer?.RaiseToggleStatePropertyChangedEvent(oldValue, newValue);
 
             if (newValue == true)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToolBarPanel.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToolBarPanel.cs
index 1f4e5933..5bd4a1ae 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToolBarPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/ToolBarPanel.cs
@@ -274,10 +274,7 @@ protected override Size MeasureOverride(Size constraint)
                 MaxLength = (horizontal ? stackDesiredSize.Width : stackDesiredSize.Height) + overflowExtent;
 
                 ToolBar toolbar = ToolBar;
-                if (toolbar != null)
-                {
-                    toolbar.SetValue(ToolBar.HasOverflowItemsPropertyKey, hasAlwaysOverflowItems || hasAsNeededOverflowItems);
-                }
+                toolbar?.SetValue(ToolBar.HasOverflowItemsPropertyKey, hasAlwaysOverflowItems || hasAsNeededOverflowItems);
             }
             else
             {
@@ -416,8 +413,7 @@ private void AddChildren(GeneratorPosition pos, int itemCount)
             {
                 for (int i = 0; i < itemCount; i++)
                 {
-                    UIElement e = generator.GenerateNext() as UIElement;
-                    if (e != null)
+                    if (generator.GenerateNext() is UIElement e)
                     {
                         _generatedItemsCollection.Insert(pos.Index + 1 + i, e);
                         generator.PrepareItemContainer(e);
@@ -425,10 +421,7 @@ private void AddChildren(GeneratorPosition pos, int itemCount)
                     else
                     {
                         ItemContainerGenerator icg = Generator as ItemContainerGenerator;
-                        if (icg != null)
-                        {
-                            icg.Verify();
-                        }
+                        icg?.Verify();
                     }
                 }
             }
@@ -484,10 +477,7 @@ private void ReplaceChildren(GeneratorPosition pos, int itemCount, int container
                     else
                     {
                         ItemContainerGenerator icg = Generator as ItemContainerGenerator;
-                        if (icg != null)
-                        {
-                            icg.Verify();
-                        }
+                        icg?.Verify();
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Track.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Track.cs
index fc9ba8f9..99742245 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Track.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Primitives/Track.cs
@@ -721,18 +721,15 @@ internal override void OnPreApplyTemplate()
         {
             base.OnPreApplyTemplate();
 
-            RangeBase rangeBase = TemplatedParent as RangeBase;
-
-            if (rangeBase != null)
+            if (TemplatedParent is RangeBase rangeBase)
             {
                 BindToTemplatedParent(MinimumProperty, RangeBase.MinimumProperty);
                 BindToTemplatedParent(MaximumProperty, RangeBase.MaximumProperty);
                 BindToTemplatedParent(ValueProperty, RangeBase.ValueProperty);
 
                 // Setup ScrollBar specific bindings
-                ScrollBar scrollBar = rangeBase as ScrollBar;
 
-                if (scrollBar != null)
+                if (rangeBase is ScrollBar scrollBar)
                 {
                     BindToTemplatedParent(ViewportSizeProperty, ScrollBar.ViewportSizeProperty);
                     BindToTemplatedParent(OrientationProperty, ScrollBar.OrientationProperty);
@@ -740,9 +737,8 @@ internal override void OnPreApplyTemplate()
                 else
                 {
                     // Setup Slider specific bindings
-                    Slider slider = rangeBase as Slider;
 
-                    if (slider != null)
+                    if (rangeBase is Slider slider)
                     {
                         BindToTemplatedParent(OrientationProperty, Slider.OrientationProperty);
                         BindToTemplatedParent(IsDirectionReversedProperty, Slider.IsDirectionReversedProperty);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ProgressBar.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ProgressBar.cs
index 2b6fa855..874474ed 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ProgressBar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ProgressBar.cs
@@ -100,10 +100,7 @@ private static void OnIsIndeterminateChanged(DependencyObject d, DependencyPrope
 
             // Invalidate automation peer
             ProgressBarAutomationPeer peer = UIElementAutomationPeer.FromElement(progressBar) as ProgressBarAutomationPeer;
-            if (peer != null)
-            {
-                peer.InvalidatePeer();
-            }
+            peer?.InvalidatePeer();
 
             progressBar.SetProgressBarGlowElementBrush();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ScrollViewer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ScrollViewer.cs
index 49b7f45b..cd5c1c22 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ScrollViewer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ScrollViewer.cs
@@ -1492,10 +1492,7 @@ public static PanningMode GetPanningMode(DependencyObject element)
         private static void OnPanningModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
             ScrollViewer sv = d as ScrollViewer;
-            if (sv != null)
-            {
-                sv.OnPanningModeChanged();
-            }
+            sv?.OnPanningModeChanged();
         }
 
         /// <summary>
@@ -2453,15 +2450,7 @@ private void OnLayoutUpdated(object sender, EventArgs e)
 
                     // Fire automation events if automation is active.
                     ScrollViewerAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as ScrollViewerAutomationPeer;
-                    if(peer != null)
-                    {
-                        peer.RaiseAutomationEvents(oldExtentWidth,
-                                                   oldExtentHeight,
-                                                   oldViewportWidth,
-                                                   oldViewportHeight,
-                                                   oldActualHorizontalOffset,
-                                                   oldActualVerticalOffset);
-                    }
+                    peer?.RaiseAutomationEvents(oldExtentWidth, oldExtentHeight, oldViewportWidth, oldViewportHeight, oldActualHorizontalOffset, oldActualVerticalOffset);
                 }
                 finally
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SinglePageViewer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SinglePageViewer.cs
index 5741d63e..8ffc7353 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SinglePageViewer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SinglePageViewer.cs
@@ -969,7 +969,7 @@ private void HandleLayoutUpdated(object sender, EventArgs e)
                     if (_contentPosition == null)
                     {
                         masterPageView = GetMasterPageView();
-                        if (masterPageView != null && masterPageView.DocumentPage != null)
+                        if (masterPageView?.DocumentPage != null)
                         {
                             _contentPosition = documentPaginator.GetPagePosition(masterPageView.DocumentPage);
                         }
@@ -1375,7 +1375,7 @@ private static void KeyDownHandler(object sender, KeyEventArgs e)
         /// </summary>
         private static object CoerceZoom(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is FlowDocumentPageViewer);
+            Invariant.Assert(d is FlowDocumentPageViewer);
 
             double maxZoom, minZoom;
             FlowDocumentPageViewer v = (FlowDocumentPageViewer) d;
@@ -1401,7 +1401,7 @@ private static object CoerceZoom(DependencyObject d, object value)
         /// </summary>
         private static object CoerceMaxZoom(DependencyObject d, object value)
         {
-            Invariant.Assert(d != null && d is FlowDocumentPageViewer);
+            Invariant.Assert(d is FlowDocumentPageViewer);
 
             FlowDocumentPageViewer v = (FlowDocumentPageViewer) d;
             double minZoom = v.MinZoom;
@@ -1417,7 +1417,7 @@ private static object CoerceMaxZoom(DependencyObject d, object value)
         /// </summary>
         private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentPageViewer);
+            Invariant.Assert(d is FlowDocumentPageViewer);
             ((FlowDocumentPageViewer)d).ZoomChanged((double) e.OldValue, (double) e.NewValue);
         }
 
@@ -1426,7 +1426,7 @@ private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEve
         /// </summary>
         private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentPageViewer);
+            Invariant.Assert(d is FlowDocumentPageViewer);
             ((FlowDocumentPageViewer)d).MaxZoomChanged((double) e.OldValue, (double) e.NewValue);
         }
 
@@ -1435,7 +1435,7 @@ private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChanged
         /// </summary>
         private static void MinZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            Invariant.Assert(d != null && d is FlowDocumentPageViewer);
+            Invariant.Assert(d is FlowDocumentPageViewer);
             ((FlowDocumentPageViewer)d).MinZoomChanged((double) e.OldValue, (double) e.NewValue);
         }
 
@@ -1460,10 +1460,7 @@ private static void UpdateCaretElement(DependencyObject d, DependencyPropertyCha
             if (viewer.Selection != null)
             {
                 CaretElement caretElement = viewer.Selection.CaretElement;
-                if (caretElement != null)
-                {
-                    caretElement.InvalidateVisual();
-                }
+                caretElement?.InvalidateVisual();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Slider.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Slider.cs
index 3722af70..937ff66d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Slider.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Slider.cs
@@ -180,9 +180,7 @@ public SliderGesture(Key normal, Key inverted, bool forHorizontal)
             /// </summary>
             public override bool Matches(object targetElement, InputEventArgs inputEventArgs)
             {
-                KeyEventArgs keyEventArgs = inputEventArgs as KeyEventArgs;
-                Slider slider = targetElement as Slider;
-                if (keyEventArgs != null && slider != null && Keyboard.Modifiers == ModifierKeys.None)
+                if (inputEventArgs is KeyEventArgs keyEventArgs && targetElement is Slider slider && Keyboard.Modifiers == ModifierKeys.None)
                 {
                     if((int)_normal == (int)keyEventArgs.RealKey)
                     {
@@ -217,55 +215,37 @@ private bool IsInverted(Slider slider)
         private static void OnIncreaseSmallCommand(object sender, ExecutedRoutedEventArgs e)
         {
             Slider slider = sender as Slider;
-            if (slider != null)
-            {
-                slider.OnIncreaseSmall();
-            }
+            slider?.OnIncreaseSmall();
         }
 
         private static void OnDecreaseSmallCommand(object sender, ExecutedRoutedEventArgs e)
         {
             Slider slider = sender as Slider;
-            if (slider != null)
-            {
-                slider.OnDecreaseSmall();
-            }
+            slider?.OnDecreaseSmall();
         }
 
         private static void OnMaximizeValueCommand(object sender, ExecutedRoutedEventArgs e)
         {
             Slider slider = sender as Slider;
-            if (slider != null)
-            {
-                slider.OnMaximizeValue();
-            }
+            slider?.OnMaximizeValue();
         }
 
         private static void OnMinimizeValueCommand(object sender, ExecutedRoutedEventArgs e)
         {
             Slider slider = sender as Slider;
-            if (slider != null)
-            {
-                slider.OnMinimizeValue();
-            }
+            slider?.OnMinimizeValue();
         }
 
         private static void OnIncreaseLargeCommand(object sender, ExecutedRoutedEventArgs e)
         {
             Slider slider = sender as Slider;
-            if (slider != null)
-            {
-                slider.OnIncreaseLarge();
-            }
+            slider?.OnIncreaseLarge();
         }
 
         private static void OnDecreaseLargeCommand(object sender, ExecutedRoutedEventArgs e)
         {
             Slider slider = sender as Slider;
-            if (slider != null)
-            {
-                slider.OnDecreaseLarge();
-            }
+            slider?.OnDecreaseLarge();
         }
 
         #endregion Commands
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SoundPlayerAction.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SoundPlayerAction.cs
index a2ec4353..56f463b9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SoundPlayerAction.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SoundPlayerAction.cs
@@ -51,10 +51,7 @@ public SoundPlayerAction()
        /// </summary>
        public void Dispose()
        {
-           if (m_player != null)
-           {
-               m_player.Dispose();
-           }
+           m_player?.Dispose();
        }
 
 
@@ -210,10 +207,7 @@ private Object OnLoadStreamCompleted(Object asyncResultArg)
            if (m_uriChangedWhileLoadingStream)  // The source URI was changed, redo Stream loading
            {
                m_uriChangedWhileLoadingStream = false;
-               if (newStream != null)  // Don't hold on to the new stream - it's not needed anymore
-               {
-                   newStream.Dispose();
-               }
+               newStream?.Dispose();
                BeginLoadStream();
            }
            else if (newStream != null)  // We loaded the Stream, begin buffering it
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SpellCheck.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SpellCheck.cs
index 5dd38f74..966ed424 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SpellCheck.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/SpellCheck.cs
@@ -204,9 +204,7 @@ public static IList GetCustomDictionaries(TextBoxBase textBoxBase)
         // Callback for changes to the IsEnabled property.
         private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            TextBoxBase textBoxBase = d as TextBoxBase;
-
-            if (textBoxBase != null)
+            if (d is TextBoxBase textBoxBase)
             {
                 TextEditor textEditor = TextEditor._GetTextEditor(textBoxBase);
 
@@ -224,16 +222,11 @@ private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyCha
         // SpellingReformProperty change callback.
         private static void OnSpellingReformChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            TextBoxBase textBoxBase = d as TextBoxBase;
-
-            if (textBoxBase != null)
+            if (d is TextBoxBase textBoxBase)
             {
                 TextEditor textEditor = TextEditor._GetTextEditor(textBoxBase);
 
-                if (textEditor != null)
-                {
-                    textEditor.SetSpellingReform((SpellingReform)e.NewValue);
-                }
+                textEditor?.SetSpellingReform((SpellingReform)e.NewValue);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Stack.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Stack.cs
index d005ab44..c22a1df9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Stack.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/Stack.cs
@@ -804,7 +804,7 @@ private static void ResetScrolling(StackPanel element)
         // At the time this method is called, scrolling state is in its new, valid state.
         private void OnScrollChange()
         {
-            if (ScrollOwner != null) { ScrollOwner.InvalidateScrollInfo(); }
+            ScrollOwner?.InvalidateScrollInfo();
         }
 
         private static void VerifyScrollingData(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size viewport, Size extent, Vector offset)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/StickyNote.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/StickyNote.cs
index fe1b6b58..207c8e07 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/StickyNote.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/StickyNote.cs
@@ -194,18 +194,12 @@ public override void OnApplyTemplate()
             if (!this.IsExpanded)
             {
                 Button button = GetIconButton();
-                if (button != null)
-                {
-                    button.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
-                }
+                button?.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
             }
             else
             {
                 Button closeButton = GetCloseButton();
-                if (closeButton != null)
-                {
-                    closeButton.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
-                }
+                closeButton?.AddHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
 
                 Thumb titleThumb = GetTitleThumb();
                 if (titleThumb != null)
@@ -992,11 +986,7 @@ private void OnInkStrokesChanged(object sender, StrokeCollectionChangedEventArgs
                 Invariant.Assert(Content != null && Content.InnerControl is InkCanvas);
                 FrameworkElement parent = VisualTreeHelper.GetParent(Content.InnerControl) as FrameworkElement;
 
-                if (parent != null)
-                {
-                    // Invalidate ContentArea's measure so that scrollbar could be updated correctly.
-                    parent.InvalidateMeasure();
-                }
+                parent?.InvalidateMeasure();
             }
 
             //fire trace event
@@ -1300,16 +1290,10 @@ private void ClearCachedControls()
             }
 
             Button closeButton = GetCloseButton();
-            if (closeButton != null)
-            {
-                closeButton.RemoveHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
-            }
+            closeButton?.RemoveHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
 
             Button iconButton = GetIconButton();
-            if (iconButton != null)
-            {
-                iconButton.RemoveHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
-            }
+            iconButton?.RemoveHandler(ButtonBase.ClickEvent, new RoutedEventHandler(OnButtonClick));
 
             Thumb titleThumb = GetTitleThumb();
             if (titleThumb != null)
@@ -1411,10 +1395,7 @@ private void GiveUpFocus()
         private void BringToFront()
         {
             PresentationContext pc = ((IAnnotationComponent)this).PresentationContext;
-            if ( pc != null )
-            {
-                pc.BringToFront(this);
-            }
+            pc?.BringToFront(this);
         }
 
         /// <summary>
@@ -1425,10 +1406,7 @@ private void BringToFront()
         private void SendToBack()
         {
             PresentationContext pc = ((IAnnotationComponent)this).PresentationContext;
-            if (pc != null)
-            {
-                pc.SendToBack(this);
-            }
+            pc?.SendToBack(this);
         }
 
         /// <summary>
@@ -1437,10 +1415,7 @@ private void SendToBack()
         private void InvalidateTransform()
         {
             PresentationContext pc = ((IAnnotationComponent)this).PresentationContext;
-            if ( pc != null )
-            {
-                pc.InvalidateTransform(this);
-            }
+            pc?.InvalidateTransform(this);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabControl.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabControl.cs
index ec6dd96a..6046e3f9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabControl.cs
@@ -89,8 +89,7 @@ private static void OnTabStripPlacementPropertyChanged(DependencyObject d, Depen
             ItemCollection tabItemCollection = tc.Items;
             for (int i = 0; i < tabItemCollection.Count; i++)
             {
-                TabItem ti = tc.ItemContainerGenerator.ContainerFromIndex(i) as TabItem;
-                if (ti != null)
+                if (tc.ItemContainerGenerator.ContainerFromIndex(i) is TabItem ti)
                     ti.CoerceValue(TabItem.TabStripPlacementProperty);
             }
         }
@@ -351,10 +350,7 @@ protected override void OnSelectionChanged(SelectionChangedEventArgs e)
                 {
                     // If keyboard focus is within the control, make sure it is going to the correct place
                     TabItem item = GetSelectedTabItem();
-                    if (item != null)
-                    {
-                        item.SetFocus();
-                    }
+                    item?.SetFocus();
                 }
                 UpdateSelectedContent();
             }
@@ -369,10 +365,7 @@ protected override void OnSelectionChanged(SelectionChangedEventArgs e)
                 {
                     // If keyboard focus is within the control, make sure it is going to the correct place
                     TabItem item = GetSelectedTabItem();
-                    if (item != null)
-                    {
-                        item.SetFocus();
-                    }
+                    item?.SetFocus();
                 }
                 base.OnSelectionChanged(e);
             }
@@ -382,8 +375,7 @@ protected override void OnSelectionChanged(SelectionChangedEventArgs e)
                 ||  AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementAddedToSelection)
                 ||  AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection)   )
             {
-                TabControlAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(this) as TabControlAutomationPeer;
-                if (peer != null)
+                if (UIElementAutomationPeer.CreatePeerForElement(this) is TabControlAutomationPeer peer)
                     peer.RaiseSelectionEvents(e);
             }
         }
@@ -467,9 +459,7 @@ private TabItem FindNextTabItem(int startIndex, int direction)
                         index = 0;
                     else if (index < 0)
                         index = Items.Count - 1;
-
-                    TabItem tabItem = ItemContainerGenerator.ContainerFromIndex(index) as TabItem;
-                    if (tabItem != null && tabItem.IsEnabled && tabItem.Visibility == Visibility.Visible)
+                    if (ItemContainerGenerator.ContainerFromIndex(index) is TabItem tabItem && tabItem.IsEnabled && tabItem.Visibility == Visibility.Visible)
                     {
                         nextTabItem = tabItem;
                         break;
@@ -562,9 +552,7 @@ private void UpdateSelectedContent()
             TabItem tabItem = GetSelectedTabItem();
             if (tabItem != null)
             {
-                FrameworkElement visualParent = VisualTreeHelper.GetParent(tabItem) as FrameworkElement;
-
-                if (visualParent != null)
+                if (VisualTreeHelper.GetParent(tabItem) is FrameworkElement visualParent)
                 {
                     KeyboardNavigation.SetTabOnceActiveElement(visualParent, tabItem);
                     KeyboardNavigation.SetTabOnceActiveElement(this, visualParent);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabItem.cs
index e974bd5f..86ae76b4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TabItem.cs
@@ -98,10 +98,7 @@ private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyCh
             bool isSelected = (bool)e.NewValue;
 
             TabControl parentTabControl = tabItem.TabControlParent;
-            if (parentTabControl != null)
-            {
-                parentTabControl.RaiseIsSelectedChangedAutomationEvent(tabItem, isSelected);
-            }
+            parentTabControl?.RaiseIsSelectedChangedAutomationEvent(tabItem, isSelected);
 
             if (isSelected)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextAdaptor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextAdaptor.cs
index 47f35abf..28014848 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextAdaptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextAdaptor.cs
@@ -242,8 +242,7 @@ internal void ScrollIntoView(ITextPointer start, ITextPointer end, bool alignToT
                 Visual visual = renderScope;
                 while (visual != null)
                 {
-                    IScrollInfo isi = visual as IScrollInfo;
-                    if (isi != null)
+                    if (visual is IScrollInfo isi)
                     {
                         // Transform the bounding rectangle into the IScrollInfo coordinates.
                         if (visual != renderScope)
@@ -266,10 +265,7 @@ internal void ScrollIntoView(ITextPointer start, ITextPointer end, bool alignToT
                 }
 
                 FrameworkElement fe = renderScope as FrameworkElement;
-                if (fe != null)
-                {
-                    fe.BringIntoView(rangeVisibleBounds);
-                }
+                fe?.BringIntoView(rangeVisibleBounds);
             }
             else
             {
@@ -277,10 +273,7 @@ internal void ScrollIntoView(ITextPointer start, ITextPointer end, bool alignToT
                 ITextPointer pointer = alignToTop ? start.CreatePointer() : end.CreatePointer();
                 pointer.MoveToElementEdge(alignToTop ? ElementEdge.AfterStart : ElementEdge.AfterEnd);
                 FrameworkContentElement element = pointer.GetAdjacentElement(LogicalDirection.Backward) as FrameworkContentElement;
-                if (element != null)
-                {
-                    element.BringIntoView();
-                }
+                element?.BringIntoView();
             }
         }
 
@@ -551,9 +544,9 @@ ITextRangeProvider ITextProvider.RangeFromChild(IRawElementProviderSimple childE
 
             // Retrieve DependencyObject from AutomationElement
             DependencyObject childElement;
-            if (_textPeer is TextAutomationPeer)
+            if (_textPeer is TextAutomationPeer textAutomationPeer)
             {
-                childElement = ((TextAutomationPeer)_textPeer).ElementFromProvider(childElementProvider);
+                childElement = textAutomationPeer.ElementFromProvider(childElementProvider);
             }
             else
             {
@@ -571,9 +564,9 @@ ITextRangeProvider ITextProvider.RangeFromChild(IRawElementProviderSimple childE
                 // If element is UIElement hosted by UIContainer (Inlien of Block), 
                 // retrieve content Start and End positions of the container.
                 // Otherwise scan ITextContainer to find a range for given element.
-                if (childElement is TextElement)
+                if (childElement is TextElement textElement)
                 {
-                    rangeStart = ((TextElement)childElement).ElementStart;
+                    rangeStart = textElement.ElementStart;
                     rangeEnd = ((TextElement)childElement).ElementEnd;
                 }
                 else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBlock.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBlock.cs
index 282b5e18..abfa254e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBlock.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBlock.cs
@@ -152,9 +152,9 @@ void IAddChild.AddChild(Object value)
             // Do implicit conversion to allowed inline type - if possible
             if (!TextSchema.IsValidChildOfContainer(parentType, /*childType*/valueType))
             {
-                if (value is UIElement)
+                if (value is UIElement uIElement)
                 {
-                    value = new InlineUIContainer((UIElement)value);
+                    value = new InlineUIContainer(uIElement);
                 }
                 else
                 {
@@ -1849,9 +1849,9 @@ protected virtual ReadOnlyCollection<Rect> GetRectanglesCore(ContentElement chil
             }
 
             TextPointer end = null;
-            if (child is TextElement)
+            if (child is TextElement textElement)
             {
-                end = new TextPointer(((TextElement)child).ElementEnd);
+                end = new TextPointer(textElement.ElementEnd);
             }
             else if (child is FrameworkContentElement)
             {
@@ -3586,9 +3586,9 @@ private static bool ContainsContentElement(TextBlock textBlock, ContentElement e
             {
                 return false;
             }
-            else if (element is TextElement)
+            else if (element is TextElement textElement)
             {
-                if (textBlock._complexContent.TextContainer != ((TextElement)element).TextContainer)
+                if (textBlock._complexContent.TextContainer != textElement.TextContainer)
                 {
                     return false;
                 }
@@ -4008,7 +4008,7 @@ internal ComplexContent(TextBlock owner, ITextContainer textContainer, bool fore
                 ForeignTextContainer = foreignTextContianer;
 
                 // Add content
-                if (content != null && content.Length > 0)
+                if (!string.IsNullOrEmpty(content))
                 {
                     TextBlock.InsertTextRun(this.TextContainer.End, content, /*whitespacesIgnorable:*/false);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBox.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBox.cs
index d8455cd3..e6be0bf2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextBox.cs
@@ -1010,8 +1010,7 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
 
             if (this.RenderScope != null)
             {
-                FrameworkPropertyMetadata fmetadata = e.Property.GetMetadata(typeof(TextBox)) as FrameworkPropertyMetadata;
-                if (fmetadata != null)
+                if (e.Property.GetMetadata(typeof(TextBox)) is FrameworkPropertyMetadata fmetadata)
                 {
                     // We need to check for TextAlignmentProperty specifically since a local value change might require a render
                     // update even though e.IsAValueChange is false (see TextBoxView.CalculatedTextAlignment).
@@ -1038,8 +1037,7 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
                 }
             }
 
-            TextBoxAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as TextBoxAutomationPeer;
-            if (peer != null)
+            if (UIElementAutomationPeer.FromElement(this) is TextBoxAutomationPeer peer)
             {
                 if (e.Property == TextProperty)
                 {
@@ -1482,9 +1480,7 @@ private TextPointer GetEndPositionOfLine(int lineIndex)
 
         private static object CoerceHorizontalScrollBarVisibility(DependencyObject d, object value)
         {
-            TextBox textBox = d as TextBox;
-
-            if (textBox != null && (textBox.TextWrapping == TextWrapping.Wrap || textBox.TextWrapping == TextWrapping.WrapWithOverflow))
+            if (d is TextBox textBox && (textBox.TextWrapping == TextWrapping.Wrap || textBox.TextWrapping == TextWrapping.WrapWithOverflow))
             {
                 return ScrollBarVisibility.Disabled;
             }
@@ -1777,9 +1773,9 @@ private int ChooseCaretIndex(int oldIndex, string oldText, string newText)
         /// </summary>
         private static void OnTextWrappingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            if (d is TextBox)
+            if (d is TextBox textBox)
             {
-                ((TextBox)d).OnTextWrappingChanged();
+                textBox.OnTextWrappingChanged();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextRangeAdaptor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextRangeAdaptor.cs
index 38848e13..48516208 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextRangeAdaptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextRangeAdaptor.cs
@@ -670,10 +670,10 @@ private void ExpandToEnclosingUnit(TextUnit unit, bool expandStart, bool expandE
                         if (expandStart && textView.Contains(_start))
                         {
                             ITextView pageTextView = textView;
-                            if (textView is MultiPageTextView)
+                            if (textView is MultiPageTextView multiPageTextView)
                             {
                                 // This is "multi page" case. Find page associated with the start position.
-                                pageTextView = ((MultiPageTextView)textView).GetPageTextViewFromPosition(_start);
+                                pageTextView = multiPageTextView.GetPageTextViewFromPosition(_start);
                             }
                             ReadOnlyCollection<TextSegment> textSegments = pageTextView.TextSegments;
                             if (textSegments != null && textSegments.Count > 0)
@@ -687,10 +687,10 @@ private void ExpandToEnclosingUnit(TextUnit unit, bool expandStart, bool expandE
                         if (expandEnd && textView.Contains(_end))
                         {
                             ITextView pageTextView = textView;
-                            if (textView is MultiPageTextView)
+                            if (textView is MultiPageTextView multiPageTextView)
                             {
                                 // This is "multi page" case. Find page associated with the start position.
-                                pageTextView = ((MultiPageTextView)textView).GetPageTextViewFromPosition(_end);
+                                pageTextView = multiPageTextView.GetPageTextViewFromPosition(_end);
                             }
                             ReadOnlyCollection<TextSegment> textSegments = pageTextView.TextSegments;
                             if (textSegments != null && textSegments.Count > 0)
@@ -908,10 +908,10 @@ private bool MoveToUnitBoundary(ITextPointer position, bool isStart, LogicalDire
                     if (textView != null && textView.IsValid && textView.Contains(position))
                     {
                         ITextView pageTextView = textView;
-                        if (textView is MultiPageTextView)
+                        if (textView is MultiPageTextView multiPageTextView)
                         {
                             // This is "multi page" case. Find page associated with the start position.
-                            pageTextView = ((MultiPageTextView)textView).GetPageTextViewFromPosition(position);
+                            pageTextView = multiPageTextView.GetPageTextViewFromPosition(position);
                         }
                         ReadOnlyCollection<TextSegment> textSegments = pageTextView.TextSegments;
 
@@ -1130,10 +1130,10 @@ private int MovePositionByUnits(ITextPointer position, TextUnit unit, int count)
                     textView = _textAdaptor.GetUpdatedTextView();
                     if (textView != null && textView.IsValid && textView.Contains(position))
                     {
-                        if (textView is MultiPageTextView)
+                        if (textView is MultiPageTextView multiPageTextView)
                         {
                             // Get embedded page ITextView for given position.
-                            ITextView pageTextView = ((MultiPageTextView)textView).GetPageTextViewFromPosition(position);
+                            ITextView pageTextView = multiPageTextView.GetPageTextViewFromPosition(position);
                             ReadOnlyCollection<TextSegment> textSegments = pageTextView.TextSegments;
                             while (moved < absCount)
                             {
@@ -1404,9 +1404,9 @@ private AutomationPeer GetEnclosingAutomationPeer(ITextPointer start, ITextPoint
         private IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer)
         {
             IRawElementProviderSimple provider;
-            if (_textPeer is TextAutomationPeer)
+            if (_textPeer is TextAutomationPeer textAutomationPeer)
             {
-                provider = ((TextAutomationPeer)_textPeer).ProviderFromPeer(peer);
+                provider = textAutomationPeer.ProviderFromPeer(peer);
             }
             else
             {
@@ -1422,9 +1422,9 @@ private List<AutomationPeer> GetAutomationPeersFromRange(AutomationPeer peer, IT
         {
             List<AutomationPeer> peers;
             Invariant.Assert(peer is TextAutomationPeer || peer is ContentTextAutomationPeer);
-            if (peer is TextAutomationPeer)
+            if (peer is TextAutomationPeer textAutomationPeer)
             {
-                peers = ((TextAutomationPeer)peer).GetAutomationPeersFromRange(start, end);
+                peers = textAutomationPeer.GetAutomationPeersFromRange(start, end);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextSearch.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextSearch.cs
index 2c18a37e..8aaac1ac 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextSearch.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TextSearch.cs
@@ -588,16 +588,9 @@ private static string GetPrimaryTextPath(ItemsControl itemsControl)
 
         private static string GetPrimaryText(object item, BindingExpression primaryTextBinding, DependencyObject primaryTextBindingHome)
         {
-            // Order of precedence for getting Primary Text is as follows:
-            //
-            // 1) PrimaryText
-            // 2) PrimaryTextPath (TextSearch.TextPath or ItemsControl.DisplayMemberPath)
-            // 3) GetPlainText()
-            // 4) ToString()
+            // Order of precedence for getting Primary Text is as follows:            //            // 1) PrimaryText            // 2) PrimaryTextPath (TextSearch.TextPath or ItemsControl.DisplayMemberPath)            // 3) GetPlainText()            // 4) ToString()
 
-            DependencyObject itemDO = item as DependencyObject;
-
-            if (itemDO != null)
+            if (item is DependencyObject itemDO)
             {
                 string primaryText = (string)itemDO.GetValue(TextProperty);
 
@@ -626,10 +619,8 @@ private static string GetPrimaryText(object item, BindingExpression primaryTextB
 
         private static string ConvertToPlainText(object o)
         {
-            FrameworkElement fe = o as FrameworkElement;
-
             // Try to return FrameworkElement.GetPlainText()
-            if (fe != null)
+            if (o is FrameworkElement fe)
             {
                 string text = fe.GetPlainText();
 
@@ -705,10 +696,7 @@ private void ResetState()
                 _charsEntered.Clear();
             }
 
-            if(_timeoutTimer != null)
-            {
-                _timeoutTimer.Stop();
-            }
+            _timeoutTimer?.Stop();
             _timeoutTimer = null;
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBar.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBar.cs
index b66fc759..229be099 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBar.cs
@@ -395,10 +395,7 @@ private static void OnOverflowModeChanged(DependencyObject element, DependencyPr
             // invalidate layout so that the child can be placed in the correct
             // location (in the main bar or the overflow menu).
             ToolBar toolBar = ItemsControl.ItemsControlFromItemContainer(element) as ToolBar;
-            if (toolBar != null)
-            {
-                toolBar.InvalidateLayout();
-            }
+            toolBar?.InvalidateLayout();
         }
 
         private void InvalidateLayout()
@@ -411,12 +408,7 @@ private void InvalidateLayout()
             InvalidateMeasure();
 
             ToolBarPanel toolBarPanel = this.ToolBarPanel;
-            if (toolBarPanel != null)
-            {
-                // Whether elements are in the overflow or not is decided
-                // in ToolBarPanel.MeasureOverride.
-                toolBarPanel.InvalidateMeasure();
-            }
+            toolBarPanel?.InvalidateMeasure();
         }
 
         private static bool IsValidOverflowMode(object o)
@@ -477,10 +469,8 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         {
             base.PrepareContainerForItemOverride(element, item);
 
-            // For certain known types, automatically change their default style
-            // to point to a ToolBar version.
-            FrameworkElement fe = element as FrameworkElement;
-            if (fe != null)
+            // For certain known types, automatically change their default style            // to point to a ToolBar version.
+            if (element is FrameworkElement fe)
             {
                 Type feType = fe.GetType();
                 ResourceKey resourceKey = null;
@@ -652,12 +642,11 @@ private ToolBarOverflowPanel FindToolBarOverflowPanel()
         protected override void OnKeyDown(KeyEventArgs e)
         {
             UIElement newFocusElement = null;
-            UIElement currentFocusElement = e.Source as UIElement;
-            if (currentFocusElement != null && ItemsControl.ItemsControlFromItemContainer(currentFocusElement) == this)
+
+            if (e.Source is UIElement currentFocusElement && ItemsControl.ItemsControlFromItemContainer(currentFocusElement) == this)
             {
                 // itemsHost should be either ToolBarPanel or ToolBarOverflowPanel
-                Panel itemsHost = VisualTreeHelper.GetParent(currentFocusElement) as Panel;
-                if (itemsHost != null)
+                if (VisualTreeHelper.GetParent(currentFocusElement) is Panel itemsHost)
                 {
                     switch (e.Key)
                     {
@@ -715,8 +704,7 @@ private static void OnMouseButtonDown(object sender, MouseButtonEventArgs e)
         private static void _OnClick(object e, RoutedEventArgs args)
         {
             ToolBar toolBar = (ToolBar)e;
-            ButtonBase bb = args.OriginalSource as ButtonBase;
-            if (toolBar.IsOverflowOpen && bb != null && bb.Parent == toolBar)
+            if (toolBar.IsOverflowOpen && args.OriginalSource is ButtonBase bb && bb.Parent == toolBar)
                 toolBar.Close();
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBarTray.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBarTray.cs
index 06e924f0..8403c49f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBarTray.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolBarTray.cs
@@ -520,11 +520,9 @@ private static void OnThumbDragDelta(object sender, DragDeltaEventArgs e)
         private void ProcessThumbDragDelta(DragDeltaEventArgs e)
         {
             // Process thumb event only if Thumb styled parent is a ToolBar under the TollBarTray
-            Thumb thumb = e.OriginalSource as Thumb;
-            if (thumb != null)
+            if (e.OriginalSource is Thumb thumb)
             {
-                ToolBar toolBar = thumb.TemplatedParent as ToolBar;
-                if (toolBar != null && toolBar.Parent == this)
+                if (thumb.TemplatedParent is ToolBar toolBar && toolBar.Parent == this)
                 {
                     // _bandsDirty would be true at this time only when a Measure gets
                     // skipped between two mouse moves. Ideally that should not happen
@@ -675,10 +673,7 @@ private Point TransformPointToToolBar(ToolBar toolBar, Point point)
         {
             Point p = point;
             GeneralTransform transform = this.TransformToDescendant(toolBar);
-            if (transform != null)
-            {
-                transform.TryTransform(point, out p);
-            }
+            transform?.TryTransform(point, out p);
             return p;
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolTipService.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolTipService.cs
index 3bd4c185..b8d6070b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolTipService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ToolTipService.cs
@@ -628,8 +628,7 @@ private static void OnFindToolTip(object sender, FindToolTipEventArgs e)
         {
             if (e.TargetElement == null)
             {
-                DependencyObject o = sender as DependencyObject;
-                if (o != null)
+                if (sender is DependencyObject o)
                 {
                     // For keyboard shortcut we don't want to stop looking for the tooltip, even if it was the last one we showed, we still want to re-show it.
                     if (e.TriggerAction != ToolTip.ToolTipTrigger.KeyboardShortcut && PopupControlService.Current.StopLookingForToolTip(o))
@@ -657,10 +656,8 @@ private static bool ToolTipIsEnabled(DependencyObject o, ToolTip.ToolTipTrigger
 
             if ((tooltipObject != null) && GetIsEnabled(o))
             {
-                // Some tooltips may choose not to show on Keyboard focus, get the ToolTip and query the property, 
-                // if we are unable to cast to a ToolTip that means a default ToolTip will be used, the default behavior is to show on focus.
-                ToolTip tooltip = tooltipObject as ToolTip;
-                bool enableOnKeyboardFocus = tooltip != null ? tooltip.ShouldShowOnKeyboardFocus : true;
+                // Some tooltips may choose not to show on Keyboard focus, get the ToolTip and query the property,                 // if we are unable to cast to a ToolTip that means a default ToolTip will be used, the default behavior is to show on focus.
+                bool enableOnKeyboardFocus = tooltipObject is ToolTip tooltip ? tooltip.ShouldShowOnKeyboardFocus : true;
 
                 if ((PopupControlService.IsElementEnabled(o) || GetShowOnDisabled(o))
                     && (triggerAction != ToolTip.ToolTipTrigger.KeyboardFocus || enableOnKeyboardFocus))
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeView.cs
index c875e0f9..647ecb8b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeView.cs
@@ -251,16 +251,14 @@ internal void ChangeSelection(object data, TreeViewItem container, bool selected
                 if (    _selectedContainer != null
                     &&  AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementSelected)   )
                 {
-                    TreeViewItemAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(_selectedContainer) as TreeViewItemAutomationPeer;
-                    if (peer != null)
+                    if (UIElementAutomationPeer.CreatePeerForElement(_selectedContainer) is TreeViewItemAutomationPeer peer)
                         peer.RaiseAutomationSelectionEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
                 }
 
                 if (    oldContainer != null
                     &&  AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection)   )
                 {
-                    TreeViewItemAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(oldContainer) as TreeViewItemAutomationPeer;
-                    if (peer != null)
+                    if (UIElementAutomationPeer.CreatePeerForElement(_selectedContainer) is TreeViewItemAutomationPeer peer)
                         peer.RaiseAutomationSelectionEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
                 }
 
@@ -757,11 +755,9 @@ protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChanged
             }
             else
             {
-                DependencyObject currentFocus = Keyboard.FocusedElement as DependencyObject;
-                if (currentFocus != null)
+                if (Keyboard.FocusedElement is DependencyObject currentFocus)
                 {
-                    UIElement root = KeyboardNavigation.GetVisualRoot(this) as UIElement;
-                    if (root != null && root.IsKeyboardFocusWithin)
+                    if (KeyboardNavigation.GetVisualRoot(this) is UIElement root && root.IsKeyboardFocusWithin)
                     {
                         if (FocusManager.GetFocusScope(currentFocus) != root)
                         {
@@ -822,8 +818,7 @@ private static DependencyObject FindParent(DependencyObject o)
                 }
                 else
                 {
-                    FrameworkContentElement fce = ce as FrameworkContentElement;
-                    if (fce != null)
+                    if (ce is FrameworkContentElement fce)
                     {
                         return fce.Parent;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeViewItem.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeViewItem.cs
index 63ba8189..7efd161c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeViewItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/TreeViewItem.cs
@@ -114,10 +114,7 @@ private static void OnIsExpandedChanged(DependencyObject d, DependencyPropertyCh
             }
 
             TreeViewItemAutomationPeer peer = UIElementAutomationPeer.FromElement(item) as TreeViewItemAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent((bool)e.OldValue, isExpanded);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent((bool)e.OldValue, isExpanded);
 
             if (isExpanded)
             {
@@ -162,10 +159,7 @@ private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyCh
             item.Select(isSelected);
 
             TreeViewItemAutomationPeer peer = UIElementAutomationPeer.FromElement(item) as TreeViewItemAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseAutomationIsSelectedChanged(isSelected);
-            }
+            peer?.RaiseAutomationIsSelectedChanged(isSelected);
 
             if (isSelected)
             {
@@ -742,10 +736,7 @@ private static void OnMouseButtonDown(object sender, MouseButtonEventArgs e)
         {
             TreeViewItem tvi = (TreeViewItem)sender;
             TreeView tv = tvi.ParentTreeView;
-            if (tv != null)
-            {
-                tv.HandleMouseButtonDown();
-            }
+            tv?.HandleMouseButtonDown();
         }
         private static void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs e)
         {
@@ -792,10 +783,7 @@ private void HandleBringIntoView(RequestBringIntoViewEventArgs e)
         private object BringItemIntoView(object args)
         {
             FrameworkElement header = HeaderElement;
-            if (header != null)
-            {
-                header.BringIntoView();
-            }
+            header?.BringIntoView();
             return null;
         }
 
@@ -929,10 +917,7 @@ internal void ClearItemContainer(object item, ItemsControl parentItemsControl)
                 // the ItemValueStorage DP for this container.
 
                 VirtualizingPanel vp = ItemsHost as VirtualizingPanel;
-                if (vp != null)
-                {
-                    vp.OnClearChildrenInternal();
-                }
+                vp?.OnClearChildrenInternal();
 
                 ItemContainerGenerator.RemoveAllInternal(true /*saveRecycleQueue*/);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/UIElementCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/UIElementCollection.cs
index 21917c4c..68320ee5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/UIElementCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/UIElementCollection.cs
@@ -266,8 +266,7 @@ internal void ClearInternal()
                 //disconnect from logical tree
                 for (int i = 0; i < cnt; i++)
                 {
-                    UIElement e = visuals[i] as UIElement;
-                    if (e != null)
+                    if (visuals[i] is UIElement e)
                     {
                         ClearLogicalParent(e);
                     }
@@ -310,13 +309,11 @@ public virtual void RemoveAt(int index)
             VerifyWriteAccess();
 
             VisualCollection vc = _visualChildren;
-
             //disconnect from logical tree
-            UIElement e = vc[index] as UIElement;
 
             vc.RemoveAt(index);
 
-            if (e != null)
+            if (vc[index] is UIElement e)
                 ClearLogicalParent(e);
 
             _visualParent.InvalidateMeasure();
@@ -363,8 +360,7 @@ internal void RemoveRangeInternal(int index, int count)
                 //disconnect from logical tree
                 for (i = 0; i < count; i++)
                 {
-                    UIElement e = visuals[i] as UIElement;
-                    if (e != null)
+                    if (visuals[i] is UIElement e)
                     {
                         ClearLogicalParent(e);
                     }
@@ -492,10 +488,7 @@ public virtual IEnumerator GetEnumerator()
         /// <param name="element"></param>
         protected void SetLogicalParent(UIElement element)
         {
-            if (_logicalParent != null)
-            {
-                _logicalParent.AddLogicalChild(element);
-            }
+            _logicalParent?.AddLogicalChild(element);
         }
 
         /// <summary>
@@ -504,10 +497,7 @@ protected void SetLogicalParent(UIElement element)
         /// <param name="element"></param>
         protected void ClearLogicalParent(UIElement element)
         {
-            if (_logicalParent != null)
-            {
-                _logicalParent.RemoveLogicalChild(element);
-            }
+            _logicalParent?.RemoveLogicalChild(element);
         }
 
         /// <summary>
@@ -529,8 +519,7 @@ private void ValidateElement(UIElement element)
 
         private void VerifyWriteAccess()
         {
-            Panel p = _visualParent as Panel;
-            if (p != null && p.IsDataBound)
+            if (_visualParent is Panel p && p.IsDataBound)
             {
                 throw new InvalidOperationException(SR.Get(SRID.Panel_BoundPanel_NoChildren));
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ValidationResult.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ValidationResult.cs
index 652fa3c3..7ba87726 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ValidationResult.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/ValidationResult.cs
@@ -100,8 +100,7 @@ public override bool Equals(object obj)
             }
             else
             {
-                ValidationResult vr = obj as ValidationResult;
-                if (vr != null)
+                if (obj is ValidationResult vr)
                 {
                     return (IsValid == vr.IsValid) && (ErrorContent == vr.ErrorContent);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLength.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLength.cs
index db40b3ce..deaf9e32 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLength.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLength.cs
@@ -123,9 +123,8 @@ public VirtualizationCacheLength(double cacheBeforeViewport, double cacheAfterVi
         /// and unit type as oCompare.</returns>
         override public bool Equals(object oCompare)
         {
-            if (oCompare is VirtualizationCacheLength)
+            if (oCompare is VirtualizationCacheLength l)
             {
-                VirtualizationCacheLength l = (VirtualizationCacheLength)oCompare;
                 return (this == l);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLengthConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLengthConverter.cs
index 09fc35e0..cd87c765 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLengthConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizationCacheLengthConverter.cs
@@ -102,9 +102,9 @@ public override object ConvertFrom(ITypeDescriptorContext typeDescriptorContext,
         {
             if (source != null)
             {
-                if (source is string)
+                if (source is string s)
                 {
-                    return (FromString((string)source, cultureInfo));
+                    return (FromString(s, cultureInfo));
                 }
                 else
                 {
@@ -140,11 +140,8 @@ public override object ConvertTo(ITypeDescriptorContext typeDescriptorContext, C
                 throw new ArgumentNullException("destinationType");
             }
 
-            if (value != null
-                && value is VirtualizationCacheLength)
+            if (value is VirtualizationCacheLength gl)
             {
-                VirtualizationCacheLength gl = (VirtualizationCacheLength)value;
-
                 if (destinationType == typeof(string))
                 {
                     return (ToString(gl, cultureInfo));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingPanel.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingPanel.cs
index 5af4d4fa..8cb720f4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingPanel.cs
@@ -390,18 +390,14 @@ private static object CoerceIsVirtualizingWhenGrouping(DependencyObject d, objec
 
         internal static void OnVirtualizationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            ItemsControl ic = d as ItemsControl;
-            if (ic != null)
+            if (d is ItemsControl ic)
             {
                 Panel p = ic.ItemsHost;
                 if (p != null)
                 {
                     p.InvalidateMeasure();
                     ItemsPresenter itemsPresenter = VisualTreeHelper.GetParent(p) as ItemsPresenter;
-                    if (itemsPresenter != null)
-                    {
-                        itemsPresenter.InvalidateMeasure();
-                    }
+                    itemsPresenter?.InvalidateMeasure();
 
                     if (d is TreeView)
                     {
@@ -424,8 +420,7 @@ private static void VirtualizationPropertyChangePropagationRecursive(DependencyO
             int childrenCount = children.Count;
             for (int i=0; i<childrenCount; i++)
             {
-                IHierarchicalVirtualizationAndScrollInfo virtualizingChild = children[i] as IHierarchicalVirtualizationAndScrollInfo;
-                if (virtualizingChild != null)
+                if (children[i] is IHierarchicalVirtualizationAndScrollInfo virtualizingChild)
                 {
                     TreeViewItem.IsVirtualizingPropagationHelper(parent, (DependencyObject)virtualizingChild);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingStackPanel.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingStackPanel.cs
index d85ce735..e58d0d87 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingStackPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/VirtualizingStackPanel.cs
@@ -1241,7 +1241,7 @@ private void ClearAnchorInformation(bool shouldAbort)
                                 else
                                 {
                                     GroupItem groupItem = fe as GroupItem;
-                                    if (groupItem != null && groupItem.ItemsHost != null && groupItem.ItemsHost.IsVisible)
+                                    if (groupItem?.ItemsHost != null && groupItem.ItemsHost.IsVisible)
                                     {
                                         result = ComputeFirstContainerInViewport(viewportElement, direction, groupItem.ItemsHost, action, findTopContainer, out firstContainerOffsetFromViewport);
                                     }
@@ -1561,12 +1561,7 @@ public Rect MakeVisible(Visual visual, Rect rectangle)
                 }
 
                 OnScrollChange();
-                if (ScrollOwner != null)
-                {
-                    // When layout gets updated it may happen that visual is obscured by a ScrollBar
-                    // We call MakeVisible again to make sure element is visible in this case
-                    ScrollOwner.MakeVisible(visual, originalRect);
-                }
+                ScrollOwner?.MakeVisible(visual, originalRect);
             }
             else
             {
@@ -1646,11 +1641,7 @@ protected internal override void BringIndexIntoView(int index)
                                 groupItem.UpdateLayout();
 
                                 VirtualizingPanel itemsHost = groupItem.ItemsHost as VirtualizingPanel;
-                                if (itemsHost != null)
-                                {
-                                    // Recursively call child panels until item is found.
-                                    itemsHost.BringIndexIntoViewPublic(index);
-                                }
+                                itemsHost?.BringIndexIntoViewPublic(index);
                             }
                             break;
                         }
@@ -1981,10 +1972,7 @@ protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs
         {
             ItemsControl itemsControl = ItemsControl.GetItemsOwner(this);
 
-            if (itemsControl != null)
-            {
-                itemsControl.RaiseEvent(e);
-            }
+            itemsControl?.RaiseEvent(e);
         }
 
         #endregion
@@ -3099,10 +3087,7 @@ private Size RealMeasureOverride(Size constraint)
                             {
                                 DependencyObject itemsOwner = itemStorageProvider as DependencyObject;
                                 Panel parentPanel = (itemsOwner != null) ? VisualTreeHelper.GetParent(itemsOwner) as Panel : null;
-                                if (parentPanel != null)
-                                {
-                                    parentPanel.InvalidateMeasure();
-                                }
+                                parentPanel?.InvalidateMeasure();
                             }
                         }
 
@@ -3989,10 +3974,7 @@ protected override void OnClearChildren()
                 CleanupContainers(Int32.MaxValue, Int32.MaxValue, itemsControl);
             }
 
-            if (_realizedChildren != null)
-            {
-                _realizedChildren.Clear();
-            }
+            _realizedChildren?.Clear();
 
             InternalChildren.ClearInternal();
         }
@@ -4031,10 +4013,7 @@ private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArg
         internal void ClearAllContainers()
         {
             IItemContainerGenerator generator = Generator;
-            if (generator != null)
-            {
-                generator.RemoveAll();
-            }
+            generator?.RemoveAll();
         }
 
         #endregion
@@ -4080,7 +4059,7 @@ private static IHierarchicalVirtualizationAndScrollInfo GetVirtualizingChild(Dep
         private static IHierarchicalVirtualizationAndScrollInfo GetVirtualizingChild(DependencyObject element, ref bool isChildHorizontal)
         {
             IHierarchicalVirtualizationAndScrollInfo virtualizingChild = element as IHierarchicalVirtualizationAndScrollInfo;
-            if (virtualizingChild != null && virtualizingChild.ItemsHost != null)
+            if (virtualizingChild?.ItemsHost != null)
             {
                 isChildHorizontal = (virtualizingChild.ItemsHost.LogicalOrientationPublic == Orientation.Horizontal);
 
@@ -4405,10 +4384,7 @@ private static void ClearItemValueStorageRecursive(IContainItemStorage itemStora
                                                     // need to remeasure, which should count
                                                     // as part of the scroll operation
                                                     DispatcherOperation clearIsScrollActiveOperation = ClearIsScrollActiveOperationField.GetValue(this);
-                                                    if (clearIsScrollActiveOperation != null)
-                                                    {
-                                                        clearIsScrollActiveOperation.Abort();
-                                                    }
+                                                    clearIsScrollActiveOperation?.Abort();
                                                     clearIsScrollActiveOperation = Dispatcher.BeginInvoke(DispatcherPriority.Background,
                                                         (Action)ClearIsScrollActive);
 
@@ -6763,13 +6739,13 @@ private bool IsViewportEmpty(bool isHorizontal, Rect viewport)
                 virtualizingChild.MustDisableVirtualization = mustDisableVirtualization;
             }
 
-            if (child is IHierarchicalVirtualizationAndScrollInfo)
+            if (child is IHierarchicalVirtualizationAndScrollInfo iHierarchicalVirtualizationAndScrollInfo)
             {
                 //
                 // Ensure that measure is invalid through the items panel
                 // of the child, so it can react to the new viewport.
                 //
-                InvalidateMeasureOnItemsHost((IHierarchicalVirtualizationAndScrollInfo)child);
+                InvalidateMeasureOnItemsHost(iHierarchicalVirtualizationAndScrollInfo);
             }
         }
 
@@ -9526,7 +9502,7 @@ private static void ResetScrolling(VirtualizingStackPanel element)
         // At the time this method is called, scrolling state is in its new, valid state.
         private void OnScrollChange()
         {
-            if (ScrollOwner != null) { ScrollOwner.InvalidateScrollInfo(); }
+            ScrollOwner?.InvalidateScrollInfo();
         }
 
         /// <summary>
@@ -9806,10 +9782,7 @@ private void OnScrollChange()
             if (discardOffsets)
             {
                 // All saved offsets are now meaningless.  Discard them.
-                if (previouslyMeasuredOffsets != null)
-                {
-                    previouslyMeasuredOffsets.Clear();
-                }
+                previouslyMeasuredOffsets?.Clear();
                 lastPageSafeOffset = null;
                 lastPagePixelSize = null;
             }
@@ -12185,7 +12158,7 @@ internal static bool IsConfigured(VirtualizingStackPanel vsp)
             internal static bool IsTracing(VirtualizingStackPanel vsp)
             {
                 ScrollTracingInfo sti = ScrollTracingInfoField.GetValue(vsp);
-                return (sti != null && sti.ScrollTracer != null);
+                return (sti?.ScrollTracer != null);
             }
 
             internal static void Trace(VirtualizingStackPanel vsp, ScrollTraceOp op, params object[] args)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/WrapPanel.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/WrapPanel.cs
index d6284bc6..7b3a3e31 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/WrapPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/WrapPanel.cs
@@ -345,8 +345,7 @@ private void arrangeLine(double v, double lineV, int start, int end, bool useIte
             UIElementCollection children = InternalChildren;
             for(int i = start; i < end; i++)
             {
-                UIElement child = children[i] as UIElement;
-                if(child != null)
+                if(children[i] is UIElement child)
                 {
                     UVSize childSize = new UVSize(Orientation, child.DesiredSize.Width, child.DesiredSize.Height);
                     double layoutSlotU = (useItemU ? itemU : childSize.U);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/tooltip.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/tooltip.cs
index cadbd8d2..44201d99 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/tooltip.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/tooltip.cs
@@ -530,10 +530,7 @@ private void HookupParentPopup()
 
         internal void ForceClose()
         {
-            if (_parentPopup != null)
-            {
-                _parentPopup.ForceClose();
-            }
+            _parentPopup?.ForceClose();
         }
 
         private void OnPopupCouldClose(object sender, EventArgs e)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/validation.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/validation.cs
index 76b6af9d..3391918b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/validation.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Controls/validation.cs
@@ -263,10 +263,7 @@ private static void OnValidationAdornerSiteChanged(DependencyObject d, Dependenc
             DependencyObject oldSite = (DependencyObject)e.OldValue;
             DependencyObject newSite = (DependencyObject)e.NewValue;
 
-            if (oldSite != null)
-            {
-                oldSite.ClearValue(ValidationAdornerSiteForProperty);
-            }
+            oldSite?.ClearValue(ValidationAdornerSiteForProperty);
 
             if (newSite != null)
             {
@@ -331,10 +328,7 @@ private static void OnValidationAdornerSiteForChanged(DependencyObject d, Depend
             DependencyObject oldSiteFor = (DependencyObject)e.OldValue;
             DependencyObject newSiteFor = (DependencyObject)e.NewValue;
 
-            if (oldSiteFor != null)
-            {
-                oldSiteFor.ClearValue(ValidationAdornerSiteProperty);
-            }
+            oldSiteFor?.ClearValue(ValidationAdornerSiteProperty);
 
             if (newSiteFor != null)
             {
@@ -577,12 +571,12 @@ static void OnValidationError(DependencyObject source, ValidationError validatio
         {
             ValidationErrorEventArgs args = new ValidationErrorEventArgs(validationError, action);
 
-            if (source is ContentElement)
-                ((ContentElement)source).RaiseEvent(args);
-            else if (source is UIElement)
-                ((UIElement)source).RaiseEvent(args);
-            else if (source is UIElement3D)
-                ((UIElement3D)source).RaiseEvent(args);
+            if (source is ContentElement contentElement)
+                contentElement.RaiseEvent(args);
+            else if (source is UIElement uIElement)
+                uIElement.RaiseEvent(args);
+            else if (source is UIElement3D uIElement3D)
+                uIElement3D.RaiseEvent(args);
         }
 
         private static ControlTemplate CreateDefaultErrorTemplate()
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadius.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadius.cs
index 13767eff..429d5181 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadius.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadius.cs
@@ -69,9 +69,8 @@ public CornerRadius(double topLeft, double topRight, double bottomRight, double
         /// <returns>True if object is a CornerRadius and all sides of it are equal to this CornerRadius'.</returns>
         public override bool Equals(object obj)
         {
-            if (obj is CornerRadius)
+            if (obj is CornerRadius otherObj)
             {
-                CornerRadius otherObj = (CornerRadius)obj;
                 return (this == otherObj);
             }
             return (false);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadiusConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadiusConverter.cs
index c7f6ecb9..8338b19a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadiusConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/CornerRadiusConverter.cs
@@ -104,7 +104,7 @@ public override object ConvertFrom(ITypeDescriptorContext typeDescriptorContext,
         {
             if (source != null)
             {
-                if (source is string) { return FromString((string)source, cultureInfo); }
+                if (source is string s) { return FromString(s, cultureInfo); }
                 else                  { return new CornerRadius(Convert.ToDouble(source, cultureInfo)); }
             }
             throw GetConvertFromException(source);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpression.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpression.cs
index 7ccbe125..69becc02 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpression.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpression.cs
@@ -202,10 +202,7 @@ public override void UpdateTarget()
             if (IsDetached)
                 throw new InvalidOperationException(SR.Get(SRID.BindingExpressionIsDetached));
 
-            if (Worker != null)
-            {
-                Worker.RefreshValue();  // calls TransferValue
-            }
+            Worker?.RefreshValue();
         }
 
 #region Expression overrides
@@ -2692,10 +2689,7 @@ internal override void HandlePropertyInvalidation(DependencyObject d, Dependency
                 TransferValue();
             }
 
-            if (Worker != null)
-            {
-                Worker.OnSourceInvalidation(d, dp, args.IsASubPropertyChange);
-            }
+            Worker?.OnSourceInvalidation(d, dp, args.IsASubPropertyChange);
         }
 
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpressionBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpressionBase.cs
index 3edb43d7..a435d969 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpressionBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingExpressionBase.cs
@@ -933,8 +933,7 @@ internal virtual bool AttachOverride(DependencyObject target, DependencyProperty
             // root bindings on TextBox.Text need to listen for IME composition events
             if (dp == System.Windows.Controls.TextBox.TextProperty && IsReflective && !IsInBindingExpressionCollection)
             {
-                System.Windows.Controls.Primitives.TextBoxBase tbb = target as System.Windows.Controls.Primitives.TextBoxBase;
-                if (tbb != null)
+                if (target is System.Windows.Controls.Primitives.TextBoxBase tbb)
                 {
                     tbb.PreviewTextInput += OnPreviewTextInput;
                 }
@@ -964,8 +963,7 @@ internal virtual void DetachOverride()
             // root bindings on TextBox.Text need to stop listening for IME composition events
             if (TargetProperty == System.Windows.Controls.TextBox.TextProperty && IsReflective && !IsInBindingExpressionCollection)
             {
-                System.Windows.Controls.Primitives.TextBoxBase tbb = TargetElement as System.Windows.Controls.Primitives.TextBoxBase;
-                if (tbb != null)
+                if (TargetElement is System.Windows.Controls.Primitives.TextBoxBase tbb)
                 {
                     tbb.PreviewTextInput -= OnPreviewTextInput;
                 }
@@ -1327,8 +1325,7 @@ internal void EndSourceUpdate()
                 System.Windows.Controls.Primitives.TextBoxBase tbb = Target as System.Windows.Controls.Primitives.TextBoxBase;
                 MS.Internal.Documents.UndoManager undoManager = (tbb == null) ? null :
                     tbb.TextContainer.UndoManager;
-                if (undoManager != null &&
-                    undoManager.OpenedUnit != null &&
+                if (undoManager?.OpenedUnit != null &&
                     undoManager.OpenedUnit.GetType() != typeof(System.Windows.Documents.TextParentUndoUnit))
                 {
                     if (!HasValue(Feature.UpdateTargetOperation))
@@ -2049,10 +2046,7 @@ internal virtual bool IsDisconnected
         internal void Attach(DependencyObject target, DependencyProperty dp)
         {
             // make sure we're on the right thread to access the target
-            if (target != null)
-            {
-                target.VerifyAccess();
-            }
+            target?.VerifyAccess();
 
             IsAttaching = true;
             AttachOverride(target, dp);
@@ -2388,10 +2382,7 @@ internal void AddValidationError(ValidationError validationError, bool skipBindi
             if (!skipBindingGroup)
             {
                 BindingGroup bindingGroup = BindingGroup;
-                if (bindingGroup != null)
-                {
-                    bindingGroup.AddValidationError(validationError);
-                }
+                bindingGroup?.AddValidationError(validationError);
             }
         }
 
@@ -2404,10 +2395,7 @@ internal void RemoveValidationError(ValidationError validationError, bool skipBi
             if (!skipBindingGroup)
             {
                 BindingGroup bindingGroup = BindingGroup;
-                if (bindingGroup != null)
-                {
-                    bindingGroup.RemoveValidationError(validationError);
-                }
+                bindingGroup?.RemoveValidationError(validationError);
             }
         }
 
@@ -2820,12 +2808,7 @@ internal static object ReplaceReference(object oldReference, object item)
                 !(item == DisconnectedItem))
             {
 #if USE_ITEM_REFERENCE
-                // if this cast fails, it's because you have done a direct assignment of an
-                // item to some field instead of assigning the result of CreateReference.
-                oldReference = ((ItemReference)oldReference).Item;
-#endif
-                WeakReference wr = oldReference as WeakReference;
-                if (wr != null)
+                if (oldReference is WeakReference wr)
                 {
                     wr.Target = item;
                     item = wr;
@@ -2849,13 +2832,7 @@ internal static object GetReference(object reference)
                 return null;
 
 #if USE_ITEM_REFERENCE
-            // if this cast fails, it's because you have done a direct assignment of an
-            // item to some field instead of assigning the result of CreateReference.
-            reference = ((ItemReference)reference).Item;
-#endif
-
-            WeakReference wr = reference as WeakReference;
-            if (wr != null)
+            if (reference is WeakReference wr)
                 return wr.Target;
             else
                 return reference;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingGroup.cs
index 15d8553b..0813fd95 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingGroup.cs
@@ -343,10 +343,7 @@ public void BeginEdit()
                 for (int i=items.Count-1; i>=0; --i)
                 {
                     IEditableObject ieo = items[i] as IEditableObject;
-                    if (ieo != null)
-                    {
-                        ieo.BeginEdit();
-                    }
+                    ieo?.BeginEdit();
                 }
 
                 IsEditing = true;
@@ -387,10 +384,7 @@ public void CancelEdit()
             for (int i=items.Count-1; i>=0; --i)
             {
                 IEditableObject ieo = items[i] as IEditableObject;
-                if (ieo != null)
-                {
-                    ieo.CancelEdit();
-                }
+                ieo?.CancelEdit();
             }
 
             // update targets
@@ -599,8 +593,7 @@ internal override void AddInheritanceContext(DependencyObject context, Dependenc
                 !_hasMultipleInheritanceContexts &&
                 (ValidatesOnDataTransfer || ValidatesOnNotifyDataError))
             {
-                UIElement layoutElement = Helper.FindMentor(this) as UIElement;
-                if (layoutElement != null)
+                if (Helper.FindMentor(this) is UIElement layoutElement)
                 {
                     // do the validation at the end of the current layout pass, to allow
                     // bindings to join the group
@@ -730,10 +723,7 @@ internal void RemoveProposedValueEntry(ProposedValueEntry entry)
         internal void AddBindingForProposedValue(BindingExpressionBase dependent, object item, string propertyName)
         {
             ProposedValueEntry entry = _proposedValueTable[item, propertyName];
-            if (entry != null)
-            {
-                entry.AddDependent(dependent);
-            }
+            entry?.AddDependent(dependent);
         }
 
         // add a validation error to the mentor's list
@@ -874,10 +864,7 @@ void EnsureItems()
                 if (IsEditing)
                 {
                     IEditableObject ieo = newItems[i].Target as IEditableObject;
-                    if (ieo != null)
-                    {
-                        ieo.BeginEdit();
-                    }
+                    ieo?.BeginEdit();
                 }
 
                 // the item may implement INotifyDataErrorInfo
@@ -919,8 +906,7 @@ private void OnLayoutUpdated(object sender, EventArgs e)
             DependencyObject mentor = Helper.FindMentor(this);
 
             // only do this once
-            UIElement layoutElement = mentor as UIElement;
-            if (layoutElement != null)
+            if (mentor is UIElement layoutElement)
             {
                 layoutElement.LayoutUpdated -= new EventHandler(OnLayoutUpdated);
             }
@@ -1251,8 +1237,7 @@ bool CommitValues()
             IList items = Items;
             for (int i=items.Count-1; i>=0; --i)
             {
-                IEditableObject ieo = items[i] as IEditableObject;
-                if (ieo != null)
+                if (items[i] is IEditableObject ieo)
                 {
                     // PreSharp uses message numbers that the C# compiler doesn't know about.
                     // Disable the C# complaints, per the PreSharp documentation.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingListCollectionView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingListCollectionView.cs
index 2aa61ba0..a4dbb7d3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingListCollectionView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingListCollectionView.cs
@@ -590,20 +590,14 @@ public object AddNew()
             MoveCurrentTo(newItem);
 
             ISupportInitialize isi = newItem as ISupportInitialize;
-            if (isi != null)
-            {
-                isi.BeginInit();
-            }
+            isi?.BeginInit();
 
             // DataView.AddNew calls BeginEdit on the new item, but other implementations
             // of IBL don't.  Make up for them.
             if (!IsDataView)
             {
                 IEditableObject ieo = newItem as IEditableObject;
-                if (ieo != null)
-                {
-                    ieo.BeginEdit();
-                }
+                ieo?.BeginEdit();
             }
 
             return newItem;
@@ -663,9 +657,7 @@ public void CommitNew()
 
             if (_newItem == NoNewItem)
                 return;
-
             // commit the new item
-            ICancelAddNew ican = InternalList as ICancelAddNew;
             IEditableObject ieo;
 
             BindingOperations.AccessCollection(InternalList,
@@ -673,7 +665,7 @@ public void CommitNew()
                 {
                     ProcessPendingChanges();
 
-                    if (ican != null)
+                    if (InternalList is ICancelAddNew ican)
                     {
                         ican.EndNew(_newItemIndex);
                     }
@@ -710,9 +702,7 @@ public void CancelNew()
 
             if (_newItem == NoNewItem)
                 return;
-
             // cancel the AddNew
-            ICancelAddNew ican = InternalList as ICancelAddNew;
             IEditableObject ieo;
 
             BindingOperations.AccessCollection(InternalList,
@@ -720,7 +710,7 @@ public void CancelNew()
                 {
                     ProcessPendingChanges();
 
-                    if (ican != null)
+                    if (InternalList is ICancelAddNew ican)
                     {
                         ican.CancelNew(_newItemIndex);
                     }
@@ -748,8 +738,7 @@ object EndAddNew(bool cancel)
 
             SetNewItem(NoNewItem);  // leave "adding-new" mode
 
-            IEditableObject ieo = newItem as IEditableObject;
-            if (ieo != null)
+            if (newItem is IEditableObject ieo)
             {
                 if (cancel)
                 {
@@ -762,10 +751,7 @@ object EndAddNew(bool cancel)
             }
 
             ISupportInitialize isi = newItem as ISupportInitialize;
-            if (isi != null)
-            {
-                isi.EndInit();
-            }
+            isi?.EndInit();
 
             return newItem;
         }
@@ -982,10 +968,7 @@ public void EditItem(object item)
             SetEditItem(item);
 
             IEditableObject ieo = item as IEditableObject;
-            if (ieo != null)
-            {
-                ieo.BeginEdit();
-            }
+            ieo?.BeginEdit();
         }
 
         /// <summary>
@@ -1000,12 +983,10 @@ public void CommitEdit()
 
             if (_editItem == null)
                 return;
-
-            IEditableObject ieo = _editItem as IEditableObject;
             object editItem = _editItem;
             SetEditItem(null);
 
-            if (ieo != null)
+            if (_editItem is IEditableObject ieo)
             {
                 BindingOperations.AccessCollection(InternalList,
                     () =>
@@ -1039,11 +1020,9 @@ public void CancelEdit()
 
             if (_editItem == null)
                 return;
-
-            IEditableObject ieo = _editItem as IEditableObject;
             SetEditItem(null);
 
-            if (ieo != null)
+            if (_editItem is IEditableObject ieo)
             {
                 ieo.CancelEdit();
             }
@@ -1056,10 +1035,7 @@ private void ImplicitlyCancelEdit()
             IEditableObject ieo = _editItem as IEditableObject;
             SetEditItem(null);
 
-            if (ieo != null)
-            {
-                ieo.CancelEdit();
-            }
+            ieo?.CancelEdit();
         }
 
         /// <summary>
@@ -1455,9 +1431,8 @@ void RebuildLists()
         void RebuildListsCore()
         {
             _cachedList = new ArrayList(InternalList);
-            LiveShapingList lsList = _shadowList as LiveShapingList;
 
-            if (lsList != null)
+            if (_shadowList is LiveShapingList lsList)
                 lsList.LiveShapingDirty -= new EventHandler(OnLiveShapingDirty);
 
             if (_isGrouping && IsLiveGrouping == true)
@@ -2263,8 +2238,7 @@ void PrepareGroups()
             }
             else
             {
-                CollectionViewGroupInternal.IListComparer ilc = _group.ActiveComparer as CollectionViewGroupInternal.IListComparer;
-                if (ilc != null)
+                if (_group.ActiveComparer is CollectionViewGroupInternal.IListComparer ilc)
                 {
                     ilc.ResetList(list);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingOperations.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingOperations.cs
index c268cd8b..2d04fa92 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingOperations.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/BindingOperations.cs
@@ -185,8 +185,7 @@ public static BindingExpression GetBindingExpression(DependencyObject target, De
         {
             BindingExpressionBase expr = GetBindingExpressionBase(target, dp);
 
-            PriorityBindingExpression pb = expr as PriorityBindingExpression;
-            if (pb != null)
+            if (expr is PriorityBindingExpression pb)
                 expr = pb.ActiveBindingExpression;
 
             return expr as BindingExpression;
@@ -592,10 +591,7 @@ internal static IDisposable EnableExceptionLogging()
         internal static void LogException(Exception ex)
         {
             ExceptionLogger logger = _exceptionLogger;
-            if (logger != null)
-            {
-                logger.LogException(ex);
-            }
+            logger?.LogException(ex);
         }
 
         private static ExceptionLogger _exceptionLogger;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionContainer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionContainer.cs
index 6d9d0446..87e0fb62 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionContainer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionContainer.cs
@@ -93,10 +93,8 @@ public bool ShouldSerializeCollection()
                 return false;
             }
 
-            // Try to see if there is an item in the Collection without
-            // creating an enumerator.
-            ICollection collection = Collection as ICollection;
-            if (collection != null && collection.Count == 0)
+            // Try to see if there is an item in the Collection without            // creating an enumerator.
+            if (Collection is ICollection collection && collection.Count == 0)
             {
                 return false;
             }
@@ -105,10 +103,7 @@ public bool ShouldSerializeCollection()
             IEnumerator enumerator = Collection.GetEnumerator();
             bool result = enumerator.MoveNext();
             IDisposable d = enumerator as IDisposable;
-            if (d != null)
-            {
-                d.Dispose();
-            }
+            d?.Dispose();
 
             return result;
         }
@@ -197,8 +192,7 @@ internal object ViewItem(int index)
         {
             Invariant.Assert(index >= 0 && View != null);
 
-            CollectionView cv = View as CollectionView;
-            if (cv != null)
+            if (View is CollectionView cv)
             {
                 return cv.GetItemAt(index);
             }
@@ -215,8 +209,7 @@ internal int ViewIndexOf(object item)
             if (View == null)
                 return -1;
 
-            CollectionView cv = View as CollectionView;
-            if (cv != null)
+            if (View is CollectionView cv)
             {
                 return cv.IndexOf(item);
             }
@@ -233,8 +226,7 @@ internal void GetCollectionChangedSources(int level, Action<int, object, bool?,
             format(level, this, false, sources);
             if (_view != null)
             {
-                CollectionView cv = _view as CollectionView;
-                if (cv != null)
+                if (_view is CollectionView cv)
                 {
                     cv.GetCollectionChangedSources(level+1, format, sources);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionView.cs
index be2c3327..4037511c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CollectionView.cs
@@ -1444,10 +1444,7 @@ internal void VerifyRefreshNotDeferred()
         internal void InvalidateEnumerableWrapper()
         {
             IndexedEnumerable wrapper = (IndexedEnumerable) Interlocked.Exchange(ref _enumerableWrapper, null);
-            if (wrapper != null)
-            {
-                wrapper.Invalidate();
-            }
+            wrapper?.Invalidate();
         }
 
         internal ReadOnlyCollection<ItemPropertyInfo> GetItemProperties()
@@ -1585,10 +1582,7 @@ internal object GetRepresentativeItem()
             }
 
             IDisposable d = ie as IDisposable;
-            if (d != null)
-            {
-                d.Dispose();
-            }
+            d?.Dispose();
 
             return result;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CompositeCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CompositeCollection.cs
index 5938386e..b82bddd3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CompositeCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/CompositeCollection.cs
@@ -115,8 +115,7 @@ public void CopyTo(Array array, int index)
         /// </exception>
         public int Add(object newItem)
         {
-            CollectionContainer cc = newItem as CollectionContainer;
-            if (cc != null)
+            if (newItem is CollectionContainer cc)
             {
                 AddCollectionContainer(cc);
             }
@@ -136,8 +135,7 @@ public void Clear()
             // unhook contained collections
             for (int k=0, n=InternalList.Count;  k < n;  ++k)
             {
-                CollectionContainer cc = this[k] as CollectionContainer;
-                if (cc != null)
+                if (this[k] is CollectionContainer cc)
                 {
                     RemoveCollectionContainer(cc);
                 }
@@ -191,8 +189,7 @@ public int IndexOf(object indexItem)
         /// </exception>
         public void Insert(int insertIndex, object insertItem)
         {
-            CollectionContainer cc = insertItem as CollectionContainer;
-            if (cc != null)
+            if (insertItem is CollectionContainer cc)
             {
                 AddCollectionContainer(cc);
             }
@@ -237,8 +234,7 @@ public void RemoveAt(int removeIndex)
             {
                 object removedItem = this[removeIndex];
 
-                CollectionContainer cc = removedItem as CollectionContainer;
-                if (cc != null)
+                if (removedItem is CollectionContainer cc)
                 {
                     RemoveCollectionContainer(cc);
                 }
@@ -573,10 +569,9 @@ private bool FindRepeatedCollection(ArrayList collections)
             for (int i = 0; i < Count; ++i)
             {
                 CollectionContainer cc = this[i] as CollectionContainer;
-                if (cc != null && cc.Collection != null)
+                if (cc?.Collection != null)
                 {
-                    CompositeCollection composite = cc.Collection as CompositeCollection;
-                    if (composite != null)
+                    if (cc.Collection is CompositeCollection composite)
                     {
                         if (composite.FindRepeatedCollection(collections))
                             return true;
@@ -600,10 +595,7 @@ internal void GetCollectionChangedSources(int level, Action<int, object, bool?,
             foreach (object o in InternalList)
             {
                 CollectionContainer cc = o as CollectionContainer;
-                if (cc != null)
-                {
-                    cc.GetCollectionChangedSources(level+1, format, sources);
-                }
+                cc?.GetCollectionChangedSources(level + 1, format, sources);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/ListCollectionView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/ListCollectionView.cs
index 2fe20fd8..1ea660f6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/ListCollectionView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/ListCollectionView.cs
@@ -777,16 +777,10 @@ object AddNewCommon(object newItem)
             MoveCurrentTo(newItem);
 
             ISupportInitialize isi = newItem as ISupportInitialize;
-            if (isi != null)
-            {
-                isi.BeginInit();
-            }
+            isi?.BeginInit();
 
             IEditableObject ieo = newItem as IEditableObject;
-            if (ieo != null)
-            {
-                ieo.BeginEdit();
-            }
+            ieo?.BeginEdit();
 
             return newItem;
         }
@@ -1005,10 +999,7 @@ object EndAddNew(bool cancel)
             }
 
             ISupportInitialize isi = newItem as ISupportInitialize;
-            if (isi != null)
-            {
-                isi.EndInit();
-            }
+            isi?.EndInit();
 
             return newItem;
         }
@@ -1180,10 +1171,7 @@ public void EditItem(object item)
             SetEditItem(item);
 
             IEditableObject ieo = item as IEditableObject;
-            if (ieo != null)
-            {
-                ieo.BeginEdit();
-            }
+            ieo?.BeginEdit();
         }
 
         /// <summary>
@@ -1203,10 +1191,7 @@ public void CommitEdit()
             IEditableObject ieo = _editItem as IEditableObject;
             SetEditItem(null);
 
-            if (ieo != null)
-            {
-                ieo.EndEdit();
-            }
+            ieo?.EndEdit();
 
             // see if the item is entering or leaving the view
             int fromIndex = InternalIndexOf(editItem);
@@ -1326,10 +1311,7 @@ private void ImplicitlyCancelEdit()
             IEditableObject ieo = _editItem as IEditableObject;
             SetEditItem(null);
 
-            if (ieo != null)
-            {
-                ieo.CancelEdit();
-            }
+            ieo?.CancelEdit();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/MultiBinding.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/MultiBinding.cs
index 21a91fc0..d02228fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/MultiBinding.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/MultiBinding.cs
@@ -55,8 +55,7 @@ public MultiBinding()
     ///</param>
     void IAddChild.AddChild(Object value)
     {
-        BindingBase binding = value as BindingBase;
-        if (binding != null)
+        if (value is BindingBase binding)
             Bindings.Add(binding);
         else
             throw new ArgumentException(SR.Get(SRID.ChildHasWrongType, this.GetType().Name, "BindingBase", value.GetType().FullName), "value");
@@ -376,8 +375,7 @@ internal object DoFilterException(object bindExpr, Exception exception)
 
     internal static void CheckTrigger(BindingBase bb)
     {
-        Binding binding = bb as Binding;
-        if (binding != null)
+        if (bb is Binding binding)
         {
             if (binding.UpdateSourceTrigger != UpdateSourceTrigger.PropertyChanged &&
                 binding.UpdateSourceTrigger != UpdateSourceTrigger.Default)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBinding.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBinding.cs
index 72e81e31..c5f8f5c9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBinding.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBinding.cs
@@ -51,8 +51,7 @@ public PriorityBinding() : base()
     ///</param>
     void IAddChild.AddChild(Object value)
     {
-        BindingBase binding = value as BindingBase;
-        if (binding != null)
+        if (value is BindingBase binding)
             Bindings.Add(binding);
         else
             throw new ArgumentException(SR.Get(SRID.ChildHasWrongType, this.GetType().Name, "BindingBase", value.GetType().FullName), "value");
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBindingExpression.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBindingExpression.cs
index 8f588d8f..c7d8221e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBindingExpression.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Data/PriorityBindingExpression.cs
@@ -84,10 +84,7 @@ public override bool HasValidationError
     public override void UpdateTarget()
     {
         BindingExpressionBase bindExpr = ActiveBindingExpression;
-        if (bindExpr != null)
-        {
-            bindExpr.UpdateTarget();
-        }
+        bindExpr?.UpdateTarget();
     }
 
     /// <summary> Send the current value back to the source </summary>
@@ -95,10 +92,7 @@ public override void UpdateTarget()
     public override void UpdateSource()
     {
         BindingExpressionBase bindExpr = ActiveBindingExpression;
-        if (bindExpr != null)
-        {
-            bindExpr.UpdateSource();
-        }
+        bindExpr?.UpdateSource();
     }
 
 #region Expression overrides
@@ -148,9 +142,8 @@ internal override bool SetValue(DependencyObject d, DependencyProperty dp, objec
     // Create a new BindingExpression from the given Binding description
     internal static PriorityBindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, PriorityBinding binding, BindingExpressionBase owner)
     {
-        FrameworkPropertyMetadata fwMetaData = dp.GetMetadata(d.DependencyObjectType) as FrameworkPropertyMetadata;
 
-        if ((fwMetaData != null && !fwMetaData.IsDataBindingAllowed) || dp.ReadOnly)
+        if ((dp.GetMetadata(d.DependencyObjectType) is FrameworkPropertyMetadata fwMetaData && !fwMetaData.IsDataBindingAllowed) || dp.ReadOnly)
             throw new ArgumentException(SR.Get(SRID.PropertyNotBindable, dp.Name), "dp");
 
         // create the BindingExpression
@@ -417,10 +410,7 @@ internal override bool UpdateSource(BindingGroup bindingGroup)
     internal override void StoreValueInBindingGroup(object value, BindingGroup bindingGroup)
     {
         BindingExpressionBase bindExpr = ActiveBindingExpression;
-        if (bindExpr != null)
-        {
-            bindExpr.StoreValueInBindingGroup(value, bindingGroup);
-        }
+        bindExpr?.StoreValueInBindingGroup(value, bindingGroup);
     }
 
     /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DataTrigger.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DataTrigger.cs
index 0f14e516..e91f8365 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DataTrigger.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DataTrigger.cs
@@ -207,9 +207,7 @@ public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExte
             {
                 throw new ArgumentNullException("eventArgs");
             }
-
-            DataTrigger trigger = targetObject as DataTrigger;
-            if (trigger != null && eventArgs.Member.Name == "Binding" && eventArgs.MarkupExtension is BindingBase)
+            if (targetObject is DataTrigger trigger && eventArgs.Member.Name == "Binding" && eventArgs.MarkupExtension is BindingBase)
             {
                 trigger.Binding = eventArgs.MarkupExtension as BindingBase;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DeferrableContentConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DeferrableContentConverter.cs
index 6517e729..8f930d14 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DeferrableContentConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DeferrableContentConverter.cs
@@ -73,8 +73,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 Stream stream = value as Stream;
                 if (stream == null)
                 {
-                    byte[] bytes = value as byte[];
-                    if (bytes != null)
+                    if (value is byte[] bytes)
                     {
                         stream = new MemoryStream(bytes);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DependencyPropertyHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DependencyPropertyHelper.cs
index 748f1e96..f8734e2d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DependencyPropertyHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DependencyPropertyHelper.cs
@@ -119,10 +119,8 @@ public override int GetHashCode()
         /// </summary>
         public override bool Equals(object o)
         {
-            if (o is ValueSource)
+            if (o is ValueSource that)
             {
-                ValueSource that = (ValueSource)o;
-
                 return  this._baseValueSource == that._baseValueSource &&
                         this._isExpression == that._isExpression &&
                         this._isAnimated == that._isAnimated &&
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalker.cs
index 8dbaa7d4..3367a415 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalker.cs
@@ -112,17 +112,14 @@ private void IterateChildren(DependencyObject d)
             }
             else
             {
-                // Neither a FrameworkElement nor FrameworkContentElement.  See
-                //  if it's a Visual and if so walk the Visual collection
-                Visual v = d as Visual;
-                if (v != null)
+                // Neither a FrameworkElement nor FrameworkContentElement.  See                //  if it's a Visual and if so walk the Visual collection
+                if (d is Visual v)
                 {
                     WalkVisualChildren(v);
                 }
                 else
                 {
-                    Visual3D v3D = d as Visual3D;
-                    if (v3D != null)
+                    if (d is Visual3D v3D)
                     {
                         WalkVisualChildren(v3D);
                     }
@@ -206,8 +203,7 @@ private void WalkVisualChildren( Visual3D v )
                 {
                     while (logicalChildren.MoveNext())
                     {
-                        DependencyObject child = logicalChildren.Current as DependencyObject;
-                        if (child != null)
+                        if (logicalChildren.Current is DependencyObject child)
                         {
                             bool visitedViaVisualTree = false;
                             VisitNode(child, visitedViaVisualTree);
@@ -266,8 +262,8 @@ private void WalkVisualChildren( Visual3D v )
                         while (logicalChildren.MoveNext())
                         {
                             object current = logicalChildren.Current;
-                            FrameworkElement fe = current as FrameworkElement;
-                            if (fe != null)
+
+                            if (current is FrameworkElement fe)
                             {
                                 // For the case that both parents are identical, this node should
                                 // have already been visited when walking through visual
@@ -280,8 +276,7 @@ private void WalkVisualChildren( Visual3D v )
                             }
                             else
                             {
-                                FrameworkContentElement fce = current as FrameworkContentElement;
-                                if (fce != null)
+                                if (current is FrameworkContentElement fce)
                                 {
                                     bool visitedViaVisualTree = false;
                                     VisitNode(fce, visitedViaVisualTree);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalkerBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalkerBase.cs
index 86e62723..0af8da41 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalkerBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/DescendentsWalkerBase.cs
@@ -59,8 +59,7 @@ internal bool WasVisited(DependencyObject d)
                 else
                 {
                     // FrameworkContentElement
-                    FrameworkContentElement ancestorFCE = ancestor as FrameworkContentElement;
-                    logicalParent = (ancestorFCE != null) ? ancestorFCE.Parent : null;
+                    logicalParent = (ancestor is FrameworkContentElement ancestorFCE) ? ancestorFCE.Parent : null;
                 }
                 ancestor = logicalParent;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Diagnostics/ResourceDictionaryDiagnostics.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Diagnostics/ResourceDictionaryDiagnostics.cs
index 73b2009b..f091b092 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Diagnostics/ResourceDictionaryDiagnostics.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Diagnostics/ResourceDictionaryDiagnostics.cs
@@ -307,8 +307,7 @@ private static IEnumerable<T> GetOwners<T>(WeakReferenceList list, IEnumerable<T
             List<T> result = new List<T>(list.Count);
             foreach (Object o in list)
             {
-                T owner = o as T;
-                if (owner != null)
+                if (o is T owner)
                 {
                     result.Add(owner);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Adorner.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Adorner.cs
index 62664f82..baf3703e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Adorner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Adorner.cs
@@ -78,10 +78,7 @@ protected override Size MeasureOverride(Size constraint)
             for (int i = 0; i < count; i++)
             {
                 UIElement ch = this.GetVisualChild(i) as UIElement;
-                if (ch != null)
-                {
-                    ch.Measure(desiredSize);
-                }
+                ch?.Measure(desiredSize);
             }
 
             return desiredSize;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/AdornerLayer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/AdornerLayer.cs
index f2228dc1..6c16d01f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/AdornerLayer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/AdornerLayer.cs
@@ -286,7 +286,7 @@ public AdornerHitTestResult AdornerHitTest(Point point)
         {
             PointHitTestResult result = VisualTreeUtils.AsNearestPointHitTestResult(VisualTreeHelper.HitTest(this, point, false));
 
-            if (result != null && result.VisualHit != null)
+            if (result?.VisualHit != null)
             {
                 Visual visual = result.VisualHit;
 
@@ -322,10 +322,10 @@ static public AdornerLayer GetAdornerLayer(Visual visual)
 
             while (parent != null)
             {
-                if (parent is AdornerDecorator)
-                    return ((AdornerDecorator)parent).AdornerLayer;
-                if (parent is ScrollContentPresenter)
-                    return ((ScrollContentPresenter)parent).AdornerLayer;
+                if (parent is AdornerDecorator adornerDecorator)
+                    return adornerDecorator.AdornerLayer;
+                if (parent is ScrollContentPresenter scrollContentPresenter)
+                    return scrollContentPresenter.AdornerLayer;
 
                 parent = VisualTreeHelper.GetParent(parent) as Visual;
             }
@@ -909,9 +909,7 @@ private CombinedGeometry GetClipGeometry(Visual element, Adorner adorner)
         /// <returns>true if info was found and removed</returns>
         private bool RemoveAdornerInfo(IDictionary infoMap, Adorner adorner, object key)
         {
-            ArrayList adornerInfos = infoMap[key] as ArrayList;
-
-            if (adornerInfos != null)
+            if (infoMap[key] is ArrayList adornerInfos)
             {
                 AdornerInfo adornerInfo = GetAdornerInfo(adornerInfos, adorner);
                 if (adornerInfo != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CaretElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CaretElement.cs
index 4bce7f03..1839a319 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CaretElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CaretElement.cs
@@ -387,9 +387,8 @@ private void DoSimpleScrollToView(double scrollToOriginPosition, Rect scrollRect
         private void DoNavigationalScrollToView(double scrollToOriginPosition, Rect targetRect)
         {
             // Find the scroller from the render scope
-            ScrollViewer scroller = _textEditor._Scroller as ScrollViewer;
 
-            if (scroller != null)
+            if (_textEditor._Scroller is ScrollViewer scroller)
             {
                 Point targetPoint = new Point(targetRect.Left, targetRect.Top);
 
@@ -863,11 +862,7 @@ private void EnsureAttachedToView()
             if (layer == null)
             {
                 // There is no AdornerLayer available.  Clear cached value and exit.
-                if (_adornerLayer != null)
-                {
-                    // We're currently in a layer that doesn't exist.
-                    _adornerLayer.Remove(this);
-                }
+                _adornerLayer?.Remove(this);
 
                 _adornerLayer = null;
                 return;
@@ -879,11 +874,7 @@ private void EnsureAttachedToView()
                 return;
             }
 
-            if (_adornerLayer != null)
-            {
-                // We're currently in the wrong layer.
-                _adornerLayer.Remove(this);
-            }
+            _adornerLayer?.Remove(this);
 
             // Add ourselves to the correct layer.
             _adornerLayer = layer;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChangeBlockUndoRecord.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChangeBlockUndoRecord.cs
index 9be6bca0..84d40482 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChangeBlockUndoRecord.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChangeBlockUndoRecord.cs
@@ -94,9 +94,9 @@ internal void OnEndChange()
                 // UIElementPropertyUndoUnit can clear the undo stack if a change is made to a databound property
                 if (openedUnit == _parentUndoUnit)
                 {
-                    if (_parentUndoUnit is TextParentUndoUnit)
+                    if (_parentUndoUnit is TextParentUndoUnit textParentUndoUnit)
                     {
-                        ((TextParentUndoUnit)_parentUndoUnit).RecordRedoSelectionState();
+                        textParentUndoUnit.RecordRedoSelectionState();
                     }
                     Invariant.Assert(_undoManager != null);
                     _undoManager.Close(_parentUndoUnit, (_parentUndoUnit.LastUnit != null) ? UndoCloseAction.Commit : UndoCloseAction.Discard);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChildDocumentBlock.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChildDocumentBlock.cs
index ef641d5c..2a414bbd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChildDocumentBlock.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ChildDocumentBlock.cs
@@ -229,11 +229,10 @@ private void _EnsureBlockLoaded()
                 DocumentsTrace.FixedDocumentSequence.TextOM.Trace("Loading TextContainer " + _docRef.ToString());
                 // Load the TextContainer
                 IDocumentPaginatorSource idp = _docRef.GetDocument(false /*forceReload*/);
-                IServiceProvider isp = idp as IServiceProvider;
-                if (isp != null)
+
+                if (idp is IServiceProvider isp)
                 {
-                    ITextContainer tc = isp.GetService(typeof(ITextContainer)) as ITextContainer;
-                    if (tc != null)
+                    if (isp.GetService(typeof(ITextContainer)) is ITextContainer tc)
                     {
                         _container = tc;
                         DocumentsTrace.FixedDocumentSequence.TextOM.Trace("Got ITextContainer");
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ColumnResizeAdorner.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ColumnResizeAdorner.cs
index 36c1061e..a4e6b27b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ColumnResizeAdorner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ColumnResizeAdorner.cs
@@ -142,10 +142,7 @@ internal void Initialize(UIElement renderScope, double xPos, double yPos, double
 
             _adornerLayer = AdornerLayer.GetAdornerLayer(renderScope);
 
-            if (_adornerLayer != null)
-            {
-                _adornerLayer.Add(this);
-            }
+            _adornerLayer?.Add(this);
 
             _x = xPos;
             _top = yPos;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CompositionAdorner.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CompositionAdorner.cs
index 16a715c1..c5f21521 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CompositionAdorner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/CompositionAdorner.cs
@@ -56,7 +56,7 @@ internal CompositionAdorner(ITextView textView) : this(textView, new ArrayList()
         internal CompositionAdorner(ITextView textView, ArrayList attributeRanges)
             : base(textView.RenderScope)
         {
-            Debug.Assert(textView != null && textView.RenderScope != null);
+            Debug.Assert(textView?.RenderScope != null);
 
             // TextView to which this CompositionAdorner is attached as adorner and it will
             // als be used for GetRectangleFromTextPosition/GetLineRange
@@ -348,8 +348,7 @@ internal void InvalidateAdorner()
             }
 
             // Invalidate the CompositionAdorner to update the rendering.
-            AdornerLayer adornerLayer = VisualTreeHelper.GetParent(this) as AdornerLayer;
-            if (adornerLayer != null)
+            if (VisualTreeHelper.GetParent(this) is AdornerLayer adornerLayer)
             {
                 adornerLayer.Update(AdornedElement);
                 adornerLayer.InvalidateArrange();
@@ -365,11 +364,7 @@ internal void Initialize(ITextView textView)
 
             _adornerLayer = AdornerLayer.GetAdornerLayer(textView.RenderScope);
 
-            if (_adornerLayer != null)
-            {
-                // Add the CompositionAdorner to the scoping of AdornerLayer
-                _adornerLayer.Add(this);
-            }
+            _adornerLayer?.Add(this);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentReference.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentReference.cs
index 6e1873e7..d4bc542a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentReference.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentReference.cs
@@ -78,7 +78,7 @@ public DocumentReference() : base()
         /// <returns>The document tree</returns>
         public FixedDocument GetDocument(bool forceReload)
         {
-            DocumentsTrace.FixedDocumentSequence.IDF.Trace(string.Format("DocumentReference.GetDocument ({0}, {1})", Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source, forceReload));
+            DocumentsTrace.FixedDocumentSequence.IDF.Trace($"DocumentReference.GetDocument ({(Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source)}, {forceReload})");
              VerifyAccess();
 
             FixedDocument idp = null;
@@ -98,7 +98,7 @@ public FixedDocument GetDocument(bool forceReload)
                     FixedDocument idpReloaded = _LoadDocument();
                     if (idpReloaded != null)
                     {
-                        DocumentsTrace.FixedDocumentSequence.IDF.Trace(string.Format("DocumentReference.GetDocument Loaded IDP {0}", idpReloaded.GetHashCode()));
+                        DocumentsTrace.FixedDocumentSequence.IDF.Trace($"DocumentReference.GetDocument Loaded IDP {idpReloaded.GetHashCode()}");
                         // save the doc's identity
                         _docIdentity = idpReloaded;
                         idp = idpReloaded;
@@ -157,9 +157,7 @@ static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventAr
             {
                 Uri oldSource = (Uri) e.OldValue;
                 Uri newSource = (Uri) e.NewValue;
-                DocumentsTrace.FixedDocumentSequence.IDF.Trace(string.Format("====Replace old doc {0} with new {1}", 
-                    oldSource == null ? "null" : oldSource.ToString(), 
-                    newSource == null? "null" : newSource.ToString()));
+                DocumentsTrace.FixedDocumentSequence.IDF.Trace($"====Replace old doc {(oldSource == null ? "null" : oldSource.ToString())} with new {(newSource == null ? "null" : newSource.ToString())}");
                 // drop loaded document if source changed
                 docRef._doc = null;
                 //
@@ -210,10 +208,10 @@ Uri IUriContext.BaseUri
 #if DEBUG
         internal void Dump()
         {
-            DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("     This {0}", this.GetHashCode()));
-            DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("         Source {0}", this.Source == null ? "null" : this.Source.ToString()));
-            DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("         _doc   {0}", _doc == null ? 0 : _doc.GetHashCode()));
-            DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("         _docIdentity {0}", _docIdentity == null ? 0 : _docIdentity.GetHashCode()));
+            DocumentsTrace.FixedDocumentSequence.Content.Trace($"     This {this.GetHashCode()}");
+            DocumentsTrace.FixedDocumentSequence.Content.Trace($"         Source {(this.Source == null ? "null" : this.Source.ToString())}");
+            DocumentsTrace.FixedDocumentSequence.Content.Trace($"         _doc   {(_doc == null ? 0 : _doc.GetHashCode())}");
+            DocumentsTrace.FixedDocumentSequence.Content.Trace($"         _docIdentity {(_docIdentity == null ? 0 : _docIdentity.GetHashCode())}");
         }
 #endif
         #endregion Internal Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequence.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequence.cs
index 17a656ae..7df9fa35 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequence.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequence.cs
@@ -125,7 +125,7 @@ void IAddChild.AddChild(Object value)
             }
             else
             {
-                DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("Doc {0} Deferred", _references.Count));
+                DocumentsTrace.FixedDocumentSequence.Content.Trace($"Doc {_references.Count} Deferred");
                 if (_partialRef == null)
                 {
                     _partialRef = docRef;
@@ -248,7 +248,7 @@ public DocumentPaginator DocumentPaginator
         /// </summary>
         internal DocumentPage GetPage(int pageNumber)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPage({0})", pageNumber));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPage({pageNumber})");
 
             // Make sure that the call is in the right context.
 //             Dispatcher.VerifyAccess();
@@ -301,7 +301,7 @@ internal DocumentPage GetPage(FixedDocument document, int fixedDocPageNumber)
         /// </summary>
         internal void GetPageAsync(int pageNumber, object userState)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPageAsync({0}, {1})", pageNumber, userState));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPageAsync({pageNumber}, {userState})");
 
             // Make sure that the call is in the right context.
 //             Dispatcher.VerifyAccess();
@@ -339,10 +339,8 @@ internal int GetPageNumber(ContentPosition contentPosition)
             // Because of that we are expecting one of 2 types here.
             DynamicDocumentPaginator childPaginator = null;
             ContentPosition childContentPosition = null;
-            if (contentPosition is DocumentSequenceTextPointer)
+            if (contentPosition is DocumentSequenceTextPointer dsTextPointer)
             {
-                DocumentSequenceTextPointer dsTextPointer = (DocumentSequenceTextPointer)contentPosition;
-
                 #pragma warning suppress 6506 // dsTextPointer is obviously not null
                 childPaginator = GetPaginator(dsTextPointer.ChildBlock.DocRef);
                 childContentPosition = dsTextPointer.ChildPointer as ContentPosition;
@@ -364,7 +362,7 @@ internal int GetPageNumber(ContentPosition contentPosition)
         /// </summary>
         internal void CancelAsync(object userState)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPageAsyncCancel([{0}])", userState));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPageAsyncCancel([{userState}])");
 
             if (userState == null)
             {
@@ -719,8 +717,7 @@ private void OnInitialized(object sender, EventArgs e)
                 DocumentPage docPage = GetPage(0);
                 if (docPage != null)
                 {
-                    FixedPage page = docPage.Visual as FixedPage;
-                    if (page != null)
+                    if (docPage.Visual is FixedPage page)
                     {
                         this.Language = page.Language;
                     }
@@ -738,7 +735,7 @@ private void _OnDocumentReferenceInitialized(object sender, EventArgs e)
 
             if (docRef == _partialRef)
             {
-                DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("Loaded DocumentReference {0}", _references.Count));
+                DocumentsTrace.FixedDocumentSequence.Content.Trace($"Loaded DocumentReference {_references.Count}");
                 _partialRef.Initialized -= new EventHandler(_OnDocumentReferenceInitialized);
                 _partialRef = null;
                 _references.Add(docRef);
@@ -759,7 +756,7 @@ private void _OnCollectionChanged(object sender, NotifyCollectionChangedEventArg
                     // get the affected item
                     object item = args.NewItems[0];
 
-                    DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("_OnCollectionChange: Add {0}", item.GetHashCode()));
+                    DocumentsTrace.FixedDocumentSequence.Content.Trace($"_OnCollectionChange: Add {item.GetHashCode()}");
                     AddLogicalChild(item);
 
                     int pageCount = this.PageCount;
@@ -774,7 +771,7 @@ private void _OnCollectionChanged(object sender, NotifyCollectionChangedEventArg
 
                     if (addedPages > 0)
                     {
-                        DocumentsTrace.FixedDocumentSequence.Content.Trace(string.Format("_OnCollectionChange: Add with IDP {0}", paginator.GetHashCode()));
+                        DocumentsTrace.FixedDocumentSequence.Content.Trace($"_OnCollectionChange: Add with IDP {paginator.GetHashCode()}");
                         _paginator.NotifyPaginationProgress(new PaginationProgressEventArgs(firstPage, addedPages));
                         _paginator.NotifyPagesChanged(new PagesChangedEventArgs(firstPage, addedPages));
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequenceHighlightLayer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequenceHighlightLayer.cs
index b55c1330..8db9917b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequenceHighlightLayer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentSequenceHighlightLayer.cs
@@ -74,7 +74,7 @@ internal override StaticTextPointer GetNextChangePosition(StaticTextPointer stat
         // to the FixedDocumentTextContainer which contains this layer.
         internal void RaiseHighlightChangedEvent(IList ranges)
         {
-            DocumentsTrace.FixedDocumentSequence.Highlights.Trace(string.Format("DSHL.RaiseHighlightChangedEvent ranges={0}", ranges.Count));
+            DocumentsTrace.FixedDocumentSequence.Highlights.Trace($"DSHL.RaiseHighlightChangedEvent ranges={ranges.Count}");
             Debug.Assert(ranges.Count > 0);
             if (this.Changed != null)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/SemanticBasicElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/SemanticBasicElement.cs
index 905cc4ef..c6e5a48e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/SemanticBasicElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/SemanticBasicElement.cs
@@ -216,9 +216,9 @@ public void Add(ListItemStructure listItem)
         
         void IAddChild.AddChild(object value)
         {
-            if (value is ListItemStructure)
+            if (value is ListItemStructure listItemStructure)
             {
-                _elementList.Add((ListItemStructure)value);
+                _elementList.Add(listItemStructure);
                 return;
             }
 
@@ -318,9 +318,9 @@ public void Add(TableRowGroupStructure tableRowGroup)
         
         void IAddChild.AddChild(object value)
         {
-            if (value is TableRowGroupStructure)
+            if (value is TableRowGroupStructure tableRowGroupStructure)
             {
-                _elementList.Add((TableRowGroupStructure)value);
+                _elementList.Add(tableRowGroupStructure);
                 return;
             }
             throw new ArgumentException(SR.Get(SRID.UnexpectedParameterType, value.GetType(), typeof(TableRowGroupStructure)), "value");
@@ -363,9 +363,9 @@ public void Add(TableRowStructure tableRow)
         
         void IAddChild.AddChild(object value)
         {
-            if (value is TableRowStructure)
+            if (value is TableRowStructure tableRowStructure)
             {
-                _elementList.Add((TableRowStructure)value);
+                _elementList.Add(tableRowStructure);
                 return;
             }
             throw new ArgumentException(SR.Get(SRID.UnexpectedParameterType, value.GetType(), typeof(TableRowStructure)), nameof(value));
@@ -409,9 +409,9 @@ public void Add(TableCellStructure tableCell)
     
         void IAddChild.AddChild(object value)
         {
-            if (value is TableCellStructure)
+            if (value is TableCellStructure tableCellStructure)
             {
-                _elementList.Add((TableCellStructure)value);
+                _elementList.Add(tableCellStructure);
                 return;
             }
             throw new ArgumentException(SR.Get(SRID.UnexpectedParameterType, value.GetType(), typeof(TableCellStructure)), nameof(value));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/StoryFragments.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/StoryFragments.cs
index 6b000633..92e7fedc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/StoryFragments.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/DocumentStructures/StoryFragments.cs
@@ -52,9 +52,9 @@ void IAddChild.AddChild(object value)
             //
             // Only the StoryFragment type are accepted. 
             //
-            if (value is StoryFragment)
+            if (value is StoryFragment storyFragment)
             {
-                _elementList.Add( (StoryFragment) value);
+                _elementList.Add( storyFragment);
                 return;
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDSBuilder.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDSBuilder.cs
index fb6b94ac..c852c8ec 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDSBuilder.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDSBuilder.cs
@@ -139,12 +139,8 @@ private void AddFixedNodeInFlow(int index, UIElement e)
         /// <param name="be"></param>
         private void _CreateFlowNodes(BlockElement be)
         {
-            //
-            // Break, NamedElement and SemanticBasicElement all derived from BlockElement.
-            // Break element is ignored for now.
-            //
-            NamedElement ne = be as NamedElement;
-            if (ne != null)
+            //            // Break, NamedElement and SemanticBasicElement all derived from BlockElement.            // Break element is ignored for now.            //
+            if (be is NamedElement ne)
             {
                 //
                 // That is the NamedElement, it might use namedReference or HierachyReference, 
@@ -154,8 +150,7 @@ private void _CreateFlowNodes(BlockElement be)
             }
             else
             {
-                SemanticBasicElement sbe = be as SemanticBasicElement;
-                if (sbe != null)
+                if (be is SemanticBasicElement sbe)
                 {
                     //
                     // Add the start node in the flow array.
@@ -220,7 +215,7 @@ private void AddChildofFixedNodeinFlow(int[] childIndex, NamedElement ne)
         private void SpecialProcessing(SemanticBasicElement sbe)
         {
             ds.ListItemStructure listItem = sbe as ds.ListItemStructure;
-            if (listItem != null && listItem.Marker != null)
+            if (listItem?.Marker != null)
             {
                 NameHashFixedNode fen;
                 if (_nameHashTable.TryGetValue(listItem.Marker, out fen) == true)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDocument.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDocument.cs
index 67825904..93cf9eff 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDocument.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedDocument.cs
@@ -159,7 +159,7 @@ void IAddChild.AddChild(Object value)
             }
             else
             {
-                DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("Page {0} Deferred", _pages.Count));
+                DocumentsTrace.FixedFormat.FixedDocument.Trace($"Page {_pages.Count} Deferred");
                 if (_partialPage == null)
                 {
                     _partialPage = fp;
@@ -329,7 +329,7 @@ public DocumentPaginator DocumentPaginator
         /// </param>
         internal DocumentPage GetPage(int pageNumber)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPage({0})", pageNumber));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPage({pageNumber})");
 
             // Make sure that the call is in the right context.
 //             Dispatcher.VerifyAccess();
@@ -374,7 +374,7 @@ internal DocumentPage GetPage(int pageNumber)
         /// <exception cref="ArgumentNullException">userState is NULL.</exception>
         internal void GetPageAsync(int pageNumber, object userState)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPageAsync({0}, {1})", pageNumber, userState));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPageAsync({pageNumber}, {userState})");
 
             // Make sure that the call is in the right context.
 //             Dispatcher.VerifyAccess();
@@ -436,7 +436,7 @@ internal int GetPageNumber(ContentPosition contentPosition)
         /// <exception cref="ArgumentNullException">userState is NULL.</exception>
         internal void CancelAsync(object userState)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPageAsyncCancel([{0}])", userState));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPageAsyncCancel([{userState}])");
 //             Dispatcher.VerifyAccess();
 
             if (userState == null)
@@ -472,7 +472,7 @@ internal ContentPosition GetObjectPosition(Object o)
             {
                 throw new ArgumentException(SR.Get(SRID.FixedDocumentExpectsDependencyObject));
             }
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDF.GetContentPositionForElement({0})", element));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDF.GetContentPositionForElement({element})");
             // Make sure that the call is in the right context.
 //             Dispatcher.VerifyAccess();
 
@@ -514,8 +514,7 @@ internal ContentPosition GetObjectPosition(Object o)
             {
                 FixedPosition fixedPosition;
                 FlowPosition flowPosition=null;
-                System.Windows.Shapes.Path p = element as System.Windows.Shapes.Path;
-                if (element is Glyphs || element is Image || (p != null &&  p.Fill is ImageBrush))
+                if (element is Glyphs || element is Image || (element is System.Windows.Shapes.Path p &&  p.Fill is ImageBrush))
                 {
                     fixedPosition = new FixedPosition(fixedPage.CreateFixedNode(pageIndex, (UIElement)element), 0);
                     flowPosition = FixedContainer.FixedTextBuilder.CreateFlowPosition(fixedPosition);
@@ -670,7 +669,7 @@ internal FixedPage SyncGetPageWithCheck(int index)
             {
                 return SyncGetPage(index, false /*forceReload*/);
             }
-            DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("SyncGetPageWithCheck {0} is invalid page", index));
+            DocumentsTrace.FixedFormat.FixedDocument.Trace($"SyncGetPageWithCheck {index} is invalid page");
             return null;
         }
 
@@ -679,7 +678,7 @@ internal FixedPage SyncGetPageWithCheck(int index)
         // Assumes index is valid
         internal FixedPage SyncGetPage(int index, bool forceReload)
         {
-            DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("SyncGetPage {0}", index));
+            DocumentsTrace.FixedFormat.FixedDocument.Trace($"SyncGetPage {index}");
             Debug.Assert(IsValidPageIndex(index));
 
             PageContentCollection pc = this.Pages;
@@ -748,7 +747,7 @@ internal void EnsurePageSize(FixedPage fp)
         // displaying page, we should remove this function.
         internal bool GetPageSize(ref Size pageSize, int pageNumber)
         {
-            DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("GetPageSize {0}", pageNumber));
+            DocumentsTrace.FixedFormat.FixedDocument.Trace($"GetPageSize {pageNumber}");
             if (pageNumber < Pages.Count)
             {
                 // NOTE: it is wrong to call this method when page is outstanding.
@@ -763,7 +762,7 @@ internal bool GetPageSize(ref Size pageSize, int pageNumber)
 #if DEBUG
                 else
                 {
-                    DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("====== GetPageSize {0}  Warning sync call made while async outstanding =====", pageNumber));
+                    DocumentsTrace.FixedFormat.FixedDocument.Trace($"====== GetPageSize {pageNumber}  Warning sync call made while async outstanding =====");
                 }
 #endif
 
@@ -879,8 +878,7 @@ private void OnInitialized(object sender, EventArgs e)
                 DocumentPage docPage = GetPage(0);
                 if (docPage != null)
                 {
-                    FixedPage page = docPage.Visual as FixedPage;
-                    if (page != null)
+                    if (docPage.Visual is FixedPage page)
                     {
                         this.Language = page.Language;
                     }
@@ -1031,7 +1029,7 @@ private void OnPageLoaded(object sender, EventArgs e)
             PageContent pc = (PageContent)sender;
             if (pc == _partialPage)
             {
-                DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("Loaded Page {0}", _pages.Count));
+                DocumentsTrace.FixedFormat.FixedDocument.Trace($"Loaded Page {_pages.Count}");
                 _partialPage.Initialized -= new EventHandler(OnPageLoaded);
                 _pages.Add(_partialPage);
                 _partialPage = null;
@@ -1041,8 +1039,8 @@ private void OnPageLoaded(object sender, EventArgs e)
         internal FixedPage GetFixedPage(int pageNumber)
         {
             FixedPage fp = null;
-            FixedDocumentPage fdp = GetPage(pageNumber) as FixedDocumentPage;
-            if (fdp != null && fdp != DocumentPage.Missing)
+
+            if (GetPage(pageNumber) is FixedDocumentPage fdp && fdp != DocumentPage.Missing)
             {
                 fp = fdp.FixedPage;
             }
@@ -1058,7 +1056,7 @@ private void OnHighlightChanged(object sender, HighlightChangedEventArgs args)
             Debug.Assert(args != null);
             Debug.Assert(args.Ranges != null);
 
-            DocumentsTrace.FixedTextOM.Highlight.Trace(string.Format("HightlightMoved From {0}-{1} To {2}-{3}",0, 0, 0, 0));
+            DocumentsTrace.FixedTextOM.Highlight.Trace($"HightlightMoved From {0}-{0} To {0}-{0}");
             Debug.Assert(args.Ranges.Count > 0 && ((TextSegment)args.Ranges[0]).Start.CompareTo(((TextSegment)args.Ranges[0]).End) < 0);
 
             // REVIEW:benwest:7/9/2004: This code is reseting the entire highlight data structure
@@ -1069,10 +1067,8 @@ private void OnHighlightChanged(object sender, HighlightChangedEventArgs args)
             ITextContainer tc = this.FixedContainer;
             Highlights highlights = null;
 
-            // If this document is part of a FixedDocumentSequence, we should use 
-            // the highlights that have been set on the sequence.
-            FixedDocumentSequence parent = this.Parent as FixedDocumentSequence;
-            if (parent != null)
+            // If this document is part of a FixedDocumentSequence, we should use             // the highlights that have been set on the sequence.
+            if (this.Parent is FixedDocumentSequence parent)
                 highlights = parent.TextContainer.Highlights;
             else
                 highlights = this.FixedContainer.Highlights;
@@ -1137,9 +1133,8 @@ private void OnHighlightChanged(object sender, HighlightChangedEventArgs args)
                 else
                 {
                     //look for annotation highlight
-                    AnnotationHighlightLayer.HighlightSegment highlightSegment = highlights.GetHighlightValue(highlightRangeStart,
-                        LogicalDirection.Forward, typeof(HighlightComponent)) as AnnotationHighlightLayer.HighlightSegment;
-                    if (highlightSegment != null)
+                    if (highlights.GetHighlightValue(highlightRangeStart,
+                        LogicalDirection.Forward, typeof(HighlightComponent)) is AnnotationHighlightLayer.HighlightSegment highlightSegment)
                     {
                         //this is a visible annotation highlight
                         highlightTransitionPosition = highlights.GetNextHighlightChangePosition(highlightTransitionPosition, LogicalDirection.Forward);
@@ -1198,10 +1193,7 @@ private void OnHighlightChanged(object sender, HighlightChangedEventArgs args)
             {
                 HighlightVisual hv = HighlightVisual.GetHighlightVisual(SyncGetPage(i, false /*forceReload*/));
 
-                if (hv != null)
-                {
-                    hv.InvalidateHighlights();
-                }
+                hv?.InvalidateHighlights();
             }
         }
 
@@ -1214,7 +1206,7 @@ private object GetPageAsyncDelegate(object arg)
         {
             GetPageAsyncRequest asyncRequest = (GetPageAsyncRequest)arg;
             PageContent pc = asyncRequest.PageContent;
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.GetPageAsyncDelegate {0}", Pages.IndexOf(pc)));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.GetPageAsyncDelegate {Pages.IndexOf(pc)}");
             // Initiate request for page if necessary
             if (!_pendingPages.Contains(pc))
             {
@@ -1233,7 +1225,7 @@ private object GetPageAsyncDelegate(object arg)
 
         private void OnGetPageRootCompleted(object sender, GetPageRootCompletedEventArgs args)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP.OnGetPageRootCompleted {0}", Pages.IndexOf((PageContent)sender)));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP.OnGetPageRootCompleted {Pages.IndexOf((PageContent)sender)}");
             // Mark this page as no longer pending
             PageContent pc = (PageContent)sender;
             pc.GetPageRootCompleted -= new GetPageRootCompletedEventHandler(OnGetPageRootCompleted);
@@ -1283,7 +1275,7 @@ private void OnGetPageRootCompleted(object sender, GetPageRootCompletedEventArgs
         // Notify the caller of IDFAsync.MeasurePageAsync
         private void _NotifyGetPageAsyncCompleted(DocumentPage page, int pageNumber, Exception error, bool cancelled, object userState)
         {
-            DocumentsTrace.FixedFormat.IDF.Trace(string.Format("IDP._NotifyGetPageAsyncCompleted {0} {1} {2} {3} {4}", page, pageNumber, error, cancelled, userState));
+            DocumentsTrace.FixedFormat.IDF.Trace($"IDP._NotifyGetPageAsyncCompleted {page} {pageNumber} {error} {cancelled} {userState}");
             _paginator.NotifyGetPageCompleted(new GetPageCompletedEventArgs(
                                                page,
                                                pageNumber,
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedElement.cs
index f0890789..89e7a444 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedElement.cs
@@ -296,8 +296,8 @@ internal object BuildObjectTree()
         private Image GetImage()
         {
             Image image = null; // return value
-            Uri source = _object as Uri;
-            if (source != null)
+
+            if (_object is Uri source)
             {
                 image = new Image();
                 image.Source = new System.Windows.Media.Imaging.BitmapImage(source);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedFindEngine.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedFindEngine.cs
index 163da9fa..17f3920d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedFindEngine.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedFindEngine.cs
@@ -75,10 +75,7 @@ internal sealed class FixedFindEngine
             FixedDocumentSequence documentSequence = paginatorSource as FixedDocumentSequence;
             DynamicDocumentPaginator childPaginator = null;
 
-            if (documentSequence != null)
-            {
-                documentSequence.TranslatePageNumber(pageNumber, out childPaginator, out translatedPageNumber);
-            }
+            documentSequence?.TranslatePageNumber(pageNumber, out childPaginator, out translatedPageNumber);
             
             if (pageNumber - endPageNumber != 0)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHighlight.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHighlight.cs
index dc4b51fe..53b1eaee 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHighlight.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHighlight.cs
@@ -113,14 +113,13 @@ internal Rect ComputeDesignRect()
             if (g == null)
             {
                 Image im = _element as Image;
-                if (im != null && im.Source != null)
+                if (im?.Source != null)
                 {
                     return new Rect(0, 0, im.Width, im.Height);
                 }
                 else
                 {
-                    Path p = _element as Path;
-                    if (p != null)
+                    if (_element is Path p)
                     {
                         return p.Data.Bounds;
                     }
@@ -177,7 +176,7 @@ internal Rect ComputeDesignRect()
             designRect.Width = width;
 
 #if DEBUG
-            DocumentsTrace.FixedTextOM.Highlight.Trace(string.Format("DesignBound {0}", designRect));
+            DocumentsTrace.FixedTextOM.Highlight.Trace($"DesignBound {designRect}");
 #endif
             return designRect;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHyperLink.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHyperLink.cs
index f277ac9d..84e5c155 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHyperLink.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedHyperLink.cs
@@ -48,9 +48,7 @@ internal static class FixedHyperLink
         /// </summary>
         public static void OnNavigationServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            FixedDocument fixedContent = d as FixedDocument;
-
-            if (fixedContent != null)
+            if (d is FixedDocument fixedContent)
             {
                 NavigationService oldService = (NavigationService) e.OldValue;
                 NavigationService newService = (NavigationService) e.NewValue;
@@ -74,14 +72,11 @@ public static void OnNavigationServiceChanged(DependencyObject d, DependencyProp
         /// <param name="e"></param>
         internal static void FragmentHandler(object sender, FragmentNavigationEventArgs e)
         {
-            NavigationService ns = sender as NavigationService;
-
-            if (ns != null)
+            if (sender is NavigationService ns)
             {
                 string fragment = e.Fragment;
-                IFixedNavigate fixedNavigate = ns.Content as IFixedNavigate;
 
-                if (fixedNavigate != null)
+                if (ns.Content is IFixedNavigate fixedNavigate)
                 {
                     fixedNavigate.NavigateAsync(e.Fragment);
                     e.Handled = true;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedNode.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedNode.cs
index d2b7b109..4d1550f8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedNode.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedNode.cs
@@ -238,9 +238,9 @@ internal int ComparetoIndex(int[] childPath)
         /// <returns>bool - true if the FixedNodes are equal, false otherwise</returns>
         public override bool Equals(object o)
         {
-            if (o is FixedNode)
+            if (o is FixedNode fixedNode)
             {
-                return Equals((FixedNode)o);
+                return Equals(fixedNode);
             }
 
             return false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPage.cs
index d831d8a2..d1ab9251 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPage.cs
@@ -127,8 +127,7 @@ protected override void OnPreviewMouseWheel(MouseWheelEventArgs e)
                 //
                 if (_uiElementCollection.Count != 0)
                 {
-                    Path path = _uiElementCollection[0] as Path;
-                    if (path != null)
+                    if (_uiElementCollection[0] is Path path)
                     {
                         if (_drawDebugVisual == 0)
                         {
@@ -577,12 +576,10 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                 if (highlightVisual == null && al != null)
                 {
                     //Get Page Content
-                    PageContent pc = LogicalTreeHelper.GetParent(this) as PageContent;
-                    if (pc != null)
+                    if (LogicalTreeHelper.GetParent(this) is PageContent pc)
                     {
                         //Get FixedDocument
-                        FixedDocument doc = LogicalTreeHelper.GetParent(pc) as FixedDocument;
-                        if (doc != null)
+                        if (LogicalTreeHelper.GetParent(pc) is FixedDocument doc)
                         {
                             if (al != null)
                             {
@@ -888,7 +885,7 @@ internal DependencyObject GetElement(FixedNode node)
 #if DEBUG
             if (node.ChildLevels > 1)
             {
-                DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("FixedPage.GetUIElement {0} is nested element", node));
+                DocumentsTrace.FixedFormat.FixedDocument.Trace($"FixedPage.GetUIElement {node} is nested element");
             }
 #endif
 
@@ -897,20 +894,20 @@ internal DependencyObject GetElement(FixedNode node)
             {
                 // Follow the path if necessary
                 currentLevelIndex = node[level];
-                if (element is Canvas)
+                if (element is Canvas canvas)
                 {
                     // Canvas is a known S0 grouping element.
                     // Boundary Node only would appear in first level!
-                    Debug.Assert(currentLevelIndex >= 0 && currentLevelIndex <= ((Canvas)element).Children.Count);
+                    Debug.Assert(currentLevelIndex >= 0 && currentLevelIndex <= canvas.Children.Count);
                     element = ((Canvas)element).Children[currentLevelIndex];
                 }
                 else 
                 {
-                    DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("FixedPage.GeElement {0} is non S0 grouping element in L[{1}]!", node, level));
+                    DocumentsTrace.FixedFormat.FixedDocument.Trace($"FixedPage.GeElement {node} is non S0 grouping element in L[{level}]!");
                     IEnumerable currentChildrens = LogicalTreeHelper.GetChildren((DependencyObject)element);
                     if (currentChildrens == null)
                     {
-                        DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("FixedPage.GetElement {0} is NOT a grouping element in L[{1}]!!!", node, level));
+                        DocumentsTrace.FixedFormat.FixedDocument.Trace($"FixedPage.GetElement {node} is NOT a grouping element in L[{level}]!!!");
                         return null;
                     }
 
@@ -933,7 +930,7 @@ internal DependencyObject GetElement(FixedNode node)
 #if DEBUG
             if (!(element is Glyphs))
             {
-                DocumentsTrace.FixedFormat.FixedDocument.Trace(string.Format("FixedPage.GetElement{0} is non-Glyphs", node));
+                DocumentsTrace.FixedFormat.FixedDocument.Trace($"FixedPage.GetElement{node} is non-Glyphs");
             }
 #endif
             return element;
@@ -1021,13 +1018,13 @@ internal int[] _CreateChildIndex(DependencyObject e)
             {
                 DependencyObject parent = LogicalTreeHelper.GetParent(e);
                 int childIndex = -1;
-                if (parent is FixedPage)
+                if (parent is FixedPage fixedPage)
                 {
-                    childIndex = ((FixedPage)parent).Children.IndexOf((UIElement)e);
+                    childIndex = fixedPage.Children.IndexOf((UIElement)e);
                 }
-                else if (parent is Canvas)
+                else if (parent is Canvas canvas)
                 {
-                    childIndex = ((Canvas)parent).Children.IndexOf((UIElement)e);
+                    childIndex = canvas.Children.IndexOf((UIElement)e);
                 }
                 else
                 {
@@ -1092,8 +1089,7 @@ private static String GetStartPartUriString(DependencyObject current)
                 DependencyObject parent = LogicalTreeHelper.GetParent(current);
                 while (parent != null)
                 {
-                    FixedDocumentSequence docSequence = parent as FixedDocumentSequence;
-                    if (docSequence != null)
+                    if (parent is FixedDocumentSequence docSequence)
                     {
                         //4) Retrieve DocumentSequence Uri
                         Uri startPartUri = ((IUriContext)docSequence).BaseUri;
@@ -1201,7 +1197,7 @@ override protected void OnRender(DrawingContext dc)
 
                     foreach (FlowNode node in pageNodes)
                     {
-                        if (node != null && node.FixedSOMElements != null)
+                        if (node?.FixedSOMElements != null)
                         {
                             foreach (FixedSOMElement somElement in node.FixedSOMElements)
                             {
@@ -1247,9 +1243,8 @@ private void _RenderMarkupOrder(DrawingContext dc, List<FixedNode> markupOrder)
             foreach (FixedNode node in markupOrder)
             {
                 DependencyObject ob = _fixedPage.GetElement(node);
-                Glyphs glyphs = ob as Glyphs;
-                Path path = ob as Path;
-                if (glyphs != null)
+
+                if (ob is Glyphs glyphs)
                 {
                     GlyphRun glyphRun = glyphs.ToGlyphRun();
                     Rect alignmentBox = glyphRun.ComputeAlignmentBox();
@@ -1263,7 +1258,7 @@ private void _RenderMarkupOrder(DrawingContext dc, List<FixedNode> markupOrder)
 
                     ++order;
                 }
-                else if (path != null)
+                else if (ob is Path path)
                 {
                     Geometry renderGeom = path.RenderedGeometry;
                     Pen backgroundPen = new Pen(Brushes.Black,1);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPageStructure.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPageStructure.cs
index c2a1d72f..b5c4326a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPageStructure.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedPageStructure.cs
@@ -66,7 +66,7 @@ internal FixedPageStructure(int pageIndex)
         /// <returns>string - A string representation of this object</returns>
         public override string ToString()
         {
-            return String.Format("Pg{0}- ", _pageIndex);
+            return $"Pg{_pageIndex}- ";
         }
 #endif
         #endregion Public Methods
@@ -103,7 +103,7 @@ internal void SetupLineResults(FixedLineResult[] lineResults)
             foreach(FixedLineResult lineResult in _lineResults)
             {
                 Debug.Assert(lineResult != null);
-                DocumentsTrace.FixedTextOM.Builder.Trace(string.Format("{0}\r\n", lineResult.ToString()));
+                DocumentsTrace.FixedTextOM.Builder.Trace($"{lineResult.ToString()}\r\n");
             }
             DocumentsTrace.FixedTextOM.Builder.Trace(string.Format("----LineResults End Dump-----\r\n"));            
 #endif
@@ -479,9 +479,7 @@ internal void RenderFlowNode(DrawingContext dc)
                         fixedElement = fn.Cookie as FixedElement;
                         String typeString = fixedElement.Type.ToString();
                         int indexofDot = typeString.LastIndexOf('.');
-                        ouptputString = String.Format("{0}-{1}",
-                                fn.ToString(),
-                                typeString.Substring(indexofDot+1));
+                        ouptputString = $"{fn.ToString()}-{typeString.Substring(indexofDot + 1)}";
 
                         ft = new FormattedText(ouptputString,  
                                                 EnglishCulture,
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMFixedBlock.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMFixedBlock.cs
index 131f945e..4f20607a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMFixedBlock.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMFixedBlock.cs
@@ -170,8 +170,7 @@ public void CombineWith(FixedSOMFixedBlock block)
         {
             foreach (FixedSOMSemanticBox box in block.SemanticBoxes)
             {
-                FixedSOMTextRun run = box as FixedSOMTextRun;
-                if (run != null)
+                if (box is FixedSOMTextRun run)
                 {
                     AddTextRun(run);
                 }
@@ -220,8 +219,7 @@ public override string ToString()
             StringBuilder builder = new StringBuilder();
             foreach (FixedSOMSemanticBox box in _semanticBoxes)
             {
-                FixedSOMTextRun run  = box as FixedSOMTextRun;
-                if (run != null)
+                if (box is FixedSOMTextRun run)
                 {
                     builder.Append(run.Text);
                     builder.Append(" ");
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMPage.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMPage.cs
index 94bf31b4..9b3c5ba3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMPage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMPage.cs
@@ -52,8 +52,7 @@ public override void Render(DrawingContext dc, string label, DrawDebugVisual deb
                     int boxIndex = 0;
                     for (int i=0; i<_semanticBoxes.Count; i++)
                     {
-                        FixedSOMGroup group = _semanticBoxes[i] as FixedSOMGroup;
-                        if (group != null)
+                        if (_semanticBoxes[i] is FixedSOMGroup group)
                         {
                             if (debugVisuals == DrawDebugVisual.Groups)
                             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTable.cs
index f83a7f24..34a81c2b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTable.cs
@@ -92,8 +92,8 @@ public bool AddContainer(FixedSOMContainer container)
                             if (cell.BoundingRect.Contains(bounds))
                             {
                                 cell.AddContainer(container);
-                                FixedSOMFixedBlock block = container as FixedSOMFixedBlock;
-                                if (block != null)
+
+                                if (container is FixedSOMFixedBlock block)
                                 {
                                     if (block.IsRTL)
                                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTableCell.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTableCell.cs
index ae07f016..d4ef2cfd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTableCell.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTableCell.cs
@@ -84,8 +84,7 @@ private bool _AddToInnerTable(FixedSOMContainer container)
         {
             foreach (FixedSOMSemanticBox box in _semanticBoxes)
             {
-                FixedSOMTable table = box as FixedSOMTable;
-                if (table != null &&
+                if (box is FixedSOMTable table &&
                     table.AddContainer(container))
                 {
                     return true;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTextRun.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTextRun.cs
index 724bcada..c5c560da 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTextRun.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedSOMTextRun.cs
@@ -214,10 +214,8 @@ public bool HasSameRichProperties(FixedSOMTextRun run)
                 run.FontFamily == this.FontFamily &&
                 run.IsRTL == this.IsRTL)
             {
-                SolidColorBrush thisBrush = this.Foreground as SolidColorBrush;
-                SolidColorBrush otherBrush = run.Foreground as SolidColorBrush;
                 if ((run.Foreground == null && this.Foreground == null) ||
-                     thisBrush != null && otherBrush != null && thisBrush.Color == otherBrush.Color && thisBrush.Opacity == otherBrush.Opacity)
+                     this.Foreground is SolidColorBrush thisBrush && run.Foreground is SolidColorBrush otherBrush && thisBrush.Color == otherBrush.Color && thisBrush.Opacity == otherBrush.Opacity)
                 {
                     return true;    
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextBuilder.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextBuilder.cs
index f147725b..f175e007 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextBuilder.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextBuilder.cs
@@ -172,7 +172,7 @@ internal FixedTextBuilder(FixedTextContainer container)
         internal void AddVirtualPage()
         {
 #if DEBUG
-            DocumentsTrace.FixedTextOM.Builder.Trace(string.Format("AppendVirtualPage {0}", _pageStructures.Count));
+            DocumentsTrace.FixedTextOM.Builder.Trace($"AppendVirtualPage {_pageStructures.Count}");
 #endif
             FixedPageStructure pageStructure = new FixedPageStructure(_pageStructures.Count);
 #if DEBUG
@@ -868,10 +868,7 @@ private GlyphComparison _CompareGlyphs(Glyphs glyph1, Glyphs glyph2)
                     GeneralTransform transform = glyph2.TransformToVisual(glyph1);
                     Point prevPt = LTR1 ? box1.TopRight : box1.TopLeft;
                     Point currentPt = LTR2 ? box2.TopLeft : box2.TopRight;
-                    if (transform != null)
-                    {
-                        transform.TryTransform(currentPt, out currentPt);
-                    }
+                    transform?.TryTransform(currentPt, out currentPt);
 
                     if (IsSameLine(currentPt.Y - prevPt.Y, box1.Height, box2.Height))
                     {
@@ -960,7 +957,7 @@ Matrix transform
                 if (!constructLines)
                 {
                     namedNode = elements.Current as IFrameworkInputElement;
-                    if (namedNode != null && namedNode.Name != null && namedNode.Name.Length != 0)
+                    if (namedNode?.Name != null && namedNode.Name.Length != 0)
                     {
                         pageStructure.FixedDSBuilder.BuildNameHashTable(namedNode.Name,
                                     elements.Current as UIElement,
@@ -1076,13 +1073,13 @@ private void _CreateFlowNodes(FixedSOMContainer node, FlowModelBuilder flowBuild
 
             foreach (FixedSOMSemanticBox box in children)
             {
-                if (box is FixedSOMElement)
+                if (box is FixedSOMElement fixedSOMElement)
                 {
-                    flowBuilder.AddElement((FixedSOMElement)box);
+                    flowBuilder.AddElement(fixedSOMElement);
                 }
-                else if (box is FixedSOMContainer)
+                else if (box is FixedSOMContainer fixedSOMContainer)
                 {
-                    _CreateFlowNodes((FixedSOMContainer)box, flowBuilder);
+                    _CreateFlowNodes(fixedSOMContainer, flowBuilder);
                 }
                 else
                 {
@@ -1298,17 +1295,17 @@ public Uri GetUri(FixedSOMElement element, FixedPage p, out UIElement shadowElem
                     {
                         Transform t = e.TransformToAncestor(p) as Transform;
                         Geometry g;
-                        if (e is Glyphs)
+                        if (e is Glyphs glyphs)
                         {
-                            GlyphRun run = ((Glyphs)e).ToGlyphRun();
+                            GlyphRun run = glyphs.ToGlyphRun();
                             Rect designRect = run.ComputeAlignmentBox();
                             designRect.Offset(run.BaselineOrigin.X, run.BaselineOrigin.Y);
 
                             g = new RectangleGeometry(designRect);
                         }
-                        else if (e is Path)
+                        else if (e is Path path)
                         {
-                            g = ((Path)e).Data;
+                            g = path.Data;
                         }
                         else
                         {
@@ -1479,7 +1476,7 @@ public void AddElement(FixedSOMElement element)
                 FixedPage page = _builder.GetFixedPage(element.FixedNode);
                 UIElement shadowHyperlink;
                 Uri navUri = _logicalHyperlinkContainer.GetUri(element, page, out shadowHyperlink);
-                if (element is FixedSOMTextRun)
+                if (element is FixedSOMTextRun fixedSOMTextRun)
                 {
                     // Will add code to get font info for rich copy here
                     FixedSOMTextRun run = element as FixedSOMTextRun;
@@ -1517,15 +1514,14 @@ public void AddElement(FixedSOMElement element)
                         _currentRun = run;
                     }
 
-                    _textRuns.Add((FixedSOMTextRun)element);
+                    _textRuns.Add(fixedSOMTextRun);
                     if (_fixedNodes.Count == 0 || _fixedNodes[_fixedNodes.Count - 1] != element.FixedNode)
                     {
                         _fixedNodes.Add(element.FixedNode);
                     }
                 }
-                else if (element is FixedSOMImage)
+                else if (element is FixedSOMImage image)
                 {
-                    FixedSOMImage image = (FixedSOMImage)element;
                     _FinishTextRun(true);
                     _SetHyperlink(navUri, image.FixedNode, shadowHyperlink);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextContainer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextContainer.cs
index c699e0d1..5e688a20 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextContainer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextContainer.cs
@@ -47,7 +47,7 @@ internal sealed class FixedTextContainer : ITextContainer
         /// </param>
         internal FixedTextContainer(DependencyObject parent)
         {
-            Debug.Assert(parent != null && parent is FixedDocument);
+            Debug.Assert(parent is FixedDocument);
             _parent = parent;
             _CreateEmptyContainer();
         }
@@ -347,10 +347,9 @@ internal FixedTextPointer VerifyPosition(ITextPointer position)
 
         internal int GetPageNumber(ITextPointer  textPointer)
         {
-            FixedTextPointer fixedTextPointer = textPointer as FixedTextPointer;
             int  pageNumber = int.MaxValue;
 
-            if (fixedTextPointer != null)
+            if (textPointer is FixedTextPointer fixedTextPointer)
             {
                 if (fixedTextPointer.CompareTo(((ITextContainer)this).Start) == 0)
                 {
@@ -367,8 +366,6 @@ internal int GetPageNumber(ITextPointer  textPointer)
 
                     fixedTextPointer.FlowPosition.GetFlowNode(fixedTextPointer.LogicalDirection, out flowNode, out flowOffset);
 
-                    FixedElement fixedElement = flowNode.Cookie as FixedElement;
-
                     if (flowNode.Type == FlowNodeType.Boundary)
                     {
                         if (flowNode.Fp > 0)
@@ -386,7 +383,7 @@ internal int GetPageNumber(ITextPointer  textPointer)
                     {
                         pageNumber = (int)flowNode.Cookie;
                     }
-                    else if (fixedElement != null)
+                    else if (flowNode.Cookie is FixedElement fixedElement)
                     {
                         pageNumber = (int)fixedElement.PageIndex;
                     }
@@ -484,8 +481,7 @@ internal int GetPageNumber(ITextPointer  textPointer)
                         highlights.Add(page, lfs);
                     }
 
-                    FixedSOMTextRun textRun = elem as FixedSOMTextRun;
-                    if (textRun != null && textRun.IsReversed)
+                    if (elem is FixedSOMTextRun textRun && textRun.IsReversed)
                     {
                         int oldBeginOffset = beginOffset;
                         beginOffset = elem.EndIndex - endOffset;
@@ -514,9 +510,9 @@ internal FixedDocument FixedDocument
             {
                 if (_fixedPanel == null)
                 {
-                    if (_parent is FixedDocument)
+                    if (_parent is FixedDocument fixedDocument)
                     {
-                        _fixedPanel = (FixedDocument)_parent;
+                        _fixedPanel = fixedDocument;
                     }
                 }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextView.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextView.cs
index 863cdd89..e3f6fce4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FixedTextView.cs
@@ -95,20 +95,17 @@ internal override ITextPointer GetTextPositionFromPoint(Point point, bool snapTo
             bool isHit = _HitTest(point, out e);
             if (isHit)
             {
-                Glyphs g = e as Glyphs;
-                if (g != null)
+                if (e is Glyphs g)
                 {
                     pos = _CreateTextPointerFromGlyphs(g, point);
                 }
-                else if (e is Image)
+                else if (e is Image im)
                 {
-                    Image im = (Image)e;
                     FixedPosition fixedp = new FixedPosition(this.FixedPage.CreateFixedNode(this.PageIndex, im), 0);
                     pos = _CreateTextPointer(fixedp, LogicalDirection.Forward);
                 }
-                else if (e is Path)
+                else if (e is Path p)
                 {
-                    Path p = (Path)e;
                     if (p.Fill is ImageBrush)
                     {
                         FixedPosition fixedp = new FixedPosition(this.FixedPage.CreateFixedNode(this.PageIndex, p), 0);
@@ -124,7 +121,7 @@ internal override ITextPointer GetTextPositionFromPoint(Point point, bool snapTo
             }
 
 
-            DocumentsTrace.FixedTextOM.TextView.Trace(string.Format("GetTextPositionFromPoint P{0}, STT={1}, CP={2}", point, snapToText, pos == null ? "null" : ((FixedTextPointer)pos).ToString()));
+            DocumentsTrace.FixedTextOM.TextView.Trace($"GetTextPositionFromPoint P{point}, STT={snapToText}, CP={(pos == null ? "null" : ((FixedTextPointer)pos).ToString())}");
             return pos;
         }
 
@@ -157,7 +154,7 @@ internal override ITextPointer GetTextPositionFromPoint(Point point, bool snapTo
         internal override Rect GetRawRectangleFromTextPosition(ITextPointer position, out Transform transform)
         {
 #if DEBUG
-            DocumentsTrace.FixedTextOM.TextView.Trace(string.Format("GetRectFromTextPosition {0}, {1}", (FixedTextPointer)position, position.LogicalDirection));
+            DocumentsTrace.FixedTextOM.TextView.Trace($"GetRectFromTextPosition {(FixedTextPointer)position}, {position.LogicalDirection}");
 #endif
 
             FixedTextPointer ftp = Container.VerifyPosition(position);
@@ -204,17 +201,15 @@ internal override Rect GetRawRectangleFromTextPosition(ITextPointer position, ou
             }
 
             DependencyObject element = this.FixedPage.GetElement(fixedp.Node);
-            if (element is Glyphs)
+            if (element is Glyphs g)
             {
-                Glyphs g = (Glyphs)element;
                 designRect = _GetGlyphRunDesignRect(g, fixedp.Offset, fixedp.Offset);
                 // need to do transform
                 GeneralTransform tran = g.TransformToAncestor(this.FixedPage);
                 designRect = _GetTransformedCaretRect(tran, designRect.TopLeft, designRect.Height);
             }
-            else if (element is Image)
+            else if (element is Image image)
             {
-                Image image = (Image)element;
                 GeneralTransform tran = image.TransformToAncestor(this.FixedPage);
                 Point offset = new Point(0, 0);
                 if (fixedp.Offset > 0)
@@ -223,9 +218,8 @@ internal override Rect GetRawRectangleFromTextPosition(ITextPointer position, ou
                 }
                 designRect = _GetTransformedCaretRect(tran, offset, image.ActualHeight);
             }
-            else if (element is Path)
+            else if (element is Path path)
             {
-                Path path = (Path)element;
                 GeneralTransform tran = path.TransformToAncestor(this.FixedPage);
                 Rect bounds = path.Data.Bounds;
                 Point offset = bounds.TopLeft;
@@ -339,7 +333,7 @@ internal override ITextPointer GetPositionAtNextLine(ITextPointer position, doub
             newSuggestedX = suggestedX;
             linesMoved = 0;
 #if DEBUG
-            DocumentsTrace.FixedTextOM.TextView.Trace(string.Format("FixedTextView.MoveToLine {0}, {1}, {2}, {3}", (FixedTextPointer)position, position.LogicalDirection, suggestedX, count));
+            DocumentsTrace.FixedTextOM.TextView.Trace($"FixedTextView.MoveToLine {(FixedTextPointer)position}, {position.LogicalDirection}, {suggestedX}, {count}");
 #endif
 
             FixedPosition fixedp;
@@ -448,9 +442,8 @@ internal override bool IsAtCaretUnitBoundary(ITextPointer position)
             if (_GetFixedPosition(ftp, out fixedp))
             {
                 DependencyObject element = this.FixedPage.GetElement(fixedp.Node);
-                if (element is Glyphs)
+                if (element is Glyphs g)
                 {
-                    Glyphs g = (Glyphs)element;
                     int characterCount = (g.UnicodeString == null ? 0 : g.UnicodeString.Length);
                     if (fixedp.Offset == characterCount)
                     {   //end of line -- allow caret
@@ -519,9 +512,8 @@ internal override ITextPointer GetNextCaretUnitPosition(ITextPointer position, L
             if (_GetFixedPosition(ftp, out fixedp))
             {
                 DependencyObject element = this.FixedPage.GetElement(fixedp.Node);
-                if (element is Glyphs)
+                if (element is Glyphs g)
                 {
-                    Glyphs g = (Glyphs)element;
                     GlyphRun run = g.ToGlyphRun();
 
                     int characterCount = (run.Characters == null) ? 0 : run.Characters.Count;
@@ -588,7 +580,7 @@ internal override ITextPointer GetBackspaceCaretUnitPosition(ITextPointer positi
         internal override TextSegment GetLineRange(ITextPointer position)
         {
 #if DEBUG
-            DocumentsTrace.FixedTextOM.TextView.Trace(string.Format("GetLineRange {0}, {1}", (FixedTextPointer)position, position.LogicalDirection));
+            DocumentsTrace.FixedTextOM.TextView.Trace($"GetLineRange {(FixedTextPointer)position}, {position.LogicalDirection}");
 #endif
             FixedTextPointer ftp = Container.VerifyPosition(position);
             FixedPosition fixedp;
@@ -610,9 +602,9 @@ internal override TextSegment GetLineRange(ITextPointer position)
             DependencyObject element = FixedPage.GetElement(lastNode);
 
             int lastIndex = 1;
-            if (element is Glyphs)
+            if (element is Glyphs glyphs)
             {
-                lastIndex = ((Glyphs)element).UnicodeString.Length;
+                lastIndex = glyphs.UnicodeString.Length;
             }
 
             ITextPointer begin = _CreateTextPointer(new FixedPosition(fixedNodes[0], 0), LogicalDirection.Forward);
@@ -836,10 +828,7 @@ private ITextPointer _SnapToText(Point point)
                     Glyphs startGlyphs = this.FixedPage.GetGlyphsElement(node);
                     GeneralTransform tranToGlyphs = this.FixedPage.TransformToDescendant(startGlyphs);
                     Point transformedPt = point;
-                    if (tranToGlyphs != null)
-                    {                        
-                        tranToGlyphs.TryTransform(transformedPt, out transformedPt);
-                    }
+                    tranToGlyphs?.TryTransform(transformedPt, out transformedPt);
 
                     GlyphRun run = startGlyphs.ToGlyphRun();
                     Rect alignmentRect = run.ComputeAlignmentBox();
@@ -1179,7 +1168,7 @@ private ITextPointer _CreateTextPointer(FixedPosition fixedPosition, LogicalDire
             FlowPosition flowHit = Container.FixedTextBuilder.CreateFlowPosition(fixedPosition);
             if (flowHit != null)
             {
-                DocumentsTrace.FixedTextOM.TextView.Trace(string.Format("_CreatetTextPointer {0}:{1}", fixedPosition.ToString(), flowHit.ToString()));
+                DocumentsTrace.FixedTextOM.TextView.Trace($"_CreatetTextPointer {fixedPosition.ToString()}:{flowHit.ToString()}");
 
                 // Create a TextPointer from the flow position
                 return new FixedTextPointer(true, edge, flowHit);
@@ -1192,10 +1181,7 @@ private ITextPointer _CreateTextPointer(FixedPosition fixedPosition, LogicalDire
         private ITextPointer _CreateTextPointerFromGlyphs(Glyphs g, Point point)
         {
             GeneralTransform transform = this.VisualRoot.TransformToDescendant(g);
-            if (transform != null)
-            {
-                transform.TryTransform(point, out point);
-            }
+            transform?.TryTransform(point, out point);
 
             int charIndex;
             LogicalDirection edge;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowDocument.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowDocument.cs
index 9889632e..60d344d3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowDocument.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowDocument.cs
@@ -786,8 +786,7 @@ protected sealed override void OnPropertyChanged(DependencyPropertyChangedEventA
                 // so they will be aquired during first formatting (full format).
                 if (_structuralCache != null && _structuralCache.IsFormattedOnce)
                 {
-                    FrameworkPropertyMetadata fmetadata = e.Metadata as FrameworkPropertyMetadata;
-                    if (fmetadata != null)
+                    if (e.Metadata is FrameworkPropertyMetadata fmetadata)
                     {
                         bool affectsRender = (fmetadata.AffectsRender &&
                             (e.IsAValueChange || !fmetadata.SubPropertiesDoNotAffectRender));
@@ -806,10 +805,7 @@ protected sealed override void OnPropertyChanged(DependencyPropertyChangedEventA
                             _structuralCache.InvalidateFormatCache(!affectsRender);
 
                             // Notify formatter about content invalidation.
-                            if (_formatter != null)
-                            {
-                                _formatter.OnContentInvalidated(!affectsRender);
-                            }
+                            _formatter?.OnContentInvalidated(!affectsRender);
                         }
                     }
                 }
@@ -894,9 +890,9 @@ internal ContentPosition GetObjectPosition(Object element)
                 textPointer = this.ContentStart;
             }
             // If element is a TextElement, return its ContentStart.
-            else if (element is TextElement)
+            else if (element is TextElement textElement)
             {
-                textPointer = ((TextElement)element).ContentStart;
+                textPointer = textElement.ContentStart;
             }
             // Otherwise we are dealing with embedded element. Find its position in the
             // TextContainer and return it.
@@ -971,10 +967,7 @@ internal void OnChildDesiredSizeChanged(UIElement child)
                 _structuralCache.AddDirtyTextRange(dtr);
 
                 // Notify formatter about content invalidation.
-                if (_formatter != null)
-                {
-                    _formatter.OnContentInvalidated(true, childStart, childEnd);
-                }
+                _formatter?.OnContentInvalidated(true, childStart, childEnd);
             }
         }
 
@@ -1412,7 +1405,7 @@ private void OnHighlightChanged(object sender, HighlightChangedEventArgs args)
             {
                 // Invalidate affected pages and break records.
                 // We DTR invalidate if we're using a formatter as well for incremental update.
-                if (_formatter == null || !(_formatter is FlowDocumentFormatter))
+                if (!(_formatter is FlowDocumentFormatter))
                 {
                     _structuralCache.InvalidateFormatCache(/*Clear structure*/ false);
                 }
@@ -1500,7 +1493,7 @@ private void OnTextContainerChange(object sender, TextContainerChangeEventArgs a
 
                 // Invalidate affected pages and break records.
                 // We DTR invalidate if we're using a formatter as well for incremental update.
-                if (!args.AffectsRenderOnly || (_formatter != null && _formatter is FlowDocumentFormatter))
+                if (!args.AffectsRenderOnly || (_formatter is FlowDocumentFormatter))
                 {
                     // Create new DTR for changing range and add it to DRTList.
                     dtr = new DirtyTextRange(args);
@@ -1513,10 +1506,7 @@ private void OnTextContainerChange(object sender, TextContainerChangeEventArgs a
                 }
 
                 // Notify formatter about content invalidation.
-                if (_formatter != null)
-                {
-                    _formatter.OnContentInvalidated(!args.AffectsRenderOnly, args.ITextPosition, segmentEnd);
-                }
+                _formatter?.OnContentInvalidated(!args.AffectsRenderOnly, args.ITextPosition, segmentEnd);
             }
             finally
             {
@@ -1654,10 +1644,10 @@ void IAddChild.AddChild(Object value)
                 throw new ArgumentException(SR.Get(SRID.TextSchema_TheChildElementBelongsToAnotherTreeAlready, value.GetType().Name));
             }
 
-            if (value is Block)
+            if (value is Block block)
             {
                 TextContainer textContainer = _structuralCache.TextContainer;
-                ((Block)value).RepositionWithContent(textContainer.End);
+                block.RepositionWithContent(textContainer.End);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowNode.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowNode.cs
index 15a2f211..02877595 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowNode.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowNode.cs
@@ -156,8 +156,7 @@ public override string ToString()
                 case FlowNodeType.End:
                 case FlowNodeType.Object:
                 {
-                    FixedElement element = _cookie as FixedElement;
-                    if (element != null)
+                    if (_cookie is FixedElement element)
                     {
                         page = element.PageIndex;
                     }
@@ -182,7 +181,7 @@ public override string ToString()
             }
             
             
-            return String.Format("Pg{0}-nCp{1}-Id{2}-Tp{3}", page, _fp, _scopeId, System.Enum.GetName(typeof(FlowNodeType), _type));
+            return $"Pg{page}-nCp{_fp}-Id{_scopeId}-Tp{System.Enum.GetName(typeof(FlowNodeType), _type)}";
         }
 #endif
         #endregion Public Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowPosition.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowPosition.cs
index 876140c5..ee6a4f23 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowPosition.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/FlowPosition.cs
@@ -253,15 +253,14 @@ internal object GetAdjacentElement(LogicalDirection dir)
             else
             {
                 Object obj = ((FixedElement)flow._flowNode.Cookie).GetObject();
-                Image image = obj as Image;
-                if (type == FlowNodeType.Object && image != null)
+
+                if (type == FlowNodeType.Object && obj is Image image)
                 {
                     //Set width and height properties by looking at corresponding SOMImage
                     FixedSOMElement[] elements = flow._flowNode.FixedSOMElements;
                     if (elements != null && elements.Length > 0)
                     {
-                        FixedSOMImage somImage = elements[0] as FixedSOMImage;
-                        if (somImage != null)
+                        if (elements[0] is FixedSOMImage somImage)
                         {
                             image.Width = somImage.BoundingRect.Width;
                             image.Height = somImage.BoundingRect.Height;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Hyperlink.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Hyperlink.cs
index 3d98dddf..13c42f51 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Hyperlink.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Hyperlink.cs
@@ -866,14 +866,12 @@ static bool ShouldPreventUriSpoofing
 
         internal static void OnNavigateUriChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            IInputElement element = d as IInputElement;
-
             //
             // We only set up spoofing prevention for known objects that are IInputElements.
             // However, for backward compatibility we shouldn't make this callback fail since
             // other places such as FixedTextBuilder use NavigateUri e.g. for serialization.
             //
-            if (element != null)
+            if (d is IInputElement element)
             {
                 Uri navigateUri = (Uri)e.NewValue;
 
@@ -883,18 +881,16 @@ internal static void OnNavigateUriChanged(DependencyObject d, DependencyProperty
                 //
                 if (navigateUri != null)
                 {
-                    FrameworkElement fe = d as FrameworkElement;
 
-                    if (fe != null && ((fe is Path) || (fe is Canvas) || (fe is Glyphs) || (fe is FixedPage)))
+                    if (d is FrameworkElement fe && ((fe is Path) || (fe is Canvas) || (fe is Glyphs) || (fe is FixedPage)))
                     {
                         SetUpNavigationEventHandlers(element);
                         fe.Cursor = Cursors.Hand;
                     }
                     else
                     {
-                        FrameworkContentElement fce = d as FrameworkContentElement;
 
-                        if (fce != null && (fce is Hyperlink))
+                        if (d is FrameworkContentElement fce && (fce is Hyperlink))
                         {
                             SetUpNavigationEventHandlers(element);
                         }
@@ -1086,8 +1082,7 @@ private static void DoNonUserInitiatedNavigation(object sender)
         /// </summary>
         private static void DispatchNavigation(object sender)
         {
-            Hyperlink hl = sender as Hyperlink;
-            if (hl != null)
+            if (sender is Hyperlink hl)
             {
                 //
                 // Call the virtual OnClick on Hyperlink to keep old behavior.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ImmComposition.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ImmComposition.cs
index 5f804efa..6b47d84b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ImmComposition.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ImmComposition.cs
@@ -78,11 +78,10 @@ internal ImmComposition(HwndSource source)
         //
         internal static ImmComposition GetImmComposition(FrameworkElement scope)
         {
-            HwndSource source = PresentationSource.CriticalFromVisual(scope) as HwndSource;
 
             ImmComposition immComposition = null;
 
-            if (source != null)
+            if (PresentationSource.CriticalFromVisual(scope) is HwndSource source)
             {
                 lock (_list)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/InlineCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/InlineCollection.cs
index 9adde924..06d92aef 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/InlineCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/InlineCollection.cs
@@ -55,9 +55,7 @@ internal override int OnAdd(object value)
         {
             int index;
 
-            string text = value as string;
-
-            if (text != null)
+            if (value is string text)
             {
                 index = AddText(text, true /* returnIndex */);
             }
@@ -66,9 +64,7 @@ internal override int OnAdd(object value)
                 this.TextContainer.BeginChange();
                 try
                 {
-                    UIElement uiElement = value as UIElement;
-
-                    if (uiElement != null)
+                    if (value is UIElement uiElement)
                     {
                         index = AddUIElement(uiElement, true /* returnIndex */);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/PageContent.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/PageContent.cs
index ca41d5a6..f3500942 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/PageContent.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/PageContent.cs
@@ -83,14 +83,11 @@ public PageContent() : base()
         public FixedPage GetPageRoot(bool forceReload)
         {
 #if DEBUG
-            DocumentsTrace.FixedFormat.PageContent.Trace(string.Format("PageContent.GetPageRoot Source={0}", Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source));
+            DocumentsTrace.FixedFormat.PageContent.Trace($"PageContent.GetPageRoot Source={(Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source)}");
 #endif
 
 //             VerifyAccess();
-            if (_asyncOp != null)
-            {
-                _asyncOp.Wait();
-            }
+            _asyncOp?.Wait();
 
             FixedPage p = null;
 
@@ -115,7 +112,7 @@ public FixedPage GetPageRoot(bool forceReload)
         public void GetPageRootAsync(bool forceReload)
         {
 #if DEBUG
-            DocumentsTrace.FixedFormat.PageContent.Trace(string.Format("PageContent.GetPageRootAsync Source={0}", Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source));
+            DocumentsTrace.FixedFormat.PageContent.Trace($"PageContent.GetPageRootAsync Source={(Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source)}");
 #endif
 
 //             VerifyAccess();
@@ -155,7 +152,7 @@ public void GetPageRootAsync(bool forceReload)
         public void GetPageRootAsyncCancel()
         {
 #if DEBUG
-            DocumentsTrace.FixedFormat.PageContent.Trace(string.Format("PageContent.GetPageRootAsyncCancel Source={0}", Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source));
+            DocumentsTrace.FixedFormat.PageContent.Trace($"PageContent.GetPageRootAsyncCancel Source={(Source == null ? new Uri("", UriKind.RelativeOrAbsolute) : Source)}");
 #endif
 //             VerifyAccess();
             // Important: do not throw if no outstanding GetPageRootAsyncCall
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RtfToXamlReader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RtfToXamlReader.cs
index 2b000132..47aa5747 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RtfToXamlReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RtfToXamlReader.cs
@@ -3438,7 +3438,7 @@ internal void ComputePreferredCodePage()
             CodePage = 1252;
             CharSet = 0;
 
-            if (Name != null && Name.Length > 0)
+            if (!string.IsNullOrEmpty(Name))
             {
                 byte[] rgBytes = new byte[Name.Length * 6];
                 char[] rgChars = new char[Name.Length * 6];
@@ -4871,7 +4871,7 @@ internal void AppendXamlFontProperties(ConverterState converterState, StringBuil
             {
                 FontTableEntry entry = converterState.FontTable.FindEntryByIndex((int)fsThis.Font);
 
-                if (entry != null && entry.Name != null && !(entry.Name.Equals(string.Empty)))
+                if (entry?.Name != null && !(entry.Name.Equals(string.Empty)))
                 {
                     sb.Append(" FontFamily=\"");
 
@@ -5368,7 +5368,7 @@ private void AppendXamlPrefixListProperties(StringBuilder xamlStringBuilder)
 
         private void AppendXamlPrefixHyperlinkProperties(StringBuilder xamlStringBuilder)
         {
-            if (NavigateUri != null && NavigateUri.Length > 0)
+            if (!string.IsNullOrEmpty(NavigateUri))
             {
                 xamlStringBuilder.Append(" NavigateUri=\"");
                 xamlStringBuilder.Append(Converters.StringToXMLAttribute(NavigateUri));
@@ -8674,7 +8674,7 @@ private void ProcessSymbolFieldInstruction(DocumentNode dn, string instr, ref in
                     string name = instr.Substring(iStart, i - iStart);
                     // Move past trailing double-quote
                     i++;
-                    if (name != null && name.Length > 0)
+                    if (!string.IsNullOrEmpty(name))
                     {
                         dn.FormatState.Font = _converterState.FontTable.DefineEntryByName(name);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RubberbandSelector.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RubberbandSelector.cs
index 859b4f78..86236f98 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RubberbandSelector.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/RubberbandSelector.cs
@@ -68,9 +68,9 @@ internal void AttachRubberbandSelector(FrameworkElement scope)
             //If the passed-in scope is DocumentGrid, we want to
             //attach our commands to its DocumentViewerOwner, since
             //DocumentGrid is not focusable by default.
-            if (scope is DocumentGrid)
+            if (scope is DocumentGrid documentGrid)
             {
-                _uiScope = ((DocumentGrid)scope).DocumentViewerOwner;
+                _uiScope = documentGrid.DocumentViewerOwner;
                 Invariant.Assert(_uiScope != null, "DocumentGrid's DocumentViewerOwner cannot be null.");
             }
             else
@@ -156,10 +156,7 @@ private void UpdateHighlightVisual(FixedPage page)
             if (page != null)
             {
                 HighlightVisual hv = HighlightVisual.GetHighlightVisual(page);
-                if (hv != null)
-                {
-                    hv.UpdateRubberbandSelection(this);
-                }
+                hv?.UpdateRubberbandSelection(this);
             }
         }
 
@@ -577,15 +574,13 @@ private void OnQueryCursor(object sender, QueryCursorEventArgs e)
 
         private FixedDocumentPage GetFixedPanelDocumentPage(Point pt)
         {
-            DocumentGrid mpScope = _scope as DocumentGrid;
-            if (mpScope != null)
+            if (_scope is DocumentGrid mpScope)
             {
                 DocumentPage dp = mpScope.GetDocumentPageFromPoint(pt);
                 FixedDocumentPage fdp = dp as FixedDocumentPage;
                 if (fdp == null)
                 {
-                    FixedDocumentSequenceDocumentPage fdsdp = dp as FixedDocumentSequenceDocumentPage;
-                    if (fdsdp != null)
+                    if (dp is FixedDocumentSequenceDocumentPage fdsdp)
                     {
                         fdp = fdsdp.ChildDocumentPage as FixedDocumentPage;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Run.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Run.cs
index 28f9db1d..43186ca2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Run.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Run.cs
@@ -271,13 +271,10 @@ private static void OnTextPropertyChanged(DependencyObject d, DependencyProperty
                 run._changeEventNestingCount--;
             }
 
-            // We need to clear undo stack if we are in a RichTextBox and the value comes from
-            // data binding or some other expression.
-            FlowDocument document = run.TextContainer.Parent as FlowDocument;
-            if (document != null)
+            // We need to clear undo stack if we are in a RichTextBox and the value comes from            // data binding or some other expression.
+            if (run.TextContainer.Parent is FlowDocument document)
             {
-                RichTextBox rtb = document.Parent as RichTextBox;
-                if (rtb != null && run.HasExpression(run.LookupEntry(Run.TextProperty.GlobalIndex), Run.TextProperty))
+                if (document.Parent is RichTextBox rtb && run.HasExpression(run.LookupEntry(Run.TextProperty.GlobalIndex), Run.TextProperty))
                 {
                     UndoManager undoManager = rtb.TextEditor._GetUndoManager();
                     if (undoManager != null && undoManager.IsEnabled)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Serialization/SerializerDescriptor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Serialization/SerializerDescriptor.cs
index f879aa79..e936568c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Serialization/SerializerDescriptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Serialization/SerializerDescriptor.cs
@@ -335,8 +335,7 @@ public bool IsLoadable
         /// </summary>
         public override bool Equals(object obj)
         {
-            SerializerDescriptor sd = obj as SerializerDescriptor;
-            if (sd != null)
+            if (obj is SerializerDescriptor sd)
             {
                 return sd._displayName == _displayName
                 && sd._assemblyName == _assemblyName
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Speller.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Speller.cs
index 45c5809c..32899024 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Speller.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Speller.cs
@@ -528,10 +528,7 @@ private void OnTextContainerChange(object sender, TextContainerChangeEventArgs e
                 return;
             }
 
-            if (_statusTable != null)
-            {
-                _statusTable.OnTextChange(e);
-            }
+            _statusTable?.OnTextChange(e);
 
             ScheduleIdleCallback();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/SplayTreeNode.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/SplayTreeNode.cs
index ca427567..9553169c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/SplayTreeNode.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/SplayTreeNode.cs
@@ -215,11 +215,7 @@ internal SplayTreeNode GetPreviousNode()
                 }
             }
 
-            if (previousNode != null)
-            {
-                // Splay to keep the tree balanced.
-                previousNode.Splay();
-            }
+            previousNode?.Splay();
 
             return previousNode;
         }
@@ -268,11 +264,7 @@ internal SplayTreeNode GetNextNode()
                 }
             }
 
-            if (nextNode != null)
-            {
-                // Splay to keep the tree balanced.
-                nextNode.Splay();
-            }
+            nextNode?.Splay();
 
             return nextNode;
         }
@@ -342,8 +334,7 @@ internal int GetIMECharOffset()
                     break;
 
                 // Add the parent start edge.
-                TextTreeTextElementNode elementNode = node as TextTreeTextElementNode;
-                if (elementNode != null)
+                if (node is TextTreeTextElementNode elementNode)
                 {
                     charOffset += elementNode.IMELeftEdgeCharCount;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Table.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Table.cs
index 90b01d91..6eec08c3 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Table.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/Table.cs
@@ -78,8 +78,7 @@ void IAddChild.AddChild(object value)
                 throw new ArgumentNullException("value");
             }
 
-            TableRowGroup rowGroup = value as TableRowGroup;
-            if (rowGroup != null)
+            if (value is TableRowGroup rowGroup)
             {
                 RowGroups.Add(rowGroup);
                 return;
@@ -272,10 +271,7 @@ internal void OnStructureChanged()
 
                 // Table structure changes affect number of rows and colums. Need to notify peer about it.
                 TableAutomationPeer peer = ContentElementAutomationPeer.FromElement(this) as TableAutomationPeer;
-                if (peer != null)
-                {
-                    peer.OnStructureInvalidated();
-                }
+                peer?.OnStructureInvalidated();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableCell.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableCell.cs
index 62598688..91917773 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableCell.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableCell.cs
@@ -339,10 +339,7 @@ void IIndexedChild<TableRow>.OnAfterExitParentTree(TableRow parent)
         /// </summary>
         internal void OnEnterParentTree()
         {
-            if(Table != null)
-            {
-                Table.OnStructureChanged();
-            }
+            Table?.OnStructureChanged();
         }
 
         /// <summary>
@@ -589,10 +586,7 @@ private static void OnColumnSpanChanged(DependencyObject d, DependencyPropertyCh
 
             // Update AutomaitonPeer.
             TableCellAutomationPeer peer = ContentElementAutomationPeer.FromElement(cell) as TableCellAutomationPeer;
-            if (peer != null)
-            {
-                peer.OnColumnSpanChanged((int)e.OldValue, (int)e.NewValue);
-            }
+            peer?.OnColumnSpanChanged((int)e.OldValue, (int)e.NewValue);
         }
 
         /// <summary>
@@ -609,10 +603,7 @@ private static void OnRowSpanChanged(DependencyObject d, DependencyPropertyChang
 
             // Update AutomaitonPeer.
             TableCellAutomationPeer peer = ContentElementAutomationPeer.FromElement(cell) as TableCellAutomationPeer;
-            if (peer != null)
-            {
-                peer.OnRowSpanChanged((int)e.OldValue, (int)e.NewValue);
-            }
+            peer?.OnRowSpanChanged((int)e.OldValue, (int)e.NewValue);
         }
 
         #endregion Property Invalidation 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableColumn.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableColumn.cs
index 80af8b00..5676263e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableColumn.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableColumn.cs
@@ -271,10 +271,7 @@ private static bool IsValidWidth(object value)
         private static void OnWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
             Table table = ((TableColumn) d).Table;
-            if(table != null)
-            {
-                table.InvalidateColumns();
-            }
+            table?.InvalidateColumns();
         }
 
         /// <summary>
@@ -283,10 +280,7 @@ private static void OnWidthChanged(DependencyObject d, DependencyPropertyChanged
         private static void OnBackgroundChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
             Table table = ((TableColumn) d).Table;
-            if(table != null)
-            {
-                table.InvalidateColumns();
-            }
+            table?.InvalidateColumns();
         }
 
         #endregion Static Initialization 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRow.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRow.cs
index 0a443313..2896311b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRow.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRow.cs
@@ -74,8 +74,7 @@ void IAddChild.AddChild(object value)
                 throw new ArgumentNullException("value");
             }
 
-            TableCell cell = value as TableCell;
-            if (cell != null)
+            if (value is TableCell cell)
             {
                 Cells.Add(cell);
                 return;
@@ -173,10 +172,7 @@ void IIndexedChild<TableRowGroup>.OnAfterExitParentTree(TableRowGroup parent)
         /// </summary>
         internal void OnEnterParentTree()
         {
-            if (Table != null)
-            {
-                Table.OnStructureChanged();
-            }
+            Table?.OnStructureChanged();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRowGroup.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRowGroup.cs
index 11f9bda3..a39dbccd 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRowGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TableRowGroup.cs
@@ -88,8 +88,7 @@ void IAddChild.AddChild(object value)
                 throw new ArgumentNullException("value");
             }
 
-            TableRow row = value as TableRow;
-            if (row != null)
+            if (value is TableRow row)
             {
                 Rows.Add(row);
 
@@ -194,10 +193,7 @@ void IIndexedChild<Table>.OnAfterExitParentTree(Table parent)
         /// </summary>
         internal void OnEnterParentTree()
         {
-            if(Table != null)
-            {
-                Table.OnStructureChanged();
-            }
+            Table?.OnStructureChanged();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextContainer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextContainer.cs
index 612ff816..a1ff7d4e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextContainer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextContainer.cs
@@ -934,10 +934,7 @@ internal void InsertTextInternal(TextPointer position, object text)
 
             // Notify the TextElement of a content change.
             TextElement textElement = position.Parent as TextElement;
-            if (textElement != null)
-            {
-                textElement.OnTextUpdated();
-            }
+            textElement?.OnTextUpdated();
         }
 
         // InsertElement worker.  Adds a TextElement to the tree.
@@ -1271,10 +1268,7 @@ internal void DeleteContentInternal(TextPointer startPosition, TextPointer endPo
 
             Invariant.Assert(symbolCount > 0);
 
-            if (undoUnit != null)
-            {
-                undoUnit.SetTreeHashCode();
-            }
+            undoUnit?.SetTreeHashCode();
 
             // Public tree event.
             deletePosition = new TextPointer(startPosition, LogicalDirection.Forward);
@@ -2107,10 +2101,7 @@ private void ReparentLogicalChildren(SplayTreeNode firstChildNode, SplayTreeNode
                 }
 
                 TextElement textElement = logicalTreeNode as TextElement;
-                if (textElement != null)
-                {
-                    textElement.BeforeLogicalTreeChange();
-                }
+                textElement?.BeforeLogicalTreeChange();
 
                 try
                 {
@@ -2126,10 +2117,7 @@ private void ReparentLogicalChildren(SplayTreeNode firstChildNode, SplayTreeNode
                 }
                 finally
                 {
-                    if (textElement != null)
-                    {
-                        textElement.AfterLogicalTreeChange();
-                    }
+                    textElement?.AfterLogicalTreeChange();
                 }
 
                 if (node == lastChildNode)
@@ -2365,14 +2353,8 @@ private int DeleteContentFromSiblingTree(SplayTreeNode containingNode, TextPoint
 
                 // Make sure left/rightSubTree stay local roots, we might
                 // have inserted new elements in the AdjustRefCountsForContentDelete call.
-                if (leftSubTree != null)
-                {
-                    leftSubTree.Splay();
-                }
-                if (rightSubTree != null)
-                {
-                    rightSubTree.Splay();
-                }
+                leftSubTree?.Splay();
+                rightSubTree?.Splay();
                 // Similarly, middleSubtree might not be a local root any more,
                 // so splay it too.
                 middleSubTree.Splay();
@@ -2411,10 +2393,7 @@ private int DeleteContentFromSiblingTree(SplayTreeNode containingNode, TextPoint
                 // their contents.
                 Invariant.Assert(startPosition.Parent == endPosition.Parent);
                 TextElement textElement = startPosition.Parent as TextElement;
-                if (textElement != null)
-                {               
-                    textElement.OnTextUpdated();                    
-                }
+                textElement?.OnTextUpdated();
             }
 
             return symbolCount;
@@ -2743,12 +2722,7 @@ private int CutContent(TextPointer startPosition, TextPointer endPosition, out i
                 }
             }
 
-            if (rightSubTree != null)
-            {
-                // Make sure rightSubTree is a root before returning.
-                // We haven't done anything yet to ensure this.
-                rightSubTree.Splay();
-            }
+            rightSubTree?.Splay();
 
             Invariant.Assert(leftSubTree == null || leftSubTree.Role == SplayTreeNodeRole.LocalRoot);
             Invariant.Assert(middleSubTree == null || middleSubTree.Role == SplayTreeNodeRole.LocalRoot);
@@ -2918,10 +2892,7 @@ private char[] ExtractElementInternal(TextElement element, bool deep, out Extrac
 
             NextGeneration(true /* deletedContent */);
 
-            if (undoUnit != null)
-            {
-                undoUnit.SetTreeHashCode();
-            }
+            undoUnit?.SetTreeHashCode();
 
             // Raise the public event.
             if (deep)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditor.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditor.cs
index 3c810211..d53015eb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditor.cs
@@ -162,9 +162,9 @@ internal void OnDetach()
             UndoManager undoManager = UndoManager.GetUndoManager(_uiScope);
             if(undoManager != null)
             {
-                if (_textContainer is TextContainer)
+                if (_textContainer is TextContainer textContainer)
                 {
-                    ((TextContainer)_textContainer).DisableUndo(_uiScope);
+                    textContainer.DisableUndo(_uiScope);
                 }
                 else
                 {
@@ -294,18 +294,14 @@ internal void SetCustomDictionaries(bool add)
         // Forwards a spelling reform property change off to the speller.
         internal void SetSpellingReform(SpellingReform spellingReform)
         {
-            if (_speller != null)
-            {
-                _speller.SetSpellingReform(spellingReform);
-            }
+            _speller?.SetSpellingReform(spellingReform);
         }
 
         // Queries a FrameworkElement for its TextView
         internal static ITextView GetTextView(UIElement scope)
         {
-            IServiceProvider serviceProvider = scope as IServiceProvider;
 
-            return (serviceProvider != null) ? serviceProvider.GetService(typeof(ITextView)) as ITextView : null;
+            return (scope is IServiceProvider serviceProvider) ? serviceProvider.GetService(typeof(ITextView)) as ITextView : null;
         }
 
         // Maps a FrameworkElement to its TextSelection, if any.
@@ -437,9 +433,9 @@ internal void SetText(ITextRange range, string text, CultureInfo cultureInfo)
             range.Text = text;
 
             // mark the range with the current input language on the start position.
-            if (range is TextRange)
+            if (range is TextRange textRange)
             {
-                MarkCultureProperty((TextRange)range, cultureInfo);
+                MarkCultureProperty(textRange, cultureInfo);
             }
         }
 
@@ -600,9 +596,9 @@ internal void Undo()
                     TextEditorTyping._BreakTypingSequence(this);
 
                     // Clear springload formatting
-                    if (_selection is TextSelection)
+                    if (_selection is TextSelection textSelection)
                     {
-                        ((TextSelection)_selection).ClearSpringloadFormatting();
+                        textSelection.ClearSpringloadFormatting();
                     }
                 }
                 finally
@@ -653,9 +649,9 @@ internal void Redo()
                     TextEditorTyping._BreakTypingSequence(this);
 
                     // Clear springload formatting
-                    if (_selection is TextSelection)
+                    if (_selection is TextSelection textSelection)
                     {
-                        ((TextSelection)_selection).ClearSpringloadFormatting();
+                        textSelection.ClearSpringloadFormatting();
                     }
                 }
                 finally
@@ -1294,15 +1290,9 @@ internal bool _IsSourceInScope(object source)
         /// </summary>
         internal void CompleteComposition()
         {
-            if (TextStore != null)
-            {
-                TextStore.CompleteComposition();
-            }
+            TextStore?.CompleteComposition();
 
-            if (ImmComposition != null)
-            {
-                ImmComposition.CompleteComposition();
-            }
+            ImmComposition?.CompleteComposition();
         }
 
         #endregion Class Internal Methods
@@ -1625,18 +1615,12 @@ private object OnTextViewUpdatedWorker(object o)
                 return null;
             }
 
-            if (_textstore != null)
-            {
-                _textstore.OnLayoutUpdated();
-            }
+            _textstore?.OnLayoutUpdated();
 
             // IMM32's OnLostFocus handler. Clean the composition string if it exists.
             if (_immEnabled)
             {
-                if (_immComposition != null)
-                {
-                    _immComposition.OnLayoutUpdated();
-                }
+                _immComposition?.OnLayoutUpdated();
             }
 
             return null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorCopyPaste.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorCopyPaste.cs
index bd3cf4c9..8f57b2bf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorCopyPaste.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorCopyPaste.cs
@@ -136,7 +136,7 @@ internal static DataObject _CreateDataObject(TextEditor This, bool isDragDrop)
 
                     // Add a CF_BITMAP if we have only one image selected.
                     Image image = This.Selection.GetUIElementSelected() as Image;
-                    if (image != null && image.Source is System.Windows.Media.Imaging.BitmapSource)
+                    if (image?.Source is System.Windows.Media.Imaging.BitmapSource)
                     {
                         dataObject.SetImage((System.Windows.Media.Imaging.BitmapSource)image.Source);
                     }
@@ -689,9 +689,7 @@ private static bool PasteContentData(TextEditor This, IDataObject dataObject, ID
                 // there is a high level assert for all clipboard in commandmanager.cs
                 if (This.AcceptsRichContent && This.Selection is TextSelection)
                 {
-                    System.Windows.Media.Imaging.BitmapSource bitmapSource = GetPasteData(dataObjectToApply, DataFormats.Bitmap) as System.Windows.Media.Imaging.BitmapSource;
-
-                    if (bitmapSource != null)
+                    if (GetPasteData(dataObjectToApply, DataFormats.Bitmap) is System.Windows.Media.Imaging.BitmapSource bitmapSource)
                     {
                         // Pack the image into a WPF container
                         MemoryStream packagedImage = WpfPayload.SaveImage(bitmapSource, WpfPayload.ImageBmpContentType);
@@ -712,17 +710,16 @@ private static bool PasteContentData(TextEditor This, IDataObject dataObject, ID
                 {
                     object pastedData = GetPasteData(dataObjectToApply, DataFormats.XamlPackage);
 
-                    MemoryStream pastedMemoryStream = pastedData as MemoryStream;
-                    if (pastedMemoryStream != null)
+                    if (pastedData is MemoryStream pastedMemoryStream)
                     {
                         object element = WpfPayload.LoadElement(pastedMemoryStream);
                         if ((element is Section || element is Span) && PasteTextElement(This, (TextElement)element))
                         {
                             return true;
                         }
-                        else if (element is FrameworkElement)
+                        else if (element is FrameworkElement frameworkElement)
                         {
-                            ((TextSelection)This.Selection).InsertEmbeddedUIElement((FrameworkElement)element);
+                            ((TextSelection)This.Selection).InsertEmbeddedUIElement(frameworkElement);
                             return true;
                         }
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorMouse.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorMouse.cs
index c07ef63b..f9dd26e6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorMouse.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorMouse.cs
@@ -147,10 +147,7 @@ internal static bool IsPointWithinInteractiveArea(TextEditor textEditor, Point p
                 {
                     // Transform point to TextView.RenderScope coordinates.
                     transform = textEditor.UiScope.TransformToDescendant(textEditor.TextView.RenderScope);
-                    if (transform != null)
-                    {
-                        transform.TryTransform(point, out point);
-                    }
+                    transform?.TryTransform(point, out point);
                     position = textEditor.TextView.GetTextPositionFromPoint(point, true);
                     interactiveArea = (position != null);
                 }
@@ -670,8 +667,7 @@ private static void OnSelectionChangedDuringGotFocus(object sender, EventArgs e)
         private static void OnScrollChangedDuringGotFocus(object sender, ScrollChangedEventArgs e)
         {
             // Reverse the scroll
-            ScrollViewer scrollViewer = e.OriginalSource as ScrollViewer;
-            if (scrollViewer != null)
+            if (e.OriginalSource is ScrollViewer scrollViewer)
             {
                 scrollViewer.RemoveHandler(ScrollViewer.ScrollChangedEvent, new ScrollChangedEventHandler(OnScrollChangedDuringGotFocus));
                 scrollViewer.ScrollToHorizontalOffset(scrollViewer.HorizontalOffset - e.HorizontalChange);
@@ -809,9 +805,9 @@ private static bool IsPointWithinRenderScope(TextEditor textEditor, Point point)
                 {
                     hitElement = VisualTreeHelper.GetParent(hitElement);
                 }
-                else if (hitElement is FrameworkContentElement)
+                else if (hitElement is FrameworkContentElement frameworkContentElement)
                 {
-                    hitElement = ((FrameworkContentElement)hitElement).Parent;
+                    hitElement = frameworkContentElement.Parent;
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorSelection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorSelection.cs
index e71bc69c..fff7c16f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorSelection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorSelection.cs
@@ -2461,8 +2461,7 @@ private static double GetAbsoluteXOffset(ITextView textview, ITextPointer positi
             // Notably, RichTextbox is missed here. 
             if (textview is TextBoxView) // Extra strict....this could be removed in the future.
             {
-                IScrollInfo scrollInfo = textview as IScrollInfo;
-                if (scrollInfo != null)
+                if (textview is IScrollInfo scrollInfo)
                 {
                     x += scrollInfo.HorizontalOffset;
                 }
@@ -2480,8 +2479,7 @@ private static double GetViewportXOffset(ITextView textview, double suggestedX)
             // Notably, RichTextbox is missed here. 
             if (textview is TextBoxView) // Extra strict....this could be removed in the future.
             {
-                IScrollInfo scrollInfo = textview as IScrollInfo;
-                if (scrollInfo != null)
+                if (textview is IScrollInfo scrollInfo)
                 {
                     suggestedX -= scrollInfo.HorizontalOffset;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorTyping.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorTyping.cs
index 1ea96266..db07d7d2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorTyping.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextEditorTyping.cs
@@ -1896,8 +1896,7 @@ private static void UpdateHyperlinkCursor(TextEditor This)
             {
                 TextPointer pointer = (TextPointer)This.TextView.GetTextPositionFromPoint(Mouse.GetPosition(This.TextView.RenderScope), false);
 
-                if (pointer != null &&
-                    pointer.Parent is TextElement &&
+                if (pointer?.Parent is TextElement &&
                     TextSchema.HasHyperlinkAncestor((TextElement)pointer.Parent))
                 {
                     Mouse.UpdateCursor();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElement.cs
index e5983b47..d94bc4e7 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElement.cs
@@ -840,20 +840,16 @@ void IAddChild.AddChild(object value)
         {
             Type valueType = value.GetType();
 
-            TextElement te = value as TextElement;
-
-            if (te != null)
+            if (value is TextElement te)
             {
                 TextSchema.ValidateChild(/*parent:*/this, /*child:*/te, true /* throwIfIllegalChild */, true /* throwIfIllegalHyperlinkDescendent */);
                 Append(te);
             }
             else
             {
-                UIElement uie = value as UIElement;
-                if (uie != null)
+                if (value is UIElement uie)
                 {
-                    InlineUIContainer inlineContainer = this as InlineUIContainer;
-                    if (inlineContainer != null)
+                    if (this is InlineUIContainer inlineContainer)
                     {
                         if (inlineContainer.Child != null)
                         {
@@ -864,8 +860,7 @@ void IAddChild.AddChild(object value)
                     }
                     else
                     {
-                        BlockUIContainer blockContainer = this as BlockUIContainer;
-                        if (blockContainer != null)
+                        if (this is BlockUIContainer blockContainer)
                         {
                             if (blockContainer.Child != null)
                             {
@@ -988,10 +983,8 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
             {
                 if (this.IsInTree) // No work to do if no one's listening.
                 {
-                    // If the modified property affects layout we have some additional
-                    // bookkeeping to take care of.
-                    FrameworkPropertyMetadata fmetadata = e.Metadata as FrameworkPropertyMetadata;
-                    if (fmetadata != null)
+                    // If the modified property affects layout we have some additional                    // bookkeeping to take care of.
+                    if (e.Metadata is FrameworkPropertyMetadata fmetadata)
                     {
                         bool affectsMeasureOrArrange = fmetadata.AffectsMeasure || fmetadata.AffectsArrange || fmetadata.AffectsParentMeasure || fmetadata.AffectsParentArrange;
                         bool affectsRender = (fmetadata.AffectsRender &&
@@ -1148,10 +1141,7 @@ internal void DeepEndInit()
                         // child.Current could be FrameworkElement, FrameworkContentElement,
                         //  or anything else.  Only recursively call self for FE & FCE.
                         TextElement child = children.Current as TextElement;
-                        if (child != null)
-                        {
-                            child.DeepEndInit();
-                        }
+                        child?.DeepEndInit();
                     }
                 }
 
@@ -1637,8 +1627,7 @@ private TextContainer EnsureTextContainer()
 
         private static bool IsValidFontFamily(object o)
         {
-            FontFamily value = o as FontFamily;
-            return (value != null);
+            return (o is FontFamily value);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElementCollection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElementCollection.cs
index a28e39ae..eb34c566 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElementCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextElementCollection.cs
@@ -723,13 +723,13 @@ internal TextContainer TextContainer
             {
                 TextContainer textContainer;
 
-                if (_owner is TextBlock)
+                if (_owner is TextBlock textBlock)
                 {
-                    textContainer = (TextContainer)((TextBlock)_owner).TextContainer;
+                    textContainer = (TextContainer)textBlock.TextContainer;
                 }
-                else if (_owner is FlowDocument)
+                else if (_owner is FlowDocument flowDocument)
                 {
-                    textContainer = ((FlowDocument)_owner).TextContainer;
+                    textContainer = flowDocument.TextContainer;
                 }
                 else 
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointer.cs
index 15091876..4e93e905 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointer.cs
@@ -1835,13 +1835,13 @@ internal static DependencyObject GetAdjacentElement(TextTreeNode node, ElementEd
 
             adjacentNode = GetAdjacentNode(node, edge, direction);
 
-            if (adjacentNode is TextTreeObjectNode)
+            if (adjacentNode is TextTreeObjectNode textTreeObjectNode)
             {
-                element = ((TextTreeObjectNode)adjacentNode).EmbeddedElement;
+                element = textTreeObjectNode.EmbeddedElement;
             }
-            else if (adjacentNode is TextTreeTextElementNode)
+            else if (adjacentNode is TextTreeTextElementNode textTreeTextElementNode)
             {
-                element = ((TextTreeTextElementNode)adjacentNode).TextElement;
+                element = textTreeTextElementNode.TextElement;
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointerBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointerBase.cs
index b5583b50..df172b55 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointerBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextPointerBase.cs
@@ -791,8 +791,7 @@ internal static ListItem GetImmediateListItem(TextPointer position)
         // Checks specifically for element emptyness, <ListItem></ListItem>.
         internal static bool IsInEmptyListItem(TextPointer position)
         {
-            ListItem listItem = position.Parent as ListItem;
-            return listItem != null && listItem.IsEmpty;
+            return position.Parent is ListItem listItem && listItem.IsEmpty;
         }
 
         //This overload is to cover for a bug that prevents line by line navigation in Fixed documents PS#1742102
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeBase.cs
index ffc27de8..a960f6aa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeBase.cs
@@ -450,9 +450,9 @@ private static object GetCharacterValueFromPosition(ITextPointer pointer, Depend
             }
             else
             {
-                if (pointer is TextPointer) // Implement only for concrete TextCotainer returning null otherwise - for optimization
+                if (pointer is TextPointer textPointer) // Implement only for concrete TextCotainer returning null otherwise - for optimization
                 {
-                    DependencyObject element = ((TextPointer)pointer).Parent as TextElement;
+                    DependencyObject element = textPointer.Parent as TextElement;
                     while (value == null && (element is Inline || element is Paragraph || element is TextBlock))
                     {
                         value = element.GetValue(formattingProperty);
@@ -833,9 +833,9 @@ private static void PlainConvertListEnd(ITextPointer navigator, ref Stack<int> l
         // Uses s stack of list items indices and updates it for following list items.
         private static void PlainConvertListItemStart(StringBuilder textBuffer, ITextPointer navigator, ref Stack<int> listItemCounter)
         {
-            if (navigator is TextPointer) // can do somethinng useful only in concrete TextContainer - not in an abstract one
+            if (navigator is TextPointer textPointer) // can do somethinng useful only in concrete TextContainer - not in an abstract one
             {
-                List list = (List)((TextPointer)navigator).Parent;
+                List list = (List)textPointer.Parent;
                 ListItem listItem = (ListItem)navigator.GetAdjacentElement(LogicalDirection.Forward);
 
                 // Initialize list context
@@ -1766,9 +1766,8 @@ private static void CreateNormalizedTextSegment(ITextRange thisRange, ITextPoint
                 else
                 {
                     // Handle Floater/Figure boundaries: non-empty ranges never cross them
-                    if (start is TextPointer)
+                    if (start is TextPointer adjustedStart)
                     {
-                        TextPointer adjustedStart = (TextPointer)start;
                         TextPointer adjustedEnd = (TextPointer)end;
                         NormalizeAnchoredBlockBoundaries(ref adjustedStart, ref adjustedEnd);
                         start = adjustedStart;
@@ -1864,9 +1863,9 @@ internal static void NormalizeAnchoredBlockBoundaries(ref TextPointer start, ref
                     TextElement innerElement = end.Parent as TextElement;
                     while (innerElement != null && innerElement != outerAnchoredBlock)
                     {
-                        if (innerElement is AnchoredBlock)
+                        if (innerElement is AnchoredBlock anchoredBlock)
                         {
-                            innerAnchoredBlock = (AnchoredBlock)innerElement;
+                            innerAnchoredBlock = anchoredBlock;
                         }
                         innerElement = innerElement.Parent as TextElement;
                     }
@@ -1906,9 +1905,9 @@ internal static void NormalizeAnchoredBlockBoundaries(ref TextPointer start, ref
                     TextElement innerElement = start.Parent as TextElement;
                     while (innerElement != null && innerElement != outerAnchoredBlock)
                     {
-                        if (innerElement is AnchoredBlock)
+                        if (innerElement is AnchoredBlock anchoredBlock)
                         {
-                            innerAnchoredBlock = (AnchoredBlock)innerElement;
+                            innerAnchoredBlock = anchoredBlock;
                         }
                         innerElement = innerElement.Parent as TextElement;
                     }
@@ -2014,10 +2013,10 @@ private static void SelectPrivate(ITextRange thisRange, ITextPointer position1,
             Invariant.Assert(position1 != null, "null check: position1");
             Invariant.Assert(position2 != null, "null check: position2");
 
-            if (position1 is TextPointer)
+            if (position1 is TextPointer textPointer)
             {
                 textSegments = TextRangeEditTables.BuildTableRange(
-                    /*anchorPosition:*/(TextPointer)position1, 
+textPointer, 
                     /*movingPosition:*/(TextPointer)position2, 
                     includeCellAtMovingPosition, 
                     out isTableCellRange);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEdit.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEdit.cs
index ab7720b6..f6f5195d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEdit.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEdit.cs
@@ -450,9 +450,9 @@ internal static void CharacterResetFormatting(TextPointer start, TextPointer end
                             // Now that content has changed, we must try to merge inlines at this position
                             MergeFormattingInlines(mergePosition);
                         }
-                        else if (parent is Inline)
+                        else if (parent is Inline inline)
                         {
-                            ClearFormattingInlineProperties((Inline)parent);
+                            ClearFormattingInlineProperties(inline);
                             // Now that properties may be removed we must try to merge this element with a preceding one
                             MergeFormattingInlines(parent.ElementStart);
                         }
@@ -772,7 +772,7 @@ internal static void SetParagraphProperty(TextPointer start, TextPointer end, De
 
                 // And expand range start to the beginning of the containing list
                 ListItem listItem = start.GetListAncestor();
-                if (listItem != null && listItem.List != null)
+                if (listItem?.List != null)
                 {
                     start = listItem.List.ElementStart;
                 }
@@ -875,9 +875,9 @@ private static void SetPropertyOnParagraphOrBlockUIContainer(DependencyObject pa
 
                 // For BlockUIContainer text alignment must be translated into
                 // HorizontalAlignment of the child embedded object.
-                if (block is BlockUIContainer)
+                if (block is BlockUIContainer blockUIContainer)
                 {
-                    UIElement embeddedElement = ((BlockUIContainer)block).Child;
+                    UIElement embeddedElement = blockUIContainer.Child;
                     if (embeddedElement != null)
                     {
                         HorizontalAlignment horizontalAlignment = GetHorizontalAlignmentFromTextAlignment((TextAlignment)newValue);
@@ -888,9 +888,9 @@ private static void SetPropertyOnParagraphOrBlockUIContainer(DependencyObject pa
                     }
                 }
             }
-            else if (currentValue is double)
+            else if (currentValue is double d)
             {
-                newValue = GetNewDoubleValue(property, (double)currentValue, (double)newValue, propertyValueAction);
+                newValue = GetNewDoubleValue(property, d, (double)newValue, propertyValueAction);
             }
 
             SetPropertyValue(block, property, currentValue, newValue);
@@ -1223,9 +1223,9 @@ private static void SwapBlockLeftAndRightMargins(Block block)
         {
             object value = block.GetValue(Block.MarginProperty);
 
-            if (value is Thickness)
+            if (value is Thickness thickness)
             {
-                if (Paragraph.IsMarginAuto((Thickness)value))
+                if (Paragraph.IsMarginAuto(thickness))
                 {
                     // Nothing to do for auto thickess
                 }
@@ -1949,9 +1949,9 @@ private static void SetStructuralInlineProperty(TextPointer start, TextPointer e
 
             ValidateApplyStructuralInlineProperty(start, end, commonAncestor, formattingProperty);
 
-            if (commonAncestor is Run)
+            if (commonAncestor is Run run)
             {
-                ApplyStructuralInlinePropertyAcrossRun(start, end, (Run)commonAncestor, formattingProperty, value);
+                ApplyStructuralInlinePropertyAcrossRun(start, end, run, formattingProperty, value);
             }
             else if ((commonAncestor is Inline && !(commonAncestor is AnchoredBlock)) ||
                      commonAncestor is Paragraph)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditLists.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditLists.cs
index 8f362a6e..e76e3480 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditLists.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditLists.cs
@@ -147,8 +147,7 @@ internal static bool MergeParagraphs(Block firstParagraphOrBlockUIContainer, Blo
                 ? positionAfterSecondParagraph.GetAdjacentElement(LogicalDirection.Forward) as ListItem : null;
             if (followingListItem != null && followingListItem == secondListItem)
             {
-                ListItem precedingListItem = positionAfterSecondParagraph.GetAdjacentElement(LogicalDirection.Backward) as ListItem;
-                if (precedingListItem != null)
+                if (positionAfterSecondParagraph.GetAdjacentElement(LogicalDirection.Backward) is ListItem precedingListItem)
                 {
                     // Merge the second list item with the preceding one
                     Invariant.Assert(positionAfterSecondParagraph.GetPointerContext(LogicalDirection.Forward) == TextPointerContext.ElementStart);
@@ -298,8 +297,7 @@ internal static bool ConvertParagraphsToListItems(TextRange range, TextMarkerSty
                 }
             }
 
-            ListItem parentListItem = firstBlock.Parent as ListItem;
-            if (parentListItem != null)
+            if (firstBlock.Parent is ListItem parentListItem)
             {
                 // Paragraphs are inside of ListItem already.
 
@@ -423,12 +421,10 @@ internal static void IndentListItems(TextRange range)
             leadingListItem.Reposition(leadingListItem.ContentStart, indentedList.ElementEnd);
 
             // Unwrap sublist from the last selected list item (to keep it on its level)
-            Paragraph leadingParagraphOfLastItem = lastListItem.Blocks.FirstBlock as Paragraph;
-            if (leadingParagraphOfLastItem != null)
+            if (lastListItem.Blocks.FirstBlock is Paragraph leadingParagraphOfLastItem)
             {
                 // Unindenting all items of a sublist - if it is the only following element of a list
-                List nestedListOfLastItem = leadingParagraphOfLastItem.NextBlock as List;
-                if (nestedListOfLastItem != null && nestedListOfLastItem.NextBlock == null)
+                if (leadingParagraphOfLastItem.NextBlock is List nestedListOfLastItem && nestedListOfLastItem.NextBlock == null)
                 {
                     lastListItem.Reposition(lastListItem.ContentStart, nestedListOfLastItem.ElementStart);
                     nestedListOfLastItem.Reposition(null, null);
@@ -497,8 +493,7 @@ internal static bool UnindentListItems(TextRange range)
             List unindentedList = (List)firstListItem.Parent;
 
             // Check whether we have outer ListItem
-            ListItem outerListItem = unindentedList.Parent as ListItem;
-            if (outerListItem != null)
+            if (unindentedList.Parent is ListItem outerListItem)
             {
                 // Selected items belong to a nested list.
                 // So we need to pull them to the level of enclosing ListItem, i.e. cut this ListItem.
@@ -675,12 +670,10 @@ internal static bool SplitListsForFlowDirectionChange(TextPointer start, TextPoi
             ListItem startListItem = start.GetListAncestor();
 
             // Unindent startListItem's list to prepare for a split, if the List's FlowDirection value is different.
-            if (startListItem != null && 
-                startListItem.List != null && // Check for unparented list items
+            if (startListItem?.List != null && // Check for unparented list items
                 !TextSchema.ValuesAreEqual(/*newValue*/newFlowDirectionValue, /*currentValue*/startListItem.List.GetValue(Paragraph.FlowDirectionProperty)))
             {
-                while (startListItem != null &&
-                    startListItem.List != null &&
+                while (startListItem?.List != null &&
                     startListItem.List.Parent is ListItem)
                 {
                     // startListItem is within a nested List.
@@ -695,11 +688,10 @@ internal static bool SplitListsForFlowDirectionChange(TextPointer start, TextPoi
             ListItem endListItem = end.GetListAncestor();
 
             // Unindent endListItem's list to prepare for a split, if the List's FlowDirection value is different.
-            if (endListItem != null &&
-                endListItem.List != null && 
+            if (endListItem?.List != null && 
                 !TextSchema.ValuesAreEqual(/*newValue*/newFlowDirectionValue, /*currentValue*/endListItem.List.GetValue(Paragraph.FlowDirectionProperty)))
             {
-                if (startListItem != null && startListItem.List != null &&
+                if (startListItem?.List != null &&
                     endListItem.List.ElementEnd.CompareTo(startListItem.List.ElementEnd) < 0)
                 {
                     // endListItem's List is contained within startListItem's List. 
@@ -707,8 +699,7 @@ internal static bool SplitListsForFlowDirectionChange(TextPointer start, TextPoi
                 }
                 else
                 {
-                    while (endListItem != null &&
-                        endListItem.List !=  null && 
+                    while (endListItem?.List != null && 
                         endListItem.List.Parent is ListItem)
                     {
                         // endListItem is within a nested List.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditTables.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditTables.cs
index 36934768..cd95946d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditTables.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeEditTables.cs
@@ -2291,9 +2291,8 @@ private static TableCell AddCellCopy(TableRow newRow, TableCell currentCell, int
                 Paragraph newParagraph = new Paragraph();
 
                 // Transfer all known formatting properties that a locally set on a sourceBlock
-                Paragraph sourceParagraph = currentCell.Blocks.FirstBlock as Paragraph;
 
-                if (sourceParagraph != null)
+                if (currentCell.Blocks.FirstBlock is Paragraph sourceParagraph)
                 {
                     DependencyProperty[] inheritableProperties = TextSchema.GetInheritableProperties(typeof(Paragraph));
                     DependencyProperty[] nonInheritableProperties = TextSchema.GetNoninheritableProperties(typeof(Paragraph));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeSerialization.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeSerialization.cs
index 8204a6de..ff62ab2f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeSerialization.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextRangeSerialization.cs
@@ -1899,8 +1899,7 @@ private static bool IsHyperlinkInvalid(ITextPointer textReader, ITextPointer ran
                 // Check whether the hyperlink having a UiElement except Image until hyperlink end position
                 while (hyperlinkNavigation.CompareTo(hyperlinkEnd) < 0)
                 {
-                    InlineUIContainer inlineUIContainer = hyperlinkNavigation.GetAdjacentElement(LogicalDirection.Forward) as InlineUIContainer;
-                    if (inlineUIContainer != null && !(inlineUIContainer.Child is Image))
+                    if (hyperlinkNavigation.GetAdjacentElement(LogicalDirection.Forward) is InlineUIContainer inlineUIContainer && !(inlineUIContainer.Child is Image))
                     {
                         hyperlinkInvalid = true;
                         break;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSchema.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSchema.cs
index b3fea8d5..38dab016 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSchema.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSchema.cs
@@ -914,8 +914,7 @@ private static bool HasIllegalHyperlinkDescendant(TextElement element, bool thro
 
         private static bool AreBrushesEqual(Brush brush1, Brush brush2)
         {
-            SolidColorBrush solidBrush1 = brush1 as SolidColorBrush;
-            if (solidBrush1 != null)
+            if (brush1 is SolidColorBrush solidBrush1)
             {
                 return solidBrush1.Color.Equals(((SolidColorBrush)brush2).Color);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSelection.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSelection.cs
index a7b68e13..7f7b390a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSelection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextSelection.cs
@@ -746,10 +746,7 @@ void ITextSelection.OnTextViewUpdated()
                 // Stress bug#1583327 indicate that _caretElement can be set to null by
                 // detaching. So the below code is caching the caret element instance locally.
                 CaretElement caretElement = _caretElement;
-                if (caretElement != null)
-                {
-                    caretElement.OnTextViewUpdated();
-                }
+                caretElement?.OnTextViewUpdated();
             }
 
             if (_pendingUpdateCaretStateCallback)
@@ -1643,14 +1640,14 @@ internal static Brush GetCaretBrush(TextEditor textEditor)
 
             // Get the background color from current selection
             focusedTextSelection = textEditor.Selection;
-            if (focusedTextSelection is TextSelection)
+            if (focusedTextSelection is TextSelection textSelection)
             {
-                backgroundPropertyValue = ((TextSelection)focusedTextSelection).GetCurrentValue(TextElement.BackgroundProperty);
+                backgroundPropertyValue = textSelection.GetCurrentValue(TextElement.BackgroundProperty);
                 if (backgroundPropertyValue != null && backgroundPropertyValue != DependencyProperty.UnsetValue)
                 {
-                    if (backgroundPropertyValue is SolidColorBrush)
+                    if (backgroundPropertyValue is SolidColorBrush solidColorBrush)
                     {
-                        backgroundColor = ((SolidColorBrush)backgroundPropertyValue).Color;
+                        backgroundColor = solidColorBrush.Color;
                     }
                 }
             }
@@ -1823,8 +1820,8 @@ private void Highlight()
         private void Unhighlight()
         {
             ITextContainer textContainer = ((ITextSelection)this).Start.TextContainer;
-            TextSelectionHighlightLayer highlightLayer = textContainer.Highlights.GetLayer(typeof(TextSelection)) as TextSelectionHighlightLayer;
-            if (highlightLayer != null)
+
+            if (textContainer.Highlights.GetLayer(typeof(TextSelection)) is TextSelectionHighlightLayer highlightLayer)
             {
                 textContainer.Highlights.RemoveLayer(highlightLayer);
                 Invariant.Assert(textContainer.Highlights.GetLayer(typeof(TextSelection)) == null);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesDisplayAttributePropertyRanges.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesDisplayAttributePropertyRanges.cs
index 4ea86c7a..18b8f9df 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesDisplayAttributePropertyRanges.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesDisplayAttributePropertyRanges.cs
@@ -194,10 +194,7 @@ internal TextServicesDisplayAttributePropertyRanges(TextStore textstore)
         // Updates composition display attribute adorner on-screen location.
         internal void OnLayoutUpdated()
         {
-            if (_compositionAdorner != null)
-            {
-                _compositionAdorner.InvalidateAdorner();
-            }
+            _compositionAdorner?.InvalidateAdorner();
         }
 
         #endregion Internal Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesHost.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesHost.cs
index c6994368..3a683a89 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesHost.cs
@@ -166,11 +166,7 @@ internal static void StopTransitoryExtension(TextStore textstore)
             {
                 UnsafeNativeMethods.ITfSource source;
                 source = textstore.DocumentManager as UnsafeNativeMethods.ITfSource;
-                if (source != null)
-                {
-                    // DocumentManager only supports ITfSource on Longhorn, XP does not support it
-                    source.UnadviseSink(textstore.TransitoryExtensionSinkCookie);
-                }
+                source?.UnadviseSink(textstore.TransitoryExtensionSinkCookie);
                 textstore.TransitoryExtensionSinkCookie = UnsafeNativeMethods.TF_INVALID_COOKIE;
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesProperty.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesProperty.cs
index 54cfdf56..ff861e8e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextServicesProperty.cs
@@ -86,10 +86,7 @@ internal void OnLayoutUpdated()
         {
             TextServicesDisplayAttributePropertyRanges displayAttributes = _propertyRanges as TextServicesDisplayAttributePropertyRanges;
 
-            if (displayAttributes != null)
-            {
-                displayAttributes.OnLayoutUpdated();
-            }
+            displayAttributes?.OnLayoutUpdated();
         }
 
         #endregion Internal Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextStore.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextStore.cs
index a52dcdbd..faa300fc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextStore.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextStore.cs
@@ -801,11 +801,7 @@ public void GetACPFromPoint(int viewCookie, ref UnsafeNativeMethods.POINT tsfPoi
 
             // Convert to local coordinates.
             GeneralTransform transform = compositionTarget.RootVisual.TransformToDescendant(RenderScope);
-            if (transform != null)
-            {
-                // REVIEW: should we throw if the point could not be transformed?
-                transform.TryTransform(milPoint, out milPoint);
-            }
+            transform?.TryTransform(milPoint, out milPoint);
 
             // Validate layout information on TextView
             if (!view.Validate(milPoint))
@@ -1481,10 +1477,7 @@ internal void OnLayoutUpdated()
                 _sink.OnLayoutChange(UnsafeNativeMethods.TsLayoutCode.TS_LC_CHANGE, _viewCookie);
             }
 
-            if (_textservicesproperty != null)
-            {
-                _textservicesproperty.OnLayoutUpdated();
-            }
+            _textservicesproperty?.OnLayoutUpdated();
         }
 
         // Called as the selection changes.
@@ -3066,12 +3059,7 @@ private void BreakTypingSequence(ITextPointer caretPosition)
         {
             CompositionParentUndoUnit unit = PeekCompositionParentUndoUnit();
 
-            if (unit != null)
-            {
-                // We also put the caret at the end of the composition after
-                // redoing a composition undo.  So update the end position now.
-                unit.RecordRedoSelectionState(caretPosition, caretPosition);
-            }
+            unit?.RecordRedoSelectionState(caretPosition, caretPosition);
         }
 
         // Repositions an ITextRange to comply with limitations on IME input.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextTreeExtractElementUndoUnit.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextTreeExtractElementUndoUnit.cs
index 6be7a54f..f92a6a1f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextTreeExtractElementUndoUnit.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/TextTreeExtractElementUndoUnit.cs
@@ -75,9 +75,9 @@ public override void DoCore()
             // Shouldn't we call this with deferLoad=true and call EndDeferLoad after all parameters set?
             this.TextContainer.SetValues(end, ArrayToLocalValueEnumerator(_localValues));
 
-            if (element is Table)
+            if (element is Table table)
             {
-                TextTreeDeleteContentUndoUnit.RestoreColumns((Table)element, _columns);
+                TextTreeDeleteContentUndoUnit.RestoreColumns(table, _columns);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ValidationHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ValidationHelper.cs
index 244ca156..fcffef9c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ValidationHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ValidationHelper.cs
@@ -117,9 +117,9 @@ internal static void ValidateChild(TextPointer position, object child, string pa
             }
 
             // The new child should not be currently in other text tree
-            if (child is TextElement)
+            if (child is TextElement textElement)
             {
-                if (((TextElement)child).Parent != null)
+                if (textElement.Parent != null)
                 {
                     throw new ArgumentException(SR.Get(SRID.TextSchema_TheChildElementBelongsToAnotherTreeAlready, child.GetType().Name));
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WinRTSpellerInterop.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WinRTSpellerInterop.cs
index 460aa317..2b5cf1e4 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WinRTSpellerInterop.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WinRTSpellerInterop.cs
@@ -689,10 +689,7 @@ private void ReleaseAllResources(bool disposing)
                 foreach (Tuple<WordsSegmenter, SpellChecker> item in _spellCheckers.Values)
                 {
                     SpellChecker spellChecker = item?.Item2;
-                    if (spellChecker != null)
-                    {
-                        spellChecker.Dispose();
-                    }
+                    spellChecker?.Dispose();
                 }
 
                 _spellCheckers = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WpfPayload.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WpfPayload.cs
index 79e924c6..7d479248 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WpfPayload.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/WpfPayload.cs
@@ -645,9 +645,7 @@ private static string GetImageFileExtension(string imageContentType)
         private static bool ImagesAreIdentical(BitmapSource imageSource1, BitmapSource imageSource2)
         {
             // First compare images as objects - the luckiest case is when it's the same object
-            BitmapFrameDecode imageBitmap1 = imageSource1 as BitmapFrameDecode;
-            BitmapFrameDecode imageBitmap2 = imageSource2 as BitmapFrameDecode;
-            if (imageBitmap1 != null && imageBitmap2 != null &&
+            if (imageSource1 is BitmapFrameDecode imageBitmap1 && imageSource2 is BitmapFrameDecode imageBitmap2 &&
                 imageBitmap1.Decoder.Frames.Count == 1 && imageBitmap2.Decoder.Frames.Count == 1 &&
                 imageBitmap1.Decoder.Frames[0] == imageBitmap2.Decoder.Frames[0])
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ZoomPercentageConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ZoomPercentageConverter.cs
index cb538444..980140a2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ZoomPercentageConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/ZoomPercentageConverter.cs
@@ -73,11 +73,8 @@ public object Convert(object value, Type targetType, object parameter, CultureIn
         }
 
         // Ensure that the value given is a double.
-        if (value != null
-            && value is double)
+        if (value is double percent)
         {
-            double percent = (double)value;
-
             // If string requested, format string.
             // If object is requested, then return a formated string.  This covers cases
             // similar to ButtonBase.CommandParameter, etc.
@@ -143,18 +140,17 @@ public object ConvertBack(object value, Type targetType, object parameter, Cultu
                 isValidArg = true;
             }
             // If value is a double, then cast
-            else if (value is double)
+            else if (value is double d)
             {
-                zoomValue = (double)value;
+                zoomValue = d;
                 isValidArg = true;
             }
             // If value is a string, then parse
-            else if (value is string)
+            else if (value is string zoomString)
             {
                 try
                 {
                     // Remove whitespace on either end of the string.
-                    string zoomString = (string)value;
                     if ((culture != null) && !String.IsNullOrEmpty(zoomString))
                     {
                         zoomString = ((string)value).Trim();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextcontainer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextcontainer.cs
index 65b5a42e..caa38734 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextcontainer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextcontainer.cs
@@ -697,7 +697,7 @@ private void _OnHighlightChanged(object sender, HighlightChangedEventArgs args)
                     // Store the highlight.
                     if (selected != DependencyProperty.UnsetValue)
                     {
-                        DocumentsTrace.FixedDocumentSequence.Highlights.Trace(string.Format("HightlightRange {0}-{1}", highlightRangeStart.ToString(), highlightTransitionPosition.ToString()));
+                        DocumentsTrace.FixedDocumentSequence.Highlights.Trace($"HightlightRange {highlightRangeStart.ToString()}-{highlightTransitionPosition.ToString()}");
                         if (highlightRangeStart.GetPointerContext(LogicalDirection.Forward) != TextPointerContext.Text)
                         {
                             DocumentsTrace.FixedDocumentSequence.Highlights.Trace("<HighlightNotOnText>");
@@ -706,7 +706,7 @@ private void _OnHighlightChanged(object sender, HighlightChangedEventArgs args)
                         {
                             char[] sb = new char[256];
                             TextPointerBase.GetTextWithLimit(highlightRangeStart.CreateDynamicTextPointer(LogicalDirection.Forward), LogicalDirection.Forward, sb, 0, 256, highlightTransitionPosition.CreateDynamicTextPointer(LogicalDirection.Forward));
-                            DocumentsTrace.FixedDocumentSequence.TextOM.Trace(string.Format("HightlightContent [{0}]", new String(sb)));
+                            DocumentsTrace.FixedDocumentSequence.TextOM.Trace($"HightlightContent [{new String(sb)}]");
                         }
                     }
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextview.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextview.cs
index 13d0c247..282ba700 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextview.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Documents/documentsequencetextview.cs
@@ -77,7 +77,7 @@ internal DocumentSequenceTextView(FixedDocumentSequenceDocumentPage docPage)
         /// </exception>
         internal override ITextPointer GetTextPositionFromPoint(Point point, bool snapToText)
         {
-            DocumentsTrace.FixedDocumentSequence.TextOM.Trace(string.Format("GetTextPositionFromPoint {0}-{1}", point, snapToText));
+            DocumentsTrace.FixedDocumentSequence.TextOM.Trace($"GetTextPositionFromPoint {point}-{snapToText}");
             DocumentSequenceTextPointer tp = null;
             LogicalDirection edge = LogicalDirection.Forward;
 
@@ -124,7 +124,7 @@ internal override ITextPointer GetTextPositionFromPoint(Point point, bool snapTo
         /// </remarks>
         internal override Rect GetRawRectangleFromTextPosition(ITextPointer position, out Transform transform)
         {
-            DocumentsTrace.FixedDocumentSequence.TextOM.Trace(string.Format("GetRawRectangleFromTextPosition {0} {1}", position, position.LogicalDirection));
+            DocumentsTrace.FixedDocumentSequence.TextOM.Trace($"GetRawRectangleFromTextPosition {position} {position.LogicalDirection}");
             DocumentSequenceTextPointer tp = null;
 
             // Initialize transform to identity
@@ -208,7 +208,7 @@ internal override ITextPointer GetPositionAtNextLine(ITextPointer position, doub
             newSuggestedX = suggestedX;
             linesMoved = count;
 
-            DocumentsTrace.FixedDocumentSequence.TextOM.Trace(string.Format("GetPositionAtNextLine {0} {1} {2} {3} ", position, position.LogicalDirection, suggestedX, count));
+            DocumentsTrace.FixedDocumentSequence.TextOM.Trace($"GetPositionAtNextLine {position} {position.LogicalDirection} {suggestedX} {count} ");
             DocumentSequenceTextPointer newTp  = null;
             LogicalDirection newEdge = LogicalDirection.Forward;
             DocumentSequenceTextPointer tp = null;
@@ -366,7 +366,7 @@ internal override ITextPointer GetBackspaceCaretUnitPosition(ITextPointer positi
         /// </exception>
         internal override TextSegment GetLineRange(ITextPointer position)
         {
-            DocumentsTrace.FixedDocumentSequence.TextOM.Trace(string.Format("GetLineRange {0} {1}", position, position.LogicalDirection));
+            DocumentsTrace.FixedDocumentSequence.TextOM.Trace($"GetLineRange {position} {position.LogicalDirection}");
             DocumentSequenceTextPointer tpStart = null;
             DocumentSequenceTextPointer tpEnd   = null;
             DocumentSequenceTextPointer tpLine = null;
@@ -439,7 +439,7 @@ internal override  ReadOnlyCollection<GlyphRun> GetGlyphRuns(ITextPointer start,
         /// </exception>
         internal override bool Contains(ITextPointer position)
         {
-            DocumentsTrace.FixedDocumentSequence.TextOM.Trace(string.Format("Contains {0} {1}", position, position.LogicalDirection));
+            DocumentsTrace.FixedDocumentSequence.TextOM.Trace($"Contains {position} {position.LogicalDirection}");
             DocumentSequenceTextPointer tp = null;
             if (position != null)
             {
@@ -472,10 +472,7 @@ internal override bool Contains(ITextPointer position)
         /// </remarks>
         internal override bool Validate()
         {
-            if (ChildTextView != null)
-            {
-                ChildTextView.Validate();
-            }
+            ChildTextView?.Validate();
 
             return ((ITextView)this).IsValid;
         }
@@ -483,10 +480,7 @@ internal override bool Validate()
         /// <see cref="ITextView.Validate(Point)"/>
         internal override bool Validate(Point point)
         {
-            if (ChildTextView != null)
-            {
-                ChildTextView.Validate(point);
-            }
+            ChildTextView?.Validate(point);
 
             return ((ITextView)this).IsValid;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventSetterHandlerConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventSetterHandlerConverter.cs
index 0765aaea..5e10bfe5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventSetterHandlerConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventSetterHandlerConverter.cs
@@ -71,15 +71,13 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                 // returning an arbitrary delegate to a (possibly malicious) caller.
                 throw new ArgumentException(SR.Get(SRID.TextRange_InvalidParameterValue), "typeDescriptorContext");
             }
-            IRootObjectProvider rootProvider = typeDescriptorContext.GetService(typeof(IRootObjectProvider)) as IRootObjectProvider;
-            if (rootProvider != null && source is String)
+
+            if (typeDescriptorContext.GetService(typeof(IRootObjectProvider)) is IRootObjectProvider rootProvider && source is String)
             {
-                IProvideValueTarget ipvt = typeDescriptorContext.GetService(typeof(IProvideValueTarget)) as IProvideValueTarget;
-                if (ipvt != null)
+                if (typeDescriptorContext.GetService(typeof(IProvideValueTarget)) is IProvideValueTarget ipvt)
                 {
-                    EventSetter setter = ipvt.TargetObject as EventSetter;
                     string handlerName;
-                    if(setter != null && (handlerName = source as string) != null)
+                    if(ipvt.TargetObject is EventSetter setter && (handlerName = source as string) != null)
                     {
                         handlerName = handlerName.Trim();
                         return Delegate.CreateDelegate(setter.Event.HandlerType, rootProvider.RootObject, handlerName);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventTrigger.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventTrigger.cs
index 0c339683..8fc02ce6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventTrigger.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/EventTrigger.cs
@@ -191,8 +191,7 @@ internal override void OnInheritanceContextChangedCore(EventArgs args)
 
             for (int i=0; i<_actions.Count; i++)
             {
-                DependencyObject action = _actions[i] as DependencyObject;
-                if (action != null && action.InheritanceContext == this)
+                if (_actions[i] is DependencyObject action && action.InheritanceContext == this)
                 {
                     action.OnInheritanceContextChanged(args);
                 }
@@ -297,16 +296,8 @@ internal static void ProcessTriggerCollection( FrameworkElement triggersHost )
         
         internal static void ProcessOneTrigger( FrameworkElement triggersHost, TriggerBase triggerBase )
         {
-            // This code path is used in the element trigger case.  We don't actually
-            //  need these guys to be usable cross-thread, so we don't really need
-            //  to freeze/seal these objects.  The only one expected to cause problems
-            //  is a change to the RoutedEvent.  At the same time we remove this
-            //  Seal(), the RoutedEvent setter will check to see if the handler has
-            //  already been created and refuse an update if so.
-            // triggerBase.Seal();
-            
-            EventTrigger eventTrigger = triggerBase as EventTrigger;
-            if( eventTrigger != null )
+            // This code path is used in the element trigger case.  We don't actually            //  need these guys to be usable cross-thread, so we don't really need            //  to freeze/seal these objects.  The only one expected to cause problems            //  is a change to the RoutedEvent.  At the same time we remove this            //  Seal(), the RoutedEvent setter will check to see if the handler has            //  already been created and refuse an update if so.            // triggerBase.Seal();
+            if( triggerBase is EventTrigger eventTrigger )
             {
                 Debug.Assert( eventTrigger._routedEventHandler == null && eventTrigger._source == null);
                 
@@ -357,9 +348,7 @@ internal static void DisconnectAllTriggers( FrameworkElement triggersHost )
 
         internal static void DisconnectOneTrigger( FrameworkElement triggersHost, TriggerBase triggerBase )
         {
-            EventTrigger eventTrigger = triggerBase as EventTrigger;
-            
-            if( eventTrigger != null )
+            if( triggerBase is EventTrigger eventTrigger )
             {
                 eventTrigger._source.RemoveHandler( eventTrigger.RoutedEvent, eventTrigger._routedEventHandler);
                 eventTrigger._routedEventHandler = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FontSizeConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FontSizeConverter.cs
index b5be3552..75e3e51c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FontSizeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FontSizeConverter.cs
@@ -77,11 +77,9 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            // NB: The culture passed from Avalon parser should always be the invariant culture.
-            //     Do we care about usage in other circumstances?
-            string text = value as string;
+            // NB: The culture passed from Avalon parser should always be the invariant culture.            //     Do we care about usage in other circumstances?
 
-            if (text != null)
+            if (value is string text)
             {
                 double       amount;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkContentElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkContentElement.cs
index ee2d3381..4b778f23 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkContentElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkContentElement.cs
@@ -558,15 +558,12 @@ internal void GetRawValue(DependencyProperty dp, PropertyMetadata metadata, ref
                 }
             }
 
-            //
-            // Try for Inherited value
-            //
-            FrameworkPropertyMetadata fmetadata = metadata as FrameworkPropertyMetadata;
+            //            // Try for Inherited value            //
 
             // Note that for inheritable properties that override the default value a parent can impart
             // its default value to the child even though the property may not have been set locally or
             // via a style or template (ie. IsUsed flag would be false).
-            if (fmetadata != null)
+            if (metadata is FrameworkPropertyMetadata fmetadata)
             {
                 if (fmetadata.Inherits)
                 {
@@ -769,15 +766,13 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
                 }
             }
 
-            FrameworkPropertyMetadata fmetadata = e.Metadata as FrameworkPropertyMetadata;
-
             //
             // Invalidation propagation for Groups and Inheritance
             //
 
             // Metadata must exist specifically stating propagate invalidation
             // due to group or inheritance
-            if (fmetadata != null)
+            if (e.Metadata is FrameworkPropertyMetadata fmetadata)
             {
                 //
                 // Inheritance
@@ -1334,17 +1329,8 @@ internal override sealed bool BuildRouteCore(EventRoute route, RoutedEventArgs a
             DependencyObject visualParent = (DependencyObject) ContentOperations.GetParent(this);
             DependencyObject modelParent = this._parent;
 
-            // FrameworkElement extends the basic event routing strategy by
-            // introducing the concept of a logical tree.  When an event
-            // passes through an element in a logical tree, the source of
-            // the event needs to change to the leaf-most node in the same
-            // logical tree that is in the route.
-
-            // Check the route to see if we are returning into a logical tree
-            // that we left before.  If so, restore the source of the event to
-            // be the source that it was when we left the logical tree.
-            DependencyObject branchNode = route.PeekBranchNode() as DependencyObject;
-            if (branchNode != null && IsLogicalDescendent(branchNode))
+            // FrameworkElement extends the basic event routing strategy by            // introducing the concept of a logical tree.  When an event            // passes through an element in a logical tree, the source of            // the event needs to change to the leaf-most node in the same            // logical tree that is in the route.            // Check the route to see if we are returning into a logical tree            // that we left before.  If so, restore the source of the event to            // be the source that it was when we left the logical tree.
+            if (route.PeekBranchNode() is DependencyObject branchNode && IsLogicalDescendent(branchNode))
             {
                 // We keep the most recent source in the event args.  Note that
                 // this is only for our consumption.  Once the event is raised,
@@ -2027,15 +2013,7 @@ internal override void InvalidateForceInheritPropertyOnChildren(DependencyProper
                 while(enumerator.MoveNext())
                 {
                     DependencyObject child =enumerator.Current as DependencyObject;
-                    if(child != null)
-                    {
-                        // CODE REVIEW (dwaynen)
-                        //
-                        // We assume we will only ever have a UIElement or a ContentElement
-                        // as a child of a FrameworkContentElement.  (Not a raw Visual.)
-
-                        child.CoerceValue(property);
-                    }
+                    child?.CoerceValue(property);
                 }
             }
         }
@@ -2063,10 +2041,7 @@ private void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler)
         private void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler)
         {
             EventHandlersStore store = EventHandlersStore;
-            if (store != null)
-            {
-                store.Remove(key, handler);
-            }
+            store?.Remove(key, handler);
         }
 
         // Gettor and Settor for flag that indicates
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElement.cs
index eb6beefb..230e192b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElement.cs
@@ -2488,9 +2488,9 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                 {
                     newParentAsVisual.VisualAncestorChanged += new AncestorChangedEventHandler(OnVisualAncestorChanged);
                 }
-                else if (newParent is Visual3D)
+                else if (newParent is Visual3D visual3D)
                 {
-                    ((Visual3D)newParent).VisualAncestorChanged += new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged);
+                    visual3D.VisualAncestorChanged += new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged);
                 }
             }
             else if (oldParent != null && (oldParent is FrameworkElement) == false)
@@ -2502,9 +2502,9 @@ protected internal override void OnVisualParentChanged(DependencyObject oldParen
                 {
                     oldParentAsVisual.VisualAncestorChanged -= new AncestorChangedEventHandler(OnVisualAncestorChanged);
                 }
-                else if (oldParent is Visual3D)
+                else if (oldParent is Visual3D visual3D)
                 {
-                    ((Visual3D)oldParent).VisualAncestorChanged -= new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged);
+                    visual3D.VisualAncestorChanged -= new Visual.AncestorChangedEventHandler(OnVisualAncestorChanged);
                 }
             }
 
@@ -3016,12 +3016,12 @@ internal override void AddToEventRouteCore(EventRoute route, RoutedEventArgs arg
             // Add TargetType EventHandlers to the route. Notice that ThemeStyle
             // cannot have EventHandlers and hence are ignored here.
             RoutedEventHandlerInfo[] handlers = null;
-            if (selfStyle != null && selfStyle.EventHandlersStore != null)
+            if (selfStyle?.EventHandlersStore != null)
             {
                 handlers = selfStyle.EventHandlersStore.GetRoutedEventHandlers(args.RoutedEvent);
                 AddStyleHandlersToEventRoute(route, source, handlers);
             }
-            if (selfFrameworkTemplate != null && selfFrameworkTemplate.EventHandlersStore != null)
+            if (selfFrameworkTemplate?.EventHandlersStore != null)
             {
                 handlers = selfFrameworkTemplate.EventHandlersStore.GetRoutedEventHandlers(args.RoutedEvent);
                 AddStyleHandlersToEventRoute(route, source, handlers);
@@ -3096,10 +3096,7 @@ internal override void InvalidateForceInheritPropertyOnChildren(DependencyProper
                     while (enumerator.MoveNext())
                     {
                         DependencyObject child = enumerator.Current as DependencyObject;
-                        if (child != null)
-                        {
-                            child.CoerceValue(property);
-                        }
+                        child?.CoerceValue(property);
                     }
                 }
             }
@@ -3989,7 +3986,7 @@ internal static bool ShouldApplyMirrorTransform(FrameworkElement fe)
                 bool hasParent = GetFrameworkParent(fe, out parentFE, out parentFCE);
                 if (hasParent)
                 {
-                    if (parentFE != null && parentFE is IContentHost)
+                    if (parentFE is IContentHost)
                     {
                         parentFlowDirection = parentFE.FlowDirection;
                     }
@@ -5811,10 +5808,7 @@ internal void OnUnloaded(RoutedEventArgs args)
         internal override void AddSynchronizedInputPreOpportunityHandlerCore(EventRoute route, RoutedEventArgs args)
         {
             UIElement uiElement = this._templatedParent as UIElement;
-            if (uiElement != null)
-            {
-                uiElement.AddSynchronizedInputPreOpportunityHandler(route, args);
-            }
+            uiElement?.AddSynchronizedInputPreOpportunityHandler(route, args);
 
         }
 
@@ -6119,10 +6113,7 @@ private void RaiseDependencyPropertyChanged(EventPrivateKey key, DependencyPrope
                         AddStyleHandlersToEventRoute(null, fce, route, args);
                     }
                 }
-                else if (uiElement3D != null)
-                {
-                    uiElement3D.AddToEventRoute(route, args);
-                }
+                else uiElement3D?.AddToEventRoute(route, args);
 
                 // Get model parent
                 modelTreeNode = LogicalTreeHelper.GetParent(modelTreeNode);
@@ -6154,10 +6145,7 @@ internal void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler)
         internal void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler)
         {
             EventHandlersStore store = EventHandlersStore;
-            if (store != null)
-            {
-                store.Remove(key, handler);
-            }
+            store?.Remove(key, handler);
         }
 
         // Gettor and Settor for flag that indicates if this
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElementFactory.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElementFactory.cs
index 4e3aeb50..e1bf2daa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElementFactory.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkElementFactory.cs
@@ -243,16 +243,13 @@ public void SetValue(DependencyProperty dp, object value)
                 //  Rather than silently do nothing, throw error.
                 throw new ArgumentException(SR.Get(SRID.ReadOnlyPropertyNotAllowed, dp.Name, GetType().Name));
             }
-
-            ResourceReferenceExpression resourceExpression = value as ResourceReferenceExpression;
-            DynamicResourceExtension dynamicResourceExtension = value as DynamicResourceExtension;
             object resourceKey = null;
 
-            if( resourceExpression != null )
+            if( value is ResourceReferenceExpression resourceExpression )
             {
                 resourceKey = resourceExpression.ResourceKey;
             }
-            else if( dynamicResourceExtension != null )
+            else if( value is DynamicResourceExtension dynamicResourceExtension )
             {
                 resourceKey = dynamicResourceExtension.ResourceKey;
             }
@@ -845,19 +842,14 @@ private void Seal()
                             // Get the value out of the table.
                             object o = PropertyValues[i].ValueInternal;
 
-
-                            // If it's a freezable that can't be frozen, it's probably not sharable,
-                            // so we make a copy of it.
-                            Freezable freezableValue = o as Freezable;
-                            if (freezableValue != null && !freezableValue.CanFreeze)
+                            // If it's a freezable that can't be frozen, it's probably not sharable,                            // so we make a copy of it.
+                            if (o is Freezable freezableValue && !freezableValue.CanFreeze)
                             {
                                 o = freezableValue.Clone();
                             }
 
-                            // Or, if it's a markup extension, get the value
-                            // to set on this property from the MarkupExtension itself.
-                            MarkupExtension me = o as MarkupExtension;
-                            if (me != null)
+                            // Or, if it's a markup extension, get the value                            // to set on this property from the MarkupExtension itself.
+                            if (o is MarkupExtension me)
                             {
                                 ProvideValueServiceProvider serviceProvider = new ProvideValueServiceProvider();
                                 serviceProvider.SetData( treeNodeVisual3D, PropertyValues[i].Property );
@@ -1137,11 +1129,8 @@ internal FrameworkObject InstantiateUnoptimizedTree()
         internal static void AddNodeToLogicalTree( DependencyObject parent, Type type,
             bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE)
         {
-            // If the logical parent already has children, then we can't add
-            // a logical subtree from the style, since there would be a conflict.
-            // Throw an exception in this case.
-            FrameworkContentElement logicalParent = parent as FrameworkContentElement;
-            if (logicalParent != null)
+            // If the logical parent already has children, then we can't add            // a logical subtree from the style, since there would be a conflict.            // Throw an exception in this case.
+            if (parent is FrameworkContentElement logicalParent)
             {
                 IEnumerator childEnumerator = logicalParent.LogicalChildren;
                 if (childEnumerator != null && childEnumerator.MoveNext())
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkPropertyMetadata.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkPropertyMetadata.cs
index 56120d21..fb0dcbb8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkPropertyMetadata.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkPropertyMetadata.cs
@@ -575,8 +575,7 @@ protected override void Merge(PropertyMetadata baseMetadata, DependencyProperty
             base.Merge(baseMetadata, dp);
 
             // Source type is guaranteed to be the same type or base type
-            FrameworkPropertyMetadata fbaseMetadata = baseMetadata as FrameworkPropertyMetadata;
-            if (fbaseMetadata != null)
+            if (baseMetadata is FrameworkPropertyMetadata fbaseMetadata)
             {
                 // Merge source metadata into this
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkTemplate.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkTemplate.cs
index 1212cbcb..1e7df82b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkTemplate.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/FrameworkTemplate.cs
@@ -430,10 +430,7 @@ public void Seal()
 
             //Let go of the TemplateContent object to reduce survived allocations.
             //Need to keep while parsing due to ambient lookup of DependencyPropertyConverter.
-            if (_templateHolder != null)
-            {
-                _templateHolder.ResetTemplateLoadData();
-            }
+            _templateHolder?.ResetTemplateLoadData();
         }
 
         // Subclasses need to call this method before any changes to their state.
@@ -724,8 +721,8 @@ public override void Reset()
         {
             DependencyObject dependencyObject = targetObject as DependencyObject;
             DependencyProperty dependencyProperty;
-            System.Windows.Baml2006.WpfXamlMember wpfMember = member as System.Windows.Baml2006.WpfXamlMember;
-            if (wpfMember != null)
+
+            if (member is System.Windows.Baml2006.WpfXamlMember wpfMember)
             {
                 dependencyProperty = wpfMember.DependencyProperty;
             }
@@ -990,10 +987,7 @@ private void LoadTemplateXaml(System.Xaml.XamlReader templateReader, XamlObjectW
 
                 while (templateReader.Read())
                 {
-                    if (lineInfoConsumer != null)
-                    {
-                        lineInfoConsumer.SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
-                    }
+                    lineInfoConsumer?.SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
 
                     // We need to call the ObjectWriter first because x:Name & RNPA needs to be registered
                     // before we call InvalidateProperties.
@@ -1056,10 +1050,7 @@ private void LoadTemplateXaml(System.Xaml.XamlReader templateReader, XamlObjectW
                             {
                                 if (Names.CurrentFrame.Property == XamlLanguage.ConnectionId)
                                 {
-                                    if (_styleConnector != null)
-                                    {
-                                        _styleConnector.Connect((int)templateReader.Value, Names.CurrentFrame.Instance);
-                                    }
+                                    _styleConnector?.Connect((int)templateReader.Value, Names.CurrentFrame.Instance);
                                 }
                             }
                             break;
@@ -1171,8 +1162,7 @@ private void InvalidatePropertiesOnTemplate(DependencyObject container, Object c
         {
             if (container != null)
             {
-                DependencyObject dObject = currentObject as DependencyObject;
-                if (dObject != null)
+                if (currentObject is DependencyObject dObject)
                 {
                     FrameworkObject child = new FrameworkObject(dObject);
                     if (child.IsValid)
@@ -1284,13 +1274,9 @@ private void InvalidatePropertiesOnTemplate(DependencyObject container, Object c
                                 value = new ResourceReferenceExpression(value);
                             }
 
-                            // Bindings are handled as just an ME
-
-                            // Set the value directly onto the element.
-
-                            MarkupExtension me = value as MarkupExtension;
+                            // Bindings are handled as just an ME                            // Set the value directly onto the element.
 
-                            if (me != null)
+                            if (value is MarkupExtension me)
                             {
                                 // This is provided for completeness, but really there's only a few
                                 // MEs that survive TemplateBamlRecordReader.  E.g. NullExtension would
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkContentElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkContentElement.cs
index c49f4b1f..d99c4703 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkContentElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkContentElement.cs
@@ -298,10 +298,7 @@ internal void ChangeLogicalParent(DependencyObject newParent)
             // to the dispatchers that the elements belong to.
             //
             this.VerifyAccess();
-            if(newParent != null)
-            {
-                newParent.VerifyAccess();
-            }
+            newParent?.VerifyAccess();
 
             // Logical Parent must first be dropped before you are attached to a newParent
             // This mitigates illegal tree state caused by logical child stealing as illustrated in bug 970706
@@ -628,25 +625,12 @@ internal void UpdateThemeStyleProperty()
                     StyleHelper.GetThemeStyle(/* fe = */ null, /* fce = */ this);
 
                     // Update the ContextMenu and ToolTips separately because they aren't in the tree
-                    ContextMenu contextMenu =
-                            GetValueEntry(
-                                    LookupEntry(ContextMenuProperty.GlobalIndex),
-                                    ContextMenuProperty,
-                                    null,
-                                    RequestFlags.DeferredReferences).Value as ContextMenu;
-                    if (contextMenu != null)
+                    if (GetValueEntry(LookupEntry(ContextMenuProperty.GlobalIndex), ContextMenuProperty, null, RequestFlags.DeferredReferences).Value is ContextMenu contextMenu)
                     {
                         TreeWalkHelper.InvalidateOnResourcesChange(contextMenu, null, ResourcesChangeInfo.ThemeChangeInfo);
                     }
 
-                    DependencyObject toolTip =
-                            GetValueEntry(
-                                    LookupEntry(ToolTipProperty.GlobalIndex),
-                                    ToolTipProperty,
-                                    null,
-                                    RequestFlags.DeferredReferences).Value as DependencyObject;
-
-                    if (toolTip != null)
+                    if (GetValueEntry(LookupEntry(ToolTipProperty.GlobalIndex), ToolTipProperty, null, RequestFlags.DeferredReferences).Value is DependencyObject toolTip)
                     {
                         FrameworkObject toolTipFO = new FrameworkObject(toolTip);
                         if (toolTipFO.IsValid)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkElement.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkElement.cs
index 1066e2ef..101c4d7a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Generated/FrameworkElement.cs
@@ -298,10 +298,7 @@ internal void ChangeLogicalParent(DependencyObject newParent)
             // to the dispatchers that the elements belong to.
             //
             this.VerifyAccess();
-            if(newParent != null)
-            {
-                newParent.VerifyAccess();
-            }
+            newParent?.VerifyAccess();
 
             // Logical Parent must first be dropped before you are attached to a newParent
             // This mitigates illegal tree state caused by logical child stealing as illustrated in bug 970706
@@ -365,7 +362,7 @@ internal virtual void OnNewParent(DependencyObject newParent)
 
 
             // Synchronize ForceInherit properties
-            if(_parent != null && _parent is ContentElement)
+            if(_parent is ContentElement)
             {
                 UIElement.SynchronizeForceInheritProperties(this, null, null, _parent);
             }
@@ -650,25 +647,12 @@ internal void UpdateThemeStyleProperty()
                     StyleHelper.GetThemeStyle(/* fe = */ this, /* fce = */ null);
 
                     // Update the ContextMenu and ToolTips separately because they aren't in the tree
-                    ContextMenu contextMenu =
-                            GetValueEntry(
-                                    LookupEntry(ContextMenuProperty.GlobalIndex),
-                                    ContextMenuProperty,
-                                    null,
-                                    RequestFlags.DeferredReferences).Value as ContextMenu;
-                    if (contextMenu != null)
+                    if (GetValueEntry(LookupEntry(ContextMenuProperty.GlobalIndex), ContextMenuProperty, null, RequestFlags.DeferredReferences).Value is ContextMenu contextMenu)
                     {
                         TreeWalkHelper.InvalidateOnResourcesChange(contextMenu, null, ResourcesChangeInfo.ThemeChangeInfo);
                     }
 
-                    DependencyObject toolTip =
-                            GetValueEntry(
-                                    LookupEntry(ToolTipProperty.GlobalIndex),
-                                    ToolTipProperty,
-                                    null,
-                                    RequestFlags.DeferredReferences).Value as DependencyObject;
-
-                    if (toolTip != null)
+                    if (GetValueEntry(LookupEntry(ToolTipProperty.GlobalIndex), ToolTipProperty, null, RequestFlags.DeferredReferences).Value is DependencyObject toolTip)
                     {
                         FrameworkObject toolTipFO = new FrameworkObject(toolTip);
                         if (toolTipFO.IsValid)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLength.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLength.cs
index b23cce98..92a0f444 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLength.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLength.cs
@@ -152,9 +152,8 @@ public GridLength(double value, GridUnitType type)
         /// and unit type as oCompare.</returns>
         override public bool Equals(object oCompare)
         {
-            if(oCompare is GridLength)
+            if(oCompare is GridLength l)
             {
-                GridLength l = (GridLength)oCompare;
                 return (this == l);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLengthConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLengthConverter.cs
index d1f3caa8..6ea74e1e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLengthConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/GridLengthConverter.cs
@@ -114,9 +114,9 @@ public class GridLengthConverter: TypeConverter
         {
             if (source != null)
             {
-                if (source is string)
+                if (source is string s)
                 {
-                    return (FromString((string)source, cultureInfo));
+                    return (FromString(s, cultureInfo));
                 }
                 else
                 {
@@ -171,11 +171,8 @@ public class GridLengthConverter: TypeConverter
                 throw new ArgumentNullException("destinationType");
             }
 
-            if (    value != null
-                &&  value is GridLength )
+            if (    value is GridLength gl)
             {
-                GridLength gl = (GridLength)value;
-
                 if (destinationType == typeof(string)) 
                 { 
                     return (ToString(gl, cultureInfo)); 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandConverter.cs
index 4752bb5d..dce64243 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandConverter.cs
@@ -75,7 +75,7 @@ public override bool CanConvertTo( ITypeDescriptorContext context, Type destinat
             {
                 RoutedCommand command = context != null ? context.Instance as RoutedCommand : null;
 
-                if (command != null && command.OwnerType != null && IsKnownType(command.OwnerType))
+                if (command?.OwnerType != null && IsKnownType(command.OwnerType))
                 {
                     return true;
                 }
@@ -95,7 +95,7 @@ public override bool CanConvertTo( ITypeDescriptorContext context, Type destinat
         ///<returns>instance of Command</returns>
         public override object ConvertFrom( ITypeDescriptorContext context, CultureInfo culture, object source )
         {
-            if (source != null && source is string)
+            if (source is string)
             {
                 if ((string)source != String.Empty)
                 {
@@ -185,7 +185,7 @@ public override object ConvertTo( ITypeDescriptorContext context, CultureInfo cu
             {
                 RoutedCommand command = value as RoutedCommand;
 
-                if (command != null && command.OwnerType != null && IsKnownType(command.OwnerType))
+                if (command?.OwnerType != null && IsKnownType(command.OwnerType))
                 {
                     return command.Name;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandValueSerializer.cs
index b7e2fd1e..00c6adb9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/Command/CommandValueSerializer.cs
@@ -101,8 +101,7 @@ public override IEnumerable<Type> TypeReferences(object value, IValueSerializerC
         {
             if (value != null)
             {
-                RoutedCommand command = value as RoutedCommand;
-                if (command != null)
+                if (value is RoutedCommand command)
                 {
                     if (command.OwnerType != null && !CommandConverter.IsKnownType(command.OwnerType))
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/KeyboardNavigation.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/KeyboardNavigation.cs
index 4406069f..b689eba9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/KeyboardNavigation.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Input/KeyboardNavigation.cs
@@ -846,10 +846,7 @@ internal void HideFocusVisual()
             if (_focusVisualAdornerCache != null)
             {
                 AdornerLayer adornerlayer = VisualTreeHelper.GetParent(_focusVisualAdornerCache) as AdornerLayer;
-                if (adornerlayer != null)
-                {
-                    adornerlayer.Remove(_focusVisualAdornerCache);
-                }
+                adornerlayer?.Remove(_focusVisualAdornerCache);
                 _focusVisualAdornerCache = null;
             }
         }
@@ -1292,10 +1289,7 @@ internal static void EnableKeyboardCues(DependencyObject element, bool enable)
             }
 
             Visual rootVisual = GetVisualRoot(visual);
-            if (rootVisual != null)
-            {
-                rootVisual.SetValue(ShowKeyboardCuesProperty, enable ? BooleanBoxes.TrueBox : BooleanBoxes.FalseBox);
-            }
+            rootVisual?.SetValue(ShowKeyboardCuesProperty, enable ? BooleanBoxes.TrueBox : BooleanBoxes.FalseBox);
         }
 
         internal static FocusNavigationDirection KeyToTraversalDirection(Key key)
@@ -2783,11 +2777,7 @@ private DependencyObject GetNextInDirection(DependencyObject sourceElement, Focu
                 else
                 {
                     ContentElement targetContentElement = targetElement as ContentElement;
-                    if (targetContentElement != null)
-                    {
-                        // When Focus is changed we need to reset the base line
-                        targetContentElement.AddHandler(Keyboard.PreviewLostKeyboardFocusEvent, new KeyboardFocusChangedEventHandler(_LostFocus), true);
-                    }
+                    targetContentElement?.AddHandler(Keyboard.PreviewLostKeyboardFocusEvent, new KeyboardFocusChangedEventHandler(_LostFocus), true);
                 }
 
                 if (targetUIElement != null)
@@ -2825,10 +2815,10 @@ private void _LostFocus(object sender, KeyboardFocusChangedEventArgs e)
             _verticalBaseline = BASELINE_DEFAULT;
             _horizontalBaseline = BASELINE_DEFAULT;
 
-            if (sender is UIElement)
-                ((UIElement)sender).RemoveHandler(Keyboard.PreviewLostKeyboardFocusEvent, new KeyboardFocusChangedEventHandler(_LostFocus));
-            else if (sender is ContentElement)
-                ((ContentElement)sender).RemoveHandler(Keyboard.PreviewLostKeyboardFocusEvent, new KeyboardFocusChangedEventHandler(_LostFocus));
+            if (sender is UIElement uIElement)
+                uIElement.RemoveHandler(Keyboard.PreviewLostKeyboardFocusEvent, new KeyboardFocusChangedEventHandler(_LostFocus));
+            else if (sender is ContentElement contentElement)
+                contentElement.RemoveHandler(Keyboard.PreviewLostKeyboardFocusEvent, new KeyboardFocusChangedEventHandler(_LostFocus));
         }
 
         private bool IsEndlessLoop(DependencyObject element, DependencyObject container)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/ActiveXHost.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/ActiveXHost.cs
index 81c0c51e..5094c9f0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/ActiveXHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/ActiveXHost.cs
@@ -887,9 +887,7 @@ private static void OnVisibilityInvalidated(ActiveXHost axHost)
         ///     This event handler forwards focus events to the hosted ActiveX control
         private static void OnGotFocus(object sender, KeyboardFocusChangedEventArgs e)
         {
-            ActiveXHost axhost = sender as ActiveXHost;
-
-            if (axhost != null)
+            if (sender is ActiveXHost axhost)
             {
                 Invariant.Assert(axhost.ActiveXState >= ActiveXHelper.ActiveXState.InPlaceActive, "Should at least be InPlaceActive when getting focus");
 
@@ -903,9 +901,7 @@ private static void OnGotFocus(object sender, KeyboardFocusChangedEventArgs e)
         ///     This event handler forwards focus events to the hosted WF controls
         private static void OnLostFocus(object sender, KeyboardFocusChangedEventArgs e)
         {
-            ActiveXHost axhost = sender as ActiveXHost;
-
-            if (axhost != null)
+            if (sender is ActiveXHost axhost)
             {
                 // If the focus goes from our control window to one of the child windows,
                 // we should not deactivate.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/DynamicScriptObject.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/DynamicScriptObject.cs
index 86b13f13..ac1f802f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/DynamicScriptObject.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/DynamicScriptObject.cs
@@ -362,8 +362,7 @@ internal unsafe bool TryFindMemberAndInvokeNonWrapped(string memberName, int fla
                     // if the output of a script accessing method is fed in to the input of another one.
                     for (int i = 0; i < args.Length; i++)
                     {
-                        var wrappedArg = args[i] as DynamicScriptObject;
-                        if (wrappedArg != null)
+                        if (args[i] is DynamicScriptObject wrappedArg)
                         {
                             args[i] = wrappedArg._scriptObject;
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/HwndHost.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/HwndHost.cs
index f9dba71f..c6724d87 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/HwndHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Interop/HwndHost.cs
@@ -354,7 +354,7 @@ public void UpdateWindowPos()
                 }
             }
 
-            if(vt != null && vt.RootVisual != null)
+            if(vt?.RootVisual != null)
             {
                 // Translate the layout information assigned to us from the co-ordinate
                 // space of this element, through the root visual, to the Win32 client
@@ -864,8 +864,7 @@ private void OnSourceChanged(object sender, SourceChangedEventArgs e)
             }
 
             // Add ourselves as an IKeyboardInputSinks child of our containing window.
-            IKeyboardInputSink source = PresentationSource.CriticalFromVisual(this, false /* enable2DTo3DTransition */) as IKeyboardInputSink;
-            if(source != null)
+            if(PresentationSource.CriticalFromVisual(this, false /* enable2DTo3DTransition */) is IKeyboardInputSink source)
             {
                 ((IKeyboardInputSink)this).KeyboardInputSite = source.RegisterKeyboardInputSink(this);
             }
@@ -936,8 +935,7 @@ private void BuildOrReparentWindow()
             PresentationSource source = PresentationSource.CriticalFromVisual(this, false /* enable2DTo3DTransition */);
             if(source != null)
             {
-                HwndSource hwndSource = source as HwndSource ;
-                if(hwndSource != null)
+                if(source is HwndSource hwndSource)
                 {
                     hwndParent = hwndSource.CriticalHandle;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/LogicalTreeHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/LogicalTreeHelper.cs
index 73f84380..c7bca2cf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/LogicalTreeHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/LogicalTreeHelper.cs
@@ -82,8 +82,7 @@ public static DependencyObject FindLogicalNode( DependencyObject logicalTreeNode
         DependencyObject childNode = null;
 
         // Check given node against named element.
-        IFrameworkInputElement selfNode = logicalTreeNode as IFrameworkInputElement;
-        if( selfNode != null )
+        if( logicalTreeNode is IFrameworkInputElement selfNode )
         {
             if( selfNode.Name == elementName )
             {
@@ -131,14 +130,12 @@ public static DependencyObject GetParent(DependencyObject current)
             throw new ArgumentNullException("current"); 
         }
 
-        FrameworkElement fe = current as FrameworkElement;
-        if (fe != null)
+        if (current is FrameworkElement fe)
         {
             return fe.Parent;
         }
 
-        FrameworkContentElement fce = current as FrameworkContentElement;
-        if (fce != null)
+        if (current is FrameworkContentElement fce)
         {
             return fce.Parent;
         }
@@ -158,14 +155,12 @@ public static IEnumerable GetChildren(DependencyObject current)
             throw new ArgumentNullException("current"); 
         }
 
-        FrameworkElement fe = current as FrameworkElement;
-        if (fe != null)
+        if (current is FrameworkElement fe)
         {
             return new EnumeratorWrapper(fe.LogicalChildren);
         }
 
-        FrameworkContentElement fce = current as FrameworkContentElement;
-        if (fce != null)
+        if (current is FrameworkContentElement fce)
         {
             return new EnumeratorWrapper(fce.LogicalChildren);
         }
@@ -210,16 +205,10 @@ public static void BringIntoView(DependencyObject current)
         }
 
         FrameworkElement fe = current as FrameworkElement;
-        if (fe != null)
-        {
-            fe.BringIntoView();
-        }
+        fe?.BringIntoView();
 
         FrameworkContentElement fce = current as FrameworkContentElement;
-        if (fce != null)
-        {
-            fce.BringIntoView();
-        }
+        fce?.BringIntoView();
     }
 
 /*
@@ -388,18 +377,14 @@ internal static void AddLogicalChild(DependencyObject parent, object child)
     {
         if (child != null && parent != null)
         {
-            FrameworkElement parentFE = parent as FrameworkElement;
-            if (parentFE != null)
+            if (parent is FrameworkElement parentFE)
             {
                 parentFE.AddLogicalChild(child);
             }
             else
             {
                 FrameworkContentElement parentFCE = parent as FrameworkContentElement;
-                if (parentFCE != null)
-                {
-                    parentFCE.AddLogicalChild(child);
-                }
+                parentFCE?.AddLogicalChild(child);
             }
         }
     }
@@ -412,10 +397,7 @@ internal static void AddLogicalChild(FrameworkElement parentFE, FrameworkContent
             {
                 parentFE.AddLogicalChild(child);
             }
-            else if (parentFCE != null)
-            {
-                parentFCE.AddLogicalChild(child);
-            }
+            else parentFCE?.AddLogicalChild(child);
         }
     }
 
@@ -423,18 +405,14 @@ internal static void RemoveLogicalChild(DependencyObject parent, object child)
     {
         if (child != null && parent != null)
         {
-            FrameworkElement parentFE = parent as FrameworkElement;
-            if (parentFE != null)
+            if (parent is FrameworkElement parentFE)
             {
                 parentFE.RemoveLogicalChild(child);
             }
             else
             {
                 FrameworkContentElement parentFCE = parent as FrameworkContentElement;
-                if (parentFCE != null)
-                {
-                    parentFCE.RemoveLogicalChild(child);
-                }
+                parentFCE?.RemoveLogicalChild(child);
             }
         }
     }
@@ -457,14 +435,12 @@ internal static void RemoveLogicalChild(FrameworkElement parentFE, FrameworkCont
 
     internal static IEnumerator GetLogicalChildren(DependencyObject current)
     {
-        FrameworkElement fe = current as FrameworkElement;
-        if (fe != null)
+        if (current is FrameworkElement fe)
         {
             return fe.LogicalChildren;
         }
 
-        FrameworkContentElement fce = current as FrameworkContentElement;
-        if (fce != null)
+        if (current is FrameworkContentElement fce)
         {
             return fce.LogicalChildren;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006Reader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006Reader.cs
index 1452e06d..28f1ad13 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006Reader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006Reader.cs
@@ -2161,10 +2161,7 @@ private void Process_LinePosition()
             _context.LineOffset = _binaryReader.ReadInt32();
             // We do this cast on every line info, but that is harmless for perf since line info is only in debug build
             IXamlLineInfoConsumer consumer = _xamlNodesWriter as IXamlLineInfoConsumer;
-            if (consumer != null)
-            {
-                consumer.SetLineInfo(_context.LineNumber, _context.LineOffset);
-            }
+            consumer?.SetLineInfo(_context.LineNumber, _context.LineOffset);
         }
 
         // (line, offset)
@@ -2174,10 +2171,7 @@ private void Process_LineNumberAndPosition()
             _context.LineOffset = _binaryReader.ReadInt32();
             // We do this cast on every line info, but that is harmless for perf since line info is only in debug build
             IXamlLineInfoConsumer consumer = _xamlNodesWriter as IXamlLineInfoConsumer;
-            if (consumer != null)
-            {
-                consumer.SetLineInfo(_context.LineNumber, _context.LineOffset);
-            }
+            consumer?.SetLineInfo(_context.LineNumber, _context.LineOffset);
         }
 
         private void Process_PIMapping()
@@ -2416,10 +2410,7 @@ private void InjectPropertyAndFrameIfNeeded(XamlType elementType, SByte flags)
                                 // This is needed to ensure that template root element carries a line info
                                 // which can then be used when it is instantiated
                                 IXamlLineInfoConsumer consumer = _xamlNodesWriter as IXamlLineInfoConsumer;
-                                if (consumer != null)
-                                {
-                                    consumer.SetLineInfo(_context.LineNumber, _context.LineOffset);
-                                }
+                                consumer?.SetLineInfo(_context.LineNumber, _context.LineOffset);
                             }
                         }
                     }
@@ -2765,10 +2756,7 @@ bool IFreezeFreezables.TryFreeze(string value, Freezable freezable)
         Freezable IFreezeFreezables.TryGetFreezable(string value)
         {
             Freezable freezable = null;
-            if (_freezeCache != null)
-            {
-                _freezeCache.TryGetValue(value, out freezable);
-            }
+            _freezeCache?.TryGetValue(value, out freezable);
 
             return freezable;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006ReaderFrame.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006ReaderFrame.cs
index 9fc57a46..69f3279e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006ReaderFrame.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006ReaderFrame.cs
@@ -89,10 +89,7 @@ public override void Reset()
         {
             XamlType = null;
             Member = null;
-            if (_namespaces != null)
-            {
-                _namespaces.Clear();
-            }
+            _namespaces?.Clear();
 
             Flags = Baml2006ReaderFrameFlags.None;
             IsDeferredContent = false;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006SchemaContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006SchemaContext.cs
index 32a74f37..8924c4fc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006SchemaContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/Baml2006SchemaContext.cs
@@ -190,8 +190,8 @@ internal XamlType GetXamlType(Int16 typeId)
         internal DependencyProperty GetDependencyProperty(Int16 propertyId)
         {
             XamlMember member = GetProperty(propertyId, false);
-            WpfXamlMember wpfMember = member as WpfXamlMember;
-            if (wpfMember != null)
+
+            if (member is WpfXamlMember wpfMember)
             {
                 Debug.Assert(wpfMember.DependencyProperty != null);
                 return wpfMember.DependencyProperty;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/SharedStream.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/SharedStream.cs
index 2664092c..85d25768 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/SharedStream.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/SharedStream.cs
@@ -65,8 +65,7 @@ private void Initialize(Stream baseStream, long offset, long length)
                 throw new ArgumentOutOfRangeException(nameof(length));
             }
 
-            SharedStream subStream = baseStream as SharedStream;
-            if (subStream != null)
+            if (baseStream is SharedStream subStream)
             {
                 _baseStream = subStream.BaseStream;
                 _offset = offset + subStream._offset;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfKnownMemberInvoker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfKnownMemberInvoker.cs
index 63fb6f15..1bde4751 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfKnownMemberInvoker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfKnownMemberInvoker.cs
@@ -84,8 +84,7 @@ public override ShouldSerializeResult ShouldSerializeValue(object instance)
                 return result ? ShouldSerializeResult.True : ShouldSerializeResult.False;
             }
 
-            DependencyObject dObject = instance as DependencyObject;
-            if (dObject != null && _member.DependencyProperty != null)
+            if (instance is DependencyObject dObject && _member.DependencyProperty != null)
             {
                 // Call DO's ShouldSerializeProperty to see if the property is set.
                 // If the property is unset, the property should not be serialized
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfMemberInvoker.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfMemberInvoker.cs
index e183e067..f8c2b230 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfMemberInvoker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfMemberInvoker.cs
@@ -23,8 +23,7 @@ public WpfMemberInvoker(WpfXamlMember member) : base(member)
 
         public override void SetValue(object instance, object value)
         {
-             DependencyObject dObject = instance as DependencyObject;
-             if (dObject != null)
+             if (instance is DependencyObject dObject)
              {
                  if (_member.DependencyProperty != null)
                  {
@@ -33,8 +32,7 @@ public override void SetValue(object instance, object value)
                  }
                  else if (_member.RoutedEvent != null)
                  {
-                     Delegate handler = value as Delegate;
-                     if (handler != null)
+                     if (value is Delegate handler)
                      {
                          UIElement.AddHandler(dObject, _member.RoutedEvent, handler);
                          return;
@@ -47,8 +45,7 @@ public override void SetValue(object instance, object value)
 
         public override object GetValue(object instance)
         {
-            DependencyObject dObject = instance as DependencyObject;
-            if (dObject != null && _member.DependencyProperty != null)
+            if (instance is DependencyObject dObject && _member.DependencyProperty != null)
             {
                 object result = dObject.GetValue(_member.DependencyProperty);
                 if (result != null)
@@ -104,8 +101,7 @@ public override ShouldSerializeResult ShouldSerializeValue(object instance)
                 return result ? ShouldSerializeResult.True : ShouldSerializeResult.False;
             }
 
-            DependencyObject dObject = instance as DependencyObject;
-            if (dObject != null && _member.DependencyProperty != null)
+            if (instance is DependencyObject dObject && _member.DependencyProperty != null)
             {
                 // Call DO's ShouldSerializeProperty to see if the property is set.
                 // If the property is unset, the property should not be serialized
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfSharedBamlSchemaContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfSharedBamlSchemaContext.cs
index f19a2e03..bf9215b9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfSharedBamlSchemaContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfSharedBamlSchemaContext.cs
@@ -235,8 +235,7 @@ internal XamlType GetKnownXamlType(Type type)
                     }
                     if (xamlType != null && xamlType.UnderlyingType == type)
                     {
-                        WpfKnownType bamlType = xamlType as WpfKnownType;
-                        if (bamlType != null)
+                        if (xamlType is WpfKnownType bamlType)
                         {
                             _knownBamlTypes[bamlType.BamlNumber] = bamlType;
                         }
@@ -285,7 +284,6 @@ internal Type ResolvePrefixedNameWithAdditionalWpfSemantics(string prefixedName,
             object dictObject = element.GetValue(System.Windows.Markup.XmlAttributeProperties.XmlnsDictionaryProperty);
             var prefixDictionary = dictObject as System.Windows.Markup.XmlnsDictionary;
             object mapsObject = element.GetValue(System.Windows.Markup.XmlAttributeProperties.XmlNamespaceMapsProperty);
-            var namespaceMaps = mapsObject as Hashtable;
 
             // If there was no xmlns map on the given Tree Element.
             // Then, as a last resort, if the prefix was "" use the Wpf Element URI.
@@ -301,7 +299,7 @@ internal Type ResolvePrefixedNameWithAdditionalWpfSemantics(string prefixedName,
             }
             else
             {
-                if (namespaceMaps != null && namespaceMaps.Count > 0)
+                if (mapsObject is Hashtable namespaceMaps && namespaceMaps.Count > 0)
                 {
                     // This DO was loaded with a custom XamlTypeMapper. Try the custom mappings first.
                     Type result = System.Windows.Markup.XamlTypeMapper.GetTypeFromName(prefixedName, element);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfXamlType.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfXamlType.cs
index fad0c558..1b992087 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfXamlType.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Baml2006/WpfXamlType.cs
@@ -85,8 +85,8 @@ public WpfXamlType(Type type, XamlSchemaContext schema, bool isBamlScenario, boo
         protected override XamlMember LookupContentProperty()
         {
             XamlMember result = base.LookupContentProperty();
-            WpfXamlMember wpfMember = result as WpfXamlMember;
-            if (wpfMember != null)
+
+            if (result is WpfXamlMember wpfMember)
             {
                 result = wpfMember.AsContentProperty;
             }
@@ -420,8 +420,7 @@ private XamlMember GetRegularDependencyProperty(string name, DependencyProperty
             XamlMember memberFromBase = base.LookupMember(name, skipReadOnlyCheck);
             if (memberFromBase != null)
             {
-                PropertyInfo propertyInfo = memberFromBase.UnderlyingMember as PropertyInfo;
-                if (propertyInfo != null)
+                if (memberFromBase.UnderlyingMember is PropertyInfo propertyInfo)
                 {
                     return new WpfXamlMember(property, propertyInfo, SchemaContext, UseV3Rules);
                 }
@@ -456,9 +455,8 @@ private static XamlMember FindKnownMember(WpfXamlType wpfXamlType, string name,
                 }
             }
 
-            WpfKnownType knownType = wpfXamlType as WpfKnownType;
             // Only look for known properties on a known type
-            if (knownType != null)
+            if (wpfXamlType is WpfKnownType knownType)
             {
                 // if it is a Baml Senario BAML doesn't really care if it was attachable or not
                 // so look for the property in AttachableMembers also if it wasn't found in Members.
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlMapTable.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlMapTable.cs
index 73538580..b6c3709c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlMapTable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlMapTable.cs
@@ -772,7 +772,7 @@ internal Type GetTypeFromTypeInfo(BamlTypeInfoRecord typeInfo)
                     // Check for cached type in object hash table.
                     TypeInfoKey key = GetTypeInfoKey(assemblyInfoRecord.AssemblyFullName, typeInfo.TypeFullName);
                     BamlTypeInfoRecord cachedTypeInfo = GetHashTableData(key) as BamlTypeInfoRecord;
-                    if (cachedTypeInfo != null && cachedTypeInfo.Type != null)
+                    if (cachedTypeInfo?.Type != null)
                     {
                         typeInfo.Type = cachedTypeInfo.Type;
                     }
@@ -823,7 +823,7 @@ internal Type GetCLRPropertyTypeAndNameFromId(short attributeId, out string prop
             Debug.Assert(attributeId >= 0, "Known Property Id must be a DependencyProperty.");
 
             BamlAttributeInfoRecord attributeInfo = GetAttributeInfoFromIdWithOwnerType(attributeId);
-            if (attributeInfo != null && attributeInfo.OwnerType != null)
+            if (attributeInfo?.OwnerType != null)
             {
                 // Update the CLR propInfo into the AttributeInfoRecord.
                 XamlTypeMapper.UpdateClrPropertyInfo(attributeInfo.OwnerType, attributeInfo);
@@ -1854,10 +1854,8 @@ internal struct AssemblyInfoKey
         /// </summary>
         public override bool Equals(object o)
         {
-            if (o is AssemblyInfoKey)
+            if (o is AssemblyInfoKey key)
             {
-                AssemblyInfoKey key = (AssemblyInfoKey)o;
-
                 return ((key.AssemblyFullName != null) ?
                                       key.AssemblyFullName.Equals(this.AssemblyFullName) :
                                       (this.AssemblyFullName == null));
@@ -1916,10 +1914,8 @@ internal struct TypeInfoKey
         /// </summary>
         public override bool Equals(object o)
         {
-            if (o is TypeInfoKey)
+            if (o is TypeInfoKey key)
             {
-                TypeInfoKey key = (TypeInfoKey)o;
-
                 return ((key.DeclaringAssembly != null) ?
                                       key.DeclaringAssembly.Equals(this.DeclaringAssembly) :
                                       (this.DeclaringAssembly == null)) &&
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlReader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlReader.cs
index fdb9daef..a2f6cf05 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlReader.cs
@@ -387,8 +387,7 @@ public bool MoveToNextProperty()
                 _propertiesIndex++;
                 object obj = _properties[_propertiesIndex];
 
-                BamlPropertyInfo info = obj as BamlPropertyInfo;
-                if (info != null)
+                if (obj is BamlPropertyInfo info)
                 {
                     _name = info.Name;
                     _localName = info.LocalName;
@@ -1254,8 +1253,8 @@ private void ProcessDeferKey()
                 // are not exposed publicly.  They are used to update the map table
                 // that maps ids to assemblies, types and attributes.
                 case BamlRecordType.DefAttributeKeyString:
-                    BamlDefAttributeKeyStringRecord stringKeyRecord = _currentBamlRecord as BamlDefAttributeKeyStringRecord;
-                    if (stringKeyRecord != null)
+
+                    if (_currentBamlRecord is BamlDefAttributeKeyStringRecord stringKeyRecord)
                     {
                         BamlKeyInfo info;
 
@@ -1287,8 +1286,8 @@ private void ProcessDeferKey()
                     break;
 
                 case BamlRecordType.DefAttributeKeyType:
-                    BamlDefAttributeKeyTypeRecord typeKeyRecord = _currentBamlRecord as BamlDefAttributeKeyTypeRecord;
-                    if (typeKeyRecord != null)
+
+                    if (_currentBamlRecord is BamlDefAttributeKeyTypeRecord typeKeyRecord)
                     {
                         // Translate the type information held in the baml record into
                         // the {x:Type prefix:Classname} format that would be used on
@@ -1508,8 +1507,7 @@ private BamlKeyInfo ProcessKeyTree()
                     case BamlRecordType.Text:
                     case BamlRecordType.TextWithId:
 
-                        BamlTextWithIdRecord textWithIdRecord = _currentBamlRecord as BamlTextWithIdRecord;
-                        if (textWithIdRecord != null)
+                        if (_currentBamlRecord is BamlTextWithIdRecord textWithIdRecord)
                         {
                             // Get the value string from the string table, and cache it in the
                             // record.
@@ -1762,10 +1760,7 @@ private string EscapeString(string value)
                     }
                     builder.Append('\\');
                 }
-                if (builder != null)
-                {
-                    builder.Append(value[i]);
-                }
+                builder?.Append(value[i]);
             }
 
             if (builder == null)
@@ -2185,8 +2180,7 @@ private void ReadTextRecord()
         {
             ClearProperties();
 
-            BamlTextWithIdRecord textWithIdRecord = _currentBamlRecord as BamlTextWithIdRecord;
-            if (textWithIdRecord != null)
+            if (_currentBamlRecord is BamlTextWithIdRecord textWithIdRecord)
             {
                 // Get the value string from the string table, and cache it in the
                 // record.
@@ -2194,8 +2188,7 @@ private void ReadTextRecord()
                                                 textWithIdRecord.ValueId);
             }
 
-            BamlTextWithConverterRecord textWithConverter = _currentBamlRecord as BamlTextWithConverterRecord;
-            if (textWithConverter != null)
+            if (_currentBamlRecord is BamlTextWithConverterRecord textWithConverter)
             {
                 short converterTypeId = textWithConverter.ConverterTypeId;
                 Type converter = MapTable.GetTypeFromId(converterTypeId);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordReader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordReader.cs
index 46d99d54..7ed3b94c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordReader.cs
@@ -369,10 +369,7 @@ internal BamlRecordType GetNextRecordType()
         /// </summary>
         internal void Close()
         {
-            if (BamlStream != null)
-            {
-                BamlStream.Close();
-            }
+            BamlStream?.Close();
             EndOfDocument = true;
         }
 
@@ -2964,10 +2961,7 @@ private void DoRegisterName( string name, object element )
                         // "myStyle" also gets registered with the Window
                         // "myBrush" gets registered with the Style
                         INameScope nameScopePeek = ParserContext.NameScopeStack.Peek() as INameScope;
-                        if (nameScopePeek != null)
-                        {
-                            nameScopePeek.RegisterName(name, element);
-                        }
+                        nameScopePeek?.RegisterName(name, element);
                     }
                     else
                     {
@@ -3819,9 +3813,8 @@ internal virtual void SetClrComplexPropertyCore(object parentObject, object valu
 
             // Check if we have a Nullable type.  If so and the object being set is
             // not a Nullable or an expression, then attempt a conversion.
-            if (memberInfo is PropertyInfo)
+            if (memberInfo is PropertyInfo propertyInfo)
             {
-                PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
                 value = OptionallyMakeNullable(propertyInfo.PropertyType, value, propertyInfo.Name);
 
                 propertyInfo.SetValue(parentObject, value, BindingFlags.Default, null, null
@@ -4430,17 +4423,14 @@ private bool ElementInitialize(object element, string name)
             else
             {
                 // Set the ApplicationMarkupBaseUri if this is for AppDef baml stream.
-                if (element is Application)
+                if (element is Application application)
                 {
-                    ((Application)element).ApplicationMarkupBaseUri = GetBaseUri();
+                    application.ApplicationMarkupBaseUri = GetBaseUri();
                 }
             }
 
             UIElement uiElement = element as UIElement;
-            if (uiElement != null)
-            {
-                uiElement.SetPersistId(++_persistId);
-            }
+            uiElement?.SetPersistId(++_persistId);
 
             // The second consition is to handle events within standalone dictionaries.
             // We need to setup the component connector correctly in this case. Note
@@ -5351,10 +5341,7 @@ internal void FreezeIfRequired(object element)
             if (_parserContext.FreezeFreezables)
             {
                 Freezable f = element as Freezable;
-                if (f != null)
-                {
-                    f.Freeze();
-                }
+                f?.Freeze();
             }
         }
         internal void PreParsedBamlReset()
@@ -5409,9 +5396,9 @@ internal Stream BamlStream
 
                 // if this is one of our Readers streams
                 // setup the XAMLReaderStream property.
-                if (_bamlStream is ReaderStream)
+                if (_bamlStream is ReaderStream readerStream)
                 {
-                    _xamlReaderStream = (ReaderStream) _bamlStream;
+                    _xamlReaderStream = readerStream;
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordWriter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordWriter.cs
index 1c962a3c..a8dace1a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlRecordWriter.cs
@@ -538,8 +538,8 @@ private IBamlDictionaryKey FindBamlDictionaryKey(KeyDeferRecord record)
                     for (int i = 0; i < record.RecordList.Count; i++)
                     {
                         ValueDeferRecord valueDeferRecord = (ValueDeferRecord)record.RecordList[i];
-                        IBamlDictionaryKey dictionaryKey = valueDeferRecord.Record as IBamlDictionaryKey;
-                        if (dictionaryKey != null)
+
+                        if (valueDeferRecord.Record is IBamlDictionaryKey dictionaryKey)
                         {
                             return dictionaryKey;
                         }
@@ -1630,10 +1630,7 @@ private void WriteDeferableContent(XamlElementEndNode xamlNode)
                         keyRecord = (IBamlDictionaryKey)deferKeyRecord.Record;
                     }
                     Debug.Assert(keyRecord != null, "Unknown key record type in defer load dictionary");
-                    if (keyRecord != null)
-                    {
-                        keyRecord.UpdateValuePosition((Int32)(position-endOfKeys), BinaryWriter);
-                    }
+                    keyRecord?.UpdateValuePosition((Int32)(position - endOfKeys), BinaryWriter);
                 }
                 WriteBamlRecord(deferRecord.Record,
                                 deferRecord.LineNumber,
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlWriter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlWriter.cs
index 941dc5ac..6187e88c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/BamlWriter.cs
@@ -122,8 +122,7 @@ string IParserHelper.LookupNamespace(string prefix)
                 typeAndSerializer = _xamlTypeMapper.GetTypeAndSerializer(namespaceURI, localName + "Extension", null);
             }
 
-            if (typeAndSerializer != null &&
-                typeAndSerializer.ObjectType != null)
+            if (typeAndSerializer?.ObjectType != null)
             {
                 serializerType = typeAndSerializer.SerializerType;
                 baseType = typeAndSerializer.ObjectType;
@@ -655,15 +654,14 @@ public void WriteEndConstructor()
             else
             {
                 propertyType = XamlTypeMapper.GetPropertyType(dpOrPi);
-                PropertyInfo pi = dpOrPi as PropertyInfo;
-                if (pi != null)
+
+                if (dpOrPi is PropertyInfo pi)
                 {
                     propertyCanWrite = pi.CanWrite;
                 }
                 else
                 {
-                    DependencyProperty dp = dpOrPi as DependencyProperty;
-                    if (dp != null)
+                    if (dpOrPi is DependencyProperty dp)
                     {
                         propertyCanWrite = !dp.ReadOnly;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/DependencyPropertyConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/DependencyPropertyConverter.cs
index 2cf87e15..bbaabe13 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/DependencyPropertyConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/DependencyPropertyConverter.cs
@@ -113,11 +113,10 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
         {
             Type type = null;
             string property = null;
-
-            DependencyProperty dProperty = source as DependencyProperty;
             byte[] bytes;
             String value;
-            if (dProperty != null)
+
+            if (source is DependencyProperty dProperty)
             {
                 return dProperty;
             }
@@ -263,10 +262,8 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
 
             AmbientPropertyValue ambientValue =
                 ambientProvider.GetFirstAmbientValue(new XamlType[] { frameworkTemplateXType }, templateProperty);
-            TemplateContent templateHolder =
-                ambientValue.Value as System.Windows.TemplateContent;
 
-            if (templateHolder != null)
+            if (ambientValue.Value is System.Windows.TemplateContent templateHolder)
             {
                 return templateHolder.GetTypeForName(target).UnderlyingType;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/ParserContext.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/ParserContext.cs
index 788cd569..79f2b8df 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/ParserContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/ParserContext.cs
@@ -803,10 +803,7 @@ internal bool TryCacheFreezable(string value, Freezable freezable)
         internal Freezable TryGetFreezable(string value)
         {
             Freezable freezable = null;
-            if (_freezeCache != null)
-            {
-                _freezeCache.TryGetValue(value, out freezable);
-            }
+            _freezeCache?.TryGetValue(value, out freezable);
 
             return freezable;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/ExtensionSimplifierMarkupObject.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/ExtensionSimplifierMarkupObject.cs
index 2a900de2..f686a3f6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/ExtensionSimplifierMarkupObject.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/ExtensionSimplifierMarkupObject.cs
@@ -357,7 +357,7 @@ private string ConvertMarkupItemToString(MarkupObject item)
                 
                 string value = property.StringValue;
                 
-                if (value != null && value.Length > 0)
+                if (!string.IsNullOrEmpty(value))
                 {
                     if (value[0] == '{')
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/MarkupWriter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/MarkupWriter.cs
index 5c5e121d..bf7d089b 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/MarkupWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/Primitives/MarkupWriter.cs
@@ -273,8 +273,7 @@ public Entry(TKey key, TValue value)
 
                 public override bool Equals(object obj)
                 {
-                    Entry other = obj as Entry;
-                    return other != null && other.Key.Equals(Key);
+                    return obj is Entry other && other.Key.Equals(Key);
                 }
 
                 public override int GetHashCode()
@@ -491,8 +490,6 @@ private void WriteItem(MarkupObject item, Scope scope)
 
             // Write attributes
             ContentPropertyAttribute cpa = item.Attributes[typeof(ContentPropertyAttribute)] as ContentPropertyAttribute;
-            XmlLangPropertyAttribute xlpa = item.Attributes[typeof(XmlLangPropertyAttribute)] as XmlLangPropertyAttribute;
-            UidPropertyAttribute upa = item.Attributes[typeof(UidPropertyAttribute)] as UidPropertyAttribute;
             MarkupProperty contentProperty = null;
 
             bool first = true;
@@ -587,12 +584,12 @@ private void WriteItem(MarkupObject item, Scope scope)
                     {
                         property.VerifyOnlySerializableTypes();
 
-                        if (xlpa != null && xlpa.Name == property.PropertyDescriptor.Name)
+                        if (item.Attributes[typeof(XmlLangPropertyAttribute)] is XmlLangPropertyAttribute xlpa && xlpa.Name == property.PropertyDescriptor.Name)
                         {
                             // This is an xml:lang attribute
                             _writer.WriteAttributeString("xml", "lang", NamespaceCache.XmlNamespace, property.StringValue);
                         }
-                        else if (upa != null && upa.Name == property.PropertyDescriptor.Name)
+                        else if (item.Attributes[typeof(UidPropertyAttribute)] is UidPropertyAttribute upa && upa.Name == property.PropertyDescriptor.Name)
                         {
                             string xamlUri = scope.MakeAddressable(NamespaceCache.XamlNamespace);
                             _writer.WriteAttributeString(scope.GetPrefixOf(xamlUri), property.PropertyDescriptor.Name, xamlUri, property.StringValue);
@@ -746,8 +743,7 @@ private void WriteItem(MarkupObject item, Scope scope)
                 // If we have a content property, write it here
                 if (contentProperty.IsComposite)
                 {
-                    IXmlSerializable serializable = contentProperty.Value as IXmlSerializable;
-                    if (serializable != null)
+                    if (contentProperty.Value is IXmlSerializable serializable)
                     {
                         WriteXmlIsland(serializable, scope);
                     }
@@ -946,8 +942,7 @@ private bool IsContentProperty(MarkupProperty property, ContentPropertyAttribute
                 // Since there can be multiple DependsOn attributes, we need to iterate
                 foreach (Attribute attribute in property.Attributes)
                 {
-                    DependsOnAttribute dependsOn = attribute as DependsOnAttribute;
-                    if (dependsOn != null)
+                    if (attribute is DependsOnAttribute dependsOn)
                     {
                         if (!writtenAttributes.ContainsKey(dependsOn.Name))
                         {
@@ -1100,8 +1095,7 @@ private List<Type> GetWrapperTypes(Type type)
                 List<Type> wrapperTypes = new List<Type>();
                 foreach (Attribute attribute in attributes)
                 {
-                    ContentWrapperAttribute contentAttribute = attribute as ContentWrapperAttribute;
-                    if (contentAttribute != null)
+                    if (attribute is ContentWrapperAttribute contentAttribute)
                         wrapperTypes.Add(contentAttribute.ContentWrapper);
                 }
                 return wrapperTypes;
@@ -1112,11 +1106,10 @@ private MarkupProperty GetWrappedProperty(List<Type> wrapperTypes, MarkupObject
         {
             if (!IsInTypes(item.ObjectType, wrapperTypes))
                 return null;
-            ContentPropertyAttribute cpa = item.Attributes[typeof(ContentPropertyAttribute)] as ContentPropertyAttribute;
             MarkupProperty contentProperty = null;
             foreach (MarkupProperty property in item.Properties)
             {
-                if (property.IsContent || (cpa != null && property.PropertyDescriptor != null && property.PropertyDescriptor.Name == cpa.Name))
+                if (property.IsContent || (item.Attributes[typeof(ContentPropertyAttribute)] is ContentPropertyAttribute cpa && property.PropertyDescriptor != null && property.PropertyDescriptor.Name == cpa.Name))
                     contentProperty = property;
                 else
                 {
@@ -1241,8 +1234,7 @@ private bool IsCollectionType(Type type)
         private bool ShouldTrimSurroundingWhitespace(MarkupObject item)
         {
             // An item declares how surrounding whitespace should be treated with the TrimSurroundingWhitespaceAttribute.
-            TrimSurroundingWhitespaceAttribute attribute = item.Attributes[typeof(TrimSurroundingWhitespaceAttribute)] as TrimSurroundingWhitespaceAttribute;
-            return (attribute != null);
+            return (item.Attributes[typeof(TrimSurroundingWhitespaceAttribute)] is TrimSurroundingWhitespaceAttribute attribute);
         }
 
         private bool IsNormalizationNeutralString(string value, bool keepLeadingSpace, bool keepTrailingSpace)
@@ -1295,8 +1287,7 @@ public Mapping(string uri, string prefix)
 
             public override bool Equals(object obj)
             {
-                Mapping other = obj as Mapping;
-                return other != null && Uri.Equals(other.Uri) && Prefix.Equals(other.Prefix);
+                return obj is Mapping other && Uri.Equals(other.Uri) && Prefix.Equals(other.Prefix);
             }
 
             public override int GetHashCode()
@@ -1546,8 +1537,7 @@ public override string ConvertToString(object value, IValueSerializerContext con
 
             public override IEnumerable<Type> TypeReferences(object value, IValueSerializerContext context)
             {
-                Type type = value as Type;
-                if (type != null)
+                if (value is Type type)
                     return new Type[] { type };
                 else
                     return base.TypeReferences(value, context);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventConverter.cs
index 9274a351..190df1bf 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventConverter.cs
@@ -48,20 +48,17 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                                            CultureInfo cultureInfo,
                                            object source)
         {
-            string routedEventName = source as string;
             RoutedEvent routedEvent = null;
 
-            if (routedEventName != null)
+            if (source is string routedEventName)
             {
                 routedEventName = routedEventName.Trim();
-                IServiceProvider serviceProvider = typeDescriptorContext as IServiceProvider;
 
-                if (serviceProvider != null)
+                if (typeDescriptorContext is IServiceProvider serviceProvider)
                 {
-                    IXamlTypeResolver resolver = serviceProvider.GetService(typeof(IXamlTypeResolver)) as IXamlTypeResolver;
                     Type type = null;
 
-                    if (resolver != null)
+                    if (serviceProvider.GetService(typeof(IXamlTypeResolver)) is IXamlTypeResolver resolver)
                     {
                         // Verify that there's at least one period.  (A simple
                         //  but not foolproof check for "[class].[event]")
@@ -81,9 +78,7 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                             GetService(typeof(IXamlSchemaContextProvider))
                                 as IXamlSchemaContextProvider);
 
-                        IAmbientProvider iapp = serviceProvider.GetService(typeof(IAmbientProvider)) as IAmbientProvider;
-
-                        if (schemaContextProvider != null && iapp != null)
+                        if (schemaContextProvider != null && serviceProvider.GetService(typeof(IAmbientProvider)) is IAmbientProvider iapp)
                         {
                             XamlSchemaContext schemaContext = schemaContextProvider.SchemaContext;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventValueSerializer.cs
index f6138ef7..d80b4744 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/RoutedEventValueSerializer.cs
@@ -26,8 +26,7 @@ public override bool CanConvertFromString(string value, IValueSerializerContext
 
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            RoutedEvent routedEvent = value as RoutedEvent;
-            if (routedEvent != null)
+            if (value is RoutedEvent routedEvent)
             {
                 ValueSerializer typeSerializer = ValueSerializer.GetSerializerFor(typeof(Type), context);
                 if (typeSerializer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/SetterTriggerConditionValueConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/SetterTriggerConditionValueConverter.cs
index 8b061a77..aecba735 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/SetterTriggerConditionValueConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/SetterTriggerConditionValueConverter.cs
@@ -166,8 +166,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                     }
                     else if (source is byte[])
                     {
-                        byte[] bytes = source as byte[];
-                        if (bytes != null && bytes.Length == 1)
+                        if (source is byte[] bytes && bytes.Length == 1)
                         {
                             return (bytes[0] != 0);
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/StyleXamlParser.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/StyleXamlParser.cs
index 82dce4fe..b038df81 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/StyleXamlParser.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/StyleXamlParser.cs
@@ -444,8 +444,7 @@ private MemberInfo GetPropertyOrEventInfo(XamlNode xamlNode, ref string member)
             {
                 if (!_inEventSetter)
                 {
-                    PropertyInfo pi = memberInfo as PropertyInfo;
-                    if (pi != null)
+                    if (memberInfo is PropertyInfo pi)
                     {
                         // For trigger condition only allow if public or internal getter
                         if (_inSetterDepth < 0 && _styleModeStack.Mode == StyleMode.TriggerBase)
@@ -579,10 +578,7 @@ public override void WriteDefAttribute(XamlDefAttributeNode xamlDefAttributeNode
         {
             if (xamlDefAttributeNode.Name == BamlMapTable.NameString)
             {
-                if (BamlRecordWriter != null)
-                {
-                    BamlRecordWriter.WriteDefAttribute(xamlDefAttributeNode);
-                }
+                BamlRecordWriter?.WriteDefAttribute(xamlDefAttributeNode);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/TemplateXamlParser.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/TemplateXamlParser.cs
index 36674430..6d7bff63 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/TemplateXamlParser.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/TemplateXamlParser.cs
@@ -500,9 +500,7 @@ private MemberInfo GetCLRPropertyInfo(XamlPropertyNode xamlPropertyNode, ref str
 
             if (memberInfo != null)
             {
-                PropertyInfo pi = memberInfo as PropertyInfo;
-
-                if (pi != null)
+                if (memberInfo is PropertyInfo pi)
                 {
                     // For trigger condition only allow if public or internal getter
                     if (_inSetterDepth < 0 && _styleModeStack.Mode == StyleMode.TriggerBase)
@@ -603,10 +601,7 @@ public override void WriteDefAttribute(XamlDefAttributeNode xamlDefAttributeNode
         {
             if (xamlDefAttributeNode.Name == BamlMapTable.NameString)
             {
-                if (BamlRecordWriter != null)
-                {
-                    BamlRecordWriter.WriteDefAttribute(xamlDefAttributeNode);
-                }
+                BamlRecordWriter?.WriteDefAttribute(xamlDefAttributeNode);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/WpfXamlLoader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/WpfXamlLoader.cs
index 29cfb380..090e8a63 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/WpfXamlLoader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/WpfXamlLoader.cs
@@ -99,10 +99,7 @@ internal static void EnsureXmlNamespaceMaps(object rootObject, XamlSchemaContext
                 }
 
                 UIElement uiElement = args.Instance as UIElement;
-                if (uiElement != null)
-                {
-                    uiElement.SetPersistId(persistId++);
-                }
+                uiElement?.SetPersistId(persistId++);
 
                 XamlSourceInfoHelper.SetXamlSourceInfo(args.Instance, args, baseUri);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XAMLParseException.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XAMLParseException.cs
index 5b92931a..ac3e8c99 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XAMLParseException.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XAMLParseException.cs
@@ -422,7 +422,7 @@ Type objectType
         {
             // If there's an inner exception, we'll append its message to our own.
 
-            if (innerException != null && innerException.Message != null)
+            if (innerException?.Message != null)
             {
                 StringBuilder sb = new StringBuilder(message);
                 if (innerException.Message != String.Empty)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlParser.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlParser.cs
index ed11a6d1..1a760f1c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlParser.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlParser.cs
@@ -225,9 +225,8 @@ public bool ReadXaml(bool singleRecordMode)
                     int linePosition = 0;
                     string newMessage = null;
 
-                    if (e is XmlException)
+                    if (e is XmlException xmlEx)
                     {
-                        XmlException xmlEx = (XmlException)e;
                         lineNumber = xmlEx.LineNumber;
                         linePosition = xmlEx.LinePosition;
                         newMessage = xmlEx.Message;
@@ -547,10 +546,7 @@ public bool ReadXaml(bool singleRecordMode)
         /// </summary>
         public virtual void WriteDocumentStart(XamlDocumentStartNode XamlDocumentStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteDocumentStart(XamlDocumentStartNode);
-            }
+            BamlRecordWriter?.WriteDocumentStart(XamlDocumentStartNode);
         }
 
         /// <summary>
@@ -558,10 +554,7 @@ public virtual void WriteDocumentStart(XamlDocumentStartNode XamlDocumentStartNo
         /// </summary>
         public virtual void WriteDocumentEnd(XamlDocumentEndNode xamlEndDocumentNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteDocumentEnd(xamlEndDocumentNode);
-            }
+            BamlRecordWriter?.WriteDocumentEnd(xamlEndDocumentNode);
         }
 
         /// <summary>
@@ -569,10 +562,7 @@ public virtual void WriteDocumentEnd(XamlDocumentEndNode xamlEndDocumentNode)
         /// </summary>
         public virtual void WriteElementStart(XamlElementStartNode xamlElementStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteElementStart(xamlElementStartNode);
-            }
+            BamlRecordWriter?.WriteElementStart(xamlElementStartNode);
         }
 
         /// <summary>
@@ -607,10 +597,7 @@ public virtual void WriteUnknownTagEnd(XamlUnknownTagEndNode xamlUnknownTagEndNo
         /// </summary>
         public virtual void WriteElementEnd(XamlElementEndNode xamlElementEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteElementEnd(xamlElementEndNode);
-            }
+            BamlRecordWriter?.WriteElementEnd(xamlElementEndNode);
         }
 
         /// <summary>
@@ -618,10 +605,7 @@ public virtual void WriteElementEnd(XamlElementEndNode xamlElementEndNode)
         /// </summary>
         public virtual void WriteLiteralContent(XamlLiteralContentNode xamlLiteralContentNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteLiteralContent(xamlLiteralContentNode);
-            }
+            BamlRecordWriter?.WriteLiteralContent(xamlLiteralContentNode);
         }
 
         /// <summary>
@@ -631,10 +615,7 @@ public virtual void WriteLiteralContent(XamlLiteralContentNode xamlLiteralConten
         public virtual void WritePropertyComplexStart(
             XamlPropertyComplexStartNode xamlPropertyComplexStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyComplexStart(xamlPropertyComplexStartNode);
-            }
+            BamlRecordWriter?.WritePropertyComplexStart(xamlPropertyComplexStartNode);
         }
 
 
@@ -645,10 +626,7 @@ public virtual void WriteLiteralContent(XamlLiteralContentNode xamlLiteralConten
         public virtual void WritePropertyComplexEnd(
             XamlPropertyComplexEndNode xamlPropertyComplexEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyComplexEnd(xamlPropertyComplexEndNode);
-            }
+            BamlRecordWriter?.WritePropertyComplexEnd(xamlPropertyComplexEndNode);
         }
 
         /// <summary>
@@ -657,10 +635,7 @@ public virtual void WriteLiteralContent(XamlLiteralContentNode xamlLiteralConten
         public virtual void WriteKeyElementStart(
             XamlElementStartNode xamlKeyElementStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteKeyElementStart(xamlKeyElementStartNode);
-            }
+            BamlRecordWriter?.WriteKeyElementStart(xamlKeyElementStartNode);
         }
 
         /// <summary>
@@ -669,10 +644,7 @@ public virtual void WriteLiteralContent(XamlLiteralContentNode xamlLiteralConten
         public virtual void WriteKeyElementEnd(
             XamlElementEndNode xamlKeyElementEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteKeyElementEnd(xamlKeyElementEndNode);
-            }
+            BamlRecordWriter?.WriteKeyElementEnd(xamlKeyElementEndNode);
         }
 
         /// <summary>
@@ -701,18 +673,12 @@ public virtual void WriteUnknownAttribute(XamlUnknownAttributeNode xamlUnknownAt
         /// </remarks>
         public virtual void WriteProperty(XamlPropertyNode xamlPropertyNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteProperty(xamlPropertyNode);
-            }
+            BamlRecordWriter?.WriteProperty(xamlPropertyNode);
         }
 
         internal void WriteBaseProperty(XamlPropertyNode xamlPropertyNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.BaseWriteProperty(xamlPropertyNode);
-            }
+            BamlRecordWriter?.BaseWriteProperty(xamlPropertyNode);
         }
 
         /// <summary>
@@ -744,10 +710,7 @@ public virtual void WritePropertyWithType(XamlPropertyWithTypeNode xamlPropertyN
 
         public virtual void WritePropertyWithExtension(XamlPropertyWithExtensionNode xamlPropertyWithExtensionNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyWithExtension(xamlPropertyWithExtensionNode);
-            }
+            BamlRecordWriter?.WritePropertyWithExtension(xamlPropertyWithExtensionNode);
         }
 
 
@@ -756,10 +719,7 @@ public virtual void WritePropertyWithExtension(XamlPropertyWithExtensionNode xam
         /// </summary>
         public virtual void WriteText(XamlTextNode xamlTextNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteText(xamlTextNode);
-            }
+            BamlRecordWriter?.WriteText(xamlTextNode);
         }
 
 
@@ -768,10 +728,7 @@ public virtual void WriteText(XamlTextNode xamlTextNode)
         /// </summary>
         public virtual void WriteNamespacePrefix(XamlXmlnsPropertyNode xamlXmlnsPropertyNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteNamespacePrefix(xamlXmlnsPropertyNode);
-            }
+            BamlRecordWriter?.WriteNamespacePrefix(xamlXmlnsPropertyNode);
         }
 
 
@@ -789,10 +746,7 @@ public virtual void WritePIMapping(XamlPIMappingNode xamlPIMappingNode)
                 ThrowException(SRID.ParserMapPIMissingKey, xamlPIMappingNode.LineNumber, xamlPIMappingNode.LinePosition);
             }
 
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePIMapping(xamlPIMappingNode);
-            }
+            BamlRecordWriter?.WritePIMapping(xamlPIMappingNode);
         }
 
         /// <summary>
@@ -810,10 +764,7 @@ public virtual void WriteClrEvent(XamlClrEventNode xamlClrEventNode)
                     xamlClrEventNode.LineNumber,
                     xamlClrEventNode.LinePosition);
             }
-            else if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteClrEvent(xamlClrEventNode);
-            }
+            else BamlRecordWriter?.WriteClrEvent(xamlClrEventNode);
         }
 
         /// <summary>
@@ -821,10 +772,7 @@ public virtual void WriteClrEvent(XamlClrEventNode xamlClrEventNode)
         /// </summary>
         public virtual void WritePropertyArrayStart(XamlPropertyArrayStartNode xamlPropertyArrayStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyArrayStart(xamlPropertyArrayStartNode);
-            }
+            BamlRecordWriter?.WritePropertyArrayStart(xamlPropertyArrayStartNode);
         }
 
 
@@ -833,10 +781,7 @@ public virtual void WritePropertyArrayStart(XamlPropertyArrayStartNode xamlPrope
         /// </summary>
         public virtual void WritePropertyArrayEnd(XamlPropertyArrayEndNode xamlPropertyArrayEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyArrayEnd(xamlPropertyArrayEndNode);
-            }
+            BamlRecordWriter?.WritePropertyArrayEnd(xamlPropertyArrayEndNode);
         }
 
 
@@ -845,10 +790,7 @@ public virtual void WritePropertyArrayEnd(XamlPropertyArrayEndNode xamlPropertyA
         /// </summary>
         public virtual void WritePropertyIListStart(XamlPropertyIListStartNode xamlPropertyIListStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyIListStart(xamlPropertyIListStartNode);
-            }
+            BamlRecordWriter?.WritePropertyIListStart(xamlPropertyIListStartNode);
         }
 
 
@@ -857,10 +799,7 @@ public virtual void WritePropertyIListStart(XamlPropertyIListStartNode xamlPrope
         /// </summary>
         public virtual void WritePropertyIListEnd(XamlPropertyIListEndNode xamlPropertyIListEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyIListEnd(xamlPropertyIListEndNode);
-            }
+            BamlRecordWriter?.WritePropertyIListEnd(xamlPropertyIListEndNode);
         }
 
         /// <summary>
@@ -868,10 +807,7 @@ public virtual void WritePropertyIListEnd(XamlPropertyIListEndNode xamlPropertyI
         /// </summary>
         public virtual void WritePropertyIDictionaryStart(XamlPropertyIDictionaryStartNode xamlPropertyIDictionaryStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyIDictionaryStart(xamlPropertyIDictionaryStartNode);
-            }
+            BamlRecordWriter?.WritePropertyIDictionaryStart(xamlPropertyIDictionaryStartNode);
         }
 
 
@@ -880,10 +816,7 @@ public virtual void WritePropertyIDictionaryStart(XamlPropertyIDictionaryStartNo
         /// </summary>
         public virtual void WritePropertyIDictionaryEnd(XamlPropertyIDictionaryEndNode xamlPropertyIDictionaryEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePropertyIDictionaryEnd(xamlPropertyIDictionaryEndNode);
-            }
+            BamlRecordWriter?.WritePropertyIDictionaryEnd(xamlPropertyIDictionaryEndNode);
         }
 
 
@@ -894,10 +827,7 @@ public virtual void WritePropertyIDictionaryEnd(XamlPropertyIDictionaryEndNode x
         /// </summary>
         public virtual void WriteEndAttributes(XamlEndAttributesNode xamlEndAttributesNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteEndAttributes(xamlEndAttributesNode);
-            }
+            BamlRecordWriter?.WriteEndAttributes(xamlEndAttributesNode);
         }
 
         /// <summary>
@@ -919,10 +849,7 @@ public virtual void WriteDefTag(XamlDefTagNode xamlDefTagNode)
         /// </summary>
         public virtual void WriteDefAttributeKeyType(XamlDefAttributeKeyTypeNode xamlDefNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteDefAttributeKeyType(xamlDefNode);
-            }
+            BamlRecordWriter?.WriteDefAttributeKeyType(xamlDefNode);
         }
 
         /// <summary>
@@ -957,10 +884,7 @@ public virtual void WriteDefAttribute(XamlDefAttributeNode xamlDefAttributeNode)
 
                 case XamlReaderHelper.DefinitionShared:
                     Boolean.Parse(attributeValue);   // For validation only.
-                    if (BamlRecordWriter != null)
-                    {
-                        BamlRecordWriter.WriteDefAttribute(xamlDefAttributeNode);
-                    }
+                    BamlRecordWriter?.WriteDefAttribute(xamlDefAttributeNode);
                     break;
 
                 case XamlReaderHelper.DefinitionUid:
@@ -980,17 +904,11 @@ public virtual void WriteDefAttribute(XamlDefAttributeNode xamlDefAttributeNode)
                         throw parseException;
                     }
 
-                    if (BamlRecordWriter != null)
-                    {
-                        BamlRecordWriter.WriteDefAttribute(xamlDefAttributeNode);
-                    }
+                    BamlRecordWriter?.WriteDefAttribute(xamlDefAttributeNode);
                     break;
 
                 case XamlReaderHelper.DefinitionName:
-                    if (BamlRecordWriter != null)
-                    {
-                        BamlRecordWriter.WriteDefAttribute(xamlDefAttributeNode);
-                    }
+                    BamlRecordWriter?.WriteDefAttribute(xamlDefAttributeNode);
                     break;
 
                 default:
@@ -1009,10 +927,7 @@ public virtual void WriteDefAttribute(XamlDefAttributeNode xamlDefAttributeNode)
         /// </summary>
         public virtual void WritePresentationOptionsAttribute(XamlPresentationOptionsAttributeNode xamlPresentationOptionsAttributeNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WritePresentationOptionsAttribute(xamlPresentationOptionsAttributeNode);
-            }
+            BamlRecordWriter?.WritePresentationOptionsAttribute(xamlPresentationOptionsAttributeNode);
         }
 
         /// <summary>
@@ -1020,18 +935,12 @@ public virtual void WritePresentationOptionsAttribute(XamlPresentationOptionsAtt
         /// </summary>
         public virtual void WriteConstructorParametersStart(XamlConstructorParametersStartNode xamlConstructorParametersStartNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteConstructorParametersStart(xamlConstructorParametersStartNode);
-            }
+            BamlRecordWriter?.WriteConstructorParametersStart(xamlConstructorParametersStartNode);
         }
 
         public virtual void WriteContentProperty(XamlContentPropertyNode xamlContentPropertyNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteContentProperty(xamlContentPropertyNode);
-            }
+            BamlRecordWriter?.WriteContentProperty(xamlContentPropertyNode);
         }
 
         /// <summary>
@@ -1041,10 +950,7 @@ public virtual void WriteContentProperty(XamlContentPropertyNode xamlContentProp
         public virtual void WriteConstructorParameterType(
              XamlConstructorParameterTypeNode xamlConstructorParameterTypeNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteConstructorParameterType(xamlConstructorParameterTypeNode);
-            }
+            BamlRecordWriter?.WriteConstructorParameterType(xamlConstructorParameterTypeNode);
         }
 
         /// <summary>
@@ -1052,10 +958,7 @@ public virtual void WriteContentProperty(XamlContentPropertyNode xamlContentProp
         /// </summary>
         public virtual void WriteConstructorParametersEnd(XamlConstructorParametersEndNode xamlConstructorParametersEndNode)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteConstructorParametersEnd(xamlConstructorParametersEndNode);
-            }
+            BamlRecordWriter?.WriteConstructorParametersEnd(xamlConstructorParametersEndNode);
         }
 
         /// <summary>
@@ -1089,8 +992,7 @@ public virtual void WriteConstructorParametersEnd(XamlConstructorParametersEndNo
             TypeAndSerializer typeAndSerializer =
                 XamlTypeMapper.GetTypeAndSerializer(namespaceUri, localName, null);
 
-            if (typeAndSerializer != null &&
-                typeAndSerializer.ObjectType != null)
+            if (typeAndSerializer?.ObjectType != null)
             {
                 serializerType = typeAndSerializer.SerializerType;
                 baseType = typeAndSerializer.ObjectType;
@@ -1114,10 +1016,7 @@ public virtual void WriteConstructorParametersEnd(XamlConstructorParametersEndNo
         /// </summary>
         protected internal void WriteConnectionId(Int32 connectionId)
         {
-            if (BamlRecordWriter != null)
-            {
-                BamlRecordWriter.WriteConnectionId(connectionId);
-            }
+            BamlRecordWriter?.WriteConnectionId(connectionId);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReader.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReader.cs
index a9ba35f0..478e140c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReader.cs
@@ -393,10 +393,7 @@ private object LoadAsync(XmlReader reader, ParserContext parserContext, bool use
                         }
 
                         UIElement uiElement = args.Instance as UIElement;
-                        if (uiElement != null)
-                        {
-                            uiElement.SetPersistId(_persistId++);
-                        }
+                        uiElement?.SetPersistId(_persistId++);
 
                         DependencyObject dObject = args.Instance as DependencyObject;
                         if (dObject != null && _stack.CurrentFrame.XmlnsDictionary != null)
@@ -1121,10 +1118,7 @@ public static object Load(System.Xaml.XamlReader reader)
                 }
 
                 DependencyObject dObject = root as DependencyObject;
-                if (dObject != null)
-                {
-                    dObject.SetValue(BaseUriHelper.BaseUriProperty, readerSettings.BaseUri);
-                }
+                dObject?.SetValue(BaseUriHelper.BaseUriProperty, readerSettings.BaseUri);
 
                 Application app = root as Application;
                 if (app != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReaderHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReaderHelper.cs
index 4545f6e2..0319e744 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReaderHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlReaderHelper.cs
@@ -3205,9 +3205,8 @@ out elementScopedAttributeFound
                     propertyCanWrite = !((DependencyProperty)dynamicObject).ReadOnly;
                 }
 #endif
-                else if (dynamicObject is MethodInfo)
+                else if (dynamicObject is MethodInfo methodInfo)
                 {
-                    MethodInfo methodInfo = (MethodInfo)dynamicObject;
                     if (methodInfo.GetParameters().Length == 1)
                     {
                         methodInfo = methodInfo.DeclaringType.GetMethod(
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlTypeMapper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlTypeMapper.cs
index d5641775..4d924b7a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlTypeMapper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XamlTypeMapper.cs
@@ -178,10 +178,7 @@ public XamlTypeMapper(string[] assemblyNames)
             _piReverseTable[fullName] = xmlNamespace;
 
             // Add mapping to the SchemaContext
-            if (_schemaContext != null)
-            {
-                _schemaContext.SetMappingProcessingInstruction(xmlNamespace, pair);
-            }
+            _schemaContext?.SetMappingProcessingInstruction(xmlNamespace, pair);
         }
 #endif
         /// <summary>
@@ -1276,7 +1273,14 @@ private bool IsInternalTypeAllowedInFullTrust(Type type)
                 TypeAndSerializer typeAndSerializer =
                     GetTypeOnly(xmlNamespace, globalClassName);
 
+
+/* Unmerged change from project 'PresentationFramework'
+Before:
                 if (typeAndSerializer != null && typeAndSerializer.ObjectType != null)
+After:
+                if (typeAndSerializer?.ObjectType != null)
+*/
+                if (typeAndSerializer?.ObjectType != null)
                 {
                     BamlAttributeInfoRecord infoRecord;
                     Type objectType = typeAndSerializer.ObjectType;
@@ -1416,17 +1420,7 @@ private bool IsInternalTypeAllowedInFullTrust(Type type)
 
                             if (null != memberInfo)
                             {
-                                if (infoRecord != null)
-                                {
-#if !PBTCOMPILER
-                                    // DP's aren't present in the PBT case
-                                    if (infoRecord.DP == null)
-                                    {
-                                        infoRecord.DP = MapTable.GetDependencyProperty(infoRecord);
-                                    }
-#endif
-                                    infoRecord.SetPropertyMember(memberInfo);
-                                }
+                                infoRecord?.SetPropertyMember(memberInfo);
                             }
                         }
                     }
@@ -1560,17 +1554,7 @@ private bool IsInternalTypeAllowedInFullTrust(Type type)
 
                             if (null != memberInfo)
                             {
-                                if (infoRecord != null)
-                                {
-#if !PBTCOMPILER
-                                    // DP's aren't present in the PBT case
-                                    if (infoRecord.DP == null)
-                                    {
-                                        infoRecord.DP = MapTable.GetDependencyProperty(infoRecord);
-                                    }
-#endif
-                                    infoRecord.SetPropertyMember(memberInfo);
-                                }
+                                infoRecord?.SetPropertyMember(memberInfo);
                             }
                         }
                     }
@@ -1666,7 +1650,7 @@ private bool IsInternalTypeAllowedInFullTrust(Type type)
                 TypeAndSerializer typeAndSerializer =
                     GetTypeOnly(xmlNamespace,globalClassName);
 
-                if (typeAndSerializer != null && typeAndSerializer.ObjectType != null)
+                if (typeAndSerializer?.ObjectType != null)
                 {
                     baseType = typeAndSerializer.ObjectType;
                     if (isEvent)
@@ -1861,7 +1845,7 @@ private bool IsInternalTypeAllowedInFullTrust(Type type)
 
                     if ( xmlLangPropertyFound )
                     {
-                        if( xmlLangPropertyName != null && xmlLangPropertyName.Length > 0)
+                        if( !string.IsNullOrEmpty(xmlLangPropertyName))
                         {
                             typeAndSerializer.XmlLangProperty = typeAndSerializer.ObjectType.GetProperty(
                                 xmlLangPropertyName,
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XmlnsDictionary.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XmlnsDictionary.cs
index fcc80e90..1e401fbe 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XmlnsDictionary.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Markup/XmlnsDictionary.cs
@@ -258,8 +258,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <param name="index">The zero-based index in array at which copying begins</param>
         public void CopyTo(Array array, int index)
         {
-            IDictionary dict = GetNamespacesInScope(NamespaceScope.All) as IDictionary;
-            if (dict != null)
+            if (GetNamespacesInScope(NamespaceScope.All) is IDictionary dict)
                 dict.CopyTo(array,index);
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Generated/ThicknessAnimationUsingKeyFrames.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Generated/ThicknessAnimationUsingKeyFrames.cs
index 7afafea6..8747a8bc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Generated/ThicknessAnimationUsingKeyFrames.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Generated/ThicknessAnimationUsingKeyFrames.cs
@@ -230,9 +230,7 @@ void IAddChild.AddChild(object child)
         [EditorBrowsable(EditorBrowsableState.Advanced)]
         protected virtual void AddChild(object child)
         {
-            ThicknessKeyFrame keyFrame = child as ThicknessKeyFrame;
-
-            if (keyFrame != null)
+            if (child is ThicknessKeyFrame keyFrame)
             {
                 KeyFrames.Add(keyFrame);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Storyboard.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Storyboard.cs
index 073e59f1..984b2e03 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Storyboard.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Media/Animation/Storyboard.cs
@@ -245,10 +245,8 @@ public bool Equals(ObjectPropertyPair key)
         object           nameScopeUsed = null;
         object           namedObject = null;
         DependencyObject targetObject = null;
-        FrameworkElement fe = element as FrameworkElement;
-        FrameworkContentElement fce = element as FrameworkContentElement;
 
-        if( fe != null )
+        if( element is FrameworkElement fe )
         {
             if( nameScope != null )
             {
@@ -261,7 +259,7 @@ public bool Equals(ObjectPropertyPair key)
                 nameScopeUsed = fe;
             }
         }
-        else if( fce != null )
+        else if( element is FrameworkContentElement fce )
         {
             Debug.Assert( nameScope == null );
             namedObject = fce.FindName(targetName);
@@ -499,11 +497,9 @@ public bool Equals(ObjectPropertyPair key)
         }
         else
         {
-            // None of the types we recognize as leaf node clock types -
-            //  recursively process child clocks.
-            ClockGroup currentClockGroup = currentClock as ClockGroup;
+            // None of the types we recognize as leaf node clock types -            //  recursively process child clocks.
 
-            if (currentClockGroup != null)
+            if (currentClock is ClockGroup currentClockGroup)
             {
                 ClockCollection childrenClocks = currentClockGroup.Children;
 
@@ -1002,10 +998,8 @@ private void VerifyComplexPathSupport( DependencyObject targetObject )
                 }
             }
 
-            // If the incoming baseValue is a deferred object, we need to get the
-            //  real value to make a valid comparison against the cache entry source.
-            DeferredReference deferredBaseValue = baseValue as DeferredReference;
-            if (deferredBaseValue != null)
+            // If the incoming baseValue is a deferred object, we need to get the            //  real value to make a valid comparison against the cache entry source.
+            if (baseValue is DeferredReference deferredBaseValue)
             {
                 baseValue = deferredBaseValue.GetValue(entry.BaseValueSourceInternal);
                 entry.Value = baseValue;
@@ -1638,10 +1632,7 @@ private void RemoveImpl(DependencyObject containingObject)
         {
             clock.Controller.Remove();
             HybridDictionary clocks = StoryboardClockTreesField.GetValue(containingObject);
-            if (clocks != null)
-            {
-                clocks.Remove(this);
-            }
+            clocks?.Remove(this);
         }
 
         if( TraceAnimation.IsEnabled )
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/Journal.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/Journal.cs
index 12a5398d..44267a6c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/Journal.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/Journal.cs
@@ -478,10 +478,7 @@ internal void PruneKeepAliveEntries()
                     Debug.Assert(je.GetType().IsSerializable);
                     // There can be keep-alive JEs creates for child frames.
                     DataStreams jds = je.JEGroupState.JournalDataStreams;
-                    if (jds != null)
-                    {
-                        jds.PrepareForSerialization();
-                    }
+                    jds?.PrepareForSerialization();
 
                     if (je.RootViewerState != null)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationService.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationService.cs
index 291f360a..d528f440 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationService.cs
@@ -269,7 +269,7 @@ private void NavigateToFragmentOrCustomContentState(Uri uri, object navState)
 
             string fragmentName = uri != null ? BindUriHelper.GetFragment(uri) : null;
             bool hasCustomContentState =
-                destinationEntry != null && destinationEntry.CustomContentState != null;
+destinationEntry?.CustomContentState != null;
             // Note: The assertion earlier implies that CustomContentState can be replayed only
             // for Back or Forward navigations. If this method is called for a New navigation,
             // it is fragment-only.
@@ -408,10 +408,7 @@ private static void BringIntoView(DependencyObject elem)
             else
             {
                 FrameworkContentElement fce = elem as FrameworkContentElement;
-                if (fce != null)
-                {
-                    fce.BringIntoView();
-                }
+                fce?.BringIntoView();
             }
         }
 
@@ -463,10 +460,7 @@ private bool RestoreRootViewerState(CustomJournalStateInternal rvs)
             if (v == null)
                 return false; // Template may not be applied yet.
             IJournalState ijs = v as IJournalState;
-            if (ijs != null)
-            {
-                ijs.RestoreJournalState(rvs);
-            }
+            ijs?.RestoreJournalState(rvs);
             //else: maybe type of viewer changed. Still returning true so that restoring state
             //  is not reattempted in this case.
             return true;
@@ -587,11 +581,7 @@ internal void OnParentNavigationServiceChanged()
             if (newParent == oldParent)
                 return;
 
-            if (oldParent != null)
-            {
-                // Remove from old parent's list
-                oldParent.RemoveChild(this);
-            }
+            oldParent?.RemoveChild(this);
 
             if (newParent != null)
             {
@@ -1085,25 +1075,9 @@ internal void VisualTreeAvailable(Visual v)
         {
             if (!ReferenceEquals(v, _oldRootVisual))
             {
-                if (_oldRootVisual != null)
-                {
-                    // Step 1: Remove the inherited NavigationService property
-                    // This will cause a property invalidation and sub-frames will remove themselves from the parent's list
-                    // That will cause a Journal view update so back/fwd state reflects the state of the new tree
-                    _oldRootVisual.SetValue(NavigationServiceProperty, null);
-                }
+                _oldRootVisual?.SetValue(NavigationServiceProperty, null);
 
-                if (v != null)
-                {
-                    // Step 1: Set the inherited NavigationService property
-                    // This will cause a property invalidation and sub-frames will remove themselves from the parent's list
-                    // That will cause a Journal view update so back/fwd state reflects the state of the new tree
-                    // Note: setting NavigationService has a non-obvious side effect -
-                    // if v has any data-bound properties that use ElementName binding,
-                    // the name will be resolved in the "inner scope", not the "outer
-                    // scope".  (Bug 1765041)
-                    v.SetValue(NavigationServiceProperty, this);
-                }
+                v?.SetValue(NavigationServiceProperty, this);
 
                 _oldRootVisual = v;
             }
@@ -1900,10 +1874,7 @@ private void DoStopLoading(bool clearRecursiveNavigations, bool fireEvents)
                 fireStopped = true;
             }
 
-            if (_navigatorHostImpl != null)
-            {
-                _navigatorHostImpl.OnSourceUpdatedFromNavService(true /* journalOrCancel */);
-            }
+            _navigatorHostImpl?.OnSourceUpdatedFromNavService(true /* journalOrCancel */);
 
             // Event handler exception continuality: if exception occurs in NavigationStopped event handler,
             // we want to finish stopping navigation.
@@ -2072,7 +2043,7 @@ private bool FireNavigating(Uri source, Object bp, Object navState, WebRequest r
             }
 
             CustomContentState customContentState =
-                (navigateInfo != null && navigateInfo.JournalEntry != null) ? navigateInfo.JournalEntry.CustomContentState : null;
+                (navigateInfo?.JournalEntry != null) ? navigateInfo.JournalEntry.CustomContentState : null;
             // do not expose navState if it is NavigateInfo
             object extraData = navigateInfo == null ? navState : null;
             NavigatingCancelEventArgs e = new NavigatingCancelEventArgs(
@@ -2099,10 +2070,7 @@ private bool FireNavigating(Uri source, Object bp, Object navState, WebRequest r
 
             if (e.Cancel)
             {
-                if (JournalScope != null)
-                {
-                    JournalScope.AbortJournalNavigation();
-                }
+                JournalScope?.AbortJournalNavigation();
             }
 
             return (!e.Cancel && !IsDisposed);
@@ -2193,10 +2161,7 @@ private bool HandleNavigating(Uri source, Object content, Object navState, WebRe
 
         private void CleanupAfterNavigationCancelled(NavigateQueueItem localNavigateQueueItem)
         {
-            if (JournalScope != null)
-            {
-                JournalScope.AbortJournalNavigation();
-            }
+            JournalScope?.AbortJournalNavigation();
 
             // If event was canceled then we need to remove it.
             // If the event was canceled AND superceded by StopLoading or Navigate, it won't be
@@ -2205,10 +2170,7 @@ private void CleanupAfterNavigationCancelled(NavigateQueueItem localNavigateQueu
             // and the caller could now proceed with the navigation
             _recursiveNavigateList.Remove(localNavigateQueueItem);
 
-            if (_navigatorHostImpl != null)
-            {
-                _navigatorHostImpl.OnSourceUpdatedFromNavService(true /* journalOrCancel */);
-            }
+            _navigatorHostImpl?.OnSourceUpdatedFromNavService(true /* journalOrCancel */);
 
             // Browser downloading state not reset; case 4.
             InformBrowserAboutStoppedNavigation();
@@ -2278,7 +2240,7 @@ private void HandleNavigated(object navState, bool navigatedToNewContent)
                 handleContentLoadedEvent = !string.IsNullOrEmpty(fragment);
             }
 
-            if (navInfo != null && navInfo.JournalEntry != null) // Was this journal navigation?
+            if (navInfo?.JournalEntry != null) // Was this journal navigation?
             {
                 JournalEntry je = navInfo.JournalEntry;
                 if (je.CustomContentState != null)
@@ -2652,7 +2614,7 @@ private void OnFirstContentLayout()
             if (_journalScope != null)
             {
                 JournalEntry je = _journalScope.Journal.CurrentEntry;
-                if (je != null && je.RootViewerState != null)
+                if (je?.RootViewerState != null)
                 {
                     RestoreRootViewerState(je.RootViewerState);
                     je.RootViewerState = null;
@@ -3650,7 +3612,7 @@ internal void Dispose()
         private NavigationWindow FindNavigationWindow()
         {
             NavigationService ns = this;
-            while (ns != null && ns.INavigatorHost != null)
+            while (ns?.INavigatorHost != null)
             {
                 NavigationWindow nw = ns.INavigatorHost as NavigationWindow;
                 if (nw != null)
@@ -3961,9 +3923,9 @@ private void NavigateToParentPage(PageFunctionBase finishingChildPageFunction, P
             {
                 this.Navigate(parentEntry.Source, pfRetInfo);
             }
-            else if (parentEntry is JournalEntryKeepAlive)
+            else if (parentEntry is JournalEntryKeepAlive journalEntryKeepAlive)
             {
-                object root = ((JournalEntryKeepAlive)parentEntry).KeepAliveRoot;
+                object root = journalEntryKeepAlive.KeepAliveRoot;
                 this.Navigate(root, pfRetInfo);
             }
             else
@@ -4520,10 +4482,7 @@ internal void DisposeElement(Object node)
 
             // Now that we've recursed through all descendants, dispose this node if it needs it
             IDisposable disposable = node as IDisposable;
-            if (disposable != null)
-            {
-                disposable.Dispose();
-            }
+            disposable?.Dispose();
         }
 
         internal DisposeTreeQueueItem(Object node)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationWindow.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationWindow.cs
index 9828885d..27c70192 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationWindow.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Navigation/NavigationWindow.cs
@@ -435,10 +435,7 @@ public override void OnApplyTemplate()
             // Get the root element of the style
             FrameworkElement root = (this.GetVisualChild(0)) as FrameworkElement;
 
-            if (_navigationService != null)
-            {
-                _navigationService.VisualTreeAvailable(root);
-            }
+            _navigationService?.VisualTreeAvailable(root);
 
             // did we just apply the framelet style?
             if ((root != null) && (root.Name == "NavigationBarRoot"))
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPath.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPath.cs
index b08f19ed..e33d667c 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPath.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPath.cs
@@ -509,8 +509,7 @@ void ResolvePathParts(ITypeDescriptorContext typeDescriptorContext)
 
             object context = null;
 
-            TypeConvertContext typeConvertContext = typeDescriptorContext as TypeConvertContext;
-            if( typeConvertContext != null )
+            if( typeDescriptorContext is TypeConvertContext typeConvertContext )
                 context = typeConvertContext.ParserContext;
 
             if (context == null)
@@ -834,11 +833,8 @@ object GetTypedParamValue(string param, Type type, bool throwOnError)
         // Return the type named by the given name
         Type GetTypeFromName(string name, object context)
         {
-            // use the parser context, if available.  This allows early resolution.
-            // bchapman 5/8/2009 - I believe with System.Xaml there is never an old parserContext here.
-            // But cannot be sure.
-            ParserContext parserContext = context as ParserContext;
-            if (parserContext != null)
+            // use the parser context, if available.  This allows early resolution.            // bchapman 5/8/2009 - I believe with System.Xaml there is never an old parserContext here.            // But cannot be sure.
+            if (context is ParserContext parserContext)
             {
                 // Find the namespace prefix
                 string nsPrefix;
@@ -869,17 +865,13 @@ Type GetTypeFromName(string name, object context)
             {
                 if (context is IServiceProvider)
                 {
-
-                    IXamlTypeResolver xtr = (context as IServiceProvider).GetService(typeof(IXamlTypeResolver)) as IXamlTypeResolver;
-
-                    if (xtr != null)
+                    if ((context as IServiceProvider).GetService(typeof(IXamlTypeResolver)) is IXamlTypeResolver xtr)
                     {
                         return xtr.Resolve(name);
                     }
                 }
 
-                IValueSerializerContext serializerContext = context as IValueSerializerContext;
-                if (serializerContext != null)
+                if (context is IValueSerializerContext serializerContext)
                 {
                     ValueSerializer typeSerializer = ValueSerializer.GetSerializerFor(typeof(Type), serializerContext);
                     if (typeSerializer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPathConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPathConverter.cs
index f6655782..3e954109 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPathConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/PropertyPathConverter.cs
@@ -106,9 +106,9 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                 throw new ArgumentNullException("source");
             }
 
-            if (source is string)
+            if (source is string s)
             {
-                return new PropertyPath((string)source, typeDescriptorContext);
+                return new PropertyPath(s, typeDescriptorContext);
             }
 
             #pragma warning suppress 6506 // source is obviously not null
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceDictionary.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceDictionary.cs
index 46fd9744..3a12cc7f 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceDictionary.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceDictionary.cs
@@ -544,8 +544,7 @@ internal Type GetValueType(object key, out bool found)
             {
                 found = true;
 
-                KeyRecord keyRecord = value as KeyRecord;
-                if (keyRecord != null)
+                if (value is KeyRecord keyRecord)
                 {
                     Debug.Assert(_numDefer > 0, "The stream was closed before all deferred content was loaded.");
                     valueType = GetTypeOfFirstObject(keyRecord);
@@ -727,8 +726,7 @@ public bool Contains(object key)
 
             if (result)
             {
-                KeyRecord keyRecord = _baseDictionary[key] as KeyRecord;
-                if (keyRecord != null && _deferredLocationList.Contains(keyRecord))
+                if (_baseDictionary[key] is KeyRecord keyRecord && _deferredLocationList.Contains(keyRecord))
                 {
                     return false;
                 }
@@ -1157,8 +1155,8 @@ private object EvaluateMarkupExtensionNodeList(System.Xaml.XamlReader reader, IS
             System.Xaml.XamlServices.Transform(reader, writer);
 
             object value = writer.Result;
-            MarkupExtension me = value as MarkupExtension;
-            if (me != null)
+
+            if (value is MarkupExtension me)
             {
                 value = me.ProvideValue(serviceProvider);
             }
@@ -1279,16 +1277,14 @@ private void SetOptimizedStaticResources(IList<object> staticResources, IService
                 object keyValue = null;
 
                 // Process OptimizedStaticResource
-                var optimizedStaticResource = staticResources[i] as OptimizedStaticResource;
-                if (optimizedStaticResource != null)
+                if (staticResources[i] is OptimizedStaticResource optimizedStaticResource)
                 {
                     keyValue = optimizedStaticResource.KeyValue;
                 }
                 else
                 {
                     // Process StaticResource  (it holds the NodeList of the StaticResourceExtension)
-                    var staticResource = staticResources[i] as StaticResource;
-                    if (staticResource != null)
+                    if (staticResources[i] is StaticResource staticResource)
                     {
                         // find and evaluate the Key value of the SR in the SR's node stream.
                         keyValue = GetStaticResourceKeyValue(staticResource, serviceProvider);
@@ -1418,11 +1414,9 @@ internal void AddOwner(DispatcherObject owner)
         {
             if (_inheritanceContext == null)
             {
-                // the first owner gets to be the InheritanceContext for
-                // all the values in the dictionary that want one.
-                DependencyObject inheritanceContext = owner as DependencyObject;
+                // the first owner gets to be the InheritanceContext for                // all the values in the dictionary that want one.
 
-                if (inheritanceContext != null)
+                if (owner is DependencyObject inheritanceContext)
                 {
                     _inheritanceContext = new WeakReference(inheritanceContext);
 
@@ -1442,8 +1436,7 @@ internal void AddOwner(DispatcherObject owner)
 
             }
 
-            FrameworkElement fe = owner as FrameworkElement;
-            if (fe != null)
+            if (owner is FrameworkElement fe)
             {
                 if (_ownerFEs == null)
                 {
@@ -1464,8 +1457,7 @@ internal void AddOwner(DispatcherObject owner)
             }
             else
             {
-                FrameworkContentElement fce = owner as FrameworkContentElement;
-                if (fce != null)
+                if (owner is FrameworkContentElement fce)
                 {
                     if (_ownerFCEs == null)
                     {
@@ -1486,8 +1478,7 @@ internal void AddOwner(DispatcherObject owner)
                 }
                 else
                 {
-                    Application app = owner as Application;
-                    if (app != null)
+                    if (owner is Application app)
                     {
                         if (_ownerApps == null)
                         {
@@ -1525,8 +1516,7 @@ internal void AddOwner(DispatcherObject owner)
         // Remove an owner for this dictionary
         internal void RemoveOwner(DispatcherObject owner)
         {
-            FrameworkElement fe = owner as FrameworkElement;
-            if (fe != null)
+            if (owner is FrameworkElement fe)
             {
                 if (_ownerFEs != null)
                 {
@@ -1540,8 +1530,7 @@ internal void RemoveOwner(DispatcherObject owner)
             }
             else
             {
-                FrameworkContentElement fce = owner as FrameworkContentElement;
-                if (fce != null)
+                if (owner is FrameworkContentElement fce)
                 {
                     if (_ownerFCEs != null)
                     {
@@ -1555,8 +1544,7 @@ internal void RemoveOwner(DispatcherObject owner)
                 }
                 else
                 {
-                    Application app = owner as Application;
-                    if (app != null)
+                    if (owner is Application app)
                     {
                         if (_ownerApps != null)
                         {
@@ -1583,22 +1571,19 @@ internal void RemoveOwner(DispatcherObject owner)
         // Check if the given is an owner to this dictionary
         internal bool ContainsOwner(DispatcherObject owner)
         {
-            FrameworkElement fe = owner as FrameworkElement;
-            if (fe != null)
+            if (owner is FrameworkElement fe)
             {
                 return (_ownerFEs != null && _ownerFEs.Contains(fe));
             }
             else
             {
-                FrameworkContentElement fce = owner as FrameworkContentElement;
-                if (fce != null)
+                if (owner is FrameworkContentElement fce)
                 {
                     return (_ownerFCEs != null && _ownerFCEs.Contains(fce));
                 }
                 else
                 {
-                    Application app = owner as Application;
-                    if (app != null)
+                    if (owner is Application app)
                     {
                         return (_ownerApps != null && _ownerApps.Contains(app));
                     }
@@ -1637,8 +1622,7 @@ private void NotifyOwners(ResourcesChangeInfo info)
                 {
                     foreach (Object o in _ownerFEs)
                     {
-                        FrameworkElement fe = o as FrameworkElement;
-                        if (fe != null)
+                        if (o is FrameworkElement fe)
                         {
                             // Set the HasImplicitStyles flag on the owner
                             if (hasImplicitStyles)
@@ -1657,8 +1641,7 @@ private void NotifyOwners(ResourcesChangeInfo info)
                 {
                     foreach (Object o in _ownerFCEs)
                     {
-                        FrameworkContentElement fce = o as FrameworkContentElement;
-                        if (fce != null)
+                        if (o is FrameworkContentElement fce)
                         {
                             // Set the HasImplicitStyles flag on the owner
                             if (hasImplicitStyles)
@@ -1677,8 +1660,7 @@ private void NotifyOwners(ResourcesChangeInfo info)
                 {
                     foreach (Object o in _ownerApps)
                     {
-                        Application app = o as Application;
-                        if (app != null)
+                        if (o is Application app)
                         {
                             // Set the HasImplicitStyles flag on the owner
                             if (hasImplicitStyles)
@@ -1777,9 +1759,7 @@ private void ValidateDeferredResourceReferences(object resourceKey)
             {
                 foreach (Object o in _deferredResourceReferences)
                 {
-
-                    DeferredResourceReference deferredResourceReference = o as DeferredResourceReference;
-                    if (deferredResourceReference != null && (resourceKey == null || Object.Equals(resourceKey, deferredResourceReference.Key)))
+                    if (o is DeferredResourceReference deferredResourceReference && (resourceKey == null || Object.Equals(resourceKey, deferredResourceReference.Key)))
                     {
                         // This will inflate the deferred reference, causing it
                         // to be removed from the list.  The list may also be
@@ -1933,8 +1913,7 @@ private void PropagateParentOwners(ResourceDictionary mergedDictionary)
 
                 foreach (object o in _ownerFEs)
                 {
-                    FrameworkElement fe = o as FrameworkElement;
-                    if (fe != null)
+                    if (o is FrameworkElement fe)
                         mergedDictionary.AddOwner(fe);
                 }
             }
@@ -1950,8 +1929,7 @@ private void PropagateParentOwners(ResourceDictionary mergedDictionary)
 
                 foreach (object o in _ownerFCEs)
                 {
-                    FrameworkContentElement fce = o as FrameworkContentElement;
-                    if (fce != null)
+                    if (o is FrameworkContentElement fce)
                         mergedDictionary.AddOwner(fce);
                 }
             }
@@ -1967,8 +1945,7 @@ private void PropagateParentOwners(ResourceDictionary mergedDictionary)
 
                 foreach (object o in _ownerApps)
                 {
-                    Application app = o as Application;
-                    if (app != null)
+                    if (o is Application app)
                         mergedDictionary.AddOwner(app);
                 }
             }
@@ -2292,11 +2269,8 @@ private void AddInheritanceContext(DependencyObject inheritanceContext, object v
             //        Changes made here will require updates in Freezable.cs
             if (inheritanceContext.ProvideSelfAsInheritanceContext(value, VisualBrush.VisualProperty))
             {
-                // if the assignment was successful, seal the value's InheritanceContext.
-                // This makes sure the resource always gets inheritance-related information
-                // from its point of definition, not from its point of use.
-                DependencyObject doValue = value as DependencyObject;
-                if (doValue != null)
+                // if the assignment was successful, seal the value's InheritanceContext.                // This makes sure the resource always gets inheritance-related information                // from its point of definition, not from its point of use.
+                if (value is DependencyObject doValue)
                 {
                     doValue.IsInheritanceContextSealed = true;
                 }
@@ -2327,10 +2301,9 @@ private void AddInheritanceContextToValues()
         // remove inheritance context from a value, if it came from this dictionary
         private void RemoveInheritanceContext(object value)
         {
-            DependencyObject doValue = value as DependencyObject;
             DependencyObject inheritanceContext = InheritanceContext;
 
-            if (doValue != null && inheritanceContext != null &&
+            if (value is DependencyObject doValue && inheritanceContext != null &&
                 doValue.IsInheritanceContextSealed &&
                 doValue.InheritanceContext == inheritanceContext)
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceReferenceExpression.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceReferenceExpression.cs
index bb4f9812..34cfd892 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceReferenceExpression.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ResourceReferenceExpression.cs
@@ -166,8 +166,8 @@ internal object GetRawValue(DependencyObject d, out object source, DependencyPro
             WriteInternalState(InternalState.HasCachedResourceValue, true);
 
             object effectiveResource = resource;
-            DeferredResourceReference deferredResourceReference = resource as DeferredResourceReference;
-            if (deferredResourceReference != null)
+
+            if (resource is DeferredResourceReference deferredResourceReference)
             {
                 if (deferredResourceReference.IsInflated)
                 {
@@ -264,10 +264,8 @@ private void InvalidateCacheValue()
         {
             object resource = _cachedResourceValue;
 
-            // If the old value was a DeferredResourceReference, it should be
-            // removed from its Dictionary's list to avoid a leak (bug 1624666).
-            DeferredResourceReference deferredResourceReference = _cachedResourceValue as DeferredResourceReference;
-            if (deferredResourceReference != null)
+            // If the old value was a DeferredResourceReference, it should be            // removed from its Dictionary's list to avoid a leak (bug 1624666).
+            if (_cachedResourceValue is DeferredResourceReference deferredResourceReference)
             {
                 if (deferredResourceReference.IsInflated)
                 {
@@ -354,8 +352,7 @@ internal void InvalidateExpressionValue(object sender, EventArgs e)
                 return;
             }
 
-            ResourcesChangedEventArgs args = e as ResourcesChangedEventArgs;
-            if (args != null)
+            if (e is ResourcesChangedEventArgs args)
             {
                 ResourcesChangeInfo info = args.Info;
                 if (!info.IsTreeChange)
@@ -400,11 +397,8 @@ private void ListenForFreezableChanges(object resource)
         {
             if (!ReadInternalState(InternalState.IsListeningForFreezableChanges))
             {
-                // If this value is an unfrozen Freezable object, we need
-                //  to listen to its changed event in order to properly update
-                //  the cache.
-                Freezable resourceAsFreezable = resource as Freezable;
-                if( resourceAsFreezable != null && !resourceAsFreezable.IsFrozen )
+                // If this value is an unfrozen Freezable object, we need                //  to listen to its changed event in order to properly update                //  the cache.
+                if( resource is Freezable resourceAsFreezable && !resourceAsFreezable.IsFrozen )
                 {
                     if (_weakContainerRRE == null)
                     {
@@ -422,13 +416,8 @@ private void StopListeningForFreezableChanges(object resource)
         {
             if (ReadInternalState(InternalState.IsListeningForFreezableChanges))
             {
-                // If the old value was an unfrozen Freezable object, we need
-                //  to stop listening to its changed event.  If the old value wasn't
-                //  frozen (hence we attached an listener) but has been frozen
-                //  since then, the change handler we had attached was already
-                //  discarded during the freeze so we don't care here.
-                Freezable resourceAsFreezable = resource as Freezable;
-                if (resourceAsFreezable != null && _weakContainerRRE != null)
+                // If the old value was an unfrozen Freezable object, we need                //  to stop listening to its changed event.  If the old value wasn't                //  frozen (hence we attached an listener) but has been frozen                //  since then, the change handler we had attached was already                //  discarded during the freeze so we don't care here.
+                if (resource is Freezable resourceAsFreezable && _weakContainerRRE != null)
                 {
                     if (!resourceAsFreezable.IsFrozen)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/JumpList.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/JumpList.cs
index b0d76ecf..01ad4d34 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/JumpList.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/JumpList.cs
@@ -242,11 +242,7 @@ public static void SetJumpList(Application application, JumpList value)
                 }
             }
 
-            if (value != null)
-            {
-                // Changes will only get applied if the list isn't in an ISupportInitialize block.
-                value.ApplyFromApplication();
-            }
+            value?.ApplyFromApplication();
         }
 
         /// <summary>
@@ -698,13 +694,11 @@ private static bool ListContainsShellObject(List<_ShellObjectPair> removedList,
             }
 
             // Casts in .Net don't AddRef.  Don't need to release these.
-            var shellItem = shellObject as IShellItem;
-            if (shellItem != null)
+            if (shellObject is IShellItem shellItem)
             {
                 foreach (var shellMap in removedList)
                 {
-                    var removedItem = shellMap.ShellObject as IShellItem;
-                    if (removedItem != null)
+                    if (shellMap.ShellObject is IShellItem removedItem)
                     {
                         if (0 == shellItem.Compare(removedItem, SICHINT.CANONICAL | SICHINT.TEST_FILESYSPATH_IF_NOT_EQUAL))
                         {
@@ -715,13 +709,11 @@ private static bool ListContainsShellObject(List<_ShellObjectPair> removedList,
                 return false;
             }
 
-            var shellLink = shellObject as IShellLinkW;
-            if (shellLink != null)
+            if (shellObject is IShellLinkW shellLink)
             {
                 foreach (var shellMap in removedList)
                 {
-                    var removedLink = shellMap.ShellObject as IShellLinkW;
-                    if (removedLink != null)
+                    if (shellMap.ShellObject is IShellLinkW removedLink)
                     { 
                         // There's no intrinsic comparison function for ShellLinks.
                         // Talking to the Shell guys, the way they compare these is to catenate a string with
@@ -750,15 +742,12 @@ private static bool ListContainsShellObject(List<_ShellObjectPair> removedList,
         /// </remarks>
         private static object GetShellObjectForJumpItem(JumpItem jumpItem)
         {
-            var jumpPath = jumpItem as JumpPath;
-            var jumpTask = jumpItem as JumpTask;
-
             // Either of these create functions could return null if the item is invalid but they shouldn't throw.
-            if (jumpPath != null)
+            if (jumpItem is JumpPath jumpPath)
             {
                 return CreateItemFromJumpPath(jumpPath);
             }
-            else if (jumpTask != null)
+            else if (jumpItem is JumpTask jumpTask)
             { 
                 return CreateLinkFromJumpTask(jumpTask, true);
             }
@@ -1015,10 +1004,7 @@ private static IShellItem2 CreateItemFromJumpPath(JumpPath jumpPath)
 
         private static JumpItem GetJumpItemForShellObject(object shellObject)
         {
-            var shellItem = shellObject as IShellItem2;
-            var shellLink = shellObject as IShellLinkW;
-
-            if (shellItem != null)
+            if (shellObject is IShellItem2 shellItem)
             {
                 JumpPath path = new JumpPath
                 {
@@ -1027,7 +1013,7 @@ private static JumpItem GetJumpItemForShellObject(object shellObject)
                 return path;
             }
 
-            if (shellLink != null)
+            if (shellObject is IShellLinkW shellLink)
             {
                 var pathBuilder = new StringBuilder(Win32Constant.MAX_PATH);
                 shellLink.GetPath(pathBuilder, pathBuilder.Capacity, null, SLGP.RAWPATH);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/ThumbButtonInfo.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/ThumbButtonInfo.cs
index 49ce7db0..2e9cda87 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/ThumbButtonInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/ThumbButtonInfo.cs
@@ -261,8 +261,7 @@ private void _InvokeCommand()
                 object parameter = CommandParameter;
                 IInputElement target = CommandTarget;
 
-                RoutedCommand routedCommand = command as RoutedCommand;
-                if (routedCommand != null)
+                if (command is RoutedCommand routedCommand)
                 {
                     if (routedCommand.CanExecute(parameter, target))
                     {
@@ -301,8 +300,7 @@ private void UpdateCanExecute()
                 object parameter = CommandParameter;
                 IInputElement target = CommandTarget;
 
-                RoutedCommand routed = Command as RoutedCommand;
-                if (routed != null)
+                if (Command is RoutedCommand routed)
                 {
                     CanExecute = routed.CanExecute(parameter, target);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SourceUriTypeConverterMarkupExtension.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SourceUriTypeConverterMarkupExtension.cs
index a7ff3c36..3baad9eb 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SourceUriTypeConverterMarkupExtension.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SourceUriTypeConverterMarkupExtension.cs
@@ -34,9 +34,9 @@ public SourceUriTypeConverterMarkupExtension(TypeConverter converter, object val
         public override object ProvideValue(IServiceProvider serviceProvider)
         {
             object convertedValue =  base.ProvideValue(serviceProvider);
-            Uri convertedUri = convertedValue as Uri;
+
             
-            if (convertedUri != null)
+            if (convertedValue is Uri convertedUri)
             {
                 Uri appendedVersionUri = BaseUriHelper.AppendAssemblyVersion(convertedUri, _assemblyInfo);
                 if (appendedVersionUri != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StaticResourceExtension.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StaticResourceExtension.cs
index d447afd9..2b214800 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StaticResourceExtension.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StaticResourceExtension.cs
@@ -140,10 +140,8 @@ private object TryProvideValueWithDiagnosticEvent(IServiceProvider serviceProvid
                 // do the lookup - the ResourceDictionary that resolves the reference will fill in the result
                 value = TryProvideValueImpl(serviceProvider, allowDeferredReference, mustReturnDeferredResourceReference);
 
-                // for the purposes of diagnostics, a deferred reference is a success -
-                // we only need the dictionary that holds the value, not the value itself
-                DeferredResourceReference deferredReference = value as DeferredResourceReference;
-                if (deferredReference != null)
+                // for the purposes of diagnostics, a deferred reference is a success -                // we only need the dictionary that holds the value, not the value itself
+                if (value is DeferredResourceReference deferredReference)
                 {
                     success = true;
                     ResourceDictionary dict = deferredReference.Dictionary;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Style.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Style.cs
index 42cd3768..5cadd6ac 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Style.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Style.cs
@@ -530,26 +530,17 @@ public void Seal()
             }
 
             // Seal setters
-            if (_setters != null)
-            {
-                _setters.Seal();
-            }
+            _setters?.Seal();
 
             // Seal triggers
-            if (_visualTriggers != null)
-            {
-                _visualTriggers.Seal();
-            }
+            _visualTriggers?.Seal();
 
             // Will throw InvalidOperationException if we find a loop of
             //  BasedOn references.  (A.BasedOn = B, B.BasedOn = C, C.BasedOn = A)
             CheckForCircularBasedOnReferences();
 
             // Seal BasedOn Style chain
-            if (_basedOn != null)
-            {
-                _basedOn.Seal();
-            }
+            _basedOn?.Seal();
 
             // Seal the ResourceDictionary
             if (_resources != null)
@@ -658,10 +649,8 @@ private void ProcessSetters(Style style)
                 SetterBase setterBase = style.Setters[i];
                 Debug.Assert(setterBase != null, "Setter collection must contain non-null instances of SetterBase");
 
-                // Setters are folded into the PropertyValues table only for the current style. The
-                // processing of BasedOn Style properties will occur in subsequent call to ProcessSelfStyle
-                Setter setter = setterBase as Setter;
-                if (setter != null)
+                // Setters are folded into the PropertyValues table only for the current style. The                // processing of BasedOn Style properties will occur in subsequent call to ProcessSelfStyle
+                if (setterBase is Setter setter)
                 {
                     // Style Setters are not allowed to have a child target name - since there are no child nodes in a Style.
                     if( setter.TargetName != null )
@@ -829,8 +818,7 @@ private void ProcessVisualTriggers(Style style)
                     }
 
                     // Set things up to handle EventTrigger
-                    EventTrigger eventTrigger = trigger as EventTrigger;
-                    if( eventTrigger != null )
+                    if( trigger is EventTrigger eventTrigger )
                     {
                         if( eventTrigger.SourceName != null && eventTrigger.SourceName.Length > 0 )
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StyleHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StyleHelper.cs
index 96d96013..4f2f42f6 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StyleHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/StyleHelper.cs
@@ -218,7 +218,7 @@ internal static Style GetThemeStyle(FrameworkElement fe, FrameworkContentElement
 
                 // First look for an applicable style in system resources
                 object styleLookup;
-                if (dTypeKey != null && dTypeKey.SystemType != null && dTypeKey.SystemType.Equals(themeStyleKey))
+                if (dTypeKey?.SystemType != null && dTypeKey.SystemType.Equals(themeStyleKey))
                 {
                     // Optimized lookup based on the DependencyObjectType for the DefaultStyleKey
                     styleLookup = SystemResources.FindThemeStyle(dTypeKey);
@@ -231,11 +231,11 @@ internal static Style GetThemeStyle(FrameworkElement fe, FrameworkContentElement
 
                 if( styleLookup != null )
                 {
-                    if( styleLookup is Style )
+                    if( styleLookup is Style style)
                     {
                         // We have found an applicable Style in system resources
                         //  let's us use that as second stop to find property values.
-                        newThemeStyle = (Style)styleLookup;
+                        newThemeStyle = style;
                     }
                     else
                     {
@@ -370,10 +370,7 @@ internal static Style GetThemeStyle(FrameworkElement fe, FrameworkContentElement
             // Seal template nodes (if exists)
 
 
-            if (frameworkTemplate != null)
-            {
-                frameworkTemplate.ProcessTemplateBeforeSeal();
-            }
+            frameworkTemplate?.ProcessTemplateBeforeSeal();
 
 
             if (templateRoot != null)
@@ -388,10 +385,7 @@ internal static Style GetThemeStyle(FrameworkElement fe, FrameworkContentElement
             }
 
             // Seal triggers
-            if (triggers != null)
-            {
-                triggers.Seal();
-            }
+            triggers?.Seal();
 
             // Seal Resource Dictionary
             if (resources != null)
@@ -2169,10 +2163,7 @@ internal static void AddCustomTemplateRoot( FrameworkElement container, UIElemen
             }
 
             // Clear the NameMap property on the root of the generated subtree
-            if (rootNode != null)
-            {
-                rootNode.ClearValue(NameScope.NameScopeProperty);
-            }
+            rootNode?.ClearValue(NameScope.NameScopeProperty);
 
             // Detach the generated tree from the conatiner
             DetachGeneratedSubTree(feContainer, fceContainer);
@@ -2426,20 +2417,20 @@ private static void ExecuteEventTriggerActionsOnContainer (object sender, Routed
             }
 
             // Invoke trigger actions on selfStyle
-            if (selfStyle != null && selfStyle.EventHandlersStore != null)
+            if (selfStyle?.EventHandlersStore != null)
             {
                 InvokeEventTriggerActions(fe, fce, selfStyle, null, 0, e.RoutedEvent);
             }
 
             // Invoke trigger actions on theme style
-            if (selfThemeStyle != null && selfThemeStyle.EventHandlersStore != null)
+            if (selfThemeStyle?.EventHandlersStore != null)
             {
                 InvokeEventTriggerActions(fe, fce, selfThemeStyle, null, 0, e.RoutedEvent);
             }
 
 
             // Invokte trigger actions on the template or table template.
-            if (selfFrameworkTemplate != null && selfFrameworkTemplate.EventHandlersStore != null)
+            if (selfFrameworkTemplate?.EventHandlersStore != null)
             {
                 InvokeEventTriggerActions(fe, fce, null /*style*/, selfFrameworkTemplate, 0, e.RoutedEvent);
             }
@@ -2983,10 +2974,7 @@ private static void ExecuteEventTriggerActionsOnChild (object sender, RoutedEven
                 {
                     expr = value as Expression;
                     // if the instance value is an expression, attach it
-                    if (expr != null)
-                    {
-                        expr.OnAttach(child, dp);
-                    }
+                    expr?.OnAttach(child, dp);
                 }
             }
 
@@ -3577,9 +3565,9 @@ private static List<ResourceDictionary> GetResourceDictionaryFromTemplate( objec
         {
             ResourceDictionary resources = null;
 
-            if( template is FrameworkTemplate )
+            if( template is FrameworkTemplate frameworkTemplate)
             {
-                resources = ((FrameworkTemplate)template)._resources;
+                resources = frameworkTemplate._resources;
             }
 
             if (resources != null)
@@ -4801,7 +4789,7 @@ private static bool NoSourceNameInTrigger( TriggerBase triggerBase )
             FrameworkTemplate frameworkTemplate )
         {
             // See if we have a list of deferred actions to execute.
-            if (frameworkTemplate != null && frameworkTemplate.DeferredActions != null)
+            if (frameworkTemplate?.DeferredActions != null)
             {
                 List<DeferredAction> actionList;
                 if (frameworkTemplate.DeferredActions.TryGetValue(triggerContainer, out actionList))
@@ -5770,10 +5758,8 @@ internal struct ChildValueLookup
         //  Trading off an object boxing cost in exchange for avoiding reflection cost.
         public override bool Equals( object value )
         {
-            if( value is ChildValueLookup )
+            if( value is ChildValueLookup other)
             {
-                ChildValueLookup other = (ChildValueLookup)value;
-
                 if( LookupType      == other.LookupType &&
                     Property        == other.Property &&
                     Value           == other.Value )
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemKeyConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemKeyConverter.cs
index dd0c39f9..b6f3cb57 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemKeyConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemKeyConverter.cs
@@ -149,8 +149,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 Type keyType = SystemKeyConverter.GetSystemClassType(keyId);
 
                 // Get the value serialization context
-                IValueSerializerContext valueSerializerContext = context as IValueSerializerContext;
-                if( valueSerializerContext != null )
+                if( context is IValueSerializerContext valueSerializerContext )
                 {
                     // And from that get a System.Type serializer
                     ValueSerializer typeSerializer = valueSerializerContext.GetValueSerializerFor(typeof(Type));
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResourceKey.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResourceKey.cs
index f4231a30..df430eef 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResourceKey.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResourceKey.cs
@@ -1864,7 +1864,7 @@ internal SystemResourceKey(SystemResourceKeyID id)
                 ((SystemResourceKeyID.InternalSystemFontsStart < id) && (id < SystemResourceKeyID.InternalSystemFontsEnd)) ||
                 ((SystemResourceKeyID.InternalSystemParametersStart < id) && (id < SystemResourceKeyID.InternalSystemParametersEnd)) ||
                 ((SystemResourceKeyID.InternalSystemColorsExtendedStart < id) && (id < SystemResourceKeyID.InternalSystemColorsExtendedEnd)),
-                String.Format("Invalid SystemResourceKeyID (id={0})", (int)id));
+                $"Invalid SystemResourceKeyID (id={(int)id})");
             _id = id;
         }
 
@@ -1895,9 +1895,7 @@ public override Assembly Assembly
         /// <returns>True if the objects are equal. False otherwise.</returns>
         public override bool Equals(object o)
         {
-            SystemResourceKey key = o as SystemResourceKey;
-
-            if (key != null)
+            if (o is SystemResourceKey key)
             {
                 return (key._id == this._id);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResources.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResources.cs
index 1bc74098..eede7487 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResources.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemResources.cs
@@ -316,11 +316,7 @@ private static bool FindCachedResource(object key, ref object resource, bool mus
             else
             {
                 DispatcherObject dispatcherObject = resource as DispatcherObject;
-                if (dispatcherObject != null)
-                {
-                    // The current thread may not have access to this object.
-                    dispatcherObject.VerifyAccess();
-                }
+                dispatcherObject?.VerifyAccess();
             }
 
             if (found && mustReturnDeferredResourceReference)
@@ -442,8 +438,7 @@ private static bool FindCachedResource(object key, ref object resource, bool mus
         /// <param name="resource">The resource to freeze.</param>
         private static void Freeze(object resource)
         {
-            Freezable freezable = resource as Freezable;
-            if (freezable != null && !freezable.IsFrozen)
+            if (resource is Freezable freezable && !freezable.IsFrozen)
             {
                 freezable.Freeze();
             }
@@ -956,7 +951,7 @@ private ResourceDictionary LoadDictionary(Assembly assembly, string assemblyName
 
                         AssemblyName asemblyName = new AssemblyName(assembly.FullName);
                         Uri streamUri = null;
-                        string packUri = string.Format("pack://application:,,,/{0};v{1};component/{2}", asemblyName.Name, asemblyName.Version.ToString(), resourceName);
+                        string packUri = $"pack://application:,,,/{asemblyName.Name};v{asemblyName.Version.ToString()};component/{resourceName}";
                         if (Uri.TryCreate(packUri, UriKind.Absolute, out streamUri))
                         {
                             if (XamlSourceInfoHelper.IsXamlSourceInfoEnabled)
@@ -1230,8 +1225,7 @@ private static void OnSystemValueChanged()
 
                 foreach (object key in _resourceCache.Keys)
                 {
-                    SystemResourceKey resKey = key as SystemResourceKey;
-                    if (resKey != null)
+                    if (key is SystemResourceKey resKey)
                     {
                         keys.Add(resKey);
                     }
@@ -1253,8 +1247,7 @@ private static object InvalidateTreeResources(Object args)
             PresentationSource source = (PresentationSource)argsArray[0];
             if (!source.IsDisposed)
             {
-                FrameworkElement fe = source.RootVisual as FrameworkElement;
-                if (fe != null)
+                if (source.RootVisual is FrameworkElement fe)
                 {
                     bool isSysColorsOrSettingsChange = (bool)argsArray[1];
                     if (isSysColorsOrSettingsChange)
@@ -1278,7 +1271,7 @@ private static object InvalidateTreeResources(Object args)
                     SystemResourcesAreChanging = false;
 
                     PopupRoot popupRoot = fe as PopupRoot;
-                    if (popupRoot != null && popupRoot.Parent != null)
+                    if (popupRoot?.Parent != null)
                     {
                         popupRoot.Parent.CoerceValue(Popup.HasDropShadowProperty);
                     }
@@ -1816,10 +1809,7 @@ internal virtual void RemoveInflatedListener(ResourceReferenceExpression listene
         {
             Debug.Assert(_inflatedList != null);
 
-            if (_inflatedList != null)
-            {
-                _inflatedList.Remove(listener);
-            }
+            _inflatedList?.Remove(listener);
         }
 
         #endregion Methods
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemThemeKey.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemThemeKey.cs
index c4273e02..6fe68284 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemThemeKey.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/SystemThemeKey.cs
@@ -57,9 +57,7 @@ public override Assembly Assembly
         /// <returns>True if the objects are equal. False otherwise.</returns>
         public override bool Equals(object o)
         {
-            SystemThemeKey key = o as SystemThemeKey;
-
-            if (key != null)
+            if (o is SystemThemeKey key)
             {
                 return key._id == this._id;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateContent.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateContent.cs
index 9ebee259..feb4b855 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateContent.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateContent.cs
@@ -374,10 +374,7 @@ private void UpdateSharedPropertyNames(string name, List<PropertyValue> sharedPr
 
             while (reader.Read())
             {
-                if (lineInfoConsumer != null)
-                {
-                    lineInfoConsumer.SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
-                }
+                lineInfoConsumer?.SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
 
                 object newValue;
                 bool reProcessOnApply = ParseNode(reader, stack, sharedProperties, ref nameNumber, out newValue);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateKey.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateKey.cs
index fa835d65..b8d622b1 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateKey.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateKey.cs
@@ -105,8 +105,7 @@ public override int GetHashCode()
         /// <summary> Override of Object.Equals() </summary>
         public override bool Equals(object o)
         {
-            TemplateKey key = o as TemplateKey;
-            if (key != null)
+            if (o is TemplateKey key)
             {
                 return  _templateType == key._templateType &&
                         Object.Equals(_dataType, key._dataType);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateNameScope.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateNameScope.cs
index 679d9774..f85fe2a5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateNameScope.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TemplateNameScope.cs
@@ -169,10 +169,7 @@ internal void RegisterNameInternal(string name, object scopedElement)
 
                 HybridDictionary templateChildLoadedDictionary = _frameworkTemplate._TemplateChildLoadedDictionary;
 
-                FrameworkTemplate.TemplateChildLoadedFlags templateChildLoadedFlags
-                        = templateChildLoadedDictionary[ childIndex ] as FrameworkTemplate.TemplateChildLoadedFlags;
-
-                if( templateChildLoadedFlags != null )
+                if( templateChildLoadedDictionary[childIndex] is FrameworkTemplate.TemplateChildLoadedFlags templateChildLoadedFlags )
                 {
                     if( templateChildLoadedFlags.HasLoadedChangedHandler || templateChildLoadedFlags.HasUnloadedChangedHandler )
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Thickness.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Thickness.cs
index a821b64b..be94a335 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Thickness.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Thickness.cs
@@ -70,9 +70,8 @@ public Thickness(double left, double top, double right, double bottom)
         /// <returns>True if object is a Thickness and all sides of it are equal to this Thickness'.</returns>
         public override bool Equals(object obj)
         {
-            if (obj is Thickness)
+            if (obj is Thickness otherObj)
             {
-                Thickness otherObj = (Thickness)obj;
                 return (this == otherObj);
             }
             return (false);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ThicknessConverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ThicknessConverter.cs
index 70c9bbe3..6d433a45 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ThicknessConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/ThicknessConverter.cs
@@ -104,8 +104,8 @@ public override object ConvertFrom(ITypeDescriptorContext typeDescriptorContext,
         {
             if (source != null)
             {
-                if (source is string)      { return FromString((string)source, cultureInfo); }
-                else if (source is double) { return new Thickness((double)source); }
+                if (source is string s)      { return FromString(s, cultureInfo); }
+                else if (source is double d) { return new Thickness(d); }
                 else                       { return new Thickness(Convert.ToDouble(source, cultureInfo)); }
             }
             throw GetConvertFromException(source);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TreeWalkHelper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TreeWalkHelper.cs
index a109668b..b77df7e0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TreeWalkHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TreeWalkHelper.cs
@@ -546,10 +546,7 @@ internal static class TreeWalkHelper
                 if (info.IsImplicitDataTemplateChange)
                 {
                     ContentPresenter contentPresenter = fe as ContentPresenter;
-                    if (contentPresenter != null)
-                    {
-                        contentPresenter.ReevaluateTemplate();
-                    }
+                    contentPresenter?.ReevaluateTemplate();
                 }
 
                 if (fe.HasResourceReference)
@@ -701,8 +698,7 @@ internal static class TreeWalkHelper
                 while (localValues.MoveNext())
                 {
                     // Is this a resource reference?
-                    ResourceReferenceExpression resource = localValues.Current.Value as ResourceReferenceExpression;
-                    if (resource != null)
+                    if (localValues.Current.Value is ResourceReferenceExpression resource)
                     {
                         // Record this property if it is referring
                         // to a resource that is being changed
@@ -1120,10 +1116,9 @@ internal static class TreeWalkHelper
             inheritanceBehavior = InheritanceBehavior.Default;
 
             // Get Framework metadata (if exists)
-            FrameworkPropertyMetadata metadata = dp.GetMetadata(d.DependencyObjectType) as FrameworkPropertyMetadata;
 
             // Check for correct type of metadata
-            if (metadata != null)
+            if (dp.GetMetadata(d.DependencyObjectType) is FrameworkPropertyMetadata metadata)
             {
                 FrameworkObject fo = new FrameworkObject(d);
 
@@ -1172,10 +1167,9 @@ internal static class TreeWalkHelper
             inheritanceBehavior = InheritanceBehavior.Default;
 
             // Get Framework metadata (if exists)
-            FrameworkPropertyMetadata metadata = dp.GetMetadata(fe.DependencyObjectType) as FrameworkPropertyMetadata;
 
             // Check for correct type of metadata
-            if (metadata != null)
+            if (dp.GetMetadata(fe.DependencyObjectType) is FrameworkPropertyMetadata metadata)
             {
                 if (fe.InheritanceBehavior != InheritanceBehavior.Default && !metadata.OverridesInheritanceBehavior)
                 {
@@ -1203,10 +1197,9 @@ internal static class TreeWalkHelper
             inheritanceBehavior = InheritanceBehavior.Default;
 
             // Get Framework metadata (if exists)
-            FrameworkPropertyMetadata metadata = dp.GetMetadata(fce.DependencyObjectType) as FrameworkPropertyMetadata;
 
             // Check for correct type of metadata
-            if (metadata != null)
+            if (dp.GetMetadata(fce.DependencyObjectType) is FrameworkPropertyMetadata metadata)
             {
                 if (fce.InheritanceBehavior != InheritanceBehavior.Default && !metadata.OverridesInheritanceBehavior)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TriggerBase.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TriggerBase.cs
index d528226f..e469d55a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TriggerBase.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/TriggerBase.cs
@@ -256,14 +256,8 @@ internal override void Seal()
                 }
             }
 
-            if( _enterActions != null )
-            {
-                _enterActions.Seal(this);
-            }
-            if( _exitActions != null )
-            {
-                _exitActions.Seal(this);
-            }
+            _enterActions?.Seal(this);
+            _exitActions?.Seal(this);
 
             // Remove thread affinity so it can be accessed across threads
             DetachFromDispatcher();
@@ -280,8 +274,7 @@ internal void ProcessSettersCollection(SetterBaseCollection setters)
 
                 for (int i = 0; i < setters.Count; i++ )
                 {
-                    Setter setter = setters[i] as Setter;
-                    if( setter != null )
+                    if( setters[i] is Setter setter )
                     {
                         DependencyProperty dp = setter.Property;
                         object value          = setter.ValueInternal;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/VisualStateManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/VisualStateManager.cs
index 7824e910..228c3fe2 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/VisualStateManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/VisualStateManager.cs
@@ -247,7 +247,7 @@ private static bool GoToStateInternal(FrameworkElement control, FrameworkElement
                                             (transition.Storyboard == null || transition.Storyboard.Duration == DurationZero)))
             {
                 // Start new state Storyboard and stop any previously running Storyboards
-                if (transition != null && transition.Storyboard != null)
+                if (transition?.Storyboard != null)
                 {
                     group.StartNewThenStopOld(stateGroupsRoot, transition.Storyboard, state.Storyboard);
                 }
@@ -647,14 +647,12 @@ internal static VisualTransition GetTransition(FrameworkElement element, VisualS
         // animation we're generating.
         private static Color? GetTargetColor(Timeline timeline, bool isEntering)
         {
-            ColorAnimation ca = timeline as ColorAnimation;
-            if (ca != null)
+            if (timeline is ColorAnimation ca)
             {
                 return ca.From.HasValue ? ca.From : ca.To;
             }
 
-            ColorAnimationUsingKeyFrames cak = timeline as ColorAnimationUsingKeyFrames;
-            if (cak != null)
+            if (timeline is ColorAnimationUsingKeyFrames cak)
             {
                 if (cak.KeyFrames.Count == 0)
                 {
@@ -670,14 +668,12 @@ internal static VisualTransition GetTransition(FrameworkElement element, VisualS
 
         private static double? GetTargetDouble(Timeline timeline, bool isEntering)
         {
-            DoubleAnimation da = timeline as DoubleAnimation;
-            if (da != null)
+            if (timeline is DoubleAnimation da)
             {
                 return da.From.HasValue ? da.From : da.To;
             }
 
-            DoubleAnimationUsingKeyFrames dak = timeline as DoubleAnimationUsingKeyFrames;
-            if (dak != null)
+            if (timeline is DoubleAnimationUsingKeyFrames dak)
             {
                 if (dak.KeyFrames.Count == 0)
                 {
@@ -693,14 +689,12 @@ internal static VisualTransition GetTransition(FrameworkElement element, VisualS
 
         private static Point? GetTargetPoint(Timeline timeline, bool isEntering)
         {
-            PointAnimation pa = timeline as PointAnimation;
-            if (pa != null)
+            if (timeline is PointAnimation pa)
             {
                 return pa.From.HasValue ? pa.From : pa.To;
             }
 
-            PointAnimationUsingKeyFrames pak = timeline as PointAnimationUsingKeyFrames;
-            if (pak != null)
+            if (timeline is PointAnimationUsingKeyFrames pak)
             {
                 if (pak.KeyFrames.Count == 0)
                 {
@@ -752,8 +746,8 @@ private static void FlattenTimelines(Storyboard storyboard, Dictionary<TimelineD
             for (int index = 0; index < storyboard.Children.Count; ++index)
             {
                 Timeline child = storyboard.Children[index];
-                Storyboard childStoryboard = child as Storyboard;
-                if (childStoryboard != null)
+
+                if (child is Storyboard childStoryboard)
                 {
                     FlattenTimelines(childStoryboard, result);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Window.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Window.cs
index d15232b2..dc97d3e0 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Window.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Window.cs
@@ -1803,8 +1803,7 @@ protected override Size ArrangeOverride(Size arrangeBounds)
 
             if (this.VisualChildrenCount > 0)
             {
-                UIElement child = this.GetVisualChild(0) as UIElement;
-                if (child != null)
+                if (this.GetVisualChild(0) is UIElement child)
                 {
                     // Find out the size of the window frame x.
                     // (constraint - x) is the size we pass onto
@@ -2013,13 +2012,10 @@ protected virtual void OnContentRendered(EventArgs e)
         {
             VerifyContextAndObjectState();
 
-            // After the content is rendered we want to check if there is an element that needs to be focused
-            // If there is - set focus to it
-            DependencyObject doContent = Content as DependencyObject;
-            if (doContent != null)
+            // After the content is rendered we want to check if there is an element that needs to be focused            // If there is - set focus to it
+            if (Content is DependencyObject doContent)
             {
-                IInputElement focusedElement = FocusManager.GetFocusedElement(doContent) as IInputElement;
-                if (focusedElement != null)
+                if (FocusManager.GetFocusedElement(doContent) is IInputElement focusedElement)
                     focusedElement.Focus();
             }
 
@@ -3234,8 +3230,7 @@ private Size MeasureOverrideHelper(Size constraint)
 
             if (this.VisualChildrenCount > 0)
             {
-                UIElement child = this.GetVisualChild(0) as UIElement;
-                if (child != null) // UIElement children
+                if (this.GetVisualChild(0) is UIElement child) // UIElement children
                 {
                     // Find out the size of the window frame x.
                     // (constraint - x) is the size we pass onto
@@ -3366,12 +3361,7 @@ private void PostContentRendered()
         {
             // Post the firing of ContentRendered as Input priority work item so
             // that ContentRendered will be fired after render query empties.
-            if (_contentRenderedCallback != null)
-            {
-                // Content was changed again before the previous rendering completed (or at least
-                // before the Dispatcher got to Input priority callbacks).
-                _contentRenderedCallback.Abort();
-            }
+            _contentRenderedCallback?.Abort();
             _contentRenderedCallback = Dispatcher.BeginInvoke(DispatcherPriority.Input,
                                    (DispatcherOperationCallback) delegate (object unused)
                                    {
@@ -4114,10 +4104,7 @@ private void OnSourceWindowDisposed(object sender, EventArgs e)
                 {
                     // Either Explorer's created a new button or it's time to try again.
                     // Stop deferring updates to the Taskbar.
-                    if (_taskbarRetryTimer != null)
-                    {
-                        _taskbarRetryTimer.Stop();
-                    }
+                    _taskbarRetryTimer?.Stop();
 
                     // We'll receive WM_TASKBARBUTTONCREATED at times other than when the Window was created,
                     //    e.g. Explorer restarting, in response to ShowInTaskbar=true, etc.
@@ -4663,10 +4650,7 @@ private bool WmMoveChanged()
                 //This will schedule a deferred update of bounding rectangle and
                 //corresponding notification to the Automation layer.
                 AutomationPeer peer = UIElementAutomationPeer.FromElement(this);
-                if(peer != null)
-                {
-                    peer.InvalidatePeer();
-                }
+                peer?.InvalidatePeer();
 }
 
             return false;
@@ -5803,7 +5787,7 @@ private void UpdateHwndRestoreBounds(double newValue, BoundsSpecified specifiedR
                     wp.rcNormalPosition_right = wp.rcNormalPosition_left + currentWidth;
                     break;
                 default:
-                    Debug.Assert(false, String.Format("specifiedRestoreBounds can't be {0}", specifiedRestoreBounds));
+                    Debug.Assert(false, $"specifiedRestoreBounds can't be {specifiedRestoreBounds}");
                     break;
             }
 
@@ -6709,10 +6693,7 @@ internal void Flush()
         }
         private void ClearRootVisual()
         {
-            if (_swh != null)
-            {
-                _swh.ClearRootVisual();
-            }
+            _swh?.ClearRootVisual();
         }
 
 
@@ -6882,23 +6863,13 @@ protected override void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedb
         private static void OnStaticManipulationInertiaStarting(object sender, ManipulationInertiaStartingEventArgs e)
         {
             Window window = sender as Window;
-            if (window != null)
-            {
-                // Transitioning from direct manipulation to inertia, animate the window
-                // back to its original position.
-                window.EndPanningFeedback(true);
-            }
+            window?.EndPanningFeedback(true);
         }
 
         private static void OnStaticManipulationCompleted(object sender, ManipulationCompletedEventArgs e)
         {
             Window window = sender as Window;
-            if (window != null)
-            {
-                // A complete was encountered. If this was a forced complete, snap the window
-                // back to its original position.
-                window.EndPanningFeedback(false);
-            }
+            window?.EndPanningFeedback(false);
         }
 
         /// <summary>
@@ -6935,11 +6906,7 @@ private void UpdatePanningFeedback(Vector totalOverpanOffset, object originalSou
         /// </summary>
         private void EndPanningFeedback(bool animateBack)
         {
-            if (_swh != null)
-            {
-                // Restore the window to its original position
-                _swh.EndPanningFeedback(animateBack);
-            }
+            _swh?.EndPanningFeedback(animateBack);
             _currentPanningTarget = null;
             _prePanningLocation = new Point(double.NaN, double.NaN);
         }
@@ -7476,11 +7443,7 @@ internal void UpdatePanningFeedback(Vector totalOverpanOffset, bool animate)
                         _panningFeedback = new HwndPanningFeedback(_sourceWindow);
                     }
 
-                    if (_panningFeedback != null)
-                    {
-                        // Update the window position
-                        _panningFeedback.UpdatePanningFeedback(totalOverpanOffset, animate);
-                    }
+                    _panningFeedback?.UpdatePanningFeedback(totalOverpanOffset, animate);
                 }
 
                 /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelength.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelength.cs
index 496c6fdd..ce94042a 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelength.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelength.cs
@@ -181,9 +181,8 @@ public FigureLength(double value, FigureUnitType type)
         /// and unit type as oCompare.</returns>
         override public bool Equals(object oCompare)
         {
-            if(oCompare is FigureLength)
+            if(oCompare is FigureLength l)
             {
-                FigureLength l = (FigureLength)oCompare;
                 return (this == l);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelengthconverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelengthconverter.cs
index e6e3a420..c632591d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelengthconverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/figurelengthconverter.cs
@@ -112,9 +112,9 @@ public class FigureLengthConverter: TypeConverter
         {
             if (source != null)
             {
-                if (source is string)
+                if (source is string s)
                 {
-                    return (FromString((string)source, cultureInfo));
+                    return (FromString(s, cultureInfo));
                 }
                 else
                 {
@@ -152,11 +152,8 @@ public class FigureLengthConverter: TypeConverter
                 throw new ArgumentNullException("destinationType");
             }
 
-            if (    value != null
-                &&  value is FigureLength )
+            if (    value is FigureLength fl)
             {
-                FigureLength fl = (FigureLength)value;
-
                 if (destinationType == typeof(string)) 
                 { 
                     return (ToString(fl, cultureInfo)); 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/lengthconverter.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/lengthconverter.cs
index b15380c5..b6c5fbfa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/lengthconverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/lengthconverter.cs
@@ -112,7 +112,7 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
         {
             if (source != null)
             {
-                if (source is string) { return FromString((string)source, cultureInfo); }
+                if (source is string s) { return FromString(s, cultureInfo); }
                 else                  { return (double)(Convert.ToDouble(source, cultureInfo)); }
             }
 
@@ -146,10 +146,8 @@ public override bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext,
                 throw new ArgumentNullException("destinationType");
             }
 
-            if (    value != null
-                &&  value is double )
+            if (    value is double l)
             {
-                double l = (double)value;
                 if (destinationType == typeof(string)) 
                 { 
                     if(DoubleUtil.IsNaN(l)) 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/localization.cs b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/localization.cs
index 13bd052f..41066e8e 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/localization.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/localization.cs
@@ -112,8 +112,7 @@ public static void SetAttributes(object element, string attributes)
 
         private static string GetValue(object element, DependencyProperty property)
         {
-            DependencyObject dependencyObject = element as DependencyObject;
-            if (dependencyObject != null)
+            if (element is DependencyObject dependencyObject)
             {
                 // For DO, get the value from the property system
                 return (string) dependencyObject.GetValue(property);
@@ -136,8 +135,7 @@ private static string GetValue(object element, DependencyProperty property)
 
         private static void SetValue(object element, DependencyProperty property, string value)
         {
-            DependencyObject dependencyObject = element as DependencyObject;
-            if (dependencyObject != null)
+            if (element is DependencyObject dependencyObject)
             {
                 // For DO, store the value in the property system
                 dependencyObject.SetValue(property, value);
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/InstallationError.xaml.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/InstallationError.xaml.cs
index c9e5b829..9c03ce47 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/InstallationError.xaml.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/InstallationError.xaml.cs
@@ -190,7 +190,7 @@ private void ShowLogFileButton()
         static void OnCommandRefresh(object sender, RoutedEventArgs e)
         {
             InstallationErrorPage page = sender as InstallationErrorPage;
-            if (page != null && page.RefreshCallback != null)
+            if (page?.RefreshCallback != null)
             {
                 page.RefreshCallback(null);
             }
@@ -198,8 +198,7 @@ static void OnCommandRefresh(object sender, RoutedEventArgs e)
 
         static void OnCanRefresh(object sender, CanExecuteRoutedEventArgs e)
         {
-            InstallationErrorPage page = sender as InstallationErrorPage;
-            if (page != null)
+            if (sender is InstallationErrorPage page)
             {
                 e.CanExecute = true;
                 e.Handled = true;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentManager.cs
index af4790dd..851b5440 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentManager.cs
@@ -133,10 +133,7 @@ internal static void CleanUp()
         {
             IDisposable disposable = controller as IDisposable;
 
-            if (disposable != null)
-            {
-                disposable.Dispose();
-            }
+            disposable?.Dispose();
         }
     }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentProperties.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentProperties.cs
index dfcc3982..8aec0f20 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentProperties.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentProperties.cs
@@ -323,10 +323,7 @@ internal void ShowDialog()
             DocumentPropertiesDialog dialog = null;
             dialog = new DocumentPropertiesDialog();
             dialog.ShowDialog();
-            if (dialog != null)
-            {
-                dialog.Dispose();
-            }
+            dialog?.Dispose();
         }
         #endregion Internal Methods
 
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentStream.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentStream.cs
index 312e3d9e..39f23cb8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentStream.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/DocumentStream.cs
@@ -420,10 +420,7 @@ internal bool ReOpenWriteable()
 
         //----------------------------------------------------------------------
         // Release Existing Locks (so we open with write)
-        if (Target != null)
-        {
-            Target.Close();
-        }
+        Target?.Close();
 
         //----------------------------------------------------------------------
         // Open Writable (if it fails re-open for Read)
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/PackageController.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/PackageController.cs
index 3b6db897..177039b5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/PackageController.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/PackageController.cs
@@ -166,9 +166,8 @@ bool IDocumentController.SavePreperation(Document document)
         // we don't have to check packageDoc for because we are only responsible
         // for PackageDocuments
         PackageDocument packageDoc = (PackageDocument)document;
-        RightsDocument rightsDoc = document.Dependency as RightsDocument;
 
-        if (rightsDoc != null)
+        if (document.Dependency is RightsDocument rightsDoc)
         {
             bool isDestinationProtected = rightsDoc.IsDestinationProtected();
             bool isSourceProtected = rightsDoc.IsSourceProtected();
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsController.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsController.cs
index 481d7ff5..e241c6e9 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsController.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsController.cs
@@ -425,10 +425,7 @@ void IDisposable.Dispose()
     {
         IDisposable provider = _provider.Value as IDisposable;
 
-        if (provider != null)
-        {
-            provider.Dispose();
-        }
+        provider?.Dispose();
 
         _provider.Value = null;
         
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsManagementErrorHandler.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsManagementErrorHandler.cs
index 2180250a..d7172ce5 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsManagementErrorHandler.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/Application/RightsManagementErrorHandler.cs
@@ -212,11 +212,11 @@ internal static class RightsManagementErrorHandler
             }
 
             // Each handled type of exception has a different handler function
-            else if (exception is RightsManagementException)
+            else if (exception is RightsManagementException rightsManagementException)
             {
                 return ParseRightsManagementException(
                     operation,
-                    (RightsManagementException)exception,
+rightsManagementException,
                     out askUser,
                     out fatal);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DigitalSignatureProvider.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DigitalSignatureProvider.cs
index 6b233e05..c3dbb0fa 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DigitalSignatureProvider.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DigitalSignatureProvider.cs
@@ -503,15 +503,12 @@ private static DigitalSignature ConvertXpsDigitalSignature(XpsDigitalSignature x
 
             digitalSignature.XpsDigitalSignature = xpsDigitalSignature;
 
-            X509Certificate2 x509Certificate2 =
-                xpsDigitalSignature.SignerCertificate as X509Certificate2;
-
             digitalSignature.SignatureState = SignatureStatus.Unknown;
 
             // Copy simple fields if cert isn't null.  If it is null then the
             // cert wasn't embedded into container so don't copy cert related
             // fields.
-            if (x509Certificate2 != null)
+            if (xpsDigitalSignature.SignerCertificate is X509Certificate2 x509Certificate2)
             {
                 digitalSignature.Certificate = x509Certificate2;
                 digitalSignature.SignedOn = xpsDigitalSignature.SigningTime;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentApplicationDocumentViewer.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentApplicationDocumentViewer.cs
index b2962486..de419270 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentApplicationDocumentViewer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentApplicationDocumentViewer.cs
@@ -320,10 +320,7 @@ protected override void OnPrintCommand()
         protected override void OnCancelPrintCommand()
         {
 #if !DONOTREFPRINTINGASMMETA
-            if (_documentWriter != null)
-            {
-                _documentWriter.CancelAsync();
-            }
+            _documentWriter?.CancelAsync();
 #endif // DONOTREFPRINTINGASMMETA
         }
 
@@ -457,9 +454,8 @@ PrintDocumentImageableArea ia
             // Create a destination FixedDocument
             //
             FixedDocument dstDoc = new FixedDocument();
-            FixedDocumentSequence fds = docPaginator.Source as FixedDocumentSequence;
 
-            if (fds != null)
+            if (docPaginator.Source is FixedDocumentSequence fds)
             {
                 //
                 // If the source is a FixedDocumentSequence (Should be in Mongoose!), do not use a DocumentPaginator
@@ -551,11 +547,8 @@ protected override void OnDocumentChanged()
         {
             base.OnDocumentChanged();
 
-            // Whenever the document changes (possibly from navigation) hook up a handler
-            // to reset the DocumentViewer to the stored state (usually this will mean the
-            // default state)
-            DynamicDocumentPaginator paginator = Document.DocumentPaginator as DynamicDocumentPaginator;
-            if (paginator != null)
+            // Whenever the document changes (possibly from navigation) hook up a handler            // to reset the DocumentViewer to the stored state (usually this will mean the            // default state)
+            if (Document.DocumentPaginator is DynamicDocumentPaginator paginator)
             {
                 paginator.PaginationCompleted += new EventHandler(OnPaginationCompleted);
 
@@ -1255,8 +1248,7 @@ private void ChangeControlVisibility(UIElement uie, bool visibility)
         /// <param name="e">Argument to the event</param>
         private void MenuPreviewKeyDown(object sender, KeyEventArgs e)
         {
-            MenuItem menuItem = sender as MenuItem;
-            if (menuItem != null && menuItem.Role == MenuItemRole.TopLevelHeader &&
+            if (sender is MenuItem menuItem && menuItem.Role == MenuItemRole.TopLevelHeader &&
                 !menuItem.IsSubmenuOpen && e.Key == Key.Escape)
             {
                 Focus();
@@ -1342,10 +1334,8 @@ private static void OnApplicationCommandExecute(object sender, ExecutedRoutedEve
                 else if (e.Command.Equals(DocumentApplicationDocumentViewer.FocusToolBar))
                 {
                     Trace.SafeWrite(Trace.Presentation, "FocusToolBar command fired.");
-
                     // Ensure that the sender is a DocumentApplicationDocumentViewer
-                    DocumentApplicationDocumentViewer docViewer = sender as DocumentApplicationDocumentViewer;
-                    Invariant.Assert(docViewer != null, "Sender must be a valid DocumentApplicationDocumentViewer");
+                    Invariant.Assert(sender is DocumentApplicationDocumentViewer docViewer, "Sender must be a valid DocumentApplicationDocumentViewer");
 
                     // Handle command so that it doesn't bubble up to DocumentViewer
                     e.Handled = true;
@@ -1419,9 +1409,8 @@ private static void OnApplicationCommandQuery(object target, CanExecuteRoutedEve
         /// <param name="e">Event arguments</param>
         private static void OnNavigationCommandExecute(object sender, ExecutedRoutedEventArgs e)
         {
-            DocumentApplicationDocumentViewer dv = sender as DocumentApplicationDocumentViewer;
 
-            if ((e != null) && (dv != null) && (e.Command != null))
+            if ((e != null) && (sender is DocumentApplicationDocumentViewer dv) && (e.Command != null))
             {
                 // If FirstPage or LastPage were executed, add a journal entry
                 if (e.Command.Equals(NavigationCommands.FirstPage))
@@ -1445,9 +1434,8 @@ private static void OnNavigationCommandExecute(object sender, ExecutedRoutedEven
         /// <param name="e">Event arguments</param>
         private static void OnNavigationCommandQuery(object sender, CanExecuteRoutedEventArgs e)
         {
-            DocumentApplicationDocumentViewer dv = sender as DocumentApplicationDocumentViewer;
 
-            if ((e != null) && (dv != null) && (e.Command != null))
+            if ((e != null) && (sender is DocumentApplicationDocumentViewer dv) && (e.Command != null))
             {
                 // Check if the commands are allowed
                 if (e.Command.Equals(NavigationCommands.FirstPage))
@@ -1469,11 +1457,10 @@ private static void OnNavigationCommandQuery(object sender, CanExecuteRoutedEven
         /// <param name="e">Event arguments</param>
         private static void OnDigSigExecute(object sender, ExecutedRoutedEventArgs e)
         {
-            DocumentApplicationDocumentViewer dv = sender as DocumentApplicationDocumentViewer;
 
             // Ensure parameters are valid, and DocumentSignatureManager is set.
             // This method is setup to fail silently if called inappropriately.
-            if ((e != null) && (dv != null) && (dv._docSigManager != null))
+            if ((e != null) && (sender is DocumentApplicationDocumentViewer dv) && (dv._docSigManager != null))
             {
                 // Check which command was executed, and act appropriately
                 if (e.Command.Equals(DocumentApplicationDocumentViewer.Sign))
@@ -1498,11 +1485,10 @@ private static void OnDigSigExecute(object sender, ExecutedRoutedEventArgs e)
         /// <param name="e">Event arguments</param>
         private static void OnDigSigQuery(object sender, CanExecuteRoutedEventArgs e)
         {
-            DocumentApplicationDocumentViewer dv = sender as DocumentApplicationDocumentViewer;
 
             // Ensure parameters are valid, and DocumentSignatureManager is set.
             // This method is setup to fail silently if called inappropriately.
-            if ((e != null) && (dv != null) && (dv._docSigManager != null))
+            if ((e != null) && (sender is DocumentApplicationDocumentViewer dv) && (dv._docSigManager != null))
             {
                 // Check which command was executed, and act appropriately:
                 // 1) The Sign command can always be executed.
@@ -1560,11 +1546,10 @@ private void OnPaginationCompleted(object sender, EventArgs args)
         /// <param name="e">Event arguments</param>
         private static void OnRMExecute(object sender, ExecutedRoutedEventArgs e)
         {
-            DocumentApplicationDocumentViewer dv = sender as DocumentApplicationDocumentViewer;
 
             // Ensure parameters are valid, and DocumentRightsManagementManager is set.
             // This method is setup to fail silently if called inappropriately.
-            if ((e != null) && (dv != null) && (dv._rmManager != null))
+            if ((e != null) && (sender is DocumentApplicationDocumentViewer dv) && (dv._rmManager != null))
             {
                 // Verify that the RM Client is installed.
                 if (dv._rmManager.IsRMInstalled)
@@ -1597,10 +1582,9 @@ private static void OnRMExecute(object sender, ExecutedRoutedEventArgs e)
         /// <param name="e">Event arguments</param>
         private static void OnRMQuery(object sender, CanExecuteRoutedEventArgs e)
         {
-            DocumentApplicationDocumentViewer dv = sender as DocumentApplicationDocumentViewer;
             // Ensure parameters are valid.
             // This method is setup to fail silently if called inappropriately.
-            if ((e != null) && (dv != null))
+            if ((e != null) && (sender is DocumentApplicationDocumentViewer dv))
             {
                 // Check which command was executed, and act appropriately
 
@@ -1704,8 +1688,7 @@ private void OnZoomComboBoxSelectionChanged(object sender, SelectionChangedEvent
                     ComboBoxItem cbItem = ZoomComboBox.SelectedItem as ComboBoxItem;
                     // Check if a selection is made (when an item is selected from the list the
                     // SelectedItem will be non-null)                
-                    if (cbItem != null &&
-                        cbItem.Content is ZoomComboBoxItem)
+                    if (cbItem?.Content is ZoomComboBoxItem)
                     {
                         ZoomComboBoxItem item = (ZoomComboBoxItem)cbItem.Content;
 
@@ -2414,9 +2397,8 @@ public override DocumentPage GetPage(int pageNumber)
             {
                 DocumentPage page = null;
                 FixedPage fixedPage = null;
-                FixedDocument fd = _documentPaginator.Source as FixedDocument;
 
-                if (fd != null && pageNumber < fd.Pages.Count)
+                if (_documentPaginator.Source is FixedDocument fd && pageNumber < fd.Pages.Count)
                 {
                     fixedPage = fd.Pages[pageNumber].GetPageRoot(false) as FixedPage;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentSignatureManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentSignatureManager.cs
index 8c8e0ffa..715ec2cc 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentSignatureManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/DocumentSignatureManager.cs
@@ -260,10 +260,7 @@ internal void ShowSignatureSummaryDialog()
                 false /*Sig Request Dialog*/);
                 dialog.ShowDialog(parentWindow);
 
-            if (dialog != null)
-            {
-                dialog.Dispose();
-            }
+            dialog?.Dispose();
         }
 
         /// <summary>
@@ -296,10 +293,7 @@ internal void ShowSignatureRequestSummaryDialog()
                     true /*Sig Request Dialog*/);
                     dialog.ShowDialog(parentWindow);
 
-                if (dialog != null)
-                {
-                    dialog.Dispose();
-                }
+                dialog?.Dispose();
             }
             else
             {
@@ -529,10 +523,7 @@ internal void ShowSigningDialog(IntPtr parentWindow)
                 this);
             dialog.ShowDialog(NativeWindow.FromHandle(parentWindow));
 
-            if (dialog != null)
-            {
-                dialog.Dispose();
-            }
+            dialog?.Dispose();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/PeoplePickerWrapper.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/PeoplePickerWrapper.cs
index 6bfde054..e5ead558 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/PeoplePickerWrapper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/PeoplePickerWrapper.cs
@@ -239,11 +239,9 @@ private String[] GetEmailAddressesFromPaths(String[] paths)
 
                 if (emailCollection != null && emailCollection.Count > 0)
                 {
-                    //We have a non-empty e-mail collection; we will add the
-                    //first available e-mail address.
-                    String address = emailCollection[0] as String;
+                    //We have a non-empty e-mail collection; we will add the                    //first available e-mail address.
 
-                    if (address != null)
+                    if (emailCollection[0] is String address)
                     {
                         addresses.Add(address);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RMPublishingDialog.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RMPublishingDialog.cs
index ed268636..6d129844 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RMPublishingDialog.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RMPublishingDialog.cs
@@ -805,9 +805,7 @@ private void comboBox1_SelectedValueChanged(object sender, EventArgs e)
         /// <param name="e">Event args (not used)</param>
         private static void OnIconButtonEnter(object sender, EventArgs e)
         {
-            Button button = sender as Button;
-
-            if (button != null)
+            if (sender is Button button)
             {
                 button.FlatStyle = FlatStyle.Standard;
             }
@@ -821,9 +819,7 @@ private static void OnIconButtonEnter(object sender, EventArgs e)
         /// <param name="e">Event args (not used)</param>
         private static void OnIconButtonLeave(object sender, EventArgs e)
         {
-            Button button = sender as Button;
-
-            if (button != null)
+            if (sender is Button button)
             {
                 button.FlatStyle = FlatStyle.Flat;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RightsManagementManager.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RightsManagementManager.cs
index c77c0c0b..74117170 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RightsManagementManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/MS/Internal/documents/RightsManagementManager.cs
@@ -270,10 +270,7 @@ internal DialogResult ShowCredentialManagementUI(bool decrypting)
             _credManagerDialog = new CredentialManagerDialog(accountList, userAccount, this);
             result = _credManagerDialog.ShowDialog();
 
-            if (_credManagerDialog != null)
-            {
-                _credManagerDialog.Dispose();
-            }
+            _credManagerDialog?.Dispose();
 
             RightsManagementUser newDefaultUser = _rmProvider.GetDefaultCredentials();
 
@@ -411,10 +408,7 @@ internal void ShowPermissions()
                 RMPermissionsDialog rmPermissionsPage = new RMPermissionsDialog(rmLicense);
                 rmPermissionsPage.ShowDialog();
 
-                if (rmPermissionsPage != null)
-                {
-                    rmPermissionsPage.Dispose();
-                }
+                rmPermissionsPage?.Dispose();
             }
         }
 
@@ -552,10 +546,7 @@ internal void ShowPublishing()
             }
             finally
             {
-                if (rmPublish != null)
-                {
-                    rmPublish.Dispose();
-                }
+                rmPublish?.Dispose();
             }
 
             // If the status changed, call Evaluate to re-evaluate the RM
@@ -596,13 +587,7 @@ internal void OnCredentialManagementRemove(string accountName)
                 {
                     _rmProvider.RemoveCredentials(user);
 
-                    if (_credManagerDialog != null)
-                    {
-                        //Set the data source for the listbox
-                        _credManagerDialog.SetCredentialManagementList(
-                            GetCredentialManagementResourceList(),
-                            GetDefaultCredentialManagementResource());
-                    }
+                    _credManagerDialog?.SetCredentialManagementList(GetCredentialManagementResourceList(), GetDefaultCredentialManagementResource());
                 }
                 catch (RightsManagementException exception)
                 {
@@ -632,13 +617,7 @@ internal void OnCredentialManagementShowEnrollment()
         {
             ShowEnrollment();
 
-            if (_credManagerDialog != null)
-            {
-                //Set the data source for the listbox
-                _credManagerDialog.SetCredentialManagementList(
-                    GetCredentialManagementResourceList(),
-                    GetDefaultCredentialManagementResource());
-            }
+            _credManagerDialog?.SetCredentialManagementList(GetCredentialManagementResourceList(), GetDefaultCredentialManagementResource());
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationError.xaml.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationError.xaml.cs
index 489afd72..bcfede0d 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationError.xaml.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationError.xaml.cs
@@ -193,7 +193,7 @@ private void ShowLogFileButton()
         static void OnCommandRefresh(object sender, RoutedEventArgs e)
         {
             TenFeetInstallationError page = sender as TenFeetInstallationError;
-            if (page != null && page.RefreshCallback != null)
+            if (page?.RefreshCallback != null)
             {
                 page.RefreshCallback(null);
             }
@@ -201,8 +201,7 @@ static void OnCommandRefresh(object sender, RoutedEventArgs e)
 
         static void OnCanRefresh(object sender, CanExecuteRoutedEventArgs e)
         {
-            TenFeetInstallationError page = sender as TenFeetInstallationError;
-            if (page != null)
+            if (sender is TenFeetInstallationError page)
             {
                 e.CanExecute = true;
                 e.Handled = true;
diff --git a/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationProgress.xaml.cs b/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationProgress.xaml.cs
index 02f050e2..112632d8 100644
--- a/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationProgress.xaml.cs
+++ b/src/Microsoft.DotNet.Wpf/src/PresentationUI/TenFeetInstallationProgress.xaml.cs
@@ -138,7 +138,7 @@ public void UpdateProgress(long bytesDownloaded, long bytesTotal)
         static void OnCommandRefresh(object sender, RoutedEventArgs e)
         {
             TenFeetInstallationProgress page = sender as TenFeetInstallationProgress;
-            if (page != null && page.RefreshCallback != null)
+            if (page?.RefreshCallback != null)
             {
                 page.RefreshCallback(null);
             }
@@ -153,7 +153,7 @@ static void OnCanRefresh(object sender, CanExecuteRoutedEventArgs e)
         static void OnCommandStop(object sender, RoutedEventArgs e)
         {
             TenFeetInstallationProgress page = sender as TenFeetInstallationProgress;
-            if (page != null && page.StopCallback != null)
+            if (page?.StopCallback != null)
             {
                 page.StopCallback(null);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/BrushProxy.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/BrushProxy.cs
index e35325a3..49dd876b 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/BrushProxy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/BrushProxy.cs
@@ -813,10 +813,7 @@ public void ApplyTransform(Matrix trans)
                     }
                 }
 
-                if (_opacityMask != null)
-                {
-                    _opacityMask.ApplyTransform(trans);
-                }
+                _opacityMask?.ApplyTransform(trans);
             }
         }
 
@@ -858,16 +855,12 @@ public BrushProxy BlendBrush(BrushProxy brushB)
             // If there is no OpacitMask, blend two brushes when possible
             if ((this._opacityMask == null) && (brushB._opacityMask == null))
             {
-                SolidColorBrush sA = _brush as SolidColorBrush;
-
-                if (sA != null)
+                if (_brush is SolidColorBrush sA)
                 {
                     return BlendColorWithBrush(_opacityOnly, Utility.Scale(sA.Color, _opacity), brushB, false);
                 }
 
-                SolidColorBrush sB = brushB.Brush as SolidColorBrush;
-
-                if (sB != null)
+                if (brushB.Brush is SolidColorBrush sB)
                 {
                     return BlendColorWithBrush(brushB._opacityOnly, Utility.Scale(sB.Color, brushB._opacity), this, true);
                 }
@@ -1120,9 +1113,7 @@ public double GetDrawingCost(Size size)
 
                 if (isOpaque && (_brush.Transform == null || Utility.IsScaleTranslate(_brush.Transform.Value)))
                 {
-                    LinearGradientBrush linearBrush = _brush as LinearGradientBrush;
-
-                    if (linearBrush != null)
+                    if (_brush is LinearGradientBrush linearBrush)
                     {
                         // Check for axis-aligned linear gradients. As an optimization we collapse one of the
                         // dimensions to 1 pixel during rasterization.
@@ -1158,9 +1149,7 @@ public bool IsWhite()
         {
             if (_brush != null)
             {
-                SolidColorBrush scb = _brush as SolidColorBrush;
-
-                if (scb != null)
+                if (_brush is SolidColorBrush scb)
                 {
                     Color c = scb.Color;
 
@@ -1226,10 +1215,9 @@ public bool IsTiled(Rect bounds)
 
             if (Brush != null)
             {
-                TileBrush tileBrush = Brush as TileBrush;
                 Debug.Assert(tileBrush.ViewportUnits == BrushMappingMode.Absolute);
 
-                if (tileBrush != null &&
+                if (Brush is TileBrush tileBrush &&
                     tileBrush.TileMode != TileMode.None &&
                     !IsViewportCoverBounds(bounds))
                 {
@@ -1248,9 +1236,7 @@ public Primitive GetDrawingPrimitive()
         {
             if (_drawing == null)
             {
-                DrawingBrush drawingBrush = _brush as DrawingBrush;
-
-                if (drawingBrush != null)
+                if (_brush is DrawingBrush drawingBrush)
                 {
                     Debug.Assert(drawingBrush.Drawing != null, "DrawingBrush where Drawing == null should've been culled");
 
@@ -1614,9 +1600,7 @@ private bool IsDrawingOpaque(Primitive p, Geometry viewbox, Matrix transform)
                 return false;
             }
 
-            CanvasPrimitive cp = p as CanvasPrimitive;
-
-            if (cp != null)
+            if (p is CanvasPrimitive cp)
             {
                 // recursively check children opaqueness
                 transform = p.Transform * transform;
@@ -1679,9 +1663,7 @@ private bool IsDrawingTransparent(Primitive p, Geometry viewbox, Matrix drawingT
                 return true;
             }
 
-            CanvasPrimitive cp = p as CanvasPrimitive;
-
-            if (cp != null)
+            if (p is CanvasPrimitive cp)
             {
                 // recursively check children transparency
                 drawingToWorldTransformHint.Prepend(p.Transform);
@@ -1904,9 +1886,7 @@ int secondIndex
             bool brushHandled = false;
 
             {
-                LinearGradientBrush b = brush as LinearGradientBrush;
-
-                if (b != null)
+                if (brush is LinearGradientBrush b)
                 {
                     brushHandled = true;
 
@@ -1921,9 +1901,7 @@ int secondIndex
             }
 
             {
-                RadialGradientBrush b = brush as RadialGradientBrush;
-
-                if (b != null)
+                if (brush is LinearGradientBrush b)
                 {
                     brushHandled = true;
 
@@ -2200,9 +2178,8 @@ private BrushProxy BlendBrushList(BrushProxy b, bool first)
         /// <returns></returns>
         private static bool Supercede(Brush brushA, Brush brushB)
         {
-            TileBrush tA = brushA as TileBrush;
 
-            if ((tA != null) && (tA.Stretch == Stretch.Fill) && (tA.TileMode == TileMode.Tile))
+            if ((brushA is TileBrush tA) && (tA.Stretch == Stretch.Fill) && (tA.TileMode == TileMode.Tile))
             {
                 if (brushB is SolidColorBrush)
                 {
@@ -2220,9 +2197,7 @@ private static bool Supercede(Brush brushA, Brush brushB)
                 {
                     Rect viewportA = tA.Viewport;
 
-                    TileBrush tB = brushB as TileBrush;
-
-                    if ((tB != null) && (tB.Stretch == Stretch.Fill))
+                    if ((brushB is TileBrush tB) && (tB.Stretch == Stretch.Fill))
                     {
                         Rect viewportB = tB.Viewport;
 
@@ -2260,9 +2235,7 @@ private static bool Supercede(Brush brushA, Brush brushB)
                         }
                     }
 
-                    LinearGradientBrush lB = brushB as LinearGradientBrush;
-
-                    if (lB != null)
+                    if (brushB is LinearGradientBrush lB)
                     {
                         double multiplier = 1;
 
@@ -2315,9 +2288,8 @@ private static bool Supercede(Brush brushA, Brush brushB)
         /// <returns>New brush if successful</returns>
         private BrushProxy BlendImageBrush(BrushProxy brushB, bool pre)
         {
-            ImageBrush ib = _brush as ImageBrush;
 
-            if ((ib != null) && (brushB.Brush != null) && Supercede(ib, brushB.Brush)) // Check for compatibility
+            if ((_brush is ImageBrush ib) && (brushB.Brush != null) && Supercede(ib, brushB.Brush)) // Check for compatibility
             {
                 BitmapSource bs = (BitmapSource)(ib.ImageSource);
 
@@ -2606,9 +2578,8 @@ private BrushProxy BlendRadialGradientBrush(BrushProxy brushB)
 
         static public bool IsOpaqueWhite(Brush brush)
         {
-            SolidColorBrush sb = brush as SolidColorBrush;
 
-            if ((sb != null) && Utility.IsOpaque(sb.Opacity))
+            if ((brush is SolidColorBrush sb) && Utility.IsOpaque(sb.Opacity))
             {
                 Color c = sb.Color;
 
@@ -2623,9 +2594,8 @@ static public bool IsOpaqueWhite(Brush brush)
 
         static public bool IsOpaqueBlack(Brush brush)
         {
-            SolidColorBrush sb = brush as SolidColorBrush;
 
-            if ((sb != null) && Utility.IsOpaque(sb.Opacity))
+            if ((brush is SolidColorBrush sb) && Utility.IsOpaque(sb.Opacity))
             {
                 Color c = sb.Color;
 
@@ -2686,19 +2656,14 @@ private static BrushProxy CreateBrushCore(Brush brush, Rect bounds)
                 }
             }
 
-            //
-            // Verify created brush. Ensure that we have absolute brush.
-            //
-            GradientBrush gb = brushProxy.Brush as GradientBrush;
+            //            // Verify created brush. Ensure that we have absolute brush.            //
 
-            if (gb != null)
+            if (brushProxy.Brush is GradientBrush gb)
             {
                 Debug.Assert(gb.MappingMode == BrushMappingMode.Absolute, "absolute brush");
             }
 
-            TileBrush tb = brushProxy.Brush as TileBrush;
-
-            if (tb != null)
+            if (brushProxy.Brush is TileBrush tb)
             {
                 // Viewport must be absolute, but Viewbox can be relative
                 Debug.Assert(tb.ViewportUnits == BrushMappingMode.Absolute, "absolute brush required for BrushProxy");
@@ -2828,9 +2793,7 @@ public static bool IsEmpty(Brush brush)
                 return true;
             }
 
-            SolidColorBrush solidBrush = brush as SolidColorBrush;
-
-            if (solidBrush != null)
+            if (brush is SolidColorBrush solidBrush)
             {
                 if (Utility.IsTransparent(solidBrush.Color.ScA))
                 {
@@ -2841,9 +2804,7 @@ public static bool IsEmpty(Brush brush)
                 return false;
             }
 
-            GradientBrush gradientBrush = brush as GradientBrush;
-
-            if (gradientBrush != null)
+            if (brush is GradientBrush gradientBrush)
             {
                 GradientStopCollection stops = gradientBrush.GradientStops;
 
@@ -2862,9 +2823,7 @@ public static bool IsEmpty(Brush brush)
                     }
                 }
 
-                LinearGradientBrush linearBrush = brush as LinearGradientBrush;
-
-                if (linearBrush != null)
+                if (brush is LinearGradientBrush linearBrush)
                 {
                     if (!Utility.IsRenderVisible(linearBrush.StartPoint) || !Utility.IsRenderVisible(linearBrush.EndPoint))
                     {
@@ -2875,9 +2834,7 @@ public static bool IsEmpty(Brush brush)
                     return false;
                 }
 
-                RadialGradientBrush radialBrush = brush as RadialGradientBrush;
-
-                if (radialBrush != null)
+                if (brush is RadialGradientBrush radialBrush)
                 {
                     if (!Utility.IsRenderVisible(radialBrush.Center) ||
                         !Utility.IsRenderVisible(radialBrush.GradientOrigin) ||
@@ -2895,9 +2852,7 @@ public static bool IsEmpty(Brush brush)
                 return false;
             }
 
-            TileBrush tileBrush = brush as TileBrush;
-
-            if (tileBrush != null)
+            if (brush is TileBrush tileBrush)
             {
                 if (! Utility.IsRenderVisible(tileBrush.Viewport) ||
                     ! Utility.IsValidViewbox(tileBrush.Viewbox, tileBrush.Stretch != Stretch.None)
@@ -2939,9 +2894,7 @@ public static Brush ReduceBrush(Brush brush, Rect bounds, Matrix brushToWorldTra
 
             double opacity = Utility.NormalizeOpacity(brush.Opacity);
 
-            GradientBrush gb = brush as GradientBrush;
-
-            if (gb != null)
+            if (brush is GradientBrush gb)
             {
                 // check for gradient brush where colors are similar enough to be a solid brush
                 GradientStopCollection gsc = gb.GradientStops;
@@ -2983,8 +2936,7 @@ public static Brush ReduceBrush(Brush brush, Rect bounds, Matrix brushToWorldTra
                 return brush;
             }
 
-            BitmapCacheBrush bcb = brush as BitmapCacheBrush;
-            if (bcb != null)
+            if (brush is BitmapCacheBrush bcb)
             {
                 Debug.Assert(!bounds.IsEmpty, "Bounds must not be empty for BitmapCacheBrush");
 
@@ -3059,10 +3011,8 @@ public static Brush ReduceBrush(Brush brush, Rect bounds, Matrix brushToWorldTra
 
                 return drawingBrush;
             }
-            
-            VisualBrush vb = brush as VisualBrush;
 
-            if (vb != null)
+            if (brush is VisualBrush vb)
             {
                 Debug.Assert(!bounds.IsEmpty, "Bounds must not be empty for VisualBrush");
 
@@ -3165,21 +3115,15 @@ public static Brush ReduceBrush(Brush brush, Rect bounds, Matrix brushToWorldTra
                 return drawingBrush;
             }
 
-            ImageBrush ib = brush as ImageBrush;
-
-            if (ib != null)
+            if (brush is ImageBrush ib)
             {
-                BitmapSource bitmapSource = ib.ImageSource as BitmapSource;
-
-                if (bitmapSource != null)
+                if (ib.ImageSource is BitmapSource bitmapSource)
                 {
                     // we can handle bitmap images
                     return brush;
                 }
 
-                DrawingImage drawingImage = ib.ImageSource as DrawingImage;
-
-                if (drawingImage != null)
+                if (ib.ImageSource is DrawingImage drawingImage)
                 {
                     // convert to DrawingBrush to reduce number of ImageBrush.ImageSource types we need to handle
                     DrawingBrush db = Utility.CreateNonInheritingDrawingBrush(drawingImage.Drawing);
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Flattener.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Flattener.cs
index ffe259d1..42646bc3 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Flattener.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Flattener.cs
@@ -173,10 +173,7 @@ public void TreeFlatten(Primitive tree, Geometry clip, Matrix transform, double
                     }
 #endif
 
-                    if (opacityMask != null)
-                    {
-                        opacityMask.ApplyTransform(transform);
-                    }
+                    opacityMask?.ApplyTransform(transform);
 
                     // Flatten sub-tree structure into a new DisplayList
                     fl.TreeFlatten(ntree, clip, transform, 1.0, null);
@@ -204,7 +201,7 @@ public void TreeFlatten(Primitive tree, Geometry clip, Matrix transform, double
             {
                 GeometryPrimitive gp = tree as GeometryPrimitive;
 
-                if (gp != null && gp.Brush != null && gp.Pen != null &&
+                if (gp?.Brush != null && gp.Pen != null &&
                     (!gp.IsOpaque || !Utility.IsOpaque(opacity)))
                 {
                     //
@@ -717,7 +714,7 @@ private static bool ConvertTransparentOnOpaque(List<PrimitiveInfo> commands, int
                         //
                         bool proceedBlending = true;
 
-                        if (blendedPenBrush != null && blendedPenBrush.BrushList != null)
+                        if (blendedPenBrush?.BrushList != null)
                         {
                             proceedBlending = false;
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/ImageProxy.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/ImageProxy.cs
index 9817344d..2e98d098 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/ImageProxy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/ImageProxy.cs
@@ -163,16 +163,10 @@ public void PushOpacity(double opacity, BrushProxy opacityMask, Rect rect, Matri
             if (opacityMask != null)
             {
                 rect.Transform(trans);
-
-                //
-                // Blend this image on top of opacity mask.
-                //
-
-                // Calculate scaling factor from opacity mask to this image.
-                TileBrush opacityBrush = opacityMask.Brush as TileBrush;
+                //                // Blend this image on top of opacity mask.                //                // Calculate scaling factor from opacity mask to this image.
                 Rect viewport;
 
-                if (opacityBrush != null)
+                if (opacityMask.Brush is TileBrush opacityBrush)
                 {
                     Debug.Assert(opacityBrush.ViewportUnits == BrushMappingMode.Absolute, "TileBrush must have absolute viewport by this point");
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Optimizer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Optimizer.cs
index 579a6f90..c50e4f26 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Optimizer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Optimizer.cs
@@ -316,13 +316,11 @@ private bool BetterRasterize(List<PrimitiveInfo> commands)
 
                 Primitive p = pi.primitive;
 
-                GeometryPrimitive gp = p as GeometryPrimitive;
-
                 Rect bounds = pi.GetClippedBounds();
 
                 bool rasterize = true;
 
-                if (gp != null)
+                if (p is GeometryPrimitive gp)
                 {
                     double complexity = 1;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Primitive.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Primitive.cs
index 4eaff72b..90818694 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Primitive.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Primitive.cs
@@ -1097,10 +1097,7 @@ private void AbsorbOpacity()
                     Brush = Brush.PushOpacity(Opacity, OpacityMask);
                 }
 
-                if (Pen != null)
-                {
-                    Pen.PushOpacity(Opacity, OpacityMask);
-                }
+                Pen?.PushOpacity(Opacity, OpacityMask);
 
                 Opacity = 1;
                 OpacityMask = null;
@@ -1335,10 +1332,7 @@ public override void ApplyTransform()
                 // Clip     = Utility.TransformGeometry(Clip, Transform);
                 Geometry = Utility.TransformGeometry(Geometry, Transform);
 
-                if (Brush != null)
-                {
-                    Brush.ApplyTransform(Transform);
-                }
+                Brush?.ApplyTransform(Transform);
 
                 Transform = Matrix.Identity; // Reset transform
                 _widenGeometry = null;  // Reset cached widen geometry if any
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveList.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveList.cs
index 1181ca8b..4433ab77 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveList.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveList.cs
@@ -36,10 +36,8 @@ public DisplayList(bool disJoint, double width, double height)
         internal static string LeftPad(object obj, int len)
         {
             string s;
-        
-            List<int> l = obj as List<int>;
 
-            if (l != null)
+            if (obj is List<int> l)
             {
                 s = "<";
 
@@ -55,14 +53,12 @@ internal static string LeftPad(object obj, int len)
 
                 return s + ">";
             }
-            else if (obj is Double)
+            else if (obj is Double d)
             {
-                s = ((Double)obj).ToString("F1", CultureInfo.InvariantCulture);
+                s = d.ToString("F1", CultureInfo.InvariantCulture);
             }
-            else if (obj is Rect)
+            else if (obj is Rect r)
             {
-                Rect r = (Rect) obj;
-
                 return " [" + LeftPad(r.Left,   6) + ' '
                             + LeftPad(r.Top,    6) + ' '
                             + LeftPad(r.Width,  6) + ' '
@@ -169,9 +165,7 @@ static internal void PrintPrimitive(PrimitiveInfo info, int index, bool verbose)
             
             if (verbose)
             {
-                GlyphPrimitive gp = p as GlyphPrimitive;
-
-                if (gp != null)
+                if (p is GlyphPrimitive gp)
                 {
                     IList<char> chars = gp.GlyphRun.Characters;
                                 
@@ -188,17 +182,14 @@ static internal void PrintPrimitive(PrimitiveInfo info, int index, bool verbose)
 
             if (verbose)
             {
-                GeometryPrimitive gp = p as GeometryPrimitive;
 
-                if ((gp != null) && (gp.Brush != null) && (gp.Pen == null))
+                if ((p is GlyphPrimitive gp) && (gp.Brush != null) && (gp.Pen == null))
                 {
                     Brush b = gp.Brush.Brush;
 
                     if (b != null)
                     {
-                        SolidColorBrush sb = b as SolidColorBrush;
-
-                        if (sb != null)
+                        if (b is SolidColorBrush sb)
                         {
                             Console.Write(" SolidColorBrush({0})", sb.Color);
                         }
@@ -223,9 +214,7 @@ static internal void PrintPrimitive(PrimitiveInfo info, int index, bool verbose)
         /// <returns></returns>
         internal static bool IsWhitePrimitive(Primitive p)
         {
-            GeometryPrimitive gp = p as GeometryPrimitive;
-
-            if (gp != null)
+            if (p is GeometryPrimitive gp)
             {
                 if ((gp.Brush != null) && (gp.Pen == null))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveRenderer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveRenderer.cs
index dbe2dae0..8eb44dd1 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveRenderer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/PrimitiveRenderer.cs
@@ -333,9 +333,8 @@ private bool FindIntersection(Geometry cur, ref int start, out PrimitiveInfo top
 
                 for (int s = start; s < _overlapping.Count; s++)
                 {
-                    PrimitiveInfo pi = _commands[_overlapping[s]] as PrimitiveInfo;
 
-                    if ((pi != null) && !pi.primitive.IsTransparent && !pi.primitive.IsOpaque)
+                    if ((_commands[_overlapping[s]] is PrimitiveInfo pi) && !pi.primitive.IsTransparent && !pi.primitive.IsOpaque)
                     {
                         allopaque = false;
                         break;
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/SegmentTree.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/SegmentTree.cs
index 2c114db8..26b267f7 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/SegmentTree.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/SegmentTree.cs
@@ -83,10 +83,7 @@ public void Remove(int index, double x0, double x1)
         {
             if ((_min >= x0) && (_max <= x1)) // [_min.._max] is within [x0..x1]
             {
-                if (_sList != null)
-                {
-                    _sList.Remove(index);
-                }
+                _sList?.Remove(index);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Utility.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Utility.cs
index da9d1de1..60410a20 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Utility.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/Utility.cs
@@ -621,8 +621,7 @@ out isLineSegment
 
             PathGeometry pathGeometry = geometry as PathGeometry;
 
-            if (pathGeometry != null &&
-                pathGeometry.Figures != null &&
+            if (pathGeometry?.Figures != null &&
                 pathGeometry.Figures.Count == 1)
             {
                 PathFigure figure = pathGeometry.Figures[0];
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/metrodevice.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/metrodevice.cs
index 694a5a58..3984ee0c 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/metrodevice.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/AlphaFlattener/metrodevice.cs
@@ -671,9 +671,7 @@ public void FlushPage()
 
             if (s_TestingHook != null)
             {
-                DrawingContext dc = s_TestingHook as DrawingContext;
-
-                if (dc != null)
+                if (s_TestingHook is DrawingContext dc)
                 {
                     // Send alpha flattening output to a DrawingContext for testing
                     ioc = new OutputContext(dc);
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/MS/Internal/Printing/Configuration/HGlobalBuffer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/MS/Internal/Printing/Configuration/HGlobalBuffer.cs
index 7f0de1e0..97dd6c2d 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/MS/Internal/Printing/Configuration/HGlobalBuffer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/MS/Internal/Printing/Configuration/HGlobalBuffer.cs
@@ -52,10 +52,7 @@ public void Release()
             SafeHandle handle = this.Handle;
             this.Handle = null;
 
-            if (handle != null)
-            {
-                handle.Dispose();
-            }
+            handle?.Dispose();
         }
     }
 }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsDocument.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsDocument.cs
index 81c72079..b19ddaa2 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsDocument.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsDocument.cs
@@ -914,10 +914,7 @@ Stream     dataStream
         DisposeXpsDocument(
             )
         {
-            if(_opcPackage != null)
-            {
-                _opcPackage.Close();
-            }
+            _opcPackage?.Close();
         }
 
         internal
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsFixedPageReaderWriter.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsFixedPageReaderWriter.cs
index 8f2daca4..926a268b 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsFixedPageReaderWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsFixedPageReaderWriter.cs
@@ -1350,10 +1350,7 @@ Uri         uri
                 _currentChildren = null;
             }
 #if !RESOURCESTREAM_USING_PART
-            if (_pageStream != null)
-            {
-                _pageStream.Close();
-            }
+            _pageStream?.Close();
 #endif
             Toolbox.EmitEvent(EventTrace.Event.WClientDRXCommitPageEnd);
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsResource.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsResource.cs
index ef70a407..7b67c5ff 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsResource.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Packaging/XpsResource.cs
@@ -141,13 +141,7 @@ Uri inUri
         INode.Flush(
             )
         {
-            if( _partEditor != null )
-            {
-                //
-                // Flush the part editor
-                //
-                _partEditor.Flush();
-            }
+            _partEditor?.Flush();
         }
 
         void
@@ -171,10 +165,7 @@ Uri inUri
         void
         IDisposable.Dispose()
         {
-            if (_partEditor != null)
-            {
-                _partEditor.Close();
-            }
+            _partEditor?.Close();
 
             GC.SuppressFinalize(this);
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/FallbackPTProvider.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/FallbackPTProvider.cs
index 2e4eefb9..aa12beed 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/FallbackPTProvider.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/FallbackPTProvider.cs
@@ -358,10 +358,7 @@ public override MemoryStream ConvertDevModeToPrintTicket(byte[] devMode, PrintTi
 
         public override void Release()
         {
-            if (_deviceHandle != null)
-            {
-                _deviceHandle.Dispose();
-            }
+            _deviceHandle?.Dispose();
 
             this._deviceHandle = null;
             this._deviceName = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/PTManager.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/PTManager.cs
index 63b5f094..1427a30e 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/PTManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintConfig/PTManager.cs
@@ -107,7 +107,7 @@ public ConflictStatus ConflictStatus
         
         public override bool Equals(object o)
         {
-            if(o == null || !(o is ValidationResult))
+            if(!(o is ValidationResult))
             {
                 return false;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintSystemExceptions/PrintSystemException.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintSystemExceptions/PrintSystemException.cs
index 35ccb697..d3b879be 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintSystemExceptions/PrintSystemException.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/PrintSystemExceptions/PrintSystemException.cs
@@ -404,10 +404,7 @@ public override
             System.Runtime.Serialization.StreamingContext   context
             )
         {
-            if (info != null)
-            {
-                info.AddValue("PrinterName", printerName);
-            }
+            info?.AddValue("PrinterName", printerName);
             base.GetObjectData(info, context);
         }
 
@@ -568,10 +565,7 @@ public override
             System.Runtime.Serialization.StreamingContext   context
             )
         {
-            if (info != null)
-            {
-                info.AddValue("ServerName", serverName);
-            }
+            info?.AddValue("ServerName", serverName);
 
             base.GetObjectData(info, context);
         }
@@ -921,10 +915,7 @@ public override
             System.Runtime.Serialization.StreamingContext    context
             )
         {
-            if( info != null )
-            {
-                info.AddValue("JobId", jobId );
-            }
+            info?.AddValue("JobId", jobId);
             base.GetObjectData(info, context);
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/ImageSourceTypeConverter.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/ImageSourceTypeConverter.cs
index 4d4f1bfd..8bbb2b90 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/ImageSourceTypeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/ImageSourceTypeConverter.cs
@@ -231,10 +231,8 @@ Type                                destinationType
                 XpsResourceStream resourceStream = manager.AcquireResourceStream(typeof(BitmapSource), imageMimeType);
                 bool bCopiedStream = false;
 
-                BitmapFrame bitmapFrame = bitmapSource as BitmapFrame;
-
                 if (isSupportedMimeType &&
-                    bitmapFrame != null &&
+                    bitmapSource is BitmapFrame bitmapFrame &&
                     bitmapFrame.Decoder != null
                     )
                 {
@@ -373,8 +371,7 @@ Type            type
             // If bitmapSource is indexed, has a color palette and transparency (e.g. transparent GIF)
             // PNG conversion may lose color or transparency or both information
             // To avoid this we convert all paletted bitmapSources to the 32 bit per pixel bgra format
-            if (bitmapSource != null
-                && bitmapSource.Palette != null
+            if (bitmapSource?.Palette != null
                 && bitmapSource.Palette.Colors != null
                 && bitmapSource.Palette.Colors.Count > 0)
             {
@@ -466,8 +463,7 @@ BitmapEncoder encoder
             BitmapFrame bitmapFrame = bitmapSource as BitmapFrame;
 
             //Use the Uri hash table if we have a bitmap with a Uri
-            if (bitmapFrame != null &&
-                bitmapFrame.Decoder != null)
+            if (bitmapFrame?.Decoder != null)
             {
                 String sourceUri  = bitmapFrame.Decoder.ToString();
                 if (sourceUri != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/VisualTreeFlattener.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/VisualTreeFlattener.cs
index 1e1c6302..1355f2bd 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/VisualTreeFlattener.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/VisualTreeFlattener.cs
@@ -148,9 +148,9 @@ Type destinationType
                 }
             }
 
-            if (value is BitmapFrame)
+            if (value is BitmapFrame bitmapFrame)
             {
-                encoder.Frames.Add((BitmapFrame)value);
+                encoder.Frames.Add(bitmapFrame);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsFontSubsetter.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsFontSubsetter.cs
index 50fa6a1e..6bea2d38 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsFontSubsetter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsFontSubsetter.cs
@@ -215,10 +215,7 @@ FontSubsetterCommitPolicies signal
             {
                 foreach (FEMCacheItem item in _fontEmbeddingManagerCache.Values)
                 {
-                    if (item != null)
-                    {
-                        item.AddRestrictedRelationship();
-                    }
+                    item?.AddRestrictedRelationship();
                 }
 
             }      
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsImageSerializationService.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsImageSerializationService.cs
index f9dba4c6..870ac64a 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsImageSerializationService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/XpsImageSerializationService.cs
@@ -56,7 +56,7 @@ BitmapSource bitmapSource
                 BitmapFrame bitmapImage = bitmapSource as BitmapFrame;
                 BitmapCodecInfo codecInfo = null;
 
-                if (bitmapImage != null && bitmapImage.Decoder != null)
+                if (bitmapImage?.Decoder != null)
                     codecInfo = bitmapImage.Decoder.CodecInfo;
 
                 if (codecInfo != null)
@@ -123,7 +123,7 @@ BitmapSource bitmapSource
                 //
                 BitmapFrame bitmapFrame = bitmapSource as BitmapFrame;
                 
-                if (bitmapFrame != null && bitmapFrame.Decoder != null)
+                if (bitmapFrame?.Decoder != null)
                 {
                     codecInfo = bitmapFrame.Decoder.CodecInfo;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/MetroSerializationManager.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/MetroSerializationManager.cs
index 9e630f68..611e097c 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/MetroSerializationManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/MetroSerializationManager.cs
@@ -782,13 +782,9 @@ Object  serializableObject
 
             if(cachedItem == null)
             {
-                //
-                // This means that the type was not seen before
-                // We have to create a new entry to that type
-                //
-                DependencyObject objectAsDependencyObject = serializableObject as DependencyObject;
+                //                // This means that the type was not seen before                // We have to create a new entry to that type                //
 
-                if (objectAsDependencyObject != null)
+                if (serializableObject is DependencyObject objectAsDependencyObject)
                 {
                     //
                     // First we have to figure out if this dependency
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCPageContentCollectionSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCPageContentCollectionSerializerAsync.cs
index 5756f166..77b12fd6 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCPageContentCollectionSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCPageContentCollectionSerializerAsync.cs
@@ -79,10 +79,7 @@ NGCSerializerContext context
 
                 case SerializerAction.serializeNextPageContent:
                 {
-                    NgcPageContentCollectionSerializerContext thisContext = 
-                    context as NgcPageContentCollectionSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is NgcPageContentCollectionSerializerContext thisContext)
                     {
                         SerializeNextPageContent(thisContext.Enumerator,
                                                  thisContext.ObjectContext);
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializer.cs
index 4fcccc53..426f0301 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializer.cs
@@ -49,8 +49,7 @@ internal static String InferJobName(object  o)
 
             if(o != null)
             {
-                IFrameworkInputElement inputElement = o as IFrameworkInputElement;
-                if (inputElement != null)
+                if (o is IFrameworkInputElement inputElement)
                 {
                     jobName = inputElement.Name;
                 }
@@ -186,9 +185,7 @@ Object serializedObject
             Size pageSize = new Size(fp.Width, fp.Height);
             ngcManager.PageSize = pageSize;
 
-            Visual visual = (Visual)serializedObject as Visual;
-
-            if (visual != null)
+            if ((Visual)serializedObject is Visual visual)
             {
                 ngcManager.WalkVisual(visual);
             }
@@ -256,9 +253,7 @@ Object serializedObject
 
             NgcSerializationManager NgcManager = SerializationManager as NgcSerializationManager;
 
-            Visual visual = (Visual)serializedObject as Visual;
-
-            if (visual != null)
+            if ((Visual)serializedObject is Visual visual)
             {
                 NgcManager.WalkVisual(visual);
             }
@@ -336,9 +331,7 @@ PackageSerializationManager   manager
             Object serializedObject
             )
         {
-
-            DocumentPage dp = serializedObject as DocumentPage;
-            if (dp != null)
+            if (serializedObject is DocumentPage dp)
             {
                 Toolbox.EmitEvent(EventTrace.Event.WClientDRXGetVisualStart);
                 Visual pageRootVisual = dp.Visual;
@@ -435,10 +428,7 @@ Object serializedObject
 
                     ReachSerializer serializer = SerializationManager.GetSerializer(page);
 
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(page);
-                    }
+                    serializer?.SerializeObject(page);
                 }
             }
 
@@ -632,23 +622,15 @@ DocumentReference dre
 
             if (idp != null)
             {
-                FixedDocument fixedDoc = idp as FixedDocument;
-
-                if (fixedDoc != null)
+                if (idp is FixedDocument fixedDoc)
                 {
                     ReachSerializer serializer = SerializationManager.GetSerializer(fixedDoc);
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(fixedDoc);
-                    }
+                    serializer?.SerializeObject(fixedDoc);
                 }
                 else
                 {
                     ReachSerializer serializer = SerializationManager.GetSerializer(idp.DocumentPaginator);
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(idp);
-                    }
+                    serializer?.SerializeObject(idp);
                 }
             }
         }
@@ -983,9 +965,7 @@ IEnumerable enumerableObject
             object uiElement
             )
         {
-            Visual visual = uiElement as Visual;
-
-            if(visual != null)
+            if(uiElement is Visual visual)
             {
                 ReachSerializer serializer = SerializationManager.GetSerializer(visual);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializerAsync.cs
index b6030bdd..1f7aa1a8 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCSerializerAsync.cs
@@ -470,10 +470,7 @@ SerializablePropertyContext serializablePropertyContext
                 ReachSerializer serializer = SerializationManager.GetSerializer(serializablePropertyContext.Value);
 
                 // If there is no serializer for this type, we won't serialize this property
-                if(serializer!=null)
-                {
-                    serializer.SerializeObject(serializablePropertyContext);
-                }
+                serializer?.SerializeObject(serializablePropertyContext);
             }
         }
 
@@ -747,10 +744,7 @@ SerializableObjectContext serializableObjectContext
             NGCSerializerContext  context
             )
         {
-
-            NGCDocumentPaginatorSerializerContext paginatorContext = context as NGCDocumentPaginatorSerializerContext;
-
-            if(paginatorContext != null)
+            if(context is NGCDocumentPaginatorSerializerContext paginatorContext)
             {
                 DocumentPaginator  paginator = paginatorContext.Paginator;
                 int                index     = paginatorContext.Index;
@@ -774,10 +768,7 @@ NGCSerializerContext  context
                     
                     ReachSerializer serializer = SerializationManager.GetSerializer(page);
 
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(page);
-                    }
+                    serializer?.SerializeObject(page);
                 }
             }
             else
@@ -864,12 +855,11 @@ Object serializedObject
 
             NgcSerializationManager.OperationStack.Push(context);
 
-            Visual visual = (Visual)serializableObjectContext.TargetObject as Visual;
-
             Size pageSize = new Size(fp.Width, fp.Height);
             NgcSerializationManager.PageSize = pageSize;
+
             
-            if (visual != null)
+            if ((Visual)serializableObjectContext.TargetObject is Visual visual)
             {
                 NgcSerializationManager.WalkVisual(visual);
             }
@@ -968,8 +958,7 @@ NGCSerializerContext context
             Object serializedObject
             )
         {
-            DocumentPage dp = serializedObject as DocumentPage;
-            if (dp != null)
+            if (serializedObject is DocumentPage dp)
             {
                 Visual pageRootVisual = dp.Visual;
 
@@ -1077,9 +1066,7 @@ SerializablePropertyContext serializedProperty
             Object serializedObject
             )
         {
-            Visual visual = serializedObject as Visual;
-
-            if (visual != null)
+            if (serializedObject is Visual visual)
             {
                 NgcSerializationManager.WalkVisual(visual);
             }
@@ -1099,9 +1086,7 @@ SerializableObjectContext   serializableObjectContext
                 throw new ArgumentNullException("serializableObjectContext");
             }
 
-            Visual visual = (Visual)serializableObjectContext.TargetObject as Visual;
-
-            if (visual != null)
+            if ((Visual)serializableObjectContext.TargetObject is Visual visual)
             {
                 NgcSerializationManager.WalkVisual(visual);
             }
@@ -1261,10 +1246,7 @@ NGCSerializerContext context
             {
                 case SerializerAction.serializeNextDocumentReference:
                 {
-                    NgcDocumentReferenceCollectionSerializerContext thisContext =
-                    context as NgcDocumentReferenceCollectionSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is NgcDocumentReferenceCollectionSerializerContext thisContext)
                     {
                         SerializeNextDocumentReference(thisContext.Enumerator,
                                                        thisContext.ObjectContext);
@@ -1372,23 +1354,15 @@ object documentReference
             
             if (idp != null)
             {
-                FixedDocument fixedDoc = idp as FixedDocument;
-
-                if (fixedDoc != null)
+                if (idp is FixedDocument fixedDoc)
                 {
                     ReachSerializer serializer = NgcSerializationManager.GetSerializer(fixedDoc);
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(fixedDoc);
-                    }
+                    serializer?.SerializeObject(fixedDoc);
                 }
                 else
                 {
                     ReachSerializer serializer = NgcSerializationManager.GetSerializer(idp.DocumentPaginator);
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(idp);
-                    }
+                    serializer?.SerializeObject(idp);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCUIElementCollectionSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCUIElementCollectionSerializerAsync.cs
index aff8c0da..7003dd75 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCUIElementCollectionSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NGCUIElementCollectionSerializerAsync.cs
@@ -78,9 +78,7 @@ NGCSerializerContext context
 
                 case SerializerAction.serializeNextUIElement:
                 {
-                    NgcUIElementCollectionSerializerContext thisContext = context as NgcUIElementCollectionSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is NgcUIElementCollectionSerializerContext thisContext)
                     {
                         SerializeNextUIElement(thisContext.Enumerator,
                                                thisContext.ObjectContext);
@@ -213,9 +211,7 @@ SerializableObjectContext   serializableObjectContext
             object uiElement
             )
         {
-            Visual visual = uiElement as Visual;
-
-            if(visual != null)
+            if(uiElement is Visual visual)
             {
                 ReachSerializer serializer = SerializationManager.GetSerializer(visual);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NullPackagingPolicy.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NullPackagingPolicy.cs
index 768284c1..fbe40c21 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NullPackagingPolicy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/NullPackagingPolicy.cs
@@ -916,25 +916,13 @@ PrintTicket printTicket
             _currentXpsColorContextRef    = 0;
             _currentXpsResourceDictionaryRef = 0;
 
-            if(_fontResourceStream!=null)
-            {
-                _fontResourceStream.Initialize();
-            }
+            _fontResourceStream?.Initialize();
 
-            if(_imageResourceStream!=null)
-            {
-                _imageResourceStream.Initialize();
-            }
+            _imageResourceStream?.Initialize();
 
-            if(_colorContextResourceStream!=null)
-            {
-                _colorContextResourceStream.Initialize();
-            }
+            _colorContextResourceStream?.Initialize();
 
-            if(_resourceDictionaryResourceStream!=null)
-            {
-                _resourceDictionaryResourceStream.Initialize();
-            }
+            _resourceDictionaryResourceStream?.Initialize();
 
 
             _fontAcquireMode = ResourceAcquireMode.NoneAcquired;
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializer.cs
index 665f7dac..317bf79b 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializer.cs
@@ -200,10 +200,7 @@ private void SerializeChild(Visual child, SerializableObjectContext parentContex
         {
             ReachSerializer serializer = SerializationManager.GetSerializer(child);
 
-            if (serializer != null)
-            {
-                serializer.SerializeObject(child);
-            }
+            serializer?.SerializeObject(child);
         }
 
         private void WriteAttribute(XmlWriter writer, string name, object value)
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializerAsync.cs
index ddcb6282..aba5c1a4 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentPageSerializerAsync.cs
@@ -239,10 +239,7 @@ private void SerializeChild(Visual child, SerializableObjectContext parentContex
         {
             ReachSerializer serializer = SerializationManager.GetSerializer(child);
 
-            if (serializer != null)
-            {
-                serializer.SerializeObject(child);
-            }
+            serializer?.SerializeObject(child);
         }
 
         private
@@ -251,9 +248,7 @@ private void SerializeChild(Visual child, SerializableObjectContext parentContex
             ReachSerializerContext context
             )
         {
-            ReachFixedPageSerializerContext thisContext = context as ReachFixedPageSerializerContext;
-
-            if(thisContext != null)
+            if(context is ReachFixedPageSerializerContext thisContext)
             {
                 ((XpsSerializationManager)SerializationManager).PackagingPolicy.PreCommitCurrentPage();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentReferenceCollectionSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentReferenceCollectionSerializerAsync.cs
index c620b053..b2d5dce0 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentReferenceCollectionSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachDocumentReferenceCollectionSerializerAsync.cs
@@ -56,10 +56,7 @@ ReachSerializerContext context
 
                 case SerializerAction.serializeNextDocumentReference:
                 {
-                    DocumentReferenceCollectionSerializerContext thisContext = 
-                    context as DocumentReferenceCollectionSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is DocumentReferenceCollectionSerializerContext thisContext)
                     {
                         SerializeNextDocumentReference(thisContext.Enumerator,
                                                        thisContext.ObjectContext);
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializer.cs
index 1bc86918..c74e34da 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializer.cs
@@ -189,16 +189,11 @@ SerializableObjectContext   serializableObjectContext
             {
                 Size fixedPageSize = new Size(fixedPage.Width, fixedPage.Height);
                 ((IXpsSerializationManager)SerializationManager).FixedPageSize = fixedPageSize;
-
-                //
-                // Before we serialize any properties on the FixedPage, we need to
-                // serialize the FixedPage as a Visual
-                //
-                Visual fixedPageAsVisual = serializableObjectContext.TargetObject as Visual;
+                //                // Before we serialize any properties on the FixedPage, we need to                // serialize the FixedPage as a Visual                //
 
                 bool   needEndVisual     = false;
 
-                if(fixedPageAsVisual != null)
+                if(serializableObjectContext.TargetObject is Visual fixedPageAsVisual)
                 {
                     needEndVisual = SerializePageAsVisual(fixedPageAsVisual);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializerAsync.cs
index d837b3ef..13c25239 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachFixedPageSerializerAsync.cs
@@ -214,16 +214,11 @@ SerializableObjectContext   serializableObjectContext
             {
                 Size fixedPageSize = new Size(fixedPage.Width, fixedPage.Height);
                 ((IXpsSerializationManager)SerializationManager).FixedPageSize = fixedPageSize;
-            
-                //
-                // Before we serialize any properties on the FixedPage, we need to 
-                // serialize the FixedPage as a Visual
-                //
-                Visual fixedPageAsVisual = serializableObjectContext.TargetObject as Visual;
+                //                // Before we serialize any properties on the FixedPage, we need to                 // serialize the FixedPage as a Visual                //
 
                 bool   needEndVisual     = false;
 
-                if(fixedPageAsVisual != null)
+                if(serializableObjectContext.TargetObject is Visual fixedPageAsVisual)
                 {
                     needEndVisual = SerializePageAsVisual(fixedPageAsVisual);
                 }
@@ -403,9 +398,7 @@ Visual fixedPageAsVisual
             ReachFixedPageSerializerContext context
             )
         {
-            ReachFixedPageSerializerContext thisContext = context as ReachFixedPageSerializerContext;
-
-            if(thisContext != null)
+            if(context is ReachFixedPageSerializerContext thisContext)
             {
                 if(thisContext.EndVisual)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializer.cs
index d214fe67..39439728 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializer.cs
@@ -115,8 +115,7 @@ SerializableObjectContext serializableObjectContext
 
                 XmlLanguage language = null;
 
-                DependencyObject dependencyObject = paginator.Source as DependencyObject;
-                if (dependencyObject != null)
+                if (paginator.Source is DependencyObject dependencyObject)
                 {
                     language = (XmlLanguage)dependencyObject.GetValue(FrameworkContentElement.LanguageProperty);
                 }
@@ -135,10 +134,7 @@ SerializableObjectContext serializableObjectContext
 
                     ReachSerializer serializer = SerializationManager.GetSerializer(page);
 
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(page);
-                    }
+                    serializer?.SerializeObject(page);
                 }
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializerAsync.cs
index 05a5c1b3..6401342b 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachIDocumentPaginatorSerializerAsync.cs
@@ -155,8 +155,7 @@ SerializableObjectContext serializableObjectContext
 
                 XmlLanguage language = null;
 
-                DependencyObject dependencyObject = paginator.Source as DependencyObject;
-                if (dependencyObject != null)
+                if (paginator.Source is DependencyObject dependencyObject)
                 {
                     language = (XmlLanguage)dependencyObject.GetValue(FrameworkContentElement.LanguageProperty);
                 }
@@ -245,10 +244,7 @@ SerializableObjectContext serializableObjectContext
             ReachSerializerContext  context
             )
         {
-
-            DocumentPaginatorSerializerContext paginatorContext = context as DocumentPaginatorSerializerContext;
-
-            if(paginatorContext != null)
+            if(context is DocumentPaginatorSerializerContext paginatorContext)
             {
                 DocumentPaginator  paginator = paginatorContext.Paginator;
                 int                index     = paginatorContext.Index;
@@ -270,10 +266,7 @@ ReachSerializerContext  context
                     DocumentPage page = Toolbox.GetPage(paginator, index-1);
                     
                     ReachSerializer serializer = SerializationManager.GetSerializer(page);
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(page);
-                    }
+                    serializer?.SerializeObject(page);
                 }
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachObjectContext.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachObjectContext.cs
index e7ec44f3..a9f25ebb 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachObjectContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachObjectContext.cs
@@ -141,9 +141,7 @@ SerializablePropertyContext serializablePropertyContext
                 currentObject != null;
                 currentObject = serializationManager.GraphContextStack[++stackIndex])
             {
-                SerializableObjectContext currentObjectContext = currentObject as SerializableObjectContext;
-
-                if(currentObjectContext!=null &&
+                if(currentObject is SerializableObjectContext currentObjectContext &&
                    currentObjectContext.TargetObject == serializableObject)
                 {
                     throw new XpsSerializationException(SR.Get(SRID.ReachSerialization_CycleDetectedInSerialization));
@@ -363,10 +361,7 @@ SerializablePropertyContext serializablePropertyContext
             _isReadOnlyValue = false;
             _namespaceTable  = null;
 
-            if (_propertiesCollection != null)
-            {
-                _propertiesCollection.Clear();
-            }
+            _propertiesCollection?.Clear();
 
             base.Clear();
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachPageContentCollectionSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachPageContentCollectionSerializerAsync.cs
index 99ed9686..fef8833a 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachPageContentCollectionSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachPageContentCollectionSerializerAsync.cs
@@ -77,10 +77,7 @@ ReachSerializerContext context
 
                 case SerializerAction.serializeNextPageContent:
                 {
-                    PageContentCollectionSerializerContext thisContext = 
-                    context as PageContentCollectionSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is PageContentCollectionSerializerContext thisContext)
                     {
                         SerializeNextPageContent(thisContext.Enumerator,
                                                  thisContext.ObjectContext);
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializableProperties.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializableProperties.cs
index c4a4fc73..104ea39b 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializableProperties.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializableProperties.cs
@@ -809,9 +809,7 @@ PackageSerializationManager serializationManager
 
                         if (!canConvert)
                         {
-                            Expression expr = this.Value as Expression;
-
-                            if (expr != null)
+                            if (this.Value is Expression expr)
                             {
                                 this.Value = ((DependencyObject)this.TargetObject).GetValue((DependencyProperty)this.DependencyProperty);
                                 isComplex = this.IsComplexProperty(serializationManager);
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationCacheItems.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationCacheItems.cs
index 5d92344d..a371fbe6 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationCacheItems.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationCacheItems.cs
@@ -234,17 +234,17 @@ SerializersCacheManager serializersCacheManager
                     Attribute attribute = attributes[numberOfAttributes];
 
 
-                    if (attribute is DesignerSerializationVisibilityAttribute)
+                    if (attribute is DesignerSerializationVisibilityAttribute designerSerializationVisibilityAttribute)
                     {
-                        visibility = ((DesignerSerializationVisibilityAttribute)attribute).Visibility;
+                        visibility = designerSerializationVisibilityAttribute.Visibility;
                     }
-                    else if (attribute is DefaultValueAttribute)
+                    else if (attribute is DefaultValueAttribute defaultValueAttribute)
                     {
-                        defaultValueAttr = (DefaultValueAttribute)attribute;
+                        defaultValueAttr = defaultValueAttribute;
                     }
-                    else if (attribute is DesignerSerializationOptionsAttribute)
+                    else if (attribute is DesignerSerializationOptionsAttribute designerSerializationOptionsAttribute)
                     {
-                        designerSerializationFlagsAttr = (DesignerSerializationOptionsAttribute)attribute;
+                        designerSerializationFlagsAttr = designerSerializationOptionsAttribute;
                     }
                 }
 
@@ -514,17 +514,17 @@ DesignerSerializationOptionsAttribute     designerSerializationFlagsAttr
                 Attribute attribute = attributes[numberOfAttributes];
 
 
-                if (attribute is DesignerSerializationVisibilityAttribute)
+                if (attribute is DesignerSerializationVisibilityAttribute designerSerializationVisibilityAttribute)
                 {
-                    visibility = ((DesignerSerializationVisibilityAttribute)attribute).Visibility;
+                    visibility = designerSerializationVisibilityAttribute.Visibility;
                 }
-                else if (attribute is DefaultValueAttribute)
+                else if (attribute is DefaultValueAttribute defaultValueAttribute)
                 {
-                    defaultValueAttr = (DefaultValueAttribute)attribute;
+                    defaultValueAttr = defaultValueAttribute;
                 }
-                else if (attribute is DesignerSerializationOptionsAttribute)
+                else if (attribute is DesignerSerializationOptionsAttribute designerSerializationOptionsAttribute)
                 {
-                    designerSerializationFlagsAttr = (DesignerSerializationOptionsAttribute)attribute;
+                    designerSerializationFlagsAttr = designerSerializationOptionsAttribute;
                 }
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationUtils.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationUtils.cs
index 503a10b4..00428656 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationUtils.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializationUtils.cs
@@ -1231,8 +1231,7 @@ PrintTicket printTicket
                 Size sz = new Size(0, 0);
 
                 //if print ticket definied, use printTicket dimensions
-                if (printTicket != null &&
-                    printTicket.PageMediaSize != null &&
+                if (printTicket?.PageMediaSize != null &&
                     printTicket.PageMediaSize.Width.HasValue &&
                     printTicket.PageMediaSize.Height.HasValue)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializer.cs
index 2c8690d5..3aa13c44 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializer.cs
@@ -376,10 +376,7 @@ SerializablePropertyContext serializablePropertyContext
                 ReachSerializer serializer = SerializationManager.GetSerializer(serializablePropertyContext.Value);
 
                 // If there is no serializer for this type, we won't serialize this property
-                if(serializer!=null)
-                {
-                    serializer.SerializeObject(serializablePropertyContext);
-                }
+                serializer?.SerializeObject(serializablePropertyContext);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializerAsync.cs
index b0109d7a..057a8edd 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachSerializerAsync.cs
@@ -483,10 +483,7 @@ SerializablePropertyContext serializablePropertyContext
                 ReachSerializer serializer = SerializationManager.GetSerializer(serializablePropertyContext.Value);
 
                 // If there is no serializer for this type, we won't serialize this property
-                if(serializer!=null)
-                {
-                    serializer.SerializeObject(serializablePropertyContext);
-                }
+                serializer?.SerializeObject(serializablePropertyContext);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializer.cs
index 7feac797..c47c8e4b 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializer.cs
@@ -150,9 +150,7 @@ SerializableObjectContext   serializableObjectContext
             object uiElement
             )
         {
-            Visual visual = uiElement as Visual;
-
-            if(visual != null)
+            if(uiElement is Visual visual)
             {
                 ReachSerializer serializer = SerializationManager.GetSerializer(visual);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializerAsync.cs
index bb64e35e..c6ec6982 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachUIElementCollectionSerializerAsync.cs
@@ -79,9 +79,7 @@ ReachSerializerContext context
 
                 case SerializerAction.serializeNextUIElement:
                 {
-                    UIElementCollectionSerializerContext thisContext = context as UIElementCollectionSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is UIElementCollectionSerializerContext thisContext)
                     {
                         SerializeNextUIElement(thisContext.Enumerator,
                                                thisContext.ObjectContext);
@@ -214,9 +212,7 @@ SerializableObjectContext   serializableObjectContext
             object uiElement
             )
         {
-            Visual visual = uiElement as Visual;
-
-            if(visual != null)
+            if(uiElement is Visual visual)
             {
                 ReachSerializer serializer = SerializationManager.GetSerializer(visual);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachVisualSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachVisualSerializerAsync.cs
index cf12a78f..956c94fe 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachVisualSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/ReachVisualSerializerAsync.cs
@@ -54,9 +54,7 @@ ReachSerializerContext context
             {
                 case SerializerAction.serializeNextTreeNode:
                 {
-                    ReachVisualSerializerContext thisContext = context as ReachVisualSerializerContext;
-
-                    if(thisContext != null)
+                    if(context is ReachVisualSerializerContext thisContext)
                     {
                         SerializeNextTreeNode(thisContext);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPageSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPageSerializer.cs
index fa2960cd..c81a3aeb 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPageSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPageSerializer.cs
@@ -225,10 +225,7 @@ SerializableObjectContext parentContext
         {
             ReachSerializer serializer = SerializationManager.GetSerializer(child);
 
-            if (serializer != null)
-            {
-                serializer.SerializeObject(child);
-            }
+            serializer?.SerializeObject(child);
         }
 
         private 
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializer.cs
index 128c9a8e..b759b46a 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializer.cs
@@ -91,10 +91,7 @@ SerializableObjectContext serializableObjectContext
 
                 ReachSerializer serializer = SerializationManager.GetSerializer(page);
 
-                if (serializer != null)
-                {
-                    serializer.SerializeObject(page);
-                }
+                serializer?.SerializeObject(page);
             }
 
             EndPersistObjectData();
@@ -134,8 +131,7 @@ SerializableObjectContext serializableObjectContext
 
             XmlLanguage language = null;
 
-            DependencyObject dependencyObject = paginator.Source as DependencyObject;
-            if (dependencyObject != null)
+            if (paginator.Source is DependencyObject dependencyObject)
             {
                 language = (XmlLanguage)dependencyObject.GetValue(FrameworkContentElement.LanguageProperty);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializerAsync.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializerAsync.cs
index 069d1fda..ed33c263 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializerAsync.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMDocumentPaginatorSerializerAsync.cs
@@ -128,10 +128,7 @@ SerializableObjectContext serializableObjectContext
             ReachSerializerContext context
             )
         {
-
-            DocumentPaginatorSerializerContext paginatorContext = context as DocumentPaginatorSerializerContext;
-
-            if (paginatorContext != null)
+            if (context is DocumentPaginatorSerializerContext paginatorContext)
             {
                 DocumentPaginator paginator = paginatorContext.Paginator;
                 int index = paginatorContext.Index;
@@ -152,10 +149,7 @@ ReachSerializerContext context
                     DocumentPage page = Toolbox.GetPage(paginator, index - 1);
 
                     ReachSerializer serializer = SerializationManager.GetSerializer(page);
-                    if (serializer != null)
-                    {
-                        serializer.SerializeObject(page);
-                    }
+                    serializer?.SerializeObject(page);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMFixedPageSerializer.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMFixedPageSerializer.cs
index 18fa49f9..51cc74eb 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMFixedPageSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMFixedPageSerializer.cs
@@ -179,16 +179,11 @@ SerializableObjectContext serializableObjectContext
 
             Size fixedPageSize = new Size(fixedPage.Width, fixedPage.Height);
             _xpsOMSerializationManager.FixedPageSize = fixedPageSize;
-
-            //
-            // Before we serialize any properties on the FixedPage, we need to
-            // serialize the FixedPage as a Visual
-            //
-            Visual fixedPageAsVisual = serializableObjectContext.TargetObject as Visual;
+            //            // Before we serialize any properties on the FixedPage, we need to            // serialize the FixedPage as a Visual            //
 
             bool needEndVisual = false;
 
-            if (fixedPageAsVisual != null)
+            if (serializableObjectContext.TargetObject is Visual fixedPageAsVisual)
             {
                 needEndVisual = SerializePageAsVisual(fixedPageAsVisual);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMPackagingPolicy.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMPackagingPolicy.cs
index f52357e4..f26a71a4 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMPackagingPolicy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsOMPackagingPolicy.cs
@@ -734,10 +734,7 @@ string resourceId
             _currentPageContentStream = null;
             _currentResourceStream = null;
 
-            if (_currentFixedPagePrintStream != null)
-            {
-                _currentFixedPagePrintStream.Dispose();
-            }
+            _currentFixedPagePrintStream?.Dispose();
             _currentFixedPagePrintStream = null;
             _currentPageContentXmlWriter = null;
             _currentResourceXmlWriter = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsPackagingPolicy.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsPackagingPolicy.cs
index 4e95afca..8799dc73 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsPackagingPolicy.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsPackagingPolicy.cs
@@ -1463,25 +1463,13 @@ PackagingProgressEventHandler PackagingProgressEvent
             _currentXpsColorContextRef = 0;
             _currentXpsResourceDictionaryRef = 0;
 
-            if(_fontResourceStream!=null)
-            {
-                _fontResourceStream.Initialize();
-            }
+            _fontResourceStream?.Initialize();
 
-            if(_imageResourceStream!=null)
-            {
-                _imageResourceStream.Initialize();
-            }
+            _imageResourceStream?.Initialize();
 
-            if(_colorContextResourceStream!=null)
-            {
-                _colorContextResourceStream.Initialize();
-            }
+            _colorContextResourceStream?.Initialize();
 
-            if(_resourceDictionaryResourceStream!=null)
-            {
-                _resourceDictionaryResourceStream.Initialize();
-            }
+            _resourceDictionaryResourceStream?.Initialize();
 
 
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsSerializationManager.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsSerializationManager.cs
index bcca8826..c4fc61a9 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsSerializationManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/Serialization/manager/XpsSerializationManager.cs
@@ -589,8 +589,7 @@ Type    writerType
             //
             if( subsetComplete && refCnt == 0 )
             {
-                XpsPackagingPolicy xpsPackagingPolicy = _packagingPolicy as  XpsPackagingPolicy;
-                if(xpsPackagingPolicy != null )
+                if(_packagingPolicy is XpsPackagingPolicy xpsPackagingPolicy )
                 {
                     xpsPackagingPolicy.InterleavingPolicy.SignalSubsetComplete();
                 }
@@ -852,10 +851,7 @@ ReachSerializationServices  reachSerializationServices
             string relationshipName
             )
         {
-            if (_packagingPolicy != null)
-            {
-                _packagingPolicy.RelateResourceToCurrentPage(targetUri, relationshipName);
-            }
+            _packagingPolicy?.RelateResourceToCurrentPage(targetUri, relationshipName);
         }
 
         internal
diff --git a/src/Microsoft.DotNet.Wpf/src/ReachFramework/SerializerFactory/XpsSerializerWriter.cs b/src/Microsoft.DotNet.Wpf/src/ReachFramework/SerializerFactory/XpsSerializerWriter.cs
index ccf221a6..f4db93f4 100644
--- a/src/Microsoft.DotNet.Wpf/src/ReachFramework/SerializerFactory/XpsSerializerWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/ReachFramework/SerializerFactory/XpsSerializerWriter.cs
@@ -443,18 +443,12 @@ public override SerializerWriterCollator CreateVisualsCollator(PrintTicket docum
 
         private void xsw_WritingPrintTicketRequired(object sender, WritingPrintTicketRequiredEventArgs e)
         {
-            if (WritingPrintTicketRequired != null)
-            {
-                WritingPrintTicketRequired.Invoke(sender, e);
-            }
+            WritingPrintTicketRequired?.Invoke(sender, e);
         }
 
         private void xsw_WritingProgressChanged(object sender, WritingProgressChangedEventArgs e)
         {
-            if ( WritingProgressChanged != null)
-            {
-                WritingProgressChanged.Invoke(sender, e);
-            }
+            WritingProgressChanged?.Invoke(sender, e);
         }
 
         private void xsw_WritingCompleted(object sender, WritingCompletedEventArgs e)
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/AppDomainShutdownMonitor.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/AppDomainShutdownMonitor.cs
index 6fb99632..2081f76f 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/AppDomainShutdownMonitor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/AppDomainShutdownMonitor.cs
@@ -73,10 +73,7 @@ private static void OnShutdown(object sender, EventArgs e)
             foreach (WeakReference value in _dictionary.Values)
             {
                 IAppDomainShutdownListener listener = value.Target as IAppDomainShutdownListener;
-                if (listener != null)
-                {
-                    listener.NotifyShutdown();
-                }
+                listener?.NotifyShutdown();
             }
         }
         
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/IO/Packaging/PackagingUtilities.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/IO/Packaging/PackagingUtilities.cs
index d7e5bad4..863b3019 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/IO/Packaging/PackagingUtilities.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/IO/Packaging/PackagingUtilities.cs
@@ -72,7 +72,7 @@ internal static void PerformInitailReadAndVerifyEncoding(XmlTextReader reader)
                 string encoding;
                 encoding = reader.GetAttribute(_encodingAttribute);
 
-                if (encoding != null && encoding.Length > 0)
+                if (!string.IsNullOrEmpty(encoding))
                 {
                     encoding = encoding.ToUpperInvariant();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Invariant.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Invariant.cs
index e0bea359..e7470b3a 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Invariant.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Invariant.cs
@@ -254,7 +254,7 @@ private static bool IsDialogOverrideEnabled
                     enabled = (dbgJITDebugLaunchSettingValue is int && ((int)dbgJITDebugLaunchSettingValue & 2) != 0);
                     if (enabled)
                     {
-                        enabled = dbgManagedDebuggerValue != null && dbgManagedDebuggerValue.Length > 0;
+                        enabled = !string.IsNullOrEmpty(dbgManagedDebuggerValue);
                     }
                 }
                 return enabled;
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Pair.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Pair.cs
index f263f59f..c18541fc 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Pair.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/Pair.cs
@@ -43,8 +43,7 @@ public override int GetHashCode()
 
         public override bool Equals(object o)
         {
-            Pair other = o as Pair;
-            return other != null &&
+            return o is Pair other &&
                 (_first != null ? _first.Equals(other._first) : other._first == null) &&
                 (_second != null ? _second.Equals(other._second) : other._second == null);
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/PointUtil.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/PointUtil.cs
index 0d86f625..cfc80222 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/PointUtil.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/PointUtil.cs
@@ -43,7 +43,7 @@ public static Point ClientToRoot(Point point, PresentationSource presentationSou
         public static Point TryClientToRoot(Point point, PresentationSource presentationSource, bool throwOnError, out bool success)
         {
             // Only do if we allow throwing on error or have a valid PresentationSource and CompositionTarget.
-            if (throwOnError || (presentationSource != null && presentationSource.CompositionTarget != null && !presentationSource.CompositionTarget.IsDisposed))
+            if (throwOnError || (presentationSource?.CompositionTarget != null && !presentationSource.CompositionTarget.IsDisposed))
             {
                 // Convert from pixels into measure units.
                 point = presentationSource.CompositionTarget.TransformFromDevice.Transform(point);
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/SafeSecurityHelper.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/SafeSecurityHelper.cs
index c7f53c0d..3ed3fa40 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/SafeSecurityHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/SafeSecurityHelper.cs
@@ -394,8 +394,7 @@ public override int GetHashCode()
 
         public override bool Equals(object o)
         {
-            WeakRefKey weakRef = o as WeakRefKey;
-            if (weakRef != null)
+            if (o is WeakRefKey weakRef)
             {
                 object target1 = Target;
                 object target2 = weakRef.Target;
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/WindowsRuntime/ReflectionHelper.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/WindowsRuntime/ReflectionHelper.cs
index 62bb81a4..10a89ff7 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/WindowsRuntime/ReflectionHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Internal/WindowsRuntime/ReflectionHelper.cs
@@ -335,7 +335,7 @@ public static object ReflectionNew<TArg1>(this Type type, TArg1 arg1)
                 ConstructorInfo constructor = type.GetConstructor(new Type[] { typeof(TArg1) });
                 if (constructor == null)
                 {
-                    string constructorName = string.Format("{0}.{1}({2})", type.FullName, type.Name, typeof(TArg1).Name);
+                    string constructorName = $"{type.FullName}.{type.Name}({typeof(TArg1).Name})";
                     throw new MissingMethodException(constructorName);
                 }
 
@@ -362,7 +362,7 @@ public static object ReflectionNew<TArg1>(this Type type, TArg1 arg1)
                 ConstructorInfo constructor = type.GetConstructor(new Type[] { typeof(TArg1), typeof(TArg2) });
                 if (constructor == null)
                 {
-                    string constructorName = string.Format("{0}.{1}({2},{3})", type.FullName, type.Name, typeof(TArg1).Name, typeof(TArg2).Name);
+                    string constructorName = $"{type.FullName}.{type.Name}({typeof(TArg1).Name},{typeof(TArg2).Name})";
                     throw new MissingMethodException(constructorName);
                 }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/DpiAwarenessContext/DpiAwarenessContextHandle.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/DpiAwarenessContext/DpiAwarenessContextHandle.cs
index 98e3df3a..8d317719 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/DpiAwarenessContext/DpiAwarenessContextHandle.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/DpiAwarenessContext/DpiAwarenessContextHandle.cs
@@ -179,17 +179,17 @@ public bool Equals(DpiAwarenessContextValue dpiContextEnumValue)
         /// <inheritdoc/>
         public override bool Equals(object obj)
         {
-            if (obj is IntPtr)
+            if (obj is IntPtr intPtr)
             {
-                return this.Equals((IntPtr)obj);
+                return this.Equals(intPtr);
             }
-            else if (obj is DpiAwarenessContextHandle)
+            else if (obj is DpiAwarenessContextHandle dpiAwarenessContextHandle)
             {
-                return this.Equals((DpiAwarenessContextHandle)obj);
+                return this.Equals(dpiAwarenessContextHandle);
             }
-            else if (obj is DpiAwarenessContextValue)
+            else if (obj is DpiAwarenessContextValue dpiAwarenessContextValue)
             {
-                return this.Equals((DpiAwarenessContextValue)obj);
+                return this.Equals(dpiAwarenessContextValue);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/FrugalMap.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/FrugalMap.cs
index af526a4b..e435d339 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/FrugalMap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/FrugalMap.cs
@@ -1794,10 +1794,7 @@ public void Iterate(ArrayList list, FrugalMapIterationCallback callback)
             {
                 if (null != list)
                 {
-                    if (_mapStore != null)
-                    {
-                        _mapStore.Iterate(list, callback);
-                    }
+                    _mapStore?.Iterate(list, callback);
                 }
                 else
                 {
@@ -2143,10 +2140,7 @@ public void Iterate(ArrayList list, FrugalMapIterationCallback callback)
             {
                 if (null != list)
                 {
-                    if (_mapStore != null)
-                    {
-                        _mapStore.Iterate(list, callback);
-                    }
+                    _mapStore?.Iterate(list, callback);
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/Maps.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/Maps.cs
index 9281bbc4..f46fe2fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/Maps.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/Maps.cs
@@ -97,10 +97,7 @@ public void Clear()
                 _activeDTypes.List[i] = null;
             }
 
-            if (_overFlow != null)
-            {
-                _overFlow.Clear();
-            }
+            _overFlow?.Clear();
         }
 
         private int _entryCount;
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/TraceProvider.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/TraceProvider.cs
index de57b306..e85d7922 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/TraceProvider.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Utility/TraceProvider.cs
@@ -273,8 +273,7 @@ private static unsafe string EncodeObject(ref object data, EventData* dataDescri
         {
             dataDescriptor->Reserved = 0;
 
-            string sRet = data as string;
-            if (sRet != null)
+            if (data is string sRet)
             {
                 dataDescriptor->Size = (uint)((sRet.Length + 1) * 2);
                 return sRet;
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Win32/HwndSubclass.cs b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Win32/HwndSubclass.cs
index 3048eafd..1f7c3682 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/MS/Win32/HwndSubclass.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/MS/Win32/HwndSubclass.cs
@@ -421,9 +421,7 @@ private object DispatcherCallbackOperation(object o)
             param.retVal = IntPtr.Zero;
             if (_bond == Bond.Attached)
             {
-                HwndWrapperHook hook= _hook.Target as HwndWrapperHook;
-
-                if (hook != null)
+                if (_hook.Target is HwndWrapperHook hook)
                 {
                     // make the call
                     param.retVal = hook(param.hwnd, param.msg, param.wParam, param.lParam, ref param.handled);
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/InterOp/OSVersionHelper.cs b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/InterOp/OSVersionHelper.cs
index 4917407d..e34ce5b6 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/InterOp/OSVersionHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/InterOp/OSVersionHelper.cs
@@ -251,7 +251,7 @@ internal static bool IsOsVersionOrGreater(OperatingSystemVersion osVer)
                     return IsOsWindowsXPSP2OrGreater;
             }
 
-            throw new ArgumentException(string.Format("{0} is not a valid OS!", osVer.ToString()), "osVer");
+            throw new ArgumentException($"{osVer.ToString()} is not a valid OS!", "osVer");
         }
 
         internal static OperatingSystemVersion GetOsVersion()
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/Replacements/TypeUriConverter.cs b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/Replacements/TypeUriConverter.cs
index 9cf895d8..b4c52947 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/Replacements/TypeUriConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/Replacements/TypeUriConverter.cs
@@ -41,8 +41,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         /// <inheritdoc />
         public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
         {
-            var uri = value as Uri;
-            if (uri != null)
+            if (value is Uri uri)
             {
                 var uriKind = UriKind.RelativeOrAbsolute;
                 if (uri.IsWellFormedOriginalString())
@@ -82,8 +81,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
         /// <inheritdoc />
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
         {
-            var uriString = value as string;
-            if (uriString != null)
+            if (value is string uriString)
             {
                 if (Uri.IsWellFormedUriString(uriString, UriKind.Absolute))
                 {
@@ -98,8 +96,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 return new Uri(uriString, UriKind.RelativeOrAbsolute);
             }
 
-            var uri = value as Uri;
-            if (uri != null)
+            if (value is Uri uri)
             {
                 if (uri.IsWellFormedOriginalString())
                 {
@@ -115,8 +112,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
         /// <inheritdoc />
         public override bool IsValid(ITypeDescriptorContext context, object value)
         {
-            var uriString = value as string;
-            if (uriString != null)
+            if (value is string uriString)
             {
                 return Uri.TryCreate(uriString, UriKind.RelativeOrAbsolute, out _);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/RuntimeIdentifierPropertyAttribute.cs b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/RuntimeIdentifierPropertyAttribute.cs
index 6362ed6d..c5a9478a 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/RuntimeIdentifierPropertyAttribute.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/RuntimeIdentifierPropertyAttribute.cs
@@ -70,9 +70,7 @@ internal static class NameValidationHelper
         [FriendAccessAllowed] // Built into Base, used by Core and Framework.
         internal static bool NameValidationCallback(object candidateName)
         {
-            string name = candidateName as string;
-
-            if( name != null )
+            if( candidateName is string name )
             {
                 // Non-null string, ask the XAML validation code for blessing.
                 return IsValidIdentifierName(name);
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/TypeConverterHelper.cs b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/TypeConverterHelper.cs
index e2478afa..209af958 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/TypeConverterHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Markup/TypeConverterHelper.cs
@@ -45,10 +45,10 @@ internal static MemberInfo GetMemberInfoForPropertyConverter(object dpOrPiOrMi)
             if (memberInfo == null)
             {
                 MethodInfo methodInfo;
+
 #if !PBTCOMPILER
-                DependencyProperty dp = dpOrPiOrMi as DependencyProperty;
 
-                if (dp != null)
+                if (dpOrPiOrMi is DependencyProperty dp)
                 {
                     // While parsing styles or templates, we end up getting a DependencyProperty,
                     // even for non-attached cases. In this case, we try fetching the CLR
diff --git a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Media/TypeConverterHelper.cs b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Media/TypeConverterHelper.cs
index 0d835908..0ebd4997 100644
--- a/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Media/TypeConverterHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Shared/System/Windows/Media/TypeConverterHelper.cs
@@ -63,9 +63,9 @@ internal static UriHolder GetUriFromUriContext(ITypeDescriptorContext context, o
         {
             UriHolder uriHolder = new UriHolder();
 
-            if (inputString is string)
+            if (inputString is string s)
             {
-                uriHolder.OriginalUri = new Uri((string)inputString, UriKind.RelativeOrAbsolute);
+                uriHolder.OriginalUri = new Uri(s, UriKind.RelativeOrAbsolute);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonAutomationPeer.cs
index aac6e712..239e70d5 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonAutomationPeer.cs
@@ -103,8 +103,7 @@ protected override System.Collections.Generic.List<AutomationPeer> GetChildrenCo
                 AutomationPeer peer = CreatePeerForElement(OwningRibbon.TitleHost);
                 if (peer == null)
                 {
-                    FrameworkElement titleHost = OwningRibbon.TitleHost as FrameworkElement;
-                    if (titleHost != null)
+                    if (OwningRibbon.TitleHost is FrameworkElement titleHost)
                         peer = new RibbonTitleAutomationPeer(titleHost);
                     else
                         peer = new UIElementAutomationPeer(OwningRibbon.TitleHost);
@@ -138,10 +137,7 @@ protected override System.Collections.Generic.List<AutomationPeer> GetChildrenCo
             {
 #if RIBBON_IN_FRAMEWORK
                 AutomationPeer peer = CreatePeerForElement(OwningRibbon.RibbonTabHeaderItemsControl);
-                if (peer != null)
-                {
-                    peer.ForceEnsureChildren();
-                }
+                peer?.ForceEnsureChildren();
 #else
                 // We are unable to use this commented piece of code because ForceEnsureChildren 
                 // is an internal method in .Net 4.0. The public alternative is to use 
@@ -211,8 +207,7 @@ protected override System.Collections.Generic.List<AutomationPeer> GetChildrenCo
                 AutomationPeer peer = CreatePeerForElement(helpPaneHost);
                 if (peer == null)
                 {
-                    FrameworkElement helpPaneHostFE = helpPaneHost as FrameworkElement;
-                    if (helpPaneHostFE != null)
+                    if (helpPaneHost is FrameworkElement helpPaneHostFE)
                         peer = new FrameworkElementAutomationPeer(helpPaneHostFE);
                     else
                         peer = new UIElementAutomationPeer(helpPaneHost);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonButtonAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonButtonAutomationPeer.cs
index e50f0a04..73e77e25 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonButtonAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonButtonAutomationPeer.cs
@@ -83,8 +83,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonButton)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonButton)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonCheckBoxAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonCheckBoxAutomationPeer.cs
index 99a9a13c..eeaf4347 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonCheckBoxAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonCheckBoxAutomationPeer.cs
@@ -85,8 +85,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonCheckBox)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonCheckBox)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupAutomationPeer.cs
index d3202e25..2a5512f3 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupAutomationPeer.cs
@@ -41,10 +41,9 @@ protected override string GetNameCore()
             if (String.IsNullOrEmpty(name))
             {
                 RibbonContextualTabGroup tabGroup = Owner as RibbonContextualTabGroup;
-                if (tabGroup != null && tabGroup.Header != null)
+                if (tabGroup?.Header != null)
                 {
-                    UIElement headerElement = tabGroup.Header as UIElement;
-                    if (headerElement != null)
+                    if (tabGroup.Header is UIElement headerElement)
                     {
                         AutomationPeer peer = CreatePeerForElement(headerElement);
                         if (peer != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupDataAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupDataAutomationPeer.cs
index 20f81d56..617162fb 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupDataAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonContextualTabGroupDataAutomationPeer.cs
@@ -44,7 +44,7 @@ void IInvokeProvider.Invoke()
         {
             RibbonContextualTabGroup group = GetWrapper() as RibbonContextualTabGroup;
             // Select the first Tab
-            if (group != null && group.Ribbon != null)
+            if (group?.Ribbon != null)
             {
                 group.Ribbon.NotifyMouseClickedOnContextualTabGroup(group);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryAutomationPeer.cs
index 0ac7dc11..f446c024 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryAutomationPeer.cs
@@ -63,8 +63,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonGallery)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonGallery)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryCategoryDataAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryCategoryDataAutomationPeer.cs
index 4472d4c9..d00ab3a6 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryCategoryDataAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryCategoryDataAutomationPeer.cs
@@ -58,8 +58,7 @@ override public object GetPattern(PatternInterface patternInterface)
                 return this;
             }
 
-            RibbonGalleryCategoryAutomationPeer wrapperPeer = GetWrapperPeer() as RibbonGalleryCategoryAutomationPeer;
-            if (wrapperPeer != null)
+            if (GetWrapperPeer() is RibbonGalleryCategoryAutomationPeer wrapperPeer)
             {
                 return wrapperPeer.GetPattern(patternInterface);
             }
@@ -77,10 +76,7 @@ override public object GetPattern(PatternInterface patternInterface)
         void IScrollItemProvider.ScrollIntoView()
         {
             RibbonGalleryCategory category = GetWrapper() as RibbonGalleryCategory;
-            if (category != null)
-            {
-                category.BringIntoView();
-            }
+            category?.BringIntoView();
         }
 
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemAutomationPeer.cs
index 658ef6f6..2f166a08 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemAutomationPeer.cs
@@ -65,8 +65,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonGalleryItem)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonGalleryItem)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
@@ -104,23 +103,14 @@ override protected bool IsOffscreenCore()
         [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
         internal void RaiseAutomationIsSelectedChanged(bool isSelected)
         {
-            if (EventsSource != null)
-            {
-                EventsSource.RaisePropertyChangedEvent(
-                    SelectionItemPatternIdentifiers.IsSelectedProperty,
-                        !isSelected,
-                        isSelected);
-            }
+            EventsSource?.RaisePropertyChangedEvent(SelectionItemPatternIdentifiers.IsSelectedProperty, !isSelected, isSelected);
         }
 
 
         // Selection Events needs to be raised on DataItem Peers now when they exist.
         internal void RaiseAutomationSelectionEvent(AutomationEvents eventId)
         {
-            if (EventsSource != null)
-            {
-                EventsSource.RaiseAutomationEvent(eventId);
-            }
+            EventsSource?.RaiseAutomationEvent(eventId);
         }
 
         #endregion Selection Events
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemDataAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemDataAutomationPeer.cs
index e7681dd6..dbc02f70 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemDataAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGalleryItemDataAutomationPeer.cs
@@ -85,10 +85,7 @@ public RibbonGalleryCategoryDataAutomationPeer ParentCategoryDataAutomationPeer
         void IScrollItemProvider.ScrollIntoView()
         {
             RibbonGalleryItem ribbonGalleryItem = GetWrapper() as RibbonGalleryItem;
-            if (ribbonGalleryItem != null)
-            {
-                ribbonGalleryItem.BringIntoView();
-            }
+            ribbonGalleryItem?.BringIntoView();
         }
 
         #endregion
@@ -118,8 +115,7 @@ bool ISelectionItemProvider.IsSelected
 
         void ISelectionItemProvider.RemoveFromSelection()
         {
-            RibbonGalleryItem ribbonGalleryItem = GetWrapper() as RibbonGalleryItem;
-            if (ribbonGalleryItem != null)
+            if (GetWrapper() is RibbonGalleryItem ribbonGalleryItem)
             {
                 ribbonGalleryItem.IsSelected = false;
             }
@@ -129,8 +125,7 @@ void ISelectionItemProvider.RemoveFromSelection()
 
         void ISelectionItemProvider.Select()
         {
-            RibbonGalleryItem ribbonGalleryItem = GetWrapper() as RibbonGalleryItem;
-            if (ribbonGalleryItem != null)
+            if (GetWrapper() is RibbonGalleryItem ribbonGalleryItem)
             {
                 ribbonGalleryItem.IsSelected = true;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupAutomationPeer.cs
index 12ec9e31..b66903d6 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupAutomationPeer.cs
@@ -134,13 +134,7 @@ RibbonGroupHeaderAutomationPeer HeaderPeer
         internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue)
         {
             AutomationPeer dataPeer = EventsSource;
-            if (dataPeer != null)
-            {
-                dataPeer.RaisePropertyChangedEvent(
-                ExpandCollapsePatternIdentifiers.ExpandCollapseStateProperty,
-                oldValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed,
-                newValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed);
-            }
+            dataPeer?.RaisePropertyChangedEvent(ExpandCollapsePatternIdentifiers.ExpandCollapseStateProperty, oldValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed, newValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed);
         }
 
         private RibbonGroupHeaderAutomationPeer _headerPeer;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupDataAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupDataAutomationPeer.cs
index da66a5a3..2ee54312 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupDataAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonGroupDataAutomationPeer.cs
@@ -49,8 +49,7 @@ public override object GetPattern(PatternInterface patternInterface)
             else if (patternInterface == PatternInterface.ExpandCollapse)
             {
                 // only if RibbonGroup is Collapsed this Pattern applies.
-                RibbonGroup wrapperGroup = GetWrapper() as RibbonGroup;
-                if (wrapperGroup != null && wrapperGroup.IsCollapsed)
+                if (GetWrapper() is RibbonGroup wrapperGroup && wrapperGroup.IsCollapsed)
                 {
                     peer = this;
                 }
@@ -88,10 +87,7 @@ protected override string GetClassNameCore()
         void IScrollItemProvider.ScrollIntoView()
         {
             RibbonGroup wrapper = GetWrapper() as RibbonGroup;
-            if (wrapper != null)
-            {
-                wrapper.BringIntoView();
-            }
+            wrapper?.BringIntoView();
         }
 
         #endregion
@@ -104,8 +100,7 @@ void IScrollItemProvider.ScrollIntoView()
         /// </summary>
         void IExpandCollapseProvider.Collapse()
         {
-            RibbonGroup wrapperGroup = GetWrapper() as RibbonGroup;
-            if (wrapperGroup != null && wrapperGroup.IsCollapsed)
+            if (GetWrapper() is RibbonGroup wrapperGroup && wrapperGroup.IsCollapsed)
             {
                 wrapperGroup.IsDropDownOpen = false;
             }
@@ -116,8 +111,7 @@ void IExpandCollapseProvider.Collapse()
         /// </summary>
         void IExpandCollapseProvider.Expand()
         {
-            RibbonGroup wrapperGroup = GetWrapper() as RibbonGroup;
-            if (wrapperGroup != null && wrapperGroup.IsCollapsed)
+            if (GetWrapper() is RibbonGroup wrapperGroup && wrapperGroup.IsCollapsed)
             {
                 wrapperGroup.IsDropDownOpen = true;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuButtonAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuButtonAutomationPeer.cs
index d7f4093f..4c20e160 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuButtonAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuButtonAutomationPeer.cs
@@ -50,7 +50,7 @@ protected override List<AutomationPeer> GetChildrenCore()
 
             // Add PartToggleButton to the children collection.  Partially fixes Dev11 42908.
             RibbonMenuButton owner = OwningMenuButton;
-            if (owner != null && owner.PartToggleButton != null )
+            if (owner?.PartToggleButton != null )
             {
                 AutomationPeer peer = CreatePeerForElement(owner.PartToggleButton);
                 if (peer != null)
@@ -122,8 +122,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonMenuButton)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonMenuButton)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemAutomationPeer.cs
index 1531d0a7..9a1e2521 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemAutomationPeer.cs
@@ -71,8 +71,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonMenuItem)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonMenuItem)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
@@ -100,13 +99,7 @@ internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue)
         {
             AutomationPeer dataPeer = EventsSource;
 
-            if (dataPeer != null)
-            {
-                dataPeer.RaisePropertyChangedEvent(
-                    ExpandCollapsePatternIdentifiers.ExpandCollapseStateProperty,
-                    oldValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed,
-                    newValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed);
-            }
+            dataPeer?.RaisePropertyChangedEvent(ExpandCollapsePatternIdentifiers.ExpandCollapseStateProperty, oldValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed, newValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed);
         }
 
         [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
@@ -114,10 +107,7 @@ internal void RaiseToggleStatePropertyChangedEvent(bool oldValue, bool newValue)
         {
             AutomationPeer dataPeer = EventsSource;
 
-            if (dataPeer != null)
-            {
-                dataPeer.RaisePropertyChangedEvent(TogglePatternIdentifiers.ToggleStateProperty, ConvertToToggleState(oldValue), ConvertToToggleState(newValue));
-            }
+            dataPeer?.RaisePropertyChangedEvent(TogglePatternIdentifiers.ToggleStateProperty, ConvertToToggleState(oldValue), ConvertToToggleState(newValue));
         }
 
         private static ToggleState ConvertToToggleState(bool value)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemDataAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemDataAutomationPeer.cs
index e948bd4b..af04e240 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemDataAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonMenuItemDataAutomationPeer.cs
@@ -145,8 +145,7 @@ void IExpandCollapseProvider.Expand()
                 throw new ElementNotAvailableException(Microsoft.Windows.Controls.SR.Get(Microsoft.Windows.Controls.SRID.VirtualizedElement));
             }
 
-            RibbonMenuItem menuItemOwner = owner as RibbonMenuItem;
-            if (menuItemOwner != null)
+            if (owner is RibbonMenuItem menuItemOwner)
             {
                 MenuItemRole role = menuItemOwner.Role;
 
@@ -176,8 +175,7 @@ void IExpandCollapseProvider.Collapse()
                 throw new ElementNotAvailableException(Microsoft.Windows.Controls.SR.Get(Microsoft.Windows.Controls.SRID.VirtualizedElement));
             }
 
-            RibbonMenuItem menuItemOwner = owner as RibbonMenuItem;
-            if (menuItemOwner != null)
+            if (owner is RibbonMenuItem menuItemOwner)
             {
                 MenuItemRole role = menuItemOwner.Role;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonRadioButtonAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonRadioButtonAutomationPeer.cs
index 617b49ed..d81646b4 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonRadioButtonAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonRadioButtonAutomationPeer.cs
@@ -83,8 +83,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonRadioButton)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonRadioButton)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonSplitButtonAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonSplitButtonAutomationPeer.cs
index 5579741d..308b4dbe 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonSplitButtonAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonSplitButtonAutomationPeer.cs
@@ -80,8 +80,7 @@ void IToggleProvider.Toggle()
 
             if (OwningSplitButton.HeaderButton != null)
             {
-                ToggleButtonAutomationPeer headerButtonAutomationPeer = CreatePeerForElement(OwningSplitButton.HeaderButton) as ToggleButtonAutomationPeer;
-                if (headerButtonAutomationPeer != null)
+                if (CreatePeerForElement(OwningSplitButton.HeaderButton) is ToggleButtonAutomationPeer headerButtonAutomationPeer)
                 {
                     ((IToggleProvider)headerButtonAutomationPeer).Toggle();
                 }
@@ -113,8 +112,7 @@ void IInvokeProvider.Invoke()
 
             if (OwningSplitButton.HeaderButton != null)
             {
-                ButtonAutomationPeer headerButtonAutomationPeer = CreatePeerForElement(OwningSplitButton.HeaderButton) as ButtonAutomationPeer;
-                if (headerButtonAutomationPeer != null)
+                if (CreatePeerForElement(OwningSplitButton.HeaderButton) is ButtonAutomationPeer headerButtonAutomationPeer)
                 {
                     ((IInvokeProvider)headerButtonAutomationPeer).Invoke();
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabAutomationPeer.cs
index d8a630b2..b21a9816 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabAutomationPeer.cs
@@ -143,13 +143,7 @@ internal void RaiseTabExpandCollapseAutomationEvent(bool oldValue, bool newValue
         {
             AutomationPeer dataPeer = EventsSource;
 
-            if (dataPeer != null)
-            {
-                dataPeer.RaisePropertyChangedEvent(
-                    ExpandCollapsePatternIdentifiers.ExpandCollapseStateProperty,
-                    oldValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed,
-                    newValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed);
-            }
+            dataPeer?.RaisePropertyChangedEvent(ExpandCollapsePatternIdentifiers.ExpandCollapseStateProperty, oldValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed, newValue ? ExpandCollapseState.Expanded : ExpandCollapseState.Collapsed);
         }
 
         // Never inline, as we don't want to unnecessarily link the 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabDataAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabDataAutomationPeer.cs
index 6c9fdb47..c373d551 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabDataAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTabDataAutomationPeer.cs
@@ -176,7 +176,7 @@ void ISelectionItemProvider.AddToSelection()
         void IScrollItemProvider.ScrollIntoView()
         {
             RibbonTab wrapperTab = GetWrapper() as RibbonTab;
-            if (wrapperTab != null && wrapperTab.RibbonTabHeader != null )
+            if (wrapperTab?.RibbonTabHeader != null )
             {
                 wrapperTab.RibbonTabHeader.BringIntoView();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTextBoxAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTextBoxAutomationPeer.cs
index 2c39fa20..663845f6 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTextBoxAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTextBoxAutomationPeer.cs
@@ -89,8 +89,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonTextBox)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonTextBox)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
@@ -107,8 +106,7 @@ protected override string GetAcceleratorKeyCore()
             string acceleratorKey = base.GetAcceleratorKeyCore();
             if (String.IsNullOrEmpty(acceleratorKey))
             {
-                RoutedUICommand uiCommand = ((RibbonTextBox)Owner).Command as RoutedUICommand;
-                if (uiCommand != null)
+                if (((RibbonTextBox)Owner).Command is RoutedUICommand uiCommand)
                 {
                     acceleratorKey = uiCommand.Text;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTitleAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTitleAutomationPeer.cs
index df9ded95..e1984319 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTitleAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonTitleAutomationPeer.cs
@@ -49,7 +49,7 @@ protected override string GetClassNameCore()
         protected override string GetNameCore()
         {
             ContentPresenter cp = Owner as ContentPresenter;
-            if (cp != null && cp.Content != null)
+            if (cp?.Content != null)
             {
                 return cp.Content.ToString();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonToggleButtonAutomationPeer.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonToggleButtonAutomationPeer.cs
index eba95cee..bfdedf9f 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonToggleButtonAutomationPeer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Automation/Peers/RibbonToggleButtonAutomationPeer.cs
@@ -84,8 +84,7 @@ protected override string GetHelpTextCore()
             string helpText = base.GetHelpTextCore();
             if (String.IsNullOrEmpty(helpText))
             {
-                RibbonToolTip toolTip = ((RibbonToggleButton)Owner).ToolTip as RibbonToolTip;
-                if (toolTip != null)
+                if (((RibbonToggleButton)Owner).ToolTip is RibbonToolTip toolTip)
                 {
                     helpText = toolTip.Description;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/PropertyHelper.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/PropertyHelper.cs
index 73ff95d0..5e421282 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/PropertyHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/PropertyHelper.cs
@@ -131,9 +131,7 @@ public static void TransferProperty(DependencyObject d, DependencyProperty p)
 
         internal static bool IsPropertyTransferEnabled(DependencyObject d, DependencyProperty p)
         {
-            var propertyTransferEnabledForObject = _propertyTransferEnabledMap[d] as Dictionary<DependencyProperty, bool>;
-
-            if (propertyTransferEnabledForObject != null)
+            if (_propertyTransferEnabledMap[d] is Dictionary<DependencyProperty, bool> propertyTransferEnabledForObject)
             {
                 bool isPropertyTransferEnabled;
                 if (propertyTransferEnabledForObject.TryGetValue(p, out isPropertyTransferEnabled))
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/TreeHelper.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/TreeHelper.cs
index 129725c8..4bb3010a 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/TreeHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Generated/TreeHelper.cs
@@ -21,8 +21,7 @@ private static DependencyObject GetVisualParent(DependencyObject element, bool i
         {
             if (includeContentElements)
             {
-                ContentElement ce = element as ContentElement;
-                if (ce != null)
+                if (element is ContentElement ce)
                 {
                     return LogicalTreeHelper.GetParent(ce);
                 }
@@ -56,8 +55,8 @@ public static DependencyObject GetParent(DependencyObject element)
             while (element != null)
             {
                 element = element.TemplatedParent as FrameworkElement;
-                T correctlyTyped = element as T;
-                if (correctlyTyped != null)
+
+                if (element is T correctlyTyped)
                 {
                     return correctlyTyped;
                 }
@@ -77,8 +76,8 @@ public static DependencyObject GetParent(DependencyObject element)
             while (element != null)
             {
                 element = GetVisualParent(element, includeContentElements);
-                T correctlyTyped = element as T;
-                if (correctlyTyped != null)
+
+                if (element is T correctlyTyped)
                 {
                     return correctlyTyped;
                 }
@@ -117,8 +116,8 @@ public static DependencyObject GetParent(DependencyObject element)
             while (element != null)
             {
                 element = LogicalTreeHelper.GetParent(element);
-                T correctlyTyped = element as T;
-                if (correctlyTyped != null)
+
+                if (element is T correctlyTyped)
                 {
                     return correctlyTyped;
                 }
@@ -212,10 +211,7 @@ public static DependencyObject FindVisualRoot(DependencyObject element)
                     return;
                 }
                 UIElement element = pathStart as UIElement;
-                if (element != null)
-                {
-                    element.InvalidateMeasure();
-                }
+                element?.InvalidateMeasure();
                 if (isEndType)
                 {
                     return;
@@ -236,10 +232,7 @@ public static DependencyObject FindVisualRoot(DependencyObject element)
             while (pathStart != null)
             {
                 UIElement element = pathStart as UIElement;
-                if (element != null)
-                {
-                    element.InvalidateMeasure();
-                }
+                element?.InvalidateMeasure();
 
                 if (predicate(pathStart))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipAdorner.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipAdorner.cs
index b8bfe011..76fd2767 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipAdorner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipAdorner.cs
@@ -79,10 +79,7 @@ protected override Size MeasureOverride(Size constraint)
 
         protected override Size ArrangeOverride(Size finalSize)
         {
-            if (_keyTipControl != null)
-            {
-                _keyTipControl.Arrange(new Rect(_keyTipControl.DesiredSize));
-            }
+            _keyTipControl?.Arrange(new Rect(_keyTipControl.DesiredSize));
             return finalSize;
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipControl.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipControl.cs
index c065773b..b94af36c 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipControl.cs
@@ -37,8 +37,7 @@ static KeyTipControl()
         private static void OnSizeChanged(object sender, SizeChangedEventArgs e)
         {
             KeyTipControl keyTipControl = sender as KeyTipControl;
-            if (keyTipControl != null &&
-                keyTipControl.KeyTipAdorner != null)
+            if (keyTipControl?.KeyTipAdorner != null)
             {
                 keyTipControl.KeyTipAdorner.OnKeyTipControlSizeChanged(e);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipService.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipService.cs
index 0db7728d..7e911f27 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/KeyTipService.cs
@@ -162,23 +162,19 @@ public static void SetKeyTipStyle(DependencyObject element, Style value)
 
         private static void OnKeyTipScopeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
-            DependencyObject oldScope = e.OldValue as DependencyObject;
-            DependencyObject newScope = e.NewValue as DependencyObject;
             KeyTipService current = Current;
 
-            if (oldScope != null)
+            if (e.OldValue is DependencyObject oldScope)
             {
                 // Remove the element from the old scope data sets.
                 WeakHashSet<DependencyObject> oldElementSet = null;
                 if (current._scopeToElementMap.TryGetValue(oldScope, out oldElementSet))
                 {
-                    if (oldElementSet != null)
-                    {
-                        oldElementSet.Remove(d);
-                    }
+                    oldElementSet?.Remove(d);
                 }
             }
-            if (newScope != null)
+
+            if (e.NewValue is DependencyObject newScope)
             {
                 // Add the element to the new scope data sets.
                 if (!current._scopeToElementMap.ContainsKey(newScope) ||
@@ -195,8 +191,7 @@ private static void HookKeyTipElementEventHandlers(DependencyObject element)
             FrameworkElement fe = element as FrameworkElement;
             if (fe == null)
             {
-                FrameworkContentElement fce = element as FrameworkContentElement;
-                if (fce != null)
+                if (element is FrameworkContentElement fce)
                 {
                     fce.Loaded += new RoutedEventHandler(OnKeyTipElementLoaded);
                     fce.Unloaded += new RoutedEventHandler(OnKeyTipElementUnLoaded);
@@ -214,8 +209,7 @@ private static void UnhookKeyTipElementEventHandlers(DependencyObject element)
             FrameworkElement fe = element as FrameworkElement;
             if (fe == null)
             {
-                FrameworkContentElement fce = element as FrameworkContentElement;
-                if (fce != null)
+                if (element is FrameworkContentElement fce)
                 {
                     fce.Loaded -= new RoutedEventHandler(OnKeyTipElementLoaded);
                     fce.Unloaded -= new RoutedEventHandler(OnKeyTipElementUnLoaded);
@@ -971,8 +965,8 @@ private void OnKeyTipExactMatch(DependencyObject exactMatchElement)
             KeyTipAccessedEventArgs eventArgs = new KeyTipAccessedEventArgs();
             eventArgs.RoutedEvent = PreviewKeyTipAccessedEvent;
             object oldFocusedElement = Keyboard.FocusedElement;
-            IInputElement inputElement = exactMatchElement as IInputElement;
-            if (inputElement != null)
+
+            if (exactMatchElement is IInputElement inputElement)
             {
                 inputElement.RaiseEvent(eventArgs);
                 eventArgs.RoutedEvent = KeyTipAccessedEvent;
@@ -1131,10 +1125,7 @@ private void StartShowKeyTipsTimer()
 
         private void ShowKeyTips()
         {
-            if (_showKeyTipsTimer != null)
-            {
-                _showKeyTipsTimer.Stop();
-            }
+            _showKeyTipsTimer?.Stop();
             if (State == KeyTipState.Pending)
             {
                 Debug.Assert(_currentGlobalScope != null);
@@ -1260,10 +1251,7 @@ private void Reset()
                 _currentWindow.LocationChanged -= new EventHandler(OnWindowLocationChanged);
             }
             _currentWindow = null;
-            if (_showKeyTipsTimer != null)
-            {
-                _showKeyTipsTimer.Stop();
-            }
+            _showKeyTipsTimer?.Stop();
             _focusRibbonOnKeyTipKeyUp = false;
             _modeEnterKey = Key.None;
             _probableModeEnterKey = Key.None;
@@ -1345,20 +1333,17 @@ static private AdornerLayer GetAdornerLayer(Visual visual, out bool isScrollAdor
 
             while (parent != null)
             {
-                AdornerDecorator adornerDecorator = parent as AdornerDecorator;
-                if (adornerDecorator != null)
+                if (parent is AdornerDecorator adornerDecorator)
                 {
                     return adornerDecorator.AdornerLayer;
                 }
 
-                ScrollContentPresenter scp = parent as ScrollContentPresenter;
-                if (scp != null)
+                if (parent is ScrollContentPresenter scp)
                 {
                     lastScp = scp;
                 }
 
-                ScrollViewer sv = parent as ScrollViewer;
-                if (sv != null && lastScp != null)
+                if (parent is ScrollViewer sv && lastScp != null)
                 {
                     if (GetCanClipKeyTip(sv))
                     {
@@ -1400,10 +1385,7 @@ private static void OnShowingKeyTipChanged(DependencyObject element, DependencyP
                 // Raise the ActivatingKeyTip event.
                 ActivatingKeyTipEventArgs activatingEventArgs = new ActivatingKeyTipEventArgs();
                 IInputElement inputElement = element as IInputElement;
-                if (inputElement != null)
-                {
-                    inputElement.RaiseEvent(activatingEventArgs);
-                }
+                inputElement?.RaiseEvent(activatingEventArgs);
 
                 // KeyTips could have been dismissed due to one
                 // of the event handler, hence check again.
@@ -1470,10 +1452,7 @@ private static void OnShowingKeyTipChanged(DependencyObject element, DependencyP
                     UnlinkKeyTipControlFromAdorner(adorner);
                     bool isScrollAdornerLayer = false;
                     AdornerLayer adornerLayer = GetAdornerLayer(adornedElement, out isScrollAdornerLayer);
-                    if (adornerLayer != null)
-                    {
-                        adornerLayer.Remove(adorner);
-                    }
+                    adornerLayer?.Remove(adorner);
                 }
                 element.ClearValue(KeyTipAdornerProperty);
                 element.ClearValue(KeyTipAdornerHolderProperty);
@@ -1500,10 +1479,7 @@ private void EnqueueAdornerLayerForPlacementProcessing(AdornerLayer adornerLayer
                             foreach (object child in LogicalTreeHelper.GetChildren(currentAdornerLayer))
                             {
                                 KeyTipAdorner keyTipAdorner = child as KeyTipAdorner;
-                                if (keyTipAdorner != null)
-                                {
-                                    keyTipAdorner.NudgeIntoAdornerLayerBoundary(currentAdornerLayer);
-                                }
+                                keyTipAdorner?.NudgeIntoAdornerLayerBoundary(currentAdornerLayer);
                             }
                         }
                         _placementProcessingAdornerLayers.Clear();
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonContextualTabGroupsPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonContextualTabGroupsPanel.cs
index a9b3a5f1..1022db8e 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonContextualTabGroupsPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonContextualTabGroupsPanel.cs
@@ -95,10 +95,7 @@ protected override Size MeasureOverride(Size availableSize)
 
                 if (WaitingForMeasure || invalidateTHPanel)
                 {
-                    if (tabHeadersPanel != null)
-                    {
-                        tabHeadersPanel.InvalidateMeasure();
-                    }
+                    tabHeadersPanel?.InvalidateMeasure();
                 }
             }
 
@@ -178,8 +175,7 @@ protected override void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItem
                 RibbonContextualTabGroupItemsControl groupHeaderItemsControl = ParentItemsControl;
                 if (groupHeaderItemsControl != null)
                 {
-                    IItemContainerGenerator generator = groupHeaderItemsControl.ItemContainerGenerator as IItemContainerGenerator;
-                    if (generator != null && generator.GetItemContainerGeneratorForPanel(this) == generator)
+                    if (groupHeaderItemsControl.ItemContainerGenerator is IItemContainerGenerator generator && generator.GetItemContainerGeneratorForPanel(this) == generator)
                     {
                         groupHeaderItemsControl.InternalItemsHost = this;
                     }
@@ -245,7 +241,7 @@ private Pen SeparatorPen
                 if (_separatorPen == null)
                 {
                     Ribbon ribbon = Ribbon;
-                    if (ribbon != null && ribbon.BorderBrush != null)
+                    if (ribbon?.BorderBrush != null)
                     {
                         Brush b = ribbon.BorderBrush.Clone();
                         _separatorPen = new Pen(b, 1.0);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryCategoriesPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryCategoriesPanel.cs
index 56788112..8542a6bb 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryCategoriesPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryCategoriesPanel.cs
@@ -138,7 +138,7 @@ private static void ResetScrolling(RibbonGalleryCategoriesPanel element)
         // At the time this method is called, scrolling state is in its new, valid state.
         private void OnScrollChange()
         {
-            if (ScrollOwner != null) { ScrollOwner.InvalidateScrollInfo(); }
+            ScrollOwner?.InvalidateScrollInfo();
         }
 
         private void VerifyScrollingData(Size viewport, Size extent, Vector offset)
@@ -392,8 +392,7 @@ private Size AutoPassMeasureOverride()
                     maxChildWidth = Math.Max(maxChildWidth, childSize.Width);
                     maxChildHeight = Math.Max(maxChildHeight, childSize.Height);
 
-                    RibbonGalleryCategory category = child as RibbonGalleryCategory;
-                    if (category != null)
+                    if (child is RibbonGalleryCategory category)
                     {
                         galleryItemCount += category.averageItemHeightInfo.Count;
                         galleryItemCumulativeHeight += category.averageItemHeightInfo.CumulativeHeight;
@@ -624,10 +623,7 @@ public void OnInitializeLayout()
             {
                 TreeHelper.InvalidateMeasureForVisualAncestorPath(this, RibbonHelper.IsISupportStarLayout);
                 RibbonGallery gallery = this.Gallery;
-                if (gallery != null)
-                {
-                    gallery.InvalidateMeasureOnAllCategoriesPanel();
-                }
+                gallery?.InvalidateMeasureOnAllCategoriesPanel();
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryItemsPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryItemsPanel.cs
index 3e13c707..b43ef872 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryItemsPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGalleryItemsPanel.cs
@@ -40,8 +40,7 @@ private bool IsAutoLayoutPass()
             RibbonGallery gallery = Gallery;
             if (gallery != null)
             {
-                RibbonGalleryCategoriesPanel categoriesPanel = gallery.ItemsHostSite as RibbonGalleryCategoriesPanel;
-                if (categoriesPanel != null)
+                if (gallery.ItemsHostSite is RibbonGalleryCategoriesPanel categoriesPanel)
                 {
                     IContainsStarLayoutManager iContainsStarLayoutManager = (IContainsStarLayoutManager)categoriesPanel;
                     if (iContainsStarLayoutManager.StarLayoutManager != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGroupItemsPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGroupItemsPanel.cs
index ac526b20..3e6560c3 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGroupItemsPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonGroupItemsPanel.cs
@@ -382,12 +382,8 @@ private void AdjustDesiredWidthForStarColumn(UIElementCollection children, List<
 
         private static bool CanChildStretch(UIElement child)
         {
-            // Gets the content child of RibbonControl and
-            // determines if its horizontal alignment is
-            // center or stretch. It is considered to be so
-            // by default.
-            RibbonControl ribbonControl = child as RibbonControl;
-            if (ribbonControl != null)
+            // Gets the content child of RibbonControl and            // determines if its horizontal alignment is            // center or stretch. It is considered to be so            // by default.
+            if (child is RibbonControl ribbonControl)
             {
                 UIElement contentChild = ribbonControl.ContentChild;
                 if (contentChild != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonQuickAccessToolBarPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonQuickAccessToolBarPanel.cs
index 163dec86..0fd9323c 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonQuickAccessToolBarPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonQuickAccessToolBarPanel.cs
@@ -252,10 +252,7 @@ protected override Size MeasureOverride(Size availableSize)
                     Dispatcher.BeginInvoke((Action)delegate()
                         {
                             UIElement parent = VisualTreeHelper.GetParent(this) as UIElement;
-                            if (parent != null)
-                            {
-                                parent.InvalidateMeasure();
-                            }
+                            parent?.InvalidateMeasure();
                         },
                         DispatcherPriority.Normal,
                         null);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonScrollButtonVisibilityConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonScrollButtonVisibilityConverter.cs
index dd7fc117..4e11f0c9 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonScrollButtonVisibilityConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonScrollButtonVisibilityConverter.cs
@@ -78,8 +78,7 @@ public object Convert(object[] values, Type targetType, object parameter, Cultur
             {
                 double target;
 
-                string parameterString = parameter as string;
-                if (parameterString != null)
+                if (parameter is string parameterString)
                 {
                     target = Double.Parse(parameterString, NumberFormatInfo.InvariantInfo);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabHeadersPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabHeadersPanel.cs
index 6b6f8ebf..56fb0605 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabHeadersPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabHeadersPanel.cs
@@ -162,7 +162,7 @@ protected override Size MeasureOverride(Size availableSize)
             if (Ribbon != null)
             {
                 RibbonContextualTabGroupItemsControl groupHeaderItemsControl = Ribbon.ContextualTabGroupItemsControl;
-                if (groupHeaderItemsControl != null && groupHeaderItemsControl.InternalItemsHost != null)
+                if (groupHeaderItemsControl?.InternalItemsHost != null)
                 {
                     groupHeaderItemsControl.InternalItemsHost.InvalidateMeasure();
                 }
@@ -216,7 +216,7 @@ protected override Size ArrangeOverride(Size finalSize)
 
                 // Invalidate ContextualTabHeadersPanel
                 RibbonContextualTabGroupItemsControl groupHeaderItemsControl = Ribbon.ContextualTabGroupItemsControl;
-                if (groupHeaderItemsControl != null && groupHeaderItemsControl.InternalItemsHost != null)
+                if (groupHeaderItemsControl?.InternalItemsHost != null)
                 {
                     groupHeaderItemsControl.InternalItemsHost.InvalidateArrange();
                 }
@@ -337,7 +337,7 @@ private Pen SeparatorPen
                 if (_separatorPen == null)
                 {
                     Ribbon ribbon = Ribbon;
-                    if (ribbon != null && ribbon.BorderBrush != null)
+                    if (ribbon?.BorderBrush != null)
                     {
                         Brush b = ribbon.BorderBrush.Clone();
                         _separatorPen = new Pen(b, 1.0);
@@ -598,7 +598,7 @@ private void NotifyDesiredWidthChanged()
         {
             // Invalidate ContextualTabHeadersPanel
             RibbonContextualTabGroupItemsControl groupHeaderItemsControl = Ribbon.ContextualTabGroupItemsControl;
-            if (groupHeaderItemsControl != null && groupHeaderItemsControl.InternalItemsHost != null)
+            if (groupHeaderItemsControl?.InternalItemsHost != null)
             {
                 foreach (RibbonContextualTabGroup tabGroup in groupHeaderItemsControl.InternalItemsHost.Children)
                 {
@@ -813,10 +813,7 @@ private void VerifyScrollData(double viewportWidth, double extentWidth)
 
             if (!fValid)
             {
-                if (ScrollOwner != null)
-                {
-                    ScrollOwner.InvalidateScrollInfo();
-                }
+                ScrollOwner?.InvalidateScrollInfo();
             }
         }
 
@@ -934,7 +931,7 @@ public Rect MakeVisible(Visual visual, Rect rectangle)
 
         private void OnScrollChange()
         {
-            if (ScrollOwner != null) { ScrollOwner.InvalidateScrollInfo(); }
+            ScrollOwner?.InvalidateScrollInfo();
         }
 
         internal static double ComputeScrollOffsetWithMinimalScroll(
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabsPanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabsPanel.cs
index fd69d2b6..9056b47d 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabsPanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTabsPanel.cs
@@ -172,7 +172,7 @@ public Rect MakeVisible(Visual visual, Rect rectangle)
 
         private void OnScrollChange()
         {
-            if (ScrollOwner != null) { ScrollOwner.InvalidateScrollInfo(); }
+            ScrollOwner?.InvalidateScrollInfo();
         }
 
         internal static double ComputeScrollOffsetWithMinimalScroll(
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTitlePanel.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTitlePanel.cs
index 336de7e6..4e1ba2ed 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTitlePanel.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonTitlePanel.cs
@@ -92,11 +92,8 @@ protected override Size MeasureOverride(Size availableSize)
                 desiredSize.Height = Math.Max(desiredSize.Height, groupHeaderItemsControl.DesiredSize.Height);
                 
             }
-            
-            FrameworkElement qat = Ribbon.QatTopHost as FrameworkElement;
-            FrameworkElement titleHost = Ribbon.TitleHost as FrameworkElement;
 
-            if (qat != null && titleHost != null)
+            if (Ribbon.QatTopHost is FrameworkElement qat && Ribbon.TitleHost is FrameworkElement titleHost)
             {
                 double availableToQat = 0.0, availableToTitle;
                 double leftSpace, rightSpace;
@@ -248,7 +245,7 @@ private double CalculateContextualTabGroupStartX(RibbonContextualTabGroup groupH
             // A visible CTG can have some of its tabs Collapsed. 
             // We should start from the first visible Tab in this CTG.
             RibbonTab firstTab = groupHeader.FirstVisibleTab;
-            if (firstTab != null && firstTab.RibbonTabHeader != null && Ribbon != null)
+            if (firstTab?.RibbonTabHeader != null && Ribbon != null)
             {
                 RibbonTabHeader tabHeader = firstTab.RibbonTabHeader;
                 GeneralTransform transformRibbonTabToRibbon = tabHeader.TransformToAncestor(Ribbon);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonWindowSmallIconConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonWindowSmallIconConverter.cs
index 3f17ef42..1fe14071 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonWindowSmallIconConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Primitives/RibbonWindowSmallIconConverter.cs
@@ -27,9 +27,9 @@ public class RibbonWindowSmallIconConverter : IValueConverter
         /// </summary>
         public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
         {
-            ImageSource imageSource = value as ImageSource;
             ImageSource returnImageSource = null;
-            if (imageSource != null)
+
+            if (value is ImageSource imageSource)
             {
                 returnImageSource = GetSmallIconImageSource(imageSource);
 
@@ -60,7 +60,7 @@ private ImageSource GetSmallIconImageSource(ImageSource imageSource)
             bool asGoodAsItGets = false;
 
             var bf = imageSource as BitmapFrame;
-            if (bf != null && bf.Decoder != null && bf.Decoder.Frames != null && bf.Decoder.Frames.Count > 0)
+            if (bf?.Decoder != null && bf.Decoder.Frames != null && bf.Decoder.Frames.Count > 0)
             {
                 bf = GetBestMatch(bf.Decoder.Frames, size);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Ribbon.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Ribbon.cs
index d620beb4..29c8a419 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Ribbon.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/Ribbon.cs
@@ -989,10 +989,7 @@ protected override void OnPreviewMouseWheel(MouseWheelEventArgs e)
                             if (newSelectedIndex >= 0)
                             {
                                 SelectedIndex = newSelectedIndex;
-                                if (_tabHeaderItemsControl != null)
-                                {
-                                    _tabHeaderItemsControl.ScrollIntoView(SelectedIndex);
-                                }
+                                _tabHeaderItemsControl?.ScrollIntoView(SelectedIndex);
                             }
                         }
                     }
@@ -1007,10 +1004,7 @@ protected override void OnPreviewMouseWheel(MouseWheelEventArgs e)
                             if (newSelectedIndex >= 0)
                             {
                                 SelectedIndex = newSelectedIndex;
-                                if (_tabHeaderItemsControl != null)
-                                {
-                                    _tabHeaderItemsControl.ScrollIntoView(SelectedIndex);
-                                }
+                                _tabHeaderItemsControl?.ScrollIntoView(SelectedIndex);
                             }
                         }
                     }
@@ -1040,8 +1034,7 @@ protected override bool IsItemItsOwnContainerOverride(object item)
 
         protected override void PrepareContainerForItemOverride(DependencyObject element, object item)
         {
-            ItemsControl childItemsControl = element as ItemsControl;
-            if (childItemsControl != null)
+            if (element is ItemsControl childItemsControl)
             {
                 // copy templates and styles from this ItemsControl
                 var itemTemplate = RibbonHelper.GetValueAndValueSource(childItemsControl, ItemsControl.ItemTemplateProperty);
@@ -1083,10 +1076,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
             }
 
             RibbonTab container = element as RibbonTab;
-            if (container != null)
-            {
-                container.PrepareRibbonTab();
-            }
+            container?.PrepareRibbonTab();
         }
         /// <summary>
         ///     Gets called when items change on this itemscontrol.
@@ -1278,14 +1268,10 @@ private static void OnIsDropDownOpenChanged(DependencyObject sender, DependencyP
             }
 
             // Raise UI Automation Events
-            RibbonTab selectedTab = ribbon.ItemContainerGenerator.ContainerFromItem(ribbon.SelectedItem) as RibbonTab;
-            if (selectedTab != null)
+            if (ribbon.ItemContainerGenerator.ContainerFromItem(ribbon.SelectedItem) is RibbonTab selectedTab)
             {
                 RibbonTabAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(selectedTab) as RibbonTabAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseTabExpandCollapseAutomationEvent((bool)e.OldValue, (bool)e.NewValue);
-                }
+                peer?.RaiseTabExpandCollapseAutomationEvent((bool)e.OldValue, (bool)e.NewValue);
             }
         }
 
@@ -1341,10 +1327,7 @@ private static void OnIsMinimizedChanged(DependencyObject sender, DependencyProp
 
             // Raise UI Automation Events
             RibbonAutomationPeer peer = UIElementAutomationPeer.FromElement(ribbon) as RibbonAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent(!(bool)e.OldValue, !(bool)e.NewValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent(!(bool)e.OldValue, !(bool)e.NewValue);
 
         }
 
@@ -1357,17 +1340,14 @@ private static void OnQuickAccessToolBarChanged(DependencyObject sender, Depende
         {
             Ribbon ribbon = (Ribbon)sender;
 
-            RibbonQuickAccessToolBar oldRibbonQuickAccessToolBar = e.OldValue as RibbonQuickAccessToolBar;
-            RibbonQuickAccessToolBar newRibbonQuickAccessToolBar = e.NewValue as RibbonQuickAccessToolBar;
-
             // Remove Logical tree link
-            if (oldRibbonQuickAccessToolBar != null)
+            if (e.OldValue is RibbonQuickAccessToolBar oldRibbonQuickAccessToolBar)
             {
                 ribbon.RemoveLogicalChild(oldRibbonQuickAccessToolBar);
             }
 
             // Add Logical tree link
-            if (newRibbonQuickAccessToolBar != null)
+            if (e.NewValue is RibbonQuickAccessToolBar newRibbonQuickAccessToolBar)
             {
                 ribbon.AddLogicalChild(newRibbonQuickAccessToolBar);
             }
@@ -1382,17 +1362,14 @@ private static void OnApplicationMenuChanged(DependencyObject sender, Dependency
         {
             Ribbon ribbon = (Ribbon)sender;
 
-            RibbonApplicationMenu oldRibbonApplicationMenu = e.OldValue as RibbonApplicationMenu;
-            RibbonApplicationMenu newRibbonApplicationMenu = e.NewValue as RibbonApplicationMenu;
-
             // Remove Logical tree link
-            if (oldRibbonApplicationMenu != null)
+            if (e.OldValue is RibbonApplicationMenu oldRibbonApplicationMenu)
             {
                 ribbon.RemoveLogicalChild(oldRibbonApplicationMenu);
             }
 
             // Add Logical tree link
-            if (newRibbonApplicationMenu != null)
+            if (e.NewValue is RibbonApplicationMenu newRibbonApplicationMenu)
             {
                 ribbon.AddLogicalChild(newRibbonApplicationMenu);
             }
@@ -1505,10 +1482,7 @@ private static void OnNotifyTabHeaderPropertyChanged(DependencyObject d, Depende
             for (int i = 0; i < itemCount; i++)
             {
                 RibbonTab ribbonTab = ribbon.ItemContainerGenerator.ContainerFromIndex(i) as RibbonTab;
-                if (ribbonTab != null)
-                {
-                    ribbonTab.NotifyPropertyChanged(e);
-                }
+                ribbonTab?.NotifyPropertyChanged(e);
             }
         }
 
@@ -1565,8 +1539,7 @@ private int GetFirstVisibleTabIndex(bool ignoreContextualTabs)
             int itemCount = Items.Count;
             for (int i = 0; i < itemCount; i++)
             {
-                RibbonTab tab = ItemContainerGenerator.ContainerFromIndex(i) as RibbonTab;
-                if (tab != null &&
+                if (ItemContainerGenerator.ContainerFromIndex(i) is RibbonTab tab &&
                     tab.IsVisible &&
                     (!tab.IsContextualTab || ignoreContextualTabs))
                 {
@@ -1675,9 +1648,9 @@ private void RefreshHeaderCollection()
             int itemCount = Items.Count;
             for (int i = 0; i < itemCount; i++)
             {
-                RibbonTab tab = ItemContainerGenerator.ContainerFromIndex(i) as RibbonTab;
                 object headerItem = null;
-                if (tab != null)
+
+                if (ItemContainerGenerator.ContainerFromIndex(i) is RibbonTab tab)
                 {
                     headerItem = tab.Header;
                 }
@@ -1716,19 +1689,13 @@ private static void OnBorderBrushChanged(DependencyObject d, DependencyPropertyC
             if (ribbon._tabHeaderItemsControl != null)
             {
                 RibbonTabHeadersPanel tabHeadersPanel = ribbon._tabHeaderItemsControl.InternalItemsHost as RibbonTabHeadersPanel;
-                if (tabHeadersPanel != null)
-                {
-                    tabHeadersPanel.OnNotifyRibbonBorderBrushChanged();
-                }
+                tabHeadersPanel?.OnNotifyRibbonBorderBrushChanged();
             }
             RibbonContextualTabGroupItemsControl contextualItemsControl = ribbon.ContextualTabGroupItemsControl;
             if (contextualItemsControl != null)
             {
                 RibbonContextualTabGroupsPanel contextualTabHeadersPanel = contextualItemsControl.InternalItemsHost as RibbonContextualTabGroupsPanel;
-                if (contextualTabHeadersPanel != null)
-                {
-                    contextualTabHeadersPanel.OnNotifyRibbonBorderBrushChanged();
-                }
+                contextualTabHeadersPanel?.OnNotifyRibbonBorderBrushChanged();
             }
         }
 
@@ -2008,8 +1975,7 @@ private int GetFocusedRibbonGroupIndex(RibbonTab tab)
         private bool TrySetFocusOnRibbonGroupAtIndex(RibbonTab tab,
             int index)
         {
-            RibbonGroup group = tab.ItemContainerGenerator.ContainerFromIndex(index) as RibbonGroup;
-            if (group != null &&
+            if (tab.ItemContainerGenerator.ContainerFromIndex(index) is RibbonGroup group &&
                 group.IsVisible)
             {
                 group.MoveFocus(new TraversalRequest(FocusNavigationDirection.First));
@@ -2052,8 +2018,7 @@ private int GetFocusedRibbonGroupIndex(RibbonTab tab)
         private bool TrySetFocusOnQatItemAtIndex(RibbonQuickAccessToolBar quickAccessToolBar,
             int index)
         {
-            RibbonControl ribbonControl = quickAccessToolBar.ItemContainerGenerator.ContainerFromIndex(index) as RibbonControl;
-            if (ribbonControl != null &&
+            if (quickAccessToolBar.ItemContainerGenerator.ContainerFromIndex(index) is RibbonControl ribbonControl &&
                 ribbonControl.IsVisible &&
                 (index == 0 || ribbonControl.HostsRibbonGroup()))
             {
@@ -2242,8 +2207,7 @@ private int GetFocusedQatItemIndex(RibbonQuickAccessToolBar quickAccessToolBar)
             RibbonTab selectedTab,
             ArrowKeyControlNavigationScope startingNavigationScope)
         {
-            DependencyObject focusedElement = Keyboard.FocusedElement as DependencyObject;
-            if (focusedElement != null &&
+            if (Keyboard.FocusedElement is DependencyObject focusedElement &&
                 !TreeHelper.IsVisualAncestorOf(this, focusedElement) &&
                 _itemsPresenterPopup != null &&
                 _itemsPresenterPopup.Child != null &&
@@ -2475,8 +2439,7 @@ private static void AddToQATExecuted(object sender, ExecutedRoutedEventArgs args
                 originalSource.RaiseEvent(e);
 
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
-                if (ribbon != null &&
-                    ribbon.QuickAccessToolBar != null &&
+                if (ribbon?.QuickAccessToolBar != null &&
                     e.CloneInstance != null)
                 {
                     ribbon.QuickAccessToolBar.Items.Add(e.CloneInstance);
@@ -2497,9 +2460,7 @@ private static DependencyObject FindElementThatCanBeAddedToQAT(DependencyObject
 
         private static void MaximizeRibbonCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
                 if (ribbon != null &&
@@ -2512,8 +2473,7 @@ private static void MaximizeRibbonCanExecute(object sender, CanExecuteRoutedEven
 
         private static void MaximizeRibbonExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
                 if (ribbon != null)
@@ -2526,9 +2486,7 @@ private static void MaximizeRibbonExecuted(object sender, ExecutedRoutedEventArg
 
         private static void MinimizeRibbonCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
                 if (ribbon != null &&
@@ -2541,8 +2499,7 @@ private static void MinimizeRibbonCanExecute(object sender, CanExecuteRoutedEven
 
         private static void MinimizeRibbonExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
                 if (ribbon != null)
@@ -2555,9 +2512,7 @@ private static void MinimizeRibbonExecuted(object sender, ExecutedRoutedEventArg
 
         private static void RemoveFromQATCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            DependencyObject obj = args.OriginalSource as DependencyObject;
-
-            if (obj != null)
+            if (args.OriginalSource is DependencyObject obj)
             {
                 args.CanExecute = RibbonControlService.GetIsInQuickAccessToolBar(obj);
             }
@@ -2565,12 +2520,10 @@ private static void RemoveFromQATCanExecute(object sender, CanExecuteRoutedEvent
 
         private static void RemoveFromQATExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            UIElement originalSource = args.OriginalSource as UIElement;
-            if (originalSource != null)
+            if (args.OriginalSource is UIElement originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
-                if (ribbon != null &&
-                    ribbon.QuickAccessToolBar != null)
+                if (ribbon?.QuickAccessToolBar != null)
                 {
                     RibbonQuickAccessToolBar qat = ribbon.QuickAccessToolBar;
                     if (qat.Items.Contains(originalSource))
@@ -2584,13 +2537,10 @@ private static void RemoveFromQATExecuted(object sender, ExecutedRoutedEventArgs
 
         private static void ShowQATAboveCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
-                if (ribbon != null &&
-                    ribbon.QuickAccessToolBar != null &&
+                if (ribbon?.QuickAccessToolBar != null &&
                     !ribbon.ShowQuickAccessToolBarOnTop)
                 {
                     args.CanExecute = true;
@@ -2600,8 +2550,7 @@ private static void ShowQATAboveCanExecute(object sender, CanExecuteRoutedEventA
 
         private static void ShowQATAboveExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
                 if (ribbon != null)
@@ -2614,13 +2563,10 @@ private static void ShowQATAboveExecuted(object sender, ExecutedRoutedEventArgs
 
         private static void ShowQATBelowCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
-                if (ribbon != null &&
-                    ribbon.QuickAccessToolBar != null &&
+                if (ribbon?.QuickAccessToolBar != null &&
                     ribbon.ShowQuickAccessToolBarOnTop)
                 {
                     args.CanExecute = true;
@@ -2630,8 +2576,7 @@ private static void ShowQATBelowCanExecute(object sender, CanExecuteRoutedEventA
 
         private static void ShowQATBelowExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            DependencyObject originalSource = args.OriginalSource as DependencyObject;
-            if (originalSource != null)
+            if (args.OriginalSource is DependencyObject originalSource)
             {
                 Ribbon ribbon = RibbonControlService.GetRibbon(originalSource);
                 if (ribbon != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonComboBox.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonComboBox.cs
index 10b4a278..083025fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonComboBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonComboBox.cs
@@ -122,10 +122,9 @@ private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedE
         {
             RibbonComboBox cb = (RibbonComboBox)d;
 
-            RibbonComboBoxAutomationPeer peer = UIElementAutomationPeer.FromElement(cb) as RibbonComboBoxAutomationPeer;
             // Raise the propetyChangeEvent for Value if Automation Peer exist, the new Value must
             // be the one in SelctionBoxItem(selected value is the one user will care about)
-            if (peer != null)
+            if (UIElementAutomationPeer.FromElement(cb) is RibbonComboBoxAutomationPeer peer)
                 peer.RaiseValuePropertyChangedEvent((string)e.OldValue, (string)e.NewValue);
 
 
@@ -517,11 +516,9 @@ private void UpdateSelectionBoxItem()
                 }
             }
 
-            // if Items contains an explicit ContentControl, use its content instead
-            // (this handles the case of ComboBoxItem)
-            ContentControl contentControl = item as ContentControl;
+            // if Items contains an explicit ContentControl, use its content instead            // (this handles the case of ComboBoxItem)
 
-            if (contentControl != null)
+            if (item is ContentControl contentControl)
             {
                 item = contentControl.Content;
                 itemTemplate = contentControl.ContentTemplate;
@@ -536,12 +533,9 @@ private void UpdateSelectionBoxItem()
 
             if (itemTemplate == null && itemTemplateSelector == null && stringFormat == null)
             {
-                // if the item is a logical element it cannot be displayed directly in
-                // the selection box because it already belongs to the tree (in the dropdown box).
-                // Instead, try to extract some useful text from the visual.
-                DependencyObject logicalElement = item as DependencyObject;
+                // if the item is a logical element it cannot be displayed directly in                // the selection box because it already belongs to the tree (in the dropdown box).                // Instead, try to extract some useful text from the visual.
 
-                if (logicalElement != null)
+                if (item is DependencyObject logicalElement)
                 {
                     // If the item is a UIElement, create a copy using a visual brush
                     _clonedElement = logicalElement as UIElement;
@@ -700,8 +694,7 @@ private void TextUpdated(string newText, bool textBoxUpdated)
                                      // it doesn't get confused with the IME's undo stack.
                                      MS.Internal.Documents.UndoManager undoManager =
                                          EditableTextBoxSite.TextContainer.UndoManager;
-                                     if (undoManager != null &&
-                                         undoManager.OpenedUnit != null &&
+                                     if (undoManager?.OpenedUnit != null &&
                                          undoManager.OpenedUnit.GetType() != typeof(TextParentUndoUnit))
                                      {
                                          _updateTextBoxOperation = Dispatcher.BeginInvoke(DispatcherPriority.Normal,
@@ -746,9 +739,7 @@ private void TextUpdated(string newText, bool textBoxUpdated)
 
                                     if (matchedGalleryCategory != null && matchedItem != null)
                                     {
-                                        RibbonGalleryItem galleryItem =
-                                            matchedGalleryCategory.ItemContainerGenerator.ContainerFromItem(matchedItem) as RibbonGalleryItem;
-                                        if (galleryItem != null)
+                                        if (                                            matchedGalleryCategory.ItemContainerGenerator.ContainerFromItem(matchedItem) is RibbonGalleryItem galleryItem)
                                         {
                                             updated = true;
                                             galleryItem.IsHighlighted = true;
@@ -887,15 +878,7 @@ internal override void OnIsDropDownOpenChanged(DependencyPropertyChangedEventArg
 
                 Dispatcher.BeginInvoke((Action)delegate()
                 {
-                    if (_firstGallery != null)
-                    {
-                        // Scroll the highlighted item into view. Note that we need to do the
-                        // scroll in a Dispatcher operation because the scroll operation wont
-                        // succeed until the Popup contents are Loaded and connected to a
-                        // PresentationSource. We need to allow time for that to happen.
-
-                        _firstGallery.ScrollIntoView(_firstGallery.HighlightedItem);
-                    }
+                    _firstGallery?.ScrollIntoView(_firstGallery.HighlightedItem);
                 },
                 DispatcherPriority.Render);
             }
@@ -1255,10 +1238,9 @@ protected override void OnPreviewMouseDown(MouseButtonEventArgs e)
         {
             if (IsEditable)
             {
-                Visual originalSource = e.OriginalSource as Visual;
                 Visual textBox = EditableTextBoxSite;
 
-                if (originalSource != null && textBox != null
+                if (e.OriginalSource is Visual originalSource && textBox != null
                     && textBox.IsAncestorOf(originalSource))
                 {
                     if (IsDropDownOpen && StaysOpenOnEdit)
@@ -1358,8 +1340,7 @@ private void UpdateFirstGallery()
         protected override void PrepareContainerForItemOverride(DependencyObject element, object item)
         {
             // If a new Gallery container has been generated for _galleryItem, update _gallery reference.
-            RibbonGallery gallery = element as RibbonGallery;
-            if (gallery != null)
+            if (element is RibbonGallery gallery)
             {
                 if (_firstGalleryItem != null && _firstGalleryItem.IsAlive && _firstGalleryItem.Target.Equals(item))
                 {
@@ -1440,11 +1421,8 @@ void OnGalleryHighlightChanged(object sender, EventArgs e)
 
         void OnGalleryGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e)
         {
-            // When on of the GalleryItems within the _firstGallery acquires Keyboard
-            // focus reinstate focus to the parent based on the IsEditable mode
-
-            RibbonGalleryItem focusedGalleryItem = Keyboard.FocusedElement as RibbonGalleryItem;
-            if (focusedGalleryItem != null)
+            // When on of the GalleryItems within the _firstGallery acquires Keyboard            // focus reinstate focus to the parent based on the IsEditable mode
+            if (Keyboard.FocusedElement is RibbonGalleryItem focusedGalleryItem)
             {
                 if (IsEditable && EditableTextBoxSite != null)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContentPresenter.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContentPresenter.cs
index 29fc7f9c..1dad2a71 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContentPresenter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContentPresenter.cs
@@ -127,11 +127,7 @@ protected override void OnTemplateChanged(DataTemplate oldTemplate, DataTemplate
             if (oldTemplate != null)
             {
                 RibbonHelper.ClearPseudoInheritedProperties(_templateRoot);
-                if (_templateRoot != null)
-                {
-                    // Clearing the Ribbon property value which was set earlier.
-                    _templateRoot.ClearValue(RibbonControlService.RibbonPropertyKey);
-                }
+                _templateRoot?.ClearValue(RibbonControlService.RibbonPropertyKey);
                 _templateRoot = null;
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextMenu.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextMenu.cs
index 525ef4ba..e5251f8b 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextMenu.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextMenu.cs
@@ -139,8 +139,7 @@ private void RestoreFocusToRibbon()
             }
             while (current != null)
             {
-                UIElement uie = current as UIElement;
-                if (uie != null && uie.Focusable)
+                if (current is UIElement uie && uie.Focusable)
                 {
                     uie.Dispatcher.BeginInvoke(
                         (Action)delegate()
@@ -408,8 +407,7 @@ public PlacementTargetToQATPositionConverter(ConverterMode mode)
 
             public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
             {
-                DependencyObject d = value as DependencyObject;
-                if (d != null)
+                if (value is DependencyObject d)
                 {
                     Ribbon ribbon = RibbonControlService.GetRibbon(d);
                     if (ribbon != null &&
@@ -546,8 +544,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
             }
             else
             {
-                RibbonSeparator separator = element as RibbonSeparator;
-                if (separator != null)
+                if (element is RibbonSeparator separator)
                 {
                     ValueSource vs = DependencyPropertyHelper.GetValueSource(separator, StyleProperty);
                     if (vs.BaseValueSource <= BaseValueSource.ImplicitStyleReference)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextualTabGroupItemsControl.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextualTabGroupItemsControl.cs
index 38d6b74e..1df612db 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextualTabGroupItemsControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonContextualTabGroupItemsControl.cs
@@ -154,20 +154,14 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         {
             base.PrepareContainerForItemOverride(element, item);
             RibbonContextualTabGroup tabGroupHeader = element as RibbonContextualTabGroup;
-            if (tabGroupHeader != null)
-            {
-                tabGroupHeader.PrepareTabGroupHeader(item, ItemTemplate, ItemTemplateSelector, ItemStringFormat);
-            }
+            tabGroupHeader?.PrepareTabGroupHeader(item, ItemTemplate, ItemTemplateSelector, ItemStringFormat);
         }
 
         protected override void ClearContainerForItemOverride(DependencyObject element, object item)
         {
             base.ClearContainerForItemOverride(element, item);
             RibbonContextualTabGroup tabGroupHeader = element as RibbonContextualTabGroup;
-            if (tabGroupHeader != null)
-            {
-                tabGroupHeader.ClearTabGroupHeader();
-            }
+            tabGroupHeader?.ClearTabGroupHeader();
 
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControl.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControl.cs
index f6bed5fd..cf076ac6 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControl.cs
@@ -154,16 +154,14 @@ private static void OnItemForItemContainerChanged(DependencyObject d, Dependency
         {
             if (e.OldValue != null)
             {
-                UIElement element = e.OldValue as UIElement;
-                if (element != null)
+                if (e.OldValue is UIElement element)
                 {
                     element.PositionAndSizeOfSetController = null;
                 }
             }
             if (e.NewValue != null)
             {
-                UIElement element = e.NewValue as UIElement;
-                if (element != null)
+                if (e.OldValue is UIElement element)
                 {
                     RibbonControl rc = (RibbonControl)d;
                     element.PositionAndSizeOfSetController = rc;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLength.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLength.cs
index 237e497f..b61908d6 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLength.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLength.cs
@@ -97,9 +97,8 @@ public RibbonControlLength(double value, RibbonControlLengthUnitType type)
         /// </summary>
         public override bool Equals(object obj)
         {
-            if (obj is RibbonControlLength)
+            if (obj is RibbonControlLength length)
             {
-                RibbonControlLength length = (RibbonControlLength)obj;
                 return (this == length);
             }
             else
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLengthConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLengthConverter.cs
index b7d0b90d..39ca52d3 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLengthConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlLengthConverter.cs
@@ -80,8 +80,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
         {
             if (value != null)
             {
-                string stringValue = value as string;
-                if (stringValue != null)
+                if (value is string stringValue)
                 {
                     return FromString(stringValue, culture);
                 }
@@ -121,10 +120,8 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 throw new ArgumentNullException("destinationType");
             }
 
-            if (value != null && value is RibbonControlLength)
+            if (value is RibbonControlLength length)
             {
-                RibbonControlLength length = (RibbonControlLength)value;
-
                 if (destinationType == typeof(string))
                 {
                     return ToString(length, culture);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlService.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlService.cs
index 192b364d..a066fb70 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlService.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonControlService.cs
@@ -800,10 +800,7 @@ private static void OnDefaultControlSizeDefinitionChanged(DependencyObject d, De
                 if (ribbonGroupItemsPanel != null)
                 {
                     RibbonGroup ribbonGroup = TreeHelper.FindVisualAncestor<RibbonGroup>(ribbonGroupItemsPanel);
-                    if (ribbonGroup != null)
-                    {
-                        ribbonGroup.UpdateGroupSizeDefinitionsAsync();
-                    }
+                    ribbonGroup?.UpdateGroupSizeDefinitionsAsync();
                 }
             }
 
@@ -839,10 +836,7 @@ private static void UpdateDefaultControlSizeDefinition(DependencyObject d)
             if (RibbonControlService.GetIsInControlGroup(d))
             {
                 RibbonControlGroup controlGroup = TreeHelper.FindVisualAncestor<RibbonControlGroup>(d);
-                if (controlGroup != null)
-                {
-                    controlGroup.CoerceValue(DefaultControlSizeDefinitionProperty);
-                }
+                controlGroup?.CoerceValue(DefaultControlSizeDefinitionProperty);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonDropDownHelper.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonDropDownHelper.cs
index 51922042..61788a0a 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonDropDownHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonDropDownHelper.cs
@@ -220,8 +220,7 @@ public static Size GetMinDropDownSize(RibbonMenuItemsPanel itemsHost, Popup popu
                 minSize = itemsHost.CachedAutoSize;
                 if (popup != null)
                 {
-                    FrameworkElement popupChild = popup.Child as FrameworkElement;
-                    if (popupChild != null && DoubleUtil.GreaterThan(popupChild.MinWidth, minSize.Width)) 
+                    if (popup.Child is FrameworkElement popupChild && DoubleUtil.GreaterThan(popupChild.MinWidth, minSize.Width)) 
                     {
                         // MenuButton's BorderThickness around the ItemsPresenter
                         minSize.Width = popupChild.MinWidth - (borderThickness.Left + borderThickness.Right);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonFilterMenuButton.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonFilterMenuButton.cs
index 0fac3e50..73d69e24 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonFilterMenuButton.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonFilterMenuButton.cs
@@ -48,9 +48,7 @@ public override void OnApplyTemplate()
         {
             base.OnApplyTemplate();
 
-            RibbonToggleButton filterToggleButton = this.Template.FindName(RibbonMenuButton.ToggleButtonTemplatePartName, this) as RibbonToggleButton;
-
-            if (filterToggleButton != null)
+            if (this.Template.FindName(RibbonMenuButton.ToggleButtonTemplatePartName, this) is RibbonToggleButton filterToggleButton)
             {
                 filterToggleButton.Loaded += new RoutedEventHandler(OnFilterToggleButtonLoaded);
             }
@@ -75,8 +73,7 @@ private void OnFilterToggleButtonLoaded(object sender, RoutedEventArgs e)
             {
                 filterToggleButton.Loaded -= new RoutedEventHandler(OnFilterToggleButtonLoaded);
 
-                RibbonGallery parentGallery = this.TemplatedParent as RibbonGallery;
-                if (parentGallery != null)
+                if (this.TemplatedParent is RibbonGallery parentGallery)
                 {
                     Binding currentFilterBinding = new Binding("CurrentFilter") { Source = parentGallery };
                     filterToggleButton.SetBinding(RibbonToggleButton.ContentProperty, currentFilterBinding);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGallery.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGallery.cs
index 5b79261a..0ef5edbc 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGallery.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGallery.cs
@@ -975,8 +975,7 @@ private void UpdateIsSynchronizedWithCurrentItemInternal()
                 // Notify categories
                 for (int i = 0; i < Items.Count; i++ )
                 {
-                    RibbonGalleryCategory category = ItemContainerGenerator.ContainerFromIndex(i) as RibbonGalleryCategory;
-                    if (category != null)
+                    if (ItemContainerGenerator.ContainerFromIndex(i) is RibbonGalleryCategory category)
                     {
                         if (newValue)
                         {
@@ -1163,10 +1162,8 @@ private void OnCurrentItemChanged()
                 return;
             }
 
-            // Synchronize the SelectedItem to be the first Item
-            // within the current Category.
-            RibbonGalleryCategory category = this.ItemContainerGenerator.ContainerFromItem(CollectionView.CurrentItem) as RibbonGalleryCategory;
-            if (category != null && category.Items.Count > 0)
+            // Synchronize the SelectedItem to be the first Item            // within the current Category.
+            if (this.ItemContainerGenerator.ContainerFromItem(CollectionView.CurrentItem) is RibbonGalleryCategory category && category.Items.Count > 0)
             {
 #if RIBBON_IN_FRAMEWORK
                 SetCurrentValue(SelectedItemProperty, category.Items[0]);
@@ -1310,13 +1307,8 @@ internal void ChangeSelection(object item, RibbonGalleryItem container, bool isS
 
                             MoveCurrentToPosition(CollectionView, -1);
                             MoveCurrentToPosition(SourceCollectionView, -1);
-
-                            // When changing RibbonGallery.SelectedItem to null, we need to push RibbonComboBox to update its
-                            // selection properties.  Even though RibbonComboBox handles RibbonGalleryItem.UnselectedEvent,
-                            // at the time of its handling RibbonGallery.SelectedItem is still non-null.  We need to refresh
-                            // RibbonComboBox's selection properties once RibbonGallery.SelectedItem is actually null.
-                            RibbonComboBox comboBoxParent = LogicalTreeHelper.GetParent(this) as RibbonComboBox;
-                            if (comboBoxParent != null &&
+                            // When changing RibbonGallery.SelectedItem to null, we need to push RibbonComboBox to update its                            // selection properties.  Even though RibbonComboBox handles RibbonGalleryItem.UnselectedEvent,                            // at the time of its handling RibbonGallery.SelectedItem is still non-null.  We need to refresh                            // RibbonComboBox's selection properties once RibbonGallery.SelectedItem is actually null.
+                            if (LogicalTreeHelper.GetParent(this) is RibbonComboBox comboBoxParent &&
                                 this == comboBoxParent.FirstGallery &&
                                 comboBoxParent.IsSelectedItemCached == false)
                             {
@@ -1503,9 +1495,7 @@ private object GetSelectableValueFromItem(object item, ContentControl dummyEleme
 
         private static object GetInnerText(object item)
         {
-            XmlNode node = item as XmlNode;
-
-            if (node != null)
+            if (item is XmlNode node)
             {
                 return node.InnerText;
             }
@@ -1781,8 +1771,7 @@ private bool ShouldForceCoerceHighlightedItem
         // We only want to execute the FilterCommand if we are in the auto-filtering case and we have _filterMenuButton available.
         private static void FilterCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            RibbonGallery rg = sender as RibbonGallery;
-            if (rg != null &&
+            if (sender is RibbonGallery rg &&
                 rg.CanUserFilter &&
                 rg._filterMenuButton != null &&
                 rg.FilterPaneContent == null &&
@@ -2155,8 +2144,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
                 object selectedItem = SelectedItem;
                 for (int index = 0; index < category.Items.Count; index++)
                 {
-                    RibbonGalleryItem galleryItem = category.ItemContainerGenerator.ContainerFromIndex(index) as RibbonGalleryItem;
-                    if (galleryItem != null)
+                    if (category.ItemContainerGenerator.ContainerFromIndex(index) is RibbonGalleryItem galleryItem)
                     {
                         // Set IsSelected to true on GalleryItems that match the SelectedItem
                         if (selectedItem != null)
@@ -2220,8 +2208,7 @@ protected override void ClearContainerForItemOverride(DependencyObject element,
 
             for (int index = 0; index < category.Items.Count; index++)
             {
-                RibbonGalleryItem galleryItem = category.ItemContainerGenerator.ContainerFromIndex(index) as RibbonGalleryItem;
-                if (galleryItem != null)
+                if (category.ItemContainerGenerator.ContainerFromIndex(index) is RibbonGalleryItem galleryItem)
                 {
                     object dataItem = category.Items[index];
 
@@ -2533,10 +2520,7 @@ private static void OnNotifyGalleryItemTemplateOrStylePropertyChanged(Dependency
             {
                 RibbonGalleryCategory category = (RibbonGalleryCategory)gallery.ItemContainerGenerator.ContainerFromIndex(index);
 
-                if (category != null)
-                {
-                    category.NotifyPropertyChanged(e);
-                }
+                category?.NotifyPropertyChanged(e);
             }
         }
 
@@ -2705,8 +2689,7 @@ internal void OnNavigationKeyDown(KeyEventArgs e, DependencyObject focusedElemen
                 FocusNavigationDirection direction = (FlowDirection == FlowDirection.LeftToRight ? FocusNavigationDirection.Left : FocusNavigationDirection.Right);
                 if (focusedElement != null)
                 {
-                    RibbonMenuItem menuItem = TreeHelper.FindAncestor(this, delegate(DependencyObject d) { return (d is RibbonMenuItem); }) as RibbonMenuItem;
-                    if (menuItem != null)
+                    if (TreeHelper.FindAncestor(this, delegate(DependencyObject d) { return (d is RibbonMenuItem); }) is RibbonMenuItem menuItem)
                     {
                         predictedFocus = RibbonHelper.PredictFocus(focusedElement, direction) as UIElement;
                         bool callRibbonMenuItemHandler = false;
@@ -2748,8 +2731,7 @@ internal void OnNavigationKeyDown(KeyEventArgs e, DependencyObject focusedElemen
             {
                 FocusNavigationDirection direction = e.Key == Key.PageDown ? FocusNavigationDirection.Down : FocusNavigationDirection.Up;
 
-                RibbonGalleryItem focusedGalleryItem = focusedElement as RibbonGalleryItem;
-                if (focusedGalleryItem != null)
+                if (focusedElement is RibbonGalleryItem focusedGalleryItem)
                 {
                     RibbonGalleryItem highlightedGalleryItem;
                     e.Handled = RibbonHelper.NavigatePageAndHighlightRibbonGalleryItem(
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryCategory.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryCategory.cs
index 0eb19efc..d8faa6f4 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryCategory.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryCategory.cs
@@ -226,10 +226,7 @@ private static void OnNotifyPropertyChanged(DependencyObject d, DependencyProper
             if (e.Property == MinColumnCountProperty || e.Property == MaxColumnCountProperty || e.Property == IsSharedColumnSizeScopeProperty || e.Property == ColumnsStretchToFillProperty)
             {
                 RibbonGallery gallery = galleryCategory.RibbonGallery;
-                if (gallery != null)
-                {
-                    gallery.InvalidateMeasureOnAllCategoriesPanel();
-                }
+                gallery?.InvalidateMeasureOnAllCategoriesPanel();
             }
         }
         internal void NotifyPropertyChanged(DependencyPropertyChangedEventArgs e)
@@ -520,8 +517,7 @@ private void OnCurrentItemChanged()
                 return;
             }
 
-            RibbonGalleryItem galleryItem = this.ItemContainerGenerator.ContainerFromItem(CollectionView.CurrentItem) as RibbonGalleryItem;
-            if (galleryItem != null)
+            if (this.ItemContainerGenerator.ContainerFromItem(CollectionView.CurrentItem) is RibbonGalleryItem galleryItem)
             {
                 // This is fast path to have the SelectedItem set
                 galleryItem.IsSelected = true;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryItem.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryItem.cs
index baa5dc32..9623c8e7 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGalleryItem.cs
@@ -108,8 +108,7 @@ protected internal virtual void OnSelected(RoutedEventArgs e)
                 return null;
             }, null);
 
-            RibbonGalleryItemAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(this) as RibbonGalleryItemAutomationPeer;
-            if (peer != null)
+            if (UIElementAutomationPeer.CreatePeerForElement(this) is RibbonGalleryItemAutomationPeer peer)
             {
                 peer.RaiseAutomationIsSelectedChanged(true);
                 peer.RaiseAutomationSelectionEvent(AutomationEvents.SelectionItemPatternOnElementSelected);
@@ -146,8 +145,7 @@ protected internal virtual void OnUnselected(RoutedEventArgs e)
         {
             RaiseEvent(e);
 
-            RibbonGalleryItemAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(this) as RibbonGalleryItemAutomationPeer;
-            if (peer != null)
+            if (UIElementAutomationPeer.CreatePeerForElement(this) is RibbonGalleryItemAutomationPeer peer)
             {
                 peer.RaiseAutomationIsSelectedChanged(false);
                 peer.RaiseAutomationSelectionEvent(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGroup.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGroup.cs
index 6f1c4185..8e3da539 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGroup.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonGroup.cs
@@ -143,8 +143,7 @@ public override void OnApplyTemplate()
                 _mouseLeaveStoryboard = new Storyboard();
                 _mouseLeaveStoryboard.Children.Add(CreateOpacityAnimation(false, _hotBackgroundBorder));
 
-                Grid popupGrid = this.GetTemplateChild(PopupGridTemplatePartName) as Grid;
-                if (popupGrid != null)
+                if (this.GetTemplateChild(PopupGridTemplatePartName) is Grid popupGrid)
                 {
                     popupGrid.MouseEnter += (s, e) =>
                         {
@@ -209,10 +208,7 @@ protected override void OnRenderSizeChanged(SizeChangedInfo info)
             if (info.WidthChanged)
             {
                 RibbonGroupsPanel groupsPanel = VisualTreeHelper.GetParent(this) as RibbonGroupsPanel;
-                if (groupsPanel != null)
-                {
-                    groupsPanel.OnChildGroupRenderSizeChanged(this, info.PreviousSize.Width);
-                }
+                groupsPanel?.OnChildGroupRenderSizeChanged(this, info.PreviousSize.Width);
             }
         }
 
@@ -638,10 +634,7 @@ private static void OnIsDropDownOpenChanged(DependencyObject sender, DependencyP
             RibbonHelper.SetContentAsToolTip(group, group.VisualChild, group.Header, (group.IsCollapsed && !group.IsDropDownOpen));
 
             RibbonGroupAutomationPeer peer = UIElementAutomationPeer.FromElement(group) as RibbonGroupAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent((bool)e.OldValue, (bool)e.NewValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent((bool)e.OldValue, (bool)e.NewValue);
         }
 
         private static object CoerceIsDropDownOpen(DependencyObject d, object baseValue)
@@ -860,9 +853,9 @@ private RibbonGroupSizeDefinition GetLargeGroupSizeDefinition()
 
             for (int i = 0; i < Items.Count; i++)
             {
-                RibbonControl ribbonControl = ItemContainerGenerator.ContainerFromIndex(i) as RibbonControl;
                 RibbonControlSizeDefinition controlSizeDefinition = null;
-                if (ribbonControl != null)
+
+                if (ItemContainerGenerator.ContainerFromIndex(i) is RibbonControl ribbonControl)
                 {
                     UIElement contentChild = ribbonControl.ContentChild;
                     if (contentChild != null)
@@ -999,10 +992,7 @@ private void UpdateGroupSizeDefinitionsCallback()
                 SetAppropriatePresenterVisibility(GroupSizeDefinitions[_sizeDefinitionIndex] is RibbonGroupSizeDefinition ? Visibility.Visible : Visibility.Collapsed);
 
                 RibbonGroupsPanel panel = TreeHelper.FindVisualAncestor<RibbonGroupsPanel>(this);
-                if (panel != null)
-                {
-                    panel.InvalidateCachedMeasure();
-                }
+                panel?.InvalidateCachedMeasure();
             }
 
             GroupSizeUpdatePending = false;
@@ -1068,8 +1058,7 @@ private void PrepareContainerSize(DependencyObject element)
             int groupSizeDefinitionsCount = groupSizeDefinitions.Count;
             if (_sizeDefinitionIndex >= 0 && _sizeDefinitionIndex < groupSizeDefinitionsCount)
             {
-                RibbonGroupSizeDefinition groupDefinition = groupSizeDefinitions[_sizeDefinitionIndex] as RibbonGroupSizeDefinition;
-                if (groupDefinition != null)
+                if (groupSizeDefinitions[_sizeDefinitionIndex] is RibbonGroupSizeDefinition groupDefinition)
                 {
                     RibbonControlSizeDefinition controlSizeDefinition = null;
                     RibbonControlSizeDefinitionCollection controlSizeDefinitions = groupDefinition.ControlSizeDefinitions;
@@ -1119,8 +1108,7 @@ private void ApplyGroupSizeDefinitionBase(RibbonGroupSizeDefinitionBase definiti
                 remeasure = true;
             }
 
-            RibbonGroupSizeDefinition groupSizeDefinition = definition as RibbonGroupSizeDefinition;
-            if (groupSizeDefinition != null)
+            if (definition is RibbonGroupSizeDefinition groupSizeDefinition)
             {
                 // Apply RibbonGroupSizeDefinition
                 if (SetAppropriatePresenterVisibility(Visibility.Visible))
@@ -1136,8 +1124,7 @@ private void ApplyGroupSizeDefinitionBase(RibbonGroupSizeDefinitionBase definiti
             }
             else
             {
-                RibbonGroupTemplateSizeDefinition groupTemplateSizeDefinition = definition as RibbonGroupTemplateSizeDefinition;
-                if (groupTemplateSizeDefinition != null)
+                if (definition is RibbonGroupTemplateSizeDefinition groupTemplateSizeDefinition)
                 {
                     // Apply RibbonGroupTemplateSizeDefinition
                     SetAppropriatePresenterVisibility(Visibility.Collapsed);
@@ -1186,8 +1173,8 @@ private RibbonControlSizeDefinitionCollection GetControlDefinitionsForCollapsedG
                 {
                     return null;
                 }
-                RibbonGroupSizeDefinition currentGroupSizeDefinition = currentGroupSizeDefinitionBase as RibbonGroupSizeDefinition;
-                if (currentGroupSizeDefinition != null)
+
+                if (currentGroupSizeDefinitionBase is RibbonGroupSizeDefinition currentGroupSizeDefinition)
                 {
                     RibbonControlSizeDefinitionCollection currentControlSizeDefinitions = currentGroupSizeDefinition.ControlSizeDefinitions;
                     if (currentControlSizeDefinitions != null &&
@@ -1256,7 +1243,7 @@ private void ApplyGroupTemplateSizeDefinition(RibbonGroupTemplateSizeDefinition
                         break;
                     }
                     RibbonGroupTemplateSizeDefinition currentGroupSizeDefinition = currentGroupSizeDefinitionBase as RibbonGroupTemplateSizeDefinition;
-                    if (currentGroupSizeDefinition != null && currentGroupSizeDefinition.ContentTemplate != null)
+                    if (currentGroupSizeDefinition?.ContentTemplate != null)
                     {
                         contentTemplate = currentGroupSizeDefinition.ContentTemplate;
                         break;
@@ -1577,16 +1564,14 @@ public IEnumerator<DependencyObject> GetEnumerator()
                     // This should not be done when in QAT.
                     foreach (object item in RibbonGroup.Items)
                     {
-                        DependencyObject element = item as DependencyObject;
-                        if (element != null)
+                        if (item is DependencyObject element)
                         {
                             if (!string.IsNullOrEmpty(KeyTipService.GetKeyTip(element)))
                             {
                                 yield return element;
                             }
 
-                            RibbonControlGroup controlGroup = element as RibbonControlGroup;
-                            if (controlGroup != null &&
+                            if (element is RibbonControlGroup controlGroup &&
                                 !KeyTipService.GetIsKeyTipScope(controlGroup))
                             {
                                 foreach (object controlGroupItem in controlGroup.Items)
@@ -1772,8 +1757,7 @@ protected virtual void OnKeyTipAccessed(KeyTipAccessedEventArgs e)
                 }
                 else
                 {
-                    RibbonTab tab = ItemsControl.ItemsControlFromItemContainer(this) as RibbonTab;
-                    if (tab != null &&
+                    if (ItemsControl.ItemsControlFromItemContainer(this) is RibbonTab tab &&
                         KeyTipService.GetIsKeyTipScope(tab))
                     {
                         e.TargetKeyTipScope = tab;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonHelper.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonHelper.cs
index a8b2f113..bb2bce1f 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonHelper.cs
@@ -479,13 +479,12 @@ internal static bool IsKeyboardMostRecentInputDevice()
 
         public static bool MoveFocus(FocusNavigationDirection direction)
         {
-            UIElement uie = Keyboard.FocusedElement as UIElement;
-            if (uie != null)
+            if (Keyboard.FocusedElement is UIElement uie)
             {
                 return uie.MoveFocus(new TraversalRequest(direction));
             }
-            ContentElement ce = Keyboard.FocusedElement as ContentElement;
-            if (ce != null)
+
+            if (Keyboard.FocusedElement is ContentElement ce)
             {
                 return ce.MoveFocus(new TraversalRequest(direction));
             }
@@ -569,7 +568,6 @@ internal static FrameworkElement FindContainer(ItemsControl itemsControl, int st
                 int count = itemsControl.Items.Count;
                 for (; startIndex >= 0 && startIndex < count; startIndex += direction)
                 {
-                    FrameworkElement container = itemsControl.ItemContainerGenerator.ContainerFromIndex(startIndex) as FrameworkElement;
 
                     // If container is virtualized, call BringIntoView.
                     if (container == null && bringIntoViewCallback != null)
@@ -578,7 +576,7 @@ internal static FrameworkElement FindContainer(ItemsControl itemsControl, int st
                         container = itemsControl.ItemContainerGenerator.ContainerFromIndex(startIndex) as FrameworkElement;
                     }
 
-                    if (container != null && (additionalCheck == null || additionalCheck(container)))
+                    if (itemsControl.ItemContainerGenerator.ContainerFromIndex(startIndex) is FrameworkElement container && (additionalCheck == null || additionalCheck(container)))
                     {
                         return container;
                     }
@@ -660,8 +658,7 @@ private static bool NavigateUpToGallery(RibbonGallery gallery)
         {
             if (gallery != null)
             {
-                RibbonGalleryCategory lastCategory = RibbonHelper.FindContainer(gallery, gallery.Items.Count - 1, -1, null, IsContainerVisible) as RibbonGalleryCategory;
-                if (lastCategory != null)
+                if (RibbonHelper.FindContainer(gallery, gallery.Items.Count - 1, -1, null, IsContainerVisible) is RibbonGalleryCategory lastCategory)
                 {
                     return RibbonHelper.NavigateToLastItem(lastCategory, /* BringIntoView callback */ null, IsContainerFocusable);
                 }
@@ -699,8 +696,7 @@ private static bool NavigateDownToGallery(RibbonGallery gallery)
                     }
                 }
 
-                RibbonGalleryCategory firstCategory = RibbonHelper.FindContainer(gallery, 0, 1, null, IsContainerVisible) as RibbonGalleryCategory;
-                if (firstCategory != null)
+                if (RibbonHelper.FindContainer(gallery, 0, 1, null, IsContainerVisible) is RibbonGalleryCategory firstCategory)
                 {
                     return RibbonHelper.NavigateToFirstItem(firstCategory, /* BringIntoView callback */ null, IsContainerFocusable);
                 }
@@ -730,8 +726,7 @@ internal static bool NavigateAndHighlightGalleryItem(RibbonGalleryItem focusedEl
         {
             if (focusedElement != null)
             {
-                RibbonGalleryItem predictedFocus = focusedElement.PredictFocus(direction) as RibbonGalleryItem;
-                if (predictedFocus != null)
+                if (focusedElement.PredictFocus(direction) is RibbonGalleryItem predictedFocus)
                 {
                     predictedFocus.IsHighlighted = true;
                     return true;
@@ -759,8 +754,7 @@ internal static bool NavigatePageAndHighlightRibbonGalleryItem(RibbonGallery gal
         {
             highlightedGalleryItem = null;
 
-            RibbonGalleryCategoriesPanel categoriesPanel = gallery.ItemsHostSite as RibbonGalleryCategoriesPanel;
-            if (categoriesPanel != null)
+            if (gallery.ItemsHostSite is RibbonGalleryCategoriesPanel categoriesPanel)
             {
                 double viewportWidth = categoriesPanel.ViewportWidth;
                 double viewportHeight = categoriesPanel.ViewportHeight;
@@ -944,25 +938,20 @@ internal static void AddHandler(DependencyObject element, RoutedEvent routedEven
             Debug.Assert(element != null, "Element must not be null");
             Debug.Assert(routedEvent != null, "RoutedEvent must not be null");
 
-            UIElement uiElement = element as UIElement;
-            if (uiElement != null)
+            if (element is UIElement uiElement)
             {
                 uiElement.AddHandler(routedEvent, handler);
             }
             else
             {
-                ContentElement contentElement = element as ContentElement;
-                if (contentElement != null)
+                if (element is ContentElement contentElement)
                 {
                     contentElement.AddHandler(routedEvent, handler);
                 }
                 else
                 {
                     UIElement3D uiElement3D = element as UIElement3D;
-                    if (uiElement3D != null)
-                    {
-                        uiElement3D.AddHandler(routedEvent, handler);
-                    }
+                    uiElement3D?.AddHandler(routedEvent, handler);
                 }
             }
         }
@@ -972,25 +961,20 @@ internal static void RemoveHandler(DependencyObject element, RoutedEvent routedE
             Debug.Assert(element != null, "Element must not be null");
             Debug.Assert(routedEvent != null, "RoutedEvent must not be null");
 
-            UIElement uiElement = element as UIElement;
-            if (uiElement != null)
+            if (element is UIElement uiElement)
             {
                 uiElement.RemoveHandler(routedEvent, handler);
             }
             else
             {
-                ContentElement contentElement = element as ContentElement;
-                if (contentElement != null)
+                if (element is ContentElement contentElement)
                 {
                     contentElement.RemoveHandler(routedEvent, handler);
                 }
                 else
                 {
                     UIElement3D uiElement3D = element as UIElement3D;
-                    if (uiElement3D != null)
-                    {
-                        uiElement3D.RemoveHandler(routedEvent, handler);
-                    }
+                    uiElement3D?.RemoveHandler(routedEvent, handler);
                 }
             }
         }
@@ -1147,10 +1131,7 @@ public static bool IsMousePhysicallyOver(UIElement element)
                     {
                         source = element;
                     }
-                    if (source != null)
-                    {
-                        source.RaiseEvent(new RibbonDismissPopupEventArgs(RibbonDismissPopupMode.MousePhysicallyNotOver));
-                    }
+                    source?.RaiseEvent(new RibbonDismissPopupEventArgs(RibbonDismissPopupMode.MousePhysicallyNotOver));
                 }
             }
         }
@@ -1264,10 +1245,7 @@ public static bool IsMousePhysicallyOver(UIElement element)
                         {
                             settor(false);
                             e.Handled = true;
-                            if (targetFocusOnFalse != null)
-                            {
-                                targetFocusOnFalse.Focus();
-                            }
+                            targetFocusOnFalse?.Focus();
                         }
                     }
                     break;
@@ -1279,8 +1257,7 @@ public static bool IsMousePhysicallyOver(UIElement element)
                         if (gettor())
                         {
                             // Raise DismissPopup event and hence the key down event.
-                            UIElement uie = sender as UIElement;
-                            if (uie != null)
+                            if (sender is UIElement uie)
                             {
                                 RibbonDismissPopupEventArgs dismissArgs = new RibbonDismissPopupEventArgs();
                                 uie.RaiseEvent(dismissArgs);
@@ -1295,10 +1272,7 @@ public static bool IsMousePhysicallyOver(UIElement element)
                         {
                             settor(false);
                             e.Handled = true;
-                            if (targetFocusOnFalse != null)
-                            {
-                                targetFocusOnFalse.Focus();
-                            }
+                            targetFocusOnFalse?.Focus();
                         }
                         else
                         {
@@ -1380,11 +1354,7 @@ public static void InitializeStarLayoutManager(DependencyObject starLayoutProvid
         {
             Debug.Assert(starLayoutProvider != null);
 
-            ISupportStarLayout starLayoutManager = TreeHelper.FindVisualAncestor(starLayoutProvider,
-                RibbonHelper.IsISupportStarLayout) as ISupportStarLayout;
-            IContainsStarLayoutManager iContainsStarLayoutManager = starLayoutProvider as IContainsStarLayoutManager;
-
-            if (iContainsStarLayoutManager != null)
+            if (starLayoutProvider is IContainsStarLayoutManager iContainsStarLayoutManager)
             {
                 IProvideStarLayoutInfoBase iProvideStarLayoutInfoBase = (IProvideStarLayoutInfoBase)starLayoutProvider;
                 if (starLayoutManager == null && iContainsStarLayoutManager.StarLayoutManager != null)
@@ -1392,7 +1362,8 @@ public static void InitializeStarLayoutManager(DependencyObject starLayoutProvid
                     iContainsStarLayoutManager.StarLayoutManager.UnregisterStarLayoutProvider(iProvideStarLayoutInfoBase);
                     iContainsStarLayoutManager.StarLayoutManager = null;
                 }
-                else if (starLayoutManager != null)
+                else if (TreeHelper.FindVisualAncestor(starLayoutProvider,
+                RibbonHelper.IsISupportStarLayout) is ISupportStarLayout starLayoutManager)
                 {
                     if (starLayoutManager != iContainsStarLayoutManager.StarLayoutManager)
                     {
@@ -1415,10 +1386,7 @@ public static void InitializeStarLayoutManager(DependencyObject starLayoutProvid
                     // will already be dirty for measure.
 
                     UIElement managerElement = starLayoutManager as UIElement;
-                    if (managerElement != null)
-                    {
-                        managerElement.InvalidateMeasure();
-                    }
+                    managerElement?.InvalidateMeasure();
                 }
             }
         }
@@ -1473,9 +1441,8 @@ internal static void OnCommandChanged(DependencyObject d, DependencyPropertyChan
         // For Ribbon controls that implement ICommandSource, coerce the QAT ID to be the Command property if QAT ID is unspecified.
         internal static object OnCoerceQuickAccessToolBarId(DependencyObject d, object baseValue)
         {
-            ICommandSource commandSource = d as ICommandSource;
             if (baseValue == null &&
-                commandSource != null)
+                d is ICommandSource commandSource)
             {
                 return commandSource.Command;
             }
@@ -1500,7 +1467,7 @@ internal static object OnCoerceCanAddToQuickAccessToolBarDirectly(DependencyObje
                 if (baseValueSource == BaseValueSource.Default)
                 {
                     FrameworkElement fe =  d as FrameworkElement;
-                    if (fe != null && fe.TemplatedParent != null && !(fe.TemplatedParent is ContentPresenter))
+                    if (fe?.TemplatedParent != null && !(fe.TemplatedParent is ContentPresenter))
                     {
                         return false;
                     }
@@ -1529,8 +1496,7 @@ internal static bool ExistsInQAT(DependencyObject element)
             Ribbon ribbon = (Ribbon)element.GetValue(RibbonControlService.RibbonProperty);
             object qatID = RibbonControlService.GetQuickAccessToolBarId(element);
 
-            if (ribbon != null &&
-                ribbon.QuickAccessToolBar != null &&
+            if (ribbon?.QuickAccessToolBar != null &&
                 qatID != null)
             {
                 return ribbon.QuickAccessToolBar.ContainsId(qatID);
@@ -1577,13 +1543,10 @@ private static void TransferProperty(UIElement original, UIElement clone, Depend
                 }
                 else
                 {
-                    Expression expr = original.ReadLocalValue(originalProperty) as Expression;
-                    if (expr != null)
+                    if (original.ReadLocalValue(originalProperty) is Expression expr)
                     {
                         // Transfer DynamicResource
-
-                        DynamicResourceExtension dynamicResource = _rreConverter.ConvertTo(expr, typeof(MarkupExtension)) as DynamicResourceExtension;
-                        if (dynamicResource != null)
+                        if (_rreConverter.ConvertTo(expr, typeof(MarkupExtension)) is DynamicResourceExtension dynamicResource)
                         {
                             clone.SetValue(cloneProperty, dynamicResource.ProvideValue(null));
                         }
@@ -1876,8 +1839,7 @@ internal static object CreateClone(object original, bool allowTransformations)
             if (original is UIElement ||
                 original is ContentElement)
             {
-                FrameworkElement feOriginal = original as FrameworkElement;
-                if (feOriginal != null)
+                if (original is FrameworkElement feOriginal)
                 {
                     FrameworkElement feClone = CreateInstance(feOriginal, allowTransformations);
 
@@ -1908,8 +1870,7 @@ internal static object CreateClone(object original, bool allowTransformations)
             }
             else
             {
-                Freezable freezable = original as Freezable;
-                if (freezable != null && !freezable.CanFreeze)
+                if (original is Freezable freezable && !freezable.CanFreeze)
                 {
                     return freezable.Clone();
                 }
@@ -1922,9 +1883,7 @@ private static FrameworkElement CreateInstance(FrameworkElement original, bool a
         {
             if (allowTransformations)
             {
-                RibbonMenuItem menuItem = original as RibbonMenuItem;
-
-                if (menuItem != null)
+                if (original is RibbonMenuItem menuItem)
                 {
                     // Determine which control type the wrapper should be
                     // based on the Items and IsCheckable values.
@@ -2077,11 +2036,11 @@ private static void TransferProperties(FrameworkElement original, FrameworkEleme
                             TransferProperties(original, clone, _ribbonGalleryItemProperties);
                         }
                     }
-                    else if (original is ItemsControl)
+                    else if (original is ItemsControl itemsControl)
                     {
                         TransferProperties(original, clone, _itemsControlProperties);
                         TransferProperties(original, clone, _scrollProperties);
-                        TransferItems((ItemsControl)original, (ItemsControl)clone);
+                        TransferItems(itemsControl, (ItemsControl)clone);
 
                         if (original is HeaderedItemsControl)
                         {
@@ -2290,9 +2249,7 @@ private static void TransferMarkupProperties(object original, object clone)
                         continue;
                     }
 
-
-                    BindingBase binding = markupProp.Value as BindingBase;
-                    if (binding != null)
+                    if (markupProp.Value is BindingBase binding)
                     {
                         // Transfer bindings.
 
@@ -2300,8 +2257,7 @@ private static void TransferMarkupProperties(object original, object clone)
                     }
                     else
                     {
-                        MarkupExtension markupExtension = markupProp.Value as MarkupExtension;
-                        if (markupExtension != null)
+                        if (markupProp.Value is MarkupExtension markupExtension)
                         {
                             // Transfer dynamic resources and other markup extensions.
 
@@ -2331,8 +2287,7 @@ private static void TransferMarkupProperties(object original, object clone)
                             continue;
                         }
 
-                        IList items = markupProp.PropertyDescriptor.GetValue(clone) as IList;
-                        if (items != null)
+                        if (markupProp.PropertyDescriptor.GetValue(clone) is IList items)
                         {
                             foreach (MarkupObject subObj in markupProp.Items)
                             {
@@ -2360,8 +2315,7 @@ private static void TransferMarkupProperties(object original, object clone)
 
         internal static void SetApplicationMenuLevel(bool parentIsTopLevel, DependencyObject element)
         {
-            RibbonApplicationMenuItem rami = element as RibbonApplicationMenuItem;
-            if (rami != null)
+            if (element is RibbonApplicationMenuItem rami)
             {
                 if (parentIsTopLevel)
                 {
@@ -2374,8 +2328,7 @@ internal static void SetApplicationMenuLevel(bool parentIsTopLevel, DependencyOb
             }
             else
             {
-                RibbonApplicationSplitMenuItem rasmi = element as RibbonApplicationSplitMenuItem;
-                if (rasmi != null)
+                if (element is RibbonApplicationSplitMenuItem rasmi)
                 {
                     if (parentIsTopLevel)
                     {
@@ -2394,11 +2347,9 @@ internal static bool CoerceIsSubmenuOpenForTopLevelItem(RibbonMenuItem menuItem,
             bool isSubMenuOpen = (bool)baseValue;
             if (!isSubMenuOpen && menuItem.CloseSubmenuTimer != null && menuItem.CloseSubmenuTimer.IsEnabled)
             {
-                RibbonApplicationMenu ram = parentItemsControl as RibbonApplicationMenu;
-                if (ram != null)
+                if (parentItemsControl is RibbonApplicationMenu ram)
                 {
-                    RibbonMenuItem currentMenuItem = ram.RibbonCurrentSelection as RibbonMenuItem;
-                    if (currentMenuItem != null && currentMenuItem.CanOpenSubMenu && currentMenuItem != menuItem)
+                    if (ram.RibbonCurrentSelection is RibbonMenuItem currentMenuItem && currentMenuItem.CanOpenSubMenu && currentMenuItem != menuItem)
                     {
                         return true;
                     }
@@ -2450,8 +2401,7 @@ public static void OnApplicationMenuItemUpDownKeyDown(KeyEventArgs e, RibbonMenu
             if (e.Key == Key.Up ||
                 e.Key == Key.Down)
             {
-                RibbonApplicationMenu applicationMenu = ItemsControl.ItemsControlFromItemContainer(menuItem) as RibbonApplicationMenu;
-                if (applicationMenu != null)
+                if (ItemsControl.ItemsControlFromItemContainer(menuItem) is RibbonApplicationMenu applicationMenu)
                 {
                     if (RibbonHelper.IsEndFocusableMenuItem(menuItem, e.Key == Key.Up /* isFirst */))
                     {
@@ -2504,8 +2454,7 @@ private static bool IsEndFocusableMenuItem(RibbonMenuItem menuItem, bool isFirst
 
             for (int i = itemIndex + incr; i < parentItemCount && i >= 0; i += incr)
             {
-                UIElement container = parentItemsControl.ItemContainerGenerator.ContainerFromIndex(i) as UIElement;
-                if (container != null &&
+                if (parentItemsControl.ItemContainerGenerator.ContainerFromIndex(i) is UIElement container &&
                     container.IsVisible &&
                     container.IsEnabled &&
                     container.Focusable)
@@ -2581,15 +2530,13 @@ public static CultureInfo InvariantEnglishUS
         /// </summary>
         public static UIElement GetContainingUIElement(DependencyObject element)
         {
-            UIElement uie = element as UIElement;
-            if (uie != null)
+            if (element is UIElement uie)
             {
                 return uie;
             }
             else
             {
-                ContentElement ce = element as ContentElement;
-                if (ce != null)
+                if (element is ContentElement ce)
                 {
                     DependencyObject parent = ContentOperations.GetParent(ce);
                     if (parent == null)
@@ -2833,14 +2780,12 @@ public static void OpenParentRibbonGroupDropDownSync(FrameworkElement fe, bool t
                 // Apply template if not yet applied.
                 fe.ApplyTemplate();
             }
-
             // Get the Parent RibbonGroup and open its dropdown if needed.
-            RibbonGroup ribbonGroup = TreeHelper.FindAncestor(fe, delegate(DependencyObject element) { return (element is RibbonGroup); }) as RibbonGroup;
             if (ribbonGroup == null)
             {
                 ribbonGroup = TreeHelper.FindLogicalAncestor<RibbonGroup>(fe);
             }
-            if (ribbonGroup != null &&
+            if (TreeHelper.FindAncestor(fe, delegate(DependencyObject element) { return (element is RibbonGroup); }) is RibbonGroup ribbonGroup &&
                 ribbonGroup.IsCollapsed &&
                 !ribbonGroup.IsDropDownOpen)
             {
@@ -2858,8 +2803,7 @@ internal static AutomationPeer CreatePeer(UIElement element)
             AutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(element);
             if (peer == null)
             {
-                FrameworkElement elementFE = element as FrameworkElement;
-                if (elementFE != null)
+                if (element is FrameworkElement elementFE)
                     peer = new FrameworkElementAutomationPeer(elementFE);
                 else
                     peer = new UIElementAutomationPeer(element);
@@ -2965,8 +2909,8 @@ public static bool FixMeasureInvalidationPaths(DependencyObject element)
                     measureInvalid |= FixMeasureInvalidationPaths(child);
                 }
             }
-            UIElement uie = element as UIElement;
-            if (uie != null)
+
+            if (element is UIElement uie)
             {
                 if (!uie.IsMeasureValid)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonKeyTipAndContentSyncHelper.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonKeyTipAndContentSyncHelper.cs
index ec140fe8..8e596d4c 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonKeyTipAndContentSyncHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonKeyTipAndContentSyncHelper.cs
@@ -38,8 +38,8 @@ public static void Sync(ISyncKeyTipAndContent syncElement, DependencyProperty co
                 {
                     string keyTip = KeyTipService.GetKeyTip(element);
                     bool isKeyTipSet = !string.IsNullOrEmpty(keyTip);
-                    string stringContent = element.GetValue(contentProperty) as string;
-                    if (stringContent != null)
+
+                    if (element.GetValue(contentProperty) is string stringContent)
                     {
                         int accessKeyIndex = RibbonHelper.FindAccessKeyMarker(stringContent);
                         if (isKeyTipSet)
@@ -100,8 +100,7 @@ public static void OnKeyTipChanged(ISyncKeyTipAndContent syncElement, Dependency
                 syncElement.KeepKeyTipAndContentInSync = false;
                 if (string.IsNullOrEmpty((string)baseValue))
                 {
-                    string stringContent = element.GetValue(contentProperty) as string;
-                    if (stringContent != null)
+                    if (element.GetValue(contentProperty) is string stringContent)
                     {
                         int accessIndex = RibbonHelper.FindAccessKeyMarker(stringContent);
                         if (accessIndex >= 0 && accessIndex < stringContent.Length - 1)
@@ -142,8 +141,8 @@ public static void OnContentPropertyChanged(ISyncKeyTipAndContent syncElement, D
                 syncElement.IsKeyTipSyncSource)
             {
                 syncElement.KeepKeyTipAndContentInSync = false;
-                string stringContent = baseValue as string;
-                if (stringContent != null)
+
+                if (baseValue is string stringContent)
                 {
                     if (RibbonHelper.FindAccessKeyMarker(stringContent) < 0)
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuButton.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuButton.cs
index ab9073cf..2cbe00a2 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuButton.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuButton.cs
@@ -576,8 +576,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
             }
             else
             {
-                RibbonSeparator separator = element as RibbonSeparator;
-                if (separator != null)
+                if (element is RibbonSeparator separator)
                 {
                     ValueSource vs = DependencyPropertyHelper.GetValueSource(separator, StyleProperty);
                     if (vs.BaseValueSource <= BaseValueSource.ImplicitStyleReference)
@@ -804,7 +803,6 @@ internal void OnNavigationKeyDown(KeyEventArgs e)
                 }
             }
             bool handled = false;
-            DependencyObject focusedElement = Keyboard.FocusedElement as DependencyObject;
             switch (e.Key)
             {
                 case Key.Home:
@@ -855,7 +853,7 @@ internal void OnNavigationKeyDown(KeyEventArgs e)
 
                 case Key.Tab:
                     if (IsDropDownOpen &&
-                        (IsFocused || (focusedElement != null && TreeHelper.IsVisualAncestorOf(this, focusedElement))))
+                        (IsFocused || (Keyboard.FocusedElement is DependencyObject focusedElement && TreeHelper.IsVisualAncestorOf(this, focusedElement))))
                     {
                         if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift)
                         {
@@ -889,9 +887,7 @@ internal void OnNavigationKeyDown(KeyEventArgs e)
         /// </summary>
         private static void OnRibbonIsSelectedChanged(object sender, RoutedPropertyChangedEventArgs<bool> e)
         {
-            FrameworkElement selectionItem = e.OriginalSource as FrameworkElement;
-
-            if (selectionItem != null)
+            if (e.OriginalSource is FrameworkElement selectionItem)
             {
                 RibbonMenuButton menu = (RibbonMenuButton)sender;
 
@@ -989,9 +985,9 @@ void OnPopupResizeStarted(object sender, DragStartedEventArgs e)
             // Clear selection and close submenus when resizing.
             if (RibbonCurrentSelection != null)
             {
-                RibbonMenuItem selectedMenuItem = RibbonCurrentSelection as RibbonMenuItem;
                 RibbonCurrentSelection = null;
-                if (selectedMenuItem != null)
+
+                if (RibbonCurrentSelection is RibbonMenuItem selectedMenuItem)
                 {
                     selectedMenuItem.IsSubmenuOpen = false;
                 }
@@ -1048,10 +1044,7 @@ internal bool ResizePopupInternal(double newWidth, double newHeight)
 
         internal void BringIndexIntoView(int index)
         {
-            if (_itemsHost != null)
-            {
-                _itemsHost.BringIndexIntoViewInternal(index);
-            }
+            _itemsHost?.BringIndexIntoViewInternal(index);
         }
 
         private void OnDropDownOpened(EventArgs e)
@@ -1130,10 +1123,7 @@ internal virtual void OnIsDropDownOpenChanged(DependencyPropertyChangedEventArgs
 
             // Raise UI Automation Events
             RibbonMenuButtonAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as RibbonMenuButtonAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent(!(bool)e.OldValue, !(bool)e.NewValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent(!(bool)e.OldValue, !(bool)e.NewValue);
         }
 
         private static object CoerceIsDropDownOpen(DependencyObject d, object baseValue)
@@ -1399,8 +1389,7 @@ internal RibbonToggleButton PartToggleButton
         /// <param name="e"></param>
         protected override void HandleMouseButton(MouseButtonEventArgs e)
         {
-            FrameworkElement source = e.OriginalSource as FrameworkElement;
-            if (source != null && (source == this || source.TemplatedParent == this))
+            if (e.OriginalSource is FrameworkElement source && (source == this || source.TemplatedParent == this))
             {
                 e.Handled = true;
             }
@@ -1495,10 +1484,7 @@ protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChanged
                     // ...call PopMenuMode.
                     MethodInfo method = type.GetMethod("PopMenuMode", BindingFlags.NonPublic | BindingFlags.Instance);
                     Debug.Assert(method != null);
-                    if (method != null)
-                    {
-                        method.Invoke(this, null);
-                    }
+                    method?.Invoke(this, null);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuItem.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuItem.cs
index 39b6d83a..9032eb8e 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonMenuItem.cs
@@ -551,8 +551,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
             }
             else
             {
-                RibbonSeparator separator = element as RibbonSeparator;
-                if (separator != null)
+                if (element is RibbonSeparator separator)
                 {
                     ValueSource vs = DependencyPropertyHelper.GetValueSource(separator, StyleProperty);
                     if (vs.BaseValueSource <= BaseValueSource.ImplicitStyleReference)
@@ -677,8 +676,7 @@ public override void OnApplyTemplate()
         /// <param name="e"></param>
         private void OnPopupOpened(object sender, EventArgs e)
         {
-            RibbonToolTip toolTip = ToolTip as RibbonToolTip;
-            if (toolTip != null)
+            if (ToolTip is RibbonToolTip toolTip)
             {
                 toolTip.IsOpen = false;
             }
@@ -726,10 +724,7 @@ protected override void OnMouseLeave(System.Windows.Input.MouseEventArgs e)
                 if (IsKeyboardFocusWithin)
                 {
                     ItemsControl parent = ItemsControl.ItemsControlFromItemContainer(this);
-                    if (parent != null)
-                    {
-                        parent.Focus();
-                    }
+                    parent?.Focus();
                 }
             }
 
@@ -1052,9 +1047,9 @@ void OnPopupResizeStarted(object sender, DragStartedEventArgs e)
             // Clear selection and close submenus when resizing.
             if (RibbonCurrentSelection != null)
             {
-                RibbonMenuItem selectedMenuItem = RibbonCurrentSelection as RibbonMenuItem;
                 RibbonCurrentSelection = null;
-                if (selectedMenuItem != null)
+
+                if (RibbonCurrentSelection is RibbonMenuItem selectedMenuItem)
                 {
                     selectedMenuItem.IsSubmenuOpen = false;
                 }
@@ -1232,10 +1227,7 @@ private void CloseSubmenu()
 
         internal void BringIndexIntoView(int index)
         {
-            if (_itemsHost != null)
-            {
-                _itemsHost.BringIndexIntoViewInternal(index);
-            }
+            _itemsHost?.BringIndexIntoViewInternal(index);
         }
 
         private static bool IsContainerFocusable(FrameworkElement container)
@@ -1246,10 +1238,7 @@ private static bool IsContainerFocusable(FrameworkElement container)
         private static void OnIsCheckedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
             RibbonMenuItemAutomationPeer peer = UIElementAutomationPeer.FromElement((RibbonMenuItem)d) as RibbonMenuItemAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseToggleStatePropertyChangedEvent((bool)e.OldValue, (bool)e.NewValue);
-            }
+            peer?.RaiseToggleStatePropertyChangedEvent((bool)e.OldValue, (bool)e.NewValue);
         }
 
         private static void OnIsSubmenuOpenChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
@@ -1303,10 +1292,7 @@ private static void OnIsSubmenuOpenChanged(DependencyObject sender, DependencyPr
             menuItem.RibbonCurrentSelection = null;
 
             RibbonMenuItemAutomationPeer peer = UIElementAutomationPeer.FromElement(menuItem) as RibbonMenuItemAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent((bool)e.OldValue, (bool)e.NewValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent((bool)e.OldValue, (bool)e.NewValue);
         }
 
         private object UpdateDropDownPosition(object arg)
@@ -1503,10 +1489,9 @@ private static void OnRibbonIsSelectedChanged(object sender, RoutedPropertyChang
             if (sender != e.OriginalSource)
             {
                 RibbonMenuItem menuItem = (RibbonMenuItem)sender;
-                FrameworkElement selectionItem = e.OriginalSource as FrameworkElement;
                 if (e.NewValue)
                 {
-                    if (selectionItem != null)
+                    if (e.OriginalSource is FrameworkElement selectionItem)
                     {
                         ItemsControl parentItemsControl = ItemsControl.ItemsControlFromItemContainer(selectionItem);
                         if (menuItem == parentItemsControl)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonQuickAccessToolBar.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonQuickAccessToolBar.cs
index 6b843c3e..cb13e2fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonQuickAccessToolBar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonQuickAccessToolBar.cs
@@ -192,10 +192,7 @@ private static void OnIsOverflowOpenChanged(DependencyObject sender, DependencyP
 
             // Raise UI Automation Events
             RibbonQuickAccessToolBarAutomationPeer peer = UIElementAutomationPeer.FromElement(qat) as RibbonQuickAccessToolBarAutomationPeer;
-            if (peer != null)
-            {
-                peer.RaiseExpandCollapseAutomationEvent(!(bool)e.OldValue, !(bool)e.NewValue);
-            }
+            peer?.RaiseExpandCollapseAutomationEvent(!(bool)e.OldValue, !(bool)e.NewValue);
         }
 
         private static object OnCoerceIsOverflowOpen(DependencyObject d, object baseValue)
@@ -338,10 +335,7 @@ private void InvalidateLayout()
             InvalidateMeasure();
 
             RibbonQuickAccessToolBarPanel toolBarPanel = this.MainPanel;
-            if (toolBarPanel != null)
-            {
-                toolBarPanel.InvalidateMeasure();
-            }
+            toolBarPanel?.InvalidateMeasure();
         }
 
         /// <summary>
@@ -528,8 +522,7 @@ internal bool ContainsId(object targetID)
         {
             foreach (object o in this.Items)
             {
-                DependencyObject dependencyObject = o as DependencyObject;
-                if (dependencyObject != null)
+                if (o is DependencyObject dependencyObject)
                 {
                     object currentID = RibbonControlService.GetQuickAccessToolBarId(dependencyObject);
                     if (object.Equals(currentID, targetID))
@@ -591,8 +584,7 @@ public IEnumerator<DependencyObject> GetEnumerator()
                 // Set KeyTip for all non-overflow items
                 for (int i = 0; i < itemCount; i++)
                 {
-                    RibbonControl ribbonControl = QuickAccessToolBar.ItemContainerGenerator.ContainerFromIndex(i) as RibbonControl;
-                    if (ribbonControl != null)
+                    if (QuickAccessToolBar.ItemContainerGenerator.ContainerFromIndex(i) is RibbonControl ribbonControl)
                     {
                         if (GetIsOverflowItem(ribbonControl))
                         {
@@ -617,8 +609,7 @@ public IEnumerator<DependencyObject> GetEnumerator()
                     // Set KeyTip for overflow items.
                     for (int i = overflowStartIndex; i < itemCount; i++)
                     {
-                        RibbonControl ribbonControl = QuickAccessToolBar.ItemContainerGenerator.ContainerFromIndex(i) as RibbonControl;
-                        if (ribbonControl != null &&
+                        if (QuickAccessToolBar.ItemContainerGenerator.ContainerFromIndex(i) is RibbonControl ribbonControl &&
                             ribbonControl.Visibility == Visibility.Visible &&
                             GetIsOverflowItem(ribbonControl))
                         {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitButton.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitButton.cs
index ee2a2202..f6dba7c6 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitButton.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitButton.cs
@@ -403,10 +403,7 @@ private void OnHeaderClicked(object sender, RoutedEventArgs e)
             if (!IsCheckable && AutomationPeer.ListenerExists(AutomationEvents.InvokePatternOnInvoked))
             {
                 RibbonSplitButtonAutomationPeer peer = UIElementAutomationPeer.FromElement(this) as RibbonSplitButtonAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseInvokeAutomationEvent();
-                }
+                peer?.RaiseInvokeAutomationEvent();
             }
         }
 
@@ -416,10 +413,7 @@ private static void OnIsCheckedChanged(DependencyObject d, DependencyPropertyCha
             if (splitButton.IsCheckable)
             {
                 RibbonSplitButtonAutomationPeer peer = UIElementAutomationPeer.FromElement(splitButton) as RibbonSplitButtonAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseToggleStatePropertyChangedEvent((bool)e.OldValue, (bool)e.NewValue);
-                }
+                peer?.RaiseToggleStatePropertyChangedEvent((bool)e.OldValue, (bool)e.NewValue);
             }
         }
 
@@ -523,15 +517,14 @@ public string HeaderKeyTip
         private Image GetHeaderImage()
         {
             Image imagePart = null;
-            RibbonButton button = _headerButton as RibbonButton;
-            if (button != null)
+
+            if (_headerButton is RibbonButton button)
             {
                 imagePart = button.Image;
             }
             else
             {
-                RibbonToggleButton toggleButton = _headerButton as RibbonToggleButton;
-                if (toggleButton != null)
+                if (_headerButton is RibbonToggleButton toggleButton)
                 {
                     imagePart = toggleButton.Image;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitMenuItem.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitMenuItem.cs
index 3af9bce4..c035c0bf 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitMenuItem.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonSplitMenuItem.cs
@@ -203,8 +203,7 @@ private static void OnIsCheckedChanged(DependencyObject d, DependencyPropertyCha
         {
             RibbonSplitMenuItem splitMenuItem = (RibbonSplitMenuItem)d;
 
-            RibbonToggleButton toggleButton = splitMenuItem._headerButton as RibbonToggleButton;
-            if (toggleButton != null)
+            if (splitMenuItem._headerButton is RibbonToggleButton toggleButton)
             {
                 toggleButton.IsChecked = splitMenuItem.IsChecked;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTab.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTab.cs
index aca7ec4d..c22171ee 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTab.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTab.cs
@@ -248,8 +248,7 @@ protected override bool IsItemItsOwnContainerOverride(object item)
 
         protected override void PrepareContainerForItemOverride(DependencyObject element, object item)
         {
-            ItemsControl childItemsControl = element as ItemsControl;
-            if (childItemsControl != null)
+            if (element is ItemsControl childItemsControl)
             {
                 // copy templates and styles from this ItemsControl
                 var itemTemplate = RibbonHelper.GetValueAndValueSource(childItemsControl, ItemsControl.ItemTemplateProperty);
@@ -286,20 +285,14 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
             }
 
             RibbonGroup ribbonGroup = element as RibbonGroup;
-            if (ribbonGroup != null)
-            {
-                ribbonGroup.PrepareRibbonGroup();
-            }
+            ribbonGroup?.PrepareRibbonGroup();
         }
 
         protected override void ClearContainerForItemOverride(DependencyObject element, object item)
         {
             base.ClearContainerForItemOverride(element, item);
             RibbonGroup ribbonGroup = element as RibbonGroup;
-            if (ribbonGroup != null)
-            {
-                ribbonGroup.ClearRibbonGroup();
-            }
+            ribbonGroup?.ClearRibbonGroup();
         }
 
         /// <summary>
@@ -375,9 +368,8 @@ protected override void OnKeyDown(KeyEventArgs e)
 
             if (!e.Handled)
             {
-                DependencyObject focusedElement = Keyboard.FocusedElement as DependencyObject;
                 RibbonTabHeader tabHeader = RibbonTabHeader;
-                if (e.Key == Key.Up && focusedElement != null && tabHeader != null)
+                if (e.Key == Key.Up && Keyboard.FocusedElement is DependencyObject focusedElement && tabHeader != null)
                 {
                     // On arrow up key press if the focus goes out of the tab,
                     // then force it to move to the corresponding TabHeader.
@@ -562,8 +554,8 @@ private bool DefaultCyclicalReduceGroup()
                 do
                 {
                     numAttempts++;
-                    RibbonGroup group = ItemContainerGenerator.ContainerFromIndex((_groupAutoResizeIndex--).Value) as RibbonGroup;
-                    if (group != null)
+
+                    if (ItemContainerGenerator.ContainerFromIndex((_groupAutoResizeIndex--).Value) is RibbonGroup group)
                     {
                         resizeSuccessful = group.DecreaseGroupSize();
                     }
@@ -615,10 +607,7 @@ internal void PrepareRibbonTab()
             CoerceValue(VisibilityProperty);
 
             RibbonTabHeader tabHeader = RibbonTabHeader;
-            if (tabHeader != null)
-            {
-                tabHeader.InitializeTransferProperties();
-            }
+            tabHeader?.InitializeTransferProperties();
         }
 
         internal void NotifyPropertyChanged(DependencyPropertyChangedEventArgs e)
@@ -698,10 +687,7 @@ private static void OnHeaderChanged(DependencyObject d, DependencyPropertyChange
         {
             RibbonTab tab = (RibbonTab)d;
             Ribbon ribbon = tab.Ribbon;
-            if (ribbon != null)
-            {
-                ribbon.NotifyTabHeaderChanged();
-            }
+            ribbon?.NotifyTabHeaderChanged();
             OnNotifyHeaderPropertyChanged(d, e);
         }
 
@@ -720,20 +706,14 @@ private static void OnIsSelectedChanged(DependencyObject sender, DependencyPrope
                 ribbonTab.OnUnselected(new RoutedEventArgs(Selector.UnselectedEvent, ribbonTab));
             }
             RibbonTabHeader header = ribbonTab.RibbonTabHeader;
-            if (header != null)
-            {
-                header.CoerceValue(RibbonTabHeader.IsRibbonTabSelectedProperty);
-            }
+            header?.CoerceValue(RibbonTabHeader.IsRibbonTabSelectedProperty);
 
             // Raise UI automation events on this RibbonTab
             if ( AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementSelected)
                 || AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection))
             {
                 RibbonTabAutomationPeer peer = RibbonTabAutomationPeer.CreatePeerForElement(ribbonTab) as RibbonTabAutomationPeer;
-                if (peer != null)
-                {
-                    peer.RaiseTabSelectionEvents();
-                }
+                peer?.RaiseTabSelectionEvents();
             }
         }
 
@@ -744,10 +724,7 @@ private static void OnIsEnabledChanged(DependencyObject sender, DependencyProper
         {
             RibbonTab ribbonTab = (RibbonTab)sender;
             RibbonTabHeader header = ribbonTab.RibbonTabHeader;
-            if (header != null)
-            {
-                header.CoerceValue(RibbonTabHeader.IsEnabledProperty);
-            }
+            header?.CoerceValue(RibbonTabHeader.IsEnabledProperty);
         }
 
         /// <summary>
@@ -787,8 +764,7 @@ private RibbonGroup FindRibbonGroupWithName(string groupName)
             int itemCount = Items.Count;
             for (int i = 0; i < itemCount; i++)
             {
-                RibbonGroup group = ItemContainerGenerator.ContainerFromIndex(i) as RibbonGroup;
-                if (group != null && group.Name == groupName)
+                if (ItemContainerGenerator.ContainerFromIndex(i) is RibbonGroup group && group.Name == groupName)
                 {
                     return group;
                 }
@@ -801,10 +777,7 @@ private static void OnNotifyHeaderPropertyChanged(DependencyObject d, Dependency
             RibbonTab tab = (RibbonTab)d;
             tab.NotifyPropertyChanged(e);
             RibbonTabHeader tabHeader = tab.RibbonTabHeader;
-            if (tabHeader != null)
-            {
-                tabHeader.NotifyPropertyChanged(e);
-            }
+            tabHeader?.NotifyPropertyChanged(e);
         }
 
         private static object CoerceHeaderStyle(DependencyObject d, object baseValue)
@@ -844,10 +817,7 @@ private static void OnKeyTipChanged(DependencyObject d, DependencyPropertyChange
         {
             RibbonTab tab = (RibbonTab)d;
             RibbonTabHeader tabHeader = tab.RibbonTabHeader;
-            if (tabHeader != null)
-            {
-                tabHeader.CoerceValue(KeyTipService.KeyTipProperty);
-            }
+            tabHeader?.CoerceValue(KeyTipService.KeyTipProperty);
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeader.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeader.cs
index ad6c9923..67b9ab6e 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeader.cs
@@ -524,10 +524,7 @@ private static object CoerceVisibility(DependencyObject d, object baseValue)
         private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e)
         {
             Panel parentPanel = VisualTreeHelper.GetParent(this) as Panel;
-            if (parentPanel != null)
-            {
-                parentPanel.InvalidateMeasure();
-            }
+            parentPanel?.InvalidateMeasure();
         }
 
         private static void OnIsRibbonTabSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeaderItemsControl.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeaderItemsControl.cs
index f6d46249..c6f93bce 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeaderItemsControl.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonTabHeaderItemsControl.cs
@@ -107,10 +107,7 @@ protected override void PrepareContainerForItemOverride(DependencyObject element
         {
             base.PrepareContainerForItemOverride(element, item);
             RibbonTabHeader header = element as RibbonTabHeader;
-            if (header != null)
-            {
-                header.PrepareRibbonTabHeader();
-            }
+            header?.PrepareRibbonTabHeader();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonToolTip.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonToolTip.cs
index e4d0234c..89f008ac 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonToolTip.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonToolTip.cs
@@ -339,10 +339,8 @@ private static object CoerceIsOpen(DependencyObject d, object value)
                     DependencyObject visualParent = VisualTreeHelper.GetParent(element);
                     if (visualParent == null)
                     {
-                        // This special check is for the case that the PlacementTarget is 
-                        // within the Popup of a Collapsed RibbonGroup
-                        Popup popupParent = LogicalTreeHelper.GetParent(element) as Popup;
-                        if (popupParent != null)
+                        // This special check is for the case that the PlacementTarget is                         // within the Popup of a Collapsed RibbonGroup
+                        if (LogicalTreeHelper.GetParent(element) is Popup popupParent)
                         {
                             ribbonGroup = popupParent.TemplatedParent as RibbonGroup;
                         }
@@ -422,12 +420,8 @@ private CustomPopupPlacement[] PlaceRibbonToolTip(Size popupSize, Size targetSiz
 
                 if (referenceFE != null)
                 {
-                    // When RibbonControl (PlacementTarget) is within a collapsed group RibbonToolTip is 
-                    // placed just below the Popup or just above the Popup (in case there is not enough 
-                    // screen space left below the Popup).
-
-                    MatrixTransform transform = referenceFE.TransformToDescendant(placementTarget) as MatrixTransform;
-                    if (transform != null)
+                    // When RibbonControl (PlacementTarget) is within a collapsed group RibbonToolTip is                     // placed just below the Popup or just above the Popup (in case there is not enough                     // screen space left below the Popup).
+                    if (referenceFE.TransformToDescendant(placementTarget) is MatrixTransform transform)
                     {
                         MatrixTransform deviceTransform = new MatrixTransform(RibbonHelper.GetTransformToDevice(referenceFE));
                         GeneralTransformGroup transformGroup = new GeneralTransformGroup();
@@ -445,11 +439,8 @@ private CustomPopupPlacement[] PlaceRibbonToolTip(Size popupSize, Size targetSiz
             }
             else
             {
-                // If PlacementTarget isn't within a RibbonGroup we shouldn't have 
-                // gotten here in the first place. But now that we are we will make 
-                // the best attempt at emulating PlacementMode.Bottom.
-                FrameworkElement placementTargetAsFE = placementTarget as FrameworkElement;
-                if (placementTargetAsFE != null)
+                // If PlacementTarget isn't within a RibbonGroup we shouldn't have                 // gotten here in the first place. But now that we are we will make                 // the best attempt at emulating PlacementMode.Bottom.
+                if (placementTarget is FrameworkElement placementTargetAsFE)
                 {
                     belowOffsetY = targetSize.Height;
                     aboveOffsetY = -popupSize.Height;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonWindow.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonWindow.cs
index c2f584bc..077479f8 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonWindow.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/RibbonWindow.cs
@@ -169,8 +169,7 @@ protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e)
 
         private static void MinimizeWindowCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null &&
+            if (sender is RibbonWindow rw &&
                 rw.WindowState != WindowState.Minimized)
             {
                 args.CanExecute = true;
@@ -179,8 +178,7 @@ private static void MinimizeWindowCanExecute(object sender, CanExecuteRoutedEven
 
         private static void MinimizeWindowExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null)
+            if (sender is RibbonWindow rw)
             {
 #if RIBBON_IN_FRAMEWORK
                 SystemCommands.MinimizeWindow(rw);
@@ -193,8 +191,7 @@ private static void MinimizeWindowExecuted(object sender, ExecutedRoutedEventArg
 
         private static void MaximizeWindowCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null
+            if (sender is RibbonWindow rw
                 && rw.WindowState != WindowState.Maximized)
             {
                 args.CanExecute = true;
@@ -203,8 +200,7 @@ private static void MaximizeWindowCanExecute(object sender, CanExecuteRoutedEven
 
         private static void MaximizeWindowExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null)
+            if (sender is RibbonWindow rw)
             {
 #if RIBBON_IN_FRAMEWORK
                 SystemCommands.MaximizeWindow(rw);
@@ -217,8 +213,7 @@ private static void MaximizeWindowExecuted(object sender, ExecutedRoutedEventArg
 
         private static void RestoreWindowCanExecute(object sender, CanExecuteRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null &&
+            if (sender is RibbonWindow rw &&
                 rw.WindowState != WindowState.Normal)
             {
                 args.CanExecute = true;
@@ -227,8 +222,7 @@ private static void RestoreWindowCanExecute(object sender, CanExecuteRoutedEvent
 
         private static void RestoreWindowExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null)
+            if (sender is RibbonWindow rw)
             {
 #if RIBBON_IN_FRAMEWORK
                 SystemCommands.RestoreWindow(rw);
@@ -246,8 +240,7 @@ private static void CloseWindowCanExecute(object sender, CanExecuteRoutedEventAr
 
         private static void CloseWindowExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null)
+            if (sender is RibbonWindow rw)
             {
 #if RIBBON_IN_FRAMEWORK
                 SystemCommands.CloseWindow(rw);
@@ -265,14 +258,13 @@ private static void SystemMenuCanExecute(object sender, CanExecuteRoutedEventArg
 
         private static void SystemMenuExecuted(object sender, ExecutedRoutedEventArgs args)
         {
-            RibbonWindow rw = sender as RibbonWindow;
-            if (rw != null)
+            if (sender is RibbonWindow rw)
             {
                 // For right-clicks, display the system menu from the point of the mouse click.
                 // For left-clicks, display the system menu in the top-left corner of the client area.
                 Point devicePoint;
-                MouseButtonEventArgs e = args.Parameter as MouseButtonEventArgs;
-                if (e != null)
+
+                if (args.Parameter is MouseButtonEventArgs e)
                 {
                     // This is the right-click handler.  The presence of a MouseButtonEventArgs as args.Parameter
                     // indicates we are handling right-click.
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/StringCollectionConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/StringCollectionConverter.cs
index bc6de7bb..65a55ecb 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/StringCollectionConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/Ribbon/StringCollectionConverter.cs
@@ -55,8 +55,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         /// <returns>A StringCollection converted from value.</returns>
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
         {
-            string valueAsStr = value as string;
-            if (valueAsStr != null)
+            if (value is string valueAsStr)
             {
                 string str = valueAsStr.Trim();
                 if (str.Length == 0)
@@ -109,8 +108,7 @@ public override object ConvertTo(ITypeDescriptorContext context, CultureInfo cul
                 throw new ArgumentNullException("destinationType");
             }
 
-            StringCollection stringCollectionValue = value as StringCollection;
-            if (stringCollectionValue != null)
+            if (value is StringCollection stringCollectionValue)
             {
                 if (destinationType == typeof(string))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/TextSearchInternal.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/TextSearchInternal.cs
index c80baa36..a7b56b29 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/TextSearchInternal.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Controls/TextSearchInternal.cs
@@ -146,8 +146,7 @@ internal bool DoHierarchicalSearch(string nextChar)
             for (int currentIndex = startItemsControlIndex; currentIndex < itemCount; )
             {
                 // Skip over filtered categories
-                ItemsControl childItemsControl = _attachedTo.ItemContainerGenerator.ContainerFromIndex(currentIndex) as ItemsControl;
-                if (childItemsControl != null && childItemsControl.Visibility == Visibility.Visible)
+                if (_attachedTo.ItemContainerGenerator.ContainerFromIndex(currentIndex) is ItemsControl childItemsControl && childItemsControl.Visibility == Visibility.Visible)
                 {
                     int startItemIndex = 0;
 
@@ -508,8 +507,7 @@ internal static object FindMatchingPrefix(ItemsControl itemsControl, string pref
                 foreach (object item in itemsControl.Items)
                 {
                     // Skip over filtered categories
-                    ItemsControl childItemsControl = itemsControl.ItemContainerGenerator.ContainerFromItem(item) as ItemsControl;
-                    if (childItemsControl != null && childItemsControl.Visibility == Visibility.Visible)
+                    if (itemsControl.ItemContainerGenerator.ContainerFromItem(item) is ItemsControl childItemsControl && childItemsControl.Visibility == Visibility.Visible)
                     {
                         int matchedIndex = FindMatchingPrefix(childItemsControl, prefix, doHierarchicalSearch);
                         if (matchedIndex != -1)
@@ -591,16 +589,9 @@ private static string GetPrimaryTextPath(ItemsControl itemsControl, bool doHiera
 
         private static string GetPrimaryText(object item, string primaryTextPath)
         {
-            // Order of precedence for getting Primary Text is as follows:
-            //
-            // 1) PrimaryText
-            // 2) PrimaryTextPath (TextSearch.TextPath or ItemsControl.DisplayMemberPath)
-            // 3) GetPlainText()
-            // 4) ToString()
+            // Order of precedence for getting Primary Text is as follows:            //            // 1) PrimaryText            // 2) PrimaryTextPath (TextSearch.TextPath or ItemsControl.DisplayMemberPath)            // 3) GetPlainText()            // 4) ToString()
 
-            DependencyObject itemDO = item as DependencyObject;
-
-            if (itemDO != null)
+            if (item is DependencyObject itemDO)
             {
                 string primaryText = (string)itemDO.GetValue(TextSearch.TextProperty);
 
@@ -719,10 +710,7 @@ private void ResetState()
                 _charsEntered.Clear();
             }
 
-            if(_timeoutTimer != null)
-            {
-                _timeoutTimer.Stop();
-            }
+            _timeoutTimer?.Stop();
             _timeoutTimer = null;
 
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Input/CommandHelpers.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Input/CommandHelpers.cs
index 6e7a88ee..3a060679 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Input/CommandHelpers.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Controls.Ribbon/Microsoft/Windows/Input/CommandHelpers.cs
@@ -32,9 +32,7 @@ internal static void InvokeCommandSource(object parameter, object previewParamet
             
             if (command != null)
             {
-                RoutedCommand routed = command as RoutedCommand;
-
-                if (routed != null)
+                if (command is RoutedCommand routed)
                 {
                     IInputElement target = commandSource.CommandTarget;
 
@@ -62,17 +60,11 @@ internal static void InvokeCommandSource(object parameter, object previewParamet
                     {
                         case CommandOperation.Preview:
                             previewCommand = command as IPreviewCommand;
-                            if (previewCommand != null)
-                            {
-                                previewCommand.Preview(previewParameter);
-                            }
+                            previewCommand?.Preview(previewParameter);
                             break;
                         case CommandOperation.CancelPreview:
                             previewCommand = command as IPreviewCommand;
-                            if (previewCommand != null)
-                            {
-                                previewCommand.CancelPreview();
-                            }
+                            previewCommand?.CancelPreview();
                             break;
                         case CommandOperation.Execute:
                             command.Execute(parameter);
@@ -94,9 +86,7 @@ internal static bool CanExecuteCommandSource(object parameter, ICommandSource co
 
             if (command != null)
             {
-                RoutedCommand routed = command as RoutedCommand;
-
-                if (routed != null)
+                if (command is RoutedCommand routed)
                 {
                     IInputElement target = commandSource.CommandTarget;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/InertiaProcessor2D.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/InertiaProcessor2D.cs
index d2273ef8..55eacb3f 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/InertiaProcessor2D.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/InertiaProcessor2D.cs
@@ -328,22 +328,19 @@ public void SetParameters(InertiaParameters2D parameters)
         {
             Validations.CheckNotNull(parameters, "parameters");
 
-            InertiaTranslationBehavior2D translationParameters = parameters as InertiaTranslationBehavior2D;
-            if (translationParameters != null)
+            if (parameters is InertiaTranslationBehavior2D translationParameters)
             {
                 TranslationBehavior = translationParameters;
                 return;
             }
 
-            InertiaRotationBehavior2D rotationParameters = parameters as InertiaRotationBehavior2D;
-            if (rotationParameters != null)
+            if (parameters is InertiaRotationBehavior2D rotationParameters)
             {
                 RotationBehavior = rotationParameters;
                 return;
             }
 
-            InertiaExpansionBehavior2D expansionParameters = parameters as InertiaExpansionBehavior2D;
-            if (expansionParameters != null)
+            if (parameters is InertiaExpansionBehavior2D expansionParameters)
             {
                 ExpansionBehavior = expansionParameters;
                 return;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/ManipulationSequence.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/ManipulationSequence.cs
index 6fa348ae..27d3ebae 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/ManipulationSequence.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Input.Manipulations/System/Windows/Input/Manipulations/ManipulationSequence.cs
@@ -310,10 +310,7 @@ private float GetSmoothScale()
             {
                 foreach (Manipulator2D manipulator in manipulators)
                 {
-                    if (removedManipulatorIds != null)
-                    {
-                        removedManipulatorIds.Remove(manipulator.Id);
-                    }
+                    removedManipulatorIds?.Remove(manipulator.Id);
                     currentManipulatorCount++;
 
                     ManipulatorState state;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Windows.Presentation/System/Windows/Threading/TaskExtensions.cs b/src/Microsoft.DotNet.Wpf/src/System.Windows.Presentation/System/Windows/Threading/TaskExtensions.cs
index 35265938..9aa0daa2 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Windows.Presentation/System/Windows/Threading/TaskExtensions.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Windows.Presentation/System/Windows/Threading/TaskExtensions.cs
@@ -16,8 +16,7 @@ public static class TaskExtensions
         /// </summary>
         public static bool IsDispatcherOperationTask(this Task @this)
         {
-            var mapping = @this.AsyncState as DispatcherOperationTaskMapping;
-            return mapping != null;
+            return @this.AsyncState is DispatcherOperationTaskMapping mapping;
         }
         
         /// <summary>
@@ -33,8 +32,7 @@ public static DispatcherOperationStatus DispatcherOperationWait(this Task @this)
         /// </summary>
         public static DispatcherOperationStatus DispatcherOperationWait(this Task @this, TimeSpan timeout)
         {
-            var mapping = @this.AsyncState as DispatcherOperationTaskMapping;
-            if(mapping != null)
+            if(@this.AsyncState is DispatcherOperationTaskMapping mapping)
             {
                 // This task did come from a DispatcherOperation.
                 return mapping.Operation.Wait(timeout);
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/DateTimeValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/DateTimeValueSerializer.cs
index 82b8ff36..e4f998ff 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/DateTimeValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/DateTimeValueSerializer.cs
@@ -114,7 +114,7 @@ public override object ConvertFromString(string value, IValueSerializerContext c
 
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if( value == null || !(value is DateTime))
+            if( !(value is DateTime))
             {
                 throw GetConvertToException( value, typeof(string) );
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/ValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/ValueSerializer.cs
index 78e2fcb5..e6d5a779 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/ValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/Markup/ValueSerializer.cs
@@ -129,10 +129,9 @@ public static ValueSerializer GetSerializerFor(Type type)
                 return value == _valueSerializersLock ? null : value as ValueSerializer;
 
             AttributeCollection attributes = TypeDescriptor.GetAttributes(type);
-            ValueSerializerAttribute attribute = attributes[typeof(ValueSerializerAttribute)] as ValueSerializerAttribute;
             ValueSerializer result = null;
 
-            if (attribute != null)
+            if (attributes[typeof(ValueSerializerAttribute)] is ValueSerializerAttribute attribute)
                 result = (ValueSerializer)Activator.CreateInstance(attribute.ValueSerializerType);
 
             if (result == null)
@@ -182,10 +181,8 @@ public static ValueSerializer GetSerializerFor(PropertyDescriptor descriptor)
             {
                 throw new ArgumentNullException(nameof(descriptor));
             }
-            
-            #pragma warning suppress 6506 // descriptor is obviously not null
-            ValueSerializerAttribute serializerAttribute = descriptor.Attributes[typeof(ValueSerializerAttribute)] as ValueSerializerAttribute;
-            if (serializerAttribute != null)
+
+            if (descriptor.Attributes[typeof(ValueSerializerAttribute)] is ValueSerializerAttribute serializerAttribute)
             {
                 result = (ValueSerializer)Activator.CreateInstance(serializerAttribute.ValueSerializerType);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/NameScope.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/NameScope.cs
index 873d65ce..2512ca3b 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/NameScope.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Windows/NameScope.cs
@@ -373,10 +373,7 @@ object IEnumerator.Current
 
             void IEnumerator.Reset()
             {
-                if (_enumerator != null)
-                {
-                    _enumerator.Reset();
-                }
+                _enumerator?.Reset();
             }
         }
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/AttachablePropertyServices.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/AttachablePropertyServices.cs
index c985f25c..81238bb0 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/AttachablePropertyServices.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/AttachablePropertyServices.cs
@@ -19,8 +19,7 @@ public static int GetAttachedPropertyCount(object instance)
                 return 0;
             }
 
-            IAttachedPropertyStore ap = instance as IAttachedPropertyStore;
-            if (ap != null)
+            if (instance is IAttachedPropertyStore ap)
             {
                 return ap.PropertyCount;
             }
@@ -35,8 +34,7 @@ public static void CopyPropertiesTo(object instance, KeyValuePair<AttachableMemb
                 return;
             }
 
-            IAttachedPropertyStore ap = instance as IAttachedPropertyStore;
-            if (ap != null)
+            if (instance is IAttachedPropertyStore ap)
             {
                 ap.CopyPropertiesTo(array, index);
             }
@@ -53,8 +51,7 @@ public static bool RemoveProperty(object instance, AttachableMemberIdentifier na
                 return false;
             }
 
-            IAttachedPropertyStore ap = instance as IAttachedPropertyStore;
-            if (ap != null)
+            if (instance is IAttachedPropertyStore ap)
             {
                 return ap.RemoveProperty(name);
             }
@@ -74,8 +71,7 @@ public static void SetProperty(object instance, AttachableMemberIdentifier name,
                 throw new ArgumentNullException(nameof(name));
             }
 
-            IAttachedPropertyStore ap = instance as IAttachedPropertyStore;
-            if (ap != null)
+            if (instance is IAttachedPropertyStore ap)
             {
                 ap.SetProperty(name, value);
                 return;
@@ -98,16 +94,15 @@ public static bool TryGetProperty<T>(object instance, AttachableMemberIdentifier
                 return false;
             }
 
-            IAttachedPropertyStore ap = instance as IAttachedPropertyStore;
-            if (ap != null)
+            if (instance is IAttachedPropertyStore ap)
             {
                 object obj;
                 bool result = ap.TryGetProperty(name, out obj);
                 if (result)
                 {
-                    if (obj is T)
+                    if (obj is T t)
                     {
-                        value = (T)obj;
+                        value = t;
                         return true;
                     }
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ContextServices.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ContextServices.cs
index 9fd785a6..489cf295 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ContextServices.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ContextServices.cs
@@ -16,8 +16,7 @@ public static object GetTargetProperty(ObjectWriterContext xamlContext)
             // If the XamlMember implements IProvideValueTarget, ask it for the TargetProperty first
             Debug.Assert(xamlContext.ParentProperty != null);
 
-            IProvideValueTarget ipvt = xamlContext.ParentProperty as IProvideValueTarget;
-            if (ipvt != null)
+            if (xamlContext.ParentProperty is IProvideValueTarget ipvt)
             {
                 return ipvt.TargetProperty;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ObjectWriterContext.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ObjectWriterContext.cs
index 9506bda9..fb4809f7 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ObjectWriterContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/ObjectWriterContext.cs
@@ -893,8 +893,7 @@ private XAML3.INameScopeDictionary HuntAroundForARootNameScope(ObjectWriterFrame
 
             if (nameScopeDictionary == null)
             {
-                XAML3.INameScope nameScope = inst as XAML3.INameScope;
-                if (nameScope != null)
+                if (inst is XAML3.INameScope nameScope)
                 {
                     nameScopeDictionary = new NameScopeDictionary(nameScope);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/XamlCommonFrame.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/XamlCommonFrame.cs
index 78a4b3c1..72eace80 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/XamlCommonFrame.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Context/XamlCommonFrame.cs
@@ -40,10 +40,7 @@ public override void Reset()
         {
             XamlType = null;
             Member = null;
-            if (_namespaces != null)
-            {
-                _namespaces.Clear();
-            }
+            _namespaces?.Clear();
         }
         
         public XamlType XamlType { get; set; }
@@ -56,10 +53,7 @@ public void AddNamespace(string prefix, string xamlNs)
 
         public void SetNamespaces(Dictionary<string, string> namespaces)
         {
-            if (_namespaces != null)
-            {
-                _namespaces.Clear();
-            }
+            _namespaces?.Clear();
             if (namespaces != null)
             {
                 foreach (KeyValuePair<string, string> ns in namespaces)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/EventConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/EventConverter.cs
index e75207b3..a62d31bf 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/EventConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/EventConverter.cs
@@ -27,8 +27,7 @@ public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceT
 
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
         {
-            string valueString = value as string;
-            if (valueString != null)
+            if (value is string valueString)
             {
                 object rootObject = null;
                 Type delegateType = null;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/DeferredWriter.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/DeferredWriter.cs
index 7445c089..80b5c5e2 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/DeferredWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/DeferredWriter.cs
@@ -195,9 +195,9 @@ public override void WriteValue(object value)
             case DeferringMode.TemplateStarting:
                 // This handles the case of SM template; V object; EM
                 Debug.Assert(_deferredTreeDepth == 0);
-                if (value is XamlNodeList)
+                if (value is XamlNodeList xamlNodeList)
                 {
-                    _deferredList = (XamlNodeList)value;
+                    _deferredList = xamlNodeList;
                     _mode = DeferringMode.TemplateReady;
                     _handled = true;
                 }
@@ -289,10 +289,7 @@ public void SetLineInfo(int lineNumber, int linePosition)
                 goto case DeferringMode.TemplateDeferring;
 
             case DeferringMode.TemplateDeferring:
-                if (_deferredLineInfoConsumer != null)
-                {
-                    _deferredLineInfoConsumer.SetLineInfo(lineNumber, linePosition);
-                }
+                _deferredLineInfoConsumer?.SetLineInfo(lineNumber, linePosition);
                 break;
 
             default:
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlNodes.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlNodes.cs
index af37ce80..56de3644 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlNodes.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlNodes.cs
@@ -258,9 +258,8 @@ internal static bool IsEof_Helper(XamlNodeType nodeType, object data)
             {
                 return false;
             }
-            if (data is InternalNodeType)
+            if (data is InternalNodeType internalNodeType)
             {
-                InternalNodeType internalNodeType = (InternalNodeType)data;
                 if (internalNodeType == InternalNodeType.EndOfStream)
                 {
                     return true;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlObjectWriter.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlObjectWriter.cs
index fbc37096..2e0bf799 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlObjectWriter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlObjectWriter.cs
@@ -1375,7 +1375,7 @@ private bool Logic_CreatePropertyValueFromValue(ObjectWriterContext ctx)
                 {
                     converter = grandParentXamlType.KeyType.TypeConverter;
                 }
-                if (converter!= null && converter.ConverterType != null && converter != BuiltInValueConverter.String)
+                if (converter?.ConverterType != null && converter != BuiltInValueConverter.String)
                 {
                     TypeConverter typeConverter = Runtime.GetConverterInstance(converter);
                     if (typeConverter != null)
@@ -2025,9 +2025,8 @@ private void Logic_DoAssignmentToParentProperty(ObjectWriterContext ctx)
                                                 ctx.ParentType));
                     }
                     ctx.ParentIsPropertyValueSet = true;
-                    if (value is NameFixupToken)
+                    if (value is NameFixupToken token)
                     {
-                        var token = (NameFixupToken)value;
                         if (parentProperty.IsDirective)
                         {
                             // Only the key directive may be assigned a reference.
@@ -2080,12 +2079,11 @@ private void Logic_DoAssignmentToParentProperty(ObjectWriterContext ctx)
                         else
                         {
 
-                            if (value is NameFixupToken)
+                            if (value is NameFixupToken token)
                             {
                                 // Only the key directive may be assigned a reference.
                                 if (parentProperty != XamlLanguage.Key)
                                 {
-                                    NameFixupToken token = (NameFixupToken)value;
                                     string names = String.Join(",", token.NeededNames.ToArray());
                                     string msg = SR.Get(SRID.ForwardRefDirectives, names);
                                     throw ctx.WithLineInfo(new XamlObjectWriterException(msg));
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlXmlReader.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlXmlReader.cs
index bda5c4a1..8d6ffdb5 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlXmlReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/InfosetObjects/XamlXmlReader.cs
@@ -264,9 +264,9 @@ private void Initialize(XmlReader givenXmlReader, XamlSchemaContext schemaContex
             {
                 _mergedSettings.XmlLang = myXmlReader.XmlLang;
             }
-            IXmlNamespaceResolver myXmlReaderNS = myXmlReader as IXmlNamespaceResolver;
             Dictionary<string, string> xmlnsDictionary = null;
-            if (myXmlReaderNS != null)
+
+            if (myXmlReader is IXmlNamespaceResolver myXmlReaderNS)
             {
                 IDictionary<string, string> rootNamespaces = myXmlReaderNS.GetNamespacesInScope(XmlNamespaceScope.Local);
                 if (rootNamespaces != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Parser/XamlPullParser.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Parser/XamlPullParser.cs
index 187c7de0..3ab3857b 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Parser/XamlPullParser.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Parser/XamlPullParser.cs
@@ -1103,7 +1103,7 @@ private bool Logic_IsDiscardableWhitespace(XamlText text)
                         {
                             prop = _context.CurrentType.ContentProperty;
                         }
-                        if (prop != null && prop.Type != null && prop.Type.IsWhitespaceSignificantCollection)
+                        if (prop?.Type != null && prop.Type.IsWhitespaceSignificantCollection)
                         {
                             return false;
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Replacements/TypeTypeConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Replacements/TypeTypeConverter.cs
index 456a511c..eb32e4cd 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Replacements/TypeTypeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Replacements/TypeTypeConverter.cs
@@ -44,9 +44,8 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
 
         public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
         {
-            Type type = value as Type;
 
-            if (context != null && type != null && destinationType == typeof(string))
+            if (context != null && value is Type type && destinationType == typeof(string))
             {
                 string result = ConvertTypeToString(context, type);
                 if (result != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/ClrObjectRuntime.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/ClrObjectRuntime.cs
index 13faba3a..fe015556 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/ClrObjectRuntime.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/ClrObjectRuntime.cs
@@ -353,12 +353,8 @@ public override IEnumerable<DictionaryEntry> GetDictionaryItems(object dictionar
             IEnumerator enumerator = GetItems(dictionary, dictionaryType);
             try
             {
-                // Dictionaries are required to either give us an either:
-                // - an IDictionaryEnumerator,
-                // - an IEnumerator<KeyValuePair<K,V>>, or 
-                // - an IEnumerator that returns DictionaryEntrys
-                IDictionaryEnumerator dictionaryEnumerator = enumerator as IDictionaryEnumerator;
-                if (dictionaryEnumerator != null)
+                // Dictionaries are required to either give us an either:                // - an IDictionaryEnumerator,                // - an IEnumerator<KeyValuePair<K,V>>, or                 // - an IEnumerator that returns DictionaryEntrys
+                if (enumerator is IDictionaryEnumerator dictionaryEnumerator)
                 {
                     return DictionaryEntriesFromIDictionaryEnumerator(dictionaryEnumerator);
                 }
@@ -436,10 +432,7 @@ public override void SetConnectionId(object root, int connectionId, object insta
             try
             {
                 XAML3.IComponentConnector connector = root as XAML3.IComponentConnector;
-                if(connector != null)
-                {
-                    connector.Connect(connectionId, instance);
-                }
+                connector?.Connect(connectionId, instance);
             }
             catch(Exception e)
             {
@@ -455,8 +448,7 @@ public override void InitializationGuard(XamlType xamlType, object obj, bool beg
         {
             try
             {
-                ISupportInitialize supportInit = obj as ISupportInitialize;
-                if(supportInit != null)
+                if(obj is ISupportInitialize supportInit)
                 {
                     if(begin)
                     {
@@ -499,8 +491,7 @@ public override void SetUriBase(XamlType xamlType, object obj, Uri baseUri)
         {
             try
             {
-                XAML3.IUriContext uriContext = obj as XAML3.IUriContext;
-                if(uriContext != null)
+                if(obj is XAML3.IUriContext uriContext)
                 {
                     uriContext.BaseUri = baseUri;
                 }
@@ -566,8 +557,7 @@ public override TConverterBase GetConverterInstance<TConverterBase>(XamlValueCon
             catch (Exception e)
             {
                 // Reset the reader in case our caller catches and retries
-                IXamlIndexingReader indexingReader = deferredContent as IXamlIndexingReader;
-                if(indexingReader != null && indexingReader.CurrentIndex >= 0)
+                if(deferredContent is IXamlIndexingReader indexingReader && indexingReader.CurrentIndex >= 0)
                 {
                     indexingReader.CurrentIndex = -1;
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/DynamicMethodRuntime.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/DynamicMethodRuntime.cs
index ef50c21e..2e21dbe4 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/DynamicMethodRuntime.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Runtime/DynamicMethodRuntime.cs
@@ -160,8 +160,7 @@ public override TConverterBase GetConverterInstance<TConverterBase>(XamlValueCon
         {
             if (ts == BuiltInValueConverter.Event)
             {
-                string valueString = value as string;
-                if (valueString != null)
+                if (value is string valueString)
                 {
                     object rootObject;
                     Type delegateType;
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/TypeReflector.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/TypeReflector.cs
index 3ffd1d99..f7c14b7e 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/TypeReflector.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/TypeReflector.cs
@@ -398,8 +398,8 @@ internal static XamlMember LookupNameScopeProperty(XamlType xamlType)
             // We only check this once, at the root of the doc, and only in ObjectWriter.
             // So it's fine to use live reflection here.
             object obj = GetCustomAttribute(typeof(XAML3.NameScopePropertyAttribute), xamlType.UnderlyingType);
-            XAML3.NameScopePropertyAttribute nspAttr = obj as XAML3.NameScopePropertyAttribute;
-            if (nspAttr != null)
+
+            if (obj is XAML3.NameScopePropertyAttribute nspAttr)
             {
                 Type ownerType = nspAttr.Type;
                 string propertyName = nspAttr.Name;
@@ -480,10 +480,7 @@ private IList<PropertyInfo> FilterProperties(PropertyInfo[] propList, List<XamlM
                 {
                     if (knownMember != null)
                     {
-                        if (knownMembers != null)
-                        {
-                            knownMembers.Add(knownMember);
-                        }
+                        knownMembers?.Add(knownMember);
                         continue;
                     }
                     else if (skipKnownNegatives)
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/XamlTypeInvoker.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/XamlTypeInvoker.cs
index 7eedd71a..78b996ad 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/XamlTypeInvoker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/Schema/XamlTypeInvoker.cs
@@ -66,8 +66,8 @@ public virtual void AddToCollection(object instance, object item)
             {
                 throw new ArgumentNullException(nameof(instance));
             }
-            IList list = instance as IList;
-            if (list != null)
+
+            if (instance is IList list)
             {
                 list.Add(item);
                 return;
@@ -101,8 +101,8 @@ public virtual void AddToDictionary(object instance, object key, object item)
             {
                 throw new ArgumentNullException(nameof(instance));
             }
-            IDictionary dictionary = instance as IDictionary;
-            if (dictionary != null)
+
+            if (instance is IDictionary dictionary)
             {
                 dictionary.Add(key, item);
                 return;
@@ -215,8 +215,8 @@ public virtual IEnumerator GetItems(object instance)
             {
                 throw new ArgumentNullException(nameof(instance));
             }
-            IEnumerable enumerable = instance as IEnumerable;
-            if (enumerable != null)
+
+            if (instance is IEnumerable enumerable)
             {
                 return enumerable.GetEnumerator();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlMember.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlMember.cs
index 7b9be6c4..58005457 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlMember.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlMember.cs
@@ -666,8 +666,7 @@ protected virtual XamlType LookupTargetType()
         {
             if (IsAttachable)
             {
-                MethodInfo accessor = UnderlyingMember as MethodInfo;
-                if (accessor != null)
+                if (UnderlyingMember is MethodInfo accessor)
                 {
                     ParameterInfo[] parameters = accessor.GetParameters();
                     if (parameters.Length > 0)
@@ -751,8 +750,7 @@ protected virtual MethodInfo LookupUnderlyingGetter()
             {
                 return _reflector.Getter;
             }
-            PropertyInfo pi = UnderlyingMember as PropertyInfo;
-            return (pi != null) ? pi.GetGetMethod(true) : null;
+            return (UnderlyingMember is PropertyInfo pi) ? pi.GetGetMethod(true) : null;
         }
 
         protected virtual MethodInfo LookupUnderlyingSetter()
@@ -764,15 +762,14 @@ protected virtual MethodInfo LookupUnderlyingSetter()
             {
                 return _reflector.Setter;
             }
-            PropertyInfo pi = UnderlyingMember as PropertyInfo;
-            if (pi != null)
+
+            if (UnderlyingMember is PropertyInfo pi)
             {
                 return pi.GetSetMethod(true);
             }
             else
             {
-                EventInfo ei = UnderlyingMember as EventInfo;
-                return (ei != null) ? ei.GetAddMethod(true) : null;
+                return (UnderlyingMember is EventInfo ei) ? ei.GetAddMethod(true) : null;
             }
         }
 
@@ -973,18 +970,18 @@ private string LookupConstructorArgument()
         private Type LookupSystemType()
         {
             MemberInfo underlyingMember = UnderlyingMember;
-            PropertyInfo pi = underlyingMember as PropertyInfo;
-            if (pi != null)
+
+            if (underlyingMember is PropertyInfo pi)
             {
                 return pi.PropertyType;
             }
-            EventInfo ei = underlyingMember as EventInfo;
-            if (ei != null)
+
+            if (underlyingMember is EventInfo ei)
             {
                 return ei.EventHandlerType;
             }
-            MethodInfo mi = underlyingMember as MethodInfo;
-            if (mi != null)
+
+            if (underlyingMember is MethodInfo mi)
             {
                 if (mi.ReturnType != null && mi.ReturnType != typeof(void))
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlObjectReader.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlObjectReader.cs
index d8782179..3ad1795e 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlObjectReader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlObjectReader.cs
@@ -672,14 +672,12 @@ static void RemoveObjectNodesForCollectionOrDictionary(MemberMarkupInfo memberIn
                 {
                     if (memberInfo.Children.Count == 1)
                     {
-                        var objectInfo = memberInfo.Children[0] as ObjectMarkupInfo;
-                        if (objectInfo != null && objectInfo.Properties.Count == 1 && memberType == objectInfo.XamlNode.XamlType)
+                        if (memberInfo.Children[0] is ObjectMarkupInfo objectInfo && objectInfo.Properties.Count == 1 && memberType == objectInfo.XamlNode.XamlType)
                         {
 
                             if (objectInfo.Properties[0].XamlNode.Member == XamlLanguage.Items)
                             {
-                                var itemsMemberInfo = objectInfo.Properties[0] as MemberMarkupInfo;
-                                if(itemsMemberInfo != null && itemsMemberInfo.Children.Count > 0)
+                                if(objectInfo.Properties[0] is MemberMarkupInfo itemsMemberInfo && itemsMemberInfo.Children.Count > 0)
                                 {
                                     //Check if the first element of the collection/dictionary is a ME and replace the SO with GO only if it is not an ME.
                                     //This is to handle cases where the first element is, say, null. If we remove the SO, then there is no way to
@@ -845,7 +843,7 @@ static bool ShouldUnwrapDueToWhitespace(string value, XamlType xamlType, bool is
                 return GetPropertyValueInfoInternal(propertyValue,
                     TypeConverterExtensions.GetConverterInstance(xamlProperty.ValueSerializer),
                     TypeConverterExtensions.GetConverterInstance(xamlProperty.TypeConverter),
-                    xamlProperty != null && xamlProperty.DeferringLoader != null,
+xamlProperty?.DeferringLoader != null,
                     xamlProperty,
                     context);
             }
@@ -1212,9 +1210,8 @@ void AddItemsProperty(object value, SerializerContext context, XamlType xamlType
             ParameterInfo[] GetMethodParams(MemberInfo memberInfo)
             {
                 ParameterInfo[] methodParams = null;
-                MethodBase method = memberInfo as MethodBase;
 
-                if (method != null)
+                if (memberInfo is MethodBase method)
                 {
                     methodParams = method.GetParameters();
                 }
@@ -1230,14 +1227,12 @@ void AddFactoryMethodAndValidateArguments(Type valueType, MemberInfo memberInfo,
                     // default ctor
                     methodParams = Array.Empty<ParameterInfo>();
                 }
-                else if (memberInfo is ConstructorInfo)
+                else if (memberInfo is ConstructorInfo ctor)
                 {
-                    var ctor = (ConstructorInfo)memberInfo;
                     methodParams = ctor.GetParameters();
                 }
-                else if (memberInfo is MethodInfo)
+                else if (memberInfo is MethodInfo mi)
                 {
-                    var mi = (MethodInfo)memberInfo;
                     methodParams = mi.GetParameters();
 
                     var methodName = memberInfo.Name;
@@ -1913,15 +1908,8 @@ public static ObjectMarkupInfo ForObject(object value, SerializerContext context
 
                 context.IsRoot = isRoot;
 
-                //var valueType = context.GetXamlType(value.GetType());
-
-                //if (XamlClrProperties.GetXmlSerializable(valueType))
-                //{
-                //    throw new XamlObjectReaderException(SR.XamlSerializerCannotHaveXDataAtRoot(valueType.Name));
-                //}
-
-                var valueAsArray = value as Array;
-                if (valueAsArray != null)
+                //var valueType = context.GetXamlType(value.GetType());                //if (XamlClrProperties.GetXmlSerializable(valueType))                //{                //    throw new XamlObjectReaderException(SR.XamlSerializerCannotHaveXDataAtRoot(valueType.Name));                //}
+                if (value is Array valueAsArray)
                 {
                     return ForArray(valueAsArray, context);
                 }
@@ -1982,10 +1970,10 @@ public static ObjectMarkupInfo ForObject(object value, SerializerContext context
                     context.Instance = null;
                     objectInfo = ForTypeConverted((string)stringValue, value, context);
                 }
-                else if (value is string)
+                else if (value is string s)
                 {
                     context.Instance = null;
-                    objectInfo = ForTypeConverted((string)value, value, context);
+                    objectInfo = ForTypeConverted(s, value, context);
                 }
                 else
                 {
@@ -2455,10 +2443,7 @@ public string FindInServiceProviderTable(object value)
             {
                 string result = null;
 
-                if (serviceProviderTable != null)
-                {
-                    serviceProviderTable.TryGetValue(value, out result);
-                }
+                serviceProviderTable?.TryGetValue(value, out result);
 
                 // this search is not recursive, because only names requested in the current
                 // namescope are meaningful references.
@@ -3061,8 +3046,7 @@ public Entry(TKey key, TValue value)
 
                 public override bool Equals(object obj)
                 {
-                    Entry other = obj as Entry;
-                    return other != null && other.Key.Equals(Key);
+                    return obj is Entry other && other.Key.Equals(Key);
                 }
 
                 public override int GetHashCode()
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlSchemaContext.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlSchemaContext.cs
index 07fc3679..1dec7bff 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlSchemaContext.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlSchemaContext.cs
@@ -809,10 +809,7 @@ private static void CleanupCollectedAssemblies(object schemaContextWeakRef)
         {
             WeakReference weakRef = (WeakReference)schemaContextWeakRef;
             XamlSchemaContext schemaContext = weakRef.Target as XamlSchemaContext;
-            if (schemaContext != null)
-            {
-                schemaContext.CleanupCollectedAssemblies();
-            }
+            schemaContext?.CleanupCollectedAssemblies();
         }
 
         // Iterate through any weak references we hold to dynamic assemblies, cleaning up references
@@ -1376,10 +1373,7 @@ public AssemblyLoadHandler(XamlSchemaContext schemaContext)
             private void OnAssemblyLoad(object sender, AssemblyLoadEventArgs args)
             {
                 XamlSchemaContext schemaContext = (XamlSchemaContext)schemaContextRef.Target;
-                if (schemaContext != null)
-                {
-                    schemaContext.SchemaContextAssemblyLoadEventHandler(sender, args);
-                }
+                schemaContext?.SchemaContextAssemblyLoadEventHandler(sender, args);
             }
 
 #if TARGETTING35SP1
diff --git a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlTypeTypeConverter.cs b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlTypeTypeConverter.cs
index 32404dc5..63afcb0f 100644
--- a/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlTypeTypeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/System.Xaml/System/Xaml/XamlTypeTypeConverter.cs
@@ -16,9 +16,7 @@ public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceT
 
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
         {
-            string typeName = value as string;
-
-            if (context != null && typeName != null)
+            if (context != null && value is string typeName)
             {
                 XamlType result = ConvertStringToXamlType(context, typeName);
                 if (result != null)
@@ -37,9 +35,8 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
 
         public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
         {
-            XamlType xamlType = value as XamlType;
 
-            if (context != null && xamlType != null && destinationType == typeof(string))
+            if (context != null && value is XamlType xamlType && destinationType == typeof(string))
             {
                 string result = ConvertXamlTypeToString(context, xamlType);
                 if (result != null)
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ButtonChrome.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ButtonChrome.cs
index 0d41e901..cac0b62a 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ButtonChrome.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ButtonChrome.cs
@@ -455,10 +455,7 @@ protected override Size ArrangeOverride(Size finalSize)
             childArrangeRect.Y = (finalSize.Height - childArrangeRect.Height) * 0.5;
 
             UIElement child = Child;
-            if (child != null)
-            {
-                child.Arrange(childArrangeRect);
-            }
+            child?.Arrange(childArrangeRect);
 
             return finalSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ListBoxChrome.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ListBoxChrome.cs
index 0552d0ae..c1319bf6 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ListBoxChrome.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero/Microsoft/Windows/Themes/ListBoxChrome.cs
@@ -292,10 +292,7 @@ protected override Size ArrangeOverride(Size finalSize)
                 childArrangeRect.Height = finalSize.Height - borderY;
             }
 
-            if (Child != null)
-            {
-                Child.Arrange(childArrangeRect);
-            }
+            Child?.Arrange(childArrangeRect);
 
             return finalSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ButtonChrome.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ButtonChrome.cs
index b8fbc5f3..ca39b422 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ButtonChrome.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ButtonChrome.cs
@@ -455,10 +455,7 @@ protected override Size ArrangeOverride(Size finalSize)
             childArrangeRect.Y = (finalSize.Height - childArrangeRect.Height) * 0.5;
 
             UIElement child = Child;
-            if (child != null)
-            {
-                child.Arrange(childArrangeRect);
-            }
+            child?.Arrange(childArrangeRect);
 
             return finalSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ListBoxChrome.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ListBoxChrome.cs
index 0552d0ae..c1319bf6 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ListBoxChrome.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Aero2/Microsoft/Windows/Themes/ListBoxChrome.cs
@@ -292,10 +292,7 @@ protected override Size ArrangeOverride(Size finalSize)
                 childArrangeRect.Height = finalSize.Height - borderY;
             }
 
-            if (Child != null)
-            {
-                Child.Arrange(childArrangeRect);
-            }
+            Child?.Arrange(childArrangeRect);
 
             return finalSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Classic/Microsoft/Windows/Themes/ClassicBorderDecorator.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Classic/Microsoft/Windows/Themes/ClassicBorderDecorator.cs
index fae03f4b..cc3e958a 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Classic/Microsoft/Windows/Themes/ClassicBorderDecorator.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Classic/Microsoft/Windows/Themes/ClassicBorderDecorator.cs
@@ -403,8 +403,6 @@ private static Color GetControlDarkColor(Color controlColor)
         private static void BorderBrushesChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
         {
             ClassicBorderDecorator decorator = (ClassicBorderDecorator)d;
-
-            SolidColorBrush controlBrush = decorator.Background as SolidColorBrush;
             Color controlColor;
 
             // When style changes, tab geometries are invalid
@@ -413,7 +411,7 @@ private static void BorderBrushesChanged(DependencyObject d, DependencyPropertyC
             // Calculate 3D highlights and shadows for solid color brushes that are not the control color
             // Don't recompute colors for the sunken styles (Sunken and RadioButton)
             if (decorator.BorderStyle != ClassicBorderStyle.Sunken && decorator.BorderStyle != ClassicBorderStyle.RadioButton &&
-                controlBrush != null && (controlColor = controlBrush.Color) != SystemColors.ControlColor && controlColor.A > 0x00)
+                decorator.Background is SolidColorBrush controlBrush && (controlColor = controlBrush.Color) != SystemColors.ControlColor && controlColor.A > 0x00)
             {
                 // If we haven't cached the colors, or if the background color changed, compute the new colors
                 if (decorator._brushCache == null || controlColor != decorator._brushCache.LightBrush.Color)
@@ -920,8 +918,7 @@ private Geometry GetBorder(Rect bounds, Thickness borderThickness)
         // Returns true if the border can be drawn using overlapping rectangles
         private static bool IsSimpleBorderBrush(Brush borderBrush)
         {
-            SolidColorBrush solidBrush = borderBrush as SolidColorBrush;
-            return (solidBrush != null && (solidBrush.Color.A == 0xFF || solidBrush.Color.A == 0x00));
+            return (borderBrush is SolidColorBrush solidBrush && (solidBrush.Color.A == 0xFF || solidBrush.Color.A == 0x00));
         }
 
         // Draws a border around the control
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Luna/Microsoft/Windows/Themes/ButtonChrome.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Luna/Microsoft/Windows/Themes/ButtonChrome.cs
index 6d0a71ed..faf34b36 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Luna/Microsoft/Windows/Themes/ButtonChrome.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Luna/Microsoft/Windows/Themes/ButtonChrome.cs
@@ -370,10 +370,7 @@ protected override Size ArrangeOverride(Size finalSize)
             childArrangeRect.Y = (finalSize.Height - childArrangeRect.Height) * 0.5;
 
             UIElement child = Child;
-            if (child != null)
-            {
-                child.Arrange(childArrangeRect);
-            }
+            child?.Arrange(childArrangeRect);
 
             return finalSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Royale/Microsoft/Windows/Themes/ButtonChrome.cs b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Royale/Microsoft/Windows/Themes/ButtonChrome.cs
index 648a0036..08c59c0d 100644
--- a/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Royale/Microsoft/Windows/Themes/ButtonChrome.cs
+++ b/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Royale/Microsoft/Windows/Themes/ButtonChrome.cs
@@ -328,10 +328,7 @@ protected override Size ArrangeOverride(Size finalSize)
             childArrangeRect.Y = (finalSize.Height - childArrangeRect.Height) * 0.5;
 
             UIElement child = Child;
-            if (child != null)
-            {
-                child.Arrange(childArrangeRect);
-            }
+            child?.Arrange(childArrangeRect);
 
             return finalSize;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/FocusTracker.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/FocusTracker.cs
index 4e538718..0dc00b76 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/FocusTracker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/FocusTracker.cs
@@ -165,8 +165,7 @@ private AutomationElement GetFocusedElementFromWinEvent(IntPtr hwnd, int idObjec
                 if(provider != null)
                 {
                     // Ask the fragment root if any of its children really have the focus
-                    IRawElementProviderFragmentRoot fragment = provider as IRawElementProviderFragmentRoot;
-                    if (fragment != null)
+                    if (provider is IRawElementProviderFragmentRoot fragment)
                     {
                         // if we get back something that is different than what we started with and its not null
                         // use that instead.  This is here to get the subset link in the listview but could be usefull
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/InvokeHandlers.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/InvokeHandlers.cs
index bcdb0116..fe1aa700 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/InvokeHandlers.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/InvokeHandlers.cs
@@ -59,17 +59,17 @@ internal static void InvokeClientHandler(Delegate clientCallback, AutomationElem
         {
             try
             {
-                if (args is AutomationPropertyChangedEventArgs)
+                if (args is AutomationPropertyChangedEventArgs automationPropertyChangedEventArgs)
                 {
-                    ((AutomationPropertyChangedEventHandler)clientCallback)(srcEl, (AutomationPropertyChangedEventArgs)args);
+                    ((AutomationPropertyChangedEventHandler)clientCallback)(srcEl, automationPropertyChangedEventArgs);
                 }
-                else if (args is StructureChangedEventArgs)
+                else if (args is StructureChangedEventArgs structureChangedEventArgs)
                 {
-                    ((StructureChangedEventHandler)clientCallback)(srcEl, (StructureChangedEventArgs)args);
+                    ((StructureChangedEventHandler)clientCallback)(srcEl, structureChangedEventArgs);
                 }
-                else if (args is InternalAutomationFocusChangedEventArgs)
+                else if (args is InternalAutomationFocusChangedEventArgs internalAutomationFocusChangedEventArgs)
                 {
-                    AutomationFocusChangedEventArgs realArgs = ((InternalAutomationFocusChangedEventArgs)args)._args;
+                    AutomationFocusChangedEventArgs realArgs = internalAutomationFocusChangedEventArgs._args;
 
                     // For focus events, check that the event is actually more recent than the last one (see note at top of file).
                     // Since the timestamps can wrap around, subtract and measure the delta instead of just comparing them.
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/ProxyManager.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/ProxyManager.cs
index 12b31341..98c2dd9d 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/ProxyManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/ProxyManager.cs
@@ -77,8 +77,7 @@ internal static void RegisterProxyAssembly ( AssemblyName assemblyName )
                 throw new ProxyAssemblyNotLoadedException(SR.Get(SRID.CouldNotFindRegisterMethodOnType0InAssembly1, typeName, assemblyName));
             }
 
-            ClientSideProviderDescription[] table = fi.GetValue(null) as ClientSideProviderDescription[];
-            if (table != null)
+            if (fi.GetValue(null) is ClientSideProviderDescription[] table)
             {
                 ClientSettings.RegisterClientSideProviders(table);
             }
@@ -142,8 +141,8 @@ internal static ClientSideProviderDescription[] GetProxyDescriptionTable()
                     foreach ( Object item in e )
                     {
                         Object o = item;
-                        if( o is DictionaryEntry )
-                            o = ((DictionaryEntry)o).Value;
+                        if( o is DictionaryEntry dictionaryEntry)
+                            o = dictionaryEntry.Value;
 
                         if (o is ClientSideProviderDescription)
                         {
@@ -170,16 +169,15 @@ internal static ClientSideProviderDescription[] GetProxyDescriptionTable()
                     foreach ( Object item in e )
                     {
                         Object o = item;
-                        if( o is DictionaryEntry )
-                            o = ((DictionaryEntry)o).Value;
+                        if( o is DictionaryEntry dictionaryEntry)
+                            o = dictionaryEntry.Value;
 
-                        if (o is ClientSideProviderDescription)
+                        if (o is ClientSideProviderDescription clientSideProviderDescription)
                         {
-                            proxyDescriptions[count++] = (ClientSideProviderDescription)o;
+                            proxyDescriptions[count++] = clientSideProviderDescription;
                         }
-                        else if (o is ClientSideProviderFactoryCallback)
+                        else if (o is ClientSideProviderFactoryCallback pfc)
                         {
-                            ClientSideProviderFactoryCallback pfc = (ClientSideProviderFactoryCallback)o;
                             proxyDescriptions[count++] = new ClientSideProviderDescription(pfc, null);
 
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/Schema.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/Schema.cs
index 4ef6f790..0c4cf78a 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/Schema.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/Schema.cs
@@ -176,9 +176,9 @@ private static object ConvertToControlType(object value)
 
         private static object ConvertToCultureInfo(object value)
         {
-            if(value is int)
+            if(value is int i)
             {
-                return new CultureInfo((int)value);
+                return new CultureInfo(i);
             }
             return null;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/WinEventWrap.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/WinEventWrap.cs
index 016c07ae..1b8c9cd0 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/WinEventWrap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/MS/Internal/Automation/WinEventWrap.cs
@@ -143,10 +143,7 @@ internal void StopListening()
                     _hHooks[i] = IntPtr.Zero;
                 }
             }
-            if (_qEvents != null)
-            {
-                _qEvents.Clear();
-            }
+            _qEvents?.Clear();
             _fBusy = false;
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Automation.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Automation.cs
index 8bd06637..397921d8 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Automation.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Automation.cs
@@ -172,7 +172,7 @@ AutomationEventHandler eventHandler
                         // False positive, element is checked, see above
 #pragma warning suppress 6506
                         object val = element.GetCurrentPropertyValue(AutomationElement.NativeWindowHandleProperty);
-                        if ( val != null && val is int && (int)val != 0 )
+                        if ( val is int && (int)val != 0 )
                         {
                             if ( HwndProxyElementProvider.IsWindowPatternWindow( NativeMethods.HWND.Cast( new IntPtr( (int)val ) ) ) )
                             {
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/AutomationElement.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/AutomationElement.cs
index 0852348e..6196c66d 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/AutomationElement.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/AutomationElement.cs
@@ -375,13 +375,8 @@ public int[] GetRuntimeId()
             if (_runtimeId != null)
                 return _runtimeId;
 
-            //Not true - some AE's from properties and event args (eg. SelectionItem.SelectionContainer,
-            //and FocuEventArgs's previousFocus) don't currently come through CacheReqest
-            //Debug.Assert(false, "Should always have runtimeID from cache at ctor.");
-
-            // false -> return null (instead of throwing) if not available; true->wrap
-            int [] val = LookupCachedValue(AutomationElement.RuntimeIdProperty, false, true) as int[];
-            if (val != null)
+            //Not true - some AE's from properties and event args (eg. SelectionItem.SelectionContainer,            //and FocuEventArgs's previousFocus) don't currently come through CacheReqest            //Debug.Assert(false, "Should always have runtimeID from cache at ctor.");            // false -> return null (instead of throwing) if not available; true->wrap
+            if (LookupCachedValue(AutomationElement.RuntimeIdProperty, false, true) is int[] val)
             {
                 _runtimeId = val;
                 return _runtimeId;
@@ -873,10 +868,10 @@ public bool TryGetClickablePoint( out Point pt )
             }
 
             // if got one
-            if (ptClickable is Point)
+            if (ptClickable is Point point)
             {
                 //If the ClickablePointProperty from the provider is NaN that means no point.
-                if (double.IsNaN (((Point) ptClickable).X) || double.IsNaN (((Point) ptClickable).Y))
+                if (double.IsNaN (point.X) || double.IsNaN (((Point) ptClickable).Y))
                 {
                     return false;
                 }
@@ -1252,11 +1247,9 @@ object LookupCachedValue(AutomationIdentifier id, bool throwIfNotRequested, bool
                 return val;
             }
 
-            AutomationPattern automationPattern = id as AutomationPattern;
-
             // Cached values are internally stored as unwrapped, direct-from-provider values, so
             // need to be wrapped as appropriate before handing back to client...
-            if (automationPattern != null)
+            if (id is AutomationPattern automationPattern)
             {
                 SafePatternHandle hpatternobj = (SafePatternHandle)val;
                 val = Misc.WrapInterfaceOnClientSide(this, hpatternobj, automationPattern);
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/ItemContainerPattern.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/ItemContainerPattern.cs
index f60b69ad..0e409155 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/ItemContainerPattern.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/ItemContainerPattern.cs
@@ -145,31 +145,29 @@ private object PropertyValueValidateAndMap(AutomationProperty property, object v
             }
 
             // Some types are handled differently in managed vs unmanaged - handle those here...
-            if (value is AutomationElement)
+            if (value is AutomationElement automationElement)
             {
                 // If this is a comparison against a Raw/LogicalElement,
                 // save the runtime ID instead of the element so that we
                 // can take it cross-proc if needed.
-                value = ((AutomationElement)value).GetRuntimeId();
+                value = automationElement.GetRuntimeId();
             }
-            else if (value is ControlType)
+            else if (value is ControlType controlType)
             {
                 // If this is a control type, use the ID, not the CLR object
-                value = ((ControlType)value).Id;
+                value = controlType.Id;
             }
-            else if (value is Rect)
+            else if (value is Rect rc)
             {
-                Rect rc = (Rect)value;
                 value = new double[] { rc.Left, rc.Top, rc.Width, rc.Height };
             }
-            else if (value is Point)
+            else if (value is Point pt)
             {
-                Point pt = (Point)value;
                 value = new double[] { pt.X, pt.Y };
             }
-            else if (value is CultureInfo)
+            else if (value is CultureInfo cultureInfo)
             {
-                value = ((CultureInfo)value).LCID;
+                value = cultureInfo.LCID;
             }
 
             return value;
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/PropertyCondition.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/PropertyCondition.cs
index 0ebcac24..11937e38 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/PropertyCondition.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/PropertyCondition.cs
@@ -147,31 +147,29 @@ void Init(AutomationProperty property, object val, PropertyConditionFlags flags
             }
 
             // Some types are handled differently in managed vs unmanaged - handle those here...
-            if (val is AutomationElement)
+            if (val is AutomationElement automationElement)
             {
                 // If this is a comparison against a Raw/LogicalElement,
                 // save the runtime ID instead of the element so that we
                 // can take it cross-proc if needed.
-                val = ((AutomationElement)val).GetRuntimeId();
+                val = automationElement.GetRuntimeId();
             }
-            else if (val is ControlType)
+            else if (val is ControlType controlType)
             {
                 // If this is a control type, use the ID, not the CLR object
-                val = ((ControlType)val).Id;
+                val = controlType.Id;
             }
-            else if (val is Rect)
+            else if (val is Rect rc)
             {
-                Rect rc = (Rect)val;
                 val = new double[] { rc.Left, rc.Top, rc.Width, rc.Height };
             }
-            else if (val is Point)
+            else if (val is Point pt)
             {
-                Point pt = (Point)val;
                 val = new double[] { pt.X, pt.Y };
             }
-            else if (val is CultureInfo)
+            else if (val is CultureInfo cultureInfo)
             {
-                val = ((CultureInfo)val).LCID;
+                val = cultureInfo.LCID;
             }
 
             _property = property;
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/RangeValuePattern.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/RangeValuePattern.cs
index 84a5e027..287b6e54 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/RangeValuePattern.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/RangeValuePattern.cs
@@ -253,9 +253,9 @@ public double Value
                     {
                         return (double)(byte)propValue;
                     }
-                    else if (propValue is DateTime)
+                    else if (propValue is DateTime dateTime)
                     {
-                        return (double)((DateTime)propValue).Year;
+                        return (double)dateTime.Year;
                     }
                     else
                     {
@@ -292,9 +292,9 @@ public double Maximum
                     {
                         return (double)(byte)propValue;
                     }
-                    else if (propValue is DateTime)
+                    else if (propValue is DateTime dateTime)
                     {
-                        return (double)((DateTime)propValue).Year;
+                        return (double)dateTime.Year;
                     }
                     else
                     {
@@ -321,9 +321,9 @@ public double Minimum
                     {
                         return (double)(byte)propValue;
                     }
-                    else if (propValue is DateTime)
+                    else if (propValue is DateTime dateTime)
                     {
-                        return (double)((DateTime)propValue).Year;
+                        return (double)dateTime.Year;
                     }
                     else
                     {
@@ -354,9 +354,9 @@ public double LargeChange
                     {
                         return (double)(byte)propValue;
                     }
-                    else if (propValue is DateTime)
+                    else if (propValue is DateTime dateTime)
                     {
-                        return (double)((DateTime)propValue).Year;
+                        return (double)dateTime.Year;
                     }
                     else
                     {
@@ -386,9 +386,9 @@ public double SmallChange
                     {
                         return (double)(byte)propValue;
                     }
-                    else if (propValue is DateTime)
+                    else if (propValue is DateTime dateTime)
                     {
-                        return (double)((DateTime)propValue).Year;
+                        return (double)dateTime.Year;
                     }
                     else
                     {
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Text/TextRange.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Text/TextRange.cs
index 69617d53..3130e33f 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Text/TextRange.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClient/System/Windows/Automation/Text/TextRange.cs
@@ -197,9 +197,9 @@ public TextPatternRange FindAttribute(AutomationTextAttribute attribute, object
             // the provider.
             if (attribute == TextPattern.CultureAttribute)
             {
-                if (value is CultureInfo)
+                if (value is CultureInfo cultureInfo)
                 {
-                    value = ((CultureInfo)value).LCID;
+                    value = cultureInfo.LCID;
                 }
             }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/Accessible.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/Accessible.cs
index f5984287..5cb379f5 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/Accessible.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/Accessible.cs
@@ -572,14 +572,13 @@ internal static Accessible GetFullAccessibleChildByIndex(Accessible accParent, i
             if (accChildren != null && 0 <= index && index < accChildren.Length)
             {
                 object child = accChildren[index];
-                IAccessible accChild = child as IAccessible;
-                if (accChild != null)
+
+                if (child is IAccessible accChild)
                 {
                     return Accessible.Wrap(accChild);
                 }
-                else if (child is int)
+                else if (child is int idChild)
                 {
-                    int idChild = (int)child;
                     return Accessible.Wrap(accParent.IAccessible, idChild);
                 }
             }
@@ -643,9 +642,8 @@ internal static AccessibleRole GetRole(IAccessible acc, int idChild)
                 children = new Accessible[1];
                 children[0] = AccessibleFromObject(obj, _acc);
             }
-            else if (obj is object [])
+            else if (obj is object[] objs)
             {
-                object [] objs = (object [])obj;
                 children = new Accessible[objs.Length];
                 for (int i=0;i<objs.Length;i++)
                 {
@@ -684,9 +682,9 @@ internal Accessible GetFocus()
             }
 
             // Expect to get back either an IAccessible...
-            if (scan is IAccessible)
+            if (scan is IAccessible iAccessible)
             {
-                return Wrap((IAccessible)scan);
+                return Wrap(iAccessible);
             }
             // ... Or a ChildID (may be this element or a ChildID)...
             else if (scan is Int32)
@@ -771,10 +769,9 @@ internal Accessible HitTest(int x, int y)
                 // point is not on this object or one of its children
                 rval = null;
             }
-            else if (scan is int)
+            else if (scan is int idChild)
             {
                 // point is on child or self. If self then return 'this'
-                int idChild = (int)scan;
                 if (idChild == NativeMethods.CHILD_SELF)
                 {
                     rval = this;
@@ -789,9 +786,9 @@ internal Accessible HitTest(int x, int y)
                     rval = Wrap(_acc, idChild);
                 }
             }
-            else if (scan is IAccessible)
+            else if (scan is IAccessible iAccessible)
             {
-                rval = Wrap((IAccessible)scan, NativeMethods.CHILD_SELF);
+                rval = Wrap(iAccessible, NativeMethods.CHILD_SELF);
             }
             else
             {
@@ -1106,13 +1103,13 @@ private static void IAccessibleFromObject(object obj, IAccessible parent, out IA
             {
                 idChild = NativeMethods.CHILD_SELF;
             }
-            else if (obj is int)
+            else if (obj is int i)
             {
                 // call get_accChild to check if the object has its own IAccessible...
                 object test = null;
                 try
                 {
-                    test = parent.get_accChild((int)obj);
+                    test = parent.get_accChild(i);
                 }
                 catch (Exception e)
                 {
@@ -1129,9 +1126,9 @@ private static void IAccessibleFromObject(object obj, IAccessible parent, out IA
                     }
                 }
 
-                if (test is IAccessible)
+                if (test is IAccessible iAccessible)
                 {
-                    acc = (IAccessible)test;
+                    acc = iAccessible;
                     idChild = NativeMethods.CHILD_SELF;
                 }
                 else
@@ -1338,14 +1335,12 @@ private static bool HandleIAccessibleException(Exception e)
                 return true;
             }
 
-            COMException comException = e as COMException;
-
             if (e is NotImplementedException)
             {
                 // just return on E_NOTIMPL errors
                 return false;
             }
-            else if (comException != null)
+            else if (e is COMException comException)
             {
                 // convert certain COM exceptions to ElementNotAvailable exceptions.
                 // these occur when the underlying UI elements disappear but we are still
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ClickablePoint.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ClickablePoint.cs
index 959f0efb..3cccd0d8 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ClickablePoint.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ClickablePoint.cs
@@ -161,9 +161,9 @@ internal static void ExcludeChildren(ProxyFragment fragment, ArrayList alIn, Arr
                 ClickablePoint.SplitRect(alIn, ref rcp, alOut, true);
 
                 // recurse on the children
-                if (simple is ProxyFragment)
+                if (simple is ProxyFragment proxyFragment)
                 {
-                    ExcludeChildren((ProxyFragment)simple, alIn, alOut);
+                    ExcludeChildren(proxyFragment, alIn, alOut);
                 }
             }
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAANativeProvider.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAANativeProvider.cs
index 7c52ccfa..c144ca32 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAANativeProvider.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAANativeProvider.cs
@@ -423,9 +423,9 @@ Rect IRawElementProviderFragment.BoundingRectangle
 
                 bool isOffscreen = false;
                 object isOffscreenProperty = GetPropertyValue(AutomationElement.IsOffscreenProperty);
-                if (isOffscreenProperty is bool)
+                if (isOffscreenProperty is bool b)
                 {
-                    isOffscreen = (bool)isOffscreenProperty;
+                    isOffscreen = b;
                 }
 
                 if (isOffscreen)
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAAWinEventWrap.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAAWinEventWrap.cs
index cf106d62..cb660e09 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAAWinEventWrap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/MSAAWinEventWrap.cs
@@ -101,10 +101,7 @@ internal void StopListening()
                     _hHooks[i] = IntPtr.Zero;
                 }
             }
-            if (_qEvents != null)
-            {
-                _qEvents.Clear();
-            }
+            _qEvents?.Clear();
             _fBusy = false;
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/NonClientArea.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/NonClientArea.cs
index c407e82c..cb6f046b 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/NonClientArea.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/NonClientArea.cs
@@ -54,10 +54,7 @@ internal override void AdviseEventAdded (AutomationEvent eventId, AutomationProp
                 }
             }
 
-            if (menuProxy != null)
-            {
-                menuProxy.AdviseEventAdded(eventId, aidProps);
-            }
+            menuProxy?.AdviseEventAdded(eventId, aidProps);
 
             base.AdviseEventAdded(eventId, aidProps);
         }
@@ -77,10 +74,7 @@ internal override void AdviseEventRemoved (AutomationEvent eventId, AutomationPr
                 }
             }
 
-            if (menuProxy != null)
-            {
-                menuProxy.AdviseEventRemoved(eventId, aidProps);
-            }
+            menuProxy?.AdviseEventRemoved(eventId, aidProps);
 
             base.AdviseEventRemoved(eventId, aidProps);
         }
@@ -654,10 +648,7 @@ private ProxySimple FindMenus(int x, int y)
         private static void RaiseMenuEventsOnClient(IntPtr hwnd, int eventId, object idProp, int idObject, int idChild)
         {
             ProxySimple el = WindowsMenu.CreateMenuItemFromEvent(hwnd, eventId, idChild, idObject);
-            if (el != null)
-            {
-                el.DispatchEvents(eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         private static void RaiseEventsOnClient(IntPtr hwnd, int eventId, object idProp, int idObject, int idChild)
@@ -665,10 +656,7 @@ private static void RaiseEventsOnClient(IntPtr hwnd, int eventId, object idProp,
             if (Misc.GetClassName(hwnd) == "ComboLBox")
             {
                 ProxySimple el = (ProxySimple)WindowsListBox.Create(hwnd, idChild);
-                if (el != null)
-                {
-                    el.DispatchEvents(eventId, idProp, idObject, idChild);
-                }
+                el?.DispatchEvents(eventId, idProp, idObject, idChild);
             }
         }
 
@@ -692,10 +680,7 @@ private static void RaiseEventsOnScroll(IntPtr hwnd, int eventId, object idProp,
                 if (scrollBar != null)
                 {
                     ProxySimple scrollBarBit = WindowsScrollBarBits.CreateFromChildId(hwnd, scrollBar, idChild, sbFlag);
-                    if (scrollBarBit != null)
-                    {
-                        scrollBarBit.DispatchEvents(eventId, idProp, idObject, idChild);
-                    }
+                    scrollBarBit?.DispatchEvents(eventId, idProp, idObject, idChild);
                 }
 
                 return;
@@ -736,10 +721,7 @@ private static void RaiseEventsOnScroll(IntPtr hwnd, int eventId, object idProp,
                 el = (ProxyFragment)WindowsListBox.Create(hwnd, 0);
             }
 
-            if (el != null)
-            {
-                el.DispatchEvents(eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         private static void RaiseEventsOnWindow(IntPtr hwnd, int eventId, object idProp, int idObject, int idChild)
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ProxySimple.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ProxySimple.cs
index faf5656a..d0453784 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ProxySimple.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/ProxySimple.cs
@@ -546,9 +546,9 @@ void IRawElementProviderFragment.SetFocus()
             // So make sure the return is of type bool before casting.
             bool isKeyboardFocusable = true;
             object isKeyboardFocusableProperty = GetElementProperty(AutomationElement.IsKeyboardFocusableProperty);
-            if (isKeyboardFocusableProperty is bool)
+            if (isKeyboardFocusableProperty is bool b)
             {
-                isKeyboardFocusable = (bool)isKeyboardFocusableProperty;
+                isKeyboardFocusable = b;
             }
 
             // UIAutomation already focuses the containing HWND for us, so only need to
@@ -604,8 +604,7 @@ internal bool GetClickablePoint(out NativeMethods.Win32Point pt, bool fClipClien
             alOut.Add(new ClickablePoint.CPRect(ref rcItem, true));
 
             // First go through all the children to exclude whatever is on top
-            ProxyFragment proxyFrag = this as ProxyFragment;
-            if (proxyFrag != null)
+            if (this is ProxyFragment proxyFrag)
             {
                 ClickablePoint.ExcludeChildren(proxyFrag, alIn, alOut);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinEventTracker.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinEventTracker.cs
index 5029bf5b..aba01460 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinEventTracker.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinEventTracker.cs
@@ -234,7 +234,7 @@ private static void WinEventProc (int winEventHook, int eventId, IntPtr hwnd, in
                     }
 
                     // Sanity check
-                    if (hookParams != null && hookParams._alHwnd != null)
+                    if (hookParams?._alHwnd != null)
                     {
                         ArrayList eventCreateParams = hookParams._alHwnd;
 
@@ -287,7 +287,7 @@ private static void WinEventProc (int winEventHook, int eventId, IntPtr hwnd, in
                     // where the hwnd is not there until it is shown.  So we need to raise these event all the time.
                     // Office command bars use this.
                     hookParams = (EventHookParams)_ahp[evt][_globalEventKey];
-                    if (hookParams != null && hookParams._alHwnd != null)
+                    if (hookParams?._alHwnd != null)
                     {
                         ArrayList eventCreateParams = hookParams._alHwnd;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinFormsSpinner.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinFormsSpinner.cs
index 9b1dcf42..50ded0b8 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinFormsSpinner.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WinFormsSpinner.cs
@@ -280,10 +280,7 @@ internal override void AdviseEventAdded(AutomationEvent eventId, AutomationPrope
             base.AdviseEventAdded(eventId, aidProps);
 
             // Need to also advise the edit portions of the spinner so that it can raise events.
-            if (_elEdit != null)
-            {
-                _elEdit.AdviseEventAdded(eventId, aidProps);
-            }
+            _elEdit?.AdviseEventAdded(eventId, aidProps);
         }
 
         internal override void AdviseEventRemoved(AutomationEvent eventId, AutomationProperty[] aidProps)
@@ -291,10 +288,7 @@ internal override void AdviseEventRemoved(AutomationEvent eventId, AutomationPro
             base.AdviseEventRemoved(eventId, aidProps);
 
             // Need to also remove the advise from the edit portions of the spinner.
-            if (_elEdit != null)
-            {
-                _elEdit.AdviseEventRemoved(eventId, aidProps);
-            }
+            _elEdit?.AdviseEventRemoved(eventId, aidProps);
         }
 
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsAltTab.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsAltTab.cs
index 469eb5ef..22d818d9 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsAltTab.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsAltTab.cs
@@ -87,10 +87,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
             if (idObject != NativeMethods.OBJID_VSCROLL && idObject != NativeMethods.OBJID_HSCROLL)
             {
                 ProxySimple el = (ProxyHwnd) WindowsAltTab.Create(hwnd, 0);
-                if (el != null)
-                {
-                    el.DispatchEvents(eventId, idProp, idObject, idChild);
-                }
+                el?.DispatchEvents(eventId, idProp, idObject, idChild);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsComboBox.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsComboBox.cs
index 8f232dad..28ddbd95 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsComboBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsComboBox.cs
@@ -106,9 +106,7 @@ internal override object GetPatternProvider (AutomationPattern iid)
 
                 if (list != null)
                 {
-                    ISelectionProvider selection = list.GetPatternProvider (iid) as ISelectionProvider;
-
-                    if (selection != null)
+                    if (list.GetPatternProvider (iid) is ISelectionProvider selection)
                     {
                         return selection;
                     }
@@ -787,10 +785,7 @@ static private void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int id
 
             }
 
-            if (el != null)
-            {
-                el.DispatchEvents (eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         // Handles combo's edit portion specific events
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListBox.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListBox.cs
index f00363a4..614931cf 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListBox.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListBox.cs
@@ -128,10 +128,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
 
                 default :
                     ProxySimple el = (ProxyHwnd)WindowsListBox.Create(hwnd, 0);
-                    if (el != null)
-                    {
-                        el.DispatchEvents(eventId, idProp, idObject, idChild);
-                    }
+                    el?.DispatchEvents(eventId, idProp, idObject, idChild);
                     break;
             }
         }
@@ -158,9 +155,8 @@ internal override object GetPatternProvider (AutomationPattern iid)
             else if (iid == ScrollPattern.Pattern && WindowScroll.HasScrollableStyle(_hwnd))
             {
                 // delegate work to the NonClientArea implementation of IScrollProvider
-                IScrollProvider scroll = NonClientArea.Create(_hwnd, 0) as IScrollProvider;
 
-                if (scroll != null)
+                if (NonClientArea.Create(_hwnd, 0) is IScrollProvider scroll)
                 {
                     return scroll;
                 }
@@ -511,19 +507,15 @@ private static void RaiseEventsOnClient(IntPtr hwnd, int eventId, object idProp,
                 return;
             }
 
-            if (el != null)
-            {
-                el.DispatchEvents(eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         private static void RaiseEventsOnWindow(IntPtr hwnd, int eventId, object idProp, int idObject, int idChild)
         {
-            AutomationProperty automationProperty = idProp as AutomationProperty;
             ProxySimple el = null;
 
             if ((eventId == NativeMethods.EventObjectShow || eventId == NativeMethods.EventObjectHide) &&
-                (automationProperty != null && automationProperty == ExpandCollapsePattern.ExpandCollapseStateProperty))
+                (idProp is AutomationProperty automationProperty && automationProperty == ExpandCollapsePattern.ExpandCollapseStateProperty))
             {
                 if (Misc.IsBitSet(Misc.GetWindowStyle(hwnd), NativeMethods.LBS_COMBOBOX))
                 {
@@ -542,10 +534,7 @@ private static void RaiseEventsOnWindow(IntPtr hwnd, int eventId, object idProp,
                 }
             }
 
-            if (el != null)
-            {
-                el.DispatchEvents(eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         #region Selection Pattern Helpers
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListView.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListView.cs
index 33598b8f..7a258359 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsListView.cs
@@ -143,10 +143,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
                 default :
                 {
                     ProxySimple el = new WindowsListView( hwnd, null, -1 );
-                    if (el != null)
-                    {
-                        el.DispatchEvents( eventId, idProp, idObject, idChild );
-                    }
+                    el?.DispatchEvents(eventId, idProp, idObject, idChild);
                     break;
                 }
             }
@@ -230,8 +227,7 @@ internal override ProxySimple GetNextSibling (ProxySimple child)
                     throw new InvalidOperationException(SR.Get(SRID.OperationCannotBePerformed));
                 }
 
-                WindowsListViewGroup windowsListViewGroup = child as WindowsListViewGroup;
-                if (windowsListViewGroup != null)
+                if (child is WindowsListViewGroup windowsListViewGroup)
                 {
                     // The group might have destroyed by an event between a first an now
                     _groupsCollection.EnsureCreation (_hwnd);
@@ -285,8 +281,7 @@ internal override ProxySimple GetPreviousSibling (ProxySimple child)
                 }
 
                 // check if current child is a group
-                WindowsListViewGroup windowsListViewGroup = child as WindowsListViewGroup;
-                if (windowsListViewGroup != null)
+                if (child is WindowsListViewGroup windowsListViewGroup)
                 {
                     int groupID = windowsListViewGroup.ID;
                     int location = Array.IndexOf (groupIds, groupID);
@@ -2003,10 +1998,7 @@ private static void RaiseEventsOnClient(IntPtr hwnd, int eventId, object idProp,
                 el = wlv;
             }
 
-            if (el != null)
-            {
-                el.DispatchEvents(eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
 
             return;
         }
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEdit.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEdit.cs
index 75ca09f7..5cbaaa58 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEdit.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEdit.cs
@@ -574,8 +574,7 @@ private void GetEmbeddedObjectText(object embeddedObject, StringBuilder sbText)
         {
             string text;
 
-            IAccessible acc = embeddedObject as IAccessible;
-            if (acc != null)
+            if (embeddedObject is IAccessible acc)
             {
                 text = acc.get_accName(NativeMethods.CHILD_SELF);
                 if (!string.IsNullOrEmpty(text))
@@ -590,8 +589,8 @@ private void GetEmbeddedObjectText(object embeddedObject, StringBuilder sbText)
 
             int hr = NativeMethods.S_FALSE;
             IDataObject dataObject = null;
-            IOleObject oleObject = embeddedObject as IOleObject;
-            if (oleObject != null)
+
+            if (embeddedObject is IOleObject oleObject)
             {
                 // Try IOleObject::GetClipboardData (which returns an IDataObject) first...
                 hr = oleObject.GetClipboardData(0, out dataObject);
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEditRange.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEditRange.cs
index 89cc6004..cc1debcb 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEditRange.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsRichEditRange.cs
@@ -413,10 +413,8 @@ private static bool AttributeValuesAreEqual(object v1, object v2)
             {
                 return true;
             }
-            Array a1 = v1 as Array;
-            Array a2 = v2 as Array;
 
-            if( a1 != null && a2 != null)
+            if( v1 is Array a1 && v2 is Array a2)
             {
                 // System.Array has reference equality not value equality so we manually check
                 // whether two arrays have the same contents.
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBar.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBar.cs
index 6a9a37ca..015542c4 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBar.cs
@@ -106,10 +106,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
             {
                 // raise events for the children 
                 ProxySimple scrollBarBit = WindowsScrollBarBits.CreateFromChildId(hwnd, wtv, idChild, NativeMethods.SB_CTL);
-                if (scrollBarBit != null)
-                {
-                    scrollBarBit.DispatchEvents(eventId, idProp, idObject, idChild);
-                }
+                scrollBarBit?.DispatchEvents(eventId, idProp, idObject, idChild);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBarBits.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBarBits.cs
index 9aae7055..43fcca34 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBarBits.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsScrollBarBits.cs
@@ -231,7 +231,7 @@ static internal Rect GetBoundingRectangle(IntPtr hwnd, ProxyFragment parent, Win
                 return Rect.Empty;
             }
 
-            if (parent != null && parent._parent != null)
+            if (parent?._parent != null)
             {
                 //
                 // Builds prior to Vista 5359 failed to correctly account for RTL scrollbar layouts.
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsSysHeader.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsSysHeader.cs
index 0c57d6ea..2843f1be 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsSysHeader.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsSysHeader.cs
@@ -84,10 +84,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
                         {
                             // Notify the Listview that the header Change
                             WindowsListView wlv = (WindowsListView) WindowsListView.Create (hwndParent, 0);
-                            if (wlv != null)
-                            {
-                                wlv.DispatchEvents (eventId, idProp, idObject, idChild);
-                            }
+                            wlv?.DispatchEvents(eventId, idProp, idObject, idChild);
                         }
                     }
                 }
@@ -473,10 +470,7 @@ void IInvokeProvider.Invoke ()
                 }
 
                 WindowsSysHeader parent = _parent as WindowsSysHeader;
-                if (parent != null)
-                {
-                    parent.ScrollIntoView(this);
-                }
+                parent?.ScrollIntoView(this);
 
                 NativeMethods.Win32Point pt;
 
@@ -721,10 +715,7 @@ private void ClickSplitButton ()
                 }
 
                 WindowsSysHeader parent = _parent as WindowsSysHeader;
-                if (parent != null)
-                {
-                    parent.ScrollIntoView(this);
-                }
+                parent?.ScrollIntoView(this);
 
 
                 Rect rect = XSendMessage.GetItemRect(_hwnd, NativeMethods.HDM_GETITEMDROPDOWNRECT, _item);
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTab.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTab.cs
index b67bc04c..0264a06e 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTab.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTab.cs
@@ -110,10 +110,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
                     el = new WindowsTab(hwnd, null, -1);
                     break;
             }
-            if (el != null)
-            {
-                el.DispatchEvents (eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsToolbar.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsToolbar.cs
index d07e3317..a8daedf3 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsToolbar.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsToolbar.cs
@@ -102,10 +102,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
                     }
                 }
                 // Ends up calling CreateToolbarItem which can return null
-                if (proxySimple != null)
-                {
-                    proxySimple.DispatchEvents(eventId, idProp, idObject, idChild);
-                }
+                proxySimple?.DispatchEvents(eventId, idProp, idObject, idChild);
             }
         }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTreeView.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTreeView.cs
index 423a0c83..ca609398 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTreeView.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsTreeView.cs
@@ -111,10 +111,7 @@ internal static void RaiseEvents (IntPtr hwnd, int eventId, object idProp, int i
                 return;
             }
 
-            if (el != null)
-            {
-                el.DispatchEvents (eventId, idProp, idObject, idChild);
-            }
+            el?.DispatchEvents(eventId, idProp, idObject, idChild);
         }
 
         #endregion Proxy Create
diff --git a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsUpDown.cs b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsUpDown.cs
index 91569ae8..ca7ce62f 100644
--- a/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsUpDown.cs
+++ b/src/Microsoft.DotNet.Wpf/src/UIAutomation/UIAutomationClientSideProviders/MS/Internal/AutomationProxies/WindowsUpDown.cs
@@ -93,10 +93,7 @@ private static void RaiseInvokedEvent(IntPtr hwnd, int idObject, int idChild)
                 WindowsUpDown wtv = new WindowsUpDown(hwnd, null, -1);
                 button = wtv.CreateSpinButtonItem(SpinItem.UpArrow);
             }
-            if (button != null)
-            {
-                button.DispatchEvents(NativeMethods.EventObjectInvoke, InvokePattern.InvokedEvent, idObject, idChild);
-            }
+            button?.DispatchEvents(NativeMethods.EventObjectInvoke, InvokePattern.InvokedEvent, idObject, idChild);
         }
 
         // Creates a list item RawElementBase Item
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/APCustomTypeDescriptor.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/APCustomTypeDescriptor.cs
index 40f83a16..c910c9a8 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/APCustomTypeDescriptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/APCustomTypeDescriptor.cs
@@ -82,8 +82,7 @@ public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
             {
                 foreach (Attribute attr in attributes) 
                 {
-                    PropertyFilterAttribute filterAttr = attr as PropertyFilterAttribute;
-                    if (filterAttr != null) 
+                    if (attr is PropertyFilterAttribute filterAttr) 
                     {
                         filter = filterAttr.Filter;
                         break;
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DPCustomTypeDescriptor.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DPCustomTypeDescriptor.cs
index be1f5ed3..9919a859 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DPCustomTypeDescriptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DPCustomTypeDescriptor.cs
@@ -64,7 +64,7 @@ public string GetComponentName()
             if (_instance != null) 
             {
                 RuntimeNamePropertyAttribute nameAttr = GetAttributes()[typeof(RuntimeNamePropertyAttribute)] as RuntimeNamePropertyAttribute;
-                if (nameAttr != null && nameAttr.Name != null) 
+                if (nameAttr?.Name != null) 
                 {
                     PropertyDescriptor nameProp = GetProperties()[nameAttr.Name];
                     if (nameProp != null) 
@@ -104,8 +104,7 @@ public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
             {
                 foreach (Attribute attr in attributes) 
                 {
-                    PropertyFilterAttribute filterAttr = attr as PropertyFilterAttribute;
-                    if (filterAttr != null) 
+                    if (attr is PropertyFilterAttribute filterAttr) 
                     {
                         filter = filterAttr.Filter;
                         break;
@@ -195,10 +194,7 @@ public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
                         }
                     }
                 }
-                else if (newDescriptors != null) 
-                {
-                    newDescriptors.Add(prop);
-                }
+                else newDescriptors?.Add(prop);
             }
 
             if (newDescriptors != null) 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyObjectPropertyDescriptor.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyObjectPropertyDescriptor.cs
index edd1ae04..7a5cfde0 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyObjectPropertyDescriptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyObjectPropertyDescriptor.cs
@@ -489,8 +489,7 @@ private AttributeCollection GetAttachedPropertyAttributes()
 
                 foreach(Attribute attr in attrArray) 
                 {
-                    AttributeProviderAttribute pa = attr as AttributeProviderAttribute;
-                    if (pa != null) 
+                    if (attr is AttributeProviderAttribute pa) 
                     {
                         Type providerType = Type.GetType(pa.TypeName);
                         if (providerType != null) 
@@ -672,9 +671,8 @@ private void MergeAttributes()
             foreach (Attribute a in baseAttributes) 
             {
                 Attribute attrToAdd = a;
-                DefaultValueAttribute defAttr = a as DefaultValueAttribute;
 
-                if (defAttr != null) 
+                if (a is DefaultValueAttribute defAttr) 
                 {
                     // DP metadata always overrides CLR metadata for
                     // default value.
@@ -682,8 +680,7 @@ private void MergeAttributes()
                 }
                 else 
                 {
-                    ReadOnlyAttribute roAttr = a as ReadOnlyAttribute;
-                    if (roAttr != null)
+                    if (a is ReadOnlyAttribute roAttr)
                     {
                         // DP metata is the merge of CLR metadata for
                         // read only
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyPropertyAttribute.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyPropertyAttribute.cs
index 541f33fa..61418733 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyPropertyAttribute.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/ComponentModel/DependencyPropertyAttribute.cs
@@ -50,9 +50,8 @@ internal DependencyPropertyAttribute(DependencyProperty dependencyProperty, bool
         /// </summary>
         public override bool Equals(object value) 
         {
-            DependencyPropertyAttribute da = value as DependencyPropertyAttribute;
 
-            if (da != null && 
+            if (value is DependencyPropertyAttribute da && 
                 object.ReferenceEquals(da._dp, _dp) && 
                 da._isAttached == _isAttached) 
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/FreezableDefaultValueFactory.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/FreezableDefaultValueFactory.cs
index 361e0018..8f0b1142 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/FreezableDefaultValueFactory.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/FreezableDefaultValueFactory.cs
@@ -61,10 +61,10 @@ internal override object CreateDefaultValue(DependencyObject owner, DependencyPr
                 "It is the caller responsibility to ensure that owner and property are non-null.");
             
             Freezable result = _defaultValuePrototype;
-            Freezable ownerFreezable = owner as Freezable;
+
             
             // If the owner is frozen, just return the frozen prototype.
-            if (ownerFreezable != null && ownerFreezable.IsFrozen)
+            if (owner is Freezable ownerFreezable && ownerFreezable.IsFrozen)
             {
                 return result;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/ContainerUtilities.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/ContainerUtilities.cs
index 3a77e1cc..0042c373 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/ContainerUtilities.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/ContainerUtilities.cs
@@ -153,10 +153,7 @@ internal static int WriteByteLengthPrefixedDWordPaddedUnicodeString(BinaryWriter
                     {
                         strByteLen += padLength;
 
-                        if (writer != null)
-                        {
-                            writer.Write(_paddingBuf, 0, padLength);
-                        }
+                        writer?.Write(_paddingBuf, 0, padLength);
                     }
                 }
 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/NativeCompoundFileAPIs.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/NativeCompoundFileAPIs.cs
index 1228d465..f6d95859 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/NativeCompoundFileAPIs.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/Compoundfile/NativeCompoundFileAPIs.cs
@@ -240,10 +240,7 @@ protected virtual void Dispose(bool disposing)
 
                         // If the storage was originally opened on lockbyte implementation
                         //  we need to dispose it as well
-                        if (_unsafeLockByteStream != null)
-                        {
-                            _unsafeLockByteStream.Dispose();
-                        }
+                        _unsafeLockByteStream?.Dispose();
                     }
                 }
                 finally
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/CustomSignedXml.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/CustomSignedXml.cs
index c53a29cd..a2a6682b 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/CustomSignedXml.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/CustomSignedXml.cs
@@ -173,9 +173,8 @@ private static XmlElement SelectSubObjectNodeForXAdESInDataObjects(Signature sig
                         }
 
                         foundMatch = true;
-                        XmlNode local = nodeList[0] as XmlElement;
 
-                        if (local != null)
+                        if (nodeList[0] is XmlElement local)
                         {
                             XmlNode temp = local;
 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/PackUriHelper.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/PackUriHelper.cs
index a9297c22..6d3a44bd 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/PackUriHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/PackUriHelper.cs
@@ -92,7 +92,7 @@ internal static ValidatedPartUri ValidatePartUri(Uri partUri)
             }
             else
             {
-                Debug.Assert(partUriString != null && partUriString.Length > 0);
+                Debug.Assert(!string.IsNullOrEmpty(partUriString));
                 return new ValidatedPartUri(partUriString);
             }
         }
@@ -454,7 +454,7 @@ internal bool IsRelationshipPartUri
             private ValidatedPartUri(string partUriString, bool isNormalized, bool computeIsRelationship, bool isRelationshipPartUri)
                 : base(partUriString, UriKind.Relative)
             {
-                Debug.Assert(partUriString != null && partUriString.Length > 0);
+                Debug.Assert(!string.IsNullOrEmpty(partUriString));
 
                 _partUriString = partUriString;
                 _isNormalized = isNormalized;
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/SparseMemoryStream.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/SparseMemoryStream.cs
index 28b0eb96..1a8c4f44 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/SparseMemoryStream.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/SparseMemoryStream.cs
@@ -420,11 +420,7 @@ protected override void Dispose(bool disposing)
                         }
 
                         // clean up isolated storage resources if in use
-                        if (_isolatedStorageStream != null)
-                        {
-                            // can only rely on _isolatedStorageStream behaving correctly if we are not in our finalizer
-                            _isolatedStorageStream.Close();
-                        }
+                        _isolatedStorageStream?.Close();
                     }
                 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/StorageBasedPackageProperties.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/StorageBasedPackageProperties.cs
index 22ce0701..dfe95f05 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/StorageBasedPackageProperties.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/StorageBasedPackageProperties.cs
@@ -737,11 +737,11 @@ out ps
                     vals[0].vt = VARTYPE.VT_LPSTR;
                     vals[0].union.pszVal = pszVal;
                 }
-                else if (propVal is DateTime)
+                else if (propVal is DateTime dateTime)
                 {
                     // set FileTime as an Int64 to avoid pointer operations
                     vals[0].vt = VARTYPE.VT_FILETIME;
-                    vals[0].union.hVal = ((DateTime)propVal).ToFileTime();
+                    vals[0].union.hVal = dateTime.ToFileTime();
                 }
                 else
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlDigitalSignatureProcessor.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlDigitalSignatureProcessor.cs
index 5a48b545..9eb8e088 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlDigitalSignatureProcessor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlDigitalSignatureProcessor.cs
@@ -538,8 +538,7 @@ internal static HashAlgorithm GetHashAlgorithm(String hashAlgorithmName)
             // we should attempt to dispose it if it offers IDisposable.
             if (algorithm == null && o != null)
             {
-                IDisposable disposable = o as IDisposable;
-                if (disposable != null)
+                if (o is IDisposable disposable)
                     disposable.Dispose();
             }
 
@@ -1076,12 +1075,12 @@ private KeyInfo GenerateKeyInfo(AsymmetricAlgorithm key, X509Certificate2 signer
             keyInfo.AddClause(keyInfoName);               // human readable Principal name
 
             // Include the public key information (if we are familiar with the algorithm type)
-            if (key is RSA)
-                keyInfo.AddClause(new RSAKeyValue((RSA)key));    // RSA key parameters
+            if (key is RSA rSA)
+                keyInfo.AddClause(new RSAKeyValue(rSA));    // RSA key parameters
             else
             {
-                if (key is DSA)
-                    keyInfo.AddClause(new DSAKeyValue((DSA)key));    // DSA
+                if (key is DSA dSA)
+                    keyInfo.AddClause(new DSAKeyValue(dSA));    // DSA
                 else
                     throw new ArgumentException(SR.Get(SRID.CertificateKeyTypeNotSupported), "signer");
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlSignatureManifest.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlSignatureManifest.cs
index b4af9e3a..31f74d7f 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlSignatureManifest.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/IO/Packaging/XmlSignatureManifest.cs
@@ -438,7 +438,7 @@ private static void ParseRelationshipsTransform(XmlReader reader, Uri partUri, r
                         // RelationshipReference tags are legal and these must be empty with a single SourceId attribute
                         // get the SourceId attribute 
                         string id = reader.GetAttribute(XTable.Get(XTable.ID.SourceIdAttrName));
-                        if (id != null && id.Length > 0)
+                        if (!string.IsNullOrEmpty(id))
                         {
                             if (relationshipSelectors == null)
                                 relationshipSelectors = new List<PackageRelationshipSelector>();
@@ -452,7 +452,7 @@ private static void ParseRelationshipsTransform(XmlReader reader, Uri partUri, r
                     {
                         // RelationshipsGroupReference tags must be empty with a single SourceType attribute
                         string type = reader.GetAttribute(XTable.Get(XTable.ID.SourceTypeAttrName));
-                        if (type != null && type.Length > 0)
+                        if (!string.IsNullOrEmpty(type))
                         {
                             // lazy init
                             if (relationshipSelectors == null)
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/InheritanceContextHelper.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/InheritanceContextHelper.cs
index d610d664..321dfee8 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/InheritanceContextHelper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/InheritanceContextHelper.cs
@@ -33,10 +33,7 @@ internal static class InheritanceContextHelper
             DependencyObject context,
             DependencyObject newValue )
         {
-            if (context != null)
-            {
-                context.ProvideSelfAsInheritanceContext(newValue, null);
-            }
+            context?.ProvideSelfAsInheritanceContext(newValue, null);
         }
 
         //--------------------------------------------------------------------
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Security/RightsManagement/ClientSession.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Security/RightsManagement/ClientSession.cs
index 32615eec..cd01adde 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Security/RightsManagement/ClientSession.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Security/RightsManagement/ClientSession.cs
@@ -150,10 +150,7 @@ protected virtual void Dispose(bool disposing)
                                 // Dispose call back handler 
                                 try
                                 {
-                                    if (_callbackHandler != null)
-                                    {
-                                        _callbackHandler.Dispose();
-                                    }
+                                    _callbackHandler?.Dispose();
                                 }
                                 finally
                                 {
@@ -937,8 +934,8 @@ private static Uri GetRegistryPassportCertificationUrl()
             else
             {
                 object keyValue = key.GetValue(null); // this should get the default value
-                string stringValue = keyValue as string;
-                if (stringValue != null)
+
+                if (keyValue is string stringValue)
                 {
                     return new Uri(stringValue);
                 }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Threading/ExceptionWrapper.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Threading/ExceptionWrapper.cs
index 765a4837..80ec8bff 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Threading/ExceptionWrapper.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/Threading/ExceptionWrapper.cs
@@ -76,15 +76,13 @@ private object InternalRealCall(Delegate callback, object args, int numArgs)
             // expensive DynamicInvoke call.
             if(numArgsEx == 0)
             {
-                Action action = callback as Action;
-                if (action != null)
+                if (callback is Action action)
                 {
                     action();
                 }
                 else
                 {
-                    Dispatcher.ShutdownCallback shutdownCallback = callback as Dispatcher.ShutdownCallback;
-                    if(shutdownCallback != null)
+                    if(callback is Dispatcher.ShutdownCallback shutdownCallback)
                     {
                         shutdownCallback();
                     }
@@ -97,15 +95,13 @@ private object InternalRealCall(Delegate callback, object args, int numArgs)
             }
             else if(numArgsEx == 1)
             {
-                DispatcherOperationCallback dispatcherOperationCallback = callback as DispatcherOperationCallback;
-                if(dispatcherOperationCallback != null)
+                if(callback is DispatcherOperationCallback dispatcherOperationCallback)
                 {
                     result = dispatcherOperationCallback(singleArg);
                 }
                 else
                 {
-                    SendOrPostCallback sendOrPostCallback = callback as SendOrPostCallback;
-                    if(sendOrPostCallback != null)
+                    if(callback is SendOrPostCallback sendOrPostCallback)
                     {
                         sendOrPostCallback(singleArg);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/TraceLevelStore.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/TraceLevelStore.cs
index 8ec088db..6827109e 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/TraceLevelStore.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/TraceLevelStore.cs
@@ -128,10 +128,9 @@ public override int GetHashCode()
 
             public override bool Equals(object o)
             {
-                if (o is Key)
+                if (o is Key that)
                 {
                     WeakReference wr;
-                    Key that = (Key)o;
 
                     if (this._hashcode != that._hashcode)
                         return false;
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakEventTable.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakEventTable.cs
index c13f1095..57d21216 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakEventTable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakEventTable.cs
@@ -542,10 +542,9 @@ public override int GetHashCode()
 
             public override bool Equals(object o)
             {
-                if (o is EventKey)
+                if (o is EventKey ek)
                 {
                     WeakReference wr;
-                    EventKey ek = (EventKey)o;
 
                     if (_manager != ek._manager || _hashcode != ek._hashcode)
                         return false;
@@ -597,9 +596,8 @@ public override int GetHashCode()
 
             public override bool Equals(object o)
             {
-                if (o is EventNameKey)
+                if (o is EventNameKey that)
                 {
-                    EventNameKey that = (EventNameKey)o;
                     return (this._eventSourceType == that._eventSourceType && this._eventName == that._eventName);
                 }
                 else
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakReferenceKey.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakReferenceKey.cs
index 704c117d..53e2f33a 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakReferenceKey.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/MS/Internal/WeakReferenceKey.cs
@@ -38,8 +38,7 @@ public override bool Equals(object o)
             if (o == this)
                 return true;
 
-            WeakReferenceKey<T> key = o as WeakReferenceKey<T>;
-            if (key != null)
+            if (o is WeakReferenceKey<T> key)
             {
                 T item = this.Item;
                 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Collections/ObjectModel/WeakReadOnlyCollection.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Collections/ObjectModel/WeakReadOnlyCollection.cs
index 160cfaeb..843bcd3a 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Collections/ObjectModel/WeakReadOnlyCollection.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Collections/ObjectModel/WeakReadOnlyCollection.cs
@@ -171,8 +171,8 @@ internal class WeakReadOnlyCollection<T>: IList<T>, IList
             }
 
             IList<T> dlist = CreateDereferencedList();
-            T[] items = array as T[];
-            if (items != null) {
+
+            if (array is T[] items) {
                 dlist.CopyTo(items, index);
             }
             else {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/DependencyPropertyDescriptor.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/DependencyPropertyDescriptor.cs
index e8d054ba..2b8bb11c 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/DependencyPropertyDescriptor.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/DependencyPropertyDescriptor.cs
@@ -90,17 +90,14 @@ public static DependencyPropertyDescriptor FromProperty(PropertyDescriptor prope
             DependencyProperty dp = null;
             bool isAttached = false;
 
-            DependencyObjectPropertyDescriptor idpd = property as DependencyObjectPropertyDescriptor;
-            if (idpd != null) 
+            if (property is DependencyObjectPropertyDescriptor idpd) 
             {
                 dp = idpd.DependencyProperty;
                 isAttached = idpd.IsAttached;
             }
             else 
             {
-                #pragma warning suppress 6506 // Property is obviously not null.
-                DependencyPropertyAttribute dpa = property.Attributes[typeof(DependencyPropertyAttribute)] as DependencyPropertyAttribute;
-                if (dpa != null)
+                if (property.Attributes[typeof(DependencyPropertyAttribute)] is DependencyPropertyAttribute dpa)
                 {
                     dp = dpa.DependencyProperty;
                     isAttached = dpa.IsAttached;
@@ -314,8 +311,7 @@ public static DependencyPropertyDescriptor FromName(string name, Type ownerType,
         /// </summary>
         public override bool Equals(object obj) 
         {
-            DependencyPropertyDescriptor dp = obj as DependencyPropertyDescriptor;
-            if (dp != null && dp._dp == _dp && dp._componentType == _componentType)
+            if (obj is DependencyPropertyDescriptor dp && dp._dp == _dp && dp._componentType == _componentType)
             {
                 return true;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/PropertyFilterAttribute.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/PropertyFilterAttribute.cs
index a9449464..379397b9 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/PropertyFilterAttribute.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/ComponentModel/PropertyFilterAttribute.cs
@@ -51,8 +51,7 @@ public PropertyFilterAttribute(PropertyFilterOptions filter)
         /// </summary>
         public override bool Equals(object value) 
         {
-            PropertyFilterAttribute a = value as PropertyFilterAttribute;
-            if (a != null && a._filter.Equals(_filter)) 
+            if (value is PropertyFilterAttribute a && a._filter.Equals(_filter)) 
             {
                 return true;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StorageInfo.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StorageInfo.cs
index b2d66002..6fe2172b 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StorageInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StorageInfo.cs
@@ -789,10 +789,10 @@ internal void DestroyElement( string elementNameInternal )
         DataSpaceManager manager = Root.GetDataSpaceManager();
         if( null != manager )
         {
-             if( deadElementWalking is StorageInfoCore )
+             if( deadElementWalking is StorageInfoCore storageInfoCore)
             {
                 //if the element getting deleted is a storage, make sure to delete all its children's references.
-                string name = ((StorageInfoCore)deadElementWalking).storageName;
+                string name = storageInfoCore.storageName;
                 StorageInfo stInfo = new StorageInfo(this, name);
                 RemoveSubStorageEntryFromDataSpaceMap(stInfo);
             }
@@ -828,10 +828,8 @@ internal void DestroyElement( string elementNameInternal )
         InvalidateEnumerators();
         
         // Remove the now-meaningless name, which also signifies disposed status.
-        if( deadElementWalking is StorageInfoCore )
+        if( deadElementWalking is StorageInfoCore deadStorageInfoCore)
         {
-            StorageInfoCore deadStorageInfoCore = (StorageInfoCore)deadElementWalking;
-
             // Erase this storage's existence
             deadStorageInfoCore.storageName = null;
             if( null != deadStorageInfoCore.safeIStorage )
@@ -840,10 +838,8 @@ internal void DestroyElement( string elementNameInternal )
                 deadStorageInfoCore.safeIStorage = null;
             }
         }
-        else if( deadElementWalking is StreamInfoCore )
+        else if( deadElementWalking is StreamInfoCore deadStreamInfoCore)
         {
-            StreamInfoCore deadStreamInfoCore = (StreamInfoCore)deadElementWalking;
-
             // Erase this stream's existence
             deadStreamInfoCore.streamName = null;
 
@@ -1230,14 +1226,12 @@ internal static void RecursiveStorageInfoCoreRelease( StorageInfoCore startCore
             //  down.
             foreach( object o in startCore.elementInfoCores.Values )
             {
-                if( o is StorageInfoCore )
+                if( o is StorageInfoCore storageInfoCore)
                 {
-                    RecursiveStorageInfoCoreRelease( (StorageInfoCore)o );
+                    RecursiveStorageInfoCoreRelease( storageInfoCore);
                 }
-                else if( o is StreamInfoCore )
+                else if( o is StreamInfoCore streamRelease)
                 {
-                    StreamInfoCore streamRelease = (StreamInfoCore)o;
-
                     try
                     {
                         if (null != streamRelease.exposedStream)
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StreamInfo.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StreamInfo.cs
index 548c3358..d421d06a 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StreamInfo.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/Compoundfile/StreamInfo.cs
@@ -828,8 +828,7 @@ private void EnsureTransformInformation()
 
                 foreach (IDataTransform dataTransform in transforms)
                 {
-                    string id = dataTransform.TransformIdentifier as string;
-                    if (id != null)
+                    if (dataTransform.TransformIdentifier is string id)
                     {
                         id = id.ToUpperInvariant();
 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/EncryptedPackage.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/EncryptedPackage.cs
index d9f0f652..96abb254 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/EncryptedPackage.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/EncryptedPackage.cs
@@ -520,18 +520,14 @@ string fileName
             }
             catch (IOException ex)
             {
-                COMException comException = ex.InnerException as COMException;
-                if (comException != null && comException.ErrorCode == STG_E_FILEALREADYEXISTS)
+                if (ex.InnerException is COMException comException && comException.ErrorCode == STG_E_FILEALREADYEXISTS)
                     return false;
 
                 throw;  // Any other kind of IOException is a real error.
             }
             finally
             {
-                if (root != null)
-                {
-                    root.Close();
-                }
+                root?.Close();
             }
 
             return retval;
@@ -578,18 +574,14 @@ Stream stream
             }
             catch (IOException ex)
             {
-                COMException comException = ex.InnerException as COMException;
-                if (comException != null && comException.ErrorCode == STG_E_FILEALREADYEXISTS)
+                if (ex.InnerException is COMException comException && comException.ErrorCode == STG_E_FILEALREADYEXISTS)
                     return false;
 
                 throw;  // Any other kind of IOException is a real error.
             }
             finally
             {
-                if (root != null)
-                {
-                    root.Close();
-                }
+                root?.Close();
             }
 
             return retval;
@@ -606,15 +598,9 @@ public void Flush()
             // Since _package is only initialized when the client calls GetPackage, it might
             // not be set when the client calls Flush, so we have to check.
             //
-            if (_package != null)
-            {
-                _package.Flush();
-            }
+            _package?.Flush();
 
-            if (_packageStream != null)
-            {
-                _packageStream.Flush();
-            }
+            _packageStream?.Flush();
 
             Invariant.Assert(_root != null, "The envelope cannot be null");
 
@@ -935,8 +921,7 @@ private void
 
             foreach (IDataTransform dataTransform in transforms)
             {
-                string id = dataTransform.TransformIdentifier as string;
-                if (id != null &&
+                if (dataTransform.TransformIdentifier is string id &&
                         String.CompareOrdinal(id.ToUpperInvariant(),
                             RightsManagementEncryptionTransform.ClassTransformIdentifier.ToUpperInvariant()) == 0)
                 {
@@ -1049,10 +1034,7 @@ bool disposing
                         // might have opened the compound file just to look at the properties, and
                         // never even opened the package.
                         //
-                        if (_package != null)
-                        {
-                            _package.Close();
-                        }
+                        _package?.Close();
                     }
                     finally
                     {
@@ -1060,10 +1042,7 @@ bool disposing
 
                         try
                         {
-                            if (_packageStream != null)
-                            {
-                                _packageStream.Close();
-                            }
+                            _packageStream?.Close();
                         }
                         finally
                         {
@@ -1071,10 +1050,7 @@ bool disposing
 
                             try
                             {
-                                if (_packageProperties != null)
-                                {
-                                    _packageProperties.Dispose();
-                                }
+                                _packageProperties?.Dispose();
                             }
                             finally
                             {
@@ -1082,10 +1058,7 @@ bool disposing
 
                                 try
                                 {
-                                    if (_root != null)
-                                    {
-                                        _root.Close();
-                                    }
+                                    _root?.Close();
                                 }
                                 finally
                                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/PackageDigitalSignatureManager.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/PackageDigitalSignatureManager.cs
index 3fe90e2b..2ec24e75 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/PackageDigitalSignatureManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/IO/Packaging/PackageDigitalSignatureManager.cs
@@ -1031,8 +1031,7 @@ private bool EnumeratorEmptyCheck(System.Collections.IEnumerable enumerable)
                 return true;            // null means empty
 
             // see if it's really a collection as this is more efficient than enumerating
-            System.Collections.ICollection collection = enumerable as System.Collections.ICollection;
-            if (collection != null)
+            if (enumerable is System.Collections.ICollection collection)
             {
                 return (collection.Count == 0);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/Int32RectValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/Int32RectValueSerializer.cs
index dfd573ab..1ff8564a 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/Int32RectValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/Int32RectValueSerializer.cs
@@ -75,10 +75,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Int32Rect)
+            if (value is Int32Rect instance)
             {
-                Int32Rect instance = (Int32Rect) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/PointValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/PointValueSerializer.cs
index 2cf64014..9da3d682 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/PointValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/PointValueSerializer.cs
@@ -75,10 +75,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Point)
+            if (value is Point instance)
             {
-                Point instance = (Point) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/RectValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/RectValueSerializer.cs
index 09f9ea7b..4f3a141d 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/RectValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/RectValueSerializer.cs
@@ -75,10 +75,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Rect)
+            if (value is Rect instance)
             {
-                Rect instance = (Rect) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/SizeValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/SizeValueSerializer.cs
index 621b52f9..4cbb5c92 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/SizeValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/SizeValueSerializer.cs
@@ -75,10 +75,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Size)
+            if (value is Size instance)
             {
-                Size instance = (Size) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/VectorValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/VectorValueSerializer.cs
index b4720105..25114dfe 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/VectorValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Converters/Generated/VectorValueSerializer.cs
@@ -75,10 +75,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Vector)
+            if (value is Vector instance)
             {
-                Vector instance = (Vector) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyObject.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyObject.cs
index 0d268a02..b0cf97ff 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyObject.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyObject.cs
@@ -857,8 +857,7 @@ private PropertyMetadata SetupPropertyChange(DependencyPropertyKey key, out Depe
         [FriendAccessAllowed] // Built into Base, also used by Core & Framework.
         internal bool ProvideSelfAsInheritanceContext( object value, DependencyProperty dp )
         {
-            DependencyObject doValue = value as DependencyObject;
-            if (doValue != null)
+            if (value is DependencyObject doValue)
             {
                 return ProvideSelfAsInheritanceContext(doValue, dp);
             }
@@ -904,8 +903,7 @@ internal bool ProvideSelfAsInheritanceContext( DependencyObject doValue, Depende
         [FriendAccessAllowed] // Built into Base, also used by Core & Framework.
         internal bool RemoveSelfAsInheritanceContext( object value, DependencyProperty dp )
         {
-            DependencyObject doValue = value as DependencyObject;
-            if (doValue != null)
+            if (value is DependencyObject doValue)
             {
                 return RemoveSelfAsInheritanceContext(doValue, dp);
             }
@@ -1177,10 +1175,7 @@ internal void NotifySubPropertyChange(DependencyProperty dp)
             // if the target is a Freezable, call FireChanged to kick off
             // notifications to the Freezable's parent chain.
             Freezable freezable = this as Freezable;
-            if (freezable != null)
-            {
-                freezable.FireChanged();
-            }
+            freezable?.FireChanged();
         }
 
         /// <summary>
@@ -2211,11 +2206,8 @@ internal object ReadLocalValueEntry(EntryIndex entryIndex, DependencyProperty dp
             // convert a deferred reference into a real value
             if (!allowDeferredReferences && entry.IsDeferredReference)
             {
-                // localValue may still not be a DeferredReference, e.g.
-                // if it is an expression whose value is a DeferredReference.
-                // So a little more work is needed before converting the value.
-                DeferredReference dr = value as DeferredReference;
-                if (dr != null)
+                // localValue may still not be a DeferredReference, e.g.                // if it is an expression whose value is a DeferredReference.                // So a little more work is needed before converting the value.
+                if (value is DeferredReference dr)
                 {
                     value = dr.GetValue(entry.BaseValueSourceInternal);
                 }
@@ -2690,8 +2682,7 @@ internal void OnInheritanceContextChanged(EventArgs args)
                         object localValue = ReadLocalValueEntry(new EntryIndex(i), dp, true /* allowDeferredReferences */);
                         if (localValue != DependencyProperty.UnsetValue)
                         {
-                            DependencyObject inheritanceChild = localValue as DependencyObject;
-                            if (inheritanceChild!= null && inheritanceChild.InheritanceContext == this)
+                            if (localValue is DependencyObject inheritanceChild && inheritanceChild.InheritanceContext == this)
                             {
                                 inheritanceChild.OnInheritanceContextChanged(args);
                             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyProperty.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyProperty.cs
index 70ed1cdc..ecc050bc 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyProperty.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyProperty.cs
@@ -422,14 +422,11 @@ internal void ValidateFactoryDefaultValue(object defaultValue)
 
                 DispatcherObject dispatcherObject = defaultValue as DispatcherObject;
 
-                if (dispatcherObject != null && dispatcherObject.Dispatcher != null)
+                if (dispatcherObject?.Dispatcher != null)
                 {
-                    // Try to make the DispatcherObject free-threaded if it's an
-                    // ISealable.
+                    // Try to make the DispatcherObject free-threaded if it's an                    // ISealable.
 
-                    ISealable valueAsISealable = dispatcherObject as ISealable;
-
-                    if (valueAsISealable != null && valueAsISealable.CanSeal)
+                    if (dispatcherObject is ISealable valueAsISealable && valueAsISealable.CanSeal)
                     {
                         Invariant.Assert (!valueAsISealable.IsSealed,
                                "A Sealed ISealable must not have dispatcher affinity");
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyPropertyValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyPropertyValueSerializer.cs
index 0279ec06..c1440c2b 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyPropertyValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/DependencyPropertyValueSerializer.cs
@@ -30,8 +30,7 @@ public override bool CanConvertFromString(string value, IValueSerializerContext
 
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            DependencyProperty property = value as DependencyProperty;
-            if (property != null)
+            if (value is DependencyProperty property)
             {
                 ValueSerializer typeSerializer = ValueSerializer.GetSerializerFor(typeof(Type), context);
                 if (typeSerializer != null)
@@ -45,8 +44,7 @@ public override string ConvertToString(object value, IValueSerializerContext con
 
         public override IEnumerable<Type> TypeReferences(object value, IValueSerializerContext context)
         {
-            DependencyProperty property = value as DependencyProperty;
-            if (property != null)
+            if (value is DependencyProperty property)
             {
                 return new Type[] { property.OwnerType };
             }
@@ -65,8 +63,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
                 if (dotIndex >= 0)
                 {
                     string typeName = value.Substring(0, dotIndex - 1);
-                    Type ownerType = typeSerializer.ConvertFromString(typeName, context) as Type;
-                    if (ownerType != null)
+
+                    if (typeSerializer.ConvertFromString(typeName, context) is Type ownerType)
                     {
                         return DependencyProperty.FromName(typeName, ownerType);
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Freezable.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Freezable.cs
index 7075f82b..ee21130f 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Freezable.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Freezable.cs
@@ -561,10 +561,7 @@ private void GetChangeHandlersAndInvalidateSubProperties(ref EventStorage called
                 DependencyObject context = SingletonContext;
 
                 contextAsFreezable = context as Freezable;
-                if (contextAsFreezable != null)
-                {
-                    contextAsFreezable.GetChangeHandlersAndInvalidateSubProperties(ref calledHandlers);
-                }
+                contextAsFreezable?.GetChangeHandlersAndInvalidateSubProperties(ref calledHandlers);
 
                 if (SingletonContextProperty != null)
                 {
@@ -590,10 +587,7 @@ private void GetChangeHandlersAndInvalidateSubProperties(ref EventStorage called
                         if (currentDO != lastDO)
                         {
                             contextAsFreezable = currentDO as Freezable;
-                            if (contextAsFreezable != null)
-                            {
-                                contextAsFreezable.GetChangeHandlersAndInvalidateSubProperties(ref calledHandlers);
-                            }
+                            contextAsFreezable?.GetChangeHandlersAndInvalidateSubProperties(ref calledHandlers);
 
                             lastDO = currentDO;
                         }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/Int32RectConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/Int32RectConverter.cs
index 5235f1f3..da8dc5d9 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/Int32RectConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/Int32RectConverter.cs
@@ -88,9 +88,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Int32Rect.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/PointConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/PointConverter.cs
index 68273b2f..e9b96ffc 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/PointConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/PointConverter.cs
@@ -88,9 +88,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Point.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/RectConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/RectConverter.cs
index b9888a29..146e9fb0 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/RectConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/RectConverter.cs
@@ -88,9 +88,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Rect.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/SizeConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/SizeConverter.cs
index 0c471b3a..d8ec7e23 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/SizeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/SizeConverter.cs
@@ -88,9 +88,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Size.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/VectorConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/VectorConverter.cs
index 6e5e8e08..33d86d85 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/VectorConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/VectorConverter.cs
@@ -88,9 +88,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Vector.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/KeyConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/KeyConverter.cs
index bf57e69e..e2801031 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/KeyConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/KeyConverter.cs
@@ -64,7 +64,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for known type
-                if (context != null && context.Instance != null)
+                if (context?.Instance != null)
                 {
                     Key key = (Key)context.Instance;
                     return ((int)key >= (int)Key.None && (int)key <= (int)Key.DeadCharProcessed);
@@ -83,9 +83,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         /// <ExternalAPI/> 
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source)
         {
-            if (source is string)
+            if (source is string s)
             {
-                string fullName = ((string)source).Trim();
+                string fullName = s.Trim();
                 object key = GetKey(fullName, CultureInfo.InvariantCulture);
                 if (key != null)
                 {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/ModifierKeysConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/ModifierKeysConverter.cs
index 7ab29dcd..7e97084a 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/ModifierKeysConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Input/ModifierKeysConverter.cs
@@ -65,7 +65,7 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
             if (destinationType == typeof(string))
             {
                 // When invoked by the serialization engine we can convert to string only for known type
-                if (context != null && context.Instance != null && 
+                if (context?.Instance != null && 
 					context.Instance is ModifierKeys)
                 {
                     return (IsDefinedModifierKeys((ModifierKeys)context.Instance));
@@ -84,9 +84,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
         /// <ExternalAPI/> 
         public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source)
         {
-            if (source is string)
+            if (source is string s)
             {
-                string modifiersToken = ((string)source).Trim();
+                string modifiersToken = s.Trim();
                 ModifierKeys modifiers = GetModifierKeys(modifiersToken, CultureInfo.InvariantCulture);
                 return modifiers;
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/LocalValueEnumerator.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/LocalValueEnumerator.cs
index 59962f6b..9d74314c 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/LocalValueEnumerator.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/LocalValueEnumerator.cs
@@ -34,10 +34,8 @@ public override int GetHashCode()
         /// </summary>
         public override bool Equals(object obj)
         {
-            if(obj is LocalValueEnumerator)
+            if(obj is LocalValueEnumerator other)
             {
-                LocalValueEnumerator other = (LocalValueEnumerator) obj;
-
                 return (_count == other._count &&
                         _index == other._index &&
                         _snapshot == other._snapshot);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Markup/TypeTypeConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Markup/TypeTypeConverter.cs
index d0c9ff56..6ae86edf 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Markup/TypeTypeConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Markup/TypeTypeConverter.cs
@@ -24,9 +24,7 @@ public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceT
 
         public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
         {
-            string typeName = value as string;
-
-            if (null != context && typeName != null)
+            if (null != context && value is string typeName)
             {
                 IXamlTypeResolver xamlTypeResolver = (IXamlTypeResolver)context.GetService(typeof(IXamlTypeResolver));
 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Converters/Generated/MatrixValueSerializer.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Converters/Generated/MatrixValueSerializer.cs
index c59f3f95..b97afdf8 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Converters/Generated/MatrixValueSerializer.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Converters/Generated/MatrixValueSerializer.cs
@@ -76,10 +76,8 @@ public override object ConvertFromString(string value, IValueSerializerContext c
         /// </summary>
         public override string ConvertToString(object value, IValueSerializerContext context)
         {
-            if (value is Matrix)
+            if (value is Matrix instance)
             {
-                Matrix instance = (Matrix) value;
-
 
                 #pragma warning suppress 6506 // instance is obviously not null
                 return instance.ConvertToString(null, System.Windows.Markup.TypeConverterHelper.InvariantEnglishUS);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Generated/MatrixConverter.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Generated/MatrixConverter.cs
index 35e54946..1dd004fd 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Generated/MatrixConverter.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Media/Generated/MatrixConverter.cs
@@ -89,9 +89,7 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
                 throw GetConvertFromException(value);
             }
 
-            String source = value as string;
-
-            if (source != null)
+            if (value is string source)
             {
                 return Matrix.Parse(source);
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/NameScope.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/NameScope.cs
index b34a7ff4..33cc1a25 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/NameScope.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/NameScope.cs
@@ -133,8 +133,7 @@ internal static INameScope NameScopeFromObject(object obj)
             INameScope nameScope = obj as INameScope;
             if (nameScope == null)
             {
-                DependencyObject objAsDO = obj as DependencyObject;
-                if (objAsDO != null)
+                if (obj is DependencyObject objAsDO)
                 {
                     nameScope = GetNameScope(objAsDO);
                 }
@@ -452,10 +451,7 @@ object IEnumerator.Current
 
             void IEnumerator.Reset()
             {
-                if (_enumerator != null)
-                {
-                    _enumerator.Reset();
-                }
+                _enumerator?.Reset();
             }
         }
         #endregion
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/PropertyMetadata.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/PropertyMetadata.cs
index 8c8458e3..813bbda0 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/PropertyMetadata.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/PropertyMetadata.cs
@@ -261,12 +261,7 @@ internal static void PromoteAllCachedDefaultValues(DependencyObject owner)
         {
             FrugalMapBase map = _defaultValueFactoryCache.GetValue(owner);
 
-            if (map != null)
-            {
-                // Iterate through all the items in the map (each representing a DP)
-                // and promote them to locally-set.
-                map.Iterate(null, _promotionCallback);
-            }
+            map?.Iterate(null, _promotionCallback);
         }
 
         /// <summary>
@@ -302,9 +297,7 @@ internal static void RemoveAllCachedDefaultValues(Freezable owner)
         /// <param name="value">The cached default</param>
         private static void DefaultValueCacheRemovalCallback(ArrayList list, int key, object value)
         {
-            Freezable cachedDefault = value as Freezable;
-
-            if (cachedDefault != null)
+            if (value is Freezable cachedDefault)
             {
                 // Freeze fires the Changed event so we need to clear off the handlers before
                 // calling it.  Otherwise the promoter would run and attempt to set the
@@ -327,11 +320,7 @@ private static void DefaultValueCachePromotionCallback(ArrayList list, int key,
         {
             Freezable cachedDefault = value as Freezable;
 
-            if (cachedDefault != null)
-            {
-                // The only way to promote a cached default is to fire its Changed event.
-                cachedDefault.FireChanged();
-            }
+            cachedDefault?.FireChanged();
         }
 
 
@@ -472,9 +461,7 @@ internal FreezeValueCallback FreezeValueCallback
 
                 if (value != null)
                 {
-                    Freezable valueAsFreezable = value as Freezable;
-
-                    if (valueAsFreezable != null)
+                    if (value is Freezable valueAsFreezable)
                     {
                         if (!valueAsFreezable.Freeze(isChecking))
                         {
@@ -493,9 +480,8 @@ internal FreezeValueCallback FreezeValueCallback
                     }
                     else  // not a Freezable
                     {
-                        DispatcherObject valueAsDispatcherObject = value as DispatcherObject;
 
-                        if (valueAsDispatcherObject != null)
+                        if (value is DispatcherObject valueAsDispatcherObject)
                         {
                             if (valueAsDispatcherObject.Dispatcher == null)
                             {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/SplashScreen.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/SplashScreen.cs
index abbf7e8f..7435ee65 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/SplashScreen.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/SplashScreen.cs
@@ -312,10 +312,7 @@ private void DestroyResources()
                 }
                 _wndClass = 0;
             }
-            if (_resourceManager != null)
-            {
-                _resourceManager.ReleaseAllResources();
-            }
+            _resourceManager?.ReleaseAllResources();
         }
 
         private bool CreateLayeredWindowFromImgBuffer(IntPtr pImgBuffer, long cImgBufferLen, bool topMost)
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/Dispatcher.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/Dispatcher.cs
index f87a32de..cf2d215a 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/Dispatcher.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/Dispatcher.cs
@@ -110,8 +110,7 @@ public static Dispatcher FromThread(Thread thread)
                         // being updated if we encounter a dead weak reference.
                         for(int i = 0; i < _dispatchers.Count; i++)
                         {
-                            Dispatcher d = _dispatchers[i].Target as Dispatcher;
-                            if(d != null)
+                            if(_dispatchers[i].Target is Dispatcher d)
                             {
                                 // Note: we compare the thread objects themselves to protect
                                 // against threads reusing old thread IDs.
@@ -981,10 +980,7 @@ private void InvokeAsyncImpl(DispatcherOperation operation, CancellationToken ca
                     operation.Completed += (s,e) => cancellationRegistration.Dispose();
                 }
 
-                if(hooks != null)
-                {
-                    hooks.RaiseOperationPosted(this, operation);
-                }
+                hooks?.RaiseOperationPosted(this, operation);
 
                 if (EventTrace.IsEnabled(EventTrace.Keyword.KeywordDispatcher | EventTrace.Keyword.KeywordPerf, EventTrace.Level.Info))
                 {
@@ -1421,10 +1417,7 @@ private object InvokeImpl(DispatcherOperation operation, CancellationToken cance
                 finally
                 {
                     ctTimeoutRegistration.Dispose();
-                    if (ctsTimeout != null)
-                    {
-                        ctsTimeout.Dispose();
-                    }
+                    ctsTimeout?.Dispose();
                 }
             }
 
@@ -1926,10 +1919,7 @@ private void ShutdownImplInSecurityContext(Object state)
                     }
                 }
 
-                if(operation != null)
-                {
-                    operation.Abort();
-                }
+                operation?.Abort();
             } while(operation != null);
 
             // clear out the fields that could be holding onto large graphs of objects.
@@ -1983,10 +1973,7 @@ private void ShutdownImplInSecurityContext(Object state)
 
             if (notify)
             {
-                if(hooks != null)
-                {
-                    hooks.RaiseOperationPriorityChanged(this, operation);
-                }
+                hooks?.RaiseOperationPriorityChanged(this, operation);
 
                 if (EventTrace.IsEnabled(EventTrace.Keyword.KeywordDispatcher | EventTrace.Keyword.KeywordPerf, EventTrace.Level.Info))
                 {
@@ -2017,10 +2004,7 @@ internal bool Abort(DispatcherOperation operation)
 
             if (notify)
             {
-                if(hooks != null)
-                {
-                    hooks.RaiseOperationAborted(this, operation);
-                }
+                hooks?.RaiseOperationAborted(this, operation);
 
                 if (EventTrace.IsEnabled(EventTrace.Keyword.KeywordDispatcher | EventTrace.Keyword.KeywordPerf, EventTrace.Level.Info))
                 {
@@ -2077,17 +2061,11 @@ private void ProcessQueue()
                     eventlogged = true;
                 }
 
-                if(hooks != null)
-                {
-                    hooks.RaiseOperationStarted(this, op);
-                }
+                hooks?.RaiseOperationStarted(this, op);
 
                 op.Invoke();
 
-                if(hooks != null)
-                {
-                    hooks.RaiseOperationCompleted(this, op);
-                }
+                hooks?.RaiseOperationCompleted(this, op);
 
                 if (eventlogged)
                 {
@@ -2329,10 +2307,7 @@ private IntPtr WndProcHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, r
 
             if (idle)
             {
-                if(hooks != null)
-                {
-                    hooks.RaiseDispatcherInactive(this);
-                }
+                hooks?.RaiseDispatcherInactive(this);
 
                 ComponentDispatcher.RaiseIdle();
             }
@@ -2529,8 +2504,7 @@ private void OnRequestProcessingFailure(string methodName)
             }
 
             // add a new entry to the failure log
-            Tuple<Object, List<String>> tuple = _reservedPtsCache as Tuple<Object, List<String>>;
-            if (tuple != null)
+            if (_reservedPtsCache is Tuple<Object, List<String>> tuple)
             {
                 List<String> list = tuple.Item2;
                 list.Add(String.Format(System.Globalization.CultureInfo.InvariantCulture,
@@ -2617,10 +2591,7 @@ internal void PromoteTimers(int currentTimeInTicks)
                         }
 
                         // Now that we are outside of the lock, promote the timer.
-                        if(timer != null)
-                        {
-                            timer.Promote();
-                        }
+                        timer?.Promote();
                     } while(timer != null);
 }
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherObject.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherObject.cs
index 8af3263f..ddd9a4a0 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherObject.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherObject.cs
@@ -118,10 +118,7 @@ public void VerifyAccess()
 
             // Note: a DispatcherObject that is not associated with a
             // dispatcher is considered to be free-threaded.
-            if(dispatcher != null)
-            {
-                dispatcher.VerifyAccess();
-            }
+            dispatcher?.VerifyAccess();
         }
 
         /// <summary>
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherOperation.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherOperation.cs
index 766a619d..78e6b456 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherOperation.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherOperation.cs
@@ -425,7 +425,7 @@ internal void Invoke()
             EventHandler handler; // either completed or aborted
             lock(DispatcherLock)
             {
-                if(_exception != null && _exception is OperationCanceledException)
+                if(_exception is OperationCanceledException)
                 {
                     // A new way to abort/cancel an operation is to raise an
                     // OperationCanceledException exception.  This only works
@@ -602,10 +602,7 @@ private void Exit()
             {
                 Continue = false;
 
-                if(_waitTimer != null)
-                {
-                    _waitTimer.Dispose();
-                }
+                _waitTimer?.Dispose();
 
                 _operation.Aborted -= new EventHandler(OnCompletedOrAborted);
                 _operation.Completed -= new EventHandler(OnCompletedOrAborted);
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/PriorityRange.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/PriorityRange.cs
index 05b633d2..8f7d7540 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/PriorityRange.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/PriorityRange.cs
@@ -196,9 +196,9 @@ public bool Contains(PriorityRange priorityRange)
         /// </summary>
         public override bool Equals(object o)
         {
-            if(o is PriorityRange)
+            if(o is PriorityRange priorityRange)
             {
-                return Equals((PriorityRange) o);
+                return Equals(priorityRange);
             }
             else
             {
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/WeakEventManager.cs b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/WeakEventManager.cs
index c7efff7e..ad2641ce 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/WeakEventManager.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/WeakEventManager.cs
@@ -793,8 +793,7 @@ internal bool DeliverEvent(ref Listener listener, object sender, EventArgs args,
                     else
                     {
                         // legacy (4.0)
-                        IWeakEventListener iwel = target as IWeakEventListener;
-                        if (iwel != null)
+                        if (target is IWeakEventListener iwel)
                         {
                             bool handled = iwel.ReceiveWeakEvent(managerType, sender, args);
 
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHost.cs b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHost.cs
index a5f56789..acb80b41 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHost.cs
@@ -302,8 +302,7 @@ protected override void OnGotFocus(EventArgs e)
 
         private void InitializeChildProperties()
         {
-            FrameworkElement childFrameworkElement = Child as FrameworkElement;
-            if (childFrameworkElement != null)
+            if (Child is FrameworkElement childFrameworkElement)
             {
                 childFrameworkElement.SizeChanged += new SizeChangedEventHandler(childFrameworkElement_SizeChanged);
                 childFrameworkElement.Height = double.NaN;
@@ -442,10 +441,7 @@ protected override void Select(bool directed, bool forward)
             }
             else
             {
-                if (Child != null)
-                {
-                    Child.Focus();
-                }
+                Child?.Focus();
             }
 
             base.Select(directed, forward);
@@ -852,10 +848,7 @@ protected override void Dispose(bool disposing)
                         SWI.InputManager.Current.PostProcessInput -= InputManager_PostProcessInput;
 
                         IDisposable disposableChild = Child as IDisposable;
-                        if (disposableChild != null)
-                        {
-                            disposableChild.Dispose();
-                        }
+                        disposableChild?.Dispose();
                     }
                 }
             }
@@ -1030,10 +1023,7 @@ private void OnPropertyChangedImeMode(object sender, System.EventArgs e)
         /// <param name="value">the new value of the property</param>
         public virtual void OnPropertyChanged(string propertyName, object value)
         {
-            if (PropertyMap != null)
-            {
-                PropertyMap.OnPropertyChanged(this, propertyName, value);
-            }
+            PropertyMap?.OnPropertyChanged(this, propertyName, value);
         }
 
         /// <summary>
@@ -1667,12 +1657,9 @@ public bool OnNoMoreTabStops(SWI.TraversalRequest request)
 
                 if (!CoreAppContextSwitches.UseNetFx471CompatibleAccessibilityFeatures)
                 {
-                    // DDVSO: 445603. If the top-most parent in this WinForms hierarchy is a WinFormsAdapter,
-                    // that means there may be more WPF controls that can receive focus outside, forward the
-                    // OnNoMoreTabStops call to the adapter's host.
-                    WinFormsAdapter adapter = topMostParent as WinFormsAdapter;
+                    // DDVSO: 445603. If the top-most parent in this WinForms hierarchy is a WinFormsAdapter,                    // that means there may be more WPF controls that can receive focus outside, forward the                    // OnNoMoreTabStops call to the adapter's host.
 
-                    if (adapter != null)
+                    if (topMostParent is WinFormsAdapter adapter)
                     {
                         return adapter.HostKeyboardInputSite?.OnNoMoreTabStops(request) == true;
                     }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHostPropertyMap.cs b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHostPropertyMap.cs
index 6873bba4..50c9ebd3 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHostPropertyMap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/ElementHostPropertyMap.cs
@@ -64,7 +64,7 @@ private static void BackgroundPropertyTranslator(object host, string propertyNam
         [ResourceConsumption(ResourceScope.Machine, ResourceScope.Machine)]
         private static void UpdateBackgroundImage(ElementHost host)
         {
-            if (host != null && host.HostContainerInternal != null)
+            if (host?.HostContainerInternal != null)
             {
                 if (host.BackColorTransparent)
                 {
@@ -158,7 +158,7 @@ private static void FontPropertyTranslator(object host, string propertyName, obj
         private static void ImeModePropertyTranslator(object host, string propertyName, object value)
         {
             ElementHost elementHost = host as ElementHost;
-            if (elementHost != null && elementHost.HwndSource != null)
+            if (elementHost?.HwndSource != null)
             {
                 elementHost.SyncHwndSrcImeStatus();
             }
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/HostUtils.cs b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/HostUtils.cs
index a1e6e48a..02b2faf7 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/HostUtils.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/HostUtils.cs
@@ -93,9 +93,8 @@ internal static Visual GetRootVisual(Visual descendant)
             while (current != null)
             {
                 current = VisualTreeHelper.GetParent(current);
-                Visual visual = current as Visual;
 
-                if (visual != null)
+                if (current is Visual visual)
                 {
                     root = visual;
                 }
@@ -117,8 +116,7 @@ internal static Point TransformToParentPoint(Visual element, Visual ancestor, Po
 
             outPoint = transform.Transform(pointElement);
 
-            FrameworkElement rootElement = ancestor as FrameworkElement;
-            if (rootElement != null)
+            if (ancestor is FrameworkElement rootElement)
             {
                 if (rootElement.LayoutTransform != null)
                 {
@@ -141,8 +139,7 @@ internal static Point TransformToParentPoint(Visual element, Visual ancestor, Po
         /// <returns></returns>
         internal static bool BrushIsSolidOpaque(SWM.Brush c)
         {
-            SWM.SolidColorBrush solid = c as SWM.SolidColorBrush;
-            return solid != null && solid.Color.A == 255;
+            return c is SWM.SolidColorBrush solid && solid.Color.A == 255;
         }
 
         internal static void SetBackgroundImage(WinFormsAdapter adapter, Control child, SD.Bitmap image)
@@ -213,8 +210,7 @@ private static FrameworkElement GetFrameworkElementAncestor(DependencyObject des
             DependencyObject current = descendant;
             while (current != null)
             {
-                FrameworkElement currentElement = current as FrameworkElement;
-                if (currentElement != null) { ancestor = currentElement; }
+                if (current is FrameworkElement currentElement) { ancestor = currentElement; }
 
                 current = VisualTreeHelper.GetParent(current);
             }
@@ -424,8 +420,7 @@ public static FrameworkElement GetCursorSource(DependencyObject currentObject, b
         {
             while (currentObject != null)
             {
-                FrameworkElement currentElement = currentObject as FrameworkElement;
-                if (currentElement != null && (
+                if (currentObject is FrameworkElement currentElement && (
                     currentElement.Cursor != null || 
                         (currentElement.ForceCursor && forceCursorMapped)
                     )
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHost.cs b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHost.cs
index 1d9f4238..2eb31de3 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHost.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHost.cs
@@ -143,8 +143,7 @@ private IntPtr OnWmGetObject(IntPtr wparam, IntPtr lparam)
         {
             IntPtr result = IntPtr.Zero;
 
-            WindowsFormsHostAutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(this) as WindowsFormsHostAutomationPeer;
-            if(peer != null)
+            if(UIElementAutomationPeer.CreatePeerForElement(this) is WindowsFormsHostAutomationPeer peer)
             {
                 // get the element proxy
                 IRawElementProviderSimple el = peer.GetProvider();
@@ -182,10 +181,7 @@ protected virtual Vector ScaleChild(Vector newScale)
         {
             if (newScale != _currentScale)
             {
-                if (Child != null)
-                {
-                    Child.Scale(new System.Drawing.SizeF((float)(newScale.X / _currentScale.X), (float)(newScale.Y / _currentScale.Y)));
-                }
+                Child?.Scale(new System.Drawing.SizeF((float)(newScale.X / _currentScale.X), (float)(newScale.Y / _currentScale.Y)));
             }
             Vector returnScale = newScale;
             returnScale.X = (newScale.X == 0) ? _currentScale.X : newScale.X;
@@ -398,8 +394,7 @@ private static SWM.Brush FindBackgroundParent(SW.DependencyObject dependencyObje
 
             if (backgroundBrush == null)
             {
-                SW.FrameworkElement frameworkElement = dependencyObject as SW.FrameworkElement;
-                if (frameworkElement != null)
+                if (dependencyObject is SW.FrameworkElement frameworkElement)
                 {
                     DependencyObject parentElement = VisualTreeHelper.GetParent(frameworkElement);
                     backgroundBrush = FindBackgroundParent(parentElement);
@@ -487,10 +482,7 @@ protected override HandleRef BuildWindowCore(HandleRef hwndParent)
             // for 4.0 compat, create a Winforms.NativeWindow to swallow exceptions during WndProc
             if (!CoreCompatibilityPreferences.TargetsAtLeast_Desktop_V4_5)
             {
-                if (_dummyNativeWindow != null)
-                {
-                    _dummyNativeWindow.Dispose();
-                }
+                _dummyNativeWindow?.Dispose();
                 _dummyNativeWindow = new DummyNativeWindow(this);
                 _dummyNativeWindow.AssignHandle(hwndParent.Handle);
             }
@@ -514,10 +506,7 @@ protected override void DestroyWindowCore(HandleRef hwnd)
             //This line shouldn't be necessary since the list cleans itself, but it's good to be tidy.
             ApplicationInterop.ThreadWindowsFormsHostList.Remove(this);
 
-            if (HostContainerInternal != null)
-            {
-                HostContainerInternal.Dispose();
-            }
+            HostContainerInternal?.Dispose();
         }
 
         void ApplyAllProperties(object sender, RoutedEventArgs e)
@@ -542,19 +531,13 @@ protected override void Dispose(bool disposing)
                     {
                         try
                         {
-                            if (_dummyNativeWindow != null)
-                            {
-                                _dummyNativeWindow.Dispose();
-                            }
+                            _dummyNativeWindow?.Dispose();
                             _hostContainerInternal.Dispose();
                             this.Loaded -= new RoutedEventHandler(ApplyAllProperties);
                         }
                         finally
                         {
-                            if (Child != null)
-                            {
-                                Child.Dispose();
-                            }
+                            Child?.Dispose();
                         }
                     }
                 }
@@ -710,10 +693,7 @@ protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
             base.OnPropertyChanged(e);
 
             // Invoke method currently set to handle this event
-            if (_propertyMap != null)
-            {
-                _propertyMap.OnPropertyChanged(this, e.Property.Name, e.NewValue);
-            }
+            _propertyMap?.OnPropertyChanged(this, e.Property.Name, e.NewValue);
         }
 
         /// <summary>
@@ -1116,10 +1096,7 @@ private void CallOnParentRightToLeftChanged(Control control)
         {
             MethodInfo methodInfo = typeof(SWF.Control).GetMethod("OnParentRightToLeftChanged", BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] { typeof(EventArgs) }, null);
             Debug.Assert(methodInfo != null, "Couldn't find OnParentRightToLeftChanged method!");
-            if (methodInfo != null)
-            {
-                methodInfo.Invoke(control, new object[] { EventArgs.Empty });
-            }
+            methodInfo?.Invoke(control, new object[]{EventArgs.Empty});
         }
     }
     #endregion WinFormsAdapter
diff --git a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHostPropertyMap.cs b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHostPropertyMap.cs
index 93d24f98..717cf621 100644
--- a/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHostPropertyMap.cs
+++ b/src/Microsoft.DotNet.Wpf/src/WindowsFormsIntegration/System/Windows/Integration/WindowsFormsHostPropertyMap.cs
@@ -113,11 +113,11 @@ private void FlowDirectionPropertyTranslator(object host, string propertyName, o
                     {
                         case SW.FlowDirection.RightToLeft:
                             adapter.RightToLeft = SWF.RightToLeft.Yes;
-                            if (propertyInfo != null) { propertyInfo.SetValue(childControl, true, null); }
+                            propertyInfo?.SetValue(childControl, true, null);
                             break;
                         case SW.FlowDirection.LeftToRight:
                             adapter.RightToLeft = SWF.RightToLeft.No;
-                            if (propertyInfo != null) { propertyInfo.SetValue(childControl, false, null); }
+                            propertyInfo?.SetValue(childControl, false, null);
                             break;
                     }
                 }
@@ -253,9 +253,9 @@ private void PaddingPropertyTranslator(object host, string propertyName, object
             WinFormsAdapter adapter = GetAdapter(host);
             if (adapter != null && childControl != null)
             {
-                if (value is SW.Thickness)
+                if (value is SW.Thickness thickness)
                 {
-                    childControl.Padding = Convert.ToSystemWindowsFormsPadding((SW.Thickness)value);
+                    childControl.Padding = Convert.ToSystemWindowsFormsPadding(thickness);
                 }
             }
         }
@@ -268,7 +268,7 @@ private void VisibilityPropertyTranslator(object host, string propertyName, obje
             if (value is SW.Visibility)
             {
                 WindowsFormsHost windowsFormsHost = host as WindowsFormsHost;
-                if (windowsFormsHost != null && windowsFormsHost.Child != null)
+                if (windowsFormsHost?.Child != null)
                 {
                     //Visible for Visible, not Visible for Hidden/Collapsed
                     windowsFormsHost.Child.Visible = ((SW.Visibility)value == SW.Visibility.Visible);
