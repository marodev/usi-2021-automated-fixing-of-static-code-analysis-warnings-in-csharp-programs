Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: MarkdownMonster
    #1 Path: D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\AddinManager.cs, Line: 593, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\MarkdownMonster\_Classes\Commands\AppCommands.cs, Line: 1270, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\MarkdownMonster\_Classes\Commands\AppCommands.cs, Line: 2246, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\MarkdownMonster\_Classes\Configuration\ApplicationUpdater.cs, Line: 212, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\MarkdownMonster\_Classes\WebSockets\WebServerRequestHandler.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\MarkdownMonster\Controls\ContextMenus\FolderBrowserContextMenu.cs, Line: 621, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\MarkdownMonster\Controls\DropdownButtonBehavior.cs, Line: 26, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #8 Path: D:\a\1\s\MarkdownMonster\Controls\DropdownButtonBehavior.cs, Line: 51, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #9 Path: D:\a\1\s\MarkdownMonster\Controls\ElementHelper.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\MarkdownMonster\Controls\ElementHelper.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\MarkdownMonster\Controls\ElementHelper.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\MarkdownMonster\Controls\ElementHelper.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\MarkdownMonster\Controls\SelectOnEntryExtension.cs, Line: 21, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\MarkdownMonster\Windows\Git\GitCommitDialog.xaml.cs, Line: 248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\MarkdownMonster\Windows\Git\GitCommitDialog.xaml.cs, Line: 252, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\MarkdownMonster\Windows\PreviewBrowser\IEWebBrowserEditorHandler.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: WebLogAddin
    #17 Path: D:\a\1\s\AddIns\WebLogAddin\MetaWebLogApi\helpers\EnumsHelper.cs, Line: 19, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #18 Path: D:\a\1\s\AddIns\WebLogAddin\MetaWebLogApi\MetaWebLogWordpressApiClient.cs, Line: 319, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #19 Path: D:\a\1\s\AddIns\WebLogAddin\WebLogAddin.cs, Line: 500, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: MarkdownMonster.Test
    #20 Path: D:\a\1\s\Tests\MarkdownMonster.Test\GitIntegrationTests.cs, Line: 104, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: SnippetsAddin
    #21 Path: D:\a\1\s\AddIns\Snippets-MarkdownMonster-Addin\SnippetsAddin\SnippetsWindow.xaml.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\AddIns\Snippets-MarkdownMonster-Addin\SnippetsAddin\SnippetsWindow.xaml.cs, Line: 185, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



--- Rules Summary ---
R8: 16
R5: 2
R2: 1
R7: 1
R9: 1
R6: 1

--- Summary ---
Fixed ReSharper issues: 21
Fixed SonarQube issues: 3
Total fixed issues: 22

Finished in: 17 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Threading;
using Dragablz;
using FontAwesome.WPF;
using LibGit2Sharp;
using MahApps.Metro.Controls;
using MahApps.Metro.Controls.Dialogs;
using MarkdownMonster._Classes;
using MarkdownMonster.AddIns;
using MarkdownMonster.Annotations;
using MarkdownMonster.Controls.ContextMenus;
using MarkdownMonster.Services;
using MarkdownMonster.Utilities;
using MarkdownMonster.Windows;
using MarkdownMonster.Windows.PreviewBrowser;
using Westwind.Utilities;
using Binding = System.Windows.Data.Binding;
using Brushes = System.Windows.Media.Brushes;
using Button = System.Windows.Controls.Button;
using Color = System.Windows.Media.Color;
using ContextMenu = System.Windows.Controls.ContextMenu;
using DataFormats = System.Windows.DataFormats;
using DataObject = System.Windows.DataObject;
using DragDropEffects = System.Windows.DragDropEffects;
using DragEventArgs = System.Windows.DragEventArgs;
using HorizontalAlignment = System.Windows.HorizontalAlignment;
using Image = System.Windows.Controls.Image;
using MenuItem = System.Windows.Controls.MenuItem;
using MessageBox = System.Windows.MessageBox;
using MouseEventArgs = System.Windows.Input.MouseEventArgs;
using OpenFileDialog = Microsoft.Win32.OpenFileDialog;
using Orientation = System.Windows.Controls.Orientation;
using ToolBar = System.Windows.Controls.ToolBar;

namespace MarkdownMonster
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : MetroWindow
        //, IPreviewBrowser
    {
        public AppModel Model { get; set; }

        public NamedPipeManager PipeManager { get; set; }

        public IntPtr Hwnd
        {
            get
            {
                if (_hwnd == IntPtr.Zero)
                    _hwnd = new WindowInteropHelper(this).EnsureHandle();

                return _hwnd;
            }
        }

        private IntPtr _hwnd = IntPtr.Zero;

        private DateTime _invoked = DateTime.MinValue;


        /// <summary>
        /// Manages the Preview Rendering in a WebBrowser Control
        /// </summary>
        public IPreviewBrowser PreviewBrowser { get; set; }

        public PreviewBrowserWindow PreviewBrowserWindow
        {
            set { _previewBrowserWindow = value; }
            get
            {
                if (_previewBrowserWindow == null || _previewBrowserWindow.IsClosed)
                {
                    _previewBrowserWindow = new PreviewBrowserWindow();
                    if (Model.Configuration.WindowPosition.PreviewDisplayMode ==
                        PreviewWindowDisplayModes.ActivatedByMainWindow)
                        _previewBrowserWindow.Owner = this;

                }

                return _previewBrowserWindow;
            }
        }

        private PreviewBrowserWindow _previewBrowserWindow;


        /// <summary>
        /// The Preview Browser Container Grid that contains the
        /// Web Browser control that handles the Document tied
        /// preview.
        /// </summary>
        public Grid PreviewBrowserContainer { get; set; }


        /// <summary>
        /// The Preview Browser Tab if active that is used
        /// for image and URL previews (ie. the Preview
        /// without an associated editor)
        /// </summary>
        public TabItem PreviewTab { get; set; }

        public TabItem FavoritesTab { get; set; }

        public TabItem SearchTab { get; set; }

        public TabItem LintingErrorTab { get; set; }


        private IEWebBrowserControl previewBrowser;

        /// <summary>
        /// Display Statusbar messages easily with pre-configuraed helper  methods
        /// </summary>
        StatusBarHelper StatusBarHelper { get; }

        /// <summary>
        /// Keybindings for the window and editor.
        /// </summary>
        public KeyBindingsManager KeyBindings { get; set; }



        public MainWindow()
        {
            // Initially don't show an icon until we have loaded
            // the form in the right location (in Activate -> Onload after FixMonitorPosition)
            ShowInTaskbar = false;

            InitializeComponent();

            Model = new AppModel(this);
            AddinManager.Current.RaiseOnModelLoaded(Model);

            // This doesn't fire when first started, but fires when
            // addins are added at from the Addin Manager at runtie
            AddinManager.Current.AddinsLoaded = OnAddinsLoaded;

            Model.WindowLayout = new MainWindowLayoutModel(this);

            DataContext = Model;

            TabControl.ClosingItemCallback = TabControlDragablz_TabItemClosing;




            Loaded += OnLoaded;
            Drop += MainWindow_Drop;
            AllowDrop = true;
            Activated += OnActivated;
            StateChanged += MainWindow_StateChanged;


            // Singleton App startup - server code that listens for other instances
            if (mmApp.Configuration.UseSingleWindow && !App.ForceNewWindow)
            {
                // Listen for other instances launching and pick up
                // forwarded command line arguments
                PipeManager = new NamedPipeManager("MarkdownMonster");
                PipeManager.StartServer();
                PipeManager.ReceiveString += HandleNamedPipe_OpenRequest;
            }

            // Override some of the theme defaults (dark header specifically)
            mmApp.SetThemeWindowOverride(this, isMainWindow: true);

            StatusBarHelper = new StatusBarHelper(StatusText, StatusIcon);
        }




        #region Opening and Closing

        private void OnLoaded(object sender, RoutedEventArgs e)
        {

            // Load either default preview browser or addin-overridden browser
            LoadPreviewBrowser();

            RestoreSettings();

            var opener = new CommandLineOpener(this);
            opener.OpenFilesFromCommandLine();

            CheckForFirstRun();

            BindTabHeaders();
            SetWindowTitle();

            var left = Left;
            Left = 300000;

            Model.IsPresentationMode = App.StartInPresentationMode;
            if (!Model.IsPresentationMode)
                Model.IsPresentationMode = mmApp.Configuration.OpenInPresentationMode;

            // run out of band
            Dispatcher.InvokeAsync(() =>
            {
                Left = left;

                FixMonitorPosition();
                ShowInTaskbar = true;


                if (Model.IsPresentationMode)
                {
                    Dispatcher.InvokeAsync(() => Model.WindowLayout.SetPresentationMode(),
                        DispatcherPriority.ApplicationIdle);
                }

                OpenFavorites(noActivate: true);

                //OpenSearchPane(noActivate: true);
            }, DispatcherPriority.Background);

            // run when app is loaded
            Dispatcher.InvokeAsync(() =>
            {
                try
                {
                    AddinManager.Current.InitializeAddinsUi(this);
                }
                catch (Exception exception)
                {
                    mmApp.Log("Addin UI Loading failed.", exception);
                }

                AddinManager.Current.RaiseOnWindowLoaded();


                // Tab Header double click to open new tab
                var tabHeaderContainer = TabControl.FindChild<Grid>("HeaderContainerGrid");
                tabHeaderContainer.Background = Brushes.Transparent; // REQUIRED OR CLICK NOT FIRING!
                tabHeaderContainer.MouseLeftButtonDown += TabHeader_DoubleClick;

                var config = Model.Configuration;

                // Start the built-in localhost Web Server if marked for AutoStart
                if (config.WebServer.AutoStart)
                    WebServerLauncher.StartMarkdownMonsterWebServer();

            }, DispatcherPriority.ApplicationIdle);

            // TODO: Check to see why this fails in async block above ^^^
            // this fails to load asynchronously so do it here
            KeyBindings = new MarkdownMonsterKeybindings(this);
            if (!File.Exists(KeyBindings.KeyBindingsFilename))
                KeyBindings.SaveKeyBindings();
            else
            {
                KeyBindings.LoadKeyBindings();
                // always write back out
                Task.Run(() => KeyBindings.SaveKeyBindings());
            }
            KeyBindings.SetKeyBindings();

        }

        /// <summary>
        /// Capture WindowState and 'old' size for maximized windows
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MainWindow_StateChanged(object sender, EventArgs e)
        {
            if (WindowState == WindowState.Maximized)
            {
                // capture window size before maximizing
                Model.Configuration.WindowPosition.WindowState = WindowState.Maximized;
                Model.Configuration.WindowPosition.Top = (int) Top;
                Model.Configuration.WindowPosition.Left = (int) Left;
                Model.Configuration.WindowPosition.Width = (int) Width;
                Model.Configuration.WindowPosition.Height = (int) Height;
            }
        }

        void CheckForFirstRun()
        {
            if (mmApp.Configuration.ApplicationUpdates.FirstRun)
            {
                var rect = WindowUtilities.GetScreenDimensions(this);
                var ratio = WindowUtilities.GetDpiRatio(this);
                rect.Width = Convert.ToInt32(Convert.ToDecimal(rect.Width) / ratio);
                rect.Height = Convert.ToInt32(Convert.ToDecimal(rect.Height) / ratio);

                Width = rect.Width - 60;
                if (Width > 1600)
                    Width = 1600;
                Left = 30;
                Model.Configuration.WindowPosition.InternalPreviewWidth = (int) (Convert.ToInt32(Width) * 0.45);

                Height = rect.Height - 75; // account for statusbar
                if (Height > 1100)
                    Height = 1100;
                Top = 10;

                if (TabControl.Items.Count == 0)
                {
                    try
                    {
                        string tempFile = Path.Combine(Path.GetTempPath(), "SampleMarkdown.md");
                        File.Copy(Path.Combine(App.InitialStartDirectory, "SampleMarkdown.md"), tempFile, true);
                        OpenTab(tempFile);
                    }
                    catch (Exception ex)
                    {
                        mmApp.Log("Handled: Unable to copy file to temp folder.", ex);
                    }
                }

                mmApp.Configuration.ApplicationUpdates.FirstRun = false;
            }
        }


        /// <summary>
        /// This is called only if addin loading takes very long
        /// Potentially fired off
        /// </summary>
        public void OnAddinsLoaded()
        {
            // Check to see if we are using another preview browser and load
            // that instead
            Dispatcher.InvokeAsync(() => { LoadPreviewBrowser(); }, DispatcherPriority.ApplicationIdle);
        }


        protected override void OnContentRendered(EventArgs e)
        {
            base.OnContentRendered(e);
        }


        /// <summary>
        /// Keep track whether the editor is focused on deactivation
        /// </summary>
        bool _saveIsEditorFocused = true;

        protected override void OnDeactivated(EventArgs e)
        {
            var editor = Model.ActiveEditor;
            if (editor == null) return;

            var doc = Model.ActiveDocument;
            if (doc == null) return;

            doc.IsActive = true;

            _saveIsEditorFocused = Model.IsEditorFocused;

            doc.LastEditorLineNumber = editor.GetLineNumber();
            if (doc.LastEditorLineNumber == -1)
                doc.LastEditorLineNumber = 0;

            base.OnDeactivated(e);

            mmApp.SetWorkingSet(10000000, 5000000);
        }

        protected void OnActivated(object sender, EventArgs e)
        {
            // Active Menu Item deactivation don't refocus
            if (MainMenu.Items.OfType<MenuItem>().Any(item => item.IsHighlighted))
                return;

            if (_saveIsEditorFocused && Model.ActiveEditor != null)
            {
                try
                {
                    Model.ActiveEditor.SetEditorFocus();
                    Model.ActiveEditor.RestyleEditor();
                }
                catch
                {
                    // ignore interop errors
                }
            }
        }


        public bool ForceClose = false;

        protected override void OnClosing(CancelEventArgs e)
        {
            // force method to abort - we'll force a close explicitly
            e.Cancel = true;

            if (ForceClose)
            {
                // cleanup code already ran
                e.Cancel = false;
                return;
            }

            // execute shutdown logic - set ForceClose and call Close() to
            // actually close the window
            Dispatcher.InvokeAsync(ShutdownApplication, DispatcherPriority.Normal);
        }

        private void ShutdownApplication()
        {
            try
            {
                // have to do this here to capture open windows etc. in SaveSettings()
                mmApp.Configuration.ApplicationUpdates.AccessCount++;
                _previewBrowserWindow?.Close();
                _previewBrowserWindow = null;
                PreviewBrowser = null;
                PreviewBrowserContainer = null;
                SaveSettings();

                if (!CloseAllTabs())
                {
                    // tab closing was cancelled
                    mmApp.Configuration.ApplicationUpdates.AccessCount--;
                    return;
                }

                // hide the window quickly
                Top -= 10000;


                FolderBrowser?.ReleaseFileWatcher();
                bool isNewVersion = ApplicationUpdater.CheckForNewVersion(false, false);

                var displayCount = 6;
                if (mmApp.Configuration.ApplicationUpdates.AccessCount > 250)
                    displayCount = 1;
                else if (mmApp.Configuration.ApplicationUpdates.AccessCount > 100)
                    displayCount = 2;
                else if (mmApp.Configuration.ApplicationUpdates.AccessCount > 50)
                    displayCount = 5;

                if (!isNewVersion && mmApp.Configuration.ApplicationUpdates.AccessCount % displayCount == 0 &&
                    !UnlockKey.IsAppRegistered())
                {
                    // bring the window back
                    Top += 10000;
                    Opacity = 0;

                    var rd = new RegisterDialog(true);
                    rd.Owner = this;
                    rd.ShowDialog();
                }

                PipeManager?.StopServer();
                WebServer?.StopServer();


                AddinManager.Current.RaiseOnApplicationShutdown();
                AddinManager.Current.UnloadAddins();

                App.Mutex?.Dispose();

                PipeManager?.WaitForThreadShutDown(5000);
                mmApp.Shutdown();

                ForceClose = true;
                Close();
            }
            catch (Exception ex)
            {
                mmApp.Log("Shutdown: " + ex.Message, ex, logLevel: LogLevels.Error);
                ForceClose = true;
                Close();
            }
        }

        public void AddRecentFile(string file, bool noConfigWrite = false)
        {
            Dispatcher.InvokeAsync(() =>
            {
                mmApp.Configuration.AddRecentFile(file);

                if (!noConfigWrite)
                    mmApp.Configuration.Write();

                try
                {
                    MostRecentlyUsedList.AddToRecentlyUsedDocs(Path.GetFullPath(file));
                }
                catch
                {
                }
            }, DispatcherPriority.ApplicationIdle);
        }


        /// <summary>
        /// Adds a fontawesome icon to the editor toolbar (or any toolbar you specify explicitly).
        /// Specify the FontAwesome Icon image name (FontAwesome.Wpf proper Case Syntax) 
        /// </summary>
        /// <param name="iconName">FontAwesome.WPF Icon name (proper case name)</param>
        /// <param name="markdownActionCommand">string action from MarkupMarkdow() implementation or wrap with `html|tag`</param>
        /// <param name="toolbar"></param>
        /// <param name="command"></param>
        public void AddEditToolbarIcon(string iconName, string markdownActionCommand, ToolBar toolbar = null,
            ICommand command = null)
        {
            ImageSource icon = null;
            if (FontAwesomeIcon.TryParse(iconName, out FontAwesomeIcon iconId))
            {
                icon = ImageAwesome.CreateImageSource(iconId, ToolbarEdit.Foreground);
            }
            AddEditToolbarIcon(icon, markdownActionCommand, toolbar, command);
        }


        /// <summary>
        /// Adds an image icon to the editor toolbar 
        /// </summary>
        /// <param name="icon">An image source icon - should size well for 16px high</param>
        /// <param name="markdownActionCommand">string action from MarkupMarkdow() implementation or wrap with `html|tag`</param>
        /// <param name="toolbar"></param>
        /// <param name="command"></param>
        public void AddEditToolbarIcon(ImageSource icon, string markdownActionCommand, ToolBar toolbar = null,
            ICommand command = null)
        {
            if (toolbar == null) toolbar = ToolbarEdit;
            if (command == null) command = Model.Commands.ToolbarInsertMarkdownCommand;

            var tb = new Button() { Command = command, CommandParameter = markdownActionCommand };
            if (icon == null)
                icon = ImageAwesome.CreateImageSource(FontAwesomeIcon.QuestionCircle, ToolbarEdit.Foreground);

            tb.Content = new Image()
            {
                Source = icon,
                Height = 16,
                Margin = new Thickness(5, 0, 5, 0),
                ToolTip = markdownActionCommand
            };

            var idx = toolbar.Items.IndexOf(ButtonEmoji);
            if (idx > -1)
                toolbar.Items.Insert(idx + 1, tb);
            else
                toolbar.Items.Add(tb);

        }

        private TabItem OpenRecentDocuments()
        {
            ApplicationConfiguration conf = Model.Configuration;
            TabItem selectedTab = null;

            // prevent TabSelectionChanged to fire
            batchTabAction = true;

            // since docs are inserted at the beginning we need to go in reverse
            foreach (var doc in conf.OpenDocuments.Take(mmApp.Configuration.RememberLastDocumentsLength)) //.Reverse();
            {
                if (doc.Filename == null)
                    continue;

                if (File.Exists(doc.Filename))
                {
                    var tab = OpenTab(doc.Filename, selectTab: false,
                        batchOpen: true,
                        initialLineNumber: doc.LastEditorLineNumber);

                    if (tab == null)
                        continue;

                    var editor = tab.Tag as MarkdownDocumentEditor;
                    if (editor == null)
                        continue;

                    if (doc.IsActive)
                    {
                        selectedTab = tab;

                        // have to explicitly notify initial activation
                        // since we surpress it on all tabs during startup

                        AddinManager.Current.RaiseOnDocumentActivated(editor.MarkdownDocument);
                    }
                }
            }

            batchTabAction = false;

            return selectedTab;
        }


        void RestoreSettings()
        {
            var conf = mmApp.Configuration;

            if (conf.WindowPosition.Width != 0)
            {
                Left = conf.WindowPosition.Left;
                Top = conf.WindowPosition.Top;
                Width = conf.WindowPosition.Width;
                Height = conf.WindowPosition.Height;
                WindowUtilities.EnsureWindowIsVisible(this);
            }

            if (conf.WindowPosition.WindowState == WindowState.Maximized)
                Dispatcher.InvokeAsync(() => WindowState = WindowState.Maximized, DispatcherPriority.ApplicationIdle);


            if (mmApp.Configuration.RememberLastDocumentsLength > 0 && mmApp.Configuration.UseSingleWindow)
            {
                //var selectedDoc = conf.RecentDocuments.FirstOrDefault();
                TabItem selectedTab = null;

                string firstDoc = conf.RecentDocuments.FirstOrDefault();


                if (!App.ForceNewWindow)
                    selectedTab = OpenRecentDocuments();

                TabControl.SelectedIndex = -1;
                TabControl.SelectedItem = null;
                if (selectedTab == null)
                    TabControl.SelectedIndex = 0;
                else
                    TabControl.SelectedItem = selectedTab;

                BindTabHeaders();
            }

            Model.IsPreviewBrowserVisible = mmApp.Configuration.IsPreviewVisible;

            ShowFolderBrowser(!mmApp.Configuration.FolderBrowser.Visible);

            // force background so we have a little more contrast
            if (mmApp.Configuration.ApplicationTheme == Themes.Light)
            {
                ContentGrid.Background = (SolidColorBrush) new BrushConverter().ConvertFromString("#eee");
                ToolbarPanelMain.Background = (SolidColorBrush) new BrushConverter().ConvertFromString("#D5DAE8");
            }
            else
                ContentGrid.Background = (SolidColorBrush) new BrushConverter().ConvertFromString("#333");


            //Button Name = "ButtonLink" Margin = "7,0" ToolTip = "Insert link (Ctrl+K)"
            //Command = "{Binding Commands.ToolbarInsertMarkdownCommand }"
            //CommandParameter = "href"
            //fa: Awesome.Content = "ExternalLink"


            //TextElement.FontFamily = "pack://application:,,,/FontAwesome.WPF;component/#FontAwesome"
            //                         />
            foreach (var buttonItem in Model.Configuration.Editor.AdditionalToolbarIcons)
            {
                AddEditToolbarIcon(buttonItem.Key, buttonItem.Value);
            }

        }

        /// <summary>
        /// Save active settings of the UI that are persisted in the configuration
        /// </summary>
        public void SaveSettings()
        {
            var config = mmApp.Configuration;

            if (Model != null)
                config.IsPreviewVisible = Model.IsPreviewBrowserVisible;
            config.WindowPosition.IsTabHeaderPanelVisible = true;

            if (WindowState == WindowState.Normal)
            {
                config.WindowPosition.Left = mmFileUtils.TryConvertToInt32(Left);
                config.WindowPosition.Top = mmFileUtils.TryConvertToInt32(Top);
                config.WindowPosition.Width = mmFileUtils.TryConvertToInt32(Width, 900);
                config.WindowPosition.Height = mmFileUtils.TryConvertToInt32(Height, 700);
            }

            if (WindowState != WindowState.Minimized)
                config.WindowPosition.WindowState = WindowState;


            if (LeftSidebarColumn.Width.Value > 20)
            {
                if (LeftSidebarColumn.Width.IsAbsolute)
                    config.FolderBrowser.WindowWidth =
                        mmFileUtils.TryConvertToInt32(LeftSidebarColumn.Width.Value, 220);
                config.FolderBrowser.Visible = true;
            }
            else
                config.FolderBrowser.Visible = false;

            config.FolderBrowser.FolderPath = FolderBrowser.FolderPath;


            if (!App.ForceNewWindow)
                SaveOpenDocuments();
            else
            {
                // only save if no other instances are open
                if (!Process.GetProcesses()
                    .Any(p => p.ProcessName.Equals("markdownmonster", StringComparison.InvariantCultureIgnoreCase)))
                    SaveOpenDocuments();
            }

            config.Write();
        }


        /// <summary>
        /// Keeps track of the open documents based on the tabs
        /// that are open along with the tab order.
        /// </summary>
        void SaveOpenDocuments()
        {
            var config = Model.Configuration;
            config.OpenDocuments.Clear();
            if (mmApp.Configuration.RememberLastDocumentsLength > 0)
            {
                IEnumerable<DragablzItem> headers = null;
                try
                {
                    var ditems = GetDragablzItems();
                    headers = TabControl.HeaderItemsOrganiser.Sort(ditems);
                }
                catch (Exception ex)
                {
                    mmApp.Log("TabControl.GetOrderedHeaders() failed. Saving unordered.", ex,
                        logLevel: LogLevels.Warning);

                    // This works, but doesn't keep tab order intact
                    headers = new List<DragablzItem>();
                    foreach (var recent in config.RecentDocuments.Take(config.RememberLastDocumentsLength))
                    {
                        var tab = GetTabFromFilename(recent);
                        if (tab != null)
                            ((List<DragablzItem>) headers).Add(new DragablzItem() {Content = tab});
                    }
                }

                if (headers != null)
                {
                    // Important: collect all open tabs in the **original tab order**
                    foreach (var dragablzItem in headers)
                    {
                        if (dragablzItem == null)
                            continue;

                        var tab = dragablzItem.Content as TabItem;

                        var editor = tab.Tag as MarkdownDocumentEditor;
                        var doc = editor?.MarkdownDocument;
                        if (doc == null)
                            continue;

                        doc.LastEditorLineNumber = editor.GetLineNumber();
                        if (doc.LastEditorLineNumber < 1)
                            doc.LastEditorLineNumber = editor.InitialLineNumber; // if document wasn't accessed line is never set
                        if (doc.LastEditorLineNumber < 0)
                            doc.LastEditorLineNumber = 0;

                        config.OpenDocuments.Add(new OpenFileDocument(doc));
                    }
                }

                // now figure out which were recent
                var recents = mmApp.Configuration.RecentDocuments.Take(mmApp.Configuration.RememberLastDocumentsLength)
                    .ToList();

                // remove all those that aren't in the recent list
                var removeList = new List<OpenFileDocument>();
                foreach (var doc in config.OpenDocuments)
                {
                    if (!recents.Any(r => r.Equals(doc.Filename, StringComparison.InvariantCultureIgnoreCase)))
                        removeList.Add(doc);
                }

                foreach (var remove in removeList)
                    config.OpenDocuments.Remove(remove);
            }
        }


        public bool SaveFile(bool secureSave = false)
        {
            var tab = TabControl.SelectedItem as TabItem;
            if (tab == null)
                return false;

            var editor = tab.Tag as MarkdownDocumentEditor;
            var doc = editor?.MarkdownDocument;
            if (doc == null)
                return false;

            // prompt for password on a secure save
            if (secureSave && editor.MarkdownDocument.Password == null)
            {
                var pwdDialog = new FilePasswordDialog(editor.MarkdownDocument, false);
                pwdDialog.ShowDialog();
            }

            if (!editor.SaveDocument())
            {
                //var res = await this.ShowMessageOverlayAsync("Unable to save Document",
                //    "Unable to save document most likely due to missing permissions.");

                MessageBox.Show("Unable to save document most likely due to missing permissions.",
                    mmApp.ApplicationName);
                return false;
            }

            return true;
        }
        #endregion

        #region Remote Activation: Singleton Pipe and Web Server access

        /// <summary>
        /// Internal instance of a local Web Server that can be used to push commands
        /// to Markdown Monster.
        /// </summary>
        public WebServer WebServer = null;
       
      

        private void HandleNamedPipe_OpenRequest(string filesToOpen)
        {
            Dispatcher.Invoke(() =>
            {
                if (!string.IsNullOrEmpty(filesToOpen))
                {
                    var parms = StringUtils.GetLines(filesToOpen.Trim());

                    var opener = new CommandLineOpener(this);
                    opener.OpenFilesFromCommandLine(parms);

                    BindTabHeaders();
                }

                Topmost = true;

                if (WindowState == WindowState.Minimized)
                    WindowState = WindowState.Normal;

                WindowUtilities.SetForegroundWindow(Hwnd);

                Dispatcher.InvokeAsync(() => Topmost = false, DispatcherPriority.ApplicationIdle);
            });
        }

        #endregion

        #region Tab Handling

        /// <summary>
        /// High level wrapper around OpenTab() that checks for
        /// different file types like images and projects that
        /// have non-tab behavior.
        ///
        /// Use this function for generically opening files
        /// by filename .
        /// </summary>
        /// <param name="filename"></param>
        /// <param name="showPreviewIfActive"></param>
        /// <param name="syntax"></param>
        /// <param name="selectTab"></param>
        /// <param name="rebindTabHeaders"></param>
        /// <param name="batchOpen"></param>
        /// <param name="initialLineNumber"></param>
        /// <param name="readOnly"></param>
        /// <param name="noFocus"></param>
        /// <param name="isPreview"></param>
        /// <param name="noShellNavigation">If true last resort editing will open in editor rather than shell execute</param>
        /// <returns>Tab or Null</returns>
        public TabItem OpenFile(string filename,
            MarkdownDocumentEditor editor = null,
            bool showPreviewIfActive = false,
            string syntax = "markdown",
            bool selectTab = true,
            bool rebindTabHeaders = false,
            bool batchOpen = false,
            int initialLineNumber = 0,
            bool readOnly = false,
            bool noFocus = false,
            bool isPreview = false,
            bool noShellNavigation = false)
        {
            if (string.IsNullOrEmpty(filename))
                return null;

            var ext = Path.GetExtension(filename).ToLowerInvariant();
            var fname = Path.GetFileName(filename);

            if (filename.Contains('%'))
            {
                filename = Environment.ExpandEnvironmentVariables(filename);
            }

            if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
            {
                return OpenBrowserTab(filename, isImageFile: true);
            }

            if (ext == ".mdproj")
            {
                Model.Commands.LoadProjectCommand.Execute(filename);
                return null;
            }

            // Executables - don't execute but open in Explorer
            if (StringUtils.Inlist(ext, ".exe", ".ps1", ".bat", ".cmd", ".vbs", ".sh", ".com", ".reg"))
            {
                ShellUtils.OpenFileInExplorer(filename);
                return null;
            }

            string format = "markdown";

            format = mmFileUtils.GetEditorSyntaxFromFileType(filename);

            // Open a Tab for editable formats
            if (!string.IsNullOrEmpty(format) || noShellNavigation)
            {
                if (string.IsNullOrEmpty(format))
                    format = "markdown";

                if (!noFocus && PreviewTab != null)
                    CloseTab(PreviewTab);

                var tab = ActivateTab(filename, false, false, !showPreviewIfActive,
                    !selectTab, noFocus, readOnly, isPreview);
                if (tab != null)
                {
                    if (initialLineNumber > 0)
                    {
                        if (tab.Tag is MarkdownDocumentEditor ed)
                            Dispatcher.InvokeAsync(() => ed.GotoLine(initialLineNumber), DispatcherPriority.ApplicationIdle);
                    }

                    return tab;
                }

                return OpenTab(filename, editor, showPreviewIfActive, syntax,
                    selectTab, rebindTabHeaders, batchOpen,
                    initialLineNumber, readOnly, noFocus, isPreview);
            }

            try
            {
                if (File.Exists(filename))
                    ShellUtils.GoUrl(filename);
                else
                    ShowStatusError($"Can't open file {filename}. File doesn't exist.");
            }
            catch
            {
                ShowStatusError($"Unable to open file {filename}");
            }

            return null;
        }


        ///  <summary>
        ///  Opens a tab by a filename
        ///  </summary>
        ///  <param name="mdFile"></param>
        ///  <param name="editor"></param>
        ///  <param name="showPreviewIfActive"></param>
        ///  <param name="syntax"></param>
        ///  <param name="selectTab"></param>
        ///  <param name="rebindTabHeaders">
        ///  Rebinds the headers which should be done whenever a new Tab is
        ///  manually opened and added but not when opening in batch.
        ///
        ///  Checks to see if multiple tabs have the same filename open and
        ///  if so displays partial path.
        ///
        ///  New Tabs are opened at the front of the tab list at index 0
        ///  </param>
        /// <param name="batchOpen"></param>
        /// <param name="initialLineNumber"></param>
        /// <param name="readOnly"></param>
        /// <param name="noFocus"></param>
        /// <param name="isPreview"></param>
        /// <returns></returns>
        public TabItem OpenTab(string mdFile = null,
            MarkdownDocumentEditor editor = null,
            bool showPreviewIfActive = false,
            string syntax = "markdown",
            bool selectTab = true,
            bool rebindTabHeaders = false,
            bool batchOpen = false,
            int initialLineNumber = 0,
            bool readOnly = false,
            bool noFocus = false,
            bool isPreview = false)
        {
            if (mdFile != null && mdFile != "untitled" &&
                (!File.Exists(mdFile) ||
                 !AddinManager.Current.RaiseOnBeforeOpenDocument(mdFile)))
                return null;

            var tab = new TabItem();
            tab.Background = Background;


            if (mdFile != null)
            {
                var ext = Path.GetExtension(mdFile).ToLowerInvariant();
                if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
                {
                    return OpenBrowserTab(mdFile, isImageFile: true);
                }
            }

            HeaderedControlHelper.SetHeaderFontSize(tab, 13f);
            
            if (editor == null)
            {
                editor = new MarkdownDocumentEditor
                {
                    Window = this,
                    InitialLineNumber = initialLineNumber,
                    IsReadOnly = readOnly,
                    NoInitialFocus = noFocus,
                    IsPreview = isPreview
                };

                tab.Content = editor.EditorPreviewPane;
                tab.Tag = editor;


                // tab is temporary until edited
                if (isPreview)
                {
                    if (PreviewTab != null && PreviewTab != tab)
                        TabControl.Items.Remove(PreviewTab);
                    PreviewTab = tab;
                }

                var doc = new MarkdownDocument() {
                    Filename = mdFile ?? "untitled",
                    EditorSyntax = "markdown",
                    Dispatcher = Dispatcher};
                if (doc.Filename != "untitled")
                {
                    doc.Filename = FileUtils.GetPhysicalPath(doc.Filename);

                    if (doc.HasBackupFile())
                    {
                        try
                        {
                            ShowStatusError("Auto-save recovery files have been found and opened in the editor.");
                            {
                                File.Copy(doc.BackupFilename, doc.BackupFilename + ".md");
                                OpenTab(doc.BackupFilename + ".md");
                                File.Delete(doc.BackupFilename + ".md");
                            }
                        }
                        catch (Exception ex)
                        {
                            string msg = "Unable to open backup file: " + doc.BackupFilename + ".md";
                            mmApp.Log(msg, ex);
                            MessageBox.Show(
                                "A backup file was previously saved, but we're unable to open it.\r\n" + msg,
                                "Cannot open backup file",
                                MessageBoxButton.OK,
                                MessageBoxImage.Warning);
                        }
                    }

                    if (doc.Password == null && doc.IsFileEncrypted())
                    {
                        var pwdDialog = new FilePasswordDialog(doc, true) {Owner = this};
                        bool? pwdResult = pwdDialog.ShowDialog();
                        if (pwdResult == false)
                        {
                            ShowStatus("Encrypted document not opened, due to missing password.",
                                mmApp.Configuration.StatusMessageTimeout);

                            return null;
                        }
                    }


                    if (!doc.Load())
                    {
                        if (!batchOpen)
                        {
                            var msg = "Most likely you don't have access to the file";
                            if (doc.Password != null && doc.IsFileEncrypted())
                                msg = "Invalid password for opening this file";
                            var file = Path.GetFileName(doc.Filename);

                            MessageBox.Show(
                                $"{msg}.\r\n\r\n{file}",
                                "Can't open File", MessageBoxButton.OK,
                                MessageBoxImage.Warning);
                        }

                        return null;
                    }
                }

                editor.MarkdownDocument = doc;
                SetTabHeaderBinding(tab, doc, "FilenameWithIndicator");
            }
            else
                tab.Tag = editor;

            var filename = Path.GetFileName(editor.MarkdownDocument.Filename);
            editor.LoadDocument();

            // is the tab already open?
            TabItem existingTab = null;
            if (filename != "untitled")
            {
                foreach (TabItem tb in TabControl.Items)
                {
                    var lEditor = tb.Tag as MarkdownDocumentEditor;
                    if (lEditor == null)
                        continue;

                    if (lEditor.MarkdownDocument.Filename == editor.MarkdownDocument.Filename)
                    {
                        existingTab = tb;
                        break;
                    }
                }
            }

            if (existingTab != null)
                TabControl.Items.Remove(existingTab);

            tab.IsSelected = false;
            if (TabControl.Items.Count > 0)
                TabablzControl.AddItem(tab, TabControl.Items[0], AddLocationHint.First);
            else
                TabControl.Items.Insert(0, tab);


            // Make the tab draggable for moving into bookmarks or anything else that can accept filenames
            // have to drag down - sideways drag re-orders.
            try
            {
                var dragablzItem = GetDragablzItemFromTabItem(tab);
                if (dragablzItem != null)
                {
                    dragablzItem.PreviewMouseMove += DragablzItem_PreviewMouseMove;
                    dragablzItem.PreviewMouseLeftButtonDown += DragablzItem_PreviewMouseLeftButtonDown;
                    //dragablzItem.PreviewGiveFeedback += (object sender, GiveFeedbackEventArgs e) =>
                    //{
                    //    //e.Effects = DragDropEffects.Copy;
                    //    e.UseDefaultCursors = true;
                    //    if (Cursor != Cursors.Cross)
                    //        Mouse.SetCursor(Cursors.Cross);
                    //};
                }
            }
            catch (Exception ex)
            {
                // this failure can be caused if there's a modal dialog popped up when the app starts
                mmApp.Log("Failed to load DragablzItem for tab drag and drop", ex, false, LogLevels.Warning);
            }


            if (selectTab)
            {
                TabControl.SelectedItem = tab;
                SetWindowTitle();
            }


            if (!isPreview)
            {
                Model.OpenDocuments.Add(editor.MarkdownDocument);
                if (!string.IsNullOrEmpty(editor.MarkdownDocument.Filename) &&
                    !editor.MarkdownDocument.Filename.Equals("untitled", StringComparison.InvariantCultureIgnoreCase))
                    Model.Configuration.LastFolder = Path.GetDirectoryName(editor.MarkdownDocument.Filename);

            }

            AddinManager.Current.RaiseOnAfterOpenDocument(editor.MarkdownDocument);


            if (rebindTabHeaders)
                BindTabHeaders();

            // force tabstate bindings to update
            Model.OnPropertyChanged(nameof(AppModel.IsTabOpen));
            Model.OnPropertyChanged(nameof(AppModel.IsNoTabOpen));

            return tab;
        }




        private void TabControl_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (batchTabAction)
                return;



            var editor = GetActiveMarkdownEditor();
            if (editor == null)
                return;


            var tab = TabControl.SelectedItem as TabItem;

            SetWindowTitle();

            foreach (var doc in Model.OpenDocuments)
                doc.IsActive = false;

            Model.ActiveDocument = editor.MarkdownDocument;
            Model.ActiveDocument.IsActive = true;

            AddRecentFile(Model.ActiveDocument?.Filename, noConfigWrite: true);

            AddinManager.Current.RaiseOnDocumentActivated(Model.ActiveDocument);

            ((Grid) PreviewBrowserContainer.Parent)?.Children.Remove(PreviewBrowserContainer);
            editor.EditorPreviewPane.PreviewBrowserContainer.Children.Add(PreviewBrowserContainer);

            if (tab.Content is Grid grid)
                grid.Children.Add(PreviewBrowserContainer);


            // handle preview tab closing
            if (PreviewTab != null && tab != PreviewTab)
            {
                if (PreviewTab.Tag == null)
                    CloseTab(PreviewTab); // browser preview
                else
                {
                    // preview Markdown Tab
                    var changedDoc = PreviewTab.Tag as MarkdownDocumentEditor;
                    if (changedDoc != null)
                    {
                        if (changedDoc.IsDirty())
                        {
                            // keep the document open
                            changedDoc.IsPreview = false;
                            PreviewTab = null;
                        }
                        else
                            CloseTab(PreviewTab);
                    }
                }
            }


            Model.WindowLayout.IsPreviewVisible = mmApp.Configuration.IsPreviewVisible;

            if (mmApp.Configuration.IsPreviewVisible)
                PreviewBrowser?.PreviewMarkdown();

            editor.RestyleEditor();
            // Don't automatically set focus - we need to do this explicitly
            //editor.SetEditorFocus();

            Dispatcher.InvokeAsync(() => { UpdateDocumentOutline(); }, DispatcherPriority.ApplicationIdle);
        }


        /// <summary>
        /// Refreshes an already loaded tab with contents of a new (or the same file) file
        /// by just replacing the document's text.
        ///
        /// If the tab is not found a new tab is opened.
        ///
        /// Note: File must already be open for this to work
        /// </summary>
        /// <param name="editorFile">File name to display int the tab</param>
        /// <param name="maintainScrollPosition">If possible preserve scroll position if refreshing</param>
        /// <param name="noPreview">If true don't refresh the preview after updating the file</param>
        /// <param name="noSelectTab"></param>
        /// <param name="noFocus">if true don't focus the editor</param>
        /// <param name="readOnly">if true document can't be edited</param>
        /// <param name="isPreview">Determines whether this tab is treated like a preview tab</param>
        /// <returns>selected tab item or null</returns>
        public TabItem RefreshTabFromFile(string editorFile,
            bool maintainScrollPosition = false,
            bool noPreview = false,
            bool noSelectTab = false,
            bool noFocus = false,
            bool readOnly = false,
            bool isPreview = false)
        {

            var tab = GetTabFromFilename(editorFile);
            if (tab == null)
                return OpenTab(editorFile, rebindTabHeaders: true, readOnly: readOnly, noFocus: noFocus,
                    selectTab: !noSelectTab, isPreview: isPreview);

            // load the underlying document
            var editor = tab.Tag as MarkdownDocumentEditor;
            if (editor == null)
                return null;

            editor.IsPreview = isPreview;
            if (isPreview)
                PreviewTab = tab;
            else
                PreviewTab = null;

            editor.MarkdownDocument.Load(editorFile);

            if (!maintainScrollPosition)
                editor.SetCursorPosition(0, 0);

            editor.SetMarkdown(editor.MarkdownDocument.CurrentText);

            if (!noSelectTab)
                TabControl.SelectedItem = tab;
            if (!noFocus)
                editor.SetEditorFocus();
            editor.IsPreview = isPreview;

            if (!noPreview)
                PreviewMarkdownAsync();

            return tab;
        }

        /// <summary>
        /// Activates a tab from an active tab instance
        /// </summary>
        /// <param name="tab"></param>
        /// <returns></returns>
        public TabItem ActivateTab(TabItem tab, bool setFocus = false)
        {
            TabControl.SelectedItem = tab;

            if (setFocus)
                Dispatcher.InvokeAsync(() => Model.ActiveEditor.SetEditorFocus(), DispatcherPriority.ApplicationIdle);

            return tab;
        }

        /// <summary>
        /// Activates a tab by checking from a filename and activating
        /// or optionally open the a new tab.
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public TabItem ActivateTab(string filename, bool openIfNotFound = false,
            bool maintainScrollPosition = false,
            bool noPreview = false,
            bool noSelectTab = false,
            bool noFocus = false,
            bool readOnly = false,
            bool isPreview = false)
        {
            var tab = GetTabFromFilename(filename);
            if (tab == null)
                return OpenTab(filename, rebindTabHeaders: true, readOnly: readOnly, noFocus: noFocus,
                    selectTab: !noSelectTab, isPreview: isPreview);

            // load the underlying document
            var editor = tab.Tag as MarkdownDocumentEditor;
            if (editor == null)
                return null;

            editor.IsPreview = isPreview;
            if (isPreview)
                PreviewTab = tab;
            else
                PreviewTab = null;

            if (!maintainScrollPosition)
                editor.SetCursorPosition(0, 0);

            if (!noSelectTab)
                TabControl.SelectedItem = tab;
            if (!noFocus)
                editor.SetEditorFocus();

            if (!noPreview)
                PreviewMarkdownAsync();

            ActivateTab(tab);

            return tab;
        }

        /// <summary>
        /// Opens a preview tab
        /// </summary>
        /// <param name="url"></param>
        /// <param name="selectTab"></param>
        /// <returns></returns>
        public TabItem OpenBrowserTab(string url,
            bool selectTab = true,
            bool isImageFile = false,
            ImageSource icon = null,
            string tabHeaderText = "Preview")
        {

            // if a document preview tab is open close it
            if (PreviewTab?.Tag is MarkdownDocumentEditor)
            {
                var tab = PreviewTab;
                PreviewTab = null;
                CloseTab(tab);
            }

            if (PreviewTab == null)
            {
                PreviewTab = new TabItem();

                var grid = new Grid();
                PreviewTab.Header = grid;
                var col1 = new ColumnDefinition {Width = new GridLength(20)};
                var col2 = new ColumnDefinition {Width = GridLength.Auto};
                grid.ColumnDefinitions.Add(col1);
                grid.ColumnDefinitions.Add(col2);

                if (icon == null)
                {
                    if (isImageFile)
                        icon = FolderStructure.IconList.GetIconFromType("image");
                    else
                        icon = FolderStructure.IconList.GetIconFromType("preview");
                }

                var img = new Image()
                {
                    Source = icon, Height = 16, Margin = new Thickness(0, 1, 5, 0), Name = "IconImage"
                };
                img.SetValue(Grid.ColumnProperty, 0);
                grid.Children.Add(img);


                var textBlock = new TextBlock
                {
                    Name = "HeaderText",
                    Text = tabHeaderText,
                    FontWeight = FontWeights.SemiBold,
                    FontStyle = FontStyles.Italic
                };
                textBlock.SetValue(Grid.ColumnProperty, 1);
                grid.Children.Add(textBlock);

                HeaderedControlHelper.SetHeaderFontSize(PreviewTab, 13F);

                previewBrowser = new IEWebBrowserControl();
                PreviewTab.Content = previewBrowser;
                TabControl.Items.Add(PreviewTab);

                PreviewTab.HorizontalAlignment = HorizontalAlignment.Right;
                PreviewTab.HorizontalContentAlignment = HorizontalAlignment.Right;
            }
            else
            {
                if (icon == null)
                {
                    if (isImageFile)
                        icon = FolderStructure.IconList.GetIconFromType("image");
                    else
                        icon = FolderStructure.IconList.GetIconFromType("preview");
                }


                var grid = PreviewTab.Header as Grid;


                var imgCtrl = grid.Children[0] as Image; //.FindChild<Image>("IconImage");
                imgCtrl.Source = icon;
                var header = grid.Children[1] as TextBlock; // FindChild<TextBlock>("HeaderText");
                header.Text = tabHeaderText;


            }

            PreviewTab.ToolTip = url;

            try
            {

                if (isImageFile)
                {
                    // Image files get a special preview tab that displays an HTML page with image link                    
                    var file = Path.Combine(App.InitialStartDirectory, "PreviewThemes", "ImagePreview.html");
                    string fileInfo = null;

                    try
                    {
                        string filename = Path.GetFileName(url);
                        string fileDimension;
                        using (var bmp = new Bitmap(url))
                        {
                            fileDimension = $"{bmp.Width}x{bmp.Height}";
                        }

                        var fileSize = ((decimal) (new FileInfo(url).Length) / 1000).ToString("N1");
                        fileInfo = $"<b>{filename}</b> - {fileDimension} &nbsp; {fileSize}kb";
                    }
                    catch
                    {
                    }

                    var content = File.ReadAllText(file).Replace("{{imageUrl}}", url).Replace("{{fileInfo}}", fileInfo);
                    File.WriteAllText(file.Replace("ImagePreview.html", "_ImagePreview.html"), content);
                    url = Path.Combine(App.InitialStartDirectory, "PreviewThemes", "_ImagePreview.html");
                }

                previewBrowser.Navigate(url);
            }
            catch
            {
                previewBrowser.Navigate("about: blank");
            }

            if (PreviewTab != null && selectTab)
                TabControl.SelectedItem = PreviewTab;

            // HACK: force refresh of display model
            Model.OnPropertyChanged(nameof(AppModel.IsTabOpen));
            Model.OnPropertyChanged(nameof(AppModel.IsNoTabOpen));

            return PreviewTab;
        }


        /// <summary>
        /// Closes a tab and ask for confirmation if the tab doc
        /// is dirty.
        /// </summary>
        /// <param name="tab"></param>
        /// <param name="rebindTabHeaders">
        /// When true tab headers are rebound to handle duplicate filenames
        /// with path additions.
        /// </param>
        /// <param name="dontPromptForSave"></param>
        /// <returns>true if tab can close, false if it should stay open</returns>
        public bool CloseTab(TabItem tab, bool rebindTabHeaders = true, bool dontPromptForSave = false)
        {
            if (tab == null)
                return false;

            if (tab == PreviewTab)
            {
                tab.Content = null;
                PreviewTab = null;
                TabControl.Items.Remove(tab);

                tab.Tag = null;
                tab = null;
                return true;
            }

            var editor = tab?.Tag as MarkdownDocumentEditor;
            if (editor == null)
                return false;

            bool returnValue = true;

            tab.Padding = new Thickness(200);

            var doc = editor.MarkdownDocument;

            doc.CleanupBackupFile();

            if (doc.IsDirty && !dontPromptForSave)
            {
                var res = MessageBox.Show(this, Path.GetFileName(doc.Filename) + "\r\n\r\nhas been modified.\r\n" +
                                          "Do you want to save changes?",
                    "Save Document",
                    MessageBoxButton.YesNoCancel, MessageBoxImage.Question, MessageBoxResult.Cancel);
                if (res == MessageBoxResult.Cancel)
                {
                    return false; // don't close
                }

                if (res == MessageBoxResult.No)
                {
                    // close but don't save
                }
                else
                {
                    if (doc.Filename == "untitled")
                        Model.Commands.SaveAsCommand.Execute(ButtonSaveAsFile);
                    else if (!SaveFile())
                        returnValue = false;
                }
            }

            doc.LastEditorLineNumber = editor.GetLineNumber();
            if (doc.LastEditorLineNumber == -1)
                doc.LastEditorLineNumber = 0;


            // *** IMPORTANT: Clean up Tab controls
            editor.ReleaseEditor();
            tab.Tag = null;
            editor = null;
            TabControl.Items.Remove(tab);
            tab = null;

            if (TabControl.Items.Count == 0)
            {
                Model.ActiveDocument = null;
                StatusStats.Text = null;

                TabDocumentOutline.Visibility = Visibility.Collapsed;
                if (SidebarContainer.SelectedItem == TabDocumentOutline)
                    SidebarContainer.SelectedItem = TabFolderBrowser;

                Title = "Markdown Monster" +
                        (UnlockKey.IsUnlocked ? "" : " (unregistered)");
                Model.Window.Focus();
            }

            if (rebindTabHeaders)
                BindTabHeaders();

            Model.OnPropertyChanged(nameof(AppModel.IsTabOpen));
            Model.OnPropertyChanged(nameof(AppModel.IsNoTabOpen));

            return returnValue; // close
        }

        /// <summary>
        /// Closes a tab and ask for confirmation if the tab doc
        /// is dirty.
        /// </summary>
        /// <param name="filename">
        /// The absolute path to the file opened in the tab that
        /// is going to be closed
        /// </param>
        /// <returns>true if tab can close, false if it should stay open or
        /// filename not opened in any tab</returns>
        public bool CloseTab(string filename)
        {
            var tab = GetTabFromFilename(filename);

            if (tab != null)
                return CloseTab(tab);

            return false;
        }

        public bool CloseAllTabs(TabItem allExcept = null)
        {
            batchTabAction = true;
            for (int i = TabControl.Items.Count - 1; i > -1; i--)
            {
                var tab = TabControl.Items[i] as TabItem;

                if (tab != null)
                {
                    if (allExcept != null && tab == allExcept)
                        continue;

                    if (!CloseTab(tab, rebindTabHeaders: false))
                        return false;
                }
            }

            batchTabAction = false;

            return true;
        }


        /// <summary>
        /// Retrieves an open tab based on its filename.
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public TabItem GetTabFromFilename([CanBeNull] string filename)
        {
            if (string.IsNullOrEmpty(filename))
                return null;

            if (filename == "Preview")
                return PreviewTab;

            TabItem tab = null;
            foreach (TabItem tabItem in TabControl.Items.Cast<TabItem>())
            {
                string tabFile =
                    (tabItem.Tag as MarkdownDocumentEditor)?.MarkdownDocument?.Filename ??
                    (tabItem.ToolTip as string);

                if (tabFile == null)
                    continue;

                if (tabFile.Equals(filename, StringComparison.InvariantCultureIgnoreCase))
                {
                    tab = tabItem;
                    break;
                }
            }

            return tab;
        }

        private void TabControl_OnPreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            // Explicitly force focus into the editor
            // Programmatic tab selection does not automatically set focus
            // unless explicitly specified. Click on a tab explicitly sets focus
            // via this operation.
            Model.ActiveEditor?.SetEditorFocus();
        }

        /// <summary>
        ///  Flag used to let us know we don't want to perform tab selection operations
        /// </summary>
        internal bool batchTabAction = false;

        /// <summary>
        /// Binds all Tab Headers
        /// </summary>
        public void BindTabHeaders()
        {
            var tabList = new List<TabItem>();
            foreach (TabItem tb in TabControl.Items)
                tabList.Add(tb);

            var tabItems = tabList
                .Where(tb => tb.Tag is MarkdownDocumentEditor)
                .Select(tb => Path.GetFileName(((MarkdownDocumentEditor) tb.Tag).MarkdownDocument.Filename.ToLower()))
                .GroupBy(fn => fn)
                .Select(tbCol => new {Filename = tbCol.Key, Count = tbCol.Count()});

            foreach (TabItem tb in TabControl.Items)
            {
                var doc = ((MarkdownDocumentEditor) tb.Tag)?.MarkdownDocument;
                if (doc == null)
                    continue;

                if (tabItems.Any(ti => ti.Filename == Path.GetFileName(doc.Filename.ToLower()) &&
                                       ti.Count > 1))

                    SetTabHeaderBinding(tb, doc, "FilenamePathWithIndicator");
                else
                    SetTabHeaderBinding(tb, doc, "FilenameWithIndicator");
            }
        }

        /// <summary>
        /// Returns a list of DragablzItems
        /// </summary>
        /// <returns></returns>
        public List<DragablzItem> GetDragablzItems()
        {
            // UGLY UGLY Hack but only way to get access to the internal controls of Dragablz
            var control = ReflectionUtils.GetField(TabControl, "_dragablzItemsControl") as DragablzItemsControl;
            if (control == null)
            {
                throw new InvalidOperationException("_dragablzItemsControl is null");
            }

            var ditems = ReflectionUtils.CallMethod(control, "DragablzItems") as List<DragablzItem>;
            return ditems;
        }

        /// <summary>
        /// Returns a DragablzItem from a TabItem
        /// </summary>
        /// <param name="tab"></param>
        /// <returns></returns>
        public DragablzItem GetDragablzItemFromTabItem(TabItem tab)
        {
            var items = GetDragablzItems();
            return items.FirstOrDefault(it => it.Content as TabItem == tab);
        }


        /// <summary>
        /// Binds the tab header to our custom controls/container that
        /// shows a customized tab header
        /// </summary>
        /// <param name="tab"></param>
        /// <param name="document"></param>
        /// <param name="propertyPath"></param>
        private void SetTabHeaderBinding(TabItem tab, MarkdownDocument document,
            string propertyPath = "FilenameWithIndicator",
            ImageSource icon = null)
        {
            if (document == null || tab == null)
                return;
            var editor = tab.Tag as MarkdownDocumentEditor;

            try
            {
                var grid = new Grid();

                tab.Header = grid;
                var col1 = new ColumnDefinition {Width = new GridLength(20)};
                var col2 = new ColumnDefinition {Width = GridLength.Auto};
                grid.ColumnDefinitions.Add(col1);
                grid.ColumnDefinitions.Add(col2);



                if (icon == null)
                {
                    icon = FolderStructure.IconList.GetIconFromFile(document.Filename);
                    if (icon == AssociatedIcons.DefaultIcon && Model.ActiveEditor != null)
                        icon = FolderStructure.IconList.GetIconFromType(Model.ActiveEditor.MarkdownDocument.EditorSyntax);
                }

                var img = new Image() {Source = icon, Height = 16, Margin = new Thickness(0, 1, 5, 0)};
                img.SetValue(Grid.ColumnProperty, 0);
                grid.Children.Add(img);


                var textBlock = new TextBlock();
                textBlock.SetValue(Grid.ColumnProperty, 1);


                var headerBinding = new Binding
                {
                    Source = document, Path = new PropertyPath(propertyPath), Mode = BindingMode.OneWay
                };
                BindingOperations.SetBinding(textBlock, TextBlock.TextProperty, headerBinding);

                var tooltipBinding = new Binding
                {
                    Source = document, Path = new PropertyPath("Filename"), Mode = BindingMode.OneWay
                };
                BindingOperations.SetBinding(tab,TabItem.ToolTipProperty, tooltipBinding);

                var fontStyleBinding = new Binding
                {
                    Source = editor,
                    Path = new PropertyPath("IsPreview"),
                    Mode = BindingMode.OneWay,
                    Converter = new FontStyleFromBoolConverter()
                };
                BindingOperations.SetBinding(textBlock, TextBlock.FontStyleProperty, fontStyleBinding);


                var fontWeightBinding = new Binding
                {
                    Source = tab,
                    Path = new PropertyPath("IsSelected"),
                    Mode = BindingMode.OneWay,
                    Converter = new FontWeightFromBoolConverter()
                };
                BindingOperations.SetBinding(textBlock, TextBlock.FontWeightProperty, fontWeightBinding);

                grid.Children.Add(textBlock);
            }
            catch
            {
                // mmApp.Log("SetTabHeaderBinding Failed. Assigning explicit path", ex);
                tab.Header = document.FilenameWithIndicator;
            }
        }


        private void TabControlDragablz_TabItemClosing(ItemActionCallbackArgs<TabablzControl> e)
        {
            var tab = e.DragablzItem.DataContext as TabItem;
            if (tab == null)
                return;

            if (!CloseTab(tab))
                e.Cancel(); // don't do default tab removal
        }

        /// <summary>
        /// Adds a new panel to the sidebar, and adds header text and icon explicitly.
        /// This overload provides a simpler way to add icon and header
        /// </summary>
        /// <param name="tabItem">Adds the TabItem. If null the tabs are refreshed and tabs removed if down to single tab</param>
        /// <param name="tabHeaderText">Optional - header text to set on the tab either just text or in combination with icon</param>
        /// <param name="tabHeaderIcon">Optional - Icon for the tab as an Image Source</param>
        /// <param name="selectItem"></param>
        public void AddLeftSidebarPanelTabItem(TabItem tabItem,
            string tabHeaderText = null,
            ImageSource tabHeaderIcon = null,
            bool selectItem = true)
        {
            if (tabItem != null)
            {
                // Create the header as Icon and Text
                var panel = new StackPanel();
                panel.Margin = new Thickness(0, 5, 0, 5);

                Image img = null;

                if (tabHeaderIcon != null)
                {
                    img = new Image {Source = tabHeaderIcon, Height = 22, ToolTip = tabHeaderText};
                    //panel.Children.Add(new TextBlock { Text = tabHeaderText });
                }
                else if (!string.IsNullOrEmpty(tabHeaderText))
                {
                    img = new Image
                    {
                        Source = ImageAwesome.CreateImageSource(FontAwesomeIcon.QuestionCircle, Brushes.SteelBlue,
                            22),
                        ToolTip = tabHeaderText
                    };
                }

                panel.Children.Add(img);
                tabItem.Header = panel;

                //ControlsHelper.SetHeaderFontSize(tabItem, 14);
                SidebarContainer.Items.Add(tabItem);

                if (selectItem)
                    SidebarContainer.SelectedItem = tabItem;
            }
        }

        /// <summary>
        /// Adds a new panel to the right sidebar
        /// </summary>
        /// <param name="tabItem">Adds the TabItem. If null the tabs are refreshed and tabs removed if down to single tab</param>
        /// <param name="tabHeaderText"></param>
        /// <param name="tabHeaderIcon"></param>
        /// <param name="selectItem"></param>
        public void AddRightSidebarPanelTabItem(TabItem tabItem = null,
            string tabHeaderText = null,
            ImageSource tabHeaderIcon = null,
            bool selectItem = true)
        {
            if (tabItem != null)
            {
                if (tabHeaderIcon != null)
                {
                    // Create the header as Icon and Text
                    var panel = new StackPanel {Orientation = Orientation.Horizontal};
                    panel.Children.Add(new Image
                    {
                        Source = tabHeaderIcon, Height = 16, Margin = new Thickness(4, 0, 4, 0)
                    });
                    panel.Children.Add(new TextBlock {Text = tabHeaderText});
                    tabItem.Header = panel;

                }
                else if (!string.IsNullOrEmpty(tabHeaderText))
                    tabItem.Header = tabHeaderText;



                HeaderedControlHelper.SetHeaderFontSize(tabItem, 14);
                RightSidebarContainer.Items.Add(tabItem);

                if (selectItem)
                    RightSidebarContainer.SelectedItem = tabItem;
            }

            ShowRightSidebar();
        }


        /// <summary>
        /// Sets the Window Title followed by Markdown Monster (registration status)
        /// by default the filename is used and it's updated whenever tabs are changed.
        ///
        /// Note: ActiveTab change causes the title to be automatically updates and
        /// generally you **don't want to set a custom title** because it'll get
        /// overwritten.
        ///
        /// Just call this when you need to have the title updated due to
        /// file name change that doesn't change the active tab.
        /// </summary>
        /// <param name="title"></param>
        public void SetWindowTitle(string title = null)
        {
            if (title == null)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                {
                    Title = "Markdown Monster" +
                             (Model.Configuration.ShowVersionNumberInTitle ? " " + mmApp.GetVersionForDisplay() : string.Empty);
                    return;
                }

                if (Model.Configuration.TitlebarDisplay == TitlebarDisplayModes.FullPath)
                    title = editor.MarkdownDocument.Filename;
                else if(Model.Configuration.TitlebarDisplay == TitlebarDisplayModes.FilenameOnly)
                    title = editor.MarkdownDocument.FilenameWithIndicator.Replace("*", "");
                else if
                    (Model.Configuration.TitlebarDisplay == TitlebarDisplayModes.FileNameAndParentPath)
                    title = editor.MarkdownDocument.FilenamePathWithIndicator.Replace("*", "");

                if (!Model.ActiveProject.IsEmpty)
                    title = title + "  " + Path.GetFileName(Model.ActiveProject.Filename);
            }

            Title = title +
                    "  - Markdown Monster " +
                    (Model.Configuration.ShowVersionNumberInTitle
                        ? mmApp.GetVersionForDisplay() + " " 
                        : "") +
                    (UnlockKey.IsUnlocked ? "" : " (unregistered)");
        }

        /// <summary>
        /// Helper method that sets editor focus
        /// </summary>
        public void SetEditorFocus()
        {
            Dispatcher.Invoke(() => Model.ActiveEditor?.SetEditorFocus());
        }

        private void TabControl_ContextMenuOpening(object sender, ContextMenuEventArgs e)
        {
            var context = new TabContextMenu();
            context.ShowContextMenu();
            e.Handled = true;
        }

        private void TabHeader_DoubleClick(object sender, MouseButtonEventArgs ev)
        {
            if (ev.ClickCount == 2)
                OpenTab("untitled");
        }

        #endregion

        #region Tab Drag and Drop

        private System.Windows.Point _dragablzStartPoint;

        private void DragablzItem_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _dragablzStartPoint = e.GetPosition(null);
        }

        /// <summary>
        ///  Drag and Drop into the BookMarks dialog
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void DragablzItem_PreviewMouseMove(object sender, MouseEventArgs e)
        {

            if (e.LeftButton == MouseButtonState.Pressed)
            {
                var curPoint = e.GetPosition(null);
                var diff = curPoint - _dragablzStartPoint;
                if (_dragablzStartPoint.Y > 0 && (diff.Y > 30 || diff.Y < -30))
                {
                    var drag = sender as DragablzItem;
                    if (drag == null)
                        return;
                    var tab = drag.Content as TabItem;

                    var editor = tab.Tag as MarkdownDocumentEditor;
                    if (editor == null)
                        return;

                    //var dragData = new DataObject(DataFormats.UnicodeText, editor.MarkdownDocument.Filename);
                    var files = new[] {editor.MarkdownDocument.Filename};
                    var dragData = new DataObject(DataFormats.FileDrop, files);

                    var fav = FavoritesTab.Content as FavoritesControl;
                    if (fav != null)
                        fav.IsDragging = true; // notify that we're ready to drop on favorites potentially

                    DragDrop.DoDragDrop(drag, dragData, DragDropEffects.Copy);

                    _dragablzStartPoint.Y = 0;
                    _dragablzStartPoint.X = 0;
                }
            }
        }

        #endregion

        #region Document Outline

        private void SidebarContainer_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var selected = SidebarContainer.SelectedItem as TabItem;
            if (selected == null)
                return;

            if (selected.Content is DocumentOutlineSidebarControl)
            {
                Dispatcher.InvokeAsync(() =>
                {
                    if (DocumentOutline.Model?.DocumentOutline == null)
                        UpdateDocumentOutline();
                }, DispatcherPriority.ApplicationIdle);
            }
            else if (selected.Content is FavoritesControl)
                OpenFavorites();
        }

        public void UpdateDocumentOutline(int editorLineNumber = -1)
        {
            DocumentOutline?.RefreshOutline(editorLineNumber);
        }

        public void OpenFavorites(bool noActivate = false)
        {
            if (FavoritesTab == null)
            {
                FavoritesTab = new MetroTabItem();
                FavoritesTab.Content = new FavoritesControl();

                AddLeftSidebarPanelTabItem(FavoritesTab, "Favorite Files and Folders",
                    ImageAwesome.CreateImageSource(FontAwesomeIcon.Star, Brushes.Goldenrod, 11),
                    selectItem: !noActivate);
            }
            else if (!noActivate)
            {
                SidebarContainer.SelectedItem = FavoritesTab;

                Dispatcher.InvokeAsync(() =>
                {
                    var control = FavoritesTab.Content as FavoritesControl;
                    control?.TextSearch.Focus();
                });
            }
        }



        public FileSearchControl OpenSearchPane(bool noActivate = false)
        {
            if (SearchTab == null)
            {
                SearchTab = new MetroTabItem() {Content = new FileSearchControl()};

                AddLeftSidebarPanelTabItem(SearchTab, "File Search",
                    ImageAwesome.CreateImageSource(FontAwesomeIcon.Search, Brushes.SteelBlue, 11), !noActivate);
            }
            else
            {
                SidebarContainer.SelectedItem = SearchTab;

                Dispatcher.InvokeAsync(() =>
                {
                    var control = SearchTab.Content as FileSearchControl;
                    control?.SearchPhrase.Focus();
                });
            }

            return SearchTab.Content as FileSearchControl;
        }

        #endregion


        #region Preview and UI Visibility Helpers

        public void PreviewMarkdown(MarkdownDocumentEditor editor = null, bool keepScrollPosition = false,
            bool showInBrowser = false, string renderedHtml = null)
        {
            PreviewBrowser?.PreviewMarkdown(editor, keepScrollPosition, showInBrowser, renderedHtml);
        }

        public void PreviewMarkdownAsync(MarkdownDocumentEditor editor = null, bool keepScrollPosition = false,
            string renderedHtml = null)
        {
            PreviewBrowser?.PreviewMarkdownAsync(editor, keepScrollPosition, renderedHtml);
        }


        public void Navigate(string url)
        {
            PreviewBrowser?.Navigate(url);
        }


        /// <summary>
        /// Shows or hides the preview browser
        /// </summary>
        /// <param name="hide"></param>
        public void ShowPreviewBrowser(bool hide = false, bool refresh = false)
        {
            if (!hide && Model.Configuration.PreviewMode != PreviewModes.None)
            {
                if (Model.Configuration.PreviewMode == PreviewModes.InternalPreview)
                {

                    if (Model.Configuration.IsPreviewVisible)
                        Model.WindowLayout.IsPreviewVisible = true;
                    else
                    {
                        Model.WindowLayout.IsPreviewVisible = false;
                        return;
                    }

                    // check if we're already active - if not assign and preview immediately
                    if (!(PreviewBrowser is IPreviewBrowser))
                    {
                        LoadPreviewBrowser();
                        return;
                    }

                    // close external window if it's open
                    if (_previewBrowserWindow != null && PreviewBrowserWindow.Visibility == Visibility.Visible)
                    {
                        PreviewBrowserWindow?.Close();
                        _previewBrowserWindow = null;
                        LoadPreviewBrowser();
                        return;
                    }

                    if (!refresh)
                    {
                        if (Model.Configuration.WindowPosition.SplitterPosition < 100)
                            Model.Configuration.WindowPosition.SplitterPosition = 600;
                    }
                }
                else if (Model.Configuration.PreviewMode == PreviewModes.ExternalPreviewWindow)
                {
                    // make sure it's visible
                    PreviewBrowserWindow?.Show();

                    // check if we're already active - if not assign and preview immediately
                    if (!(PreviewBrowser is PreviewBrowserWindow))
                    {
                        PreviewBrowser = PreviewBrowserWindow;
                        PreviewBrowser?.PreviewMarkdownAsync();
                    }


                    Model.WindowLayout.IsPreviewVisible = false;

                    // clear the preview
                    ((IPreviewBrowser) PreviewBrowserContainer.Children[0]).Navigate("about:blank");
                }
            }
            else
            {
                if (Model.Configuration.PreviewMode == PreviewModes.InternalPreview)
                {
                    Model.WindowLayout.IsPreviewVisible = false;
                }
                else if (Model.Configuration.PreviewMode == PreviewModes.ExternalPreviewWindow)
                {
                    if (_previewBrowserWindow != null)
                    {
                        PreviewBrowserWindow?.Close();
                        _previewBrowserWindow = null;
                        PreviewBrowser = null;
                    }
                }

            }
        }

        /// <summary>
        /// Shows or hides the File Browser
        /// </summary>
        /// <param name="hide"></param>
        /// <param name="folder">Folder or File. If File the file will be selected in the folder</param>
        public void ShowFolderBrowser(bool hide = false, string folder = null)
        {
            var layoutModel = Model.WindowLayout;
            if (hide)
            {
                layoutModel.IsLeftSidebarVisible = false;
                mmApp.Configuration.FolderBrowser.Visible = false;
            }
            else
            {
                if (folder == null)
                    folder = FolderBrowser.FolderPath;
                if (folder == null)
                    folder = mmApp.Configuration.FolderBrowser.FolderPath;

                Dispatcher.InvokeAsync(() =>
                {
                    if (string.IsNullOrEmpty(folder) && Model.ActiveDocument != null)
                        folder = Path.GetDirectoryName(Model.ActiveDocument.Filename);

                    FolderBrowser.FolderPath = folder;
                }, DispatcherPriority.ApplicationIdle);

                layoutModel.IsLeftSidebarVisible = true;
                mmApp.Configuration.FolderBrowser.Visible = true;
                SidebarContainer.SelectedIndex = 0; // folder browser tab

                Model.Configuration.LastFolder = folder;
            }
        }

        public void ShowLeftSidebar(bool hide = false)
        {
            if (!hide && SidebarContainer.Items.Count == 1)
            {
                ShowFolderBrowser();
                return;
            }

            Model.WindowLayout.IsLeftSidebarVisible = !hide;
        }

        public void ShowRightSidebar(bool hide = false)
        {
            Model.WindowLayout.IsRightSidebarVisible = !hide;
        }

        /// <summary>
        /// Create an instance of the Preview Browser either using the
        /// default IE based preview browser, or if an addin has registered
        /// a custom preview browser.
        /// </summary>
        public void LoadPreviewBrowser()
        {
            var previewBrowser = AddinManager.Current.RaiseGetPreviewBrowserControl();
            if (previewBrowser == null || PreviewBrowser != previewBrowser)
            {
                if (previewBrowser == null)
                    PreviewBrowser = new IEWebBrowserControl() {Name = "PreviewBrowser"};
                else
                    PreviewBrowser = previewBrowser;

                if (PreviewBrowserContainer == null)
                    PreviewBrowserContainer = new Grid();


                PreviewBrowserContainer.Children.Clear();
                PreviewBrowserContainer.Children.Add(PreviewBrowser as UIElement);

                ShowPreviewBrowser();
            }

            // show or hide
            PreviewMarkdownAsync();
        }

        #endregion

        #region Worker Functions

        public MarkdownDocumentEditor GetActiveMarkdownEditor()
        {
            var tab = TabControl?.SelectedItem as TabItem;
            return tab?.Tag as MarkdownDocumentEditor;
        }


        /// <summary>
        /// Check to see if the window is visible in the bounds of the
        /// virtual screen space. If not adjust to main monitor off 0 position.
        /// </summary>
        /// <returns></returns>
        void FixMonitorPosition()
        {
            var virtualScreenHeight = SystemParameters.VirtualScreenHeight;
            var virtualScreenWidth = SystemParameters.VirtualScreenWidth;


            if (Left > virtualScreenWidth - 150)
                Left = 20;
            if (Top > virtualScreenHeight - 150)
                Top = 20;

            if (Left < SystemParameters.VirtualScreenLeft)
                Left = SystemParameters.VirtualScreenLeft;
            if (Top < SystemParameters.VirtualScreenTop)
                Top = SystemParameters.VirtualScreenTop;

            if (Width > virtualScreenWidth)
                Width = virtualScreenWidth - 40;
            if (Height > virtualScreenHeight)
                Height = virtualScreenHeight - 40;
        }

        #endregion

        #region Button Handlers

        /// <summary>
        /// Generic button handler that handles a number of simple
        /// tasks in a single method to minimize class noise.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public void Button_Handler(object sender, RoutedEventArgs e)
        {
            var button = sender;
            if (button == null)
                return;

            if (button == ButtonOpenFromHtml)
            {
                var fd = new OpenFileDialog
                {
                    DefaultExt = ".htm",
                    Filter = "Html files (*.htm,*.html)|*.htm;*.html|" +
                             "All files (*.*)|*.*",
                    CheckFileExists = true,
                    RestoreDirectory = true,
                    Multiselect = true,
                    Title = "Open Html as Markdown"                    
                };

                if (!string.IsNullOrEmpty(mmApp.Configuration.LastFolder))
                    fd.InitialDirectory = mmApp.Configuration.LastFolder;

                var res = fd.ShowDialog();
                if (res == null || !res.Value)
                    return;

                string html = mmFileUtils.OpenTextFile(fd.FileName);
                if (html == null)
                    return;

                var markdown = MarkdownUtilities.HtmlToMarkdown(html);

                OpenTab("untitled");
                var editor = GetActiveMarkdownEditor();
                editor.MarkdownDocument.CurrentText = markdown;
                PreviewBrowser.PreviewMarkdown();
            }
            else if (button == ToolbarButtonRecentFiles)
            {
                var mi = button as Button;

                var contextMenu = new RecentDocumentsContextMenu(this);
                contextMenu.UpdateRecentDocumentsContextMenu(RecentFileDropdownModes.ToolbarDropdown);
                if (mi.ContextMenu != null)
                    mi.ContextMenu.IsOpen = true;
                e.Handled = true;
            }
            else if (button == ButtonExit)
            {
                Close();
            }

            else if (button == MenuOpenConfigFolder)
            {
                ShellUtils.GoUrl(mmApp.Configuration.CommonFolder);
            }
            else if (button == MenuOpenPreviewFolder)
            {
                ShellUtils.GoUrl(Path.Combine(App.InitialStartDirectory, "PreviewThemes",
                    mmApp.Configuration.PreviewTheme));
            }
            else if (button == MenuMarkdownMonsterSite)
            {
                ShellUtils.GoUrl(mmApp.Urls.WebSiteUrl);
            }
            else if (button == MenuBugReport)
            {
                ShellUtils.GoUrl(mmApp.Urls.SupportUrl);
            }
            else if (button == MenuCheckNewVersion)
            {
                ShowStatus("Checking for new version...");
                if (!ApplicationUpdater.CheckForNewVersion(true, failTimeout: 5000))
                    ShowStatusSuccess("Your version of Markdown Monster is up to date.");
            }
            else if (button == MenuRegister)
            {
                Window rf = new RegistrationForm();
                rf.Owner = this;
                rf.ShowDialog();
            }
            else if (button == ButtonAbout)
            {
                Window about = new About();
                about.Owner = this;
                about.Show();
            }
            else if (button == Button_Find)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                    return;
                editor.ExecEditorCommand("find");
            }
            else if (button == Button_FindNext)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                    return;
                editor.ExecEditorCommand("findnext");
            }
            else if (button == Button_Replace)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                    return;
                editor.ExecEditorCommand("replace");
            }
            else if (button == ButtonWordWrap ||
                     button == ButtonLineNumbers ||
                     button == ButtonShowInvisibles ||
                     button == ButtonCenteredView)
            {
                Model.ActiveEditor?.RestyleEditor();
            }
            else if (button == ButtonStatusEncrypted)
            {
                if (Model.ActiveDocument == null)
                    return;

                var dialog = new FilePasswordDialog(Model.ActiveDocument, false) {Owner = this};
                dialog.ShowDialog();
            }
            else if (button == MenuDocumentation)
                ShellUtils.GoUrl(mmApp.Urls.DocumentationBaseUrl);
            else if (button == MenuMarkdownBasics)
                ShellUtils.GoUrl(mmApp.Urls.DocumentationBaseUrl + "_4ne1eu2cq.htm");
            else if (button == MenuCreateAddinDocumentation)
                ShellUtils.GoUrl(mmApp.Urls.DocumentationBaseUrl + "_4ne0s0qoi.htm");
            else if (button == MenuShowSampleDocument)
                OpenTab(Path.Combine(App.InitialStartDirectory, "SampleMarkdown.md"));
            else if (button == MenuShowErrorLog)
            {
                string logFile = Path.Combine(mmApp.Configuration.CommonFolder, "MarkdownMonsterErrors.txt");
                if (File.Exists(logFile))
                    ShellUtils.GoUrl(logFile);
                else
                    MessageBox.Show("There are no errors in your log file.",
                        mmApp.ApplicationName,
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
            }
            else if (button == MenuResetConfiguration)
            {
                if (MessageBox.Show(
                        "This operation will reset all of your configuration settings and shut down Markdown Monster.\r\n\r\nAre you sure?",
                        "Reset Configuration Settings",
                        MessageBoxButton.YesNo, MessageBoxImage.Warning, MessageBoxResult.No) == MessageBoxResult.Yes)
                {
                    mmApp.Configuration.Backup();
                    mmApp.Configuration.Reset();
                }
            }
            else if (button == MenuBackupConfiguration)
            {
                string filename = mmApp.Configuration.Backup();
                ShowStatus($"Configuration backed up to: {Path.GetFileName(filename)}",
                    mmApp.Configuration.StatusMessageTimeout);
                ShellUtils.OpenFileInExplorer(filename);
            }
            else if (button == ButtonAllowScriptTags)
            {
                if (!Model.Configuration.MarkdownOptions.AllowRenderScriptTags &&
                    (Model.Configuration.MarkdownOptions.UseMathematics ||  Model.Configuration.MarkdownOptions.MermaidDiagrams) )
                {
                    if (MessageBox.Show(@"Disabling this option also disables:

   Mathematics 
   Mermaid Diagrams

as these options require JavaScript scripts in order to work.

Do you want to continue anyway?", "Disable Markdown Script Rendering",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Question,
                            MessageBoxResult.Yes) == MessageBoxResult.No)
                        Model.Configuration.MarkdownOptions.AllowRenderScriptTags = true;
                    else
                    {
                        Model.Configuration.MarkdownOptions.UseMathematics = false;
                        Model.Configuration.MarkdownOptions.MermaidDiagrams = false;
                    }
                }

                // force preview to refresh
                Model.Commands.RefreshPreviewCommand.Execute(null);
            }
        }

        #endregion

        #region Miscelleaneous Events

        /// <summary>
        /// Handle drag and drop of file. Note only works when dropped on the
        /// window - doesn't not work when dropped on the editor.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MainWindow_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[]) e.Data.GetData(DataFormats.FileDrop);

                foreach (var file in files)
                {
                    var ext = Path.GetExtension(file.ToLower());
                    if (File.Exists(file) && ("," +  mmApp.AllowedFileExtensions + ",").Contains($",{ext},"))
                    {
                        OpenTab(file, rebindTabHeaders: true);
                    }
                }
            }
        }

        private void PreviewBrowser_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            //if (e.NewSize.Width > 100)
            //{
            //	int width = Convert.ToInt32(MainWindowPreviewColumn.Width.Value);
            //	if (width > 100)
            //		mmApp.Configuration.WindowPosition.SplitterPosition = width;
            //}
        }

        private void EditorTheme_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            foreach (TabItem tab in TabControl.Items)
            {
                var editor = tab.Tag as MarkdownDocumentEditor;
                editor?.RestyleEditor();
            }

            PreviewBrowser?.PreviewMarkdownAsync();
        }

        private void PreviewTheme_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            Model.ActiveEditor?.AceEditor?.SetEditorStyling();
            PreviewBrowser?.PreviewMarkdownAsync();
        }


        //public void AppTheme_MenuButtonClick(object sender, RoutedEventArgs e)
        //{
        //    var button = sender as MenuItem;
        //    var text = button.Header as string;

        //    var selected = (Themes) Enum.Parse(typeof(Themes), text);
        //    var oldVal = mmApp.Configuration.ApplicationTheme;

        //    if (oldVal != selected &&
        //        MessageBox.Show("Application theme changes require that you restart.\r\n\r\nDo you want to restart Markdown Monster?",
        //                        "Theme Change", MessageBoxButton.YesNo,
        //                        MessageBoxImage.Question, MessageBoxResult.Yes) == MessageBoxResult.Yes)
        //    {
        //        mmApp.Configuration.ApplicationTheme = selected;
        //        if (mmApp.Configuration.ApplicationTheme == Themes.Light)
        //        {
        //            mmApp.Configuration.EditorTheme = "vscodelight";
        //            mmApp.Configuration.PreviewTheme = "Github";
        //        }
        //        else
        //            mmApp.Configuration.EditorTheme = "vscodedark";

        //        mmApp.Configuration.Write();

        //        PipeManager.StopServer();
        //        ForceClose = true;
        //        Close();

        //        // execute with delay
        //        ShellUtils.ExecuteProcess(Path.Combine(App.InitialStartDirectory, "MarkdownMonster.exe"), "-delay");
        //        Environment.Exit(0);
        //    }
        //}

        private void DocumentType_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (Model.ActiveEditor == null)
                return;

            Model.ActiveEditor.SetEditorSyntax(Model.ActiveEditor.MarkdownDocument.EditorSyntax);
            SetTabHeaderBinding(TabControl.SelectedItem as TabItem, Model.ActiveEditor.MarkdownDocument);

            // Refresh the Preview to show preview for html and markdown and hide it for others
            Model.Window.PreviewMarkdownAsync();
        }

        private void ButtonRecentFiles_SubmenuOpened(object sender, RoutedEventArgs e)
        {
            var menu = new RecentDocumentsContextMenu(this);
            menu.UpdateRecentDocumentsContextMenu(RecentFileDropdownModes.MenuDropDown);
        }

        private void LeftSidebarExpand_MouseDown(object sender, MouseButtonEventArgs e)
        {
            Model.Commands.OpenLeftSidebarPanelCommand.Execute(null);
        }

        private void RightSidebarExpand_MouseDown(object sender, MouseButtonEventArgs e)
        {
            Model.WindowLayout.IsRightSidebarVisible = true;
            Model.WindowLayout.RightSidebarWidth = GridLengthHelper.FromInt(300);
        }

        private void MarkdownParserName_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (mmApp.Configuration != null &&
                !string.IsNullOrEmpty(mmApp.Configuration.MarkdownOptions.MarkdownParserName))
            {
                MarkdownParserFactory.GetParser(parserAddinId: mmApp.Configuration.MarkdownOptions.MarkdownParserName,
                    forceLoad: true);
                PreviewBrowser?.PreviewMarkdownAsync();
            }
        }

        private void ButtonLangugeDropDown_Click(object sender, RoutedEventArgs e)
        {
            var context = new LanguagesContextMenu(this);
            context.OpenContextMenu();
        }


        private void ButtonWindowSizesDropdown_Click(object sender, RoutedEventArgs e)
        {
            var menu = new WindowSizesContextMenu(this);
            menu.OpenContextMenu();
        }

        private void Refresh_Styling(object sender, RoutedEventArgs e)
        {
            Model.ActiveEditor?.RestyleEditor();
        }

        #endregion

        #region Window Menu Items
        public List<MenuItem> GenerateContextMenuItemsFromOpenTabs(ContextMenu ctx = null)
        {
            var menuItems = new List<MenuItem>();
            var icons = new AssociatedIcons();
            var selectedTab = TabControl.SelectedItem as TabItem;

            var headers = TabControl.GetOrderedHeaders();
            foreach (var hd in headers)
            {
                var tab = hd.Content as TabItem;

                StackPanel sp;
                string commandParameter;
                var doc = tab.Tag as MarkdownDocumentEditor;

                if (tab == PreviewTab && doc == null)
                {
                    var icon = (tab.Header as Grid).FindChild<Image>("IconImage")?.Source;
                    var txt = (tab.Header as Grid).FindChild<TextBlock>("HeaderText")?.Text;

                    sp = new StackPanel { Orientation = Orientation.Horizontal };
                    sp.Children.Add(new Image
                    {
                        Source = icon,
                        Width = 16,
                        Height = 16,
                        Margin = new Thickness(0, 0, 20, 0)
                    });
                    sp.Children.Add(new TextBlock { Text = txt });
                    commandParameter = "Preview";

                    sp = new StackPanel { Orientation = Orientation.Horizontal };
                    sp.Children.Add(new Image
                    {
                        Source = icon,
                        Width = 16,
                        Height = 16,
                        Margin = new Thickness(0, 0, 20, 0)
                    });
                    sp.Children.Add(new TextBlock { Text = txt });
                    commandParameter = "Preview";
                }
                else
                {
                    if (doc == null) continue;

                    var filename = doc.MarkdownDocument.FilenamePathWithIndicator;
                    var icon = icons.GetIconFromFile(doc.MarkdownDocument.Filename);

                    sp = new StackPanel { Orientation = Orientation.Horizontal };
                    sp.Children.Add(new Image
                    {
                        Source = icon,
                        Width = 16,
                        Height = 16,
                        Margin = new Thickness(0, 0, 20, 0)
                    });
                    sp.Children.Add(new TextBlock { Text = filename });
                    commandParameter = doc.MarkdownDocument.Filename;
                }


                var mi = new MenuItem();
                mi.Header = sp;
                mi.Command = Model.Commands.TabControlFileListCommand;
                mi.CommandParameter = commandParameter;
                if (tab == selectedTab)
                {
                    mi.FontWeight = FontWeights.Bold;
                    mi.Foreground = Brushes.SteelBlue;
                }

                menuItems.Add(mi);
            }

            return menuItems;
        }

        private void MainMenuWindow_SubmenuOpened(object sender, RoutedEventArgs e)
        {
            Model.Commands.WindowMenuCommand.Execute(null);
        }
        #endregion

        #region StatusBar Display

        public void ShowStatus(string message = null, int milliSeconds = 0,
            FontAwesomeIcon icon = FontAwesomeIcon.None,
            Color color = default(Color),
            bool spin = false) => StatusBarHelper.ShowStatus(message, milliSeconds, icon, color, spin);

        /// <summary>
        /// Displays an error message using common defaults for a timeout milliseconds
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="timeout">optional timeout</param>
        /// <param name="icon">optional icon (warning)</param>
        /// <param name="color">optional color (firebrick)</param>
        public void ShowStatusError(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.Warning,
            Color color = default(Color)) => StatusBarHelper.ShowStatusError(message, timeout, icon, color);


        /// <summary>
        /// Shows a success message with a green check icon for the timeout
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="timeout">optional timeout</param>
        /// <param name="icon">optional icon (warning)</param>
        /// <param name="color">optional color (firebrick)</param>
        public void ShowStatusSuccess(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.CheckCircle,
            Color color = default(Color)) => StatusBarHelper.ShowStatusSuccess(message, timeout, icon, color);


        /// <summary>
        /// Displays an Progress message using common defaults including a spinning icon
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="timeout">optional timeout</param>
        /// <param name="icon">optional icon (warning)</param>
        /// <param name="color">optional color (firebrick)</param>
        /// <param name="spin"></param>
        public void ShowStatusProgress(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.CircleOutlineNotch,
            Color color = default(Color),
            bool spin = true) => StatusBarHelper.ShowStatusProgress(message, timeout, icon, color);

        /// <summary>
        /// Status the statusbar icon on the left bottom to some indicator
        /// </summary>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        /// <param name="spin"></param>
        public void SetStatusIcon(FontAwesomeIcon icon, Color color, bool spin = false) => StatusBarHelper.SetStatusIcon(icon, color, spin);

        /// <summary>
        /// Resets the Status bar icon on the left to its default green circle
        /// </summary>
        public void SetStatusIcon() => StatusBarHelper.SetStatusIcon();

        /// <summary>
        /// Helper routine to show a Metro Dialog. Note this dialog popup is fully async!
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="style"></param>
        /// <param name="settings"></param>
        /// <returns></returns>
        public async Task<MessageDialogResult> ShowMessageOverlayAsync(string title, string message,
            MessageDialogStyle style = MessageDialogStyle.Affirmative,
            MetroDialogSettings settings = null)
        {
            return await this.ShowMessageAsync(title, message, style, settings);
        }

        private void StatusZoomLevel_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            mmApp.Configuration.Editor.ZoomLevel = 100;
            Model.ActiveEditor?.RestyleEditor();
        }

        private void StatusZoomLevel_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            var text = StatusZoomLevel.Text;
            text = text.Replace("%", "");
            if (int.TryParse(text, out int num))
            {
                Model.Configuration.Editor.ZoomLevel = num;
                Model.ActiveEditor?.RestyleEditor();
            }
        }

        private void StatusZoomLevel_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var text = StatusZoomLevel.Text;
            text = text.Replace("%", "");

            if (int.TryParse(text, out int num))
                Model.Configuration.Editor.ZoomLevel = num;

            Model.ActiveEditor?.RestyleEditor();
        }


        private void StatusEncoding_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (Model.ActiveDocument == null)
                return;

            var encoding = Model.ActiveDocument.Encoding;

            string enc = StatusEncoding.SelectedItem as string;
            if (enc == null || enc.StartsWith(""))
            {
                StatusEncoding.SelectedValue = mmFileUtils.GetEncodingName(encoding);
                return;
            }
            
            if (enc.StartsWith("Load additional"))
            {
                Model.EncodingTypes = new ObservableCollection<string>(mmFileUtils.GetEncodingList(true));
                StatusEncoding.SelectedValue = mmFileUtils.GetEncodingName(encoding);

                Dispatcher.InvokeAsync(() => StatusEncoding.IsDropDownOpen = true);
                return;
            }

            encoding = mmFileUtils.GetEncoding(enc);
            if (Model.ActiveDocument.Encoding.Equals(encoding))
            {
                Model.Window.ShowStatusSuccess($"Document already set to {StatusEncoding.SelectedValue} encoding.");
                return;
            }

            if (Model.ActiveDocument.IsDirty &&
                MessageBox.Show(
                    "This document has unsaved changes that have to be saved before the document Encoding can be updated.\n\n" +
                    "Do you want to save changes?",
                    "Document Changes Pending",
                    MessageBoxButton.YesNo, MessageBoxImage.Question, MessageBoxResult.No) == MessageBoxResult.No)
            {
                Model.Window.ShowStatusError("Encoding has not been updated. Please save your document first.");
                return;
            }

           
            Model.ActiveDocument.Encoding = encoding;

            // otherwise re-open
            if (!Model.ActiveDocument.Load(Model.ActiveDocument.Filename, encoding: encoding))
                Model.Window.ShowStatusError("Couldn't reopen file with the " + encoding.EncodingName + " Encoding.");
            else
            {
                // Save Selection and past new content
                Model.ActiveEditor.ReplaceContent(Model.ActiveDocument.CurrentText);
                Model.ActiveEditor.PreviewMarkdownCallback(true);
                Model.ActiveDocument.IsDirty = true;
            }

            StatusEncoding.SelectedValue = mmFileUtils.GetEncodingName(encoding);
            Model.Window.ShowStatusSuccess($"The document has been reloaded with {StatusEncoding.SelectedValue} encoding.");
        }

        #endregion

        private void TextLinefeedMode_MouseUp(object sender, MouseButtonEventArgs e)
        {
            Model.Commands.SettingsVisualCommand?.Execute("Linefeed");
        }

        private void MainApplicationWindow_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            mmApp.Model.WindowLayout.FixUpEditorSize();
        }
    }

    public class RecentDocumentListItem
    {   
        public string Filename { get; set; }
        public string DisplayFilename { get; set; }
    }


    public enum RecentFileDropdownModes
    {
        ToolbarDropdown,
        MenuDropDown
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Threading;
using Dragablz;
using FontAwesome.WPF;
using LibGit2Sharp;
using MahApps.Metro.Controls;
using MahApps.Metro.Controls.Dialogs;
using MarkdownMonster._Classes;
using MarkdownMonster.AddIns;
using MarkdownMonster.Annotations;
using MarkdownMonster.Controls.ContextMenus;
using MarkdownMonster.Services;
using MarkdownMonster.Utilities;
using MarkdownMonster.Windows;
using MarkdownMonster.Windows.PreviewBrowser;
using Westwind.Utilities;
using Binding = System.Windows.Data.Binding;
using Brushes = System.Windows.Media.Brushes;
using Button = System.Windows.Controls.Button;
using Color = System.Windows.Media.Color;
using ContextMenu = System.Windows.Controls.ContextMenu;
using DataFormats = System.Windows.DataFormats;
using DataObject = System.Windows.DataObject;
using DragDropEffects = System.Windows.DragDropEffects;
using DragEventArgs = System.Windows.DragEventArgs;
using HorizontalAlignment = System.Windows.HorizontalAlignment;
using Image = System.Windows.Controls.Image;
using MenuItem = System.Windows.Controls.MenuItem;
using MessageBox = System.Windows.MessageBox;
using MouseEventArgs = System.Windows.Input.MouseEventArgs;
using OpenFileDialog = Microsoft.Win32.OpenFileDialog;
using Orientation = System.Windows.Controls.Orientation;
using ToolBar = System.Windows.Controls.ToolBar;

namespace MarkdownMonster
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : MetroWindow
        //, IPreviewBrowser
    {
        public AppModel Model { get; set; }

        public NamedPipeManager PipeManager { get; set; }

        public IntPtr Hwnd
        {
            get
            {
                if (_hwnd == IntPtr.Zero)
                    _hwnd = new WindowInteropHelper(this).EnsureHandle();

                return _hwnd;
            }
        }

        private IntPtr _hwnd = IntPtr.Zero;

        private DateTime _invoked = DateTime.MinValue;


        /// <summary>
        /// Manages the Preview Rendering in a WebBrowser Control
        /// </summary>
        public IPreviewBrowser PreviewBrowser { get; set; }

        public PreviewBrowserWindow PreviewBrowserWindow
        {
            set { _previewBrowserWindow = value; }
            get
            {
                if (_previewBrowserWindow == null || _previewBrowserWindow.IsClosed)
                {
                    _previewBrowserWindow = new PreviewBrowserWindow();
                    if (Model.Configuration.WindowPosition.PreviewDisplayMode ==
                        PreviewWindowDisplayModes.ActivatedByMainWindow)
                        _previewBrowserWindow.Owner = this;

                }

                return _previewBrowserWindow;
            }
        }

        private PreviewBrowserWindow _previewBrowserWindow;


        /// <summary>
        /// The Preview Browser Container Grid that contains the
        /// Web Browser control that handles the Document tied
        /// preview.
        /// </summary>
        public Grid PreviewBrowserContainer { get; set; }


        /// <summary>
        /// The Preview Browser Tab if active that is used
        /// for image and URL previews (ie. the Preview
        /// without an associated editor)
        /// </summary>
        public TabItem PreviewTab { get; set; }

        public TabItem FavoritesTab { get; set; }

        public TabItem SearchTab { get; set; }

        public TabItem LintingErrorTab { get; set; }


        private IEWebBrowserControl previewBrowser;

        /// <summary>
        /// Display Statusbar messages easily with pre-configuraed helper  methods
        /// </summary>
        StatusBarHelper StatusBarHelper { get; }

        /// <summary>
        /// Keybindings for the window and editor.
        /// </summary>
        public KeyBindingsManager KeyBindings { get; set; }



        public MainWindow()
        {
            // Initially don't show an icon until we have loaded
            // the form in the right location (in Activate -> Onload after FixMonitorPosition)
            ShowInTaskbar = false;

            InitializeComponent();

            Model = new AppModel(this);
            AddinManager.Current.RaiseOnModelLoaded(Model);

            // This doesn't fire when first started, but fires when
            // addins are added at from the Addin Manager at runtie
            AddinManager.Current.AddinsLoaded = OnAddinsLoaded;

            Model.WindowLayout = new MainWindowLayoutModel(this);

            DataContext = Model;

            TabControl.ClosingItemCallback = TabControlDragablz_TabItemClosing;




            Loaded += OnLoaded;
            Drop += MainWindow_Drop;
            AllowDrop = true;
            Activated += OnActivated;
            StateChanged += MainWindow_StateChanged;


            // Singleton App startup - server code that listens for other instances
            if (mmApp.Configuration.UseSingleWindow && !App.ForceNewWindow)
            {
                // Listen for other instances launching and pick up
                // forwarded command line arguments
                PipeManager = new NamedPipeManager("MarkdownMonster");
                PipeManager.StartServer();
                PipeManager.ReceiveString += HandleNamedPipe_OpenRequest;
            }

            // Override some of the theme defaults (dark header specifically)
            mmApp.SetThemeWindowOverride(this, isMainWindow: true);

            StatusBarHelper = new StatusBarHelper(StatusText, StatusIcon);
        }




        #region Opening and Closing

        private void OnLoaded(object sender, RoutedEventArgs e)
        {

            // Load either default preview browser or addin-overridden browser
            LoadPreviewBrowser();

            RestoreSettings();

            var opener = new CommandLineOpener(this);
            opener.OpenFilesFromCommandLine();

            CheckForFirstRun();

            BindTabHeaders();
            SetWindowTitle();

            var left = Left;
            Left = 300000;

            Model.IsPresentationMode = App.StartInPresentationMode;
            if (!Model.IsPresentationMode)
                Model.IsPresentationMode = mmApp.Configuration.OpenInPresentationMode;

            // run out of band
            Dispatcher.InvokeAsync(() =>
            {
                Left = left;

                FixMonitorPosition();
                ShowInTaskbar = true;


                if (Model.IsPresentationMode)
                {
                    Dispatcher.InvokeAsync(() => Model.WindowLayout.SetPresentationMode(),
                        DispatcherPriority.ApplicationIdle);
                }

                OpenFavorites(noActivate: true);

                //OpenSearchPane(noActivate: true);
            }, DispatcherPriority.Background);

            // run when app is loaded
            Dispatcher.InvokeAsync(() =>
            {
                try
                {
                    AddinManager.Current.InitializeAddinsUi(this);
                }
                catch (Exception exception)
                {
                    mmApp.Log("Addin UI Loading failed.", exception);
                }

                AddinManager.Current.RaiseOnWindowLoaded();


                // Tab Header double click to open new tab
                var tabHeaderContainer = TabControl.FindChild<Grid>("HeaderContainerGrid");
                tabHeaderContainer.Background = Brushes.Transparent; // REQUIRED OR CLICK NOT FIRING!
                tabHeaderContainer.MouseLeftButtonDown += TabHeader_DoubleClick;

                var config = Model.Configuration;

                // Start the built-in localhost Web Server if marked for AutoStart
                if (config.WebServer.AutoStart)
                    WebServerLauncher.StartMarkdownMonsterWebServer();

            }, DispatcherPriority.ApplicationIdle);

            // TODO: Check to see why this fails in async block above ^^^
            // this fails to load asynchronously so do it here
            KeyBindings = new MarkdownMonsterKeybindings(this);
            if (!File.Exists(KeyBindings.KeyBindingsFilename))
                KeyBindings.SaveKeyBindings();
            else
            {
                KeyBindings.LoadKeyBindings();
                // always write back out
                Task.Run(() => KeyBindings.SaveKeyBindings());
            }
            KeyBindings.SetKeyBindings();

        }

        /// <summary>
        /// Capture WindowState and 'old' size for maximized windows
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MainWindow_StateChanged(object sender, EventArgs e)
        {
            if (WindowState == WindowState.Maximized)
            {
                // capture window size before maximizing
                Model.Configuration.WindowPosition.WindowState = WindowState.Maximized;
                Model.Configuration.WindowPosition.Top = (int) Top;
                Model.Configuration.WindowPosition.Left = (int) Left;
                Model.Configuration.WindowPosition.Width = (int) Width;
                Model.Configuration.WindowPosition.Height = (int) Height;
            }
        }

        void CheckForFirstRun()
        {
            if (mmApp.Configuration.ApplicationUpdates.FirstRun)
            {
                var rect = WindowUtilities.GetScreenDimensions(this);
                var ratio = WindowUtilities.GetDpiRatio(this);
                rect.Width = Convert.ToInt32(Convert.ToDecimal(rect.Width) / ratio);
                rect.Height = Convert.ToInt32(Convert.ToDecimal(rect.Height) / ratio);

                Width = rect.Width - 60;
                if (Width > 1600)
                    Width = 1600;
                Left = 30;
                Model.Configuration.WindowPosition.InternalPreviewWidth = (int) (Convert.ToInt32(Width) * 0.45);

                Height = rect.Height - 75; // account for statusbar
                if (Height > 1100)
                    Height = 1100;
                Top = 10;

                if (TabControl.Items.Count == 0)
                {
                    try
                    {
                        string tempFile = Path.Combine(Path.GetTempPath(), "SampleMarkdown.md");
                        File.Copy(Path.Combine(App.InitialStartDirectory, "SampleMarkdown.md"), tempFile, true);
                        OpenTab(tempFile);
                    }
                    catch (Exception ex)
                    {
                        mmApp.Log("Handled: Unable to copy file to temp folder.", ex);
                    }
                }

                mmApp.Configuration.ApplicationUpdates.FirstRun = false;
            }
        }


        /// <summary>
        /// This is called only if addin loading takes very long
        /// Potentially fired off
        /// </summary>
        public void OnAddinsLoaded()
        {
            // Check to see if we are using another preview browser and load
            // that instead
            Dispatcher.InvokeAsync(() => { LoadPreviewBrowser(); }, DispatcherPriority.ApplicationIdle);
        }


        protected override void OnContentRendered(EventArgs e)
        {
            base.OnContentRendered(e);
        }


        /// <summary>
        /// Keep track whether the editor is focused on deactivation
        /// </summary>
        bool _saveIsEditorFocused = true;

        protected override void OnDeactivated(EventArgs e)
        {
            var editor = Model.ActiveEditor;
            if (editor == null) return;

            var doc = Model.ActiveDocument;
            if (doc == null) return;

            doc.IsActive = true;

            _saveIsEditorFocused = Model.IsEditorFocused;

            doc.LastEditorLineNumber = editor.GetLineNumber();
            if (doc.LastEditorLineNumber == -1)
                doc.LastEditorLineNumber = 0;

            base.OnDeactivated(e);

            mmApp.SetWorkingSet(10000000, 5000000);
        }

        protected void OnActivated(object sender, EventArgs e)
        {
            // Active Menu Item deactivation don't refocus
            if (MainMenu.Items.OfType<MenuItem>().Any(item => item.IsHighlighted))
                return;

            if (_saveIsEditorFocused && Model.ActiveEditor != null)
            {
                try
                {
                    Model.ActiveEditor.SetEditorFocus();
                    Model.ActiveEditor.RestyleEditor();
                }
                catch
                {
                    // ignore interop errors
                }
            }
        }


        public bool ForceClose = false;

        protected override void OnClosing(CancelEventArgs e)
        {
            // force method to abort - we'll force a close explicitly
            e.Cancel = true;

            if (ForceClose)
            {
                // cleanup code already ran
                e.Cancel = false;
                return;
            }

            // execute shutdown logic - set ForceClose and call Close() to
            // actually close the window
            Dispatcher.InvokeAsync(ShutdownApplication, DispatcherPriority.Normal);
        }

        private void ShutdownApplication()
        {
            try
            {
                // have to do this here to capture open windows etc. in SaveSettings()
                mmApp.Configuration.ApplicationUpdates.AccessCount++;
                _previewBrowserWindow?.Close();
                _previewBrowserWindow = null;
                PreviewBrowser = null;
                PreviewBrowserContainer = null;
                SaveSettings();

                if (!CloseAllTabs())
                {
                    // tab closing was cancelled
                    mmApp.Configuration.ApplicationUpdates.AccessCount--;
                    return;
                }

                // hide the window quickly
                Top -= 10000;


                FolderBrowser?.ReleaseFileWatcher();
                bool isNewVersion = ApplicationUpdater.CheckForNewVersion(false, false);

                var displayCount = 6;
                if (mmApp.Configuration.ApplicationUpdates.AccessCount > 250)
                    displayCount = 1;
                else if (mmApp.Configuration.ApplicationUpdates.AccessCount > 100)
                    displayCount = 2;
                else if (mmApp.Configuration.ApplicationUpdates.AccessCount > 50)
                    displayCount = 5;

                if (!isNewVersion && mmApp.Configuration.ApplicationUpdates.AccessCount % displayCount == 0 &&
                    !UnlockKey.IsAppRegistered())
                {
                    // bring the window back
                    Top += 10000;
                    Opacity = 0;

                    var rd = new RegisterDialog(true);
                    rd.Owner = this;
                    rd.ShowDialog();
                }

                PipeManager?.StopServer();
                WebServer?.StopServer();


                AddinManager.Current.RaiseOnApplicationShutdown();
                AddinManager.Current.UnloadAddins();

                App.Mutex?.Dispose();

                PipeManager?.WaitForThreadShutDown(5000);
                mmApp.Shutdown();

                ForceClose = true;
                Close();
            }
            catch (Exception ex)
            {
                mmApp.Log("Shutdown: " + ex.Message, ex, logLevel: LogLevels.Error);
                ForceClose = true;
                Close();
            }
        }

        public void AddRecentFile(string file, bool noConfigWrite = false)
        {
            Dispatcher.InvokeAsync(() =>
            {
                mmApp.Configuration.AddRecentFile(file);

                if (!noConfigWrite)
                    mmApp.Configuration.Write();

                try
                {
                    MostRecentlyUsedList.AddToRecentlyUsedDocs(Path.GetFullPath(file));
                }
                catch
                {
                }
            }, DispatcherPriority.ApplicationIdle);
        }


        /// <summary>
        /// Adds a fontawesome icon to the editor toolbar (or any toolbar you specify explicitly).
        /// Specify the FontAwesome Icon image name (FontAwesome.Wpf proper Case Syntax) 
        /// </summary>
        /// <param name="iconName">FontAwesome.WPF Icon name (proper case name)</param>
        /// <param name="markdownActionCommand">string action from MarkupMarkdow() implementation or wrap with `html|tag`</param>
        /// <param name="toolbar"></param>
        /// <param name="command"></param>
        public void AddEditToolbarIcon(string iconName, string markdownActionCommand, ToolBar toolbar = null,
            ICommand command = null)
        {
            ImageSource icon = null;
            if (FontAwesomeIcon.TryParse(iconName, out FontAwesomeIcon iconId))
            {
                icon = ImageAwesome.CreateImageSource(iconId, ToolbarEdit.Foreground);
            }
            AddEditToolbarIcon(icon, markdownActionCommand, toolbar, command);
        }


        /// <summary>
        /// Adds an image icon to the editor toolbar 
        /// </summary>
        /// <param name="icon">An image source icon - should size well for 16px high</param>
        /// <param name="markdownActionCommand">string action from MarkupMarkdow() implementation or wrap with `html|tag`</param>
        /// <param name="toolbar"></param>
        /// <param name="command"></param>
        public void AddEditToolbarIcon(ImageSource icon, string markdownActionCommand, ToolBar toolbar = null,
            ICommand command = null)
        {
            if (toolbar == null) toolbar = ToolbarEdit;
            if (command == null) command = Model.Commands.ToolbarInsertMarkdownCommand;

            var tb = new Button() { Command = command, CommandParameter = markdownActionCommand };
            if (icon == null)
                icon = ImageAwesome.CreateImageSource(FontAwesomeIcon.QuestionCircle, ToolbarEdit.Foreground);

            tb.Content = new Image()
            {
                Source = icon,
                Height = 16,
                Margin = new Thickness(5, 0, 5, 0),
                ToolTip = markdownActionCommand
            };

            var idx = toolbar.Items.IndexOf(ButtonEmoji);
            if (idx > -1)
                toolbar.Items.Insert(idx + 1, tb);
            else
                toolbar.Items.Add(tb);

        }

        private TabItem OpenRecentDocuments()
        {
            ApplicationConfiguration conf = Model.Configuration;
            TabItem selectedTab = null;

            // prevent TabSelectionChanged to fire
            batchTabAction = true;

            // since docs are inserted at the beginning we need to go in reverse
            foreach (var doc in conf.OpenDocuments.Take(mmApp.Configuration.RememberLastDocumentsLength)) //.Reverse();
            {
                if (doc.Filename == null)
                    continue;

                if (File.Exists(doc.Filename))
                {
                    var tab = OpenTab(doc.Filename, selectTab: false,
                        batchOpen: true,
                        initialLineNumber: doc.LastEditorLineNumber);

                    if (tab == null)
                        continue;

                    var editor = tab.Tag as MarkdownDocumentEditor;
                    if (editor == null)
                        continue;

                    if (doc.IsActive)
                    {
                        selectedTab = tab;

                        // have to explicitly notify initial activation
                        // since we surpress it on all tabs during startup

                        AddinManager.Current.RaiseOnDocumentActivated(editor.MarkdownDocument);
                    }
                }
            }

            batchTabAction = false;

            return selectedTab;
        }


        void RestoreSettings()
        {
            var conf = mmApp.Configuration;

            if (conf.WindowPosition.Width != 0)
            {
                Left = conf.WindowPosition.Left;
                Top = conf.WindowPosition.Top;
                Width = conf.WindowPosition.Width;
                Height = conf.WindowPosition.Height;
                WindowUtilities.EnsureWindowIsVisible(this);
            }

            if (conf.WindowPosition.WindowState == WindowState.Maximized)
                Dispatcher.InvokeAsync(() => WindowState = WindowState.Maximized, DispatcherPriority.ApplicationIdle);


            if (mmApp.Configuration.RememberLastDocumentsLength > 0 && mmApp.Configuration.UseSingleWindow)
            {
                //var selectedDoc = conf.RecentDocuments.FirstOrDefault();
                TabItem selectedTab = null;

                string firstDoc = conf.RecentDocuments.FirstOrDefault();


                if (!App.ForceNewWindow)
                    selectedTab = OpenRecentDocuments();

                TabControl.SelectedIndex = -1;
                TabControl.SelectedItem = null;
                if (selectedTab == null)
                    TabControl.SelectedIndex = 0;
                else
                    TabControl.SelectedItem = selectedTab;

                BindTabHeaders();
            }

            Model.IsPreviewBrowserVisible = mmApp.Configuration.IsPreviewVisible;

            ShowFolderBrowser(!mmApp.Configuration.FolderBrowser.Visible);

            // force background so we have a little more contrast
            if (mmApp.Configuration.ApplicationTheme == Themes.Light)
            {
                ContentGrid.Background = (SolidColorBrush) new BrushConverter().ConvertFromString("#eee");
                ToolbarPanelMain.Background = (SolidColorBrush) new BrushConverter().ConvertFromString("#D5DAE8");
            }
            else
                ContentGrid.Background = (SolidColorBrush) new BrushConverter().ConvertFromString("#333");


            //Button Name = "ButtonLink" Margin = "7,0" ToolTip = "Insert link (Ctrl+K)"
            //Command = "{Binding Commands.ToolbarInsertMarkdownCommand }"
            //CommandParameter = "href"
            //fa: Awesome.Content = "ExternalLink"


            //TextElement.FontFamily = "pack://application:,,,/FontAwesome.WPF;component/#FontAwesome"
            //                         />
            foreach (var buttonItem in Model.Configuration.Editor.AdditionalToolbarIcons)
            {
                AddEditToolbarIcon(buttonItem.Key, buttonItem.Value);
            }

        }

        /// <summary>
        /// Save active settings of the UI that are persisted in the configuration
        /// </summary>
        public void SaveSettings()
        {
            var config = mmApp.Configuration;

            if (Model != null)
                config.IsPreviewVisible = Model.IsPreviewBrowserVisible;
            config.WindowPosition.IsTabHeaderPanelVisible = true;

            if (WindowState == WindowState.Normal)
            {
                config.WindowPosition.Left = mmFileUtils.TryConvertToInt32(Left);
                config.WindowPosition.Top = mmFileUtils.TryConvertToInt32(Top);
                config.WindowPosition.Width = mmFileUtils.TryConvertToInt32(Width, 900);
                config.WindowPosition.Height = mmFileUtils.TryConvertToInt32(Height, 700);
            }

            if (WindowState != WindowState.Minimized)
                config.WindowPosition.WindowState = WindowState;


            if (LeftSidebarColumn.Width.Value > 20)
            {
                if (LeftSidebarColumn.Width.IsAbsolute)
                    config.FolderBrowser.WindowWidth =
                        mmFileUtils.TryConvertToInt32(LeftSidebarColumn.Width.Value, 220);
                config.FolderBrowser.Visible = true;
            }
            else
                config.FolderBrowser.Visible = false;

            config.FolderBrowser.FolderPath = FolderBrowser.FolderPath;


            if (!App.ForceNewWindow)
                SaveOpenDocuments();
            else
            {
                // only save if no other instances are open
                if (!Process.GetProcesses()
                    .Any(p => p.ProcessName.Equals("markdownmonster", StringComparison.InvariantCultureIgnoreCase)))
                    SaveOpenDocuments();
            }

            config.Write();
        }


        /// <summary>
        /// Keeps track of the open documents based on the tabs
        /// that are open along with the tab order.
        /// </summary>
        void SaveOpenDocuments()
        {
            var config = Model.Configuration;
            config.OpenDocuments.Clear();
            if (mmApp.Configuration.RememberLastDocumentsLength > 0)
            {
                IEnumerable<DragablzItem> headers = null;
                try
                {
                    var ditems = GetDragablzItems();
                    headers = TabControl.HeaderItemsOrganiser.Sort(ditems);
                }
                catch (Exception ex)
                {
                    mmApp.Log("TabControl.GetOrderedHeaders() failed. Saving unordered.", ex,
                        logLevel: LogLevels.Warning);

                    // This works, but doesn't keep tab order intact
                    headers = new List<DragablzItem>();
                    foreach (var recent in config.RecentDocuments.Take(config.RememberLastDocumentsLength))
                    {
                        var tab = GetTabFromFilename(recent);

                        if (dragablzItem.Content is TabItem tab)
                            ((List<DragablzItem>) headers).Add(new DragablzItem() {Content = tab});
                    }
                }

                if (headers != null)
                {
                    // Important: collect all open tabs in the **original tab order**
                    foreach (var dragablzItem in headers)
                    {
                        if (dragablzItem == null)
                            continue;

                        var editor = tab.Tag as MarkdownDocumentEditor;
                        var doc = editor?.MarkdownDocument;
                        if (doc == null)
                            continue;

                        doc.LastEditorLineNumber = editor.GetLineNumber();
                        if (doc.LastEditorLineNumber < 1)
                            doc.LastEditorLineNumber = editor.InitialLineNumber; // if document wasn't accessed line is never set
                        if (doc.LastEditorLineNumber < 0)
                            doc.LastEditorLineNumber = 0;

                        config.OpenDocuments.Add(new OpenFileDocument(doc));
                    }
                }

                // now figure out which were recent
                var recents = mmApp.Configuration.RecentDocuments.Take(mmApp.Configuration.RememberLastDocumentsLength)
                    .ToList();

                // remove all those that aren't in the recent list
                var removeList = new List<OpenFileDocument>();
                foreach (var doc in config.OpenDocuments)
                {
                    if (!recents.Any(r => r.Equals(doc.Filename, StringComparison.InvariantCultureIgnoreCase)))
                        removeList.Add(doc);
                }

                foreach (var remove in removeList)
                    config.OpenDocuments.Remove(remove);
            }
        }


        public bool SaveFile(bool secureSave = false)
        {
            var tab = TabControl.SelectedItem as TabItem;
            if (tab == null)
                return false;

            var editor = tab.Tag as MarkdownDocumentEditor;
            var doc = editor?.MarkdownDocument;
            if (doc == null)
                return false;

            // prompt for password on a secure save
            if (secureSave && editor.MarkdownDocument.Password == null)
            {
                var pwdDialog = new FilePasswordDialog(editor.MarkdownDocument, false);
                pwdDialog.ShowDialog();
            }

            if (!editor.SaveDocument())
            {
                //var res = await this.ShowMessageOverlayAsync("Unable to save Document",
                //    "Unable to save document most likely due to missing permissions.");

                MessageBox.Show("Unable to save document most likely due to missing permissions.",
                    mmApp.ApplicationName);
                return false;
            }

            return true;
        }
        #endregion

        #region Remote Activation: Singleton Pipe and Web Server access

        /// <summary>
        /// Internal instance of a local Web Server that can be used to push commands
        /// to Markdown Monster.
        /// </summary>
        public WebServer WebServer = null;
       
      

        private void HandleNamedPipe_OpenRequest(string filesToOpen)
        {
            Dispatcher.Invoke(() =>
            {
                if (!string.IsNullOrEmpty(filesToOpen))
                {
                    var parms = StringUtils.GetLines(filesToOpen.Trim());

                    var opener = new CommandLineOpener(this);
                    opener.OpenFilesFromCommandLine(parms);

                    BindTabHeaders();
                }

                Topmost = true;

                if (WindowState == WindowState.Minimized)
                    WindowState = WindowState.Normal;

                WindowUtilities.SetForegroundWindow(Hwnd);

                Dispatcher.InvokeAsync(() => Topmost = false, DispatcherPriority.ApplicationIdle);
            });
        }

        #endregion

        #region Tab Handling

        /// <summary>
        /// High level wrapper around OpenTab() that checks for
        /// different file types like images and projects that
        /// have non-tab behavior.
        ///
        /// Use this function for generically opening files
        /// by filename .
        /// </summary>
        /// <param name="filename"></param>
        /// <param name="showPreviewIfActive"></param>
        /// <param name="syntax"></param>
        /// <param name="selectTab"></param>
        /// <param name="rebindTabHeaders"></param>
        /// <param name="batchOpen"></param>
        /// <param name="initialLineNumber"></param>
        /// <param name="readOnly"></param>
        /// <param name="noFocus"></param>
        /// <param name="isPreview"></param>
        /// <param name="noShellNavigation">If true last resort editing will open in editor rather than shell execute</param>
        /// <returns>Tab or Null</returns>
        public TabItem OpenFile(string filename,
            MarkdownDocumentEditor editor = null,
            bool showPreviewIfActive = false,
            string syntax = "markdown",
            bool selectTab = true,
            bool rebindTabHeaders = false,
            bool batchOpen = false,
            int initialLineNumber = 0,
            bool readOnly = false,
            bool noFocus = false,
            bool isPreview = false,
            bool noShellNavigation = false)
        {
            if (string.IsNullOrEmpty(filename))
                return null;

            var ext = Path.GetExtension(filename).ToLowerInvariant();
            var fname = Path.GetFileName(filename);

            if (filename.Contains('%'))
            {
                filename = Environment.ExpandEnvironmentVariables(filename);
            }

            if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
            {
                return OpenBrowserTab(filename, isImageFile: true);
            }

            if (ext == ".mdproj")
            {
                Model.Commands.LoadProjectCommand.Execute(filename);
                return null;
            }

            // Executables - don't execute but open in Explorer
            if (StringUtils.Inlist(ext, ".exe", ".ps1", ".bat", ".cmd", ".vbs", ".sh", ".com", ".reg"))
            {
                ShellUtils.OpenFileInExplorer(filename);
                return null;
            }

            string format = "markdown";

            format = mmFileUtils.GetEditorSyntaxFromFileType(filename);

            // Open a Tab for editable formats
            if (!string.IsNullOrEmpty(format) || noShellNavigation)
            {
                if (string.IsNullOrEmpty(format))
                    format = "markdown";

                if (!noFocus && PreviewTab != null)
                    CloseTab(PreviewTab);

                var tab = ActivateTab(filename, false, false, !showPreviewIfActive,
                    !selectTab, noFocus, readOnly, isPreview);
                if (tab != null)
                {
                    if (initialLineNumber > 0)
                    {
                        if (tab.Tag is MarkdownDocumentEditor ed)
                            Dispatcher.InvokeAsync(() => ed.GotoLine(initialLineNumber), DispatcherPriority.ApplicationIdle);
                    }

                    return tab;
                }

                return OpenTab(filename, editor, showPreviewIfActive, syntax,
                    selectTab, rebindTabHeaders, batchOpen,
                    initialLineNumber, readOnly, noFocus, isPreview);
            }

            try
            {
                if (File.Exists(filename))
                    ShellUtils.GoUrl(filename);
                else
                    ShowStatusError($"Can't open file {filename}. File doesn't exist.");
            }
            catch
            {
                ShowStatusError($"Unable to open file {filename}");
            }

            return null;
        }


        ///  <summary>
        ///  Opens a tab by a filename
        ///  </summary>
        ///  <param name="mdFile"></param>
        ///  <param name="editor"></param>
        ///  <param name="showPreviewIfActive"></param>
        ///  <param name="syntax"></param>
        ///  <param name="selectTab"></param>
        ///  <param name="rebindTabHeaders">
        ///  Rebinds the headers which should be done whenever a new Tab is
        ///  manually opened and added but not when opening in batch.
        ///
        ///  Checks to see if multiple tabs have the same filename open and
        ///  if so displays partial path.
        ///
        ///  New Tabs are opened at the front of the tab list at index 0
        ///  </param>
        /// <param name="batchOpen"></param>
        /// <param name="initialLineNumber"></param>
        /// <param name="readOnly"></param>
        /// <param name="noFocus"></param>
        /// <param name="isPreview"></param>
        /// <returns></returns>
        public TabItem OpenTab(string mdFile = null,
            MarkdownDocumentEditor editor = null,
            bool showPreviewIfActive = false,
            string syntax = "markdown",
            bool selectTab = true,
            bool rebindTabHeaders = false,
            bool batchOpen = false,
            int initialLineNumber = 0,
            bool readOnly = false,
            bool noFocus = false,
            bool isPreview = false)
        {
            if (mdFile != null && mdFile != "untitled" &&
                (!File.Exists(mdFile) ||
                 !AddinManager.Current.RaiseOnBeforeOpenDocument(mdFile)))
                return null;

            var tab = new TabItem();
            tab.Background = Background;


            if (mdFile != null)
            {
                var ext = Path.GetExtension(mdFile).ToLowerInvariant();
                if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
                {
                    return OpenBrowserTab(mdFile, isImageFile: true);
                }
            }

            HeaderedControlHelper.SetHeaderFontSize(tab, 13f);
            
            if (editor == null)
            {
                editor = new MarkdownDocumentEditor
                {
                    Window = this,
                    InitialLineNumber = initialLineNumber,
                    IsReadOnly = readOnly,
                    NoInitialFocus = noFocus,
                    IsPreview = isPreview
                };

                tab.Content = editor.EditorPreviewPane;
                tab.Tag = editor;


                // tab is temporary until edited
                if (isPreview)
                {
                    if (PreviewTab != null && PreviewTab != tab)
                        TabControl.Items.Remove(PreviewTab);
                    PreviewTab = tab;
                }

                var doc = new MarkdownDocument() {
                    Filename = mdFile ?? "untitled",
                    EditorSyntax = "markdown",
                    Dispatcher = Dispatcher};
                if (doc.Filename != "untitled")
                {
                    doc.Filename = FileUtils.GetPhysicalPath(doc.Filename);

                    if (doc.HasBackupFile())
                    {
                        try
                        {
                            ShowStatusError("Auto-save recovery files have been found and opened in the editor.");
                            {
                                File.Copy(doc.BackupFilename, doc.BackupFilename + ".md");
                                OpenTab(doc.BackupFilename + ".md");
                                File.Delete(doc.BackupFilename + ".md");
                            }
                        }
                        catch (Exception ex)
                        {
                            string msg = "Unable to open backup file: " + doc.BackupFilename + ".md";
                            mmApp.Log(msg, ex);
                            MessageBox.Show(
                                "A backup file was previously saved, but we're unable to open it.\r\n" + msg,
                                "Cannot open backup file",
                                MessageBoxButton.OK,
                                MessageBoxImage.Warning);
                        }
                    }

                    if (doc.Password == null && doc.IsFileEncrypted())
                    {
                        var pwdDialog = new FilePasswordDialog(doc, true) {Owner = this};
                        bool? pwdResult = pwdDialog.ShowDialog();
                        if (pwdResult == false)
                        {
                            ShowStatus("Encrypted document not opened, due to missing password.",
                                mmApp.Configuration.StatusMessageTimeout);

                            return null;
                        }
                    }


                    if (!doc.Load())
                    {
                        if (!batchOpen)
                        {
                            var msg = "Most likely you don't have access to the file";
                            if (doc.Password != null && doc.IsFileEncrypted())
                                msg = "Invalid password for opening this file";
                            var file = Path.GetFileName(doc.Filename);

                            MessageBox.Show(
                                $"{msg}.\r\n\r\n{file}",
                                "Can't open File", MessageBoxButton.OK,
                                MessageBoxImage.Warning);
                        }

                        return null;
                    }
                }

                editor.MarkdownDocument = doc;
                SetTabHeaderBinding(tab, doc, "FilenameWithIndicator");
            }
            else
                tab.Tag = editor;

            var filename = Path.GetFileName(editor.MarkdownDocument.Filename);
            editor.LoadDocument();

            // is the tab already open?
            TabItem existingTab = null;
            if (filename != "untitled")
            {
                foreach (TabItem tb in TabControl.Items)
                {
                    var lEditor = tb.Tag as MarkdownDocumentEditor;
                    if (lEditor == null)
                        continue;

                    if (lEditor.MarkdownDocument.Filename == editor.MarkdownDocument.Filename)
                    {
                        existingTab = tb;
                        break;
                    }
                }
            }

            if (existingTab != null)
                TabControl.Items.Remove(existingTab);

            tab.IsSelected = false;
            if (TabControl.Items.Count > 0)
                TabablzControl.AddItem(tab, TabControl.Items[0], AddLocationHint.First);
            else
                TabControl.Items.Insert(0, tab);


            // Make the tab draggable for moving into bookmarks or anything else that can accept filenames
            // have to drag down - sideways drag re-orders.
            try
            {
                var dragablzItem = GetDragablzItemFromTabItem(tab);
                if (dragablzItem != null)
                {
                    dragablzItem.PreviewMouseMove += DragablzItem_PreviewMouseMove;
                    dragablzItem.PreviewMouseLeftButtonDown += DragablzItem_PreviewMouseLeftButtonDown;
                    //dragablzItem.PreviewGiveFeedback += (object sender, GiveFeedbackEventArgs e) =>
                    //{
                    //    //e.Effects = DragDropEffects.Copy;
                    //    e.UseDefaultCursors = true;
                    //    if (Cursor != Cursors.Cross)
                    //        Mouse.SetCursor(Cursors.Cross);
                    //};
                }
            }
            catch (Exception ex)
            {
                // this failure can be caused if there's a modal dialog popped up when the app starts
                mmApp.Log("Failed to load DragablzItem for tab drag and drop", ex, false, LogLevels.Warning);
            }


            if (selectTab)
            {
                TabControl.SelectedItem = tab;
                SetWindowTitle();
            }


            if (!isPreview)
            {
                Model.OpenDocuments.Add(editor.MarkdownDocument);
                if (!string.IsNullOrEmpty(editor.MarkdownDocument.Filename) &&
                    !editor.MarkdownDocument.Filename.Equals("untitled", StringComparison.InvariantCultureIgnoreCase))
                    Model.Configuration.LastFolder = Path.GetDirectoryName(editor.MarkdownDocument.Filename);

            }

            AddinManager.Current.RaiseOnAfterOpenDocument(editor.MarkdownDocument);


            if (rebindTabHeaders)
                BindTabHeaders();

            // force tabstate bindings to update
            Model.OnPropertyChanged(nameof(AppModel.IsTabOpen));
            Model.OnPropertyChanged(nameof(AppModel.IsNoTabOpen));

            return tab;
        }




        private void TabControl_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (batchTabAction)
                return;



            var editor = GetActiveMarkdownEditor();
            if (editor == null)
                return;


            var tab = TabControl.SelectedItem as TabItem;

            SetWindowTitle();

            foreach (var doc in Model.OpenDocuments)
                doc.IsActive = false;

            Model.ActiveDocument = editor.MarkdownDocument;
            Model.ActiveDocument.IsActive = true;

            AddRecentFile(Model.ActiveDocument?.Filename, noConfigWrite: true);

            AddinManager.Current.RaiseOnDocumentActivated(Model.ActiveDocument);

            ((Grid) PreviewBrowserContainer.Parent)?.Children.Remove(PreviewBrowserContainer);
            editor.EditorPreviewPane.PreviewBrowserContainer.Children.Add(PreviewBrowserContainer);

            if (tab.Content is Grid grid)
                grid.Children.Add(PreviewBrowserContainer);


            // handle preview tab closing
            if (PreviewTab != null && tab != PreviewTab)
            {
                if (PreviewTab.Tag == null)
                    CloseTab(PreviewTab); // browser preview
                else
                {
                    // preview Markdown Tab
                    if (PreviewTab.Tag is MarkdownDocumentEditor changedDoc)
                    {
                        if (changedDoc.IsDirty())
                        {
                            // keep the document open
                            changedDoc.IsPreview = false;
                            PreviewTab = null;
                        }
                        else
                            CloseTab(PreviewTab);
                    }
                }
            }


            Model.WindowLayout.IsPreviewVisible = mmApp.Configuration.IsPreviewVisible;

            if (mmApp.Configuration.IsPreviewVisible)
                PreviewBrowser?.PreviewMarkdown();

            editor.RestyleEditor();
            // Don't automatically set focus - we need to do this explicitly
            //editor.SetEditorFocus();

            Dispatcher.InvokeAsync(() => { UpdateDocumentOutline(); }, DispatcherPriority.ApplicationIdle);
        }


        /// <summary>
        /// Refreshes an already loaded tab with contents of a new (or the same file) file
        /// by just replacing the document's text.
        ///
        /// If the tab is not found a new tab is opened.
        ///
        /// Note: File must already be open for this to work
        /// </summary>
        /// <param name="editorFile">File name to display int the tab</param>
        /// <param name="maintainScrollPosition">If possible preserve scroll position if refreshing</param>
        /// <param name="noPreview">If true don't refresh the preview after updating the file</param>
        /// <param name="noSelectTab"></param>
        /// <param name="noFocus">if true don't focus the editor</param>
        /// <param name="readOnly">if true document can't be edited</param>
        /// <param name="isPreview">Determines whether this tab is treated like a preview tab</param>
        /// <returns>selected tab item or null</returns>
        public TabItem RefreshTabFromFile(string editorFile,
            bool maintainScrollPosition = false,
            bool noPreview = false,
            bool noSelectTab = false,
            bool noFocus = false,
            bool readOnly = false,
            bool isPreview = false)
        {

            var tab = GetTabFromFilename(editorFile);
            if (tab == null)
                return OpenTab(editorFile, rebindTabHeaders: true, readOnly: readOnly, noFocus: noFocus,
                    selectTab: !noSelectTab, isPreview: isPreview);

            // load the underlying document
            var editor = tab.Tag as MarkdownDocumentEditor;
            if (editor == null)
                return null;

            editor.IsPreview = isPreview;
            if (isPreview)
                PreviewTab = tab;
            else
                PreviewTab = null;

            editor.MarkdownDocument.Load(editorFile);

            if (!maintainScrollPosition)
                editor.SetCursorPosition(0, 0);

            editor.SetMarkdown(editor.MarkdownDocument.CurrentText);

            if (!noSelectTab)
                TabControl.SelectedItem = tab;
            if (!noFocus)
                editor.SetEditorFocus();
            editor.IsPreview = isPreview;

            if (!noPreview)
                PreviewMarkdownAsync();

            return tab;
        }

        /// <summary>
        /// Activates a tab from an active tab instance
        /// </summary>
        /// <param name="tab"></param>
        /// <returns></returns>
        public TabItem ActivateTab(TabItem tab, bool setFocus = false)
        {
            TabControl.SelectedItem = tab;

            if (setFocus)
                Dispatcher.InvokeAsync(() => Model.ActiveEditor.SetEditorFocus(), DispatcherPriority.ApplicationIdle);

            return tab;
        }

        /// <summary>
        /// Activates a tab by checking from a filename and activating
        /// or optionally open the a new tab.
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public TabItem ActivateTab(string filename, bool openIfNotFound = false,
            bool maintainScrollPosition = false,
            bool noPreview = false,
            bool noSelectTab = false,
            bool noFocus = false,
            bool readOnly = false,
            bool isPreview = false)
        {
            var tab = GetTabFromFilename(filename);
            if (tab == null)
                return OpenTab(filename, rebindTabHeaders: true, readOnly: readOnly, noFocus: noFocus,
                    selectTab: !noSelectTab, isPreview: isPreview);

            // load the underlying document
            var editor = tab.Tag as MarkdownDocumentEditor;
            if (editor == null)
                return null;

            editor.IsPreview = isPreview;
            if (isPreview)
                PreviewTab = tab;
            else
                PreviewTab = null;

            if (!maintainScrollPosition)
                editor.SetCursorPosition(0, 0);

            if (!noSelectTab)
                TabControl.SelectedItem = tab;
            if (!noFocus)
                editor.SetEditorFocus();

            if (!noPreview)
                PreviewMarkdownAsync();

            ActivateTab(tab);

            return tab;
        }

        /// <summary>
        /// Opens a preview tab
        /// </summary>
        /// <param name="url"></param>
        /// <param name="selectTab"></param>
        /// <returns></returns>
        public TabItem OpenBrowserTab(string url,
            bool selectTab = true,
            bool isImageFile = false,
            ImageSource icon = null,
            string tabHeaderText = "Preview")
        {

            // if a document preview tab is open close it
            if (PreviewTab?.Tag is MarkdownDocumentEditor)
            {
                var tab = PreviewTab;
                PreviewTab = null;
                CloseTab(tab);
            }

            if (PreviewTab == null)
            {
                PreviewTab = new TabItem();

                var grid = new Grid();
                PreviewTab.Header = grid;
                var col1 = new ColumnDefinition {Width = new GridLength(20)};
                var col2 = new ColumnDefinition {Width = GridLength.Auto};
                grid.ColumnDefinitions.Add(col1);
                grid.ColumnDefinitions.Add(col2);

                if (icon == null)
                {
                    if (isImageFile)
                        icon = FolderStructure.IconList.GetIconFromType("image");
                    else
                        icon = FolderStructure.IconList.GetIconFromType("preview");
                }

                var img = new Image()
                {
                    Source = icon, Height = 16, Margin = new Thickness(0, 1, 5, 0), Name = "IconImage"
                };
                img.SetValue(Grid.ColumnProperty, 0);
                grid.Children.Add(img);


                var textBlock = new TextBlock
                {
                    Name = "HeaderText",
                    Text = tabHeaderText,
                    FontWeight = FontWeights.SemiBold,
                    FontStyle = FontStyles.Italic
                };
                textBlock.SetValue(Grid.ColumnProperty, 1);
                grid.Children.Add(textBlock);

                HeaderedControlHelper.SetHeaderFontSize(PreviewTab, 13F);

                previewBrowser = new IEWebBrowserControl();
                PreviewTab.Content = previewBrowser;
                TabControl.Items.Add(PreviewTab);

                PreviewTab.HorizontalAlignment = HorizontalAlignment.Right;
                PreviewTab.HorizontalContentAlignment = HorizontalAlignment.Right;
            }
            else
            {
                if (icon == null)
                {
                    if (isImageFile)
                        icon = FolderStructure.IconList.GetIconFromType("image");
                    else
                        icon = FolderStructure.IconList.GetIconFromType("preview");
                }


                var grid = PreviewTab.Header as Grid;


                var imgCtrl = grid.Children[0] as Image; //.FindChild<Image>("IconImage");
                imgCtrl.Source = icon;
                var header = grid.Children[1] as TextBlock; // FindChild<TextBlock>("HeaderText");
                header.Text = tabHeaderText;


            }

            PreviewTab.ToolTip = url;

            try
            {

                if (isImageFile)
                {
                    // Image files get a special preview tab that displays an HTML page with image link                    
                    var file = Path.Combine(App.InitialStartDirectory, "PreviewThemes", "ImagePreview.html");
                    string fileInfo = null;

                    try
                    {
                        string filename = Path.GetFileName(url);
                        string fileDimension;
                        using (var bmp = new Bitmap(url))
                        {
                            fileDimension = $"{bmp.Width}x{bmp.Height}";
                        }

                        var fileSize = ((decimal) (new FileInfo(url).Length) / 1000).ToString("N1");
                        fileInfo = $"<b>{filename}</b> - {fileDimension} &nbsp; {fileSize}kb";
                    }
                    catch
                    {
                    }

                    var content = File.ReadAllText(file).Replace("{{imageUrl}}", url).Replace("{{fileInfo}}", fileInfo);
                    File.WriteAllText(file.Replace("ImagePreview.html", "_ImagePreview.html"), content);
                    url = Path.Combine(App.InitialStartDirectory, "PreviewThemes", "_ImagePreview.html");
                }

                previewBrowser.Navigate(url);
            }
            catch
            {
                previewBrowser.Navigate("about: blank");
            }

            if (PreviewTab != null && selectTab)
                TabControl.SelectedItem = PreviewTab;

            // HACK: force refresh of display model
            Model.OnPropertyChanged(nameof(AppModel.IsTabOpen));
            Model.OnPropertyChanged(nameof(AppModel.IsNoTabOpen));

            return PreviewTab;
        }


        /// <summary>
        /// Closes a tab and ask for confirmation if the tab doc
        /// is dirty.
        /// </summary>
        /// <param name="tab"></param>
        /// <param name="rebindTabHeaders">
        /// When true tab headers are rebound to handle duplicate filenames
        /// with path additions.
        /// </param>
        /// <param name="dontPromptForSave"></param>
        /// <returns>true if tab can close, false if it should stay open</returns>
        public bool CloseTab(TabItem tab, bool rebindTabHeaders = true, bool dontPromptForSave = false)
        {
            if (tab == null)
                return false;

            if (tab == PreviewTab)
            {
                tab.Content = null;
                PreviewTab = null;
                TabControl.Items.Remove(tab);

                tab.Tag = null;
                tab = null;
                return true;
            }

            var editor = tab?.Tag as MarkdownDocumentEditor;
            if (editor == null)
                return false;

            bool returnValue = true;

            tab.Padding = new Thickness(200);

            var doc = editor.MarkdownDocument;

            doc.CleanupBackupFile();

            if (doc.IsDirty && !dontPromptForSave)
            {
                var res = MessageBox.Show(this, Path.GetFileName(doc.Filename) + "\r\n\r\nhas been modified.\r\n" +
                                          "Do you want to save changes?",
                    "Save Document",
                    MessageBoxButton.YesNoCancel, MessageBoxImage.Question, MessageBoxResult.Cancel);
                if (res == MessageBoxResult.Cancel)
                {
                    return false; // don't close
                }

                if (res == MessageBoxResult.No)
                {
                    // close but don't save
                }
                else
                {
                    if (doc.Filename == "untitled")
                        Model.Commands.SaveAsCommand.Execute(ButtonSaveAsFile);
                    else if (!SaveFile())
                        returnValue = false;
                }
            }

            doc.LastEditorLineNumber = editor.GetLineNumber();
            if (doc.LastEditorLineNumber == -1)
                doc.LastEditorLineNumber = 0;


            // *** IMPORTANT: Clean up Tab controls
            editor.ReleaseEditor();
            tab.Tag = null;
            editor = null;
            TabControl.Items.Remove(tab);
            tab = null;

            if (TabControl.Items.Count == 0)
            {
                Model.ActiveDocument = null;
                StatusStats.Text = null;

                TabDocumentOutline.Visibility = Visibility.Collapsed;
                if (SidebarContainer.SelectedItem == TabDocumentOutline)
                    SidebarContainer.SelectedItem = TabFolderBrowser;

                Title = "Markdown Monster" +
                        (UnlockKey.IsUnlocked ? "" : " (unregistered)");
                Model.Window.Focus();
            }

            if (rebindTabHeaders)
                BindTabHeaders();

            Model.OnPropertyChanged(nameof(AppModel.IsTabOpen));
            Model.OnPropertyChanged(nameof(AppModel.IsNoTabOpen));

            return returnValue; // close
        }

        /// <summary>
        /// Closes a tab and ask for confirmation if the tab doc
        /// is dirty.
        /// </summary>
        /// <param name="filename">
        /// The absolute path to the file opened in the tab that
        /// is going to be closed
        /// </param>
        /// <returns>true if tab can close, false if it should stay open or
        /// filename not opened in any tab</returns>
        public bool CloseTab(string filename)
        {
            var tab = GetTabFromFilename(filename);

            if (tab != null)
                return CloseTab(tab);

            return false;
        }

        public bool CloseAllTabs(TabItem allExcept = null)
        {
            batchTabAction = true;
            for (int i = TabControl.Items.Count - 1; i > -1; i--)
            {
                if (TabControl.Items[i] is TabItem tab)
                {
                    if (allExcept != null && tab == allExcept)
                        continue;

                    if (!CloseTab(tab, rebindTabHeaders: false))
                        return false;
                }
            }

            batchTabAction = false;

            return true;
        }


        /// <summary>
        /// Retrieves an open tab based on its filename.
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public TabItem GetTabFromFilename([CanBeNull] string filename)
        {
            if (string.IsNullOrEmpty(filename))
                return null;

            if (filename == "Preview")
                return PreviewTab;

            TabItem tab = null;
            foreach (TabItem tabItem in TabControl.Items.Cast<TabItem>())
            {
                string tabFile =
                    (tabItem.Tag as MarkdownDocumentEditor)?.MarkdownDocument?.Filename ??
                    (tabItem.ToolTip as string);

                if (tabFile == null)
                    continue;

                if (tabFile.Equals(filename, StringComparison.InvariantCultureIgnoreCase))
                {
                    tab = tabItem;
                    break;
                }
            }

            return tab;
        }

        private void TabControl_OnPreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            // Explicitly force focus into the editor
            // Programmatic tab selection does not automatically set focus
            // unless explicitly specified. Click on a tab explicitly sets focus
            // via this operation.
            Model.ActiveEditor?.SetEditorFocus();
        }

        /// <summary>
        ///  Flag used to let us know we don't want to perform tab selection operations
        /// </summary>
        internal bool batchTabAction = false;

        /// <summary>
        /// Binds all Tab Headers
        /// </summary>
        public void BindTabHeaders()
        {
            var tabList = new List<TabItem>();
            foreach (TabItem tb in TabControl.Items)
                tabList.Add(tb);

            var tabItems = tabList
                .Where(tb => tb.Tag is MarkdownDocumentEditor)
                .Select(tb => Path.GetFileName(((MarkdownDocumentEditor) tb.Tag).MarkdownDocument.Filename.ToLower()))
                .GroupBy(fn => fn)
                .Select(tbCol => new {Filename = tbCol.Key, Count = tbCol.Count()});

            foreach (TabItem tb in TabControl.Items)
            {
                var doc = ((MarkdownDocumentEditor) tb.Tag)?.MarkdownDocument;
                if (doc == null)
                    continue;

                if (tabItems.Any(ti => ti.Filename == Path.GetFileName(doc.Filename.ToLower()) &&
                                       ti.Count > 1))

                    SetTabHeaderBinding(tb, doc, "FilenamePathWithIndicator");
                else
                    SetTabHeaderBinding(tb, doc, "FilenameWithIndicator");
            }
        }

        /// <summary>
        /// Returns a list of DragablzItems
        /// </summary>
        /// <returns></returns>
        public List<DragablzItem> GetDragablzItems()
        {
            // UGLY UGLY Hack but only way to get access to the internal controls of Dragablz
            var control = ReflectionUtils.GetField(TabControl, "_dragablzItemsControl") as DragablzItemsControl;
            if (control == null)
            {
                throw new InvalidOperationException("_dragablzItemsControl is null");
            }

            var ditems = ReflectionUtils.CallMethod(control, "DragablzItems") as List<DragablzItem>;
            return ditems;
        }

        /// <summary>
        /// Returns a DragablzItem from a TabItem
        /// </summary>
        /// <param name="tab"></param>
        /// <returns></returns>
        public DragablzItem GetDragablzItemFromTabItem(TabItem tab)
        {
            var items = GetDragablzItems();
            return items.FirstOrDefault(it => it.Content as TabItem == tab);
        }


        /// <summary>
        /// Binds the tab header to our custom controls/container that
        /// shows a customized tab header
        /// </summary>
        /// <param name="tab"></param>
        /// <param name="document"></param>
        /// <param name="propertyPath"></param>
        private void SetTabHeaderBinding(TabItem tab, MarkdownDocument document,
            string propertyPath = "FilenameWithIndicator",
            ImageSource icon = null)
        {
            if (document == null || tab == null)
                return;
            var editor = tab.Tag as MarkdownDocumentEditor;

            try
            {
                var grid = new Grid();

                tab.Header = grid;
                var col1 = new ColumnDefinition {Width = new GridLength(20)};
                var col2 = new ColumnDefinition {Width = GridLength.Auto};
                grid.ColumnDefinitions.Add(col1);
                grid.ColumnDefinitions.Add(col2);



                if (icon == null)
                {
                    icon = FolderStructure.IconList.GetIconFromFile(document.Filename);
                    if (icon == AssociatedIcons.DefaultIcon && Model.ActiveEditor != null)
                        icon = FolderStructure.IconList.GetIconFromType(Model.ActiveEditor.MarkdownDocument.EditorSyntax);
                }

                var img = new Image() {Source = icon, Height = 16, Margin = new Thickness(0, 1, 5, 0)};
                img.SetValue(Grid.ColumnProperty, 0);
                grid.Children.Add(img);


                var textBlock = new TextBlock();
                textBlock.SetValue(Grid.ColumnProperty, 1);


                var headerBinding = new Binding
                {
                    Source = document, Path = new PropertyPath(propertyPath), Mode = BindingMode.OneWay
                };
                BindingOperations.SetBinding(textBlock, TextBlock.TextProperty, headerBinding);

                var tooltipBinding = new Binding
                {
                    Source = document, Path = new PropertyPath("Filename"), Mode = BindingMode.OneWay
                };
                BindingOperations.SetBinding(tab,TabItem.ToolTipProperty, tooltipBinding);

                var fontStyleBinding = new Binding
                {
                    Source = editor,
                    Path = new PropertyPath("IsPreview"),
                    Mode = BindingMode.OneWay,
                    Converter = new FontStyleFromBoolConverter()
                };
                BindingOperations.SetBinding(textBlock, TextBlock.FontStyleProperty, fontStyleBinding);


                var fontWeightBinding = new Binding
                {
                    Source = tab,
                    Path = new PropertyPath("IsSelected"),
                    Mode = BindingMode.OneWay,
                    Converter = new FontWeightFromBoolConverter()
                };
                BindingOperations.SetBinding(textBlock, TextBlock.FontWeightProperty, fontWeightBinding);

                grid.Children.Add(textBlock);
            }
            catch
            {
                // mmApp.Log("SetTabHeaderBinding Failed. Assigning explicit path", ex);
                tab.Header = document.FilenameWithIndicator;
            }
        }


        private void TabControlDragablz_TabItemClosing(ItemActionCallbackArgs<TabablzControl> e)
        {
            var tab = e.DragablzItem.DataContext as TabItem;
            if (tab == null)
                return;

            if (!CloseTab(tab))
                e.Cancel(); // don't do default tab removal
        }

        /// <summary>
        /// Adds a new panel to the sidebar, and adds header text and icon explicitly.
        /// This overload provides a simpler way to add icon and header
        /// </summary>
        /// <param name="tabItem">Adds the TabItem. If null the tabs are refreshed and tabs removed if down to single tab</param>
        /// <param name="tabHeaderText">Optional - header text to set on the tab either just text or in combination with icon</param>
        /// <param name="tabHeaderIcon">Optional - Icon for the tab as an Image Source</param>
        /// <param name="selectItem"></param>
        public void AddLeftSidebarPanelTabItem(TabItem tabItem,
            string tabHeaderText = null,
            ImageSource tabHeaderIcon = null,
            bool selectItem = true)
        {
            if (tabItem != null)
            {
                // Create the header as Icon and Text
                var panel = new StackPanel();
                panel.Margin = new Thickness(0, 5, 0, 5);

                Image img = null;

                if (tabHeaderIcon != null)
                {
                    img = new Image {Source = tabHeaderIcon, Height = 22, ToolTip = tabHeaderText};
                    //panel.Children.Add(new TextBlock { Text = tabHeaderText });
                }
                else if (!string.IsNullOrEmpty(tabHeaderText))
                {
                    img = new Image
                    {
                        Source = ImageAwesome.CreateImageSource(FontAwesomeIcon.QuestionCircle, Brushes.SteelBlue,
                            22),
                        ToolTip = tabHeaderText
                    };
                }

                panel.Children.Add(img);
                tabItem.Header = panel;

                //ControlsHelper.SetHeaderFontSize(tabItem, 14);
                SidebarContainer.Items.Add(tabItem);

                if (selectItem)
                    SidebarContainer.SelectedItem = tabItem;
            }
        }

        /// <summary>
        /// Adds a new panel to the right sidebar
        /// </summary>
        /// <param name="tabItem">Adds the TabItem. If null the tabs are refreshed and tabs removed if down to single tab</param>
        /// <param name="tabHeaderText"></param>
        /// <param name="tabHeaderIcon"></param>
        /// <param name="selectItem"></param>
        public void AddRightSidebarPanelTabItem(TabItem tabItem = null,
            string tabHeaderText = null,
            ImageSource tabHeaderIcon = null,
            bool selectItem = true)
        {
            if (tabItem != null)
            {
                if (tabHeaderIcon != null)
                {
                    // Create the header as Icon and Text
                    var panel = new StackPanel {Orientation = Orientation.Horizontal};
                    panel.Children.Add(new Image
                    {
                        Source = tabHeaderIcon, Height = 16, Margin = new Thickness(4, 0, 4, 0)
                    });
                    panel.Children.Add(new TextBlock {Text = tabHeaderText});
                    tabItem.Header = panel;

                }
                else if (!string.IsNullOrEmpty(tabHeaderText))
                    tabItem.Header = tabHeaderText;



                HeaderedControlHelper.SetHeaderFontSize(tabItem, 14);
                RightSidebarContainer.Items.Add(tabItem);

                if (selectItem)
                    RightSidebarContainer.SelectedItem = tabItem;
            }

            ShowRightSidebar();
        }


        /// <summary>
        /// Sets the Window Title followed by Markdown Monster (registration status)
        /// by default the filename is used and it's updated whenever tabs are changed.
        ///
        /// Note: ActiveTab change causes the title to be automatically updates and
        /// generally you **don't want to set a custom title** because it'll get
        /// overwritten.
        ///
        /// Just call this when you need to have the title updated due to
        /// file name change that doesn't change the active tab.
        /// </summary>
        /// <param name="title"></param>
        public void SetWindowTitle(string title = null)
        {
            if (title == null)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                {
                    Title = "Markdown Monster" +
                             (Model.Configuration.ShowVersionNumberInTitle ? " " + mmApp.GetVersionForDisplay() : string.Empty);
                    return;
                }

                if (Model.Configuration.TitlebarDisplay == TitlebarDisplayModes.FullPath)
                    title = editor.MarkdownDocument.Filename;
                else if(Model.Configuration.TitlebarDisplay == TitlebarDisplayModes.FilenameOnly)
                    title = editor.MarkdownDocument.FilenameWithIndicator.Replace("*", "");
                else if
                    (Model.Configuration.TitlebarDisplay == TitlebarDisplayModes.FileNameAndParentPath)
                    title = editor.MarkdownDocument.FilenamePathWithIndicator.Replace("*", "");

                if (!Model.ActiveProject.IsEmpty)
                    title = title + "  " + Path.GetFileName(Model.ActiveProject.Filename);
            }

            Title = title +
                    "  - Markdown Monster " +
                    (Model.Configuration.ShowVersionNumberInTitle
                        ? mmApp.GetVersionForDisplay() + " " 
                        : "") +
                    (UnlockKey.IsUnlocked ? "" : " (unregistered)");
        }

        /// <summary>
        /// Helper method that sets editor focus
        /// </summary>
        public void SetEditorFocus()
        {
            Dispatcher.Invoke(() => Model.ActiveEditor?.SetEditorFocus());
        }

        private void TabControl_ContextMenuOpening(object sender, ContextMenuEventArgs e)
        {
            var context = new TabContextMenu();
            context.ShowContextMenu();
            e.Handled = true;
        }

        private void TabHeader_DoubleClick(object sender, MouseButtonEventArgs ev)
        {
            if (ev.ClickCount == 2)
                OpenTab("untitled");
        }

        #endregion

        #region Tab Drag and Drop

        private System.Windows.Point _dragablzStartPoint;

        private void DragablzItem_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _dragablzStartPoint = e.GetPosition(null);
        }

        /// <summary>
        ///  Drag and Drop into the BookMarks dialog
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void DragablzItem_PreviewMouseMove(object sender, MouseEventArgs e)
        {

            if (e.LeftButton == MouseButtonState.Pressed)
            {
                var curPoint = e.GetPosition(null);
                var diff = curPoint - _dragablzStartPoint;
                if (_dragablzStartPoint.Y > 0 && (diff.Y > 30 || diff.Y < -30))
                {
                    var drag = sender as DragablzItem;
                    if (drag == null)
                        return;
                    var tab = drag.Content as TabItem;

                    var editor = tab.Tag as MarkdownDocumentEditor;
                    if (editor == null)
                        return;

                    //var dragData = new DataObject(DataFormats.UnicodeText, editor.MarkdownDocument.Filename);
                    var files = new[] {editor.MarkdownDocument.Filename};
                    var dragData = new DataObject(DataFormats.FileDrop, files);

                    if (FavoritesTab.Content is FavoritesControl fav)
                        fav.IsDragging = true; // notify that we're ready to drop on favorites potentially

                    DragDrop.DoDragDrop(drag, dragData, DragDropEffects.Copy);

                    _dragablzStartPoint.Y = 0;
                    _dragablzStartPoint.X = 0;
                }
            }
        }

        #endregion

        #region Document Outline

        private void SidebarContainer_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var selected = SidebarContainer.SelectedItem as TabItem;
            if (selected == null)
                return;

            if (selected.Content is DocumentOutlineSidebarControl)
            {
                Dispatcher.InvokeAsync(() =>
                {
                    if (DocumentOutline.Model?.DocumentOutline == null)
                        UpdateDocumentOutline();
                }, DispatcherPriority.ApplicationIdle);
            }
            else if (selected.Content is FavoritesControl)
                OpenFavorites();
        }

        public void UpdateDocumentOutline(int editorLineNumber = -1)
        {
            DocumentOutline?.RefreshOutline(editorLineNumber);
        }

        public void OpenFavorites(bool noActivate = false)
        {
            if (FavoritesTab == null)
            {
                FavoritesTab = new MetroTabItem();
                FavoritesTab.Content = new FavoritesControl();

                AddLeftSidebarPanelTabItem(FavoritesTab, "Favorite Files and Folders",
                    ImageAwesome.CreateImageSource(FontAwesomeIcon.Star, Brushes.Goldenrod, 11),
                    selectItem: !noActivate);
            }
            else if (!noActivate)
            {
                SidebarContainer.SelectedItem = FavoritesTab;

                Dispatcher.InvokeAsync(() =>
                {
                    var control = FavoritesTab.Content as FavoritesControl;
                    control?.TextSearch.Focus();
                });
            }
        }



        public FileSearchControl OpenSearchPane(bool noActivate = false)
        {
            if (SearchTab == null)
            {
                SearchTab = new MetroTabItem() {Content = new FileSearchControl()};

                AddLeftSidebarPanelTabItem(SearchTab, "File Search",
                    ImageAwesome.CreateImageSource(FontAwesomeIcon.Search, Brushes.SteelBlue, 11), !noActivate);
            }
            else
            {
                SidebarContainer.SelectedItem = SearchTab;

                Dispatcher.InvokeAsync(() =>
                {
                    var control = SearchTab.Content as FileSearchControl;
                    control?.SearchPhrase.Focus();
                });
            }

            return SearchTab.Content as FileSearchControl;
        }

        #endregion


        #region Preview and UI Visibility Helpers

        public void PreviewMarkdown(MarkdownDocumentEditor editor = null, bool keepScrollPosition = false,
            bool showInBrowser = false, string renderedHtml = null)
        {
            PreviewBrowser?.PreviewMarkdown(editor, keepScrollPosition, showInBrowser, renderedHtml);
        }

        public void PreviewMarkdownAsync(MarkdownDocumentEditor editor = null, bool keepScrollPosition = false,
            string renderedHtml = null)
        {
            PreviewBrowser?.PreviewMarkdownAsync(editor, keepScrollPosition, renderedHtml);
        }


        public void Navigate(string url)
        {
            PreviewBrowser?.Navigate(url);
        }


        /// <summary>
        /// Shows or hides the preview browser
        /// </summary>
        /// <param name="hide"></param>
        public void ShowPreviewBrowser(bool hide = false, bool refresh = false)
        {
            if (!hide && Model.Configuration.PreviewMode != PreviewModes.None)
            {
                if (Model.Configuration.PreviewMode == PreviewModes.InternalPreview)
                {

                    if (Model.Configuration.IsPreviewVisible)
                        Model.WindowLayout.IsPreviewVisible = true;
                    else
                    {
                        Model.WindowLayout.IsPreviewVisible = false;
                        return;
                    }

                    // check if we're already active - if not assign and preview immediately
                    if (!(PreviewBrowser is IPreviewBrowser))
                    {
                        LoadPreviewBrowser();
                        return;
                    }

                    // close external window if it's open
                    if (_previewBrowserWindow != null && PreviewBrowserWindow.Visibility == Visibility.Visible)
                    {
                        PreviewBrowserWindow?.Close();
                        _previewBrowserWindow = null;
                        LoadPreviewBrowser();
                        return;
                    }

                    if (!refresh)
                    {
                        if (Model.Configuration.WindowPosition.SplitterPosition < 100)
                            Model.Configuration.WindowPosition.SplitterPosition = 600;
                    }
                }
                else if (Model.Configuration.PreviewMode == PreviewModes.ExternalPreviewWindow)
                {
                    // make sure it's visible
                    PreviewBrowserWindow?.Show();

                    // check if we're already active - if not assign and preview immediately
                    if (!(PreviewBrowser is PreviewBrowserWindow))
                    {
                        PreviewBrowser = PreviewBrowserWindow;
                        PreviewBrowser?.PreviewMarkdownAsync();
                    }


                    Model.WindowLayout.IsPreviewVisible = false;

                    // clear the preview
                    ((IPreviewBrowser) PreviewBrowserContainer.Children[0]).Navigate("about:blank");
                }
            }
            else
            {
                if (Model.Configuration.PreviewMode == PreviewModes.InternalPreview)
                {
                    Model.WindowLayout.IsPreviewVisible = false;
                }
                else if (Model.Configuration.PreviewMode == PreviewModes.ExternalPreviewWindow)
                {
                    if (_previewBrowserWindow != null)
                    {
                        PreviewBrowserWindow?.Close();
                        _previewBrowserWindow = null;
                        PreviewBrowser = null;
                    }
                }

            }
        }

        /// <summary>
        /// Shows or hides the File Browser
        /// </summary>
        /// <param name="hide"></param>
        /// <param name="folder">Folder or File. If File the file will be selected in the folder</param>
        public void ShowFolderBrowser(bool hide = false, string folder = null)
        {
            var layoutModel = Model.WindowLayout;
            if (hide)
            {
                layoutModel.IsLeftSidebarVisible = false;
                mmApp.Configuration.FolderBrowser.Visible = false;
            }
            else
            {
                if (folder == null)
                    folder = FolderBrowser.FolderPath;
                if (folder == null)
                    folder = mmApp.Configuration.FolderBrowser.FolderPath;

                Dispatcher.InvokeAsync(() =>
                {
                    if (string.IsNullOrEmpty(folder) && Model.ActiveDocument != null)
                        folder = Path.GetDirectoryName(Model.ActiveDocument.Filename);

                    FolderBrowser.FolderPath = folder;
                }, DispatcherPriority.ApplicationIdle);

                layoutModel.IsLeftSidebarVisible = true;
                mmApp.Configuration.FolderBrowser.Visible = true;
                SidebarContainer.SelectedIndex = 0; // folder browser tab

                Model.Configuration.LastFolder = folder;
            }
        }

        public void ShowLeftSidebar(bool hide = false)
        {
            if (!hide && SidebarContainer.Items.Count == 1)
            {
                ShowFolderBrowser();
                return;
            }

            Model.WindowLayout.IsLeftSidebarVisible = !hide;
        }

        public void ShowRightSidebar(bool hide = false)
        {
            Model.WindowLayout.IsRightSidebarVisible = !hide;
        }

        /// <summary>
        /// Create an instance of the Preview Browser either using the
        /// default IE based preview browser, or if an addin has registered
        /// a custom preview browser.
        /// </summary>
        public void LoadPreviewBrowser()
        {
            var previewBrowser = AddinManager.Current.RaiseGetPreviewBrowserControl();
            if (previewBrowser == null || PreviewBrowser != previewBrowser)
            {
                if (previewBrowser == null)
                    PreviewBrowser = new IEWebBrowserControl() {Name = "PreviewBrowser"};
                else
                    PreviewBrowser = previewBrowser;

                if (PreviewBrowserContainer == null)
                    PreviewBrowserContainer = new Grid();


                PreviewBrowserContainer.Children.Clear();
                PreviewBrowserContainer.Children.Add(PreviewBrowser as UIElement);

                ShowPreviewBrowser();
            }

            // show or hide
            PreviewMarkdownAsync();
        }

        #endregion

        #region Worker Functions

        public MarkdownDocumentEditor GetActiveMarkdownEditor()
        {
            var tab = TabControl?.SelectedItem as TabItem;
            return tab?.Tag as MarkdownDocumentEditor;
        }


        /// <summary>
        /// Check to see if the window is visible in the bounds of the
        /// virtual screen space. If not adjust to main monitor off 0 position.
        /// </summary>
        /// <returns></returns>
        void FixMonitorPosition()
        {
            var virtualScreenHeight = SystemParameters.VirtualScreenHeight;
            var virtualScreenWidth = SystemParameters.VirtualScreenWidth;


            if (Left > virtualScreenWidth - 150)
                Left = 20;
            if (Top > virtualScreenHeight - 150)
                Top = 20;

            if (Left < SystemParameters.VirtualScreenLeft)
                Left = SystemParameters.VirtualScreenLeft;
            if (Top < SystemParameters.VirtualScreenTop)
                Top = SystemParameters.VirtualScreenTop;

            if (Width > virtualScreenWidth)
                Width = virtualScreenWidth - 40;
            if (Height > virtualScreenHeight)
                Height = virtualScreenHeight - 40;
        }

        #endregion

        #region Button Handlers

        /// <summary>
        /// Generic button handler that handles a number of simple
        /// tasks in a single method to minimize class noise.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public void Button_Handler(object sender, RoutedEventArgs e)
        {
            var button = sender;
            if (button == null)
                return;

            if (button == ButtonOpenFromHtml)
            {
                var fd = new OpenFileDialog
                {
                    DefaultExt = ".htm",
                    Filter = "Html files (*.htm,*.html)|*.htm;*.html|" +
                             "All files (*.*)|*.*",
                    CheckFileExists = true,
                    RestoreDirectory = true,
                    Multiselect = true,
                    Title = "Open Html as Markdown"                    
                };

                if (!string.IsNullOrEmpty(mmApp.Configuration.LastFolder))
                    fd.InitialDirectory = mmApp.Configuration.LastFolder;

                var res = fd.ShowDialog();
                if (res == null || !res.Value)
                    return;

                string html = mmFileUtils.OpenTextFile(fd.FileName);
                if (html == null)
                    return;

                var markdown = MarkdownUtilities.HtmlToMarkdown(html);

                OpenTab("untitled");
                var editor = GetActiveMarkdownEditor();
                editor.MarkdownDocument.CurrentText = markdown;
                PreviewBrowser.PreviewMarkdown();
            }
            else if (button == ToolbarButtonRecentFiles)
            {
                var mi = button as Button;

                var contextMenu = new RecentDocumentsContextMenu(this);
                contextMenu.UpdateRecentDocumentsContextMenu(RecentFileDropdownModes.ToolbarDropdown);
                if (mi.ContextMenu != null)
                    mi.ContextMenu.IsOpen = true;
                e.Handled = true;
            }
            else if (button == ButtonExit)
            {
                Close();
            }

            else if (button == MenuOpenConfigFolder)
            {
                ShellUtils.GoUrl(mmApp.Configuration.CommonFolder);
            }
            else if (button == MenuOpenPreviewFolder)
            {
                ShellUtils.GoUrl(Path.Combine(App.InitialStartDirectory, "PreviewThemes",
                    mmApp.Configuration.PreviewTheme));
            }
            else if (button == MenuMarkdownMonsterSite)
            {
                ShellUtils.GoUrl(mmApp.Urls.WebSiteUrl);
            }
            else if (button == MenuBugReport)
            {
                ShellUtils.GoUrl(mmApp.Urls.SupportUrl);
            }
            else if (button == MenuCheckNewVersion)
            {
                ShowStatus("Checking for new version...");
                if (!ApplicationUpdater.CheckForNewVersion(true, failTimeout: 5000))
                    ShowStatusSuccess("Your version of Markdown Monster is up to date.");
            }
            else if (button == MenuRegister)
            {
                Window rf = new RegistrationForm();
                rf.Owner = this;
                rf.ShowDialog();
            }
            else if (button == ButtonAbout)
            {
                Window about = new About();
                about.Owner = this;
                about.Show();
            }
            else if (button == Button_Find)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                    return;
                editor.ExecEditorCommand("find");
            }
            else if (button == Button_FindNext)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                    return;
                editor.ExecEditorCommand("findnext");
            }
            else if (button == Button_Replace)
            {
                var editor = GetActiveMarkdownEditor();
                if (editor == null)
                    return;
                editor.ExecEditorCommand("replace");
            }
            else if (button == ButtonWordWrap ||
                     button == ButtonLineNumbers ||
                     button == ButtonShowInvisibles ||
                     button == ButtonCenteredView)
            {
                Model.ActiveEditor?.RestyleEditor();
            }
            else if (button == ButtonStatusEncrypted)
            {
                if (Model.ActiveDocument == null)
                    return;

                var dialog = new FilePasswordDialog(Model.ActiveDocument, false) {Owner = this};
                dialog.ShowDialog();
            }
            else if (button == MenuDocumentation)
                ShellUtils.GoUrl(mmApp.Urls.DocumentationBaseUrl);
            else if (button == MenuMarkdownBasics)
                ShellUtils.GoUrl(mmApp.Urls.DocumentationBaseUrl + "_4ne1eu2cq.htm");
            else if (button == MenuCreateAddinDocumentation)
                ShellUtils.GoUrl(mmApp.Urls.DocumentationBaseUrl + "_4ne0s0qoi.htm");
            else if (button == MenuShowSampleDocument)
                OpenTab(Path.Combine(App.InitialStartDirectory, "SampleMarkdown.md"));
            else if (button == MenuShowErrorLog)
            {
                string logFile = Path.Combine(mmApp.Configuration.CommonFolder, "MarkdownMonsterErrors.txt");
                if (File.Exists(logFile))
                    ShellUtils.GoUrl(logFile);
                else
                    MessageBox.Show("There are no errors in your log file.",
                        mmApp.ApplicationName,
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
            }
            else if (button == MenuResetConfiguration)
            {
                if (MessageBox.Show(
                        "This operation will reset all of your configuration settings and shut down Markdown Monster.\r\n\r\nAre you sure?",
                        "Reset Configuration Settings",
                        MessageBoxButton.YesNo, MessageBoxImage.Warning, MessageBoxResult.No) == MessageBoxResult.Yes)
                {
                    mmApp.Configuration.Backup();
                    mmApp.Configuration.Reset();
                }
            }
            else if (button == MenuBackupConfiguration)
            {
                string filename = mmApp.Configuration.Backup();
                ShowStatus($"Configuration backed up to: {Path.GetFileName(filename)}",
                    mmApp.Configuration.StatusMessageTimeout);
                ShellUtils.OpenFileInExplorer(filename);
            }
            else if (button == ButtonAllowScriptTags)
            {
                if (!Model.Configuration.MarkdownOptions.AllowRenderScriptTags &&
                    (Model.Configuration.MarkdownOptions.UseMathematics ||  Model.Configuration.MarkdownOptions.MermaidDiagrams) )
                {
                    if (MessageBox.Show(@"Disabling this option also disables:

   Mathematics 
   Mermaid Diagrams

as these options require JavaScript scripts in order to work.

Do you want to continue anyway?", "Disable Markdown Script Rendering",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Question,
                            MessageBoxResult.Yes) == MessageBoxResult.No)
                        Model.Configuration.MarkdownOptions.AllowRenderScriptTags = true;
                    else
                    {
                        Model.Configuration.MarkdownOptions.UseMathematics = false;
                        Model.Configuration.MarkdownOptions.MermaidDiagrams = false;
                    }
                }

                // force preview to refresh
                Model.Commands.RefreshPreviewCommand.Execute(null);
            }
        }

        #endregion

        #region Miscelleaneous Events

        /// <summary>
        /// Handle drag and drop of file. Note only works when dropped on the
        /// window - doesn't not work when dropped on the editor.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MainWindow_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[]) e.Data.GetData(DataFormats.FileDrop);

                foreach (var file in files)
                {
                    var ext = Path.GetExtension(file.ToLower());
                    if (File.Exists(file) && ("," +  mmApp.AllowedFileExtensions + ",").Contains($",{ext},"))
                    {
                        OpenTab(file, rebindTabHeaders: true);
                    }
                }
            }
        }

        private void PreviewBrowser_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            //if (e.NewSize.Width > 100)
            //{
            //	int width = Convert.ToInt32(MainWindowPreviewColumn.Width.Value);
            //	if (width > 100)
            //		mmApp.Configuration.WindowPosition.SplitterPosition = width;
            //}
        }

        private void EditorTheme_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            foreach (TabItem tab in TabControl.Items)
            {
                var editor = tab.Tag as MarkdownDocumentEditor;
                editor?.RestyleEditor();
            }

            PreviewBrowser?.PreviewMarkdownAsync();
        }

        private void PreviewTheme_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            Model.ActiveEditor?.AceEditor?.SetEditorStyling();
            PreviewBrowser?.PreviewMarkdownAsync();
        }


        //public void AppTheme_MenuButtonClick(object sender, RoutedEventArgs e)
        //{
        //    var button = sender as MenuItem;
        //    var text = button.Header as string;

        //    var selected = (Themes) Enum.Parse(typeof(Themes), text);
        //    var oldVal = mmApp.Configuration.ApplicationTheme;

        //    if (oldVal != selected &&
        //        MessageBox.Show("Application theme changes require that you restart.\r\n\r\nDo you want to restart Markdown Monster?",
        //                        "Theme Change", MessageBoxButton.YesNo,
        //                        MessageBoxImage.Question, MessageBoxResult.Yes) == MessageBoxResult.Yes)
        //    {
        //        mmApp.Configuration.ApplicationTheme = selected;
        //        if (mmApp.Configuration.ApplicationTheme == Themes.Light)
        //        {
        //            mmApp.Configuration.EditorTheme = "vscodelight";
        //            mmApp.Configuration.PreviewTheme = "Github";
        //        }
        //        else
        //            mmApp.Configuration.EditorTheme = "vscodedark";

        //        mmApp.Configuration.Write();

        //        PipeManager.StopServer();
        //        ForceClose = true;
        //        Close();

        //        // execute with delay
        //        ShellUtils.ExecuteProcess(Path.Combine(App.InitialStartDirectory, "MarkdownMonster.exe"), "-delay");
        //        Environment.Exit(0);
        //    }
        //}

        private void DocumentType_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (Model.ActiveEditor == null)
                return;

            Model.ActiveEditor.SetEditorSyntax(Model.ActiveEditor.MarkdownDocument.EditorSyntax);
            SetTabHeaderBinding(TabControl.SelectedItem as TabItem, Model.ActiveEditor.MarkdownDocument);

            // Refresh the Preview to show preview for html and markdown and hide it for others
            Model.Window.PreviewMarkdownAsync();
        }

        private void ButtonRecentFiles_SubmenuOpened(object sender, RoutedEventArgs e)
        {
            var menu = new RecentDocumentsContextMenu(this);
            menu.UpdateRecentDocumentsContextMenu(RecentFileDropdownModes.MenuDropDown);
        }

        private void LeftSidebarExpand_MouseDown(object sender, MouseButtonEventArgs e)
        {
            Model.Commands.OpenLeftSidebarPanelCommand.Execute(null);
        }

        private void RightSidebarExpand_MouseDown(object sender, MouseButtonEventArgs e)
        {
            Model.WindowLayout.IsRightSidebarVisible = true;
            Model.WindowLayout.RightSidebarWidth = GridLengthHelper.FromInt(300);
        }

        private void MarkdownParserName_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (mmApp.Configuration != null &&
                !string.IsNullOrEmpty(mmApp.Configuration.MarkdownOptions.MarkdownParserName))
            {
                MarkdownParserFactory.GetParser(parserAddinId: mmApp.Configuration.MarkdownOptions.MarkdownParserName,
                    forceLoad: true);
                PreviewBrowser?.PreviewMarkdownAsync();
            }
        }

        private void ButtonLangugeDropDown_Click(object sender, RoutedEventArgs e)
        {
            var context = new LanguagesContextMenu(this);
            context.OpenContextMenu();
        }


        private void ButtonWindowSizesDropdown_Click(object sender, RoutedEventArgs e)
        {
            var menu = new WindowSizesContextMenu(this);
            menu.OpenContextMenu();
        }

        private void Refresh_Styling(object sender, RoutedEventArgs e)
        {
            Model.ActiveEditor?.RestyleEditor();
        }

        #endregion

        #region Window Menu Items
        public List<MenuItem> GenerateContextMenuItemsFromOpenTabs(ContextMenu ctx = null)
        {
            var menuItems = new List<MenuItem>();
            var icons = new AssociatedIcons();
            var selectedTab = TabControl.SelectedItem as TabItem;

            var headers = TabControl.GetOrderedHeaders();
            foreach (var hd in headers)
            {
                var tab = hd.Content as TabItem;

                StackPanel sp;
                string commandParameter;
                var doc = tab.Tag as MarkdownDocumentEditor;

                if (tab == PreviewTab && doc == null)
                {
                    var icon = (tab.Header as Grid).FindChild<Image>("IconImage")?.Source;
                    var txt = (tab.Header as Grid).FindChild<TextBlock>("HeaderText")?.Text;

                    sp = new StackPanel { Orientation = Orientation.Horizontal };
                    sp.Children.Add(new Image
                    {
                        Source = icon,
                        Width = 16,
                        Height = 16,
                        Margin = new Thickness(0, 0, 20, 0)
                    });
                    sp.Children.Add(new TextBlock { Text = txt });
                    commandParameter = "Preview";

                    sp = new StackPanel { Orientation = Orientation.Horizontal };
                    sp.Children.Add(new Image
                    {
                        Source = icon,
                        Width = 16,
                        Height = 16,
                        Margin = new Thickness(0, 0, 20, 0)
                    });
                    sp.Children.Add(new TextBlock { Text = txt });
                    commandParameter = "Preview";
                }
                else
                {
                    if (doc == null) continue;

                    var filename = doc.MarkdownDocument.FilenamePathWithIndicator;
                    var icon = icons.GetIconFromFile(doc.MarkdownDocument.Filename);

                    sp = new StackPanel { Orientation = Orientation.Horizontal };
                    sp.Children.Add(new Image
                    {
                        Source = icon,
                        Width = 16,
                        Height = 16,
                        Margin = new Thickness(0, 0, 20, 0)
                    });
                    sp.Children.Add(new TextBlock { Text = filename });
                    commandParameter = doc.MarkdownDocument.Filename;
                }


                var mi = new MenuItem();
                mi.Header = sp;
                mi.Command = Model.Commands.TabControlFileListCommand;
                mi.CommandParameter = commandParameter;
                if (tab == selectedTab)
                {
                    mi.FontWeight = FontWeights.Bold;
                    mi.Foreground = Brushes.SteelBlue;
                }

                menuItems.Add(mi);
            }

            return menuItems;
        }

        private void MainMenuWindow_SubmenuOpened(object sender, RoutedEventArgs e)
        {
            Model.Commands.WindowMenuCommand.Execute(null);
        }
        #endregion

        #region StatusBar Display

        public void ShowStatus(string message = null, int milliSeconds = 0,
            FontAwesomeIcon icon = FontAwesomeIcon.None,
            Color color = default(Color),
            bool spin = false) => StatusBarHelper.ShowStatus(message, milliSeconds, icon, color, spin);

        /// <summary>
        /// Displays an error message using common defaults for a timeout milliseconds
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="timeout">optional timeout</param>
        /// <param name="icon">optional icon (warning)</param>
        /// <param name="color">optional color (firebrick)</param>
        public void ShowStatusError(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.Warning,
            Color color = default(Color)) => StatusBarHelper.ShowStatusError(message, timeout, icon, color);


        /// <summary>
        /// Shows a success message with a green check icon for the timeout
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="timeout">optional timeout</param>
        /// <param name="icon">optional icon (warning)</param>
        /// <param name="color">optional color (firebrick)</param>
        public void ShowStatusSuccess(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.CheckCircle,
            Color color = default(Color)) => StatusBarHelper.ShowStatusSuccess(message, timeout, icon, color);


        /// <summary>
        /// Displays an Progress message using common defaults including a spinning icon
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="timeout">optional timeout</param>
        /// <param name="icon">optional icon (warning)</param>
        /// <param name="color">optional color (firebrick)</param>
        /// <param name="spin"></param>
        public void ShowStatusProgress(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.CircleOutlineNotch,
            Color color = default(Color),
            bool spin = true) => StatusBarHelper.ShowStatusProgress(message, timeout, icon, color);

        /// <summary>
        /// Status the statusbar icon on the left bottom to some indicator
        /// </summary>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        /// <param name="spin"></param>
        public void SetStatusIcon(FontAwesomeIcon icon, Color color, bool spin = false) => StatusBarHelper.SetStatusIcon(icon, color, spin);

        /// <summary>
        /// Resets the Status bar icon on the left to its default green circle
        /// </summary>
        public void SetStatusIcon() => StatusBarHelper.SetStatusIcon();

        /// <summary>
        /// Helper routine to show a Metro Dialog. Note this dialog popup is fully async!
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="style"></param>
        /// <param name="settings"></param>
        /// <returns></returns>
        public async Task<MessageDialogResult> ShowMessageOverlayAsync(string title, string message,
            MessageDialogStyle style = MessageDialogStyle.Affirmative,
            MetroDialogSettings settings = null)
        {
            return await this.ShowMessageAsync(title, message, style, settings);
        }

        private void StatusZoomLevel_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            mmApp.Configuration.Editor.ZoomLevel = 100;
            Model.ActiveEditor?.RestyleEditor();
        }

        private void StatusZoomLevel_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            var text = StatusZoomLevel.Text;
            text = text.Replace("%", "");
            if (int.TryParse(text, out int num))
            {
                Model.Configuration.Editor.ZoomLevel = num;
                Model.ActiveEditor?.RestyleEditor();
            }
        }

        private void StatusZoomLevel_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var text = StatusZoomLevel.Text;
            text = text.Replace("%", "");

            if (int.TryParse(text, out int num))
                Model.Configuration.Editor.ZoomLevel = num;

            Model.ActiveEditor?.RestyleEditor();
        }


        private void StatusEncoding_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (Model.ActiveDocument == null)
                return;

            var encoding = Model.ActiveDocument.Encoding;

            string enc = StatusEncoding.SelectedItem as string;
            if (enc == null || enc.StartsWith(""))
            {
                StatusEncoding.SelectedValue = mmFileUtils.GetEncodingName(encoding);
                return;
            }
            
            if (enc.StartsWith("Load additional"))
            {
                Model.EncodingTypes = new ObservableCollection<string>(mmFileUtils.GetEncodingList(true));
                StatusEncoding.SelectedValue = mmFileUtils.GetEncodingName(encoding);

                Dispatcher.InvokeAsync(() => StatusEncoding.IsDropDownOpen = true);
                return;
            }

            encoding = mmFileUtils.GetEncoding(enc);
            if (Model.ActiveDocument.Encoding.Equals(encoding))
            {
                Model.Window.ShowStatusSuccess($"Document already set to {StatusEncoding.SelectedValue} encoding.");
                return;
            }

            if (Model.ActiveDocument.IsDirty &&
                MessageBox.Show(
                    "This document has unsaved changes that have to be saved before the document Encoding can be updated.\n\n" +
                    "Do you want to save changes?",
                    "Document Changes Pending",
                    MessageBoxButton.YesNo, MessageBoxImage.Question, MessageBoxResult.No) == MessageBoxResult.No)
            {
                Model.Window.ShowStatusError("Encoding has not been updated. Please save your document first.");
                return;
            }

           
            Model.ActiveDocument.Encoding = encoding;

            // otherwise re-open
            if (!Model.ActiveDocument.Load(Model.ActiveDocument.Filename, encoding: encoding))
                Model.Window.ShowStatusError("Couldn't reopen file with the " + encoding.EncodingName + " Encoding.");
            else
            {
                // Save Selection and past new content
                Model.ActiveEditor.ReplaceContent(Model.ActiveDocument.CurrentText);
                Model.ActiveEditor.PreviewMarkdownCallback(true);
                Model.ActiveDocument.IsDirty = true;
            }

            StatusEncoding.SelectedValue = mmFileUtils.GetEncodingName(encoding);
            Model.Window.ShowStatusSuccess($"The document has been reloaded with {StatusEncoding.SelectedValue} encoding.");
        }

        #endregion

        private void TextLinefeedMode_MouseUp(object sender, MouseButtonEventArgs e)
        {
            Model.Commands.SettingsVisualCommand?.Execute("Linefeed");
        }

        private void MainApplicationWindow_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            mmApp.Model.WindowLayout.FixUpEditorSize();
        }
    }

    public class RecentDocumentListItem
    {   
        public string Filename { get; set; }
        public string DisplayFilename { get; set; }
    }


    public enum RecentFileDropdownModes
    {
        ToolbarDropdown,
        MenuDropDown
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(173,13): error CS0103: The name 'InitializeComponent' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(186,24): error CS0117: 'TabControl' does not contain a definition for 'ClosingItemCallback',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(211,51): error CS0103: The name 'StatusText' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(211,63): error CS0103: The name 'StatusIcon' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(278,53): error CS0117: 'TabControl' does not contain a definition for 'FindChild',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(343,21): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(409,17): error CS0103: The name 'MainMenu' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(469,17): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(549,63): error CS0103: The name 'ToolbarEdit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(565,44): error CS0103: The name 'ToolbarEdit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(570,87): error CS0103: The name 'ToolbarEdit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(580,45): error CS0103: The name 'ButtonEmoji' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(661,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedIndex',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(662,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(664,21): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedIndex',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(666,21): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(678,17): error CS0103: The name 'ContentGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(679,17): error CS0103: The name 'ToolbarPanelMain' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(682,17): error CS0103: The name 'ContentGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(723,17): error CS0103: The name 'LeftSidebarColumn' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(725,21): error CS0103: The name 'LeftSidebarColumn' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(727,55): error CS0103: The name 'LeftSidebarColumn' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(733,47): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(764,42): error CS0117: 'TabControl' does not contain a definition for 'HeaderItemsOrganiser',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(826,23): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(839,27): error CS1061: 'FilePasswordDialog' does not contain a definition for 'ShowDialog' and no accessible extension method 'ShowDialog' accepting a first argument of type 'FilePasswordDialog' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1078,25): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1115,76): error CS0117: 'FilePasswordDialog' does not contain a definition for 'Owner',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1116,53): error CS1061: 'FilePasswordDialog' does not contain a definition for 'ShowDialog' and no accessible extension method 'ShowDialog' accepting a first argument of type 'FilePasswordDialog' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1159,40): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1174,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1177,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1178,45): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1180,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1210,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1252,23): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1267,38): error CS1061: 'EditorAndPreviewPane' does not contain a definition for 'PreviewBrowserContainer' and no accessible extension method 'PreviewBrowserContainer' accepting a first argument of type 'EditorAndPreviewPane' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1359,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1377,13): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1419,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1493,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1560,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1590,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1627,62): error CS0103: The name 'ButtonSaveAsFile' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1642,13): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1645,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1648,17): error CS0103: The name 'StatusStats' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1650,17): error CS0103: The name 'TabDocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1651,21): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1651,54): error CS0103: The name 'TabDocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1652,21): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1652,53): error CS0103: The name 'TabFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1691,26): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1693,27): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1725,41): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1764,36): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1773,36): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1795,52): error CS0119: 'TabControl' is a type, which is not valid in the given context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1951,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1954,21): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1990,17): error CS0103: The name 'RightSidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1993,21): error CS0103: The name 'RightSidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2121,28): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2129,25): error CS0103: The name 'DocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2139,13): error CS0103: The name 'DocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2155,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2160,29): error CS1061: 'FavoritesControl' does not contain a definition for 'TextSearch' and no accessible extension method 'TextSearch' accepting a first argument of type 'FavoritesControl' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2178,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2183,29): error CS1061: 'FileSearchControl' does not contain a definition for 'SearchPhrase' and no accessible extension method 'SearchPhrase' accepting a first argument of type 'FileSearchControl' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2309,30): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2318,21): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2323,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2331,26): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2380,23): error CS0119: 'TabControl' is a type, which is not valid in the given context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2428,27): error CS0103: The name 'ButtonOpenFromHtml' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2459,32): error CS0103: The name 'ToolbarButtonRecentFiles' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2469,32): error CS0103: The name 'ButtonExit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2474,32): error CS0103: The name 'MenuOpenConfigFolder' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2478,32): error CS0103: The name 'MenuOpenPreviewFolder' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2483,32): error CS0103: The name 'MenuMarkdownMonsterSite' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2487,32): error CS0103: The name 'MenuBugReport' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2491,32): error CS0103: The name 'MenuCheckNewVersion' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2497,32): error CS0103: The name 'MenuRegister' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2503,32): error CS0103: The name 'ButtonAbout' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2509,32): error CS0103: The name 'Button_Find' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2516,32): error CS0103: The name 'Button_FindNext' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2523,32): error CS0103: The name 'Button_Replace' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2530,32): error CS0103: The name 'ButtonWordWrap' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2531,32): error CS0103: The name 'ButtonLineNumbers' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2532,32): error CS0103: The name 'ButtonShowInvisibles' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2533,32): error CS0103: The name 'ButtonCenteredView' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2537,32): error CS0103: The name 'ButtonStatusEncrypted' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2542,83): error CS0117: 'FilePasswordDialog' does not contain a definition for 'Owner',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2543,24): error CS1061: 'FilePasswordDialog' does not contain a definition for 'ShowDialog' and no accessible extension method 'ShowDialog' accepting a first argument of type 'FilePasswordDialog' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2545,32): error CS0103: The name 'MenuDocumentation' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2547,32): error CS0103: The name 'MenuMarkdownBasics' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2549,32): error CS0103: The name 'MenuCreateAddinDocumentation' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2551,32): error CS0103: The name 'MenuShowSampleDocument' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2553,32): error CS0103: The name 'MenuShowErrorLog' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2564,32): error CS0103: The name 'MenuResetConfiguration' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2575,32): error CS0103: The name 'MenuBackupConfiguration' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2582,32): error CS0103: The name 'ButtonAllowScriptTags' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2650,37): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2706,33): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2765,31): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2767,38): error CS0117: 'TabControl' does not contain a definition for 'GetOrderedHeaders',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2925,24): error CS0103: The name 'StatusZoomLevel' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2936,24): error CS0103: The name 'StatusZoomLevel' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2953,26): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2956,17): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2963,17): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2965,46): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2972,75): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(3001,13): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(3002,83): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(36,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(47,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(173,13): error CS0103: The name 'InitializeComponent' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(186,24): error CS0117: 'TabControl' does not contain a definition for 'ClosingItemCallback',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(211,51): error CS0103: The name 'StatusText' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(211,63): error CS0103: The name 'StatusIcon' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(278,53): error CS0117: 'TabControl' does not contain a definition for 'FindChild',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(343,21): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(409,17): error CS0103: The name 'MainMenu' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(469,17): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(549,63): error CS0103: The name 'ToolbarEdit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(565,44): error CS0103: The name 'ToolbarEdit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(570,87): error CS0103: The name 'ToolbarEdit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(580,45): error CS0103: The name 'ButtonEmoji' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(661,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedIndex',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(662,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(664,21): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedIndex',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(666,21): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(678,17): error CS0103: The name 'ContentGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(679,17): error CS0103: The name 'ToolbarPanelMain' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(682,17): error CS0103: The name 'ContentGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(723,17): error CS0103: The name 'LeftSidebarColumn' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(725,21): error CS0103: The name 'LeftSidebarColumn' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(727,55): error CS0103: The name 'LeftSidebarColumn' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(733,47): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(764,42): error CS0117: 'TabControl' does not contain a definition for 'HeaderItemsOrganiser',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(777,29): error CS0103: The name 'dragablzItem' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(777,61): error CS0128: A local variable or function named 'tab' is already defined in this scope,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(790,38): error CS0103: The name 'tab' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(825,23): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(838,27): error CS1061: 'FilePasswordDialog' does not contain a definition for 'ShowDialog' and no accessible extension method 'ShowDialog' accepting a first argument of type 'FilePasswordDialog' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1077,25): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1114,76): error CS0117: 'FilePasswordDialog' does not contain a definition for 'Owner',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1115,53): error CS1061: 'FilePasswordDialog' does not contain a definition for 'ShowDialog' and no accessible extension method 'ShowDialog' accepting a first argument of type 'FilePasswordDialog' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1158,40): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1173,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1176,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1177,45): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1179,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1209,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1251,23): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1266,38): error CS1061: 'EditorAndPreviewPane' does not contain a definition for 'PreviewBrowserContainer' and no accessible extension method 'PreviewBrowserContainer' accepting a first argument of type 'EditorAndPreviewPane' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1357,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1375,13): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1417,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1491,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1558,17): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1588,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1625,62): error CS0103: The name 'ButtonSaveAsFile' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1640,13): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1643,17): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1646,17): error CS0103: The name 'StatusStats' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1648,17): error CS0103: The name 'TabDocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1649,21): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1649,54): error CS0103: The name 'TabDocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1650,21): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1650,53): error CS0103: The name 'TabFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1689,26): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1691,21): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1721,41): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1760,36): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1769,36): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1791,52): error CS0119: 'TabControl' is a type, which is not valid in the given context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1947,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1950,21): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1986,17): error CS0103: The name 'RightSidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(1989,21): error CS0103: The name 'RightSidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2116,28): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2124,25): error CS0103: The name 'DocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2134,13): error CS0103: The name 'DocumentOutline' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2150,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2155,29): error CS1061: 'FavoritesControl' does not contain a definition for 'TextSearch' and no accessible extension method 'TextSearch' accepting a first argument of type 'FavoritesControl' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2173,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2178,29): error CS1061: 'FileSearchControl' does not contain a definition for 'SearchPhrase' and no accessible extension method 'SearchPhrase' accepting a first argument of type 'FileSearchControl' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2304,30): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2313,21): error CS0103: The name 'FolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2318,17): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2326,26): error CS0103: The name 'SidebarContainer' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2375,23): error CS0119: 'TabControl' is a type, which is not valid in the given context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2423,27): error CS0103: The name 'ButtonOpenFromHtml' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2454,32): error CS0103: The name 'ToolbarButtonRecentFiles' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2464,32): error CS0103: The name 'ButtonExit' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2469,32): error CS0103: The name 'MenuOpenConfigFolder' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2473,32): error CS0103: The name 'MenuOpenPreviewFolder' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2478,32): error CS0103: The name 'MenuMarkdownMonsterSite' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2482,32): error CS0103: The name 'MenuBugReport' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2486,32): error CS0103: The name 'MenuCheckNewVersion' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2492,32): error CS0103: The name 'MenuRegister' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2498,32): error CS0103: The name 'ButtonAbout' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2504,32): error CS0103: The name 'Button_Find' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2511,32): error CS0103: The name 'Button_FindNext' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2518,32): error CS0103: The name 'Button_Replace' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2525,32): error CS0103: The name 'ButtonWordWrap' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2526,32): error CS0103: The name 'ButtonLineNumbers' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2527,32): error CS0103: The name 'ButtonShowInvisibles' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2528,32): error CS0103: The name 'ButtonCenteredView' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2532,32): error CS0103: The name 'ButtonStatusEncrypted' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2537,83): error CS0117: 'FilePasswordDialog' does not contain a definition for 'Owner',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2538,24): error CS1061: 'FilePasswordDialog' does not contain a definition for 'ShowDialog' and no accessible extension method 'ShowDialog' accepting a first argument of type 'FilePasswordDialog' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2540,32): error CS0103: The name 'MenuDocumentation' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2542,32): error CS0103: The name 'MenuMarkdownBasics' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2544,32): error CS0103: The name 'MenuCreateAddinDocumentation' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2546,32): error CS0103: The name 'MenuShowSampleDocument' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2548,32): error CS0103: The name 'MenuShowErrorLog' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2559,32): error CS0103: The name 'MenuResetConfiguration' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2570,32): error CS0103: The name 'MenuBackupConfiguration' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2577,32): error CS0103: The name 'ButtonAllowScriptTags' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2645,37): error CS0120: An object reference is required for the non-static field, method, or property 'ItemsControl.Items',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2701,33): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2760,31): error CS0120: An object reference is required for the non-static field, method, or property 'Selector.SelectedItem',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2762,38): error CS0117: 'TabControl' does not contain a definition for 'GetOrderedHeaders',D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2920,24): error CS0103: The name 'StatusZoomLevel' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2931,24): error CS0103: The name 'StatusZoomLevel' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2948,26): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2951,17): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2958,17): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2960,46): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2967,75): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2996,13): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(2997,83): error CS0103: The name 'StatusEncoding' does not exist in the current context,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(47,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\MainWindow.xaml.cs(36,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Media3D;
using System.Windows.Threading;
using System.Xml;
using FontAwesome.WPF;
using MahApps.Metro.Controls;
using MarkdownMonster.Annotations;
using MarkdownMonster.Controls;
using MarkdownMonster.Controls.ContextMenus;
using MarkdownMonster.Utilities;
using Westwind.Utilities;
using UserControl = System.Windows.Controls.UserControl;


    namespace MarkdownMonster.Windows
    {
        /// <summary>
        /// Interaction logic for FolderBrowerSidebar.xaml
        /// </summary>
        public partial class FolderBrowerSidebar : UserControl, INotifyPropertyChanged
        {
            public MainWindow Window { get; set; }
            public AppModel AppModel { get; set; }

            public FolderBrowserContextMenu FolderBrowserContextMenu { get; set; }

            public string FolderPath
            {
                get { return _folderPath; }
                set
                {
                    if (value == _folderPath) return;

                    string filename = null;
                    if (!Directory.Exists(value))
                    {
                        if (!File.Exists(value))
                            value = null;
                        else
                        {
                            filename = value;
                            value = Path.GetDirectoryName(value);
                        }
                    }

                    var previousFolder = _folderPath;

                    _folderPath = value;
                    OnPropertyChanged(nameof(FolderPath));

                    if (Window == null) return;

                    SearchText = null;
                    SearchSubTrees = false;

                    if (string.IsNullOrEmpty(_folderPath))
                        ActivePathItem = new PathItem(); // empty the folderOrFilePath browser
                    else
                    {
                        if (filename != null && previousFolder == _folderPath && string.IsNullOrEmpty(SearchText))
                            SelectFileInSelectedFolderBrowserFolder(filename);
                        else
                            SetTreeFromFolder(filename ?? _folderPath, filename != null, SearchText);
                    }


                    if (ActivePathItem != null)
                    {
                        _folderPath = value;
                        mmApp.Configuration.FolderBrowser.AddRecentFolder(_folderPath);

                        OnPropertyChanged(nameof(FolderPath));
                        OnPropertyChanged(nameof(ActivePathItem));
                    }
                }
            }

            private string _folderPath;


            public string SearchText
            {
                get { return _searchText; }
                set
                {
                    if (value == _searchText) return;
                    _searchText = value;
                    OnPropertyChanged();
                }
            }

            private string _searchText;



            public bool SearchSubTrees
            {
                get { return _searchSubTrees; }
                set
                {
                    if (value == _searchSubTrees) return;
                    _searchSubTrees = value;
                    OnPropertyChanged();
                }
            }

            private bool _searchSubTrees;


            public PathItem ActivePathItem
            {
                get { return _activePath; }
                set
                {
                    if (Equals(value, _activePath)) return;
                    _activePath = value;
                    OnPropertyChanged(nameof(ActivePathItem));
                }
            }

            private PathItem _activePath;


            /// <summary>
            /// Internal value
            /// </summary>
            public FolderStructure FolderStructure {
                get
                {
                    return new FolderStructure(this);
                }
            } 


            /// <summary>
            /// Filewatcher used to detect changes to files in the active folder
            /// including subdirectories.
            /// </summary>
            private FileSystemWatcher FileWatcher = null;


            #region Initialization

            public FolderBrowerSidebar()
            {
                InitializeComponent();
                Focusable = true;

                DataContext = null;

                Loaded += FolderBrowerSidebar_Loaded;
                Unloaded += (s, e) => ReleaseFileWatcher();
            }


            private void FolderBrowerSidebar_Loaded(object sender, RoutedEventArgs e)
            {
                AppModel = mmApp.Model;
                Window = AppModel.Window;
                DataContext = this;
                
                FolderBrowserContextMenu = new FolderBrowserContextMenu(this);

                // Load explicitly here to fire *after* behavior has attached
                ComboFolderPath.PreviewKeyUp += ComboFolderPath_PreviewKeyDown;

                TreeFolderBrowser.GotFocus += TreeFolderBrowser_GotFocus;
                ComboFolderPath.GotFocus += TreeFolderBrowser_GotFocus;
            }


            private void TreeFolderBrowser_GotFocus(object sender, RoutedEventArgs e)
            {
                // ensure that directory wasn't deleted under us
                if (!Directory.Exists(FolderPath))
                    FolderPath = null;
            }

            /// <summary>
            /// Updates the Git status of the files currently active
            /// in the tree.
            /// </summary>
            /// <param name="pathItem"></param>
            public void UpdateGitStatus(PathItem pathItem = null)
            {
                if (pathItem == null)
                    pathItem = ActivePathItem;

                FolderStructure.UpdateGitFileStatus(pathItem);
            }

            #endregion

            #region FileWatcher

            private void FileWatcher_Renamed(object sender, RenamedEventArgs e)
            {
                if (mmApp.Model == null || mmApp.Model.Window == null)
                    return;

                mmApp.Model.Window.Dispatcher.Invoke(() =>
                {

                    var file = e.FullPath;
                    var oldFile = e.OldFullPath;

                    var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, oldFile);
                    if (pi == null)
                        return;

                    pi.FullPath = file;
                    pi.Parent.Files.Remove(pi);

                    FolderStructure.InsertPathItemInOrder(pi, pi.Parent);
                }, DispatcherPriority.ApplicationIdle);
            }

            private void FileWatcher_CreateOrDelete(object sender, FileSystemEventArgs e)
            {

                if (mmApp.Model == null || mmApp.Model.Window == null)
                    return;

                if (!Directory.Exists(FolderPath))
                {
                    FolderPath = null;
                    return;
                }

                var file = e.FullPath;
                if (string.IsNullOrEmpty(file))
                    return;

                if (e.ChangeType == WatcherChangeTypes.Deleted)
                {
                    mmApp.Model.Window.Dispatcher.Invoke(() =>
                    {
                        var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, file);
                        if (pi == null)
                            return;

                        pi.Parent.Files.Remove(pi);

                        //Debug.WriteLine("After: " + pi.Parent.Files.Count + " " + file);
                    }, DispatcherPriority.ApplicationIdle);
                }

                if (e.ChangeType == WatcherChangeTypes.Created)
                {
                    mmApp.Model.Window.Dispatcher.Invoke(() =>
                    {
                        // Skip ignored Extensions
                        string[] extensions = null;
                        if (!string.IsNullOrEmpty(mmApp.Model.Configuration.FolderBrowser.IgnoredFileExtensions))
                            extensions =
                                mmApp.Model.Configuration.FolderBrowser.IgnoredFileExtensions.Split(new[] {','},
                                    StringSplitOptions.RemoveEmptyEntries);

                        if (extensions != null && extensions.Any(ext =>
                            file.EndsWith(ext, StringComparison.InvariantCultureIgnoreCase)))
                            return;

                        var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, file);
                        if (pi != null) // Already exists in the tree
                            return;

                        // does the path exist?
                        var parentPathItem =
                            FolderStructure.FindPathItemByFilename(ActivePathItem, Path.GetDirectoryName(file));

                        // Path either doesn't exist or is not expanded yet so don't attach - opening will trigger
                        if (parentPathItem == null ||
                            (parentPathItem.Files.Count == 1 && parentPathItem.Files[0] == PathItem.Empty))
                            return;

                        bool isFolder = Directory.Exists(file);
                        pi = new PathItem()
                        {
                            FullPath = file, IsFolder = isFolder, IsFile = !isFolder, Parent = parentPathItem
                        };
                        // make sure we pick up the child items so the node shows as expandable if there are items
                        if (isFolder)
                        {
                            var newPi = FolderStructure.GetFilesAndFolders(pi.FullPath, nonRecursive: true);
                            pi.Files = newPi.Files;
                        }

                        pi.SetIcon();

                        FolderStructure.InsertPathItemInOrder(pi, parentPathItem);

                    }, DispatcherPriority.ApplicationIdle);
                }

            }


            private void FileWatcher_Changed(object sender, FileSystemEventArgs e)
            {
                if (mmApp.Model == null || mmApp.Model.Window == null)
                    return;

                Dispatcher.Invoke(async () =>
                {
                    var file = e.FullPath;

                    var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, file);
                    if (pi == null)
                        return;

                    int errorCount = 0;
                    while (errorCount < 3)
                    {
                        try
                        {
                            var gh = new GitHelper();
                            pi.FileStatus = gh.GetGitStatusForFile(pi.FullPath);
                            break;
                        }
                        catch
                        {
                            await Task.Delay(25);
                            errorCount++;
                        }
                    }

                }, DispatcherPriority.ApplicationIdle);
            }

            private void AttachFileWatcher(string fullPath)
            {
                if (fullPath == null) return;

                ReleaseFileWatcher();

                // no file watcher for root paths
                var di = new DirectoryInfo(fullPath);
                if (di.Root.FullName == fullPath)
                {
                    AppModel.Window.ShowStatusProgress("Drive root selected: Files are not updated in root folders.",
                        mmApp.Configuration.StatusMessageTimeout, spin: false, icon: FontAwesomeIcon.Circle);
                    return;
                }

                if (FileWatcher != null)
                    ReleaseFileWatcher();

                if (string.IsNullOrEmpty(fullPath))
                    return;

                if (!Directory.Exists(fullPath))
                {
                    FolderPath = null;
                    return;
                }

                FileWatcher =
                    new FileSystemWatcher(fullPath) {IncludeSubdirectories = true, EnableRaisingEvents = true};

                FileWatcher.Created += FileWatcher_CreateOrDelete;
                FileWatcher.Deleted += FileWatcher_CreateOrDelete;
                FileWatcher.Renamed += FileWatcher_Renamed;
                FileWatcher.Changed += FileWatcher_Changed;
            }


            public void ReleaseFileWatcher()
            {
                if (FileWatcher != null)
                {
                    FileWatcher.Changed -= FileWatcher_Changed;
                    FileWatcher.Deleted -= FileWatcher_CreateOrDelete;
                    FileWatcher.Created -= FileWatcher_CreateOrDelete;
                    FileWatcher.Renamed -= FileWatcher_Renamed;

                    // TODO: MAKE SURE THIS DOESN'T HAVE SIDE EFFECTS (Hanging on shutdown)
                    // This can hang in weird ways when application is shutting down
                    // Since this is the only time this should go away this is probably safe but ugly
                    //FileWatcher.Dispose();

                    FileWatcher = null;
                }
            }

            #endregion

            #region Folder Button and Text Handling

            public void OpenFile(string file, bool forceEditorFocus = false)
            {
                Window.OpenFile(file, noFocus: !forceEditorFocus);
            }

            /// <summary>
            /// Sets the tree's content from a folderOrFilePath or filename.
            ///
            /// This method is also called from the FolderPath property Getter
            /// after some pre-processing.
            /// </summary>
            /// <param name="folderOrFilePath">Folder or File path to load. If File folder is loaded and file selected</param>
            /// <param name="setFocus">Optional - determines on whether focus is set to the TreeView Item</param>
            /// <param name="searchText">Optional - search text filter that is applied to the file names</param>
            public void SetTreeFromFolder(string folderOrFilePath, bool setFocus = false, string searchText = null)
            {
                if (Window == null)
                    return;

                string fileName = null;
                if (File.Exists(folderOrFilePath))
                {
                    fileName = folderOrFilePath;
                    folderOrFilePath = Path.GetDirectoryName(folderOrFilePath);
                }

                Window.ShowStatusProgress($"Retrieving files for folderOrFilePath {folderOrFilePath}...");

                Dispatcher.InvokeAsync(() =>
                {
                    // just get the top level folderOrFilePath first
                    ActivePathItem = null;
                    WindowUtilities.DoEvents();

                    var items = FolderStructure.GetFilesAndFolders(folderOrFilePath, nonRecursive: true,
                                    ignoredFolders: mmApp.Configuration.FolderBrowser.IgnoredFolders,
                                    ignoredFileExtensions: mmApp.Configuration.FolderBrowser.IgnoredFileExtensions);
                    ActivePathItem = items;

                    WindowUtilities.DoEvents();
                    Window.ShowStatus();

                    if (TreeFolderBrowser.HasItems)
                        SetTreeViewSelectionByIndex(0);

                    if (setFocus)
                        TreeFolderBrowser.Focus();


                    AttachFileWatcher(folderOrFilePath);

                    FolderStructure.UpdateGitFileStatus(items);

                    if (!string.IsNullOrEmpty(fileName))
                        SelectFileInSelectedFolderBrowserFolder(fileName);

                }, DispatcherPriority.ApplicationIdle);
            }

            /// <summary>
            /// Selects a file in the top level folder browser folder
            /// by file name.
            /// </summary>
            /// <param name="fileName">filename with full path - must match case</param>
            public void SelectFileInSelectedFolderBrowserFolder(string fileName, bool setFocus = true)
            {
                if (!string.IsNullOrEmpty(fileName))
                {
                    foreach (var file in ActivePathItem.Files)
                    {
                        if (file.FullPath == fileName)
                        {
                            if (setFocus)
                                TreeFolderBrowser.Focus();

                            file.IsSelected = true;
                        }
                    }
                }

            }


            //private void ButtonUseCurrentFolder_Click(object sender, RoutedEventArgs e)
            //{
            //    var doc = AppModel?.ActiveDocument;
            //    if (doc == null)
            //        return;

            //    SetTreeFromFolder(doc.Filename, true);
            //}


            public void SetTreeViewSelectionByIndex(int index)
            {
                TreeViewItem item = TreeFolderBrowser
                    .ItemContainerGenerator
                    .ContainerFromIndex(index) as TreeViewItem;

                if (item != null)
                    item.IsSelected = true;
            }

            public void SetTreeViewSelectionByItem(PathItem item, TreeViewItem parentTreeViewItem = null)
            {
                TreeViewItem treeitem = GetNestedTreeviewItem(item);

                if (treeitem != null)
                {
                    treeitem.BringIntoView();

                    if (treeitem.Parent != null && treeitem.Parent is TreeViewItem)
                        ((TreeViewItem) treeitem.Parent).IsExpanded = true;

                    treeitem.IsSelected = true;

                    // show edited filename with file stem selected
                    if (item.IsEditing && item.IsFile &&
                        item.DisplayName != null && item.DisplayName.Contains('.'))
                    {
                        Dispatcher.Invoke(() =>
                        {
                            var tb = WindowUtilities.FindVisualChild<TextBox>(treeitem);
                            if (tb == null)
                                return;
                            var idx = item.DisplayName.IndexOf(".");
                            if (idx > 0)
                            {
                                tb.SelectionStart = 0;
                                tb.SelectionLength = idx;
                            }
                        }, DispatcherPriority.ApplicationIdle);
                    }
                }
            }

            private void ComboFolderPath_PreviewKeyDown(object sender, KeyEventArgs e)
            {
                if (e.Key == Key.Enter
                ) // || e.Key == Key.Tab && (Keyboard.Modifiers & ModifierKeys.Shift) != (ModifierKeys.Shift) )
                {
                    ((ComboBox) sender).IsDropDownOpen = false;
                    TreeFolderBrowser.Focus();
                    e.Handled = true;
                }
            }

            private void ButtonRecentFolders_Click(object sender, RoutedEventArgs e)
            {
                if (ButtonRecentFolders.ContextMenu == null)
                    ButtonRecentFolders.ContextMenu = new ContextMenu();

                mmApp.Configuration.FolderBrowser.UpdateRecentFolderContextMenu(ButtonRecentFolders.ContextMenu);
                if (ButtonRecentFolders.ContextMenu.Items.Count > 0)
                    ButtonRecentFolders.ContextMenu.IsOpen = true;

            }

            private void ButtonSelectFolder_Click(object sender, RoutedEventArgs e)
            {
                string folder = FolderPath;

                if (string.IsNullOrEmpty(folder))
                {
                    folder = AppModel.ActiveDocument?.Filename;
                    if (string.IsNullOrEmpty(folder))
                        folder = Path.GetDirectoryName(folder);
                    else
                        folder = KnownFolders.GetPath(KnownFolder.Libraries);
                }

                folder = mmWindowsUtils.ShowFolderDialog(folder,
                    "Select folderOrFilePath to open in the Folder Browser");
                if (folder == null)
                    return;

                FolderPath = folder;
                TreeFolderBrowser.Focus();
            }

            private void ButtonRefreshFolder_Click(object sender, RoutedEventArgs e)
            {
                if (ActivePathItem != null)
                {
                    ActivePathItem.Files.Clear();
                    ActivePathItem.FullPath = FolderPath;
                    ActivePathItem.IsFolder = true;
                }

                SetTreeFromFolder(FolderPath, true);
            }

            #endregion


            #region TreeView Selections

            /// <summary>
            /// Returns the Active Selected Path Item
            /// </summary>
            /// <returns></returns>
            public PathItem GetSelectedPathItem()
            {
                return TreeFolderBrowser.SelectedItem as PathItem;
            }


            /// <summary>
            /// Returns a list of selected items.
            /// </summary>
            /// <returns>List of items</returns>
            public List<PathItem> GetSelectedPathItems()
            {
                return GetSelectedItems(TreeFolderBrowser.Items);
            }


            /// <summary>
            /// Explicitly selects the active path item and forces focus into it
            /// </summary>
            /// <param name="forceEditorFocus"></param>
            public void HandleItemSelection(bool forceEditorFocus = false)
            {
                var fileItem = GetSelectedPathItem(); //TreeFolderBrowser.SelectedItem as PathItem;
                if (fileItem == null)
                    return;
                
                if (fileItem.FullPath == "..")
                    FolderPath = Path.GetDirectoryName(FolderPath.Trim('\\'));
                else if (fileItem.IsFolder)
                    fileItem.IsExpanded = !fileItem.IsExpanded;
                else
                    OpenFile(fileItem.FullPath, forceEditorFocus);
            }

            /// <summary>
            /// Retrieves a nested TreeViewItem by walking the hierarchy.
            /// Specify a root treeview or treeviewitem and it then walks
            /// the hierarchy to find the item
            /// </summary>
            /// <param name="item">Item to find</param>
            /// <param name="treeItem">Parent item to start search from</param>
            /// <returns></returns>
            public TreeViewItem GetNestedTreeviewItem(object item, ItemsControl treeItem = null)
            {
                if (treeItem == null)
                    treeItem = TreeFolderBrowser;

                return WindowUtilities.GetNestedTreeviewItem(item, treeItem);
            }

            /// <summary>
            /// Used for TreeViewSelection() - will hold current selection after
            /// </summary>
            private PathItem lastSelectedPathItem = PathItem.Empty;


            /// <summary>
            /// This selects the item including multi-file selections
            /// </summary>
            private void TreeViewSelection(TreeViewItem titem, Key key = Key.None)
            {
                var pitem = titem?.DataContext as PathItem;
                if (pitem == null || ActivePathItem == null) return;

                try
                {
                    pitem.IsSelected = true;

                    // clear all selections except in current folder
                    var selItems = pitem.Parent?.Files.Where(p => p.IsSelected).ToArray();
                    ClearSelectedItems(ActivePathItem?.Files, except: selItems);

                    if (pitem.IsFolder)
                    {
                        foreach (var pi in pitem.Files)
                            pi.IsSelected = pitem.IsSelected;
                    }

                    if (Keyboard.IsKeyDown(Key.LeftCtrl) || key == Key.LeftCtrl)
                    {
                        return; // don't need to clear any items additive
                    }

                    if (Keyboard.IsKeyDown(Key.LeftShift) || key == Key.LeftShift)
                    {
                        // select items between cursor position
                        var items = pitem.Parent?.Files;
                        if (items == null)
                            items = new ObservableCollection<PathItem>(TreeFolderBrowser.Items.Cast<PathItem>());


                        var idx = items.IndexOf(pitem);
                        var lastidx = items.IndexOf(lastSelectedPathItem);

                        if (lastidx < 0 || idx == lastidx)
                            return;

                        int start = idx;
                        int stop = lastidx;
                        if (lastidx < idx)
                        {
                            start = lastidx;
                            stop = idx;
                        }

                        for (int i = start; i < stop; i++)
                        {
                            items[i].IsSelected = pitem.IsSelected;
                        }

                        return;
                    }

                    // single click - we have to clear all but the new selection
                    ClearSelectedItems(ActivePathItem?.Files, pitem);
                }
                finally
                {
                    lastSelectedPathItem = pitem;
                }
            }

            /// <summary>
            /// Returns the first selected item in the tree from the top down.
            /// </summary>
            /// <param name="items">Root tree nodes or child nodes. Defaults to the root</param>
            /// <returns>Selected path item or null</returns>
            public PathItem GetSelectedItem(ItemCollection items = null)
            {
                if (items == null)
                    items = TreeFolderBrowser.Items;

                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;
                    if (pi.IsSelected)
                        return pi;

                    if (pi.Files.Count > 0)
                    {
                        var titem = GetTreeViewItem(pi);

                        if (titem == null)
                            continue;

                        pi = GetSelectedItem(titem.Items);
                        if (pi != null)
                            return pi;
                    }
                }

                return null;
            }

            /// <summary>
            /// Returns all selected Path Items in the folder tree
            /// </summary>
            /// <param name="items">Root tree nodes or child nodes. Defaults to the root</param>
            /// <param name="list">Optional list passed in for recursive child parsing</param>
            /// <returns>Returns a list of matching items or an empty list</returns>
            public List<PathItem> GetSelectedItems(ItemCollection items = null, List<PathItem> list = null)
            {
                if (items == null)
                    items = TreeFolderBrowser.Items;

                if (list == null)
                    list = new List<PathItem>();

                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;
                    if (pi.IsSelected)
                        list.Add(pi);

                    if (pi.Files.Count > 0)
                    {
                        var titem = GetTreeViewItem(pi);
                        if (titem == null) continue;
                        GetSelectedItems(titem.Items, list);
                    }
                }

                return list;
            }


            /// <summary>
            /// Clears all selected items
            /// </summary>
            /// <param name="items">A node of the tree. Defaults to the root of the tree.</param>
            /// <param name="except">Optional - A PathItem that should stay selected.</param>
            public void ClearSelectedItems(ItemCollection items = null, params PathItem[] except)
            {
                if (items == null)
                    items = TreeFolderBrowser.Items;


                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;

                    if (except != null && except.Contains(pi))
                        pi.IsSelected = true;
                    else
                        pi.IsSelected = false;

                    if (pi.Files.Count == 0) continue;

                    var titem = GetTreeViewItem(pi);

                    if (titem?.Items == null) continue;

                    ClearSelectedItems(titem.Items, except);
                }
            }

            /// <summary>
            /// Clears all selected items
            /// </summary>
            /// <param name="items">A node of the tree. Defaults to the root of the tree.</param>
            /// <param name="except">Optional - A PathItem that should stay selected.</param>
            /// <param name="noClearParent">Optional - a parent folder that should not be cleared</param>
            public void ClearSelectedItems(IEnumerable<PathItem> items, params PathItem[] except)
            {
                if (items == null)
                    items = ActivePathItem.Files;

                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;

                    if (except != null && except.Contains(pi))
                        pi.IsSelected = true;
                    else
                        pi.IsSelected = false;

                    ClearSelectedItems(pi.Files, except);
                }
            }

            /// <summary>
            /// Returns a TreeViewItem from a Path Item recursively
            /// </summary>
            /// <param name="pathItem">A path item</param>
            /// <returns></returns>
            public TreeViewItem GetTreeViewItem(PathItem pathItem, ItemsControl parentContainer = null,
                bool nonRecursive = false)
            {
                if (pathItem == null)
                    return null;

                if (parentContainer == null)
                    parentContainer = TreeFolderBrowser;

                var titem = parentContainer
                    .ItemContainerGenerator
                    .ContainerFromItem(pathItem) as TreeViewItem;

                if (titem != null || nonRecursive) return titem;

                foreach (var item in parentContainer.Items)
                {
                    var folder = item as PathItem;
                    if (folder == null || !folder.IsFolder) continue;

                    var folderItem = GetTreeViewItem(folder, parentContainer);
                    if (folderItem != null)
                    {
                        titem = GetTreeViewItem(pathItem, folderItem);
                        if (titem != null)
                            break;
                    }
                }

                return titem;
            }

            #endregion

            #region TreeView Selection Events

            private string searchFilter = string.Empty;
            private DateTime searchFilterLast = DateTime.MinValue;

            private void TreeView_Keydown(object sender, KeyEventArgs e)
            {
                var selected = TreeFolderBrowser.SelectedItem as PathItem;

                // this works without a selection
                if ((e.Key == Key.F2 && Keyboard.IsKeyDown(Key.LeftShift)) ||
                    (e.Key == Key.N && Keyboard.IsKeyDown(Key.LeftCtrl)))
                {
                    if (selected == null || !selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuAddFile_Click(sender, null);
                        e.Handled = true;
                    }

                    return;
                }

                if (e.Key == Key.F8)
                {
                    if (selected == null || !selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuAddDirectory_Click(sender, null);
                        e.Handled = true;
                    }
                }

                if (selected == null)
                    return;

                if (e.Key == Key.Enter || e.Key == Key.Tab)
                {
                    if (!selected.IsEditing)
                        HandleItemSelection(forceEditorFocus: true);
                    else
                        RenameOrCreateFileOrFolder();


                    e.Handled = true;
                }
                else if (e.Key == Key.Escape)
                {
                    if (selected.IsEditing)
                    {
                        selected.IsEditing = false;
                        if (!string.IsNullOrEmpty(selected.OriginalRenamePath))
                        {
                            selected.FullPath = selected.OriginalRenamePath;
                            selected.OriginalRenamePath = null;
                        }
                        else
                            selected.Parent?.Files?.Remove(selected);
                    }
                }
                else if (e.Key == Key.F2)
                {
                    if (!selected.IsEditing)
                        FolderBrowserContextMenu.MenuRenameFile_Click(sender, null);
                }
                else if (e.Key == Key.Delete)
                {
                    if (!selected.IsEditing)
                        FolderBrowserContextMenu.MenuDeleteFile_Click(sender, null);
                }
                else if (e.Key == Key.G && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    if (!selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuCommitGit_Click(null, null);
                        e.Handled = true;
                    }
                }
                else if (e.Key == Key.Z && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    if (!selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuUndoGit_Click(null, null);
                        e.Handled = true;
                    }
                }
                // Copy, Cut
                else if ((e.Key == Key.C || e.Key == Key.X) && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    var menu = new FolderBrowserContextMenu(this);
                    menu.FileBrowserCopyFile(e.Key == Key.X);
                    e.Handled = true;
                }
                // Paste Files(s) from clipboard
                else if (e.Key == Key.V && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    var menu = new FolderBrowserContextMenu(this);
                    menu.FileBrowserPasteFile();
                    e.Handled = true;
                }
                // Find in Files
                else if (e.Key == Key.F && Keyboard.IsKeyDown(Key.LeftCtrl) && Keyboard.IsKeyDown(Key.LeftShift))
                {
                    AppModel.Commands.OpenSearchSidebarCommand.Execute(FolderPath);
                    e.Handled = true;
                }
                // Find
                else if (e.Key == Key.F && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    TextSearch.Focus();
                    e.Handled = true;
                }
                

                if (e.Handled || selected.IsEditing || Keyboard.IsKeyDown(Key.LeftCtrl))
                    return;

                // search key
                if (e.Key >= Key.A && e.Key <= Key.Z ||
                    e.Key >= Key.D0 && e.Key <= Key.D9 ||
                    e.Key == Key.OemPeriod ||
                    e.Key == Key.Space ||
                    e.Key == Key.Separator ||
                    e.Key == Key.OemMinus ||
                    e.Key == Key.OemPipe ||
                    e.Key == Key.Back &&
                    // ignore control/alt keys
                    (!Keyboard.IsKeyDown(Key.LeftCtrl) && !Keyboard.IsKeyDown(Key.LeftAlt)))
                {
                    //Debug.WriteLine("Treeview TreeDown: " + e.Key + " shfit: " + Keyboard.IsKeyDown(Key.LeftShift));
                    var keyConverter = new KeyConverter();

                    string keyText = string.Empty;
                    bool isShiftDown = Keyboard.IsKeyDown(Key.LeftShift);
                    bool isBack = false;

                    // special key mapping
                    if (e.Key == Key.OemPeriod)
                        keyText = ".";
                    else if (e.Key == Key.OemMinus)
                        keyText = "-";
                    else if (e.Key == Key.Space)
                        keyText = " ";
                    else if(e.Key == Key.OemPipe)
                        keyText = "|";
                    else if (isShiftDown)
                    {
                        if (e.Key == Key.OemMinus)
                            keyText = "_";
                        else if (e.Key == Key.D1)
                            keyText = "!";
                        else if (e.Key == Key.D2)
                            keyText = "@";
                        else if (e.Key == Key.D3)
                            keyText = "#";
                        else if (e.Key == Key.D4)
                            keyText = "$";
                        else if (e.Key == Key.D5)
                            keyText = "%";
                        else if (e.Key == Key.D7)
                            keyText = "&";
                    }
                    else if (e.Key == Key.Back)
                    {
                        isBack = true;
                        if (searchFilter.Length > 0)
                            searchFilter = searchFilter.Substring(0,searchFilter.Length-1);
                    }
                    else
                        keyText = keyConverter.ConvertToString(e.Key);

                    if (searchFilterLast > DateTime.Now.AddSeconds(-1.2))
                    {
                        if (!isBack)
                            searchFilter += keyText.ToLower();
                    }
                    else
                    {
                        if(isBack)
                            searchFilter = string.Empty;
                        else
                            searchFilter = keyText.ToLower();
                    }

                    var parentPath = selected.Parent;
                    if (parentPath == null)
                        parentPath = ActivePathItem; // root

                    ClearSelectedItems(parentPath.Files);
                    selected.IsSelected = false;

                    Window.ShowStatus("File search filter: " + searchFilter, 2000);

                    var lowerFilter = searchFilter.ToLower();
                
                    var item = parentPath.Files.FirstOrDefault(sf => sf.DisplayName.ToLower().StartsWith(lowerFilter));
                    if (item != null)
                    {
                        item.IsSelected = true;

                        // force the native selection to release the old selection
                        var tvItem = GetTreeViewItem(item);
                        if (tvItem != null) tvItem.IsSelected = true;
                    }
                    
                    searchFilterLast = DateTime.Now;
                }

            }

            /// <summary>
            /// Handle certain keys that aren't triggering in KeyDown
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void TreeViewItem_PreviewKeyUp(object sender, KeyEventArgs e)
            {

                var titem = sender as TreeViewItem;
                var selected = titem?.DataContext as PathItem; //TreeFolderBrowser.SelectedItem as PathItem;

                if (e.Key == Key.F1)
                {
                    AppModel.Commands.HelpCommand.Execute("_4xs10gaui.htm");
                    e.Handled = true;
                }
                else if (e.Key == Key.Down || e.Key == Key.Up)
                {
                    // select the item if not already selected
                    TreeViewSelection(titem, e.Key);
                }
            }

            private void TreeViewItem_MouseDoubleClick(object sender, MouseButtonEventArgs e)
            {
                //LastClickTime = DateTime.MinValue;   // 

                // select the item including multi-item selection
                TreeViewSelection(sender as TreeViewItem);

                HandleItemSelection(forceEditorFocus: true);
            }



            private void TreeViewItem_MouseUpClick(object sender, MouseButtonEventArgs e)
            {
                if (e.ClickCount == 2)
                    return;

                var titem = sender as TreeViewItem;
                if (titem == null) return;

                var selected = titem.DataContext as PathItem;
                if (selected == null)
                    return;

                // select the item including multi-item selection
                TreeViewSelection(titem);
                e.Handled = true;

                var filePath = selected.FullPath;

                if (string.IsNullOrEmpty(filePath))
                    return;

                var ext = Path.GetExtension(filePath).ToLower();
                if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
                {
                    Window.OpenBrowserTab(filePath, isImageFile: true);
                    return;
                }


                var tab = AppModel.Window.GetTabFromFilename(filePath);
                if (tab != null)
                {
                    AppModel.Window.TabControl.SelectedItem = tab;
                    return;
                }

                if (ext == ".md" || ext == ".markdown")
                    Window.RefreshTabFromFile(filePath, isPreview: true, noFocus: true);
                else if (ext == ".html" || ext == ".htm")
                    Window.OpenBrowserTab(filePath);


            }

            private void TreeViewItem_PreviewMouseRightButtonUp(object sender, MouseButtonEventArgs e)
            {
                var item = ElementHelper.FindVisualTreeParent<TreeViewItem>(e.OriginalSource as FrameworkElement);
                if (item != null)
                    item.IsSelected = true;

                var ctx = new FolderBrowserContextMenu(this);
                ctx.ShowContextMenu();
            }


            private void TreeFolderBrowser_Expanded(object sender, RoutedEventArgs e)
            {
                var tvi = e.OriginalSource as TreeViewItem;
                if (tvi == null)
                    return;

                tvi.IsSelected = true;

                var selected = TreeFolderBrowser.SelectedItem as PathItem;
                if (selected == null || selected.IsFile || selected.FullPath == "..")
                    return;

                if (selected.Files != null && selected.Files.Count == 1 && selected.Files[0] == PathItem.Empty)
                {
                    var subfolder = FolderStructure.GetFilesAndFolders(selected.FullPath, nonRecursive: true,
                        parentPathItem: selected);
                    FolderStructure.UpdateGitFileStatus(subfolder);
                }
            }


            void RenameOrCreateFileOrFolder()
            {
                var fileItem = TreeFolderBrowser.SelectedItem as PathItem;
                if (fileItem == null)
                    return;

                fileItem.EditName = fileItem.EditName?.Trim();

                if (string.IsNullOrEmpty(fileItem.EditName) ||
                    fileItem.DisplayName == fileItem.EditName && File.Exists(fileItem.FullPath))
                {
                    fileItem.IsEditing = false;
                    return;
                }

                if (FileUtils.HasInvalidPathCharacters(fileItem.DisplayName))
                {
                    Window.ShowStatusError($"Invalid filename for renaming: {fileItem.DisplayName}");
                    return;
                }

                string oldFile = fileItem.FullPath;
                string oldPath = Path.GetDirectoryName(fileItem.FullPath);
                string newPath = Path.Combine(oldPath, fileItem.EditName);
                bool isNewFile = false;

                if (fileItem.IsFolder)
                {
                    try
                    {
                        if (Directory.Exists(fileItem.FullPath))
                            Directory.Move(fileItem.FullPath, newPath);
                        else
                        {
                            if (Directory.Exists(newPath))
                            {
                                AppModel.Window.ShowStatusError(
                                    $"Can't create folderOrFilePath {newPath} because it exists already.");
                                return;
                            }

                            fileItem.IsEditing = false;
                            var parent = fileItem.Parent;
                            parent.Files.Remove(fileItem);

                            fileItem.FullPath = newPath;
                            FolderStructure.InsertPathItemInOrder(fileItem, parent);

                            Dispatcher.Invoke(() =>
                            {
                                Directory.CreateDirectory(newPath);
                                fileItem.UpdateGitFileStatus();
                            }, DispatcherPriority.ApplicationIdle);
                        }
                    }
                    catch
                    {
                        MessageBox.Show("Unable to rename or create folderOrFilePath:\r\n" +
                                        newPath, "Path Creation Error",
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                }
                else
                {
                    try
                    {
                        if (File.Exists(fileItem.FullPath))
                        {
                            if (!File.Exists(newPath))
                                File.Move(fileItem.FullPath, newPath);
                            else
                                File.Copy(fileItem.FullPath, newPath, true);
                        }
                        else
                        {
                            if (File.Exists(newPath))
                            {
                                AppModel.Window.ShowStatusError(
                                    $"Can't create file {newPath} because it exists already.");
                                return;
                            }

                            isNewFile = true;
                            fileItem.IsEditing = false;
                            fileItem.FullPath = newPath; // force assignment so file watcher doesn't add another

                            File.WriteAllText(newPath, "");
                            fileItem.UpdateGitFileStatus();

                            var parent = fileItem.Parent;
                            fileItem.Parent.Files.Remove(fileItem);

                            FolderStructure.InsertPathItemInOrder(fileItem, parent);
                        }

                        // If tab was open - close it and re-open new file
                        var tab = Window.GetTabFromFilename(oldFile);
                        if (tab != null)
                        {
                            Window.CloseTab(oldFile);
                            WindowUtilities.DoEvents();
                            Window.OpenFile(newPath, isPreview: true);
                            WindowUtilities.DoEvents();
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show("Unable to rename or create file:\r\n" +
                                        newPath + "\r\n" + ex.Message, "File Creation Error",
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }

                fileItem.FullPath = newPath;
                fileItem.IsEditing = false;
                fileItem.IsSelected = true;

                ClearSelectedItems(ActivePathItem.Files, fileItem);

                var titem = GetTreeViewItem(fileItem, TreeFolderBrowser);
                titem?.Focus();
                if (isNewFile)
                    Window.OpenFile(newPath);
            }

            #endregion

            #region Search Textbox

            private DebounceDispatcher debounceTimer = new DebounceDispatcher();

            private void DoSearchOperation()
            {
                debounceTimer.Debounce(500, async  (p) =>
                {
                    Window.ShowStatusProgress("Filtering files...");
                    
                    if (string.IsNullOrEmpty(SearchText))
                    {
                        ActivePathItem.Files.Clear();
                        ActivePathItem.FullPath = FolderPath;
                        ActivePathItem.IsFolder = true;
                        SetTreeFromFolder(FolderPath, true);
                        FolderStructure.GetFilesAndFolders(FolderPath);
                        return;
                    }

                    await Dispatcher.InvokeAsync(() =>
                    {
                        FolderStructure.SetSearchVisibility(SearchText, ActivePathItem, SearchSubTrees);
                        Window.ShowStatus();
                    });
                });
            }
        
            private void TextSearch_TextChanged(object sender, TextChangedEventArgs e)
            {
                DoSearchOperation();
            }
        
            internal void MenuFindFiles_Click(object sender, RoutedEventArgs e)
            {
                TextSearch.Focus();
            }

            private void CheckSearchTree_Click(object sender, RoutedEventArgs e)
            {
                SearchSubTrees = !SearchSubTrees;
                TextSearch.Focus();

                if(!string.IsNullOrEmpty(SearchText))
                    DoSearchOperation();
            }


            public void FocusFileSearchBox(string searchText = null)
            {
                SearchText = searchText ?? string.Empty;
                TextSearch.Focus();
            }
        #endregion

        #region Context Menu Actions

        private void TreeFolderBrowser_ContextMenuOpening(object sender, ContextMenuEventArgs e)
            {
                FolderBrowserContextMenu.ShowContextMenu();
            }


            #endregion

            #region Items and Item Selection

            //private DateTime LastClickTime;
            //private PathItem LastItem;

            /// <summary>
            /// Handle renaming double click
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void TextFileOrFolderName_MouseUpToEdit(object sender, MouseButtonEventArgs e)
            {
                //if (e.ChangedButton == MouseButton.Left)
                //{
                //    var selected = TreeFolderBrowser.SelectedItem as PathItem;
                //    var t = DateTime.Now;

                //    if (LastItem == selected)
                //    {
                //        if (t >= LastClickTime.AddMilliseconds(System.Windows.Forms.SystemInformation.DoubleClickTime + 200) &&
                //            t <= LastClickTime.AddMilliseconds(System.Windows.Forms.SystemInformation.DoubleClickTime * 2 + 200))
                //        {
                //            FolderBrowserContextMenu.MenuRenameFile_Click(null, null);
                //        }
                //    }

                //    LastItem = selected;
                //    LastClickTime = t;
                //}
            }

            /// <summary>
            /// Special intercepts for New File and Folder handling.
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void TextEditFileItem_LostFocus(object sender, RoutedEventArgs e)
            {
                var selected = GetSelectedItem();
                if (selected != null)
                {

                    if (selected.DisplayName == "NewFile.md" || selected.DisplayName == "NewFolder")
                    {
                        selected.Parent.Files.Remove(selected);
                        return;
                    }

                    if (selected.IsEditing) // this should be handled by Key ops in treeview
                    {
                        RenameOrCreateFileOrFolder();
                    }

                    selected.IsEditing = false;
                    selected.SetIcon();
                }
            }

            /// <summary>
            /// Handle Text Selection for the filename only
            /// </summary>
            private void TextEditFileItem_GotFocus(object sender, RoutedEventArgs e)
            {
                var selected = TreeFolderBrowser.SelectedItem as PathItem;
                if (selected != null)
                {
                    var tb = sender as TextBox;
                    if (tb == null)
                        return;

                    if (!selected.DisplayName.Contains('.') && tb.SelectionLength > 0) // already selected
                        return;

                    var at = selected.DisplayName.IndexOf('.');
                    tb.SelectionStart = 0;
                    tb.SelectionLength = at > 1 ? at : selected.DisplayName.Length;
                }
            }

            #endregion

            #region Drag Operations


            private System.Windows.Point startPoint;

            private void TreeFolderBrowser_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
            {
                if (Window.PreviewTab != null)
                {
                    var filename = (Window.PreviewTab.Tag as MarkdownDocumentEditor)?.MarkdownDocument?.Filename;
                    if (filename != null)
                    {
                        var ext = Path.GetExtension(filename)?.ToLower();
                        if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
                            Window.CloseTab(Window.PreviewTab);
                    }
                }

                startPoint = e.GetPosition(null);
            }


            private void TreeFolderBrowser_MouseMove(object sender, MouseEventArgs e)
            {
                if (e.LeftButton == MouseButtonState.Pressed)
                {
                    var selected = GetSelectedItem(); //TreeFolderBrowser.SelectedItem as PathItem;

                    // Only allow the items to be dragged
                    var src = e.OriginalSource as TextBlock;
                    if (src == null)
                        return;

                    // only drag image files
                    if (selected == null)
                        return;

                    var mousePos = e.GetPosition(null);
                    var diff = startPoint - mousePos;

                    DragDropEffects effect = DragDropEffects.Move;
                    if (Keyboard.IsKeyDown(Key.LeftCtrl))
                        effect = DragDropEffects.Copy;

                    if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
                        || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
                    {
                        var treeViewItem = GetTreeViewItem(selected);
                        if (treeViewItem == null)
                            return;

                        var files = GetSelectedItems()
                            .Where(p => !string.IsNullOrEmpty(p.FullPath)) // dont move root or parent paths
                            .Select(p => p.FullPath).ToArray();

                        var dragData = new DataObject(DataFormats.FileDrop, files);
                        if (files.Length > 0)
                            dragData.SetText(files[0]); // so Web Browser can drop files
                        //dragData.SetText(string.Join("\n",files));   // so Web Browser can drop files

                        DragDrop.DoDragDrop(treeViewItem, dragData, effect);
                    }
                }
            }

            private void TreeViewItem_Drop(object sender, DragEventArgs e)
            {
                PathItem dropTargetPathItem = ActivePathItem; // assume root
                var npi = GetSelectedItems();

                var formats = e.Data.GetFormats();

                if (sender is TreeView)
                {
                    // dropped into treeview open space
                }
                else
                {
                    dropTargetPathItem = (e.OriginalSource as FrameworkElement)?.DataContext as PathItem;
                    if (dropTargetPathItem == null)
                        return;
                }

                e.Handled = true;


                if (formats.Contains("FileDrop"))
                {
                    HandleDroppedFiles(e.Data.GetData("FileDrop") as string[], dropTargetPathItem, e.Effects);

                    ClearSelectedItems(ActivePathItem.Files, dropTargetPathItem);
                    dropTargetPathItem.IsExpanded = true;
                    return;
                }

                if (!dropTargetPathItem.IsFolder)
                    dropTargetPathItem = dropTargetPathItem.Parent;

                var path = e.Data.GetData(DataFormats.UnicodeText) as string;
                if (string.IsNullOrEmpty(path))
                {
                    return;
                }

                string newPath;
                var sourceItem = FolderStructure.FindPathItemByFilename(ActivePathItem, path);
                if (sourceItem == null)
                {
                    // Handle dropped new files (from Explorer perhaps)
                    if (File.Exists(path))
                    {
                        newPath = Path.Combine(dropTargetPathItem.FullPath, Path.GetFileName(path));
                        mmFileUtils.CopyFileOrFolder(path, newPath, true);
                        AppModel.Window.ShowStatusSuccess($"File copied.");
                    }


                    return;
                }

                newPath = Path.Combine(dropTargetPathItem.FullPath, sourceItem.DisplayName);

                if (sourceItem.FullPath.Equals(newPath, StringComparison.InvariantCultureIgnoreCase))
                {
                    AppModel.Window.ShowStatusError($"File not moved.",
                        mmApp.Configuration.StatusMessageTimeout);
                    return;
                }

                try
                {
                    mmFileUtils.MoveFileOrFolder(sourceItem.FullPath, newPath, true);
                }
                catch (Exception ex)
                {
                    AppModel.Window.ShowStatusError($"Couldn't move file: {ex.Message}",
                        mmApp.Configuration.StatusMessageTimeout);
                    return;
                }

                dropTargetPathItem.IsExpanded = true;

                // wait for file watcher to pick up the file
                Dispatcher.Delay(200, (p) =>
                {
                    var srceItem = FolderStructure.FindPathItemByFilename(ActivePathItem, p as string);
                    if (srceItem == null)
                        return;
                    srceItem.IsSelected = true;
                }, newPath);

                AppModel.Window.ShowStatus($"File moved to: {newPath}", mmApp.Configuration.StatusMessageTimeout);
            }

            /// <summary>
            /// Handles files that were dropped on the tree view
            /// </summary>
            /// <param name="files">array of files</param>
            void HandleDroppedFiles(string[] files, PathItem target, DragDropEffects effect)
            {
                if (files == null)
                    return;

                WindowUtilities.DoEvents();

                Window.ShowStatusProgress("Copying files and folders...");

                WindowUtilities.DoEvents();

                string errors = "";

                //Task.Run(() =>
                //{
                foreach (var file in files)
                {
                    var isFile = File.Exists(file);
                    var isDir = Directory.Exists(file);
                    if (!isDir && !isFile)
                        continue;

                    string nPath = target.FullPath;
                    if (isFile)
                    {
                        if (!target.IsFolder)
                        {
                            var par = target.Parent == null ? ActivePathItem : target.Parent;
                            nPath = Path.Combine(Path.GetDirectoryName(target.FullPath), Path.GetFileName(file));
                        }

                        if (file == nPath)
                            continue;

                        try
                        {
                            // only move if EXPLICITLY using MOVE operation
                            if (effect == DragDropEffects.Move)
                            {
                                mmFileUtils.MoveFileOrFolder(file, nPath, confirmation: true);
                            }
                            else
                            {
                                mmFileUtils.CopyFileOrFolder(file, nPath, confirmation: true);
                            }
                        }
                        catch
                        {
                            errors += $"{nPath},";
                        }

                    }
                    else
                    {
                        var sourceFolderName = Path.GetFileName(file);
                        var targetFolder = Path.Combine(target.FullPath, sourceFolderName);

                        if (targetFolder != file)
                        {
                            try
                            {
                                if (effect == DragDropEffects.Move)
                                {
                                    mmFileUtils.MoveFileOrFolder(file, targetFolder);
                                }
                                else
                                {
                                    mmFileUtils.CopyFileOrFolder(file, targetFolder);
                                }

                                break;
                            }
                            catch
                            {
                                errors += $"{Path.GetFileName(file)},";
                            }
                        }
                    }


                }

                ClearSelectedItems();
                target.IsSelected = true;

                Dispatcher.InvokeAsync(() =>
                {
                    if (string.IsNullOrEmpty(errors))
                        Window.ShowStatusSuccess($"Files and Folders copied.");
                    else
                        Window.ShowStatusError($"There were errors copying files and folders.");
                });

            }

            #endregion

            #region INotifyPropertyChanged

            public event PropertyChangedEventHandler PropertyChanged;

            [NotifyPropertyChangedInvocator]
            protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
            {
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }


        #endregion
        
    }

    }

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Media3D;
using System.Windows.Threading;
using System.Xml;
using FontAwesome.WPF;
using MahApps.Metro.Controls;
using MarkdownMonster.Annotations;
using MarkdownMonster.Controls;
using MarkdownMonster.Controls.ContextMenus;
using MarkdownMonster.Utilities;
using Westwind.Utilities;
using UserControl = System.Windows.Controls.UserControl;


    namespace MarkdownMonster.Windows
    {
        /// <summary>
        /// Interaction logic for FolderBrowerSidebar.xaml
        /// </summary>
        public partial class FolderBrowerSidebar : UserControl, INotifyPropertyChanged
        {
            public MainWindow Window { get; set; }
            public AppModel AppModel { get; set; }

            public FolderBrowserContextMenu FolderBrowserContextMenu { get; set; }

            public string FolderPath
            {
                get { return _folderPath; }
                set
                {
                    if (value == _folderPath) return;

                    string filename = null;
                    if (!Directory.Exists(value))
                    {
                        if (!File.Exists(value))
                            value = null;
                        else
                        {
                            filename = value;
                            value = Path.GetDirectoryName(value);
                        }
                    }

                    var previousFolder = _folderPath;

                    _folderPath = value;
                    OnPropertyChanged(nameof(FolderPath));

                    if (Window == null) return;

                    SearchText = null;
                    SearchSubTrees = false;

                    if (string.IsNullOrEmpty(_folderPath))
                        ActivePathItem = new PathItem(); // empty the folderOrFilePath browser
                    else
                    {
                        if (filename != null && previousFolder == _folderPath && string.IsNullOrEmpty(SearchText))
                            SelectFileInSelectedFolderBrowserFolder(filename);
                        else
                            SetTreeFromFolder(filename ?? _folderPath, filename != null, SearchText);
                    }


                    if (ActivePathItem != null)
                    {
                        _folderPath = value;
                        mmApp.Configuration.FolderBrowser.AddRecentFolder(_folderPath);

                        OnPropertyChanged(nameof(FolderPath));
                        OnPropertyChanged(nameof(ActivePathItem));
                    }
                }
            }

            private string _folderPath;


            public string SearchText
            {
                get { return _searchText; }
                set
                {
                    if (value == _searchText) return;
                    _searchText = value;
                    OnPropertyChanged();
                }
            }

            private string _searchText;



            public bool SearchSubTrees
            {
                get { return _searchSubTrees; }
                set
                {
                    if (value == _searchSubTrees) return;
                    _searchSubTrees = value;
                    OnPropertyChanged();
                }
            }

            private bool _searchSubTrees;


            public PathItem ActivePathItem
            {
                get { return _activePath; }
                set
                {
                    if (Equals(value, _activePath)) return;
                    _activePath = value;
                    OnPropertyChanged(nameof(ActivePathItem));
                }
            }

            private PathItem _activePath;


            /// <summary>
            /// Internal value
            /// </summary>
            public FolderStructure FolderStructure {
                get
                {
                    return new FolderStructure(this);
                }
            } 


            /// <summary>
            /// Filewatcher used to detect changes to files in the active folder
            /// including subdirectories.
            /// </summary>
            private FileSystemWatcher FileWatcher = null;


            #region Initialization

            public FolderBrowerSidebar()
            {
                InitializeComponent();
                Focusable = true;

                DataContext = null;

                Loaded += FolderBrowerSidebar_Loaded;
                Unloaded += (s, e) => ReleaseFileWatcher();
            }


            private void FolderBrowerSidebar_Loaded(object sender, RoutedEventArgs e)
            {
                AppModel = mmApp.Model;
                Window = AppModel.Window;
                DataContext = this;
                
                FolderBrowserContextMenu = new FolderBrowserContextMenu(this);

                // Load explicitly here to fire *after* behavior has attached
                ComboFolderPath.PreviewKeyUp += ComboFolderPath_PreviewKeyDown;

                TreeFolderBrowser.GotFocus += TreeFolderBrowser_GotFocus;
                ComboFolderPath.GotFocus += TreeFolderBrowser_GotFocus;
            }


            private void TreeFolderBrowser_GotFocus(object sender, RoutedEventArgs e)
            {
                // ensure that directory wasn't deleted under us
                if (!Directory.Exists(FolderPath))
                    FolderPath = null;
            }

            /// <summary>
            /// Updates the Git status of the files currently active
            /// in the tree.
            /// </summary>
            /// <param name="pathItem"></param>
            public void UpdateGitStatus(PathItem pathItem = null)
            {
                if (pathItem == null)
                    pathItem = ActivePathItem;

                FolderStructure.UpdateGitFileStatus(pathItem);
            }

            #endregion

            #region FileWatcher

            private void FileWatcher_Renamed(object sender, RenamedEventArgs e)
            {
                if (mmApp.Model == null || mmApp.Model.Window == null)
                    return;

                mmApp.Model.Window.Dispatcher.Invoke(() =>
                {

                    var file = e.FullPath;
                    var oldFile = e.OldFullPath;

                    var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, oldFile);
                    if (pi == null)
                        return;

                    pi.FullPath = file;
                    pi.Parent.Files.Remove(pi);

                    FolderStructure.InsertPathItemInOrder(pi, pi.Parent);
                }, DispatcherPriority.ApplicationIdle);
            }

            private void FileWatcher_CreateOrDelete(object sender, FileSystemEventArgs e)
            {

                if (mmApp.Model == null || mmApp.Model.Window == null)
                    return;

                if (!Directory.Exists(FolderPath))
                {
                    FolderPath = null;
                    return;
                }

                var file = e.FullPath;
                if (string.IsNullOrEmpty(file))
                    return;

                if (e.ChangeType == WatcherChangeTypes.Deleted)
                {
                    mmApp.Model.Window.Dispatcher.Invoke(() =>
                    {
                        var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, file);
                        if (pi == null)
                            return;

                        pi.Parent.Files.Remove(pi);

                        //Debug.WriteLine("After: " + pi.Parent.Files.Count + " " + file);
                    }, DispatcherPriority.ApplicationIdle);
                }

                if (e.ChangeType == WatcherChangeTypes.Created)
                {
                    mmApp.Model.Window.Dispatcher.Invoke(() =>
                    {
                        // Skip ignored Extensions
                        string[] extensions = null;
                        if (!string.IsNullOrEmpty(mmApp.Model.Configuration.FolderBrowser.IgnoredFileExtensions))
                            extensions =
                                mmApp.Model.Configuration.FolderBrowser.IgnoredFileExtensions.Split(new[] {','},
                                    StringSplitOptions.RemoveEmptyEntries);

                        if (extensions != null && extensions.Any(ext =>
                            file.EndsWith(ext, StringComparison.InvariantCultureIgnoreCase)))
                            return;

                        var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, file);
                        if (pi != null) // Already exists in the tree
                            return;

                        // does the path exist?
                        var parentPathItem =
                            FolderStructure.FindPathItemByFilename(ActivePathItem, Path.GetDirectoryName(file));

                        // Path either doesn't exist or is not expanded yet so don't attach - opening will trigger
                        if (parentPathItem == null ||
                            (parentPathItem.Files.Count == 1 && parentPathItem.Files[0] == PathItem.Empty))
                            return;

                        bool isFolder = Directory.Exists(file);
                        pi = new PathItem()
                        {
                            FullPath = file, IsFolder = isFolder, IsFile = !isFolder, Parent = parentPathItem
                        };
                        // make sure we pick up the child items so the node shows as expandable if there are items
                        if (isFolder)
                        {
                            var newPi = FolderStructure.GetFilesAndFolders(pi.FullPath, nonRecursive: true);
                            pi.Files = newPi.Files;
                        }

                        pi.SetIcon();

                        FolderStructure.InsertPathItemInOrder(pi, parentPathItem);

                    }, DispatcherPriority.ApplicationIdle);
                }

            }


            private void FileWatcher_Changed(object sender, FileSystemEventArgs e)
            {
                if (mmApp.Model == null || mmApp.Model.Window == null)
                    return;

                Dispatcher.Invoke(async () =>
                {
                    var file = e.FullPath;

                    var pi = FolderStructure.FindPathItemByFilename(ActivePathItem, file);
                    if (pi == null)
                        return;

                    int errorCount = 0;
                    while (errorCount < 3)
                    {
                        try
                        {
                            var gh = new GitHelper();
                            pi.FileStatus = gh.GetGitStatusForFile(pi.FullPath);
                            break;
                        }
                        catch
                        {
                            await Task.Delay(25);
                            errorCount++;
                        }
                    }

                }, DispatcherPriority.ApplicationIdle);
            }

            private void AttachFileWatcher(string fullPath)
            {
                if (fullPath == null) return;

                ReleaseFileWatcher();

                // no file watcher for root paths
                var di = new DirectoryInfo(fullPath);
                if (di.Root.FullName == fullPath)
                {
                    AppModel.Window.ShowStatusProgress("Drive root selected: Files are not updated in root folders.",
                        mmApp.Configuration.StatusMessageTimeout, spin: false, icon: FontAwesomeIcon.Circle);
                    return;
                }

                if (FileWatcher != null)
                    ReleaseFileWatcher();

                if (string.IsNullOrEmpty(fullPath))
                    return;

                if (!Directory.Exists(fullPath))
                {
                    FolderPath = null;
                    return;
                }

                FileWatcher =
                    new FileSystemWatcher(fullPath) {IncludeSubdirectories = true, EnableRaisingEvents = true};

                FileWatcher.Created += FileWatcher_CreateOrDelete;
                FileWatcher.Deleted += FileWatcher_CreateOrDelete;
                FileWatcher.Renamed += FileWatcher_Renamed;
                FileWatcher.Changed += FileWatcher_Changed;
            }


            public void ReleaseFileWatcher()
            {
                if (FileWatcher != null)
                {
                    FileWatcher.Changed -= FileWatcher_Changed;
                    FileWatcher.Deleted -= FileWatcher_CreateOrDelete;
                    FileWatcher.Created -= FileWatcher_CreateOrDelete;
                    FileWatcher.Renamed -= FileWatcher_Renamed;

                    // TODO: MAKE SURE THIS DOESN'T HAVE SIDE EFFECTS (Hanging on shutdown)
                    // This can hang in weird ways when application is shutting down
                    // Since this is the only time this should go away this is probably safe but ugly
                    //FileWatcher.Dispose();

                    FileWatcher = null;
                }
            }

            #endregion

            #region Folder Button and Text Handling

            public void OpenFile(string file, bool forceEditorFocus = false)
            {
                Window.OpenFile(file, noFocus: !forceEditorFocus);
            }

            /// <summary>
            /// Sets the tree's content from a folderOrFilePath or filename.
            ///
            /// This method is also called from the FolderPath property Getter
            /// after some pre-processing.
            /// </summary>
            /// <param name="folderOrFilePath">Folder or File path to load. If File folder is loaded and file selected</param>
            /// <param name="setFocus">Optional - determines on whether focus is set to the TreeView Item</param>
            /// <param name="searchText">Optional - search text filter that is applied to the file names</param>
            public void SetTreeFromFolder(string folderOrFilePath, bool setFocus = false, string searchText = null)
            {
                if (Window == null)
                    return;

                string fileName = null;
                if (File.Exists(folderOrFilePath))
                {
                    fileName = folderOrFilePath;
                    folderOrFilePath = Path.GetDirectoryName(folderOrFilePath);
                }

                Window.ShowStatusProgress($"Retrieving files for folderOrFilePath {folderOrFilePath}...");

                Dispatcher.InvokeAsync(() =>
                {
                    // just get the top level folderOrFilePath first
                    ActivePathItem = null;
                    WindowUtilities.DoEvents();

                    var items = FolderStructure.GetFilesAndFolders(folderOrFilePath, nonRecursive: true,
                                    ignoredFolders: mmApp.Configuration.FolderBrowser.IgnoredFolders,
                                    ignoredFileExtensions: mmApp.Configuration.FolderBrowser.IgnoredFileExtensions);
                    ActivePathItem = items;

                    WindowUtilities.DoEvents();
                    Window.ShowStatus();

                    if (TreeFolderBrowser.HasItems)
                        SetTreeViewSelectionByIndex(0);

                    if (setFocus)
                        TreeFolderBrowser.Focus();


                    AttachFileWatcher(folderOrFilePath);

                    FolderStructure.UpdateGitFileStatus(items);

                    if (!string.IsNullOrEmpty(fileName))
                        SelectFileInSelectedFolderBrowserFolder(fileName);

                }, DispatcherPriority.ApplicationIdle);
            }

            /// <summary>
            /// Selects a file in the top level folder browser folder
            /// by file name.
            /// </summary>
            /// <param name="fileName">filename with full path - must match case</param>
            public void SelectFileInSelectedFolderBrowserFolder(string fileName, bool setFocus = true)
            {
                if (!string.IsNullOrEmpty(fileName))
                {
                    foreach (var file in ActivePathItem.Files)
                    {
                        if (file.FullPath == fileName)
                        {
                            if (setFocus)
                                TreeFolderBrowser.Focus();

                            file.IsSelected = true;
                        }
                    }
                }

            }


            //private void ButtonUseCurrentFolder_Click(object sender, RoutedEventArgs e)
            //{
            //    var doc = AppModel?.ActiveDocument;
            //    if (doc == null)
            //        return;

            //    SetTreeFromFolder(doc.Filename, true);
            //}


            public void SetTreeViewSelectionByIndex(int index)
            {
                if (TreeFolderBrowser
                    .ItemContainerGenerator
                    .ContainerFromIndex(index) is TreeViewItem item)
                    item.IsSelected = true;
            }

            public void SetTreeViewSelectionByItem(PathItem item, TreeViewItem parentTreeViewItem = null)
            {
                TreeViewItem treeitem = GetNestedTreeviewItem(item);

                if (treeitem != null)
                {
                    treeitem.BringIntoView();

                    if (treeitem.Parent != null && treeitem.Parent is TreeViewItem)
                        ((TreeViewItem) treeitem.Parent).IsExpanded = true;

                    treeitem.IsSelected = true;

                    // show edited filename with file stem selected
                    if (item.IsEditing && item.IsFile &&
                        item.DisplayName != null && item.DisplayName.Contains('.'))
                    {
                        Dispatcher.Invoke(() =>
                        {
                            var tb = WindowUtilities.FindVisualChild<TextBox>(treeitem);
                            if (tb == null)
                                return;
                            var idx = item.DisplayName.IndexOf(".");
                            if (idx > 0)
                            {
                                tb.SelectionStart = 0;
                                tb.SelectionLength = idx;
                            }
                        }, DispatcherPriority.ApplicationIdle);
                    }
                }
            }

            private void ComboFolderPath_PreviewKeyDown(object sender, KeyEventArgs e)
            {
                if (e.Key == Key.Enter
                ) // || e.Key == Key.Tab && (Keyboard.Modifiers & ModifierKeys.Shift) != (ModifierKeys.Shift) )
                {
                    ((ComboBox) sender).IsDropDownOpen = false;
                    TreeFolderBrowser.Focus();
                    e.Handled = true;
                }
            }

            private void ButtonRecentFolders_Click(object sender, RoutedEventArgs e)
            {
                if (ButtonRecentFolders.ContextMenu == null)
                    ButtonRecentFolders.ContextMenu = new ContextMenu();

                mmApp.Configuration.FolderBrowser.UpdateRecentFolderContextMenu(ButtonRecentFolders.ContextMenu);
                if (ButtonRecentFolders.ContextMenu.Items.Count > 0)
                    ButtonRecentFolders.ContextMenu.IsOpen = true;

            }

            private void ButtonSelectFolder_Click(object sender, RoutedEventArgs e)
            {
                string folder = FolderPath;

                if (string.IsNullOrEmpty(folder))
                {
                    folder = AppModel.ActiveDocument?.Filename;
                    if (string.IsNullOrEmpty(folder))
                        folder = Path.GetDirectoryName(folder);
                    else
                        folder = KnownFolders.GetPath(KnownFolder.Libraries);
                }

                folder = mmWindowsUtils.ShowFolderDialog(folder,
                    "Select folderOrFilePath to open in the Folder Browser");
                if (folder == null)
                    return;

                FolderPath = folder;
                TreeFolderBrowser.Focus();
            }

            private void ButtonRefreshFolder_Click(object sender, RoutedEventArgs e)
            {
                if (ActivePathItem != null)
                {
                    ActivePathItem.Files.Clear();
                    ActivePathItem.FullPath = FolderPath;
                    ActivePathItem.IsFolder = true;
                }

                SetTreeFromFolder(FolderPath, true);
            }

            #endregion


            #region TreeView Selections

            /// <summary>
            /// Returns the Active Selected Path Item
            /// </summary>
            /// <returns></returns>
            public PathItem GetSelectedPathItem()
            {
                return TreeFolderBrowser.SelectedItem as PathItem;
            }


            /// <summary>
            /// Returns a list of selected items.
            /// </summary>
            /// <returns>List of items</returns>
            public List<PathItem> GetSelectedPathItems()
            {
                return GetSelectedItems(TreeFolderBrowser.Items);
            }


            /// <summary>
            /// Explicitly selects the active path item and forces focus into it
            /// </summary>
            /// <param name="forceEditorFocus"></param>
            public void HandleItemSelection(bool forceEditorFocus = false)
            {
                var fileItem = GetSelectedPathItem(); //TreeFolderBrowser.SelectedItem as PathItem;
                if (fileItem == null)
                    return;
                
                if (fileItem.FullPath == "..")
                    FolderPath = Path.GetDirectoryName(FolderPath.Trim('\\'));
                else if (fileItem.IsFolder)
                    fileItem.IsExpanded = !fileItem.IsExpanded;
                else
                    OpenFile(fileItem.FullPath, forceEditorFocus);
            }

            /// <summary>
            /// Retrieves a nested TreeViewItem by walking the hierarchy.
            /// Specify a root treeview or treeviewitem and it then walks
            /// the hierarchy to find the item
            /// </summary>
            /// <param name="item">Item to find</param>
            /// <param name="treeItem">Parent item to start search from</param>
            /// <returns></returns>
            public TreeViewItem GetNestedTreeviewItem(object item, ItemsControl treeItem = null)
            {
                if (treeItem == null)
                    treeItem = TreeFolderBrowser;

                return WindowUtilities.GetNestedTreeviewItem(item, treeItem);
            }

            /// <summary>
            /// Used for TreeViewSelection() - will hold current selection after
            /// </summary>
            private PathItem lastSelectedPathItem = PathItem.Empty;


            /// <summary>
            /// This selects the item including multi-file selections
            /// </summary>
            private void TreeViewSelection(TreeViewItem titem, Key key = Key.None)
            {
                var pitem = titem?.DataContext as PathItem;
                if (pitem == null || ActivePathItem == null) return;

                try
                {
                    pitem.IsSelected = true;

                    // clear all selections except in current folder
                    var selItems = pitem.Parent?.Files.Where(p => p.IsSelected).ToArray();
                    ClearSelectedItems(ActivePathItem?.Files, except: selItems);

                    if (pitem.IsFolder)
                    {
                        foreach (var pi in pitem.Files)
                            pi.IsSelected = pitem.IsSelected;
                    }

                    if (Keyboard.IsKeyDown(Key.LeftCtrl) || key == Key.LeftCtrl)
                    {
                        return; // don't need to clear any items additive
                    }

                    if (Keyboard.IsKeyDown(Key.LeftShift) || key == Key.LeftShift)
                    {
                        // select items between cursor position
                        var items = pitem.Parent?.Files;
                        if (items == null)
                            items = new ObservableCollection<PathItem>(TreeFolderBrowser.Items.Cast<PathItem>());


                        var idx = items.IndexOf(pitem);
                        var lastidx = items.IndexOf(lastSelectedPathItem);

                        if (lastidx < 0 || idx == lastidx)
                            return;

                        int start = idx;
                        int stop = lastidx;
                        if (lastidx < idx)
                        {
                            start = lastidx;
                            stop = idx;
                        }

                        for (int i = start; i < stop; i++)
                        {
                            items[i].IsSelected = pitem.IsSelected;
                        }

                        return;
                    }

                    // single click - we have to clear all but the new selection
                    ClearSelectedItems(ActivePathItem?.Files, pitem);
                }
                finally
                {
                    lastSelectedPathItem = pitem;
                }
            }

            /// <summary>
            /// Returns the first selected item in the tree from the top down.
            /// </summary>
            /// <param name="items">Root tree nodes or child nodes. Defaults to the root</param>
            /// <returns>Selected path item or null</returns>
            public PathItem GetSelectedItem(ItemCollection items = null)
            {
                if (items == null)
                    items = TreeFolderBrowser.Items;

                foreach (var childItem in items)
                {
                    if (pi.IsSelected)
                        return pi;

                    if (pi.Files.Count > 0)
                    {
                        var titem = GetTreeViewItem(pi);

                        if (titem == null)
                            continue;

                        pi = GetSelectedItem(titem.Items);

                        if (childItem is PathItem pi)
                            return pi;
                    }
                }

                return null;
            }

            /// <summary>
            /// Returns all selected Path Items in the folder tree
            /// </summary>
            /// <param name="items">Root tree nodes or child nodes. Defaults to the root</param>
            /// <param name="list">Optional list passed in for recursive child parsing</param>
            /// <returns>Returns a list of matching items or an empty list</returns>
            public List<PathItem> GetSelectedItems(ItemCollection items = null, List<PathItem> list = null)
            {
                if (items == null)
                    items = TreeFolderBrowser.Items;

                if (list == null)
                    list = new List<PathItem>();

                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;
                    if (pi.IsSelected)
                        list.Add(pi);

                    if (pi.Files.Count > 0)
                    {
                        var titem = GetTreeViewItem(pi);
                        if (titem == null) continue;
                        GetSelectedItems(titem.Items, list);
                    }
                }

                return list;
            }


            /// <summary>
            /// Clears all selected items
            /// </summary>
            /// <param name="items">A node of the tree. Defaults to the root of the tree.</param>
            /// <param name="except">Optional - A PathItem that should stay selected.</param>
            public void ClearSelectedItems(ItemCollection items = null, params PathItem[] except)
            {
                if (items == null)
                    items = TreeFolderBrowser.Items;


                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;

                    if (except != null && except.Contains(pi))
                        pi.IsSelected = true;
                    else
                        pi.IsSelected = false;

                    if (pi.Files.Count == 0) continue;

                    var titem = GetTreeViewItem(pi);

                    if (titem?.Items == null) continue;

                    ClearSelectedItems(titem.Items, except);
                }
            }

            /// <summary>
            /// Clears all selected items
            /// </summary>
            /// <param name="items">A node of the tree. Defaults to the root of the tree.</param>
            /// <param name="except">Optional - A PathItem that should stay selected.</param>
            /// <param name="noClearParent">Optional - a parent folder that should not be cleared</param>
            public void ClearSelectedItems(IEnumerable<PathItem> items, params PathItem[] except)
            {
                if (items == null)
                    items = ActivePathItem.Files;

                foreach (var childItem in items)
                {
                    var pi = childItem as PathItem;

                    if (except != null && except.Contains(pi))
                        pi.IsSelected = true;
                    else
                        pi.IsSelected = false;

                    ClearSelectedItems(pi.Files, except);
                }
            }

            /// <summary>
            /// Returns a TreeViewItem from a Path Item recursively
            /// </summary>
            /// <param name="pathItem">A path item</param>
            /// <returns></returns>
            public TreeViewItem GetTreeViewItem(PathItem pathItem, ItemsControl parentContainer = null,
                bool nonRecursive = false)
            {
                if (pathItem == null)
                    return null;

                if (parentContainer == null)
                    parentContainer = TreeFolderBrowser;

                if (parentContainer
                    .ItemContainerGenerator
                    .ContainerFromItem(pathItem) is TreeViewItem titem || nonRecursive) return titem;

                foreach (var item in parentContainer.Items)
                {
                    var folder = item as PathItem;
                    if (folder == null || !folder.IsFolder) continue;

                    var folderItem = GetTreeViewItem(folder, parentContainer);
                    if (folderItem != null)
                    {
                        titem = GetTreeViewItem(pathItem, folderItem);

                        if (parentContainer
                    .ItemContainerGenerator
                    .ContainerFromItem(pathItem) is TreeViewItem titem)
                            break;
                    }
                }

                return titem;
            }

            #endregion

            #region TreeView Selection Events

            private string searchFilter = string.Empty;
            private DateTime searchFilterLast = DateTime.MinValue;

            private void TreeView_Keydown(object sender, KeyEventArgs e)
            {
                var selected = TreeFolderBrowser.SelectedItem as PathItem;

                // this works without a selection
                if ((e.Key == Key.F2 && Keyboard.IsKeyDown(Key.LeftShift)) ||
                    (e.Key == Key.N && Keyboard.IsKeyDown(Key.LeftCtrl)))
                {
                    if (selected == null || !selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuAddFile_Click(sender, null);
                        e.Handled = true;
                    }

                    return;
                }

                if (e.Key == Key.F8)
                {
                    if (selected == null || !selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuAddDirectory_Click(sender, null);
                        e.Handled = true;
                    }
                }

                if (selected == null)
                    return;

                if (e.Key == Key.Enter || e.Key == Key.Tab)
                {
                    if (!selected.IsEditing)
                        HandleItemSelection(forceEditorFocus: true);
                    else
                        RenameOrCreateFileOrFolder();


                    e.Handled = true;
                }
                else if (e.Key == Key.Escape)
                {
                    if (selected.IsEditing)
                    {
                        selected.IsEditing = false;
                        if (!string.IsNullOrEmpty(selected.OriginalRenamePath))
                        {
                            selected.FullPath = selected.OriginalRenamePath;
                            selected.OriginalRenamePath = null;
                        }
                        else
                            selected.Parent?.Files?.Remove(selected);
                    }
                }
                else if (e.Key == Key.F2)
                {
                    if (!selected.IsEditing)
                        FolderBrowserContextMenu.MenuRenameFile_Click(sender, null);
                }
                else if (e.Key == Key.Delete)
                {
                    if (!selected.IsEditing)
                        FolderBrowserContextMenu.MenuDeleteFile_Click(sender, null);
                }
                else if (e.Key == Key.G && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    if (!selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuCommitGit_Click(null, null);
                        e.Handled = true;
                    }
                }
                else if (e.Key == Key.Z && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    if (!selected.IsEditing)
                    {
                        FolderBrowserContextMenu.MenuUndoGit_Click(null, null);
                        e.Handled = true;
                    }
                }
                // Copy, Cut
                else if ((e.Key == Key.C || e.Key == Key.X) && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    var menu = new FolderBrowserContextMenu(this);
                    menu.FileBrowserCopyFile(e.Key == Key.X);
                    e.Handled = true;
                }
                // Paste Files(s) from clipboard
                else if (e.Key == Key.V && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    var menu = new FolderBrowserContextMenu(this);
                    menu.FileBrowserPasteFile();
                    e.Handled = true;
                }
                // Find in Files
                else if (e.Key == Key.F && Keyboard.IsKeyDown(Key.LeftCtrl) && Keyboard.IsKeyDown(Key.LeftShift))
                {
                    AppModel.Commands.OpenSearchSidebarCommand.Execute(FolderPath);
                    e.Handled = true;
                }
                // Find
                else if (e.Key == Key.F && Keyboard.IsKeyDown(Key.LeftCtrl))
                {
                    TextSearch.Focus();
                    e.Handled = true;
                }
                

                if (e.Handled || selected.IsEditing || Keyboard.IsKeyDown(Key.LeftCtrl))
                    return;

                // search key
                if (e.Key >= Key.A && e.Key <= Key.Z ||
                    e.Key >= Key.D0 && e.Key <= Key.D9 ||
                    e.Key == Key.OemPeriod ||
                    e.Key == Key.Space ||
                    e.Key == Key.Separator ||
                    e.Key == Key.OemMinus ||
                    e.Key == Key.OemPipe ||
                    e.Key == Key.Back &&
                    // ignore control/alt keys
                    (!Keyboard.IsKeyDown(Key.LeftCtrl) && !Keyboard.IsKeyDown(Key.LeftAlt)))
                {
                    //Debug.WriteLine("Treeview TreeDown: " + e.Key + " shfit: " + Keyboard.IsKeyDown(Key.LeftShift));
                    var keyConverter = new KeyConverter();

                    string keyText = string.Empty;
                    bool isShiftDown = Keyboard.IsKeyDown(Key.LeftShift);
                    bool isBack = false;

                    // special key mapping
                    if (e.Key == Key.OemPeriod)
                        keyText = ".";
                    else if (e.Key == Key.OemMinus)
                        keyText = "-";
                    else if (e.Key == Key.Space)
                        keyText = " ";
                    else if(e.Key == Key.OemPipe)
                        keyText = "|";
                    else if (isShiftDown)
                    {
                        if (e.Key == Key.OemMinus)
                            keyText = "_";
                        else if (e.Key == Key.D1)
                            keyText = "!";
                        else if (e.Key == Key.D2)
                            keyText = "@";
                        else if (e.Key == Key.D3)
                            keyText = "#";
                        else if (e.Key == Key.D4)
                            keyText = "$";
                        else if (e.Key == Key.D5)
                            keyText = "%";
                        else if (e.Key == Key.D7)
                            keyText = "&";
                    }
                    else if (e.Key == Key.Back)
                    {
                        isBack = true;
                        if (searchFilter.Length > 0)
                            searchFilter = searchFilter.Substring(0,searchFilter.Length-1);
                    }
                    else
                        keyText = keyConverter.ConvertToString(e.Key);

                    if (searchFilterLast > DateTime.Now.AddSeconds(-1.2))
                    {
                        if (!isBack)
                            searchFilter += keyText.ToLower();
                    }
                    else
                    {
                        if(isBack)
                            searchFilter = string.Empty;
                        else
                            searchFilter = keyText.ToLower();
                    }

                    var parentPath = selected.Parent;
                    if (parentPath == null)
                        parentPath = ActivePathItem; // root

                    ClearSelectedItems(parentPath.Files);
                    selected.IsSelected = false;

                    Window.ShowStatus("File search filter: " + searchFilter, 2000);

                    var lowerFilter = searchFilter.ToLower();
                
                    var item = parentPath.Files.FirstOrDefault(sf => sf.DisplayName.ToLower().StartsWith(lowerFilter));
                    if (item != null)
                    {
                        item.IsSelected = true;

                        // force the native selection to release the old selection
                        var tvItem = GetTreeViewItem(item);
                        if (tvItem != null) tvItem.IsSelected = true;
                    }
                    
                    searchFilterLast = DateTime.Now;
                }

            }

            /// <summary>
            /// Handle certain keys that aren't triggering in KeyDown
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void TreeViewItem_PreviewKeyUp(object sender, KeyEventArgs e)
            {

                var titem = sender as TreeViewItem;
                var selected = titem?.DataContext as PathItem; //TreeFolderBrowser.SelectedItem as PathItem;

                if (e.Key == Key.F1)
                {
                    AppModel.Commands.HelpCommand.Execute("_4xs10gaui.htm");
                    e.Handled = true;
                }
                else if (e.Key == Key.Down || e.Key == Key.Up)
                {
                    // select the item if not already selected
                    TreeViewSelection(titem, e.Key);
                }
            }

            private void TreeViewItem_MouseDoubleClick(object sender, MouseButtonEventArgs e)
            {
                //LastClickTime = DateTime.MinValue;   // 

                // select the item including multi-item selection
                TreeViewSelection(sender as TreeViewItem);

                HandleItemSelection(forceEditorFocus: true);
            }



            private void TreeViewItem_MouseUpClick(object sender, MouseButtonEventArgs e)
            {
                if (e.ClickCount == 2)
                    return;

                var titem = sender as TreeViewItem;
                if (titem == null) return;

                var selected = titem.DataContext as PathItem;
                if (selected == null)
                    return;

                // select the item including multi-item selection
                TreeViewSelection(titem);
                e.Handled = true;

                var filePath = selected.FullPath;

                if (string.IsNullOrEmpty(filePath))
                    return;

                var ext = Path.GetExtension(filePath).ToLower();
                if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
                {
                    Window.OpenBrowserTab(filePath, isImageFile: true);
                    return;
                }


                var tab = AppModel.Window.GetTabFromFilename(filePath);
                if (tab != null)
                {
                    AppModel.Window.TabControl.SelectedItem = tab;
                    return;
                }

                if (ext == ".md" || ext == ".markdown")
                    Window.RefreshTabFromFile(filePath, isPreview: true, noFocus: true);
                else if (ext == ".html" || ext == ".htm")
                    Window.OpenBrowserTab(filePath);


            }

            private void TreeViewItem_PreviewMouseRightButtonUp(object sender, MouseButtonEventArgs e)
            {
                var item = ElementHelper.FindVisualTreeParent<TreeViewItem>(e.OriginalSource as FrameworkElement);
                if (item != null)
                    item.IsSelected = true;

                var ctx = new FolderBrowserContextMenu(this);
                ctx.ShowContextMenu();
            }


            private void TreeFolderBrowser_Expanded(object sender, RoutedEventArgs e)
            {
                var tvi = e.OriginalSource as TreeViewItem;
                if (tvi == null)
                    return;

                tvi.IsSelected = true;

                var selected = TreeFolderBrowser.SelectedItem as PathItem;
                if (selected == null || selected.IsFile || selected.FullPath == "..")
                    return;

                if (selected.Files != null && selected.Files.Count == 1 && selected.Files[0] == PathItem.Empty)
                {
                    var subfolder = FolderStructure.GetFilesAndFolders(selected.FullPath, nonRecursive: true,
                        parentPathItem: selected);
                    FolderStructure.UpdateGitFileStatus(subfolder);
                }
            }


            void RenameOrCreateFileOrFolder()
            {
                var fileItem = TreeFolderBrowser.SelectedItem as PathItem;
                if (fileItem == null)
                    return;

                fileItem.EditName = fileItem.EditName?.Trim();

                if (string.IsNullOrEmpty(fileItem.EditName) ||
                    fileItem.DisplayName == fileItem.EditName && File.Exists(fileItem.FullPath))
                {
                    fileItem.IsEditing = false;
                    return;
                }

                if (FileUtils.HasInvalidPathCharacters(fileItem.DisplayName))
                {
                    Window.ShowStatusError($"Invalid filename for renaming: {fileItem.DisplayName}");
                    return;
                }

                string oldFile = fileItem.FullPath;
                string oldPath = Path.GetDirectoryName(fileItem.FullPath);
                string newPath = Path.Combine(oldPath, fileItem.EditName);
                bool isNewFile = false;

                if (fileItem.IsFolder)
                {
                    try
                    {
                        if (Directory.Exists(fileItem.FullPath))
                            Directory.Move(fileItem.FullPath, newPath);
                        else
                        {
                            if (Directory.Exists(newPath))
                            {
                                AppModel.Window.ShowStatusError(
                                    $"Can't create folderOrFilePath {newPath} because it exists already.");
                                return;
                            }

                            fileItem.IsEditing = false;
                            var parent = fileItem.Parent;
                            parent.Files.Remove(fileItem);

                            fileItem.FullPath = newPath;
                            FolderStructure.InsertPathItemInOrder(fileItem, parent);

                            Dispatcher.Invoke(() =>
                            {
                                Directory.CreateDirectory(newPath);
                                fileItem.UpdateGitFileStatus();
                            }, DispatcherPriority.ApplicationIdle);
                        }
                    }
                    catch
                    {
                        MessageBox.Show("Unable to rename or create folderOrFilePath:\r\n" +
                                        newPath, "Path Creation Error",
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                }
                else
                {
                    try
                    {
                        if (File.Exists(fileItem.FullPath))
                        {
                            if (!File.Exists(newPath))
                                File.Move(fileItem.FullPath, newPath);
                            else
                                File.Copy(fileItem.FullPath, newPath, true);
                        }
                        else
                        {
                            if (File.Exists(newPath))
                            {
                                AppModel.Window.ShowStatusError(
                                    $"Can't create file {newPath} because it exists already.");
                                return;
                            }

                            isNewFile = true;
                            fileItem.IsEditing = false;
                            fileItem.FullPath = newPath; // force assignment so file watcher doesn't add another

                            File.WriteAllText(newPath, "");
                            fileItem.UpdateGitFileStatus();

                            var parent = fileItem.Parent;
                            fileItem.Parent.Files.Remove(fileItem);

                            FolderStructure.InsertPathItemInOrder(fileItem, parent);
                        }

                        // If tab was open - close it and re-open new file
                        var tab = Window.GetTabFromFilename(oldFile);
                        if (tab != null)
                        {
                            Window.CloseTab(oldFile);
                            WindowUtilities.DoEvents();
                            Window.OpenFile(newPath, isPreview: true);
                            WindowUtilities.DoEvents();
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show("Unable to rename or create file:\r\n" +
                                        newPath + "\r\n" + ex.Message, "File Creation Error",
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }

                fileItem.FullPath = newPath;
                fileItem.IsEditing = false;
                fileItem.IsSelected = true;

                ClearSelectedItems(ActivePathItem.Files, fileItem);

                var titem = GetTreeViewItem(fileItem, TreeFolderBrowser);
                titem?.Focus();
                if (isNewFile)
                    Window.OpenFile(newPath);
            }

            #endregion

            #region Search Textbox

            private DebounceDispatcher debounceTimer = new DebounceDispatcher();

            private void DoSearchOperation()
            {
                debounceTimer.Debounce(500, async  (p) =>
                {
                    Window.ShowStatusProgress("Filtering files...");
                    
                    if (string.IsNullOrEmpty(SearchText))
                    {
                        ActivePathItem.Files.Clear();
                        ActivePathItem.FullPath = FolderPath;
                        ActivePathItem.IsFolder = true;
                        SetTreeFromFolder(FolderPath, true);
                        FolderStructure.GetFilesAndFolders(FolderPath);
                        return;
                    }

                    await Dispatcher.InvokeAsync(() =>
                    {
                        FolderStructure.SetSearchVisibility(SearchText, ActivePathItem, SearchSubTrees);
                        Window.ShowStatus();
                    });
                });
            }
        
            private void TextSearch_TextChanged(object sender, TextChangedEventArgs e)
            {
                DoSearchOperation();
            }
        
            internal void MenuFindFiles_Click(object sender, RoutedEventArgs e)
            {
                TextSearch.Focus();
            }

            private void CheckSearchTree_Click(object sender, RoutedEventArgs e)
            {
                SearchSubTrees = !SearchSubTrees;
                TextSearch.Focus();

                if(!string.IsNullOrEmpty(SearchText))
                    DoSearchOperation();
            }


            public void FocusFileSearchBox(string searchText = null)
            {
                SearchText = searchText ?? string.Empty;
                TextSearch.Focus();
            }
        #endregion

        #region Context Menu Actions

        private void TreeFolderBrowser_ContextMenuOpening(object sender, ContextMenuEventArgs e)
            {
                FolderBrowserContextMenu.ShowContextMenu();
            }


            #endregion

            #region Items and Item Selection

            //private DateTime LastClickTime;
            //private PathItem LastItem;

            /// <summary>
            /// Handle renaming double click
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void TextFileOrFolderName_MouseUpToEdit(object sender, MouseButtonEventArgs e)
            {
                //if (e.ChangedButton == MouseButton.Left)
                //{
                //    var selected = TreeFolderBrowser.SelectedItem as PathItem;
                //    var t = DateTime.Now;

                //    if (LastItem == selected)
                //    {
                //        if (t >= LastClickTime.AddMilliseconds(System.Windows.Forms.SystemInformation.DoubleClickTime + 200) &&
                //            t <= LastClickTime.AddMilliseconds(System.Windows.Forms.SystemInformation.DoubleClickTime * 2 + 200))
                //        {
                //            FolderBrowserContextMenu.MenuRenameFile_Click(null, null);
                //        }
                //    }

                //    LastItem = selected;
                //    LastClickTime = t;
                //}
            }

            /// <summary>
            /// Special intercepts for New File and Folder handling.
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void TextEditFileItem_LostFocus(object sender, RoutedEventArgs e)
            {
                var selected = GetSelectedItem();
                if (selected != null)
                {

                    if (selected.DisplayName == "NewFile.md" || selected.DisplayName == "NewFolder")
                    {
                        selected.Parent.Files.Remove(selected);
                        return;
                    }

                    if (selected.IsEditing) // this should be handled by Key ops in treeview
                    {
                        RenameOrCreateFileOrFolder();
                    }

                    selected.IsEditing = false;
                    selected.SetIcon();
                }
            }

            /// <summary>
            /// Handle Text Selection for the filename only
            /// </summary>
            private void TextEditFileItem_GotFocus(object sender, RoutedEventArgs e)
            {
                if (TreeFolderBrowser.SelectedItem is PathItem selected)
                {
                    var tb = sender as TextBox;
                    if (tb == null)
                        return;

                    if (!selected.DisplayName.Contains('.') && tb.SelectionLength > 0) // already selected
                        return;

                    var at = selected.DisplayName.IndexOf('.');
                    tb.SelectionStart = 0;
                    tb.SelectionLength = at > 1 ? at : selected.DisplayName.Length;
                }
            }

            #endregion

            #region Drag Operations


            private System.Windows.Point startPoint;

            private void TreeFolderBrowser_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
            {
                if (Window.PreviewTab != null)
                {
                    var filename = (Window.PreviewTab.Tag as MarkdownDocumentEditor)?.MarkdownDocument?.Filename;
                    if (filename != null)
                    {
                        var ext = Path.GetExtension(filename)?.ToLower();
                        if (ext == ".jpg" || ext == ".png" || ext == ".gif" || ext == ".jpeg")
                            Window.CloseTab(Window.PreviewTab);
                    }
                }

                startPoint = e.GetPosition(null);
            }


            private void TreeFolderBrowser_MouseMove(object sender, MouseEventArgs e)
            {
                if (e.LeftButton == MouseButtonState.Pressed)
                {
                    var selected = GetSelectedItem(); //TreeFolderBrowser.SelectedItem as PathItem;

                    // Only allow the items to be dragged
                    var src = e.OriginalSource as TextBlock;
                    if (src == null)
                        return;

                    // only drag image files
                    if (selected == null)
                        return;

                    var mousePos = e.GetPosition(null);
                    var diff = startPoint - mousePos;

                    DragDropEffects effect = DragDropEffects.Move;
                    if (Keyboard.IsKeyDown(Key.LeftCtrl))
                        effect = DragDropEffects.Copy;

                    if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
                        || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
                    {
                        var treeViewItem = GetTreeViewItem(selected);
                        if (treeViewItem == null)
                            return;

                        var files = GetSelectedItems()
                            .Where(p => !string.IsNullOrEmpty(p.FullPath)) // dont move root or parent paths
                            .Select(p => p.FullPath).ToArray();

                        var dragData = new DataObject(DataFormats.FileDrop, files);
                        if (files.Length > 0)
                            dragData.SetText(files[0]); // so Web Browser can drop files
                        //dragData.SetText(string.Join("\n",files));   // so Web Browser can drop files

                        DragDrop.DoDragDrop(treeViewItem, dragData, effect);
                    }
                }
            }

            private void TreeViewItem_Drop(object sender, DragEventArgs e)
            {
                PathItem dropTargetPathItem = ActivePathItem; // assume root
                var npi = GetSelectedItems();

                var formats = e.Data.GetFormats();

                if (sender is TreeView)
                {
                    // dropped into treeview open space
                }
                else
                {
                    dropTargetPathItem = (e.OriginalSource as FrameworkElement)?.DataContext as PathItem;
                    if (dropTargetPathItem == null)
                        return;
                }

                e.Handled = true;


                if (formats.Contains("FileDrop"))
                {
                    HandleDroppedFiles(e.Data.GetData("FileDrop") as string[], dropTargetPathItem, e.Effects);

                    ClearSelectedItems(ActivePathItem.Files, dropTargetPathItem);
                    dropTargetPathItem.IsExpanded = true;
                    return;
                }

                if (!dropTargetPathItem.IsFolder)
                    dropTargetPathItem = dropTargetPathItem.Parent;

                var path = e.Data.GetData(DataFormats.UnicodeText) as string;
                if (string.IsNullOrEmpty(path))
                {
                    return;
                }

                string newPath;
                var sourceItem = FolderStructure.FindPathItemByFilename(ActivePathItem, path);
                if (sourceItem == null)
                {
                    // Handle dropped new files (from Explorer perhaps)
                    if (File.Exists(path))
                    {
                        newPath = Path.Combine(dropTargetPathItem.FullPath, Path.GetFileName(path));
                        mmFileUtils.CopyFileOrFolder(path, newPath, true);
                        AppModel.Window.ShowStatusSuccess($"File copied.");
                    }


                    return;
                }

                newPath = Path.Combine(dropTargetPathItem.FullPath, sourceItem.DisplayName);

                if (sourceItem.FullPath.Equals(newPath, StringComparison.InvariantCultureIgnoreCase))
                {
                    AppModel.Window.ShowStatusError($"File not moved.",
                        mmApp.Configuration.StatusMessageTimeout);
                    return;
                }

                try
                {
                    mmFileUtils.MoveFileOrFolder(sourceItem.FullPath, newPath, true);
                }
                catch (Exception ex)
                {
                    AppModel.Window.ShowStatusError($"Couldn't move file: {ex.Message}",
                        mmApp.Configuration.StatusMessageTimeout);
                    return;
                }

                dropTargetPathItem.IsExpanded = true;

                // wait for file watcher to pick up the file
                Dispatcher.Delay(200, (p) =>
                {
                    var srceItem = FolderStructure.FindPathItemByFilename(ActivePathItem, p as string);
                    if (srceItem == null)
                        return;
                    srceItem.IsSelected = true;
                }, newPath);

                AppModel.Window.ShowStatus($"File moved to: {newPath}", mmApp.Configuration.StatusMessageTimeout);
            }

            /// <summary>
            /// Handles files that were dropped on the tree view
            /// </summary>
            /// <param name="files">array of files</param>
            void HandleDroppedFiles(string[] files, PathItem target, DragDropEffects effect)
            {
                if (files == null)
                    return;

                WindowUtilities.DoEvents();

                Window.ShowStatusProgress("Copying files and folders...");

                WindowUtilities.DoEvents();

                string errors = "";

                //Task.Run(() =>
                //{
                foreach (var file in files)
                {
                    var isFile = File.Exists(file);
                    var isDir = Directory.Exists(file);
                    if (!isDir && !isFile)
                        continue;

                    string nPath = target.FullPath;
                    if (isFile)
                    {
                        if (!target.IsFolder)
                        {
                            var par = target.Parent == null ? ActivePathItem : target.Parent;
                            nPath = Path.Combine(Path.GetDirectoryName(target.FullPath), Path.GetFileName(file));
                        }

                        if (file == nPath)
                            continue;

                        try
                        {
                            // only move if EXPLICITLY using MOVE operation
                            if (effect == DragDropEffects.Move)
                            {
                                mmFileUtils.MoveFileOrFolder(file, nPath, confirmation: true);
                            }
                            else
                            {
                                mmFileUtils.CopyFileOrFolder(file, nPath, confirmation: true);
                            }
                        }
                        catch
                        {
                            errors += $"{nPath},";
                        }

                    }
                    else
                    {
                        var sourceFolderName = Path.GetFileName(file);
                        var targetFolder = Path.Combine(target.FullPath, sourceFolderName);

                        if (targetFolder != file)
                        {
                            try
                            {
                                if (effect == DragDropEffects.Move)
                                {
                                    mmFileUtils.MoveFileOrFolder(file, targetFolder);
                                }
                                else
                                {
                                    mmFileUtils.CopyFileOrFolder(file, targetFolder);
                                }

                                break;
                            }
                            catch
                            {
                                errors += $"{Path.GetFileName(file)},";
                            }
                        }
                    }


                }

                ClearSelectedItems();
                target.IsSelected = true;

                Dispatcher.InvokeAsync(() =>
                {
                    if (string.IsNullOrEmpty(errors))
                        Window.ShowStatusSuccess($"Files and Folders copied.");
                    else
                        Window.ShowStatusError($"There were errors copying files and folders.");
                });

            }

            #endregion

            #region INotifyPropertyChanged

            public event PropertyChangedEventHandler PropertyChanged;

            [NotifyPropertyChangedInvocator]
            protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
            {
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }


        #endregion
        
    }

    }

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(160,17): error CS0103: The name 'InitializeComponent' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(179,17): error CS0103: The name 'ComboFolderPath' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(181,17): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(182,17): error CS0103: The name 'ComboFolderPath' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(445,25): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(449,25): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(476,33): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(498,37): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(545,21): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(552,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(553,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(555,81): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(556,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(557,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(580,17): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(606,24): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(616,41): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(649,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(692,72): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(734,29): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(767,29): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(798,29): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(856,39): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(890,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(990,32): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1158,37): error CS1061: 'MainWindow' does not contain a definition for 'TabControl' and no accessible extension method 'TabControl' accepting a first argument of type 'MainWindow' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1189,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1204,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1322,55): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1365,28): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1371,28): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1381,28): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1458,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(15,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(10,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(4,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(20,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(18,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(160,17): error CS0103: The name 'InitializeComponent' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(179,17): error CS0103: The name 'ComboFolderPath' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(181,17): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(182,17): error CS0103: The name 'ComboFolderPath' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(445,25): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(449,25): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(476,33): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(498,21): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(543,21): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(550,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(551,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(553,81): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(554,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(555,21): error CS0103: The name 'ButtonRecentFolders' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(578,17): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(604,24): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(614,41): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(647,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(690,72): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(732,29): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(736,25): error CS0103: The name 'pi' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(737,32): error CS0103: The name 'pi' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(739,25): error CS0103: The name 'pi' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(741,53): error CS0841: Cannot use local variable 'pi' before it is declared,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(746,25): error CS0841: Cannot use local variable 'pi' before it is declared,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(765,29): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(796,29): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(854,39): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(868,25): error CS0841: Cannot use local variable 'titem' before it is declared,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(872,66): error CS0136: A local or parameter named 'titem' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(858,96): error CS0165: Use of unassigned local variable 'titem',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(889,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(989,32): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1157,37): error CS1061: 'MainWindow' does not contain a definition for 'TabControl' and no accessible extension method 'TabControl' accepting a first argument of type 'MainWindow' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1188,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1203,32): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1321,55): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1364,28): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1370,28): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1380,28): error CS0117: 'TextSearch' does not contain a definition for 'Focus',D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(1457,21): error CS0103: The name 'TreeFolderBrowser' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(10,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(20,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(15,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(16,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\FolderBrowserSidebar\FolderBrowerSidebar.xaml.cs(4,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MarkdownMonster\Windows\Helpers\WindowUtilities.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using PixelFormat = System.Drawing.Imaging.PixelFormat;
using Point = System.Drawing.Point;

namespace MarkdownMonster.Windows
{
    /// <summary>
    /// WPF Helpers for MM
    /// </summary>
    public class WindowUtilities
    {
        #region Window Placement

        /// <summary>
        ///  Centers a WPF window on the screen. Considers DPI settings
        /// </summary>
        /// <param name="window"></param>
        public static void CenterWindow(Window window)
        {
            var hwnd = WindowToHwnd(window);

            var screen = Screen.FromHandle(hwnd);
            var ratio = Convert.ToDouble(GetDpiRatio(hwnd));
            var windowWidth = screen.Bounds.Width / ratio;
            var windowHeight = screen.Bounds.Height / ratio;

            
            var offsetWidth = (windowWidth - window.Width) /  2 + (screen.Bounds.X * ratio);
            var offsetHeight = (windowHeight -  window.Height) / 2 + (screen.Bounds.Y * ratio);

            window.Left = Convert.ToDouble(offsetWidth);
            window.Top = Convert.ToDouble(offsetHeight);
        }

        /// <summary>
        /// Ensures that the window rendered is visible and fitting
        /// on the currently active screen.
        /// </summary>
        /// <param name="window"></param>
        public static void EnsureWindowIsVisible(Window window)
        {
            var hwnd = WindowToHwnd(window);
            var screenBounds = GetScreenDimensions(window);
            var ratio = Convert.ToDouble(GetDpiRatio(hwnd));

            var screenWidth = screenBounds.Width / ratio;
            var screenHeight = screenBounds.Height / ratio;
            var screenX = screenBounds.X / ratio;
            var screenY = screenBounds.Y / ratio;

            var windowLeftAbsolute = window.Left + screenX; // absolute Left
            var windowTopAbsolute = window.Top + screenY; // absolute Top

            if (window.Left + window.Width  > screenWidth)
                //if (window.Left + window.Width - screenX > screenWidth)
            {
                // move window into visible space
                window.Left = screenX + screenWidth - window.Width;
                windowLeftAbsolute = window.Left;
            }
            if (windowLeftAbsolute < screenX)
            {
                window.Left = 20 + screenX;
                if (window.Width + 20 > screenWidth)
                    window.Width = screenWidth - 40;
            }


            if (window.Top + window.Height > screenHeight - 40)
            {
                window.Top = screenY + screenHeight - window.Height - 40;
                windowTopAbsolute = window.Top;

            }
            if (windowTopAbsolute < screenY)
            {
                window.Top = 20 + screenY;
                if (window.Height + 20 > screenHeight)
                    window.Height = screenHeight - 60;
            }
        }

        #endregion

        #region Window Activation API Calls

        /// <summary>
        /// Force Window to the foreground. This seems to be the only reliable way
        /// to get MM to become UI active from within MM when activated externally.
        /// </summary>
        /// <param name="hWnd">IntPtr of the Window Handle to activate</param>
        /// <returns></returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll")]
        public  static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll", EntryPoint="FindWindow", SetLastError = true)]
        static extern IntPtr FindWindow(IntPtr ZeroOnly, string lpWindowName);

        [DllImport("user32.dll")]
        public static extern uint GetWindowThreadProcessId(IntPtr hWnd, IntPtr ProcessId);

        


        [DllImport("user32.dll")]
        public static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);

        /// <summary>
        /// Activates a WPF window even if the window is activated on a separate thread
        /// </summary>
        /// <param name="window"></param>
        public static void ActivateWindow(Window window)
        {
            var hwnd = WindowToHwnd(window);

            var threadId1 = GetWindowThreadProcessId(GetForegroundWindow(), IntPtr.Zero);
            var threadId2 = GetWindowThreadProcessId(hwnd, IntPtr.Zero);

            if (threadId1 != threadId2)
            {
                AttachThreadInput(threadId1, threadId2, true);
                SetForegroundWindow(hwnd);
                AttachThreadInput(threadId1, threadId2, false);
            }
            else
              SetForegroundWindow(hwnd); // this is the only thing that works to activate the window
        }

        #endregion

        #region GetDpiRatio

        public static decimal GetDpiRatio(Window window)
        {
            var dpi = WindowUtilities.GetDpi(window, DpiType.Effective);
            decimal ratio = 1;
            if (dpi > 96)
                ratio = (decimal) dpi / 96M;

            return ratio;
        }




        public static decimal GetDpiRatio(IntPtr hwnd)
        {
            var dpi = GetDpi(hwnd, DpiType.Effective);
            decimal ratio = 1;
            if (dpi > 96)
                ratio = (decimal) dpi / 96M;

            //Debug.WriteLine($"Scale: {factor} {ratio}");
            return ratio;
        }



        public static uint GetDpi(IntPtr hwnd, DpiType dpiType)
        {
            var screen = Screen.FromHandle(hwnd);
            var pnt = new Point(screen.Bounds.Left, screen.Bounds.Top);

            var mon = MonitorFromPoint(pnt, 2 /*MONITOR_DEFAULTTONEAREST*/);

            try
            {
                uint dpiX, dpiY;
                GetDpiForMonitor(mon, dpiType, out dpiX, out dpiY);

                //Debug.WriteLine($"dpi: {dpiX} on mon {mon}");
                return dpiX;
            }
            catch
            {
                // fallback for Windows 7 and older - not 100% reliable
                Graphics graphics = Graphics.FromHwnd(hwnd);
                float dpiXX = graphics.DpiX;
                return Convert.ToUInt32(dpiXX);
            }
        }

        public static uint GetDpi(System.Drawing.Point point, DpiType dpiType)
        {
            var mon = MonitorFromPoint(point, 2 /*MONITOR_DEFAULTTONEAREST*/);

            try
            {
                uint dpiX, dpiY;
                GetDpiForMonitor(mon, dpiType, out dpiX, out dpiY);
                return dpiX;
            }
            catch
            {
                // fallback for Windows 7 and older - not 100% reliable
                Graphics graphics = Graphics.FromHdc(mon);
                float dpiXX = graphics.DpiX;
                return Convert.ToUInt32(dpiXX);
            }
        }




        public static uint GetDpi(Window window, DpiType dpiType)
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            return GetDpi(hwnd, dpiType);
        }


        //https://msdn.microsoft.com/en-us/library/windows/desktop/dd145062(v=vs.85).aspx
        [DllImport("User32.dll")]
        private static extern IntPtr MonitorFromPoint([In] System.Drawing.Point pt, [In] uint dwFlags);

        //https://msdn.microsoft.com/en-us/library/windows/desktop/dn280510(v=vs.85).aspx
        [DllImport("Shcore.dll")]
        private static extern IntPtr GetDpiForMonitor([In] IntPtr hmonitor, [In] DpiType dpiType, [Out] out uint dpiX,
            [Out] out uint dpiY);

        #endregion

        #region SetDPIAwareness

        /// <summary>
        /// IMPORTANT: This only works if this is called in the immediate startup code
        /// of the application. For WPF this means `static App() { }`.
        /// </summary>
        public static bool SetPerMonitorDpiAwareness(
            ProcessDpiAwareness type = ProcessDpiAwareness.Process_Per_Monitor_DPI_Aware)
        {
            try
            {
                // for this to work make sure [assembly: DisableDpiAwareness]
                ProcessDpiAwareness awarenessType;
                GetProcessDpiAwareness(Process.GetCurrentProcess().Handle, out awarenessType);
                var result = SetProcessDpiAwareness(type);
                GetProcessDpiAwareness(Process.GetCurrentProcess().Handle, out awarenessType);

                return awarenessType == type;
            }
            catch
            {
                return false;
            }
        }

        [DllImport("SHCore.dll", SetLastError = true)]
        private static extern bool SetProcessDpiAwareness(ProcessDpiAwareness awareness);

        [DllImport("SHCore.dll", SetLastError = true)]
        private static extern void GetProcessDpiAwareness(IntPtr hprocess, out ProcessDpiAwareness awareness);

        #endregion

        #region Conversions and screen sizes

        /// <summary>
        /// Returns the active screen's size in pixels
        /// </summary>
        /// <param name="window"></param>
        /// <returns></returns>
        public static Rectangle GetScreenDimensions(Window window)
        {
            var screen = Screen.FromHandle(new WindowInteropHelper(window).Handle);
            return screen.Bounds;
        }


        /// <summary>
        /// Returns IntPtr for an HWND from  WPF Window object
        /// </summary>
        /// <param name="window"></param>
        /// <returns></returns>
        public static IntPtr WindowToHwnd(Window window)
        {
            return new WindowInteropHelper(window).EnsureHandle();
        }

        #endregion

        #region Bitmap Conversions

        /// <summary>
        /// Converts a bitmap source to a bitmap
        /// Make sure to dispose the bitmap
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public static Bitmap BitmapSourceToBitmap(BitmapSource source)
        {
            if (source == null)
                return null;

            var pixelFormat = PixelFormat.Format32bppArgb;  //Bgr32 default
            if (source.Format == PixelFormats.Bgr24)
                pixelFormat = PixelFormat.Format24bppRgb;
            else if(source.Format == PixelFormats.Pbgra32)
                pixelFormat = PixelFormat.Format32bppPArgb;
            else if(source.Format == PixelFormats.Prgba64)
                pixelFormat = PixelFormat.Format64bppPArgb;
            
            Bitmap bmp = new Bitmap(
                source.PixelWidth,
                source.PixelHeight,
                pixelFormat);

            BitmapData data = bmp.LockBits(
                new Rectangle(Point.Empty, bmp.Size),
                ImageLockMode.WriteOnly,
                pixelFormat);

            source.CopyPixels(
                Int32Rect.Empty,
                data.Scan0,
                data.Height * data.Stride,
                data.Stride);

            bmp.UnlockBits(data);

            return bmp;
        }


        [DllImport("gdi32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool DeleteObject(IntPtr hObject);

        public static BitmapSource BitmapToBitmapSource(Bitmap bmp)
        {
            var hBitmap = bmp.GetHbitmap();
            var imageSource = Imaging.CreateBitmapSourceFromHBitmap(hBitmap, IntPtr.Zero,
                System.Windows.Int32Rect.Empty,
                System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions());
            DeleteObject(hBitmap);
            return imageSource;
        }


        #endregion

        #region Make Window Transparent

        /// <summary>
        /// Call this to make a window completely click through including all controls
        /// on it.
        /// </summary>
        /// <example>
        /// ///
        /// protected override void OnSourceInitialized(EventArgs e)
        /// {
        ///    base.OnSourceInitialized(e);
        ///    var hwnd = new WindowInteropHelper(this).Handle;
        ///    WindowsServices.SetWindowExTransparent(hwnd);
        /// }
        ///</example>
        public static void MakeWindowCompletelyTransparent(IntPtr hwnd)
        {
            var extendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
            SetWindowLong(hwnd, GWL_EXSTYLE, extendedStyle | WS_EX_TRANSPARENT);
        }

        const int WS_EX_TRANSPARENT = 0x00000020;
        const int GWL_EXSTYLE = (-20);

        [DllImport("user32.dll")]
        static extern int GetWindowLong(IntPtr hwnd, int index);

        [DllImport("user32.dll")]
        static extern int SetWindowLong(IntPtr hwnd, int index, int newStyle);

        #endregion

        #region Menus

        /// <summary>
        /// Invalidates a menu control and all of its subitems
        /// by checking Command.IsEnabled property if a command exists
        /// </summary>
        /// <param name="menu"></param>
        public static void InvalidateMenuCommands(System.Windows.Controls.Menu menu)
        {

            foreach (var item in menu.Items)
            {
                var mi = item as System.Windows.Controls.MenuItem;
                if (mi == null)
                    continue;

                InvalidateSubmenuCommands(mi);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="menuItem"></param>
        public static void InvalidateSubmenuCommands(System.Windows.Controls.MenuItem menuItem)
        {
            if (menuItem == null)
                return;

            foreach (var item in menuItem.Items)
            {
                var mi = item as System.Windows.Controls.MenuItem;
                if (mi == null)
                    continue;

                if (mi.Command != null)
                    mi.IsEnabled = mi.Command.CanExecute(mi.CommandParameter);

                if (mi.HasItems)
                    InvalidateSubmenuCommands(mi);
            }
        }

        #endregion

        #region Miscellaneous
        private static void EmptyMethod()
        {
        }

        /// <summary>
        /// Idle loop to let events fire in the UI
        /// 
        /// Use SPARINGLY or not at all if there is a better way
        /// but there are a few places where this is required.
        /// </summary>
        public static void DoEvents()
        {
            try
            {
                // This can fail if the dispatcher is disabled by another process
                if (!IsDispatcherDisabled())
                    Dispatcher.CurrentDispatcher.Invoke(EmptyMethod, DispatcherPriority.Background);
            }
            catch (Exception ex)
            {
                mmApp.Log("DoEvents failed", ex);
            }
        }


        static readonly FieldInfo DisableProcessCountField =
            typeof(Dispatcher).GetField("_disableProcessingCount", BindingFlags.Instance | BindingFlags.NonPublic);


        /// <summary>
        /// Check to see if the Dispatcher is currently not active which can happen internally
        /// in WPF rendering and cause unexpected exceptions. Check for those edge cases
        /// </summary>
        /// <param name="dispatcher"></param>
        /// <returns></returns>
        public static bool IsDispatcherDisabled(Dispatcher dispatcher = null)
        {
            if (dispatcher == null)
                dispatcher = Dispatcher.CurrentDispatcher;

            // This can fail if the dispatcher is disabled by another process
            if (DisableProcessCountField == null)
                return true;

            return (int) DisableProcessCountField.GetValue(dispatcher) != 0;
        }

        /// <summary>
        /// Forces lost focus on the active control in a Window to force the selected control
        /// to databind.
        /// Typical scenario: Toolbar clicks (which don't cause a focus change) don't see
        /// latest control state of the active control because it doesn't know focus has
        /// changed. This forces the active control to unbind       
        /// </summary>
        /// <param name="window">Active window</param>
        /// <param name="control">Control to force focus to briefly to force active control to bind</param>
        public static void FixFocus(Window window, System.Windows.Controls.Control control)
        {
            var ctl = FocusManager.GetFocusedElement(window);
            if (ctl == null)
                return;

            control.Focus();
            window.Dispatcher.Invoke(() => ctl.Focus(), DispatcherPriority.ApplicationIdle);
        }

        /// <summary>
        /// Finds a particular type of control in the children of a top level control
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static T FindVisualChild<T>(DependencyObject obj) where T : DependencyObject
        {
            if (obj != null)
            {
                for (int i = 0; i < VisualTreeHelper.GetChildrenCount(obj); i++)
                {
                    var child = VisualTreeHelper.GetChild(obj, i);
                    if (child is T)
                    {
                        return (T) child;
                    }

                    T childItem = FindVisualChild<T>(child);
                    if (childItem != null) return childItem;
                }
            }

            return null;
        }


        /// <summary>
        /// Finds a type of element in the parent chain of an element
        /// </summary>
        /// <typeparam name="T">Type of Element to find</typeparam>
        /// <param name="current">start element</param>
        /// <returns></returns>
        public static T FindAnchestor<T>(DependencyObject current)
            where T : DependencyObject
        {
            do
            {
                if (current is T) return (T) current;

                current = VisualTreeHelper.GetParent(current);
            } while (current != null);

            return null;
        }


        /// <summary>
        /// Retrieves a nested TreeViewItem by walking the hierarchy.
        /// Specify a root treeview or treeviewitem and it then walks
        /// the hierarchy to find the item
        /// </summary>
        /// <param name="item">Item to find</param>
        /// <param name="treeItem">Parent item to start search from</param>
        /// <returns></returns>
        public static TreeViewItem GetNestedTreeviewItem(object item, ItemsControl treeItem)
        {
            var titem = treeItem
                .ItemContainerGenerator
                .ContainerFromItem(item) as TreeViewItem;

            if (titem != null)
                return titem;

            foreach (var childItem in treeItem.Items)
            {
                titem = treeItem
                    .ItemContainerGenerator
                    .ContainerFromItem(childItem) as TreeViewItem;

                if (titem == null) continue;

                titem = GetNestedTreeviewItem(item, titem);
                if (titem != null)
                    return titem;
            }

            return null;
        }
        #endregion
    }

    public enum ProcessDpiAwareness
    {
        Process_DPI_Unaware = 0,
        Process_System_DPI_Aware = 1,
        Process_Per_Monitor_DPI_Aware = 2
    }

    //https://msdn.microsoft.com/en-us/library/windows/desktop/dn280511(v=vs.85).aspx
    public enum DpiType
    {
        Effective = 0,
        Angular = 1,
        Raw = 2,
    }

    [DebuggerDisplay("L:{Left} T:{Top}  {Width}x{Height} - C:{CenteredInMainWindow}")]
    public class WindowPosition
    {
        public double Left {get; set; }
        public double Top {get; set; }

        public double Width {get; set; }

        public double Height {get; set; }

        public bool CenterInMainWindow { get; set; } = false;
    }

}

---- Transformed Tree ----
using System;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using PixelFormat = System.Drawing.Imaging.PixelFormat;
using Point = System.Drawing.Point;

namespace MarkdownMonster.Windows
{
    /// <summary>
    /// WPF Helpers for MM
    /// </summary>
    public class WindowUtilities
    {
        #region Window Placement

        /// <summary>
        ///  Centers a WPF window on the screen. Considers DPI settings
        /// </summary>
        /// <param name="window"></param>
        public static void CenterWindow(Window window)
        {
            var hwnd = WindowToHwnd(window);

            var screen = Screen.FromHandle(hwnd);
            var ratio = Convert.ToDouble(GetDpiRatio(hwnd));
            var windowWidth = screen.Bounds.Width / ratio;
            var windowHeight = screen.Bounds.Height / ratio;

            
            var offsetWidth = (windowWidth - window.Width) /  2 + (screen.Bounds.X * ratio);
            var offsetHeight = (windowHeight -  window.Height) / 2 + (screen.Bounds.Y * ratio);

            window.Left = Convert.ToDouble(offsetWidth);
            window.Top = Convert.ToDouble(offsetHeight);
        }

        /// <summary>
        /// Ensures that the window rendered is visible and fitting
        /// on the currently active screen.
        /// </summary>
        /// <param name="window"></param>
        public static void EnsureWindowIsVisible(Window window)
        {
            var hwnd = WindowToHwnd(window);
            var screenBounds = GetScreenDimensions(window);
            var ratio = Convert.ToDouble(GetDpiRatio(hwnd));

            var screenWidth = screenBounds.Width / ratio;
            var screenHeight = screenBounds.Height / ratio;
            var screenX = screenBounds.X / ratio;
            var screenY = screenBounds.Y / ratio;

            var windowLeftAbsolute = window.Left + screenX; // absolute Left
            var windowTopAbsolute = window.Top + screenY; // absolute Top

            if (window.Left + window.Width  > screenWidth)
                //if (window.Left + window.Width - screenX > screenWidth)
            {
                // move window into visible space
                window.Left = screenX + screenWidth - window.Width;
                windowLeftAbsolute = window.Left;
            }
            if (windowLeftAbsolute < screenX)
            {
                window.Left = 20 + screenX;
                if (window.Width + 20 > screenWidth)
                    window.Width = screenWidth - 40;
            }


            if (window.Top + window.Height > screenHeight - 40)
            {
                window.Top = screenY + screenHeight - window.Height - 40;
                windowTopAbsolute = window.Top;

            }
            if (windowTopAbsolute < screenY)
            {
                window.Top = 20 + screenY;
                if (window.Height + 20 > screenHeight)
                    window.Height = screenHeight - 60;
            }
        }

        #endregion

        #region Window Activation API Calls

        /// <summary>
        /// Force Window to the foreground. This seems to be the only reliable way
        /// to get MM to become UI active from within MM when activated externally.
        /// </summary>
        /// <param name="hWnd">IntPtr of the Window Handle to activate</param>
        /// <returns></returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll")]
        public  static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll", EntryPoint="FindWindow", SetLastError = true)]
        static extern IntPtr FindWindow(IntPtr ZeroOnly, string lpWindowName);

        [DllImport("user32.dll")]
        public static extern uint GetWindowThreadProcessId(IntPtr hWnd, IntPtr ProcessId);

        


        [DllImport("user32.dll")]
        public static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);

        /// <summary>
        /// Activates a WPF window even if the window is activated on a separate thread
        /// </summary>
        /// <param name="window"></param>
        public static void ActivateWindow(Window window)
        {
            var hwnd = WindowToHwnd(window);

            var threadId1 = GetWindowThreadProcessId(GetForegroundWindow(), IntPtr.Zero);
            var threadId2 = GetWindowThreadProcessId(hwnd, IntPtr.Zero);

            if (threadId1 != threadId2)
            {
                AttachThreadInput(threadId1, threadId2, true);
                SetForegroundWindow(hwnd);
                AttachThreadInput(threadId1, threadId2, false);
            }
            else
              SetForegroundWindow(hwnd); // this is the only thing that works to activate the window
        }

        #endregion

        #region GetDpiRatio

        public static decimal GetDpiRatio(Window window)
        {
            var dpi = WindowUtilities.GetDpi(window, DpiType.Effective);
            decimal ratio = 1;
            if (dpi > 96)
                ratio = (decimal) dpi / 96M;

            return ratio;
        }




        public static decimal GetDpiRatio(IntPtr hwnd)
        {
            var dpi = GetDpi(hwnd, DpiType.Effective);
            decimal ratio = 1;
            if (dpi > 96)
                ratio = (decimal) dpi / 96M;

            //Debug.WriteLine($"Scale: {factor} {ratio}");
            return ratio;
        }



        public static uint GetDpi(IntPtr hwnd, DpiType dpiType)
        {
            var screen = Screen.FromHandle(hwnd);
            var pnt = new Point(screen.Bounds.Left, screen.Bounds.Top);

            var mon = MonitorFromPoint(pnt, 2 /*MONITOR_DEFAULTTONEAREST*/);

            try
            {
                uint dpiX, dpiY;
                GetDpiForMonitor(mon, dpiType, out dpiX, out dpiY);

                //Debug.WriteLine($"dpi: {dpiX} on mon {mon}");
                return dpiX;
            }
            catch
            {
                // fallback for Windows 7 and older - not 100% reliable
                Graphics graphics = Graphics.FromHwnd(hwnd);
                float dpiXX = graphics.DpiX;
                return Convert.ToUInt32(dpiXX);
            }
        }

        public static uint GetDpi(System.Drawing.Point point, DpiType dpiType)
        {
            var mon = MonitorFromPoint(point, 2 /*MONITOR_DEFAULTTONEAREST*/);

            try
            {
                uint dpiX, dpiY;
                GetDpiForMonitor(mon, dpiType, out dpiX, out dpiY);
                return dpiX;
            }
            catch
            {
                // fallback for Windows 7 and older - not 100% reliable
                Graphics graphics = Graphics.FromHdc(mon);
                float dpiXX = graphics.DpiX;
                return Convert.ToUInt32(dpiXX);
            }
        }




        public static uint GetDpi(Window window, DpiType dpiType)
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            return GetDpi(hwnd, dpiType);
        }


        //https://msdn.microsoft.com/en-us/library/windows/desktop/dd145062(v=vs.85).aspx
        [DllImport("User32.dll")]
        private static extern IntPtr MonitorFromPoint([In] System.Drawing.Point pt, [In] uint dwFlags);

        //https://msdn.microsoft.com/en-us/library/windows/desktop/dn280510(v=vs.85).aspx
        [DllImport("Shcore.dll")]
        private static extern IntPtr GetDpiForMonitor([In] IntPtr hmonitor, [In] DpiType dpiType, [Out] out uint dpiX,
            [Out] out uint dpiY);

        #endregion

        #region SetDPIAwareness

        /// <summary>
        /// IMPORTANT: This only works if this is called in the immediate startup code
        /// of the application. For WPF this means `static App() { }`.
        /// </summary>
        public static bool SetPerMonitorDpiAwareness(
            ProcessDpiAwareness type = ProcessDpiAwareness.Process_Per_Monitor_DPI_Aware)
        {
            try
            {
                // for this to work make sure [assembly: DisableDpiAwareness]
                ProcessDpiAwareness awarenessType;
                GetProcessDpiAwareness(Process.GetCurrentProcess().Handle, out awarenessType);
                var result = SetProcessDpiAwareness(type);
                GetProcessDpiAwareness(Process.GetCurrentProcess().Handle, out awarenessType);

                return awarenessType == type;
            }
            catch
            {
                return false;
            }
        }

        [DllImport("SHCore.dll", SetLastError = true)]
        private static extern bool SetProcessDpiAwareness(ProcessDpiAwareness awareness);

        [DllImport("SHCore.dll", SetLastError = true)]
        private static extern void GetProcessDpiAwareness(IntPtr hprocess, out ProcessDpiAwareness awareness);

        #endregion

        #region Conversions and screen sizes

        /// <summary>
        /// Returns the active screen's size in pixels
        /// </summary>
        /// <param name="window"></param>
        /// <returns></returns>
        public static Rectangle GetScreenDimensions(Window window)
        {
            var screen = Screen.FromHandle(new WindowInteropHelper(window).Handle);
            return screen.Bounds;
        }


        /// <summary>
        /// Returns IntPtr for an HWND from  WPF Window object
        /// </summary>
        /// <param name="window"></param>
        /// <returns></returns>
        public static IntPtr WindowToHwnd(Window window)
        {
            return new WindowInteropHelper(window).EnsureHandle();
        }

        #endregion

        #region Bitmap Conversions

        /// <summary>
        /// Converts a bitmap source to a bitmap
        /// Make sure to dispose the bitmap
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public static Bitmap BitmapSourceToBitmap(BitmapSource source)
        {
            if (source == null)
                return null;

            var pixelFormat = PixelFormat.Format32bppArgb;  //Bgr32 default
            if (source.Format == PixelFormats.Bgr24)
                pixelFormat = PixelFormat.Format24bppRgb;
            else if(source.Format == PixelFormats.Pbgra32)
                pixelFormat = PixelFormat.Format32bppPArgb;
            else if(source.Format == PixelFormats.Prgba64)
                pixelFormat = PixelFormat.Format64bppPArgb;
            
            Bitmap bmp = new Bitmap(
                source.PixelWidth,
                source.PixelHeight,
                pixelFormat);

            BitmapData data = bmp.LockBits(
                new Rectangle(Point.Empty, bmp.Size),
                ImageLockMode.WriteOnly,
                pixelFormat);

            source.CopyPixels(
                Int32Rect.Empty,
                data.Scan0,
                data.Height * data.Stride,
                data.Stride);

            bmp.UnlockBits(data);

            return bmp;
        }


        [DllImport("gdi32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool DeleteObject(IntPtr hObject);

        public static BitmapSource BitmapToBitmapSource(Bitmap bmp)
        {
            var hBitmap = bmp.GetHbitmap();
            var imageSource = Imaging.CreateBitmapSourceFromHBitmap(hBitmap, IntPtr.Zero,
                System.Windows.Int32Rect.Empty,
                System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions());
            DeleteObject(hBitmap);
            return imageSource;
        }


        #endregion

        #region Make Window Transparent

        /// <summary>
        /// Call this to make a window completely click through including all controls
        /// on it.
        /// </summary>
        /// <example>
        /// ///
        /// protected override void OnSourceInitialized(EventArgs e)
        /// {
        ///    base.OnSourceInitialized(e);
        ///    var hwnd = new WindowInteropHelper(this).Handle;
        ///    WindowsServices.SetWindowExTransparent(hwnd);
        /// }
        ///</example>
        public static void MakeWindowCompletelyTransparent(IntPtr hwnd)
        {
            var extendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
            SetWindowLong(hwnd, GWL_EXSTYLE, extendedStyle | WS_EX_TRANSPARENT);
        }

        const int WS_EX_TRANSPARENT = 0x00000020;
        const int GWL_EXSTYLE = (-20);

        [DllImport("user32.dll")]
        static extern int GetWindowLong(IntPtr hwnd, int index);

        [DllImport("user32.dll")]
        static extern int SetWindowLong(IntPtr hwnd, int index, int newStyle);

        #endregion

        #region Menus

        /// <summary>
        /// Invalidates a menu control and all of its subitems
        /// by checking Command.IsEnabled property if a command exists
        /// </summary>
        /// <param name="menu"></param>
        public static void InvalidateMenuCommands(System.Windows.Controls.Menu menu)
        {

            foreach (var item in menu.Items)
            {
                var mi = item as System.Windows.Controls.MenuItem;
                if (mi == null)
                    continue;

                InvalidateSubmenuCommands(mi);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="menuItem"></param>
        public static void InvalidateSubmenuCommands(System.Windows.Controls.MenuItem menuItem)
        {
            if (menuItem == null)
                return;

            foreach (var item in menuItem.Items)
            {
                var mi = item as System.Windows.Controls.MenuItem;
                if (mi == null)
                    continue;

                if (mi.Command != null)
                    mi.IsEnabled = mi.Command.CanExecute(mi.CommandParameter);

                if (mi.HasItems)
                    InvalidateSubmenuCommands(mi);
            }
        }

        #endregion

        #region Miscellaneous
        private static void EmptyMethod()
        {
        }

        /// <summary>
        /// Idle loop to let events fire in the UI
        /// 
        /// Use SPARINGLY or not at all if there is a better way
        /// but there are a few places where this is required.
        /// </summary>
        public static void DoEvents()
        {
            try
            {
                // This can fail if the dispatcher is disabled by another process
                if (!IsDispatcherDisabled())
                    Dispatcher.CurrentDispatcher.Invoke(EmptyMethod, DispatcherPriority.Background);
            }
            catch (Exception ex)
            {
                mmApp.Log("DoEvents failed", ex);
            }
        }


        static readonly FieldInfo DisableProcessCountField =
            typeof(Dispatcher).GetField("_disableProcessingCount", BindingFlags.Instance | BindingFlags.NonPublic);


        /// <summary>
        /// Check to see if the Dispatcher is currently not active which can happen internally
        /// in WPF rendering and cause unexpected exceptions. Check for those edge cases
        /// </summary>
        /// <param name="dispatcher"></param>
        /// <returns></returns>
        public static bool IsDispatcherDisabled(Dispatcher dispatcher = null)
        {
            if (dispatcher == null)
                dispatcher = Dispatcher.CurrentDispatcher;

            // This can fail if the dispatcher is disabled by another process
            if (DisableProcessCountField == null)
                return true;

            return (int) DisableProcessCountField.GetValue(dispatcher) != 0;
        }

        /// <summary>
        /// Forces lost focus on the active control in a Window to force the selected control
        /// to databind.
        /// Typical scenario: Toolbar clicks (which don't cause a focus change) don't see
        /// latest control state of the active control because it doesn't know focus has
        /// changed. This forces the active control to unbind       
        /// </summary>
        /// <param name="window">Active window</param>
        /// <param name="control">Control to force focus to briefly to force active control to bind</param>
        public static void FixFocus(Window window, System.Windows.Controls.Control control)
        {
            var ctl = FocusManager.GetFocusedElement(window);
            if (ctl == null)
                return;

            control.Focus();
            window.Dispatcher.Invoke(() => ctl.Focus(), DispatcherPriority.ApplicationIdle);
        }

        /// <summary>
        /// Finds a particular type of control in the children of a top level control
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static T FindVisualChild<T>(DependencyObject obj) where T : DependencyObject
        {
            if (obj != null)
            {
                for (int i = 0; i < VisualTreeHelper.GetChildrenCount(obj); i++)
                {
                    var child = VisualTreeHelper.GetChild(obj, i);
                    if (child is T)
                    {
                        return (T) child;
                    }

                    T childItem = FindVisualChild<T>(child);
                    if (childItem != null) return childItem;
                }
            }

            return null;
        }


        /// <summary>
        /// Finds a type of element in the parent chain of an element
        /// </summary>
        /// <typeparam name="T">Type of Element to find</typeparam>
        /// <param name="current">start element</param>
        /// <returns></returns>
        public static T FindAnchestor<T>(DependencyObject current)
            where T : DependencyObject
        {
            do
            {
                if (current is T) return (T) current;

                current = VisualTreeHelper.GetParent(current);
            } while (current != null);

            return null;
        }


        /// <summary>
        /// Retrieves a nested TreeViewItem by walking the hierarchy.
        /// Specify a root treeview or treeviewitem and it then walks
        /// the hierarchy to find the item
        /// </summary>
        /// <param name="item">Item to find</param>
        /// <param name="treeItem">Parent item to start search from</param>
        /// <returns></returns>
        public static TreeViewItem GetNestedTreeviewItem(object item, ItemsControl treeItem)
        {
            if (treeItem
                .ItemContainerGenerator
                .ContainerFromItem(item) is TreeViewItem titem)
                return titem;

            foreach (var childItem in treeItem.Items)
            {
                titem = treeItem
                    .ItemContainerGenerator
                    .ContainerFromItem(childItem) as TreeViewItem;

                if (titem == null) continue;

                titem = GetNestedTreeviewItem(item, titem);

                if (treeItem
                .ItemContainerGenerator
                .ContainerFromItem(item) is TreeViewItem titem)
                    return titem;
            }

            return null;
        }
        #endregion
    }

    public enum ProcessDpiAwareness
    {
        Process_DPI_Unaware = 0,
        Process_System_DPI_Aware = 1,
        Process_Per_Monitor_DPI_Aware = 2
    }

    //https://msdn.microsoft.com/en-us/library/windows/desktop/dn280511(v=vs.85).aspx
    public enum DpiType
    {
        Effective = 0,
        Angular = 1,
        Raw = 2,
    }

    [DebuggerDisplay("L:{Left} T:{Top}  {Width}x{Height} - C:{CenteredInMainWindow}")]
    public class WindowPosition
    {
        public double Left {get; set; }
        public double Top {get; set; }

        public double Width {get; set; }

        public double Height {get; set; }

        public bool CenterInMainWindow { get; set; } = false;
    }

}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MarkdownMonster\Windows\Helpers\WindowUtilities.cs(566,17): error CS0841: Cannot use local variable 'titem' before it is declared,D:\a\1\s\MarkdownMonster\Windows\Helpers\WindowUtilities.cs(570,21): error CS0841: Cannot use local variable 'titem' before it is declared,D:\a\1\s\MarkdownMonster\Windows\Helpers\WindowUtilities.cs(572,17): error CS0841: Cannot use local variable 'titem' before it is declared,D:\a\1\s\MarkdownMonster\Windows\Helpers\WindowUtilities.cs(572,53): error CS0841: Cannot use local variable 'titem' before it is declared,D:\a\1\s\MarkdownMonster\Windows\Helpers\WindowUtilities.cs(576,58): error CS0136: A local or parameter named 'titem' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using MahApps.Metro.Controls;
using MarkdownMonster.AddIns;
using MarkdownMonster.Utilities;
using Microsoft.Win32;
using Westwind.Utilities;

namespace MarkdownMonster.Windows
{
    /// <summary>
    /// Interaction logic for PasteHref.xaml
    /// </summary>
    public partial class PasteImageWindow : MetroWindow, INotifyPropertyChanged
    {
        private string _image;
        private string _imageText;

        public string Image
        {
            get { return _image; }
            set
            {
                if (value == _image) return;
                _image = value;
                OnPropertyChanged(nameof(Image));
                OnPropertyChanged(nameof(IsEditable));
            }
        }

        public string ImageText
        {
            get { return _imageText; }
            set
            {
                if (value == _imageText) return;
                _imageText = value;
                OnPropertyChanged(nameof(ImageText));
            }
        }


        public int ImageWidth
        {
            get { return _ImageWidth; }
            set
            {
                if (value > 10000)
                    value = 10000;

                if (value == _ImageWidth) return;
                _ImageWidth = value;
                OnPropertyChanged(nameof(ImageWidth));
            }
        }

        private int _ImageWidth;


        public int ImageHeight
        {
            get { return _ImageHeight; }
            set
            {
                if (value > 10000)
                    value = 10000;

                if (value == _ImageHeight) return;
                _ImageHeight = value;
                OnPropertyChanged(nameof(ImageHeight));
            }
        }

        private int _ImageHeight;


        public bool IsImageFixedRatio
        {
            get { return _IsImageFixedRatio; }
            set
            {
                if (value == _IsImageFixedRatio) return;
                _IsImageFixedRatio = value;
                OnPropertyChanged(nameof(IsImageFixedRatio));
            }
        }
        private bool _IsImageFixedRatio = true;



        public bool PasteAsBase64Content
        {
            get { return _PasteAsBase64Content; }
            set
            {
                if (value == _PasteAsBase64Content) return;
                _PasteAsBase64Content = value;
                OnPropertyChanged(nameof(PasteAsBase64Content));
            }
        }

        private bool _PasteAsBase64Content = false;




        public string MarkdownFile { get; set; }

        public AppModel AppModel { get; set; } = mmApp.Model;

        public CommandBase PasteCommand
        {
            get { return _pasteCommand; }
            set
            {
                _pasteCommand = value;
                OnPropertyChanged(nameof(PasteCommand));
            }
        }

        private CommandBase _pasteCommand;

        public bool IsFileImage
        {
            get { return !_isMemoryImage; }
        }

        public bool IsMemoryImage
        {
            get { return _isMemoryImage; }
            set
            {
                if (value == _isMemoryImage) return;
                _isMemoryImage = value;
                OnPropertyChanged(nameof(IsMemoryImage));
                OnPropertyChanged(nameof(IsFileImage));
                OnPropertyChanged(nameof(IsPreview));
                OnPropertyChanged(nameof(IsEditable));
            }
        }

        private bool _isMemoryImage;

        public bool IsEditable
        {
            get { return !string.IsNullOrEmpty(Image) || IsMemoryImage; } 
        }

        public bool IsPreview
        {
            get { return ImagePreview.Source != null; }
        }


        
        AppModel Model { get; set; }
        MarkdownDocumentEditor Editor { get; set; }
        MarkdownDocument Document { get; set; }

        StatusBarHelper StatusBar { get; }


        public PasteImageWindow(MainWindow window)
        {
            InitializeComponent();

            Owner = window;
            DataContext = this;

            mmApp.SetThemeWindowOverride(this);

            Loaded += PasteImage_Loaded;
            SizeChanged += PasteImage_SizeChanged;
            Activated += PasteImage_Activated;
            PreviewKeyDown += PasteImage_PreviewKeyDown;


            Model = window.Model;
            Editor = Model.ActiveEditor;
            Document = Model.ActiveDocument;

            StatusBar = new StatusBarHelper(StatusText, StatusIcon);
        }


        private void PasteImage_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            bool isControlKey = (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control;
            var clipText = ClipboardHelper.GetText();

            if (isControlKey && e.Key == Key.V && Clipboard.ContainsImage())
                PasteImageFromClipboard();
            else if (isControlKey && e.Key == Key.C)
                Button_CopyImage(null, null);
        }

        private void PasteImage_Activated(object sender, EventArgs e)
        {
            if (string.IsNullOrEmpty(Image) && Clipboard.ContainsImage())
                PasteImageFromClipboard();
        }

        private void PasteImage_Loaded(object sender, RoutedEventArgs e)
        {

            PasteCommand = new CommandBase((s, args) => { MessageBox.Show("PasteCommand"); });

            TextImage.Focus();
            if (string.IsNullOrEmpty(Image) && Clipboard.ContainsImage())
            {
                PasteImageFromClipboard();
            }
            else if (string.IsNullOrEmpty(Image) && Clipboard.ContainsText())
            {
                string clip = ClipboardHelper.GetText()?.ToLower();
                if ((clip.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase) ||
                     clip.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase)) &&
                    (clip.Contains(".png", StringComparison.InvariantCultureIgnoreCase) ||
                     clip.Contains("jpg", StringComparison.InvariantCultureIgnoreCase)))
                {
                    TextImage.Text = clip;
                    SetImagePreview(clip);
                }
            }
        }

        private void TextImage_LostFocus(object sender, RoutedEventArgs e)
        {

            if (!IsMemoryImage && string.IsNullOrEmpty(TextImage.Text))
            {
                ImagePreview.Source = null;
                return;
            }

            string href = TextImage.Text.ToLower();
            if (href.StartsWith("http://") || href.StartsWith("https://"))
            {
                SetImagePreview(TextImage.Text);
            }
        }

        #region Main Buttons

        /// <summary>
        /// Saves an image loaded from clipboard to disk OR if base64 is checked
        /// creates the base64 content.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Button_SaveImage(object sender, RoutedEventArgs e)
        {
            string imagePath = null;

            var bitmapSource = ImagePreview.Source as BitmapSource;
            if (bitmapSource == null)
            {
                MessageBox.Show("Unable to convert bitmap source.", "Bitmap conversion error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
                return;
            }

            using (var bitMap = WindowUtilities.BitmapSourceToBitmap(bitmapSource))
            {
                if (bitMap == null)
                    return;

                if (PasteAsBase64Content)
                {
                    Base64EncodeImage(bitMap);
                    IsMemoryImage = false;
                    return;
                }


                // image path overridden by addin?
                imagePath = AddinManager.Current.RaiseOnSaveImage(bitMap);
                if (!string.IsNullOrEmpty(imagePath))
                {
                    TextImage.Text = imagePath;
                    IsMemoryImage = false;
                    return;
                }

                // Save image and return the relative Url
                imagePath = FileSaver.SaveBitmapAndLinkInEditor(bitMap);
                if (!string.IsNullOrEmpty(imagePath))
                {
                    Image = imagePath;
                    IsMemoryImage = false;
                }
            }
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            WindowUtilities.FixFocus(this, CheckPasteAsBase64Content);

            if (DialogResult == null)  // avoid multi-click setting
            {
                if (sender == ButtonCancel)
                    DialogResult = false;
                else
                    DialogResult = true;
            }

            Close();
        }

        private void Button_PasteImage(object sender, RoutedEventArgs e)
        {
            PasteImageFromClipboard();
        }

        private void CheckPasteAsBase64Content_Checked(object sender, RoutedEventArgs e)
        {
            if (PasteAsBase64Content)
                if (IsMemoryImage)
                {
                    Base64EncodeImage(WindowUtilities.BitmapSourceToBitmap(ImagePreview.Source as BitmapSource));
                    IsMemoryImage = false;
                }
                else
                    Base64EncodeImage(Image);
            else
                Image = null;
        }

        private void Button_EditImage(object sender, RoutedEventArgs e)
        {
            if (IsMemoryImage)
            {
                EditMemoryImage();
                return;
            } 

            string exe = mmApp.Configuration.Images.ImageEditor;

            if (string.IsNullOrEmpty(Image))
            {
                StatusBar.ShowStatusError("No image selected.");
                return;
            }

            string imageFile = Image;
            if (!imageFile.Contains(":\\") && Document != null)
            {
                imageFile = Path.Combine(Path.GetDirectoryName(Document.Filename),
                    Image);
            }

            if (!mmFileUtils.OpenImageInImageEditor(imageFile))
            {
                MessageBox.Show("Unable to launch image editor " + Path.GetFileName(mmApp.Configuration.Images.ImageEditor) +
                                "\r\n\r\n" +
                                "Most likely the image editor configured in settings is not a valid executable. Please check the 'ImageEditor' key in the Markdown Monster Settings.\r\n\r\n" +
                                "We're opening the settings file for you in the editor now.",
                    "Image Launching Error",
                    MessageBoxButton.OK, MessageBoxImage.Warning);

                mmApp.Model.Window.OpenTab(Path.Combine(mmApp.Configuration.CommonFolder, "MarkdownMonster.json"));
            }
            else
                StatusBar.ShowStatusSuccess($"Launching editor {exe} with {imageFile}");
        }

        private void EditMemoryImage()
        {
            var bmpSource = ImagePreview.Source as BitmapSource;
            if (bmpSource == null)
                return;

            var bmp = WindowUtilities.BitmapSourceToBitmap(bmpSource);
            if (bmp == null)
            {
                StatusBar.ShowStatusError("Couldn't convert image to file.");
                return;
            }

            var filename = Path.Combine(Path.ChangeExtension(Path.GetTempFileName(), "png"));
            bmp.Save(filename);

            mmFileUtils.OpenImageInImageEditor(filename);
            StatusBar.ShowStatusSuccess("When done copy your image to the clipboard and return to this dialog.");
        }


        private void Button_ClearImage(object sender, RoutedEventArgs e)
        {
            Image = null;
            ImageText = null;
            ImagePreview.Source = null;
            IsMemoryImage = false;

            StatusBar.ShowStatusSuccess("Image has been cleared.");
        }

        private void Button_CopyImage(object sender, RoutedEventArgs e)
        {
            if (ImagePreview.Source != null)
            {
                var src = ImagePreview.Source as BitmapSource;
                if (src != null)
                {
                    Clipboard.SetImage(src);
                    StatusBar.ShowStatus("Image copied to the Clipboard.");
                }
            }
        }

        private void Button_SelectLocalImageFile_Click(object sender, RoutedEventArgs e)
        {
            var fd = new OpenFileDialog
            {
                DefaultExt = ".png",
                Filter = "Image files (*.png;*.jpg;*.gif;)|*.png;*.jpg;*.jpeg;*.gif|All Files (*.*)|*.*",
                CheckFileExists = true,
                RestoreDirectory = true,
                Multiselect = false,
                Title = "Embed Image"
            };

            if (!string.IsNullOrEmpty(Document.LastImageFolder))
                fd.InitialDirectory = Document.LastImageFolder;
            else if (!string.IsNullOrEmpty(MarkdownFile))
                fd.InitialDirectory = Path.GetDirectoryName(MarkdownFile);
            else
                fd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);

            var res = fd.ShowDialog();
            if (res == null || !res.Value)
                return;


            Image = fd.FileName;
            Document.LastImageFolder = Path.GetDirectoryName(fd.FileName);

            if (PasteAsBase64Content)
            {
                var bmi = new BitmapImage(new Uri(fd.FileName))
                {
                    CreateOptions = BitmapCreateOptions.IgnoreImageCache // don't lock file
                };

                Base64EncodeImage(fd.FileName);
                ImagePreview.Source = bmi;
                return;
            }


            // Normalize the path relative to the Markdown file
            if (!string.IsNullOrEmpty(MarkdownFile) && MarkdownFile != "untitled")
            {
                var imgUrl = AddinManager.Current.RaiseOnSaveImage(fd.FileName);
                if (!string.IsNullOrEmpty(imgUrl))
                {
                    Image = imgUrl;
                    TextImageText.Focus();
                    return;
                }

                string mdPath = Path.GetDirectoryName(MarkdownFile);
                string relPath = fd.FileName;
                try
                {
                    relPath = FileUtils.GetRelativePath(fd.FileName, mdPath);
                }
                catch (Exception ex)
                {
                    mmApp.Log($"Failed to get relative path.\r\nFile: {fd.FileName}, Path: {mdPath}", ex);
                }


                if (!relPath.StartsWith("..\\"))
                    Image = relPath;
                else
                {
                    // not relative
                    var mbres = MessageBox.Show(
                        "The image you are linking, is not in a relative path.\r\n" +
                        "Do you want to copy it to a local path?",
                        "Non-relative Image",
                        MessageBoxButton.YesNo,
                        MessageBoxImage.Question);

                    if (mbres.Equals(MessageBoxResult.Yes))
                    {
                        string newImageFileName = Path.Combine(mdPath, Path.GetFileName(fd.FileName));
                        var sd = new SaveFileDialog
                        {
                            Filter =
                                "Image files (*.png;*.jpg;*.gif;)|*.png;*.jpg;*.jpeg;*.gif|All Files (*.*)|*.*",
                            FilterIndex = 1,
                            FileName = newImageFileName,
                            InitialDirectory = mdPath,
                            CheckFileExists = false,
                            OverwritePrompt = true,
                            CheckPathExists = true,
                            RestoreDirectory = true
                        };
                        var result = sd.ShowDialog();
                        if (result != null && result.Value)
                        {
                            try
                            {
                                File.Copy(fd.FileName, sd.FileName, true);
                                Document.LastImageFolder = Path.GetDirectoryName(sd.FileName);
                            }
                            catch (Exception ex)
                            {
                                MessageBox.Show("Couldn't copy file to new location: \r\n" + ex.Message,
                                    mmApp.ApplicationName);
                                return;
                            }

                            try
                            {
                                relPath = FileUtils.GetRelativePath(sd.FileName, mdPath);
                            }
                            catch (Exception ex)
                            {
                                mmApp.Log($"Failed to get relative path.\r\nFile: {sd.FileName}, Path: {mdPath}", ex);
                            }

                            Image = relPath;
                        }
                    }
                    else
                        Image = relPath;
                }
            }



            if (Image.Contains(":\\"))
                Image = "file:///" + Image;
            else
                Image = Image.Replace("\\", "/");

            SetImagePreview("file:///" + fd.FileName);

            IsMemoryImage = false;
            TextImageText.Focus();
        }

        private void ButtonRememberLastSize_Click(object sender, RoutedEventArgs e)
        {
            ImageWidth = Model.Configuration.Images.LastImageWidth;
            ImageHeight = Model.Configuration.Images.LastImageHeight;
            ImageSizeChanged(ResizeModes.Auto);
        }

        #endregion

        #region Image Manipulation

        public void SetImagePreview(string url = null)
        {
            if (string.IsNullOrEmpty(url))
            {
                url = GetFullImageFilename();
                if (url == null)
                    url = Image;
            }

            try
            {

                var bmi = new BitmapImage();
                bmi.BeginInit();
                //bmi.CacheOption = BitmapCacheOption.OnLoad;
                bmi.UriSource = new Uri(url);
                bmi.EndInit();

                SetImagePreview(bmi);

            }
            catch (Exception ex)
            {
                Debug.WriteLine("SetImagePreview Exception: " + ex.Message);
            }
        }

        private void SetImagePreview(ImageSource source)
        {
            try
            {
                ImagePreview.Source = source;
                if (Height < 400)
                {
                    Top -= 300;
                    Left -= 100;
                    Width = 800;
                    Height = 800;
                }

                var bmp = source as BitmapFrame;
                if (bmp != null)
                {
                    ImageHeight = (int) bmp.PixelHeight;
                    ImageWidth = (int) bmp.PixelWidth;
                }
                else
                {
                    ImageHeight = 0;
                    ImageWidth = 0;
                }

                ResizeImagePreviewControl(bmp);
            }
            catch(Exception ex)
            {
                Debug.WriteLine("SetImagePreview Exception: " + ex.Message);
            }
        }


        /// <summary>
        /// This method will resize the in-memory image using a fixed ratio
        /// </summary>
        private void ImageSizeChanged(ResizeModes resizeMode)
        {
            var image = ImagePreview.Source as BitmapSource;
            if (image == null)
                return;

            Dispatcher.InvokeAsync(() =>
            {
                if (ImageHeight == (int) image.Height && ImageWidth == (int) image.Width)
                    return;

                using (var bitmap = WindowUtilities.BitmapSourceToBitmap(ImagePreview.Source as BitmapSource))
                {
                    if (bitmap == null)
                    {
                        StatusBar.ShowStatusError("No image to resize.");
                        return;
                    }

                    if (ImageWidth != bitmap.Width && ImageHeight != bitmap.Height)
                        return;

                    
                    Bitmap bitmap2;
                    using (bitmap2 = ImageResizer.ResizeImageByMode(bitmap, ImageWidth, ImageHeight,resizeMode))
                    {
                        if (bitmap2 != null)
                        {
                            Debug.WriteLine($"ImageSizeChanged from: {ImageWidth} x {ImageHeight} to: {bitmap2.Width} x {bitmap2.Height}");


                            ImageWidth = bitmap2.Width;
                            ImageHeight = bitmap2.Height;

                            var bmpSource = WindowUtilities.BitmapToBitmapSource(bitmap2);
                            WindowUtilities.DoEvents();
                            ImagePreview.Source = bmpSource;


                            Dispatcher.InvokeAsync(() => ResizeImagePreviewControl(bmpSource),
                                DispatcherPriority.ApplicationIdle);
                        }
                    }
                }
            }, DispatcherPriority.ApplicationIdle);
        }

        /// <summary>
        /// Figures out how to stretch the image that is displayed whether it's 'normal'
        /// or adjusted.
        /// </summary>
        /// <param name="image"></param>
        private void ResizeImagePreviewControl(ImageSource image)
        {
            if (image == null)
                return;

            // ensure that any new image assignment has 
            if (image.Width < Width - 20 && image.Height < PageGrid.RowDefinitions[1].ActualHeight)
                ImagePreview.Stretch = Stretch.None;
            else
                ImagePreview.Stretch = Stretch.Uniform;
        }
        #endregion


        private void PasteImageFromClipboard()
        {
            ImageSource image;
            
            try
            {
                image = ClipboardHelper.GetImageSource();
            }
            catch (Exception e)
            {
                StatusBar.ShowStatusError("Image retrieval from clipboard failed: " + e.Message);
                return;
            }

            if (image == null)
            {
                var data = System.Windows.Forms.Clipboard.GetDataObject();
                var formats = data?.GetFormats();
                string formatStrings = null;
                if (formats != null && formats.Length > 0)
                    formatStrings = "Formats: " + string.Join(",", formats);

                mmApp.Log($"Couldn't retrieve image from Clipboard. {formatStrings}",logLevel: LogLevels.Warning);
                StatusBar.ShowStatusError("Image retrieval from clipboard failed.");
                return;
            }

            ImagePreview.Source = image;

            SetImagePreview(image);

            Image = null;
            IsMemoryImage = true;

            ImageWidth = (int) image.Width;
            ImageHeight = (int) image.Height;

            StatusBar.ShowStatusSuccess("Image pasted from clipboard.");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="file"></param>
        public void Base64EncodeImage(string file)
        {
            try
            {
                if (!PasteAsBase64Content ||
                    Image == null ||
                    Image.StartsWith("data:image/") ||
                    file == "Untitled")
                    return;

                file = file.Replace("file:///", "");

                var fullPath = file;
                if (!File.Exists(file))
                    fullPath = Path.Combine(Path.GetDirectoryName(Editor.MarkdownDocument.Filename), file);

                if (File.Exists(fullPath))
                {
                    var bytes = File.ReadAllBytes(fullPath);
                    var bytestring = Convert.ToBase64String(bytes);
                    var mediaFormat = ImageUtils.GetImageMediaTypeFromFilename(fullPath);
                    Image = $"data:{mediaFormat};base64," + bytestring;
                }
            }
            catch (Exception ex)
            {
                StatusBar.ShowStatusError("Image base64 encoding failed: " + ex.GetBaseException().Message);
            }
        }

        public void Base64EncodeImage(Bitmap bmp)
        {
            try
            {
                using (var ms = new MemoryStream(10000))
                {
                    bmp.Save(ms, ImageFormat.Jpeg);
                    ms.Flush();
                    Image = $"data:image/jpeg;base64,{Convert.ToBase64String(ms.ToArray())}";
                }
            }
            catch (Exception ex)
            {
                StatusBar.ShowStatusError($"Image base64 encoding failed: {ex.GetBaseException().Message}");
            }
        }

        #region Image Operationz

        private void TextBox_ImageSizeChanged(object sender, RoutedEventArgs e)
        {
            var resizeMode = ResizeModes.ByWidth;
            if (sender == TextBoxImageHeight)
                resizeMode = ResizeModes.ByHeight;
            if (!IsImageFixedRatio)
                resizeMode = ResizeModes.DontKeepAspectRatio;


            // have to handle out of band or the binding hasn't updated yet
            Dispatcher.InvokeAsync(() =>
            {
                //var txtBox = sender as TextBox;
                //Debug.WriteLine(
                //    $"Image Size Changed {((TextBox) sender).Name} {ImageWidth} x {ImageHeight} {txtBox.Text}");
                ImageSizeChanged(resizeMode);

                Model.Configuration.Images.LastImageWidth = ImageWidth;
                Model.Configuration.Images.LastImageHeight = ImageHeight;
            }, DispatcherPriority.ApplicationIdle);
        }

        private void PasteImage_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            var image = ImagePreview.Source as BitmapSource;
            if (image == null)
                return;

            if (image.Width < Width - 20 && image.Height < PageGrid.RowDefinitions[1].ActualHeight)
                ImagePreview.Stretch = Stretch.None;
            else
                ImagePreview.Stretch = Stretch.Uniform;
        }


        /// <summary>
        /// Attempts to resolve the full image filename from the active image
        /// if the image is a file based image with a relative or physical
        /// path but not a URL based image.
        /// </summary>
        /// <returns></returns>
        public string GetFullImageFilename(string filename = null)
        {
            string imageFile = filename ?? Image;

            if (string.IsNullOrEmpty(imageFile))
                return null;

            try
            {
                if (!File.Exists(imageFile))
                    imageFile = Path.Combine(Path.GetDirectoryName(Editor.MarkdownDocument.Filename), imageFile);

                return File.Exists(imageFile) ? imageFile : null;
            }
            catch
            {
                mmApp.Log("Non-fatal error: Invalid image filename: " + imageFile);
                return null;
            }
        }

        #endregion

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

---- Transformed Tree ----
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using MahApps.Metro.Controls;
using MarkdownMonster.AddIns;
using MarkdownMonster.Utilities;
using Microsoft.Win32;
using Westwind.Utilities;

namespace MarkdownMonster.Windows
{
    /// <summary>
    /// Interaction logic for PasteHref.xaml
    /// </summary>
    public partial class PasteImageWindow : MetroWindow, INotifyPropertyChanged
    {
        private string _image;
        private string _imageText;

        public string Image
        {
            get { return _image; }
            set
            {
                if (value == _image) return;
                _image = value;
                OnPropertyChanged(nameof(Image));
                OnPropertyChanged(nameof(IsEditable));
            }
        }

        public string ImageText
        {
            get { return _imageText; }
            set
            {
                if (value == _imageText) return;
                _imageText = value;
                OnPropertyChanged(nameof(ImageText));
            }
        }


        public int ImageWidth
        {
            get { return _ImageWidth; }
            set
            {
                if (value > 10000)
                    value = 10000;

                if (value == _ImageWidth) return;
                _ImageWidth = value;
                OnPropertyChanged(nameof(ImageWidth));
            }
        }

        private int _ImageWidth;


        public int ImageHeight
        {
            get { return _ImageHeight; }
            set
            {
                if (value > 10000)
                    value = 10000;

                if (value == _ImageHeight) return;
                _ImageHeight = value;
                OnPropertyChanged(nameof(ImageHeight));
            }
        }

        private int _ImageHeight;


        public bool IsImageFixedRatio
        {
            get { return _IsImageFixedRatio; }
            set
            {
                if (value == _IsImageFixedRatio) return;
                _IsImageFixedRatio = value;
                OnPropertyChanged(nameof(IsImageFixedRatio));
            }
        }
        private bool _IsImageFixedRatio = true;



        public bool PasteAsBase64Content
        {
            get { return _PasteAsBase64Content; }
            set
            {
                if (value == _PasteAsBase64Content) return;
                _PasteAsBase64Content = value;
                OnPropertyChanged(nameof(PasteAsBase64Content));
            }
        }

        private bool _PasteAsBase64Content = false;




        public string MarkdownFile { get; set; }

        public AppModel AppModel { get; set; } = mmApp.Model;

        public CommandBase PasteCommand
        {
            get { return _pasteCommand; }
            set
            {
                _pasteCommand = value;
                OnPropertyChanged(nameof(PasteCommand));
            }
        }

        private CommandBase _pasteCommand;

        public bool IsFileImage
        {
            get { return !_isMemoryImage; }
        }

        public bool IsMemoryImage
        {
            get { return _isMemoryImage; }
            set
            {
                if (value == _isMemoryImage) return;
                _isMemoryImage = value;
                OnPropertyChanged(nameof(IsMemoryImage));
                OnPropertyChanged(nameof(IsFileImage));
                OnPropertyChanged(nameof(IsPreview));
                OnPropertyChanged(nameof(IsEditable));
            }
        }

        private bool _isMemoryImage;

        public bool IsEditable
        {
            get { return !string.IsNullOrEmpty(Image) || IsMemoryImage; } 
        }

        public bool IsPreview
        {
            get { return ImagePreview.Source != null; }
        }


        
        AppModel Model { get; set; }
        MarkdownDocumentEditor Editor { get; set; }
        MarkdownDocument Document { get; set; }

        StatusBarHelper StatusBar { get; }


        public PasteImageWindow(MainWindow window)
        {
            InitializeComponent();

            Owner = window;
            DataContext = this;

            mmApp.SetThemeWindowOverride(this);

            Loaded += PasteImage_Loaded;
            SizeChanged += PasteImage_SizeChanged;
            Activated += PasteImage_Activated;
            PreviewKeyDown += PasteImage_PreviewKeyDown;


            Model = window.Model;
            Editor = Model.ActiveEditor;
            Document = Model.ActiveDocument;

            StatusBar = new StatusBarHelper(StatusText, StatusIcon);
        }


        private void PasteImage_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            bool isControlKey = (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control;
            var clipText = ClipboardHelper.GetText();

            if (isControlKey && e.Key == Key.V && Clipboard.ContainsImage())
                PasteImageFromClipboard();
            else if (isControlKey && e.Key == Key.C)
                Button_CopyImage(null, null);
        }

        private void PasteImage_Activated(object sender, EventArgs e)
        {
            if (string.IsNullOrEmpty(Image) && Clipboard.ContainsImage())
                PasteImageFromClipboard();
        }

        private void PasteImage_Loaded(object sender, RoutedEventArgs e)
        {

            PasteCommand = new CommandBase((s, args) => { MessageBox.Show("PasteCommand"); });

            TextImage.Focus();
            if (string.IsNullOrEmpty(Image) && Clipboard.ContainsImage())
            {
                PasteImageFromClipboard();
            }
            else if (string.IsNullOrEmpty(Image) && Clipboard.ContainsText())
            {
                string clip = ClipboardHelper.GetText()?.ToLower();
                if ((clip.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase) ||
                     clip.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase)) &&
                    (clip.Contains(".png", StringComparison.InvariantCultureIgnoreCase) ||
                     clip.Contains("jpg", StringComparison.InvariantCultureIgnoreCase)))
                {
                    TextImage.Text = clip;
                    SetImagePreview(clip);
                }
            }
        }

        private void TextImage_LostFocus(object sender, RoutedEventArgs e)
        {

            if (!IsMemoryImage && string.IsNullOrEmpty(TextImage.Text))
            {
                ImagePreview.Source = null;
                return;
            }

            string href = TextImage.Text.ToLower();
            if (href.StartsWith("http://") || href.StartsWith("https://"))
            {
                SetImagePreview(TextImage.Text);
            }
        }

        #region Main Buttons

        /// <summary>
        /// Saves an image loaded from clipboard to disk OR if base64 is checked
        /// creates the base64 content.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Button_SaveImage(object sender, RoutedEventArgs e)
        {
            string imagePath = null;

            var bitmapSource = ImagePreview.Source as BitmapSource;
            if (bitmapSource == null)
            {
                MessageBox.Show("Unable to convert bitmap source.", "Bitmap conversion error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
                return;
            }

            using (var bitMap = WindowUtilities.BitmapSourceToBitmap(bitmapSource))
            {
                if (bitMap == null)
                    return;

                if (PasteAsBase64Content)
                {
                    Base64EncodeImage(bitMap);
                    IsMemoryImage = false;
                    return;
                }


                // image path overridden by addin?
                imagePath = AddinManager.Current.RaiseOnSaveImage(bitMap);
                if (!string.IsNullOrEmpty(imagePath))
                {
                    TextImage.Text = imagePath;
                    IsMemoryImage = false;
                    return;
                }

                // Save image and return the relative Url
                imagePath = FileSaver.SaveBitmapAndLinkInEditor(bitMap);
                if (!string.IsNullOrEmpty(imagePath))
                {
                    Image = imagePath;
                    IsMemoryImage = false;
                }
            }
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            WindowUtilities.FixFocus(this, CheckPasteAsBase64Content);

            if (DialogResult == null)  // avoid multi-click setting
            {
                if (sender == ButtonCancel)
                    DialogResult = false;
                else
                    DialogResult = true;
            }

            Close();
        }

        private void Button_PasteImage(object sender, RoutedEventArgs e)
        {
            PasteImageFromClipboard();
        }

        private void CheckPasteAsBase64Content_Checked(object sender, RoutedEventArgs e)
        {
            if (PasteAsBase64Content)
                if (IsMemoryImage)
                {
                    Base64EncodeImage(WindowUtilities.BitmapSourceToBitmap(ImagePreview.Source as BitmapSource));
                    IsMemoryImage = false;
                }
                else
                    Base64EncodeImage(Image);
            else
                Image = null;
        }

        private void Button_EditImage(object sender, RoutedEventArgs e)
        {
            if (IsMemoryImage)
            {
                EditMemoryImage();
                return;
            } 

            string exe = mmApp.Configuration.Images.ImageEditor;

            if (string.IsNullOrEmpty(Image))
            {
                StatusBar.ShowStatusError("No image selected.");
                return;
            }

            string imageFile = Image;
            if (!imageFile.Contains(":\\") && Document != null)
            {
                imageFile = Path.Combine(Path.GetDirectoryName(Document.Filename),
                    Image);
            }

            if (!mmFileUtils.OpenImageInImageEditor(imageFile))
            {
                MessageBox.Show("Unable to launch image editor " + Path.GetFileName(mmApp.Configuration.Images.ImageEditor) +
                                "\r\n\r\n" +
                                "Most likely the image editor configured in settings is not a valid executable. Please check the 'ImageEditor' key in the Markdown Monster Settings.\r\n\r\n" +
                                "We're opening the settings file for you in the editor now.",
                    "Image Launching Error",
                    MessageBoxButton.OK, MessageBoxImage.Warning);

                mmApp.Model.Window.OpenTab(Path.Combine(mmApp.Configuration.CommonFolder, "MarkdownMonster.json"));
            }
            else
                StatusBar.ShowStatusSuccess($"Launching editor {exe} with {imageFile}");
        }

        private void EditMemoryImage()
        {
            var bmpSource = ImagePreview.Source as BitmapSource;
            if (bmpSource == null)
                return;

            var bmp = WindowUtilities.BitmapSourceToBitmap(bmpSource);
            if (bmp == null)
            {
                StatusBar.ShowStatusError("Couldn't convert image to file.");
                return;
            }

            var filename = Path.Combine(Path.ChangeExtension(Path.GetTempFileName(), "png"));
            bmp.Save(filename);

            mmFileUtils.OpenImageInImageEditor(filename);
            StatusBar.ShowStatusSuccess("When done copy your image to the clipboard and return to this dialog.");
        }


        private void Button_ClearImage(object sender, RoutedEventArgs e)
        {
            Image = null;
            ImageText = null;
            ImagePreview.Source = null;
            IsMemoryImage = false;

            StatusBar.ShowStatusSuccess("Image has been cleared.");
        }

        private void Button_CopyImage(object sender, RoutedEventArgs e)
        {
            if (ImagePreview.Source != null)
            {
                if (ImagePreview.Source is BitmapSource src)
                {
                    Clipboard.SetImage(src);
                    StatusBar.ShowStatus("Image copied to the Clipboard.");
                }
            }
        }

        private void Button_SelectLocalImageFile_Click(object sender, RoutedEventArgs e)
        {
            var fd = new OpenFileDialog
            {
                DefaultExt = ".png",
                Filter = "Image files (*.png;*.jpg;*.gif;)|*.png;*.jpg;*.jpeg;*.gif|All Files (*.*)|*.*",
                CheckFileExists = true,
                RestoreDirectory = true,
                Multiselect = false,
                Title = "Embed Image"
            };

            if (!string.IsNullOrEmpty(Document.LastImageFolder))
                fd.InitialDirectory = Document.LastImageFolder;
            else if (!string.IsNullOrEmpty(MarkdownFile))
                fd.InitialDirectory = Path.GetDirectoryName(MarkdownFile);
            else
                fd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);

            var res = fd.ShowDialog();
            if (res == null || !res.Value)
                return;


            Image = fd.FileName;
            Document.LastImageFolder = Path.GetDirectoryName(fd.FileName);

            if (PasteAsBase64Content)
            {
                var bmi = new BitmapImage(new Uri(fd.FileName))
                {
                    CreateOptions = BitmapCreateOptions.IgnoreImageCache // don't lock file
                };

                Base64EncodeImage(fd.FileName);
                ImagePreview.Source = bmi;
                return;
            }


            // Normalize the path relative to the Markdown file
            if (!string.IsNullOrEmpty(MarkdownFile) && MarkdownFile != "untitled")
            {
                var imgUrl = AddinManager.Current.RaiseOnSaveImage(fd.FileName);
                if (!string.IsNullOrEmpty(imgUrl))
                {
                    Image = imgUrl;
                    TextImageText.Focus();
                    return;
                }

                string mdPath = Path.GetDirectoryName(MarkdownFile);
                string relPath = fd.FileName;
                try
                {
                    relPath = FileUtils.GetRelativePath(fd.FileName, mdPath);
                }
                catch (Exception ex)
                {
                    mmApp.Log($"Failed to get relative path.\r\nFile: {fd.FileName}, Path: {mdPath}", ex);
                }


                if (!relPath.StartsWith("..\\"))
                    Image = relPath;
                else
                {
                    // not relative
                    var mbres = MessageBox.Show(
                        "The image you are linking, is not in a relative path.\r\n" +
                        "Do you want to copy it to a local path?",
                        "Non-relative Image",
                        MessageBoxButton.YesNo,
                        MessageBoxImage.Question);

                    if (mbres.Equals(MessageBoxResult.Yes))
                    {
                        string newImageFileName = Path.Combine(mdPath, Path.GetFileName(fd.FileName));
                        var sd = new SaveFileDialog
                        {
                            Filter =
                                "Image files (*.png;*.jpg;*.gif;)|*.png;*.jpg;*.jpeg;*.gif|All Files (*.*)|*.*",
                            FilterIndex = 1,
                            FileName = newImageFileName,
                            InitialDirectory = mdPath,
                            CheckFileExists = false,
                            OverwritePrompt = true,
                            CheckPathExists = true,
                            RestoreDirectory = true
                        };
                        var result = sd.ShowDialog();
                        if (result != null && result.Value)
                        {
                            try
                            {
                                File.Copy(fd.FileName, sd.FileName, true);
                                Document.LastImageFolder = Path.GetDirectoryName(sd.FileName);
                            }
                            catch (Exception ex)
                            {
                                MessageBox.Show("Couldn't copy file to new location: \r\n" + ex.Message,
                                    mmApp.ApplicationName);
                                return;
                            }

                            try
                            {
                                relPath = FileUtils.GetRelativePath(sd.FileName, mdPath);
                            }
                            catch (Exception ex)
                            {
                                mmApp.Log($"Failed to get relative path.\r\nFile: {sd.FileName}, Path: {mdPath}", ex);
                            }

                            Image = relPath;
                        }
                    }
                    else
                        Image = relPath;
                }
            }



            if (Image.Contains(":\\"))
                Image = "file:///" + Image;
            else
                Image = Image.Replace("\\", "/");

            SetImagePreview("file:///" + fd.FileName);

            IsMemoryImage = false;
            TextImageText.Focus();
        }

        private void ButtonRememberLastSize_Click(object sender, RoutedEventArgs e)
        {
            ImageWidth = Model.Configuration.Images.LastImageWidth;
            ImageHeight = Model.Configuration.Images.LastImageHeight;
            ImageSizeChanged(ResizeModes.Auto);
        }

        #endregion

        #region Image Manipulation

        public void SetImagePreview(string url = null)
        {
            if (string.IsNullOrEmpty(url))
            {
                url = GetFullImageFilename();
                if (url == null)
                    url = Image;
            }

            try
            {

                var bmi = new BitmapImage();
                bmi.BeginInit();
                //bmi.CacheOption = BitmapCacheOption.OnLoad;
                bmi.UriSource = new Uri(url);
                bmi.EndInit();

                SetImagePreview(bmi);

            }
            catch (Exception ex)
            {
                Debug.WriteLine("SetImagePreview Exception: " + ex.Message);
            }
        }

        private void SetImagePreview(ImageSource source)
        {
            try
            {
                ImagePreview.Source = source;
                if (Height < 400)
                {
                    Top -= 300;
                    Left -= 100;
                    Width = 800;
                    Height = 800;
                }

                if (source is BitmapFrame bmp)
                {
                    ImageHeight = (int) bmp.PixelHeight;
                    ImageWidth = (int) bmp.PixelWidth;
                }
                else
                {
                    ImageHeight = 0;
                    ImageWidth = 0;
                }

                ResizeImagePreviewControl(bmp);
            }
            catch(Exception ex)
            {
                Debug.WriteLine("SetImagePreview Exception: " + ex.Message);
            }
        }


        /// <summary>
        /// This method will resize the in-memory image using a fixed ratio
        /// </summary>
        private void ImageSizeChanged(ResizeModes resizeMode)
        {
            var image = ImagePreview.Source as BitmapSource;
            if (image == null)
                return;

            Dispatcher.InvokeAsync(() =>
            {
                if (ImageHeight == (int) image.Height && ImageWidth == (int) image.Width)
                    return;

                using (var bitmap = WindowUtilities.BitmapSourceToBitmap(ImagePreview.Source as BitmapSource))
                {
                    if (bitmap == null)
                    {
                        StatusBar.ShowStatusError("No image to resize.");
                        return;
                    }

                    if (ImageWidth != bitmap.Width && ImageHeight != bitmap.Height)
                        return;

                    
                    Bitmap bitmap2;
                    using (bitmap2 = ImageResizer.ResizeImageByMode(bitmap, ImageWidth, ImageHeight,resizeMode))
                    {
                        if (bitmap2 != null)
                        {
                            Debug.WriteLine($"ImageSizeChanged from: {ImageWidth} x {ImageHeight} to: {bitmap2.Width} x {bitmap2.Height}");


                            ImageWidth = bitmap2.Width;
                            ImageHeight = bitmap2.Height;

                            var bmpSource = WindowUtilities.BitmapToBitmapSource(bitmap2);
                            WindowUtilities.DoEvents();
                            ImagePreview.Source = bmpSource;


                            Dispatcher.InvokeAsync(() => ResizeImagePreviewControl(bmpSource),
                                DispatcherPriority.ApplicationIdle);
                        }
                    }
                }
            }, DispatcherPriority.ApplicationIdle);
        }

        /// <summary>
        /// Figures out how to stretch the image that is displayed whether it's 'normal'
        /// or adjusted.
        /// </summary>
        /// <param name="image"></param>
        private void ResizeImagePreviewControl(ImageSource image)
        {
            if (image == null)
                return;

            // ensure that any new image assignment has 
            if (image.Width < Width - 20 && image.Height < PageGrid.RowDefinitions[1].ActualHeight)
                ImagePreview.Stretch = Stretch.None;
            else
                ImagePreview.Stretch = Stretch.Uniform;
        }
        #endregion


        private void PasteImageFromClipboard()
        {
            ImageSource image;
            
            try
            {
                image = ClipboardHelper.GetImageSource();
            }
            catch (Exception e)
            {
                StatusBar.ShowStatusError("Image retrieval from clipboard failed: " + e.Message);
                return;
            }

            if (image == null)
            {
                var data = System.Windows.Forms.Clipboard.GetDataObject();
                var formats = data?.GetFormats();
                string formatStrings = null;
                if (formats != null && formats.Length > 0)
                    formatStrings = "Formats: " + string.Join(",", formats);

                mmApp.Log($"Couldn't retrieve image from Clipboard. {formatStrings}",logLevel: LogLevels.Warning);
                StatusBar.ShowStatusError("Image retrieval from clipboard failed.");
                return;
            }

            ImagePreview.Source = image;

            SetImagePreview(image);

            Image = null;
            IsMemoryImage = true;

            ImageWidth = (int) image.Width;
            ImageHeight = (int) image.Height;

            StatusBar.ShowStatusSuccess("Image pasted from clipboard.");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="file"></param>
        public void Base64EncodeImage(string file)
        {
            try
            {
                if (!PasteAsBase64Content ||
                    Image == null ||
                    Image.StartsWith("data:image/") ||
                    file == "Untitled")
                    return;

                file = file.Replace("file:///", "");

                var fullPath = file;
                if (!File.Exists(file))
                    fullPath = Path.Combine(Path.GetDirectoryName(Editor.MarkdownDocument.Filename), file);

                if (File.Exists(fullPath))
                {
                    var bytes = File.ReadAllBytes(fullPath);
                    var bytestring = Convert.ToBase64String(bytes);
                    var mediaFormat = ImageUtils.GetImageMediaTypeFromFilename(fullPath);
                    Image = $"data:{mediaFormat};base64," + bytestring;
                }
            }
            catch (Exception ex)
            {
                StatusBar.ShowStatusError("Image base64 encoding failed: " + ex.GetBaseException().Message);
            }
        }

        public void Base64EncodeImage(Bitmap bmp)
        {
            try
            {
                using (var ms = new MemoryStream(10000))
                {
                    bmp.Save(ms, ImageFormat.Jpeg);
                    ms.Flush();
                    Image = $"data:image/jpeg;base64,{Convert.ToBase64String(ms.ToArray())}";
                }
            }
            catch (Exception ex)
            {
                StatusBar.ShowStatusError($"Image base64 encoding failed: {ex.GetBaseException().Message}");
            }
        }

        #region Image Operationz

        private void TextBox_ImageSizeChanged(object sender, RoutedEventArgs e)
        {
            var resizeMode = ResizeModes.ByWidth;
            if (sender == TextBoxImageHeight)
                resizeMode = ResizeModes.ByHeight;
            if (!IsImageFixedRatio)
                resizeMode = ResizeModes.DontKeepAspectRatio;


            // have to handle out of band or the binding hasn't updated yet
            Dispatcher.InvokeAsync(() =>
            {
                //var txtBox = sender as TextBox;
                //Debug.WriteLine(
                //    $"Image Size Changed {((TextBox) sender).Name} {ImageWidth} x {ImageHeight} {txtBox.Text}");
                ImageSizeChanged(resizeMode);

                Model.Configuration.Images.LastImageWidth = ImageWidth;
                Model.Configuration.Images.LastImageHeight = ImageHeight;
            }, DispatcherPriority.ApplicationIdle);
        }

        private void PasteImage_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            var image = ImagePreview.Source as BitmapSource;
            if (image == null)
                return;

            if (image.Width < Width - 20 && image.Height < PageGrid.RowDefinitions[1].ActualHeight)
                ImagePreview.Stretch = Stretch.None;
            else
                ImagePreview.Stretch = Stretch.Uniform;
        }


        /// <summary>
        /// Attempts to resolve the full image filename from the active image
        /// if the image is a file based image with a relative or physical
        /// path but not a URL based image.
        /// </summary>
        /// <returns></returns>
        public string GetFullImageFilename(string filename = null)
        {
            string imageFile = filename ?? Image;

            if (string.IsNullOrEmpty(imageFile))
                return null;

            try
            {
                if (!File.Exists(imageFile))
                    imageFile = Path.Combine(Path.GetDirectoryName(Editor.MarkdownDocument.Filename), imageFile);

                return File.Exists(imageFile) ? imageFile : null;
            }
            catch
            {
                mmApp.Log("Non-fatal error: Invalid image filename: " + imageFile);
                return null;
            }
        }

        #endregion

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(163,26): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(177,13): error CS0103: The name 'InitializeComponent' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(194,45): error CS0103: The name 'StatusText' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(194,57): error CS0103: The name 'StatusIcon' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(220,13): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(233,21): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(242,56): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(244,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(248,27): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(251,33): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(267,32): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(293,21): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(310,44): error CS0103: The name 'CheckPasteAsBase64Content' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(314,31): error CS0103: The name 'ButtonCancel' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(333,76): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(382,29): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(405,13): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(413,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(415,27): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(459,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(471,21): error CS0103: The name 'TextImageText' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(556,13): error CS0103: The name 'TextImageText' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(601,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(636,25): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(645,74): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(670,29): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(692,60): error CS0103: The name 'PageGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(693,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(695,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(727,13): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(796,27): error CS0103: The name 'TextBoxImageHeight' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(817,25): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(821,60): error CS0103: The name 'PageGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(822,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(824,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(9,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(163,26): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(177,13): error CS0103: The name 'InitializeComponent' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(194,45): error CS0103: The name 'StatusText' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(194,57): error CS0103: The name 'StatusIcon' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(220,13): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(233,21): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(242,56): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(244,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(248,27): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(251,33): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(267,32): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(293,21): error CS0103: The name 'TextImage' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(310,44): error CS0103: The name 'CheckPasteAsBase64Content' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(314,31): error CS0103: The name 'ButtonCancel' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(333,76): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(382,29): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(405,13): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(413,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(415,21): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(458,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(470,21): error CS0103: The name 'TextImageText' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(555,13): error CS0103: The name 'TextImageText' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(600,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(620,43): error CS0165: Use of unassigned local variable 'bmp',D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(634,25): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(643,74): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(668,29): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(690,60): error CS0103: The name 'PageGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(691,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(693,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(725,13): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(794,27): error CS0103: The name 'TextBoxImageHeight' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(815,25): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(819,60): error CS0103: The name 'PageGrid' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(820,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(822,17): error CS0103: The name 'ImagePreview' does not exist in the current context,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(9,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\Windows\PasteImageWindow.xaml.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Controls;
using System.Windows.Media;
using FontAwesome.WPF;
using MarkdownMonster.Windows;
using MarkdownMonster.Windows.PreviewBrowser;
using Westwind.Utilities;

namespace MarkdownMonster.AddIns
{
    /// <summary>
    /// Addin Base class that exposes core functionality to the addin.
    ///
    /// </summary>
    public abstract class MarkdownMonsterAddin : IMarkdownMonsterAddin
    {
        #region Addin Configuration
        /// <summary>
        /// Optional Id for this addin - use a recognizable Id
        /// </summary>
        public string Id { get; set; } = StringUtils.NewStringId();

        /// <summary>
        /// The display name of the Addin
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The application model which gives you access to Markdown Monster.
        /// Includes access to Configuration and the Main Window
        /// </summary>
        public AppModel Model { get; set; }

        /// <summary>
        /// Determines whether this addin is enabled
        /// </summary>
        public bool IsEnabled { get; set; } = true;

        /// <summary>
        /// List of menu items that are used to extend MM
        /// Menu items get attached to the Addin menu and fire
        /// when clicked.
        /// </summary>
        public List<AddInMenuItem> MenuItems { get; set;  }  = new List<AddInMenuItem>();

        #endregion

        #region Access Properties

        /// <summary>
        /// Returns an instance of the Active Editor instance. The editor contains
        /// editor behavior of the browser control as well as all interactions with
        /// the editor's event model and text selection interfaces.
        ///
        /// Contains an `AceEditor` property that references the underlying
        /// JavaScript editor wrapper instance.
        /// </summary>
        public MarkdownDocumentEditor ActiveEditor => Model.ActiveEditor;


        /// <summary>
        /// Returns the active Markdown document that's being edited. The document
        /// holds the actual markdown text and knows how to load, save and render
        /// the markdown contained within it.
        /// </summary>
        public MarkdownDocument ActiveDocument => Model.ActiveDocument;


        #endregion



        #region Event Handlers

        /// <summary>
        /// Allows addins to intercept the html used for the preview, to
        /// examine or further manipulate it, e.g. insert a style
        /// block in the head.
        /// </summary>
        /// <remarks>
        /// If multiple addins are hooked in to modify the preview html
        /// you may get unpredictable results.
        /// </remarks>
        public virtual string OnModifyPreviewHtml(string renderedHtml, string markdownHtml)
        {
            return renderedHtml;
        }

        /// <summary>
        /// Called when the Menu or Toolbar button is clicked
        /// </summary>
        /// <param name="sender">Menu item clicked</param>
        public virtual void OnExecute(object sender)
        {
        }

        /// <summary>
        /// Called when the configuration Toolbar drop down button is clicked
        /// </summary>
        /// <param name="sender">Menu Item clicked</param>
        public virtual void OnExecuteConfiguration(object sender)
        {

        }

        /// <summary>
        /// Called to determine whether the menu option should be enabled and execute
        /// </summary>
        /// <param name="sender"></param>
        /// <returns></returns>
        public virtual bool OnCanExecute(object sender)
        {
            return true;
        }

        /// <summary>
        /// Called when the application starts and after the AddinManager
        /// has initialized.
        ///
        /// Use this handler to add new menu items to the Addin Toolbar.
        /// </summary>
        /// <remarks>
        /// Fires very early in the load cycle and therefore has no access
        /// to the App Model or UI. If you require access to Model or UI
        /// override `OnWindowLoaded()` instead.
        /// </remarks>
        public virtual void OnApplicationStart()
        {

        }


        /// <summary>
        /// Fired when the application has Initialized the Model. This happens
        /// after OnApplicationStart() but before OnWindowLoaded() and allows
        /// you to access the Model before initial data binding of the Window
        /// occurs.
        /// </summary>
        /// <param name="model">Instance of the Markdown Monster Application Model</param>
        public virtual void OnModelLoaded(AppModel model)
        {
            Model = model;
        }

        /// <summary>
        /// Fired when the main application window has been loaded and the
        /// main Markdown Monster Application Model is available.
        /// Access the Window with mmApp.Model.Window.
        ///
        /// Use this method to ensure that Model and UI are available,
        /// often in combination with `OnApplicationStart()` and `GetMarkdownParser()`
        /// which fire before the Model or UI are active.
        /// </summary>
        public virtual void OnWindowLoaded()
        {

        }

        /// <summary>
        /// Called just before the application is shut down
        /// </summary>
        public virtual void OnApplicationShutdown()
        {

        }

        /// <summary>
        /// Called before a document is opened. Return false to
        /// keep the document from being opened
        /// </summary>
        /// <returns></returns>
        public virtual bool OnBeforeOpenDocument(string filename)
        {
            return true;
        }

        /// <summary>
        /// Called after a new document has been opened. If this is a new
        /// document the filename will be 'untitled'
        /// </summary>
        /// <param name="doc"></param>
        public virtual void  OnAfterOpenDocument(MarkdownDocument doc)
        {
        }

        /// <summary>
        /// Called before the document is saved. Return false to
        /// disallow saving the document
        /// </summary>
        /// <param name="doc"></param>
        /// <returns></returns>
        public virtual bool OnBeforeSaveDocument(MarkdownDocument doc)
        {
            return true;
        }


        /// <summary>
        /// Called after the document has been saved.
        /// </summary>
        /// <param name="doc"></param>
        public virtual void OnAfterSaveDocument(MarkdownDocument doc)
        {

        }

        /// <summary>
        /// An optional command string that is fired into addins
        ///
        /// You can override this method to capture commands that are not
        /// already handled by the editor.
        /// </summary>
        /// <remarks>
        ///
        /// </remarks>
        /// <param name="command">Command Name</param>
        /// <param name="parameter">Command parameter</param>
        public virtual void OnNotifyAddin(string command, object parameter)
        {

        }


        /// <summary>
        /// Optional editor command handler that can intercept editor commands
        /// like bold/italic that are fired if not handled previously by
        /// the default handlers.
        ///
        /// Allows adding custom handlers for additional markdown expansions you'd
        /// like to fire from custom buttons, or using AdditionalToolbarIcons.
        /// </summary>
        /// <param name="command">Name of the Markup command to handle (ie. something like `bold`, `italic`, `list`)</param>
        /// <param name="input">Selected text if any</param>
        /// <returns>Return the expanded or injected text. Return null to leave the input unchanged.</returns>
        public virtual string OnEditorCommand(string command, string input)
        {
            return null;
        }

        /// <summary>
        /// Called when an image is to be saved. By default MM saves images to
        /// disk. You can hook this method with your add in to take over the image
        /// save operation. Return true to indicate you handled the
        /// </summary>
        /// <param name="image">This parameter holds either a string filename or a Bitmap of the actual image to save</param>
        /// <returns>A Url to link to the image or null to indicate default processing should continue</returns>
        public virtual string OnSaveImage(object image)
        {
            return null;
        }

        /// <summary>
        /// Called whenever a new document is activated in the editor
        /// (when tabs change). Note on startup if multiple documents
        /// are open this method is called for each document.
        /// </summary>
        /// <param name="doc"></param>
        public virtual void OnDocumentActivated(MarkdownDocument doc)
        {
        }


        /// <summary>
        /// Called whenever the document is updated and the document's current
        /// text is updated. Note this may not be always 100% in sync of what's
        /// in the editor as the document is updated only when the user stops
        /// typing for around a second.
        /// </summary>
        public virtual void OnDocumentUpdated()
        {
        }

        /// <summary>
        /// Allows you to detect Preview Browser Link navigation
        /// and take over the navigation.
        /// </summary>
        /// <remarks>
        /// If multiple handlers have registered in multiple addins,
        /// the first one to handle navigation wins. Be conservative
        /// in returning true
        /// </remarks>
        /// <param name="url">The URL that was navigated in the preview</param>
        /// <param name="src">The actual href ``referenced in the URL without browser fixup which might be different than the URL
        /// ie. relative urls or custom monikers</param>
        /// <returns>true to specify you handled the navigation, false to let the default behavior run</returns>
        public virtual bool OnPreviewLinkNavigation(string url, string src)
        {
            return false;
        }

        /// <summary>
        /// If this addin wants to provide a custom Markdown Parser this method can
        /// be overriden to do it.
        /// </summary>
        /// <returns>IMarkdownParser instance or null. Passed the instance is used for parsing</returns>
        [Obsolete("Please use the GetMarkdownDownParser(bool usePragmaLines, bool force) overload.")]
        public virtual IMarkdownParser GetMarkdownParser()
        {
            return null;
        }

        /// <summary>
        /// If this addin wants to provide a custom Markdown Parser this method can
        /// be overriden to do it.
        /// </summary>
        /// <param name="usePragmaLines">If true, pragma line ids should be added into the document
        /// to support preview synchronization</param>
        /// <param name="force">Forces the parser to be reloaded - otherwise previously loaded instance can be used</param>
        /// <returns>IMarkdownParser instance or null. Passed the instance is used for parsing</returns>
        public virtual IMarkdownParser GetMarkdownParser(bool usePragmaLines, bool force)
        {
            // Existing parsers use the older method, so default to calling that.
#pragma warning disable CS0618 // Type or member is obsolete
            return GetMarkdownParser();
#pragma warning restore CS0618 // Type or member is obsolete

        }

        /// <summary>
        /// Allows returning a WPF control that implements IPreviewBrowser and
        /// that handles previewing the output from documents.
        ///
        /// This control should return an IPreviewBrowser interface implemented
        /// on a WPF UIControl (UserControl most likely).
        /// </summary>
        /// <returns></returns>
        public virtual IPreviewBrowser GetPreviewBrowserUserControl()
        {
            return null;
        }

        /// <summary>
        /// Called after the addin is initially installed. Use this
        /// method to install additional resources or add additional
        /// one time configuration.
        /// </summary>
        public virtual void OnInstall()
        {
        }


        /// <summary>
        /// Called after the addin has been uninstalled. Allows
        /// for additional cleanup.
        /// </summary>
        public virtual void OnUninstall()
        {
        }
        #endregion

        #region Helper Methods
        /// <summary>
        /// Retrieve an instance of the MarkdownEditor control from the
        /// active window. This instance wraps the editor and provides
        /// a number of methods for getting access to the editor document
        /// </summary>
        /// <returns></returns>
        public MarkdownDocumentEditor GetMarkdownEditor()
        {
            return Model.Window.GetActiveMarkdownEditor();
        }

        /// <summary>
        /// Returns the Markdown document instance which has access
        /// to the actual document that ends up being saved. This
        /// includes the content and the IsDirty flag. Note that
        /// content is updated only after save operations. If you need
        /// to update live content it's best to inject directly into
        /// the edtor using the GetSelectedText() and SetSelectedText().
        /// </summary>
        /// <returns></returns>
        public MarkdownDocument GetMarkdownDocument()
        {
            var editor =  Model.Window.GetActiveMarkdownEditor();
            return editor?.MarkdownDocument;
        }

        /// <summary>
        /// Returns the active live markdown text from the editor
        /// </summary>
        /// <returns></returns>
        public string GetMarkdown()
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            return editor?.GetMarkdown();
        }


        /// <summary>
        /// Sets all the text in the markdown editor
        /// </summary>
        /// <param name="markdownText"></param>
        public void SetMarkdown(string markdownText)
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            editor?.SetMarkdown(markdownText);
        }


        /// <summary>
        /// Gets the active selection from the editor
        /// </summary>
        /// <returns></returns>
        public string GetSelection()
        {
            return Model.ActiveEditor?.AceEditor.GetSelection() ?? string.Empty;
        }

        /// <summary>
        /// Sets the active selection from the editor
        /// </summary>
        /// <param name="text"></param>
        public void SetSelection(string text)
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            if (editor == null)
                return;

            if (!string.IsNullOrEmpty(text))
                editor.AceEditor.SetSelection(text);

            editor.WebBrowser.Focus();
            editor.AceEditor.SetFocus();

            editor.MarkdownDocument.CurrentText = editor.GetMarkdown();
            Model.Window.PreviewMarkdown(editor, true);
        }


        /// <summary>
        /// Brings the editor to focus
        /// </summary>
        public void SetEditorFocus()
        {
            Model.Window?.Activate();
            Model.ActiveEditor?.SetEditorFocus();
        }


        /// <summary>
        /// Refreshes the Html Preview Window if active
        /// </summary>
        /// <param name="keepScrollPosition"></param>
        public void RefreshPreview(bool keepScrollPosition=true)
        {
            Model.Window.PreviewMarkdownAsync(keepScrollPosition: keepScrollPosition);
        }

        /// <summary>
        /// Executes a predefined edit command (bold,italic,href etc.)
        /// against the editor.
        /// </summary>
        /// <param name="action">Name of the Editor action to perform</param>
        public void ExecuteEditCommand(string action)
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            editor?.ProcessEditorUpdateCommand(action);
        }


        /// <summary>
        /// Opens a tab with a given filename and selects it
        /// </summary>
        /// <param name="filename">File to open</param>
        /// <returns>The TabItem instance representing the opened tab</returns>
        public TabItem OpenTab(string filename)
        {
            return Model.Window.OpenTab(filename, rebindTabHeaders: true);
        }


        /// <summary>
        /// Closes a specific tab that you pass. You can look at
        /// the tab collection via Model.Window.TabControl.
        /// </summary>
        /// <param name="tab"></param>
        public void CloseTab(TabItem tab)
        {
            Model.Window.CloseTab(tab);
        }

        /// <summary>
        /// Closes the tab that contains the file specified by
        /// filename
        /// </summary>
        /// <param name="filename"></param>
        public void CloseTab(string filename)
        {
            Model.Window.CloseTab(filename);
        }


        /// <summary>
        /// Displays a status message on the main application's status bar
        /// </summary>
        /// <param name="message"></param>
        /// <param name="timeoutMs"></param>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        /// <param name="spin"></param>
        public void ShowStatus(string message = null, int timeoutMs = 0,
            FontAwesomeIcon icon = FontAwesomeIcon.None,
            Color color = default(Color),
            bool spin = false)
        {
            Model.Window.ShowStatus(message, timeoutMs, icon, color, spin);
        }

        /// <summary>
        /// Displays and error message on the status bar using common
        /// default values (red icon, standard timeout, warning icon)
        /// </summary>
        /// <param name="message"></param>
        /// <param name="timeout"></param>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        public void ShowStatusError(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.Warning,
            Color color = default(Color))
        {
            Model.Window.ShowStatusError(message,timeout,icon,color);
        }

        /// <summary>
        /// Lets you modify the status icon and color on the status bar.
        /// </summary>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        /// <param name="spin"></param>
        [Obsolete("Use ShowStatusError instead")]
        public void SetStatusIcon(FontAwesome.WPF.FontAwesomeIcon icon, Color color,bool spin = false)
        {
            Model.Window.SetStatusIcon(icon, color,spin);
        }
        #endregion

        #region UI Shell Operations




        /// <summary>
        /// Allows insertion of a menu item relative to another menu item by name or menu text
        /// </summary>
        /// <param name="mitem">The menu item to insert</param>
        /// <param name="menuItemNameToFind">Name of the main menuitem element to insert before or after - find in MainWindow.xaml or with Debug Tools</param>
        /// <param name="menuItemTextToFind">Text of the menuitem element to insert bfore or after (use if there's is no explicit Name for the item).
        /// Note: Menu text must include any mnemonics that might be used in the menu item's text
        /// </param>
        /// <param name="addMode">Determines where the item is to be inserted</param>
        public bool AddMenuItem(MenuItem mitem, string menuItemNameToFind = null,
                                string menuItemTextToFind = null,
                                AddMenuItemModes addMode = AddMenuItemModes.AddAfter)
        {
            // find the menu item to in
            var menuItem = GetChildMenuItem(Model.Window.MainMenu, menuItemNameToFind, menuItemTextToFind);
            if (menuItem == null)
            {
                mmApp.Log("Couldn't add menu item: " + mitem.Header + " " +   addMode + " " + menuItemNameToFind ?? menuItemTextToFind, logLevel: LogLevels.Warning);
                return false;
            }

            ItemsControl parent = menuItem.Parent as ItemsControl;
            if (parent == null)
            {
                mmApp.Log("Couldn't add menu item: " + mitem.Header + " " +   addMode + " " + menuItemNameToFind ?? menuItemTextToFind, logLevel: LogLevels.Warning);
                return false;
            }

            int idx;
            if (addMode == AddMenuItemModes.AddBefore)
            {
                idx = parent.Items.IndexOf(menuItem);
            }
            else if (addMode == AddMenuItemModes.Replace)
            {
                idx = parent.Items.IndexOf(menuItem);
                parent.Items[idx] = mitem;
                return true;
            }
            else
            {
                idx = parent.Items.IndexOf(menuItem);
                idx++;

            }
            parent.Items.Insert(idx, mitem);

            return true;
        }


        // TODO: remove in the future
        /// <summary>
        /// Obsolete - Adds a menu item relative to an existing menu item.
        /// </summary>
        /// <param name="mitem"></param>
        /// <param name="menuItemNameToFind"></param>
        /// <param name="menuItemTextToFind"></param>
        /// <param name="mode">0 - AddAfter, 1 - AddBefore, 2 - Replace</param>
        /// <returns></returns>
        [Obsolete("Please use the alternate version of this method that uses the enum parameter.")]
        public bool AddMenuItem(MenuItem mitem, string menuItemNameToFind = null,
            string menuItemTextToFind = null,
            int mode = 0)
        {
            var addMode = AddMenuItemModes.AddAfter;
            if (mode == 1)
                addMode = AddMenuItemModes.AddBefore;
            if (mode == 2)
                addMode = AddMenuItemModes.Replace;

            return AddMenuItem(mitem, menuItemNameToFind, menuItemTextToFind, addMode);
        }

        /// <summary>
        /// Use this to find a menu item either by control name or by
        /// caption text.
        ///
        /// Pass either menuItemName OR menuItemText parameter. If both are
        /// passed menuItemName takes precendence.
        /// </summary>
        /// <param name="mitem"></param>
        /// <param name="menuItemName"></param>
        /// <param name="menuItemText"></param>
        /// <returns></returns>
        public MenuItem GetChildMenuItem(ItemsControl mitem, string menuItemName = null, string menuItemText = null)
        {
            foreach (var control in mitem.Items)
            {
                var menuItem = control as MenuItem;
                if (menuItem == null)
                    continue;

                if (!string.IsNullOrEmpty(menuItemName) && menuItemName == menuItem.Name)
                    return menuItem;

                if (!string.IsNullOrEmpty(menuItemText))
                {
                    var header = menuItem.Header?.ToString();
                    var cleanHeader = header?.Replace("_", "");
                    if (!string.IsNullOrEmpty(menuItemText) &&
                        (menuItemName == header || menuItemName == cleanHeader))
                        return menuItem;
                }

                menuItem = GetChildMenuItem(menuItem, menuItemName, menuItemText);
                if (menuItem != null)
                    return menuItem;
            }

            return null;
        }
        #endregion

        /// <summary>
        /// Customized to display the Addin Id or Name
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return Id ?? Name ?? "no name";
        }



    }

    public enum AddMenuItemModes
    {
        AddAfter = 0,
        AddBefore = 1,
        Replace = 2
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Controls;
using System.Windows.Media;
using FontAwesome.WPF;
using MarkdownMonster.Windows;
using MarkdownMonster.Windows.PreviewBrowser;
using Westwind.Utilities;

namespace MarkdownMonster.AddIns
{
    /// <summary>
    /// Addin Base class that exposes core functionality to the addin.
    ///
    /// </summary>
    public abstract class MarkdownMonsterAddin : IMarkdownMonsterAddin
    {
        #region Addin Configuration
        /// <summary>
        /// Optional Id for this addin - use a recognizable Id
        /// </summary>
        public string Id { get; set; } = StringUtils.NewStringId();

        /// <summary>
        /// The display name of the Addin
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The application model which gives you access to Markdown Monster.
        /// Includes access to Configuration and the Main Window
        /// </summary>
        public AppModel Model { get; set; }

        /// <summary>
        /// Determines whether this addin is enabled
        /// </summary>
        public bool IsEnabled { get; set; } = true;

        /// <summary>
        /// List of menu items that are used to extend MM
        /// Menu items get attached to the Addin menu and fire
        /// when clicked.
        /// </summary>
        public List<AddInMenuItem> MenuItems { get; set;  }  = new List<AddInMenuItem>();

        #endregion

        #region Access Properties

        /// <summary>
        /// Returns an instance of the Active Editor instance. The editor contains
        /// editor behavior of the browser control as well as all interactions with
        /// the editor's event model and text selection interfaces.
        ///
        /// Contains an `AceEditor` property that references the underlying
        /// JavaScript editor wrapper instance.
        /// </summary>
        public MarkdownDocumentEditor ActiveEditor => Model.ActiveEditor;


        /// <summary>
        /// Returns the active Markdown document that's being edited. The document
        /// holds the actual markdown text and knows how to load, save and render
        /// the markdown contained within it.
        /// </summary>
        public MarkdownDocument ActiveDocument => Model.ActiveDocument;


        #endregion



        #region Event Handlers

        /// <summary>
        /// Allows addins to intercept the html used for the preview, to
        /// examine or further manipulate it, e.g. insert a style
        /// block in the head.
        /// </summary>
        /// <remarks>
        /// If multiple addins are hooked in to modify the preview html
        /// you may get unpredictable results.
        /// </remarks>
        public virtual string OnModifyPreviewHtml(string renderedHtml, string markdownHtml)
        {
            return renderedHtml;
        }

        /// <summary>
        /// Called when the Menu or Toolbar button is clicked
        /// </summary>
        /// <param name="sender">Menu item clicked</param>
        public virtual void OnExecute(object sender)
        {
        }

        /// <summary>
        /// Called when the configuration Toolbar drop down button is clicked
        /// </summary>
        /// <param name="sender">Menu Item clicked</param>
        public virtual void OnExecuteConfiguration(object sender)
        {

        }

        /// <summary>
        /// Called to determine whether the menu option should be enabled and execute
        /// </summary>
        /// <param name="sender"></param>
        /// <returns></returns>
        public virtual bool OnCanExecute(object sender)
        {
            return true;
        }

        /// <summary>
        /// Called when the application starts and after the AddinManager
        /// has initialized.
        ///
        /// Use this handler to add new menu items to the Addin Toolbar.
        /// </summary>
        /// <remarks>
        /// Fires very early in the load cycle and therefore has no access
        /// to the App Model or UI. If you require access to Model or UI
        /// override `OnWindowLoaded()` instead.
        /// </remarks>
        public virtual void OnApplicationStart()
        {

        }


        /// <summary>
        /// Fired when the application has Initialized the Model. This happens
        /// after OnApplicationStart() but before OnWindowLoaded() and allows
        /// you to access the Model before initial data binding of the Window
        /// occurs.
        /// </summary>
        /// <param name="model">Instance of the Markdown Monster Application Model</param>
        public virtual void OnModelLoaded(AppModel model)
        {
            Model = model;
        }

        /// <summary>
        /// Fired when the main application window has been loaded and the
        /// main Markdown Monster Application Model is available.
        /// Access the Window with mmApp.Model.Window.
        ///
        /// Use this method to ensure that Model and UI are available,
        /// often in combination with `OnApplicationStart()` and `GetMarkdownParser()`
        /// which fire before the Model or UI are active.
        /// </summary>
        public virtual void OnWindowLoaded()
        {

        }

        /// <summary>
        /// Called just before the application is shut down
        /// </summary>
        public virtual void OnApplicationShutdown()
        {

        }

        /// <summary>
        /// Called before a document is opened. Return false to
        /// keep the document from being opened
        /// </summary>
        /// <returns></returns>
        public virtual bool OnBeforeOpenDocument(string filename)
        {
            return true;
        }

        /// <summary>
        /// Called after a new document has been opened. If this is a new
        /// document the filename will be 'untitled'
        /// </summary>
        /// <param name="doc"></param>
        public virtual void  OnAfterOpenDocument(MarkdownDocument doc)
        {
        }

        /// <summary>
        /// Called before the document is saved. Return false to
        /// disallow saving the document
        /// </summary>
        /// <param name="doc"></param>
        /// <returns></returns>
        public virtual bool OnBeforeSaveDocument(MarkdownDocument doc)
        {
            return true;
        }


        /// <summary>
        /// Called after the document has been saved.
        /// </summary>
        /// <param name="doc"></param>
        public virtual void OnAfterSaveDocument(MarkdownDocument doc)
        {

        }

        /// <summary>
        /// An optional command string that is fired into addins
        ///
        /// You can override this method to capture commands that are not
        /// already handled by the editor.
        /// </summary>
        /// <remarks>
        ///
        /// </remarks>
        /// <param name="command">Command Name</param>
        /// <param name="parameter">Command parameter</param>
        public virtual void OnNotifyAddin(string command, object parameter)
        {

        }


        /// <summary>
        /// Optional editor command handler that can intercept editor commands
        /// like bold/italic that are fired if not handled previously by
        /// the default handlers.
        ///
        /// Allows adding custom handlers for additional markdown expansions you'd
        /// like to fire from custom buttons, or using AdditionalToolbarIcons.
        /// </summary>
        /// <param name="command">Name of the Markup command to handle (ie. something like `bold`, `italic`, `list`)</param>
        /// <param name="input">Selected text if any</param>
        /// <returns>Return the expanded or injected text. Return null to leave the input unchanged.</returns>
        public virtual string OnEditorCommand(string command, string input)
        {
            return null;
        }

        /// <summary>
        /// Called when an image is to be saved. By default MM saves images to
        /// disk. You can hook this method with your add in to take over the image
        /// save operation. Return true to indicate you handled the
        /// </summary>
        /// <param name="image">This parameter holds either a string filename or a Bitmap of the actual image to save</param>
        /// <returns>A Url to link to the image or null to indicate default processing should continue</returns>
        public virtual string OnSaveImage(object image)
        {
            return null;
        }

        /// <summary>
        /// Called whenever a new document is activated in the editor
        /// (when tabs change). Note on startup if multiple documents
        /// are open this method is called for each document.
        /// </summary>
        /// <param name="doc"></param>
        public virtual void OnDocumentActivated(MarkdownDocument doc)
        {
        }


        /// <summary>
        /// Called whenever the document is updated and the document's current
        /// text is updated. Note this may not be always 100% in sync of what's
        /// in the editor as the document is updated only when the user stops
        /// typing for around a second.
        /// </summary>
        public virtual void OnDocumentUpdated()
        {
        }

        /// <summary>
        /// Allows you to detect Preview Browser Link navigation
        /// and take over the navigation.
        /// </summary>
        /// <remarks>
        /// If multiple handlers have registered in multiple addins,
        /// the first one to handle navigation wins. Be conservative
        /// in returning true
        /// </remarks>
        /// <param name="url">The URL that was navigated in the preview</param>
        /// <param name="src">The actual href ``referenced in the URL without browser fixup which might be different than the URL
        /// ie. relative urls or custom monikers</param>
        /// <returns>true to specify you handled the navigation, false to let the default behavior run</returns>
        public virtual bool OnPreviewLinkNavigation(string url, string src)
        {
            return false;
        }

        /// <summary>
        /// If this addin wants to provide a custom Markdown Parser this method can
        /// be overriden to do it.
        /// </summary>
        /// <returns>IMarkdownParser instance or null. Passed the instance is used for parsing</returns>
        [Obsolete("Please use the GetMarkdownDownParser(bool usePragmaLines, bool force) overload.")]
        public virtual IMarkdownParser GetMarkdownParser()
        {
            return null;
        }

        /// <summary>
        /// If this addin wants to provide a custom Markdown Parser this method can
        /// be overriden to do it.
        /// </summary>
        /// <param name="usePragmaLines">If true, pragma line ids should be added into the document
        /// to support preview synchronization</param>
        /// <param name="force">Forces the parser to be reloaded - otherwise previously loaded instance can be used</param>
        /// <returns>IMarkdownParser instance or null. Passed the instance is used for parsing</returns>
        public virtual IMarkdownParser GetMarkdownParser(bool usePragmaLines, bool force)
        {
            // Existing parsers use the older method, so default to calling that.
#pragma warning disable CS0618 // Type or member is obsolete
            return GetMarkdownParser();
#pragma warning restore CS0618 // Type or member is obsolete

        }

        /// <summary>
        /// Allows returning a WPF control that implements IPreviewBrowser and
        /// that handles previewing the output from documents.
        ///
        /// This control should return an IPreviewBrowser interface implemented
        /// on a WPF UIControl (UserControl most likely).
        /// </summary>
        /// <returns></returns>
        public virtual IPreviewBrowser GetPreviewBrowserUserControl()
        {
            return null;
        }

        /// <summary>
        /// Called after the addin is initially installed. Use this
        /// method to install additional resources or add additional
        /// one time configuration.
        /// </summary>
        public virtual void OnInstall()
        {
        }


        /// <summary>
        /// Called after the addin has been uninstalled. Allows
        /// for additional cleanup.
        /// </summary>
        public virtual void OnUninstall()
        {
        }
        #endregion

        #region Helper Methods
        /// <summary>
        /// Retrieve an instance of the MarkdownEditor control from the
        /// active window. This instance wraps the editor and provides
        /// a number of methods for getting access to the editor document
        /// </summary>
        /// <returns></returns>
        public MarkdownDocumentEditor GetMarkdownEditor()
        {
            return Model.Window.GetActiveMarkdownEditor();
        }

        /// <summary>
        /// Returns the Markdown document instance which has access
        /// to the actual document that ends up being saved. This
        /// includes the content and the IsDirty flag. Note that
        /// content is updated only after save operations. If you need
        /// to update live content it's best to inject directly into
        /// the edtor using the GetSelectedText() and SetSelectedText().
        /// </summary>
        /// <returns></returns>
        public MarkdownDocument GetMarkdownDocument()
        {
            var editor =  Model.Window.GetActiveMarkdownEditor();
            return editor?.MarkdownDocument;
        }

        /// <summary>
        /// Returns the active live markdown text from the editor
        /// </summary>
        /// <returns></returns>
        public string GetMarkdown()
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            return editor?.GetMarkdown();
        }


        /// <summary>
        /// Sets all the text in the markdown editor
        /// </summary>
        /// <param name="markdownText"></param>
        public void SetMarkdown(string markdownText)
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            editor?.SetMarkdown(markdownText);
        }


        /// <summary>
        /// Gets the active selection from the editor
        /// </summary>
        /// <returns></returns>
        public string GetSelection()
        {
            return Model.ActiveEditor?.AceEditor.GetSelection() ?? string.Empty;
        }

        /// <summary>
        /// Sets the active selection from the editor
        /// </summary>
        /// <param name="text"></param>
        public void SetSelection(string text)
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            if (editor == null)
                return;

            if (!string.IsNullOrEmpty(text))
                editor.AceEditor.SetSelection(text);

            editor.WebBrowser.Focus();
            editor.AceEditor.SetFocus();

            editor.MarkdownDocument.CurrentText = editor.GetMarkdown();
            Model.Window.PreviewMarkdown(editor, true);
        }


        /// <summary>
        /// Brings the editor to focus
        /// </summary>
        public void SetEditorFocus()
        {
            Model.Window?.Activate();
            Model.ActiveEditor?.SetEditorFocus();
        }


        /// <summary>
        /// Refreshes the Html Preview Window if active
        /// </summary>
        /// <param name="keepScrollPosition"></param>
        public void RefreshPreview(bool keepScrollPosition=true)
        {
            Model.Window.PreviewMarkdownAsync(keepScrollPosition: keepScrollPosition);
        }

        /// <summary>
        /// Executes a predefined edit command (bold,italic,href etc.)
        /// against the editor.
        /// </summary>
        /// <param name="action">Name of the Editor action to perform</param>
        public void ExecuteEditCommand(string action)
        {
            var editor = Model.Window.GetActiveMarkdownEditor();
            editor?.ProcessEditorUpdateCommand(action);
        }


        /// <summary>
        /// Opens a tab with a given filename and selects it
        /// </summary>
        /// <param name="filename">File to open</param>
        /// <returns>The TabItem instance representing the opened tab</returns>
        public TabItem OpenTab(string filename)
        {
            return Model.Window.OpenTab(filename, rebindTabHeaders: true);
        }


        /// <summary>
        /// Closes a specific tab that you pass. You can look at
        /// the tab collection via Model.Window.TabControl.
        /// </summary>
        /// <param name="tab"></param>
        public void CloseTab(TabItem tab)
        {
            Model.Window.CloseTab(tab);
        }

        /// <summary>
        /// Closes the tab that contains the file specified by
        /// filename
        /// </summary>
        /// <param name="filename"></param>
        public void CloseTab(string filename)
        {
            Model.Window.CloseTab(filename);
        }


        /// <summary>
        /// Displays a status message on the main application's status bar
        /// </summary>
        /// <param name="message"></param>
        /// <param name="timeoutMs"></param>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        /// <param name="spin"></param>
        public void ShowStatus(string message = null, int timeoutMs = 0,
            FontAwesomeIcon icon = FontAwesomeIcon.None,
            Color color = default(Color),
            bool spin = false)
        {
            Model.Window.ShowStatus(message, timeoutMs, icon, color, spin);
        }

        /// <summary>
        /// Displays and error message on the status bar using common
        /// default values (red icon, standard timeout, warning icon)
        /// </summary>
        /// <param name="message"></param>
        /// <param name="timeout"></param>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        public void ShowStatusError(string message, int timeout = -1,
            FontAwesomeIcon icon = FontAwesomeIcon.Warning,
            Color color = default(Color))
        {
            Model.Window.ShowStatusError(message,timeout,icon,color);
        }

        /// <summary>
        /// Lets you modify the status icon and color on the status bar.
        /// </summary>
        /// <param name="icon"></param>
        /// <param name="color"></param>
        /// <param name="spin"></param>
        [Obsolete("Use ShowStatusError instead")]
        public void SetStatusIcon(FontAwesome.WPF.FontAwesomeIcon icon, Color color,bool spin = false)
        {
            Model.Window.SetStatusIcon(icon, color,spin);
        }
        #endregion

        #region UI Shell Operations




        /// <summary>
        /// Allows insertion of a menu item relative to another menu item by name or menu text
        /// </summary>
        /// <param name="mitem">The menu item to insert</param>
        /// <param name="menuItemNameToFind">Name of the main menuitem element to insert before or after - find in MainWindow.xaml or with Debug Tools</param>
        /// <param name="menuItemTextToFind">Text of the menuitem element to insert bfore or after (use if there's is no explicit Name for the item).
        /// Note: Menu text must include any mnemonics that might be used in the menu item's text
        /// </param>
        /// <param name="addMode">Determines where the item is to be inserted</param>
        public bool AddMenuItem(MenuItem mitem, string menuItemNameToFind = null,
                                string menuItemTextToFind = null,
                                AddMenuItemModes addMode = AddMenuItemModes.AddAfter)
        {
            // find the menu item to in
            var menuItem = GetChildMenuItem(Model.Window.MainMenu, menuItemNameToFind, menuItemTextToFind);
            if (menuItem == null)
            {
                mmApp.Log("Couldn't add menu item: " + mitem.Header + " " +   addMode + " " + menuItemNameToFind ?? menuItemTextToFind, logLevel: LogLevels.Warning);
                return false;
            }

            ItemsControl parent = menuItem.Parent as ItemsControl;
            if (parent == null)
            {
                mmApp.Log("Couldn't add menu item: " + mitem.Header + " " +   addMode + " " + menuItemNameToFind ?? menuItemTextToFind, logLevel: LogLevels.Warning);
                return false;
            }

            int idx;
            if (addMode == AddMenuItemModes.AddBefore)
            {
                idx = parent.Items.IndexOf(menuItem);
            }
            else if (addMode == AddMenuItemModes.Replace)
            {
                idx = parent.Items.IndexOf(menuItem);
                parent.Items[idx] = mitem;
                return true;
            }
            else
            {
                idx = parent.Items.IndexOf(menuItem);
                idx++;

            }
            parent.Items.Insert(idx, mitem);

            return true;
        }


        // TODO: remove in the future
        /// <summary>
        /// Obsolete - Adds a menu item relative to an existing menu item.
        /// </summary>
        /// <param name="mitem"></param>
        /// <param name="menuItemNameToFind"></param>
        /// <param name="menuItemTextToFind"></param>
        /// <param name="mode">0 - AddAfter, 1 - AddBefore, 2 - Replace</param>
        /// <returns></returns>
        [Obsolete("Please use the alternate version of this method that uses the enum parameter.")]
        public bool AddMenuItem(MenuItem mitem, string menuItemNameToFind = null,
            string menuItemTextToFind = null,
            int mode = 0)
        {
            var addMode = AddMenuItemModes.AddAfter;
            if (mode == 1)
                addMode = AddMenuItemModes.AddBefore;
            if (mode == 2)
                addMode = AddMenuItemModes.Replace;

            return AddMenuItem(mitem, menuItemNameToFind, menuItemTextToFind, addMode);
        }

        /// <summary>
        /// Use this to find a menu item either by control name or by
        /// caption text.
        ///
        /// Pass either menuItemName OR menuItemText parameter. If both are
        /// passed menuItemName takes precendence.
        /// </summary>
        /// <param name="mitem"></param>
        /// <param name="menuItemName"></param>
        /// <param name="menuItemText"></param>
        /// <returns></returns>
        public MenuItem GetChildMenuItem(ItemsControl mitem, string menuItemName = null, string menuItemText = null)
        {
            foreach (var control in mitem.Items)
            {
                if (menuItem == null)
                    continue;

                if (!string.IsNullOrEmpty(menuItemName) && menuItemName == menuItem.Name)
                    return menuItem;

                if (!string.IsNullOrEmpty(menuItemText))
                {
                    var header = menuItem.Header?.ToString();
                    var cleanHeader = header?.Replace("_", "");
                    if (!string.IsNullOrEmpty(menuItemText) &&
                        (menuItemName == header || menuItemName == cleanHeader))
                        return menuItem;
                }

                menuItem = GetChildMenuItem(menuItem, menuItemName, menuItemText);

                if (control is MenuItem menuItem)
                    return menuItem;
            }

            return null;
        }
        #endregion

        /// <summary>
        /// Customized to display the Addin Id or Name
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return Id ?? Name ?? "no name";
        }



    }

    public enum AddMenuItemModes
    {
        AddAfter = 0,
        AddBefore = 1,
        Replace = 2
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(582,58): error CS1061: 'MainWindow' does not contain a definition for 'MainMenu' and no accessible extension method 'MainMenu' accepting a first argument of type 'MainWindow' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(27,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(31,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(582,58): error CS1061: 'MainWindow' does not contain a definition for 'MainMenu' and no accessible extension method 'MainMenu' accepting a first argument of type 'MainWindow' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(657,21): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(660,76): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(661,28): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(665,34): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(669,32): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(672,17): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(672,45): error CS0841: Cannot use local variable 'menuItem' before it is declared,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(27,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\MarkdownMonster\_Classes\AddInInterfaces\MarkdownMonsterAddin.cs(31,1): hidden CS8019: Unnecessary using directive.
######################################################################


