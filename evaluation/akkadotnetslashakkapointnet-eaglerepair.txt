Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Akka.Remote.Tests(net471)
    #1 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AccrualFailureDetectorSpec.cs, Line: 307, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #2 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AckedDeliverySpec.cs, Line: 346, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AckedDeliverySpec.cs, Line: 349, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AckedDeliverySpec.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #5 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AckedDeliverySpec.cs, Line: 353, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #6 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AckedDeliverySpec.cs, Line: 363, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #7 Path: D:\a\1\s\src\core\Akka.Remote.Tests\AckedDeliverySpec.cs, Line: 367, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #8 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Serialization\MiscMessageSerializerSpec.cs, Line: 364, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #9 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\AkkaProtocolStressTest.cs, Line: 121, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\GenericTransportSpec.cs, Line: 140, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\GenericTransportSpec.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\GenericTransportSpec.cs, Line: 187, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\GenericTransportSpec.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\GenericTransportSpec.cs, Line: 36, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #15 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\GenericTransportSpec.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\TestTransportSpec.cs, Line: 134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\TestTransportSpec.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\src\core\Akka.Remote.Tests\Transport\TestTransportSpec.cs, Line: 191, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\src\core\Akka.Remote.Tests\UntrustedSpec.cs, Line: 235, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.TestKit
    #20 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\DeadLettersFilter.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\DeadLettersFilter.cs, Line: 45, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\DebugFilter.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\ErrorFilter.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\EventFilterApplier.cs, Line: 299, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\EventFilterApplier.cs, Line: 303, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\EventFilterApplier.cs, Line: 307, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\EventFilterApplier.cs, Line: 362, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\EventFilterApplier.cs, Line: 366, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\EventFilterApplier.cs, Line: 370, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\InfoFilter.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\Internal\WarningFilter.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\TestEventListener.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #33 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\TestEventListener.cs, Line: 33, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #34 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\TestEventListener.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #35 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\TestEventListener.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #36 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\TestEventListener.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #37 Path: D:\a\1\s\src\core\Akka.TestKit\EventFilter\TestEventListener.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #38 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActor.cs, Line: 43, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActor.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActor.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActor.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActor.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActorRef.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActorRef.cs, Line: 183, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\src\core\Akka.TestKit\Internal\InternalTestActorRef.cs, Line: 189, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\src\core\Akka.TestKit\TestKitBase_Expect.cs, Line: 179, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #47 Path: D:\a\1\s\src\core\Akka.TestKit\TestKitBase_Expect.cs, Line: 319, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\src\core\Akka.TestKit\TestKitBase_Expect.cs, Line: 380, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: D:\a\1\s\src\core\Akka.TestKit\TestKitBase_Receive.cs, Line: 308, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Tests(net471)
    #50 Path: D:\a\1\s\src\core\Akka.Tests\Actor\ActorRefSpec.cs, Line: 534, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #51 Path: D:\a\1\s\src\core\Akka.Tests\Actor\ActorSelectionSpec.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\src\core\Akka.Tests\Actor\ActorSelectionSpec.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\src\core\Akka.Tests\Actor\DeathWatchSpec.cs, Line: 403, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\src\core\Akka.Tests\Actor\RemotePathParsingSpec.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #55 Path: D:\a\1\s\src\core\Akka.Tests\Actor\Scheduler\TaskBasedScheduler_ActionScheduler_Schedule_Tests.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #56 Path: D:\a\1\s\src\core\Akka.Tests\Actor\Scheduler\TaskBasedScheduler_TellScheduler_Schedule_Tests.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #57 Path: D:\a\1\s\src\core\Akka.Tests\IO\TestUtils.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\src\core\Akka.Tests\IO\TestUtils.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\src\core\Akka.Tests\IO\UdpConnectedIntegrationSpec.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\src\core\Akka.Tests\IO\UdpConnectedIntegrationSpec.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\src\core\Akka.Tests\Routing\ConfiguredLocalRoutingSpec.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\src\core\Akka.Tests\Routing\ConsistentHashingRouterSpec.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #63 Path: D:\a\1\s\src\core\Akka.Tests\Serialization\SerializationSpec.cs, Line: 66, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #64 Path: D:\a\1\s\src\core\Akka.Tests\TestUtils\Supervisor.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #65 Path: D:\a\1\s\src\core\Akka.Tests\TestUtils\Supervisor.cs, Line: 40, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Remote
    #66 Path: D:\a\1\s\src\core\Akka.Remote\Endpoint.cs, Line: 1313, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #67 Path: D:\a\1\s\src\core\Akka.Remote\Endpoint.cs, Line: 1450, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #68 Path: D:\a\1\s\src\core\Akka.Remote\Endpoint.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #69 Path: D:\a\1\s\src\core\Akka.Remote\Endpoint.cs, Line: 1902, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #70 Path: D:\a\1\s\src\core\Akka.Remote\EndpointManager.cs, Line: 188, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #71 Path: D:\a\1\s\src\core\Akka.Remote\RemoteActorRefProvider.cs, Line: 793, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\src\core\Akka.Remote\RemoteSystemDaemon.cs, Line: 126, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #73 Path: D:\a\1\s\src\core\Akka.Remote\RemoteSystemDaemon.cs, Line: 177, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #74 Path: D:\a\1\s\src\core\Akka.Remote\RemoteWatcher.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #75 Path: D:\a\1\s\src\core\Akka.Remote\RemoteWatcher.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #76 Path: D:\a\1\s\src\core\Akka.Remote\RemoteWatcher.cs, Line: 435, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #77 Path: D:\a\1\s\src\core\Akka.Remote\RemoteWatcher.cs, Line: 463, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #78 Path: D:\a\1\s\src\core\Akka.Remote\RemoteWatcher.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #79 Path: D:\a\1\s\src\core\Akka.Remote\RemoteWatcher.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #80 Path: D:\a\1\s\src\core\Akka.Remote\RemotingLifecycleEvent.cs, Line: 199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: D:\a\1\s\src\core\Akka.Remote\RemotingLifecycleEvent.cs, Line: 237, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #82 Path: D:\a\1\s\src\core\Akka.Remote\RemotingLifecycleEvent.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #83 Path: D:\a\1\s\src\core\Akka.Remote\RemotingLifecycleEvent.cs, Line: 388, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #84 Path: D:\a\1\s\src\core\Akka.Remote\RemotingLifecycleEvent.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #85 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\PrimitiveSerializers.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\PrimitiveSerializers.cs, Line: 34, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #87 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\PrimitiveSerializers.cs, Line: 35, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #88 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\ProtobufSerializer.cs, Line: 39, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #89 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 42, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #90 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 43, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #91 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 45, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #92 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 47, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #93 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 48, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #94 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #95 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 50, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #96 Path: D:\a\1\s\src\core\Akka.Remote\Serialization\SystemMessageSerializer.cs, Line: 51, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #97 Path: D:\a\1\s\src\core\Akka.Remote\Transport\AkkaPduCodec.cs, Line: 487, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #98 Path: D:\a\1\s\src\core\Akka.Remote\Transport\AkkaProtocolTransport.cs, Line: 133, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #99 Path: D:\a\1\s\src\core\Akka.Remote\Transport\AkkaProtocolTransport.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #100 Path: D:\a\1\s\src\core\Akka.Remote\Transport\DotNetty\AkkaLoggingHandler.cs, Line: 138, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #101 Path: D:\a\1\s\src\core\Akka.Remote\Transport\DotNetty\AkkaLoggingHandler.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #102 Path: D:\a\1\s\src\core\Akka.Remote\Transport\ThrottleTransportAdapter.cs, Line: 546, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\src\core\Akka.Remote\Transport\ThrottleTransportAdapter.cs, Line: 98, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\src\core\Akka.Remote\Transport\TransportAdapters.cs, Line: 154, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\src\core\Akka.Remote\Transport\TransportAdapters.cs, Line: 175, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka
    #106 Path: D:\a\1\s\src\core\Akka\Actor\ActorBase.cs, Line: 227, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #107 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.Children.cs, Line: 268, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #108 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.DeathWatch.cs, Line: 238, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #109 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.DeathWatch.cs, Line: 247, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #110 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.DeathWatch.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #111 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.DeathWatch.cs, Line: 276, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #112 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.DeathWatch.cs, Line: 342, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\src\core\Akka\Actor\ActorCell.FaultHandling.cs, Line: 433, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #114 Path: D:\a\1\s\src\core\Akka\Actor\ActorPath.cs, Line: 728, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #115 Path: D:\a\1\s\src\core\Akka\Actor\ActorPath.cs, Line: 731, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #116 Path: D:\a\1\s\src\core\Akka\Actor\ActorPath.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #117 Path: D:\a\1\s\src\core\Akka\Actor\ActorProducerPipeline.cs, Line: 306, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #118 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #119 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #120 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #121 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 210, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #122 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #123 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #125 Path: D:\a\1\s\src\core\Akka\Actor\BuiltInActors.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #126 Path: D:\a\1\s\src\core\Akka\Actor\Cancellation\Cancelable.cs, Line: 219, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #127 Path: D:\a\1\s\src\core\Akka\Actor\ChildrenContainer\Internal\ChildrenContainerBase.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #128 Path: D:\a\1\s\src\core\Akka\Actor\ChildrenContainer\Internal\ChildrenContainerBase.cs, Line: 199, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #129 Path: D:\a\1\s\src\core\Akka\Actor\Deployer.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #130 Path: D:\a\1\s\src\core\Akka\Actor\EmptyLocalActorRef.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #131 Path: D:\a\1\s\src\core\Akka\Actor\EmptyLocalActorRef.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\src\core\Akka\Actor\EmptyLocalActorRef.cs, Line: 111, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #133 Path: D:\a\1\s\src\core\Akka\Actor\EmptyLocalActorRef.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\src\core\Akka\Actor\EmptyLocalActorRef.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\src\core\Akka\Actor\EmptyLocalActorRef.cs, Line: 89, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #136 Path: D:\a\1\s\src\core\Akka\Actor\Futures.cs, Line: 200, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #137 Path: D:\a\1\s\src\core\Akka\Actor\LocalActorRef.cs, Line: 221, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\src\core\Akka\Actor\RepointableActorRef.cs, Line: 152, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #139 Path: D:\a\1\s\src\core\Akka\Actor\RepointableActorRef.cs, Line: 300, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #140 Path: D:\a\1\s\src\core\Akka\Actor\RepointableActorRef.cs, Line: 526, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #141 Path: D:\a\1\s\src\core\Akka\Actor\RootGuardianSupervisor.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #142 Path: D:\a\1\s\src\core\Akka\Actor\RootGuardianSupervisor.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #143 Path: D:\a\1\s\src\core\Akka\Actor\RootGuardianSupervisor.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #144 Path: D:\a\1\s\src\core\Akka\Actor\Stash\IActorStash.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #145 Path: D:\a\1\s\src\core\Akka\Actor\Stash\IActorStash.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #146 Path: D:\a\1\s\src\core\Akka\Actor\Stash\Internal\AbstractStash.cs, Line: 169, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #147 Path: D:\a\1\s\src\core\Akka\Actor\SupervisorStrategy.cs, Line: 147, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #148 Path: D:\a\1\s\src\core\Akka\Configuration\ConfigurationFactory.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #149 Path: D:\a\1\s\src\core\Akka\Configuration\ConfigurationFactory.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #150 Path: D:\a\1\s\src\core\Akka\Configuration\Hocon\HoconValue.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #151 Path: D:\a\1\s\src\core\Akka\Configuration\Hocon\HoconValue.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #152 Path: D:\a\1\s\src\core\Akka\Configuration\Hocon\HoconValue.cs, Line: 536, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #153 Path: D:\a\1\s\src\core\Akka\Dispatch\CachingConfig.cs, Line: 289, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #154 Path: D:\a\1\s\src\core\Akka\Dispatch\Dispatchers.cs, Line: 429, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #155 Path: D:\a\1\s\src\core\Akka\Dispatch\Dispatchers.cs, Line: 435, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #156 Path: D:\a\1\s\src\core\Akka\Dispatch\Mailbox.cs, Line: 468, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #157 Path: D:\a\1\s\src\core\Akka\Event\EventBusUnsubscriber.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #158 Path: D:\a\1\s\src\core\Akka\Event\EventBusUnsubscriber.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #159 Path: D:\a\1\s\src\core\Akka\Event\EventBusUnsubscriber.cs, Line: 65, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #160 Path: D:\a\1\s\src\core\Akka\Event\EventBusUnsubscriber.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #161 Path: D:\a\1\s\src\core\Akka\Event\EventBusUnsubscriber.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #162 Path: D:\a\1\s\src\core\Akka\Event\EventStream.cs, Line: 138, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #163 Path: D:\a\1\s\src\core\Akka\Event\EventStream.cs, Line: 156, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #164 Path: D:\a\1\s\src\core\Akka\Event\LoggingBus.cs, Line: 172, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #165 Path: D:\a\1\s\src\core\Akka\Event\LoggingBus.cs, Line: 193, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #166 Path: D:\a\1\s\src\core\Akka\Event\StandardOutLogger.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\src\core\Akka\Event\TraceLogger.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #168 Path: D:\a\1\s\src\core\Akka\Helios.Concurrency.DedicatedThreadPool.cs, Line: 352, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #169 Path: D:\a\1\s\src\core\Akka\Helios.Concurrency.DedicatedThreadPool.cs, Line: 50, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\src\core\Akka\Helios.Concurrency.DedicatedThreadPool.cs, Line: 52, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #171 Path: D:\a\1\s\src\core\Akka\IO\InetAddressDnsResolver.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #172 Path: D:\a\1\s\src\core\Akka\IO\SimpleDnsManager.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\src\core\Akka\IO\Tcp.cs, Line: 414, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\src\core\Akka\IO\Tcp.cs, Line: 418, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\src\core\Akka\IO\Tcp.cs, Line: 630, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\src\core\Akka\IO\Tcp.cs, Line: 637, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: D:\a\1\s\src\core\Akka\IO\TcpConnection.cs, Line: 245, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: D:\a\1\s\src\core\Akka\IO\TcpListener.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #179 Path: D:\a\1\s\src\core\Akka\IO\TcpManager.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #180 Path: D:\a\1\s\src\core\Akka\IO\TcpManager.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #181 Path: D:\a\1\s\src\core\Akka\IO\TcpManager.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: D:\a\1\s\src\core\Akka\IO\TcpManager.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #183 Path: D:\a\1\s\src\core\Akka\IO\TcpOutgoingConnection.cs, Line: 127, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: D:\a\1\s\src\core\Akka\IO\UdpManager.cs, Line: 65, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\src\core\Akka\IO\UdpManager.cs, Line: 72, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 196, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 240, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 255, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 347, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #190 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 362, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #191 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 364, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #192 Path: D:\a\1\s\src\core\Akka\Serialization\NewtonSoftJsonSerializer.cs, Line: 366, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #193 Path: D:\a\1\s\src\core\Akka\Util\Result.cs, Line: 68, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Akka.TestKit.Tests(net471)
    #194 Path: D:\a\1\s\src\core\Akka.TestKit.Tests\TestActorRefTests\Logger.cs, Line: 20, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #195 Path: D:\a\1\s\src\core\Akka.TestKit.Tests\TestActorRefTests\TestActorRefSpec.cs, Line: 109, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #196 Path: D:\a\1\s\src\core\Akka.TestKit.Tests\TestActorRefTests\WatchAndForwardActor.cs, Line: 25, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #197 Path: D:\a\1\s\src\core\Akka.TestKit.Tests\TestActorRefTests\WorkerActor.cs, Line: 24, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #198 Path: D:\a\1\s\src\core\Akka.TestKit.Tests\TestKitBaseTests\DilatedTests.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #199 Path: D:\a\1\s\src\core\Akka.TestKit.Tests\TestKitBaseTests\DilatedTests.cs, Line: 69, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.Tests.Shared.Internals
    #200 Path: D:\a\1\s\src\core\Akka.Tests.Shared.Internals\AkkaSpec.cs, Line: 127, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #201 Path: D:\a\1\s\src\core\Akka.Tests.Shared.Internals\AkkaSpec.cs, Line: 129, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #202 Path: D:\a\1\s\src\core\Akka.Tests.Shared.Internals\AkkaSpec.cs, Line: 131, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #203 Path: D:\a\1\s\src\core\Akka.Tests.Shared.Internals\AkkaSpec.cs, Line: 139, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #204 Path: D:\a\1\s\src\core\Akka.Tests.Shared.Internals\AkkaSpecExtensions.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #205 Path: D:\a\1\s\src\core\Akka.Tests.Shared.Internals\AkkaSpecExtensions.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.Cluster
    #206 Path: D:\a\1\s\src\core\Akka.Cluster\Cluster.cs, Line: 541, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #207 Path: D:\a\1\s\src\core\Akka.Cluster\ClusterDaemon.cs, Line: 2179, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #208 Path: D:\a\1\s\src\core\Akka.Cluster\ClusterDaemon.cs, Line: 2731, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #209 Path: D:\a\1\s\src\core\Akka.Cluster\ClusterDaemon.cs, Line: 2838, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #210 Path: D:\a\1\s\src\core\Akka.Cluster\ClusterDaemon.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #211 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\ClusterMessageSerializer.cs, Line: 413, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #212 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 1004, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #213 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 1318, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #214 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 1586, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #215 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 1806, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #216 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 2046, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #217 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 2356, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #218 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 2620, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #219 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 265, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #220 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 2826, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #221 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 3042, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #222 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 3259, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #223 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 3507, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #224 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 3773, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #225 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 495, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #226 Path: D:\a\1\s\src\core\Akka.Cluster\Serialization\Proto\ClusterMessages.g.cs, Line: 746, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Akka.Remote.TestKit
    #227 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Conductor.cs, Line: 190, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #228 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Conductor.cs, Line: 213, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #229 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Conductor.cs, Line: 362, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #230 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Conductor.cs, Line: 380, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #231 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Conductor.cs, Line: 424, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Controller.cs, Line: 282, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #233 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Controller.cs, Line: 294, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #234 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\Controller.cs, Line: 326, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #235 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgDecoder.cs, Line: 45, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #236 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #237 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #238 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #239 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #240 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #241 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 26, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #242 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #243 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 51, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #244 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MsgEncoder.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #245 Path: D:\a\1\s\src\core\Akka.Remote.TestKit\MultiNodeSpec.cs, Line: 643, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.NodeTestRunner(net471)
    #246 Path: D:\a\1\s\src\core\Akka.NodeTestRunner\Program.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #247 Path: D:\a\1\s\src\core\Akka.NodeTestRunner\Sink.cs, Line: 44, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #248 Path: D:\a\1\s\src\core\Akka.NodeTestRunner\Sink.cs, Line: 50, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #249 Path: D:\a\1\s\src\core\Akka.NodeTestRunner\Sink.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #250 Path: D:\a\1\s\src\core\Akka.NodeTestRunner\Sink.cs, Line: 72, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Persistence.Tests(net471)
    #251 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 163, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #252 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 164, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #253 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #254 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 184, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #255 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #256 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 209, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #257 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryFailureSpec.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #258 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliveryReceiveActorSpec.cs, Line: 338, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #259 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\AtLeastOnceDeliverySpec.cs, Line: 351, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #260 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\EndToEndEventAdapterSpec.cs, Line: 396, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #261 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\Journal\ChaosJournal.cs, Line: 25, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #262 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\Journal\ChaosJournal.cs, Line: 31, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorDeleteFailureSpec.cs, Line: 69, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #264 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorDeleteFailureSpec.cs, Line: 98, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #265 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #266 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 202, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 213, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #268 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 241, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #269 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 242, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #270 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 263, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #271 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 265, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #272 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorFailureSpec.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #273 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorJournalProtocolSpec.cs, Line: 223, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #274 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorJournalProtocolSpec.cs, Line: 236, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #275 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorJournalProtocolSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #276 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorJournalProtocolSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #277 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorJournalProtocolSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #278 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorJournalProtocolSpec.cs, Line: 374, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #279 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 1012, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #280 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 1070, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #281 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 1114, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #282 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 146, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #283 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 157, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #284 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 449, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #285 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 466, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #286 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 466, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #287 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 48, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #288 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 486, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #289 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 518, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #290 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 551, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 56, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #292 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 591, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #293 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 621, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #294 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 649, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #295 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 675, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #296 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 735, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 758, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #298 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 781, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 806, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #300 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 884, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #301 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 916, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #302 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 948, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #303 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpec.Actors.cs, Line: 980, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #304 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 153, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #305 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 164, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #306 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 512, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #307 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 535, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #308 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 535, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #309 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 55, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #310 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 555, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #311 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 593, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #312 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 63, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #313 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 632, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #314 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 678, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #315 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 714, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #316 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 747, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #317 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 778, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #318 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 843, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #319 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 871, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #320 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 899, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #321 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorSpecAsyncAwait.Actors.cs, Line: 929, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #322 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 120, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #323 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #324 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 178, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #325 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 204, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #326 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #327 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 256, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #328 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 380, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #329 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\PersistentActorStashingSpec.cs, Line: 408, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #330 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\Serialization\MessageSerializerRemotingSpec.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #331 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\Serialization\TestSerializers.cs, Line: 34, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #332 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\Serialization\TestSerializers.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #333 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotDirectoryFailureSpec.cs, Line: 43, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #334 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 102, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #335 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 139, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #336 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #337 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #338 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #339 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #340 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #341 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotFailureRobustnessSpec.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #342 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotRecoveryLocalStoreSpec.cs, Line: 45, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #343 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotSerializationSpec.cs, Line: 125, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #344 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotSerializationSpec.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #345 Path: D:\a\1\s\src\core\Akka.Persistence.Tests\SnapshotSpec.cs, Line: 366, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Persistence.TCK
    #346 Path: D:\a\1\s\src\core\Akka.Persistence.TCK\Serialization\JournalSerializationSpec.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #347 Path: D:\a\1\s\src\core\Akka.Persistence.TCK\Serialization\JournalSerializationSpec.cs, Line: 197, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.Persistence
    #348 Path: D:\a\1\s\src\core\Akka.Persistence\Eventsourced.cs, Line: 623, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #349 Path: D:\a\1\s\src\core\Akka.Persistence\Fsm\PersistentFSM.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #350 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\AsyncWriteJournal.cs, Line: 313, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #351 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\AsyncWriteProxy.cs, Line: 306, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #352 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\EventAdapters.cs, Line: 317, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #353 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\EventAdapters.cs, Line: 366, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #354 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\EventAdapters.cs, Line: 438, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #355 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\EventAdapters.cs, Line: 469, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #356 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\PersistencePluginProxy.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #357 Path: D:\a\1\s\src\core\Akka.Persistence\Journal\ReplayFilter.cs, Line: 134, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #358 Path: D:\a\1\s\src\core\Akka.Persistence\Snapshot\SnapshotStore.cs, Line: 200, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.MultiNodeTestRunner.Shared.Tests(net471)
    #359 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared.Tests\NodeMessageHelpers.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #360 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared.Tests\NodeMessageHelpers.cs, Line: 127, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #361 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared.Tests\NodeMessageHelpers.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #362 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared.Tests\NodeMessageHelpers.cs, Line: 97, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.MultiNodeTestRunner.Shared
    #363 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Persistence\JsonPersistentTestRunStore.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #364 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Persistence\VisualizerRuntimeTemplate.Tree.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #365 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Persistence\VisualizerRuntimeTemplate.Tree.cs, Line: 109, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #366 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Reporting\MultiNodeMessage.cs, Line: 153, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #367 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Reporting\MultiNodeMessage.cs, Line: 210, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #368 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Reporting\MultiNodeMessage.cs, Line: 289, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #369 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Reporting\MultiNodeMessage.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #370 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Reporting\SpecRunCoordinator.cs, Line: 26, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #371 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #372 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #373 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #374 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 48, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #375 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #376 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #377 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 64, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #378 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #379 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #380 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\ConsoleMessageSinkActor.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #381 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\Messages.cs, Line: 119, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #382 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\Messages.cs, Line: 146, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #383 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\Spec.cs, Line: 40, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #384 Path: D:\a\1\s\src\core\Akka.MultiNodeTestRunner.Shared\Sinks\Spec.cs, Line: 68, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.Persistence.Sql.Common
    #385 Path: D:\a\1\s\src\contrib\persistence\Akka.Persistence.Sql.Common\Snapshot\QueryExecutor.cs, Line: 356, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Akka.Cluster.Tests.MultiNode(net471)
    #386 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs, Line: 280, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #387 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #388 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\LeaderLeavingSpec.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #389 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\LeaderLeavingSpec.cs, Line: 142, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #390 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs, Line: 181, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #391 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #392 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs, Line: 430, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #393 Path: D:\a\1\s\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Remote.Tests.MultiNode(net471)
    #394 Path: D:\a\1\s\src\core\Akka.Remote.Tests.MultiNode\RemoteDeliverySpec.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Serialization.TestKit(net471)
    #395 Path: D:\a\1\s\src\contrib\serializers\Akka.Serialization.TestKit\UntypedContainerMessage.cs, Line: 48, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.Tests.Performance
    #396 Path: D:\a\1\s\src\core\Akka.Tests.Performance\Actor\ActorThroughputSpec.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #397 Path: D:\a\1\s\src\core\Akka.Tests.Performance\Actor\ActorThroughputSpec.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #398 Path: D:\a\1\s\src\core\Akka.Tests.Performance\Actor\ActorThroughputSpec.cs, Line: 83, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Akka.Streams
    #399 Path: D:\a\1\s\src\core\Akka.Streams\ActorMaterializer.cs, Line: 215, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #400 Path: D:\a\1\s\src\core\Akka.Streams\ActorMaterializer.cs, Line: 707, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #401 Path: D:\a\1\s\src\core\Akka.Streams\ActorMaterializer.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #402 Path: D:\a\1\s\src\core\Akka.Streams\Actors\ActorPublisher.cs, Line: 25, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #403 Path: D:\a\1\s\src\core\Akka.Streams\Actors\ActorPublisher.cs, Line: 489, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #404 Path: D:\a\1\s\src\core\Akka.Streams\Actors\ActorSubscriber.cs, Line: 164, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #405 Path: D:\a\1\s\src\core\Akka.Streams\Attributes.cs, Line: 331, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #406 Path: D:\a\1\s\src\core\Akka.Streams\Attributes.cs, Line: 521, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\src\core\Akka.Streams\Dsl\Internal\GraphImpl.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs, Line: 309, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs, Line: 313, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #410 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs, Line: 317, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #411 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs, Line: 78, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #412 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #413 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 297, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #414 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #415 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #416 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 313, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #417 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #418 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 510, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #419 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorProcessor.cs, Line: 529, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #420 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorRefBackpressureSinkStage.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #421 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorRefSinkActor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #422 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorRefSinkActor.cs, Line: 73, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #423 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\Fusing.cs, Line: 821, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #424 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\Fusing.cs, Line: 905, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #425 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\GraphAssembly.cs, Line: 205, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #426 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\GraphStages.cs, Line: 408, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #427 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\StreamOfStreams.cs, Line: 1222, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #428 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\StreamOfStreams.cs, Line: 1270, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #429 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\StreamOfStreams.cs, Line: 1282, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #430 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\StreamOfStreams.cs, Line: 1349, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #431 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\StreamOfStreams.cs, Line: 1365, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #432 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Fusing\StreamOfStreams.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #433 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 117, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #434 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #435 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 26, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #436 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #437 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 463, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #438 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 485, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #439 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 502, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #440 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 530, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #441 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\IO\TcpStages.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #442 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Sources.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #443 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Sources.cs, Line: 238, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #444 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Sources.cs, Line: 286, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #445 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\Sources.cs, Line: 298, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #446 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1600, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #447 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1611, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #448 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1658, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #449 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1661, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #450 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1672, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #451 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1731, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #452 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1741, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #453 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1759, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #454 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1790, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #455 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1799, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #456 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1807, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #457 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1843, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #458 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1857, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #459 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1880, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #460 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1896, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #461 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 1962, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #462 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2066, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #463 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #464 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2291, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #465 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2301, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #466 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2425, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #467 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2489, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #468 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 2496, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #469 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 299, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #470 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 301, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #471 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 329, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #472 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 342, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #473 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 346, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #474 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 350, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #475 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #476 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #477 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 747, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #478 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 759, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #479 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 760, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #480 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 761, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #481 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\StreamLayout.cs, Line: 828, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #482 Path: D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedVirtualPublisher.cs, Line: 81, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Akka.Streams.Tests(net471)
    #483 Path: D:\a\1\s\src\core\Akka.Streams.Tests\Dsl\FlowMonitorSpec.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #484 Path: D:\a\1\s\src\core\Akka.Streams.Tests\Dsl\FlowMonitorSpec.cs, Line: 150, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #485 Path: D:\a\1\s\src\core\Akka.Streams.Tests\Dsl\FlowMonitorSpec.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #486 Path: D:\a\1\s\src\core\Akka.Streams.Tests\Dsl\GraphStageTimersSpec.cs, Line: 205, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #487 Path: D:\a\1\s\src\core\Akka.Streams.Tests\Implementation\StreamLayoutSpec.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #488 Path: D:\a\1\s\src\core\Akka.Streams.Tests\Implementation\StreamLayoutSpec.cs, Line: 97, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Akka.Cluster.Tools.Tests.MultiNode(net471)
    #489 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Tools.Tests.MultiNode\PublishSubscribe\DistributedPubSubMediatorSpec.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #490 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Tools.Tests.MultiNode\PublishSubscribe\DistributedPubSubMediatorSpec.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #491 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Tools.Tests.MultiNode\TestLease.cs, Line: 170, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Akka.Cluster.Sharding.Tests.MultiNode(net471)
    #492 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Sharding.Tests.MultiNode\AsyncWriteProxyEx.cs, Line: 462, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #493 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Sharding.Tests.MultiNode\ClusterShardingSpec.cs, Line: 1270, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Akka.DistributedData
    #494 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ORSet.cs, Line: 13, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #495 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ORSet.cs, Line: 521, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #496 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ORSet.cs, Line: 570, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #497 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ORSet.cs, Line: 593, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #498 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ReadAggregator.cs, Line: 140, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #499 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ReadAggregator.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #500 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\ReadAggregator.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #501 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData\WriteAggregator.cs, Line: 170, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Akka.DistributedData.Tests(net471)
    #502 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData.Tests\ORDictionarySpec.cs, Line: 193, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #503 Path: D:\a\1\s\src\contrib\cluster\Akka.DistributedData.Tests\ORDictionarySpec.cs, Line: 197, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Samples.Cluster.Transformation
    #504 Path: D:\a\1\s\src\examples\Cluster\Roles\Samples.Cluster.Transformation\TransformationMessages.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #505 Path: D:\a\1\s\src\examples\Cluster\Roles\Samples.Cluster.Transformation\TransformationMessages.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Akka.Cluster.Metrics
    #506 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 1060, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #507 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 1284, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #508 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 1503, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #509 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 1707, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #510 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 1852, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #511 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 199, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #512 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 388, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #513 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 530, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #514 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 739, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #515 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics\Serialization\ClusterMetricsMessages.g.cs, Line: 916, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Akka.Cluster.Metrics.Tests.MultiNode(net471)
    #516 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics.Tests.MultiNode\ClustetMetricsRoutingSpec.cs, Line: 287, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #517 Path: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Metrics.Tests.MultiNode\ClustetMetricsRoutingSpec.cs, Line: 305, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



--- Rules Summary ---
R8: 207
R5: 143
R9: 118
R7: 31
R2: 9
R4: 4
R6: 3
R3: 2

--- Summary ---
Fixed ReSharper issues: 508
Fixed SonarQube issues: 152
Total fixed issues: 517

Finished in: 1 min 20 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\core\Akka.Remote.Tests\RemoteRouterSpec.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Configuration;
using Akka.Dispatch;
using Akka.Remote.Routing;
using Akka.Routing;
using Akka.TestKit;
using Akka.Util.Internal;
using Xunit;
using FluentAssertions;
using Xunit.Abstractions;

namespace Akka.Remote.Tests
{
    /// <summary>
    /// Tests for <see cref="RemoteRouterConfig"/>
    /// </summary>
    public class RemoteRouterSpec : AkkaSpec
    {
        #region Echo actor

        private class Echo : UntypedActor
        {
            protected override void OnReceive(object message)
            {
                Sender.Tell(message);
            }
        }

        private class Parent : UntypedActor
        {
            protected override void OnReceive(object message)
            {
                var tuple = message as (Props, string)?;
                if (tuple != null)
                {
                    Sender.Tell(Context.ActorOf(tuple.Value.Item1, tuple.Value.Item2));
                }
            }
        }

        private Props EchoActorProps
        {
            get { return Props.Create<Echo>(); }
        }

        #endregion

        private int port;
        private string sysName;
        private Config conf;
        private ActorSystem masterSystem;
        private Address intendedRemoteAddress;

        public RemoteRouterSpec(ITestOutputHelper output)
            : base(@"
            akka.actor.provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""
            akka.remote.dot-netty.tcp {
                hostname = 127.0.0.1
                port = 0
            }
            akka.actor.deployment {
              /remote-override {
                router = round-robin-pool
                nr-of-instances = 4
              }
              /round {
                router = round-robin-pool
                nr-of-instances = 5
              }
              /sys-parent/round {
                router = round-robin-pool
                nr-of-instances = 6
              }
            }
        ", output)
        {
            // ReSharper disable once PossibleInvalidOperationException
            port = Sys.AsInstanceOf<ExtendedActorSystem>().Provider.DefaultAddress.Port.Value;
            sysName = Sys.Name;
            conf = ConfigurationFactory.ParseString(@"
                akka {
      actor.deployment {
        /blub {
          router = round-robin-pool
          nr-of-instances = 2
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
        /elastic-blub {
          router = round-robin-pool
          resizer {
            enabled = on
            lower-bound = 2
            upper-bound = 3
          }
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
        /remote-blub {
          remote = ""akka.tcp://${sysName}@127.0.0.1:${port}""
          router = round-robin-pool
          nr-of-instances = 2
        }
        /local-blub {
          remote = ""akka://${masterSysName}""
          router = round-robin-pool
          nr-of-instances = 2
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
        /local-blub2 {
          router = round-robin-pool
          nr-of-instances = 4
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
      }
    }
".Replace("${masterSysName}", "Master" + sysName).Replace("${sysName}", sysName).Replace("${port}", port.ToString())).WithFallback(Sys.Settings.Config);

            masterSystem = ActorSystem.Create("Master" + sysName, conf);

            intendedRemoteAddress = Address.Parse("akka.tcp://${sysName}@127.0.0.1:${port}"
                .Replace("${sysName}", sysName)
                .Replace("${port}", port.ToString()));
        }

        protected override void AfterTermination()
        {
            Shutdown(masterSystem);
        }

        private IEnumerable<ActorPath> CollectRouteePaths(TestProbe probe, IActorRef router, int n)
        {
            List<ActorPath> list = new List<ActorPath>();

            for (var i = 1; i <= n; i++)
            {
                string msg = i.ToString();
                router.Tell(msg, probe.Ref);
                probe.ExpectMsg(msg);
                list.Add(probe.LastSender.Path);
            }

            return list;
        }

        [Fact]
        public void RemoteRouter_must_deploy_its_children_on_remote_host_driven_by_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(new RoundRobinPool(2).Props(EchoActorProps), "blub");
            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);
            children.Select(x => x.Parent).Distinct().Should().HaveCount(1);
            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_its_children_on_remote_host_driven_by_programmatic_definition()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(new RemoteRouterConfig(
                new RoundRobinPool(2),
                new[] { new Address("akka.tcp", sysName, "127.0.0.1", port) })
                .Props(EchoActorProps), "blub2");
            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);
            children.Select(x => x.Parent).Distinct().Should().HaveCount(1);
            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_dynamic_resizable_number_of_children_on_remote_host_driven_by_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(FromConfig.Instance.Props(EchoActorProps), "elastic-blub");
            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);
            children.Select(x => x.Parent).Distinct().Should().HaveCount(1);
            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_remote_routers_based_on_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(FromConfig.Instance.Props(EchoActorProps), "remote-blub");
            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Should().Be(router.Path);

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_remote_routers_based_on_explicit_deployment()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "remote-blub2");

            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Should().Be(router.Path);

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_let_remote_deployment_be_overridden_by_local_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(
                new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "local-blub");
            router.Path.Address.ToString().Should().Be($"akka://{masterSystem.Name}");

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Address.Should().Be(new Address("akka.tcp", sysName, "127.0.0.1", port));

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_let_remote_deployment_router_be_overridden_by_local_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(
                new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "local-blub2");

            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(4);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Address.Should().Be(new Address("akka.tcp", sysName, "127.0.0.1", port));

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_let_remote_deployment_be_overridden_by_remote_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(
                new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "remote-override");

            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(4);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Address.Should().Be(router.Path.Address);

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public async Task RemoteRouter_must_set_supplied_SupervisorStrategy()
        {
            var probe = CreateTestProbe(masterSystem);
            var escalator = new OneForOneStrategy(ex =>
            {
                probe.Ref.Tell(ex);
                return Directive.Escalate;
            });

            var router = masterSystem.ActorOf(new RemoteRouterConfig(
                new RoundRobinPool(1, null, escalator, Dispatchers.DefaultDispatcherId),
                new[] { new Address("akka.tcp", sysName, "127.0.0.1", port) }).Props(Props.Empty), "blub3");

            router.Tell(new GetRoutees(), probe.Ref);

            // Need to be able to bind EventFilter to additional actor system (masterActorSystem in this case) before this code works
            // EventFilter.Exception<ActorKilledException>().ExpectOne(() => 
            probe.ExpectMsg<Routees>(TimeSpan.FromSeconds(10)).Members.Head().Send(Kill.Instance, TestActor);
            //);
            probe.ExpectMsg<ActorKilledException>(TimeSpan.FromSeconds(10));
        }

        [Fact(Skip = "Remote actor's DCN is currently not supported")]
        public void RemoteRouter_must_load_settings_from_config_for_local_router()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(FromConfig.Instance.Props(EchoActorProps), "round");
            var replies = CollectRouteePaths(probe, router, 10);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(5);
            masterSystem.Stop(router);
        }

        [Fact(Skip = "Remote actor's DCN is currently not supported")]
        public void RemoteRouter_must_load_settings_from_config_for_local_child_router_of_system_actor()
        {
            // we don't really support deployment configuration of system actors, but
            // it's used for the pool of the SimpleDnsManager "/IO-DNS/inet-address"
            var probe = CreateTestProbe(masterSystem);
            var parent = ((ExtendedActorSystem)masterSystem).SystemActorOf(FromConfig.Instance.Props(Props.Create<Parent>()), "sys-parent");
            parent.Tell((FromConfig.Instance.Props(EchoActorProps), "round"), probe);
            var router = probe.ExpectMsg<IActorRef>();
            var replies = CollectRouteePaths(probe, router, 10);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(6);
            masterSystem.Stop(router);
        }
    }
}


---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Configuration;
using Akka.Dispatch;
using Akka.Remote.Routing;
using Akka.Routing;
using Akka.TestKit;
using Akka.Util.Internal;
using Xunit;
using FluentAssertions;
using Xunit.Abstractions;

namespace Akka.Remote.Tests
{
    /// <summary>
    /// Tests for <see cref="RemoteRouterConfig"/>
    /// </summary>
    public class RemoteRouterSpec : AkkaSpec
    {
        #region Echo actor

        private class Echo : UntypedActor
        {
            protected override void OnReceive(object message)
            {
                Sender.Tell(message);
            }
        }

        private class Parent : UntypedActor
        {
            protected override void OnReceive(object message)
            {
                if (message is (Props, string)? tuple)
                {
                    Sender.Tell(Context.ActorOf(tuple.Value.Item1, tuple.Value.Item2));
                }
            }
        }

        private Props EchoActorProps
        {
            get { return Props.Create<Echo>(); }
        }

        #endregion

        private int port;
        private string sysName;
        private Config conf;
        private ActorSystem masterSystem;
        private Address intendedRemoteAddress;

        public RemoteRouterSpec(ITestOutputHelper output)
            : base(@"
            akka.actor.provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""
            akka.remote.dot-netty.tcp {
                hostname = 127.0.0.1
                port = 0
            }
            akka.actor.deployment {
              /remote-override {
                router = round-robin-pool
                nr-of-instances = 4
              }
              /round {
                router = round-robin-pool
                nr-of-instances = 5
              }
              /sys-parent/round {
                router = round-robin-pool
                nr-of-instances = 6
              }
            }
        ", output)
        {
            // ReSharper disable once PossibleInvalidOperationException
            port = Sys.AsInstanceOf<ExtendedActorSystem>().Provider.DefaultAddress.Port.Value;
            sysName = Sys.Name;
            conf = ConfigurationFactory.ParseString(@"
                akka {
      actor.deployment {
        /blub {
          router = round-robin-pool
          nr-of-instances = 2
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
        /elastic-blub {
          router = round-robin-pool
          resizer {
            enabled = on
            lower-bound = 2
            upper-bound = 3
          }
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
        /remote-blub {
          remote = ""akka.tcp://${sysName}@127.0.0.1:${port}""
          router = round-robin-pool
          nr-of-instances = 2
        }
        /local-blub {
          remote = ""akka://${masterSysName}""
          router = round-robin-pool
          nr-of-instances = 2
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
        /local-blub2 {
          router = round-robin-pool
          nr-of-instances = 4
          target.nodes = [""akka.tcp://${sysName}@127.0.0.1:${port}""]
        }
      }
    }
".Replace("${masterSysName}", "Master" + sysName).Replace("${sysName}", sysName).Replace("${port}", port.ToString())).WithFallback(Sys.Settings.Config);

            masterSystem = ActorSystem.Create("Master" + sysName, conf);

            intendedRemoteAddress = Address.Parse("akka.tcp://${sysName}@127.0.0.1:${port}"
                .Replace("${sysName}", sysName)
                .Replace("${port}", port.ToString()));
        }

        protected override void AfterTermination()
        {
            Shutdown(masterSystem);
        }

        private IEnumerable<ActorPath> CollectRouteePaths(TestProbe probe, IActorRef router, int n)
        {
            List<ActorPath> list = new List<ActorPath>();

            for (var i = 1; i <= n; i++)
            {
                string msg = i.ToString();
                router.Tell(msg, probe.Ref);
                probe.ExpectMsg(msg);
                list.Add(probe.LastSender.Path);
            }

            return list;
        }

        [Fact]
        public void RemoteRouter_must_deploy_its_children_on_remote_host_driven_by_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(new RoundRobinPool(2).Props(EchoActorProps), "blub");
            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);
            children.Select(x => x.Parent).Distinct().Should().HaveCount(1);
            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_its_children_on_remote_host_driven_by_programmatic_definition()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(new RemoteRouterConfig(
                new RoundRobinPool(2),
                new[] { new Address("akka.tcp", sysName, "127.0.0.1", port) })
                .Props(EchoActorProps), "blub2");
            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);
            children.Select(x => x.Parent).Distinct().Should().HaveCount(1);
            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_dynamic_resizable_number_of_children_on_remote_host_driven_by_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(FromConfig.Instance.Props(EchoActorProps), "elastic-blub");
            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);
            children.Select(x => x.Parent).Distinct().Should().HaveCount(1);
            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_remote_routers_based_on_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(FromConfig.Instance.Props(EchoActorProps), "remote-blub");
            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Should().Be(router.Path);

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_deploy_remote_routers_based_on_explicit_deployment()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "remote-blub2");

            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Should().Be(router.Path);

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_let_remote_deployment_be_overridden_by_local_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(
                new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "local-blub");
            router.Path.Address.ToString().Should().Be($"akka://{masterSystem.Name}");

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(2);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Address.Should().Be(new Address("akka.tcp", sysName, "127.0.0.1", port));

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_let_remote_deployment_router_be_overridden_by_local_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(
                new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "local-blub2");

            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(4);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Address.Should().Be(new Address("akka.tcp", sysName, "127.0.0.1", port));

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public void RemoteRouter_must_let_remote_deployment_be_overridden_by_remote_configuration()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(
                new RoundRobinPool(2)
                .Props(EchoActorProps)
                .WithDeploy(new Deploy(new RemoteScope(intendedRemoteAddress))), "remote-override");

            router.Path.Address.Should().Be(intendedRemoteAddress);

            var replies = CollectRouteePaths(probe, router, 5);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(4);

            var parents = children.Select(x => x.Parent).Distinct().ToList();
            parents.Should().HaveCount(1);
            parents.Head().Address.Should().Be(router.Path.Address);

            children.ForEach(x => x.Address.Should().Be(intendedRemoteAddress));
            masterSystem.Stop(router);
        }

        [Fact]
        public async Task RemoteRouter_must_set_supplied_SupervisorStrategy()
        {
            var probe = CreateTestProbe(masterSystem);
            var escalator = new OneForOneStrategy(ex =>
            {
                probe.Ref.Tell(ex);
                return Directive.Escalate;
            });

            var router = masterSystem.ActorOf(new RemoteRouterConfig(
                new RoundRobinPool(1, null, escalator, Dispatchers.DefaultDispatcherId),
                new[] { new Address("akka.tcp", sysName, "127.0.0.1", port) }).Props(Props.Empty), "blub3");

            router.Tell(new GetRoutees(), probe.Ref);

            // Need to be able to bind EventFilter to additional actor system (masterActorSystem in this case) before this code works
            // EventFilter.Exception<ActorKilledException>().ExpectOne(() => 
            probe.ExpectMsg<Routees>(TimeSpan.FromSeconds(10)).Members.Head().Send(Kill.Instance, TestActor);
            //);
            probe.ExpectMsg<ActorKilledException>(TimeSpan.FromSeconds(10));
        }

        [Fact(Skip = "Remote actor's DCN is currently not supported")]
        public void RemoteRouter_must_load_settings_from_config_for_local_router()
        {
            var probe = CreateTestProbe(masterSystem);
            var router = masterSystem.ActorOf(FromConfig.Instance.Props(EchoActorProps), "round");
            var replies = CollectRouteePaths(probe, router, 10);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(5);
            masterSystem.Stop(router);
        }

        [Fact(Skip = "Remote actor's DCN is currently not supported")]
        public void RemoteRouter_must_load_settings_from_config_for_local_child_router_of_system_actor()
        {
            // we don't really support deployment configuration of system actors, but
            // it's used for the pool of the SimpleDnsManager "/IO-DNS/inet-address"
            var probe = CreateTestProbe(masterSystem);
            var parent = ((ExtendedActorSystem)masterSystem).SystemActorOf(FromConfig.Instance.Props(Props.Create<Parent>()), "sys-parent");
            parent.Tell((FromConfig.Instance.Props(EchoActorProps), "round"), probe);
            var router = probe.ExpectMsg<IActorRef>();
            var replies = CollectRouteePaths(probe, router, 10);
            var children = new HashSet<ActorPath>(replies);
            children.Should().HaveCount(6);
            masterSystem.Stop(router);
        }
    }
}


---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\core\Akka.Remote.Tests\RemoteRouterSpec.cs(307,27): warning CS1998: This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Remote.Tests\RemoteRouterSpec.cs(44,32): error CS8116: It is not legal to use nullable type '(Props, string)?' in a pattern; use the underlying type '(Props, string)' instead.,D:\a\1\s\src\core\Akka.Remote.Tests\RemoteRouterSpec.cs(306,27): warning CS1998: This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.
######################################################################


######################################################################
Nr: 2 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\src\core\Akka.Remote\Endpoint.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Dispatch;
using Akka.Dispatch.SysMsg;
using Akka.Event;
using Akka.Pattern;
using Akka.Remote.Serialization;
using Akka.Remote.Transport;
using Akka.Serialization;
using Akka.Util;
using Akka.Util.Internal;
using Google.Protobuf;
using SerializedMessage = Akka.Remote.Serialization.Proto.Msg.Payload;

namespace Akka.Remote
{
    /// <summary>
    /// INTERNAL API
    /// </summary>
    // ReSharper disable once InconsistentNaming
    internal interface IInboundMessageDispatcher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null);
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class DefaultMessageDispatcher : IInboundMessageDispatcher
    {
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ILoggingAdapter _log;
        private readonly IInternalActorRef _remoteDaemon;
        private readonly RemoteSettings _settings;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="provider">TBD</param>
        /// <param name="log">TBD</param>
        public DefaultMessageDispatcher(ExtendedActorSystem system, IRemoteActorRefProvider provider, ILoggingAdapter log)
        {
            _system = system;
            _provider = provider;
            _log = log;
            _remoteDaemon = provider.RemoteDaemon;
            _settings = provider.RemoteSettings;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        public void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null)
        {
            var payload = MessageSerializer.Deserialize(_system, message);
            var payloadClass = payload?.GetType();
            var sender = senderOption ?? _system.DeadLetters;
            var originalReceiver = recipient.Path;

            // message is intended for the RemoteDaemon, usually a command to create a remote actor
            if (recipient.Equals(_remoteDaemon))
            {
                if (_settings.UntrustedMode) _log.Debug("dropping daemon message in untrusted mode");
                else
                {
                    if (_settings.LogReceive)
                    {
                        var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                        _log.Debug("received daemon message [{0}]", msgLog);
                    }
                    _remoteDaemon.Tell(payload);
                }
            }

            //message is intended for a local recipient
            else if ((recipient is ILocalRef || recipient is RepointableActorRef) && recipient.IsLocal)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                    _log.Debug("received local message [{0}]", msgLog);
                }
                if (payload is ActorSelectionMessage sel)
                {
                    if (_settings.UntrustedMode
                        && (!_settings.TrustedSelectionPaths.Contains(FormatActorPath(sel))
                            || sel.Message is IPossiblyHarmful
                            || !recipient.Equals(_provider.RootGuardian)))
                    {
                        _log.Debug(
                            "operating in UntrustedMode, dropping inbound actor selection to [{0}], allow it" +
                            "by adding the path to 'akka.remote.trusted-selection-paths' in configuration",
                            FormatActorPath(sel));
                    }
                    else
                    {
                        //run the receive logic for ActorSelectionMessage here to make sure it is not stuck on busy user actor
                        ActorSelection.DeliverSelection(recipient, sender, sel);
                    }
                }
                else if (payload is IPossiblyHarmful && _settings.UntrustedMode)
                {
                    _log.Debug("operating in UntrustedMode, dropping inbound IPossiblyHarmful message of type {0}",
                        payload.GetType());
                }
                else if (payload is ISystemMessage systemMessage)
                {
                    recipient.SendSystemMessage(systemMessage);
                }
                else
                {
                    recipient.Tell(payload, sender);
                }
            }

            // message is intended for a remote-deployed recipient
            else if ((recipient is IRemoteRef || recipient is RepointableActorRef) && !recipient.IsLocal &&
                     !_settings.UntrustedMode)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = string.Format("RemoteMessage: {0} to {1}<+{2} from {3}", payload, recipient, originalReceiver, sender);
                    _log.Debug("received remote-destined message {0}", msgLog);
                }
                if (_provider.Transport.Addresses.Contains(recipientAddress))
                {
                    //if it was originally addressed to us but is in fact remote from our point of view (i.e. remote-deployed)
                    recipient.Tell(payload, sender);
                }
                else
                {
                    _log.Error(
                        "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                        payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
                }
            }
            else
            {
                _log.Error(
                    "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                    payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
            }
        }

        private static string FormatActorPath(ActorSelectionMessage sel)
        {
            return "/" + string.Join("/", sel.Elements.Select(x => x.ToString()));
        }
    }

    #region Endpoint Exception Types

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointException : AkkaException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="cause">The exception that is the cause of the current exception.</param>
        public EndpointException(string message, Exception cause = null) : base(message, cause) { }

#if SERIALIZATION
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected EndpointException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal interface IAssociationProblem { }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class ShutDownAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="cause">TBD</param>
        public ShutDownAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal sealed class InvalidAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TbD</param>
        /// <param name="cause">TBD</param>
        /// <param name="disassociateInfo">TBD</param>
        public InvalidAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null, DisassociateInfo? disassociateInfo = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            DisassociationInfo = disassociateInfo;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public DisassociateInfo? DisassociationInfo { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class HopelessAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="cause">TBD</param>
        public HopelessAssociation(Address localAddress, Address remoteAddress, int? uid = null, Exception cause = null)
            : base("Catastrophic association error.", cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            Uid = uid;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointDisassociatedException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointDisassociatedException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointDisassociatedException(string message)
            : base(message)
        {
        }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointAssociationException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointAssociationException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        public EndpointAssociationException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class OversizedPayloadException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OversizedPayloadException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public OversizedPayloadException(string message)
            : base(message)
        {
        }
    }

    #endregion

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class ReliableDeliverySupervisor : ReceiveActor
    {
        #region Internal message classes

        /// <summary>
        /// TBD
        /// </summary>
        public class IsIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly IsIdle Instance = new IsIdle();
            private IsIdle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class Idle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly Idle Instance = new Idle();
            private Idle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class TooLongIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly TooLongIdle Instance = new TooLongIdle();
            private TooLongIdle() { }
        }

        #endregion

        private readonly ILoggingAdapter _log = Context.GetLogger();

        private readonly Address _localAddress;
        private readonly Address _remoteAddress;
        private readonly int? _refuseUid;
        private readonly AkkaProtocolTransport _transport;
        private readonly RemoteSettings _settings;
        private AkkaPduCodec _codec;
        private AkkaProtocolHandle _currentHandle;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        public ReliableDeliverySupervisor(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers)
        {
            _localAddress = localAddress;
            _remoteAddress = remoteAddress;
            _refuseUid = refuseUid;
            _transport = transport;
            _settings = settings;
            _codec = codec;
            _currentHandle = handleOrActive;
            _receiveBuffers = receiveBuffers;
            Reset(); // needs to be called at startup
            _writer = CreateWriter(); // need to create writer at startup
            Uid = handleOrActive != null ? (int?)handleOrActive.HandshakeInfo.Uid : null;
            UidConfirmed = Uid.HasValue && (Uid != _refuseUid);

            if (Uid.HasValue && Uid == _refuseUid)
                throw new HopelessAssociation(localAddress, remoteAddress, Uid,
                    new InvalidOperationException(
                        $"The remote system [{remoteAddress}] has a UID [{Uid}] that has been quarantined. Association aborted."));

            Receiving();
            _autoResendTimer = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(_settings.SysResendTimeout, _settings.SysResendTimeout, Self, new AttemptSysMsgRedelivery(),
                    Self);
        }

        private readonly ICancelable _autoResendTimer;

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; set; }

        /// <summary>
        /// Processing of <see cref="Ack"/>s has to be delayed until the UID is discovered after a reconnect. Depending whether the
        /// UID matches the expected one, pending Acks can be processed or must be dropped. It is guaranteed that for any inbound
        /// connections (calling <see cref="CreateWriter"/>) the first message from that connection is <see cref="GotUid"/>, therefore it serves
        /// a separator.
        ///
        /// If we already have an inbound handle then UID is initially confirmed.
        /// (This actor is never restarted.)
        /// </summary>
        public bool UidConfirmed { get; private set; }

        private Deadline _bailoutAt = null;

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                if (ex is IAssociationProblem)
                    return Directive.Escalate;

                _log.Warning("Association with remote system {0} has failed; address is now gated for {1} ms. Reason is: [{2}]", _remoteAddress, _settings.RetryGateClosedFor.TotalMilliseconds, ex);
                UidConfirmed = false; // Need confirmation of UID again

                if ((_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any()) && _bailoutAt == null)
                    _bailoutAt = Deadline.Now + _settings.InitialSysMsgDeliveryTimeout;
                Become(() => Gated(writerTerminated: false, earlyUngateRequested: false));
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                return Directive.Stop;
            });
        }


        private ICancelable _maxSilenceTimer = null;
        private AckedSendBuffer<EndpointManager.Send> _resendBuffer;
        private long _seqCounter;

        private IActorRef _writer;

        private void Reset()
        {
            _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(_settings.SysMsgBufferSize);
            _seqCounter = 0L;
            _bailoutAt = null;
        }

        private SeqNo NextSeq()
        {
            var tmp = _seqCounter;
            _seqCounter++;
            return new SeqNo(tmp);
        }

        #region ActorBase methods and Behaviors

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            // All remaining messages in the buffer has to be delivered to dead letters. It is important to clear the sequence
            // number otherwise deadLetters will ignore it to avoid reporting system messages as dead letters while they are
            // still possibly retransmitted.
            // Such a situation may arise when the EndpointWriter is shut down, and all of its mailbox contents are delivered
            // to dead letters. These messages should be ignored, as they still live in resendBuffer and might be delivered to
            // the remote system later.
            foreach (var msg in _resendBuffer.Nacked.Concat(_resendBuffer.NonAcked))
            {
                Context.System.DeadLetters.Tell(msg.Copy(opt: null));
            }

            _log.Info("Removing receive buffers for [{0}]->[{1}]", _localAddress, _remoteAddress);
            _receiveBuffers.TryRemove(new EndpointManager.Link(_localAddress, _remoteAddress), out _);
            _autoResendTimer.Cancel();
            _maxSilenceTimer?.Cancel();
        }

        /// <summary>
        /// N/A
        /// </summary>
        /// <param name="reason">N/A</param>
        /// <exception cref="IllegalActorStateException">
        /// This exception is thrown automatically since <see cref="ReliableDeliverySupervisor"/> must not be restarted.
        /// </exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("BUG: ReliableDeliverySupervisor has been attempted to be restarted. This must not happen.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Receiving()
        {
            Receive<EndpointWriter.FlushAndStop>(flush =>
            {
                //Trying to serve until our last breath
                ResendAll();
                _writer.Tell(EndpointWriter.FlushAndStop.Instance);
                Become(FlushWait);
            });
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, or send a GotUid
            Receive<EndpointManager.Send>(send => HandleSend(send));
            Receive<Ack>(ack =>
            {
                // If we are not sure about the UID just ignore the ack. Ignoring is fine.
                if (UidConfirmed)
                {
                    try
                    {
                        _resendBuffer = _resendBuffer.Acknowledge(ack);
                    }
                    catch (Exception ex)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new IllegalStateException($"Error encountered while processing system message acknowledgement buffer: {_resendBuffer} ack: {ack}", ex));
                    }

                    ResendNacked();
                }
            });
            Receive<AttemptSysMsgRedelivery>(sysmsg =>
            {
                if (UidConfirmed) ResendAll();
            });
            Receive<Terminated>(terminated =>
            {
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                    Context.System.Scheduler.ScheduleTellOnce(_settings.SysResendTimeout, Self,
                        new AttemptSysMsgRedelivery(), Self);
                GoToIdle();
            });
            Receive<GotUid>(g =>
            {
                _bailoutAt = null;
                Context.Parent.Tell(g);
                //New system that has the same address as the old - need to start from fresh state
                UidConfirmed = true;
                if (Uid.HasValue && Uid.Value != g.Uid) Reset();
                Uid = g.Uid;
                ResendAll();
            });
            Receive<EndpointWriter.StopReading>(stopped =>
            {
                _writer.Forward(stopped); //forward the request
            });
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        private void GoToIdle()
        {
            if (_maxSilenceTimer == null)
                _maxSilenceTimer =
                    Context.System.Scheduler.ScheduleTellOnceCancelable(_settings.QuarantineSilentSystemTimeout, Self,
                        TooLongIdle.Instance, Self);
            Become(IdleBehavior);
        }

        private void GoToActive()
        {
            _maxSilenceTimer?.Cancel();
            _maxSilenceTimer = null;
            Become(Receiving);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="writerTerminated">TBD</param>
        /// <param name="earlyUngateRequested">TBD</param>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Gated(bool writerTerminated, bool earlyUngateRequested)
        {
            Receive<Terminated>(terminated =>
            {
                if (!writerTerminated)
                {
                    if (earlyUngateRequested)
                        Self.Tell(new Ungate());
                    else
                    {
                        Context.System.Scheduler.ScheduleTellOnce(_settings.RetryGateClosedFor, Self, new Ungate(), Self);
                    }
                }

                Become(() => Gated(true, earlyUngateRequested));
            });
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<Ungate>(ungate =>
            {
                if (!writerTerminated)
                {
                    // Ungate was sent from EndpointManager, but we must wait for Terminated first.
                    Become(() => Gated(false, true));
                }
                else if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                {
                    // If we talk to a system we have not talked to before (or has given up talking to in the past) stop
                    // system delivery attempts after the specified time. This act will drop the pending system messages and gate the
                    // remote address at the EndpointManager level stopping this actor. In case the remote system becomes reachable
                    // again it will be immediately quarantined due to out-of-sync system message buffer and becomes quarantined.
                    // In other words, this action is safe.
                    if (_bailoutAt != null && _bailoutAt.IsOverdue)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new TimeoutException("Delivery of system messages timed out and they were dropped"));
                    }

                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
                else
                {
                    GoToIdle();
                }
            });
            Receive<AttemptSysMsgRedelivery>(redelivery => { }); // Ignore
            Receive<EndpointManager.Send>(send => send.Message is ISystemMessage, send => TryBuffer(send.Copy(NextSeq())));
            Receive<EndpointManager.Send>(send => Context.System.DeadLetters.Tell(send));
            Receive<EndpointWriter.FlushAndStop>(flush => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
                Sender.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void IdleBehavior()
        {
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<EndpointManager.Send>(send =>
            {
                _writer = CreateWriter();
                //Resending will be triggered by the incoming GotUid message after the connection finished
                HandleSend(send);
                GoToActive();
            });

            Receive<AttemptSysMsgRedelivery>(sys =>
            {
                if (_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any())
                {
                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
            });
            Receive<TooLongIdle>(idle =>
            {
                HandleTooLongIdle();
            });
            Receive<EndpointWriter.FlushAndStop>(stop => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void FlushWait()
        {
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, which will do the inbound connection unstashing
            Receive<Terminated>(terminated =>
            {
                //Clear buffer to prevent sending system messages to dead letters -- at this point we are shutting down and
                //don't know if they were properly delivered or not
                _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(0);
                Context.Stop(Self);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion

        #region Static methods and Internal Message Types

        /// <summary>
        /// TBD
        /// </summary>
        public class AttemptSysMsgRedelivery { }

        /// <summary>
        /// TBD
        /// </summary>
        public class Ungate { }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class GotUid
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="uid">TBD</param>
            /// <param name="remoteAddress">TBD</param>
            public GotUid(int uid, Address remoteAddress)
            {
                Uid = uid;
                RemoteAddress = remoteAddress;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public int Uid { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public Address RemoteAddress { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReliableDeliverySupervisorProps(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    string dispatcher)
        {
            return
                Props.Create(
                    () =>
                        new ReliableDeliverySupervisor(handleOrActive, localAddress, remoteAddress, refuseUid, transport,
                            settings, codec, receiveBuffers))
                    .WithDispatcher(dispatcher);
        }

        #endregion

        // Extracted this method to solve a compiler issue with `Receive<TooLongIdle>`
        private void HandleTooLongIdle()
        {
            throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                new TimeoutException("Delivery of system messages timed out and they were dropped"));
        }

        private void HandleSend(EndpointManager.Send send)
        {
            if (send.Message is ISystemMessage)
            {
                var sequencedSend = send.Copy(NextSeq());
                TryBuffer(sequencedSend);
                // If we have not confirmed the remote UID we cannot transfer the system message at this point just buffer it.
                // GotUid will kick ResendAll() causing the messages to be properly written.
                // Flow control by not sending more when we already have many outstanding.
                if (UidConfirmed && _resendBuffer.NonAcked.Count <= _settings.SysResendLimit) _writer.Tell(sequencedSend);
            }
            else
            {
                _writer.Tell(send);
            }
        }

        private void ResendNacked()
        {
            _resendBuffer.Nacked.ForEach(nacked => _writer.Tell(nacked));
        }

        private void ResendAll()
        {
            ResendNacked();
            _resendBuffer.NonAcked.Take(_settings.SysResendLimit).ForEach(nonacked => _writer.Tell(nonacked));
        }

        private void TryBuffer(EndpointManager.Send s)
        {
            try
            {
                _resendBuffer = _resendBuffer.Buffer(s);
            }
            catch (Exception ex)
            {
                throw new HopelessAssociation(_localAddress, _remoteAddress, Uid, ex);
            }
        }

        #region Writer create

        private IActorRef CreateWriter()
        {
            var writer =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointWriter.EndpointWriterProps(_currentHandle, _localAddress, _remoteAddress, _refuseUid, _transport,
                            _settings, new AkkaPduProtobuffCodec(Context.System), _receiveBuffers, Self)
                            .WithDeploy(Deploy.Local)),
                    "endpointWriter");
            Context.Watch(writer);
            return writer;
        }

        #endregion

    }

    /// <summary>
    /// Abstract base class for <see cref="EndpointReader"/> classes
    /// </summary>
    internal abstract class EndpointActor : ReceiveActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        protected readonly Address LocalAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected Address RemoteAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected RemoteSettings Settings;
        /// <summary>
        /// TBD
        /// </summary>
        protected AkkaProtocolTransport Transport;

        private readonly ILoggingAdapter _log = Context.GetLogger();

        /// <summary>
        /// TBD
        /// </summary>
        protected readonly EventPublisher EventPublisher;
        /// <summary>
        /// TBD
        /// </summary>
        protected bool Inbound { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        protected EndpointActor(Address localAddress, Address remoteAddress, AkkaProtocolTransport transport,
            RemoteSettings settings)
        {
            EventPublisher = new EventPublisher(Context.System, _log, Logging.LogLevelFor(settings.RemoteLifecycleEventsLogLevel));
            LocalAddress = localAddress;
            RemoteAddress = remoteAddress;
            Transport = transport;
            Settings = settings;
        }

        #region Event publishing methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="ex">TBD</param>
        /// <param name="level">TBD</param>
        protected void PublishError(Exception ex, LogLevel level)
        {
            TryPublish(new AssociationErrorEvent(ex, LocalAddress, RemoteAddress, Inbound, level));
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void PublishDisassociated()
        {
            TryPublish(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        private void TryPublish(RemotingLifecycleEvent ev)
        {
            try
            {
                EventPublisher.NotifyListeners(ev);
            }
            catch (Exception ex)
            {
                _log.Error(ex, "Unable to publish error event to EventStream");
            }
        }

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointWriter : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointWriter(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                        base(localAddress, remoteAddress, transport, settings)
        {
            _refuseUid = refuseUid;
            _codec = codec;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _system = Context.System.AsInstanceOf<ExtendedActorSystem>();
            _provider = RARP.For(Context.System).Provider;
            _msgDispatcher = new DefaultMessageDispatcher(_system, _provider, _log);
            _receiveBuffers = receiveBuffers;
            Inbound = handleOrActive != null;
            _ackDeadline = NewAckDeadline();
            _handle = handleOrActive;
            _remoteMetrics = RemoteMetricsExtension.Create(Context.System.AsInstanceOf<ExtendedActorSystem>());

            if (_handle == null)
            {
                Initializing();
            }
            else
            {
                Writing();
            }
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly int? _refuseUid;
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private DisassociateInfo _stopReason = DisassociateInfo.Unknown;

        private IActorRef _reader;
        private readonly AtomicCounter _readerId = new AtomicCounter(0);
        private readonly IInboundMessageDispatcher _msgDispatcher;

        private Ack _lastAck = null;
        private Deadline _ackDeadline;
        private AkkaProtocolHandle _handle;

        private ICancelable _ackIdleTimerCancelable;

        // Use an internal buffer instead of Stash for efficiency
        // stash/unstashAll is slow when many messages are stashed
        // IMPORTANT: sender is not stored, so .Sender and forward must not be used in EndpointWriter
        private readonly LinkedList<object> _buffer = new LinkedList<object>();

        //buffer for IPriorityMessages - ensures that heartbeats get delivered before user-defined messages
        private readonly LinkedList<EndpointManager.Send> _prioBuffer = new LinkedList<EndpointManager.Send>();
        private long _largeBufferLogTimestamp = MonotonicClock.GetNanos();

        private readonly IRemoteMetrics _remoteMetrics;

        #region ActorBase methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel, false);
                return Directive.Escalate;
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="reason">TBD</param>
        /// <exception cref="IllegalActorStateException">TBD</exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("EndpointWriter must not be restarted");
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_handle == null)
            {
                var self = Self;
                AssociateAsync().PipeTo(self);
            }
            else
            {
                _reader = StartReadEndpoint(_handle);
            }

            var ackIdleInterval = new TimeSpan(Settings.SysMsgAckTimeout.Ticks / 2);
            _ackIdleTimerCancelable = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(ackIdleInterval, ackIdleInterval, Self, AckIdleCheckTimer.Instance, Self);
        }

        private async Task<object> AssociateAsync()
        {
            try
            {
                return new Handle(await Transport.Associate(RemoteAddress, _refuseUid).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                return new Status.Failure(e.InnerException ?? e);
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            _ackIdleTimerCancelable.CancelIfNotNull();

            foreach (var msg in _prioBuffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _prioBuffer.Clear();

            foreach (var msg in _buffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _buffer.Clear();

            if (_handle != null) _handle.Disassociate(_stopReason);
            EventPublisher.NotifyListeners(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        #endregion

        #region Receives

        private void Initializing()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<Status.Failure>(failure =>
            {
                if (failure.Cause is InvalidAssociationException)
                {
                    if (failure.Cause.InnerException == null)
                    {
                        PublishAndThrow(new InvalidAssociation(failure.Cause.Message, LocalAddress, RemoteAddress), LogLevel.WarningLevel);
                    }
                }

                PublishAndThrow(new InvalidAssociation($"Association failed with {RemoteAddress}", LocalAddress, RemoteAddress, failure.Cause), LogLevel.WarningLevel);
            });
            Receive<Handle>(handle =>
            {
                // Assert handle == None?
                Context.Parent.Tell(
                    new ReliableDeliverySupervisor.GotUid((int)handle.ProtocolHandle.HandshakeInfo.Uid, RemoteAddress));
                _handle = handle.ProtocolHandle;
                _reader = StartReadEndpoint(_handle);
                EventPublisher.NotifyListeners(new AssociatedEvent(LocalAddress, RemoteAddress, Inbound));
                BecomeWritingOrSendBufferedMessages();
            });
        }

        private void Buffering()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<BackoffTimer>(backoff => SendBufferedMessages());
            Receive<FlushAndStop>(stop =>
            {
                _buffer.AddLast(stop); //Flushing is postponed after the pending writes
                Context.System.Scheduler.ScheduleTellOnce(Settings.FlushWait, Self, FlushAndStopTimeout.Instance, Self);
            });
            Receive<FlushAndStopTimeout>(timeout =>
            {
                // enough, ready to flush
                DoFlushAndStop();
            });
        }

        private void Writing()
        {
            Receive<EndpointManager.Send>(s =>
            {
                if (!WriteSend(s))
                {
                    if (s.Seq == null) EnqueueInBuffer(s);
                    ScheduleBackoffTimer();
                    Become(Buffering);
                }
            });
            Receive<FlushAndStop>(flush => DoFlushAndStop());
            Receive<AckIdleCheckTimer>(ack =>
            {
                if (_ackDeadline.IsOverdue)
                {
                    TrySendPureAck();
                }
            });
        }

        private void Handoff()
        {
            Receive<Terminated>(terminated =>
            {
                _reader = StartReadEndpoint(_handle);
                BecomeWritingOrSendBufferedMessages();
            });
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        protected override void Unhandled(object message)
        {
            if (message is Terminated)
            {
                var t = message as Terminated;
                if (_reader == null || t.ActorRef.Equals(_reader))
                {
                    PublishAndThrow(new EndpointDisassociatedException("Disassociated"), LogLevel.DebugLevel);
                }
            }
            else if (message is StopReading)
            {
                var stop = message as StopReading;
                if (_reader != null)
                {
                    _reader.Tell(stop, stop.ReplyTo);
                }
                else
                {
                    // initializing, buffer and take care of it later when buffer is sent
                    EnqueueInBuffer(message);
                }
            }
            else if (message is TakeOver)
            {
                var takeover = message as TakeOver;

                // Shutdown old reader
                _handle.Disassociate();
                _handle = takeover.ProtocolHandle;
                takeover.ReplyTo.Tell(new TookOver(Self, _handle));
                Become(Handoff);
            }
            else if (message is FlushAndStop)
            {
                _stopReason = DisassociateInfo.Shutdown;
                Context.Stop(Self);
            }
            else if (message is OutboundAck)
            {
                var ack = message as OutboundAck;
                _lastAck = ack.Ack;
                if (_ackDeadline.IsOverdue)
                    TrySendPureAck();
            }
            else if (message is AckIdleCheckTimer || message is FlushAndStopTimeout || message is BackoffTimer)
            {
                //ignore
            }
            else
            {
                base.Unhandled(message);
            }
        }

        #endregion

        #region Internal methods

        private Deadline NewAckDeadline()
        {
            return Deadline.Now + Settings.SysMsgAckTimeout;
        }

        private void PublishAndThrow(Exception reason, LogLevel level, bool needToThrow = true)
        {
            reason.Match()
                .With<EndpointDisassociatedException>(endpoint => PublishDisassociated())
                .With<ShutDownAssociation>(shutdown => { }) // don't log an error for planned shutdowns
                .Default(msg => PublishError(reason, level));

            if (needToThrow)
            {
                throw reason;
            }
        }

        private IActorRef StartReadEndpoint(AkkaProtocolHandle handle)
        {
            var newReader =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointReader.ReaderProps(LocalAddress, RemoteAddress, Transport, Settings, _codec, _msgDispatcher,
                            Inbound, (int)handle.HandshakeInfo.Uid, _receiveBuffers, _reliableDeliverySupervisor)
                            .WithDeploy(Deploy.Local)),
                    string.Format("endpointReader-{0}-{1}", AddressUrlEncoder.Encode(RemoteAddress), _readerId.Next()));
            Context.Watch(newReader);
            handle.ReadHandlerSource.SetResult(new ActorHandleEventListener(newReader));
            return newReader;
        }

        /// <summary>
        /// Serializes the outbound message going onto the wire.
        /// </summary>
        /// <param name="msg">The C# object we intend to serialize.</param>
        /// <returns>The Akka.NET envelope containing the serialized message and addressing information.</returns>
        /// <remarks>Differs from JVM implementation due to Scala implicits.</remarks>
        private SerializedMessage SerializeMessage(object msg)
        {
            if (_handle == null)
            {
                throw new EndpointException("Internal error: No handle was present during serialization of outbound message.");
            }
            return MessageSerializer.Serialize(_system, _handle.LocalAddress, msg);
        }

        private int _writeCount = 0;
        private int _maxWriteCount = MaxWriteCount;
        private long _adaptiveBackoffNanos = 1000000L; // 1 ms
        private bool _fullBackoff = false;

        // FIXME remove these counters when tuning/testing is completed
        private int _fullBackoffCount = 1;
        private int _smallBackoffCount = 0;
        private int _noBackoffCount = 0;

        private void AdjustAdaptiveBackup()
        {
            _maxWriteCount = Math.Max(_writeCount, _maxWriteCount);
            if (_writeCount <= SendBufferBatchSize)
            {
                _fullBackoff = true;
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.2), MaxAdaptiveBackoffNanos);
            }
            else if (_writeCount >= _maxWriteCount * 0.6)
            {
                _adaptiveBackoffNanos = Math.Max(Convert.ToInt64(_adaptiveBackoffNanos * 0.9), MinAdaptiveBackoffNanos);
            }
            else if (_writeCount <= _maxWriteCount * 0.2)
            {
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.1), MaxAdaptiveBackoffNanos);
            }
            _writeCount = 0;
        }

        private void ScheduleBackoffTimer()
        {
            if (_fullBackoff)
            {
                _fullBackoffCount += 1;
                _fullBackoff = false;
                Context.System.Scheduler.ScheduleTellOnce(Settings.BackoffPeriod, Self, BackoffTimer.Instance, Self, null);
            }
            else
            {
                _smallBackoffCount += 1;
                var backoffDeadlineNanoTime = TimeSpan.FromTicks(_adaptiveBackoffNanos.ToTicks());

                Context.System.Scheduler.ScheduleTellOnce(backoffDeadlineNanoTime, Self, BackoffTimer.Instance, Self);
            }
        }

        private void DoFlushAndStop()
        {
            //Try to send last Ack message
            TrySendPureAck();
            _stopReason = DisassociateInfo.Shutdown;
            Context.Stop(Self);
        }

        private void TrySendPureAck()
        {
            if (_handle != null && _lastAck != null)
            {
                if (_handle.Write(_codec.ConstructPureAck(_lastAck)))
                {
                    _ackDeadline = NewAckDeadline();
                    _lastAck = null;
                }
            }
        }

        private void EnqueueInBuffer(object message)
        {
            var send = message as EndpointManager.Send;
            if (send != null && send.Message is IPriorityMessage)
                _prioBuffer.AddLast(send);
            else if (send != null && send.Message is ActorSelectionMessage &&
                     send.Message.AsInstanceOf<ActorSelectionMessage>().Message is IPriorityMessage)
            {
                _prioBuffer.AddLast(send);
            }
            else
            {
                _buffer.AddLast(message);
            }
        }

        private void BecomeWritingOrSendBufferedMessages()
        {
            if (!_buffer.Any())
            {
                Become(Writing);
            }
            else
            {
                Become(Buffering);
                SendBufferedMessages();
            }
        }

        private bool WriteSend(EndpointManager.Send send)
        {
            try
            {
                if (_handle == null)
                    throw new EndpointException(
                        "Internal error: Endpoint is in state Writing, but no association handle is present.");
                if (_provider.RemoteSettings.LogSend)
                {
                    _log.Debug("RemoteMessage: {0} to [{1}]<+[{2}] from [{3}]", send.Message,
                        send.Recipient, send.Recipient.Path, send.SenderOption ?? _system.DeadLetters);
                }

                var pdu = _codec.ConstructMessage(send.Recipient.LocalAddressToUse, send.Recipient,
                    this.SerializeMessage(send.Message), send.SenderOption, send.Seq, _lastAck);

                _remoteMetrics.LogPayloadBytes(send.Message, pdu.Length);

                if (pdu.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload sent to {0}: max allowed size {1} bytes, actual size of encoded {2} was {3} bytes.",
                            send.Recipient,
                            Transport.MaximumPayloadBytes,
                            send.Message.GetType(),
                            pdu.Length));
                    _log.Error(reason, "Transient association error (association remains live)");
                    return true;
                }
                else
                {
                    var ok = _handle.Write(pdu);

                    if (ok)
                    {
                        _ackDeadline = NewAckDeadline();
                        _lastAck = null;
                        return true;
                    }
                }
                return false;
            }
            catch (SerializationException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (ArgumentException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (EndpointException ex)
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel);
            }
            catch (Exception ex)
            {
                PublishAndThrow(new EndpointException("Failed to write message to the transport", ex),
                    LogLevel.ErrorLevel);
            }

            return false;
        }

        private void SendBufferedMessages()
        {
            bool SendDelegate(object msg)
            {
                switch (msg)
                {
                    case EndpointManager.Send s:
                        return WriteSend(s);
                    case FlushAndStop f:
                        DoFlushAndStop();
                        return false;
                    case StopReading stop:
                        _reader?.Tell(stop, stop.ReplyTo);
                        return true;
                    default:
                        return true;
                }
            }

            bool WriteLoop(int count)
            {
                if (count > 0 && _buffer.Any())
                {
                    if (SendDelegate(_buffer.First.Value))
                    {
                        _buffer.RemoveFirst();
                        _writeCount += 1;
                        return WriteLoop(count - 1);
                    }
                    return false;
                }

                return true;
            }

            bool WritePrioLoop()
            {
                if (!_prioBuffer.Any()) return true;
                if (WriteSend(_prioBuffer.First.Value))
                {
                    _prioBuffer.RemoveFirst();
                    return WritePrioLoop();
                }
                return false;
            }

            var size = _buffer.Count;

            var ok = WritePrioLoop() && WriteLoop(SendBufferBatchSize);
            if (!_buffer.Any() && !_prioBuffer.Any())
            {
                // FIXME remove this when testing/tuning is completed
                if (_log.IsDebugEnabled)
                {
                    _log.Debug("Drained buffer with maxWriteCount: {0}, fullBackoffCount: {1}," +
                               "smallBackoffCount: {2}, noBackoffCount: {3}," +
                               "adaptiveBackoff: {4}", _maxWriteCount, _fullBackoffCount, _smallBackoffCount, _noBackoffCount, _adaptiveBackoffNanos / 1000);
                }
                _fullBackoffCount = 1;
                _smallBackoffCount = 0;
                _noBackoffCount = 0;
                _writeCount = 0;
                _maxWriteCount = MaxWriteCount;
                Become(Writing);
            }
            else if (ok)
            {
                _noBackoffCount += 1;
                Self.Tell(BackoffTimer.Instance);
            }
            else
            {
                if (size > Settings.LogBufferSizeExceeding)
                {
                    var now = MonotonicClock.GetNanos();
                    if (now - _largeBufferLogTimestamp >= LogBufferSizeInterval)
                    {
                        _log.Warning("[{0}] buffered messages in EndpointWriter for [{1}]. You should probably implement flow control to avoid flooding the remote connection.", size, RemoteAddress);
                        _largeBufferLogTimestamp = now;
                    }
                }
            }

            AdjustAdaptiveBackup();
            ScheduleBackoffTimer();
        }

        #endregion

        #region Static methods and Internal messages

        // These settings are not configurable because wrong configuration will break the auto-tuning
        private const int SendBufferBatchSize = 5;
        private const long MinAdaptiveBackoffNanos = 300000L; // 0.3 ms
        private const long MaxAdaptiveBackoffNanos = 2000000L; // 2 ms
        private const long LogBufferSizeInterval = 5000000000L; // 5 s, in nanoseconds
        private const int MaxWriteCount = 50;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props EndpointWriterProps(AkkaProtocolHandle handleOrActive, Address localAddress,
                    Address remoteAddress, int? refuseUid, AkkaProtocolTransport transport, RemoteSettings settings,
                    AkkaPduCodec codec, ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers, IActorRef reliableDeliverySupervisor = null)
        {
            return Props.Create(
                () =>
                    new EndpointWriter(handleOrActive, localAddress, remoteAddress, refuseUid, transport, settings,
                        codec, receiveBuffers, reliableDeliverySupervisor));
        }

        /// <summary>
        /// This message signals that the current association maintained by the local <see cref="EndpointWriter"/> and
        /// <see cref="EndpointReader"/> is to be overridden by a new inbound association. This is needed to avoid parallel inbound
        /// associations from the same remote endpoint: when a parallel inbound association is detected, the old one is removed and the new
        /// one is used instead.
        /// </summary>
        public sealed class TakeOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// Create a new TakeOver command
            /// </summary>
            /// <param name="protocolHandle">The handle of the new association</param>
            /// <param name="replyTo">TBD</param>
            public TakeOver(AkkaProtocolHandle protocolHandle, IActorRef replyTo)
            {
                ProtocolHandle = protocolHandle;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class TookOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="protocolHandle">TBD</param>
            public TookOver(IActorRef writer, AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class BackoffTimer
        {
            private BackoffTimer() { }
            private static readonly BackoffTimer _instance = new BackoffTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static BackoffTimer Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class FlushAndStop
        {
            private FlushAndStop() { }
            private static readonly FlushAndStop _instance = new FlushAndStop();
            /// <summary>
            /// TBD
            /// </summary>
            public static FlushAndStop Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class AckIdleCheckTimer
        {
            private AckIdleCheckTimer() { }
            private static readonly AckIdleCheckTimer _instance = new AckIdleCheckTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static AckIdleCheckTimer Instance { get { return _instance; } }
        }

        private sealed class FlushAndStopTimeout
        {
            private FlushAndStopTimeout() { }
            private static readonly FlushAndStopTimeout _instance = new FlushAndStopTimeout();
            public static FlushAndStopTimeout Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Handle : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="protocolHandle">TBD</param>
            public Handle(AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StopReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="replyTo">TBD</param>
            public StopReading(IActorRef writer, IActorRef replyTo)
            {
                Writer = writer;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StoppedReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            public StoppedReading(IActorRef writer)
            {
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class OutboundAck
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="ack">TBD</param>
            public OutboundAck(Ack ack)
            {
                Ack = ack;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public Ack Ack { get; private set; }
        }

        private const string AckIdleTimerName = "AckIdleTimer";

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointReader : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="msgDispatch">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointReader(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher msgDispatch,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                    base(localAddress, remoteAddress, transport, settings)
        {
            _receiveBuffers = receiveBuffers;
            _msgDispatch = msgDispatch;
            Inbound = inbound;
            _uid = uid;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _codec = codec;
            _provider = RARP.For(Context.System).Provider;
            Reading();
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private readonly int _uid;
        private readonly IInboundMessageDispatcher _msgDispatch;

        private readonly IRemoteActorRefProvider _provider;
        private AckedReceiveBuffer<Message> _ackedReceiveBuffer = new AckedReceiveBuffer<Message>();

        #region ActorBase overrides

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_receiveBuffers.TryGetValue(new EndpointManager.Link(LocalAddress, RemoteAddress), out var resendState))
            {
                if(resendState.Uid == _uid)
                {
                    _ackedReceiveBuffer = resendState.Buffer;
                    DeliverAndAck();
                }
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            SaveState();
        }

        private void Reading()
        {
           
            Receive<InboundPayload>(inbound =>
            {
                var payload = inbound.Payload;
                if (payload.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload received: max allowed size {0} bytes, actual size {1} bytes.",
                            Transport.MaximumPayloadBytes,
                            payload.Length));
                    _log.Error(reason, "Transient error while reading from association (association remains live)");
                }
                else
                {
                    var ackAndMessage = TryDecodeMessageAndAck(payload);
                    if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                        _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
                    if (ackAndMessage.MessageOption != null)
                    {
                        if (ackAndMessage.MessageOption.ReliableDeliveryEnabled)
                        {
                            _ackedReceiveBuffer = _ackedReceiveBuffer.Receive(ackAndMessage.MessageOption);
                            DeliverAndAck();
                        }
                        else
                        {
                            try
                            {
                                _msgDispatch.Dispatch(ackAndMessage.MessageOption.Recipient,
                                    ackAndMessage.MessageOption.RecipientAddress,
                                    ackAndMessage.MessageOption.SerializedMessage,
                                    ackAndMessage.MessageOption.SenderOptional);
                            }
                            catch (SerializationException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (ArgumentException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (Exception e)
                            {
                                throw;
                            }
                        }
                    }
                }
            });
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                SaveState();
                Become(NotReading);
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        private void LogTransientSerializationError(Message msg, Exception error)
        {
            var sm = msg.SerializedMessage;
            _log.Warning(
              "Serializer not defined for message with serializer id [{0}] and manifest [{1}]. " +
                "Transient association error (association remains live). {2}",
              sm.SerializerId,
              sm.MessageManifest.IsEmpty ? "" : sm.MessageManifest.ToStringUtf8(),
              error.Message);
        }

        private void NotReading()
        {
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<InboundPayload>(payload =>
            {
                var ackAndMessage = TryDecodeMessageAndAck(payload.Payload);
                if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                    _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion



        #region Lifecycle event handlers

        private void SaveState()
        {
            EndpointManager.ResendState Merge(EndpointManager.ResendState current,
                EndpointManager.ResendState oldState)
            {
                if (current.Uid == oldState.Uid) return new EndpointManager.ResendState(_uid, oldState.Buffer.MergeFrom(current.Buffer));
                return current;
            }

            void UpdateSavedState(EndpointManager.Link key, EndpointManager.ResendState expectedState)
            {
                if (expectedState == null)
                {
                    if (!_receiveBuffers.TryAdd(key, new EndpointManager.ResendState(_uid, _ackedReceiveBuffer)))
                    {
                        _receiveBuffers.TryGetValue(key, out var prevValue);
                        UpdateSavedState(key, prevValue);
                    }
                }
                else if (!_receiveBuffers.TryUpdate(key,
                    Merge(new EndpointManager.ResendState(_uid, _ackedReceiveBuffer), expectedState), expectedState))
                {
                    _receiveBuffers.TryGetValue(key, out var prevValue);
                    UpdateSavedState(key, prevValue);
                }
            }

            var k = new EndpointManager.Link(LocalAddress, RemoteAddress);
            UpdateSavedState(k, !_receiveBuffers.TryGetValue(k, out var previousValue) ? null : previousValue);
        }

        private void HandleDisassociated(DisassociateInfo info)
        {
            switch (info)
            {
                case DisassociateInfo.Quarantined:
                    throw new InvalidAssociation("The remote system has quarantined this system. No further associations " +
                                                   "to the remote system are possible until this system is restarted.", LocalAddress, RemoteAddress, disassociateInfo: DisassociateInfo.Quarantined);
                case DisassociateInfo.Shutdown:
                    throw new ShutDownAssociation($"The remote system terminated the association because it is shutting down. Shut down address: {RemoteAddress}", LocalAddress, RemoteAddress);
                case DisassociateInfo.Unknown:
                default:
                    Context.Stop(Self);
                    break;
            }
        }

        private void DeliverAndAck()
        {
            var deliverable = _ackedReceiveBuffer.ExtractDeliverable();
            _ackedReceiveBuffer = deliverable.Buffer;

            // Notify writer that some messages can be acked
            Context.Parent.Tell(new EndpointWriter.OutboundAck(deliverable.Ack));
            deliverable.Deliverables.ForEach(msg => _msgDispatch.Dispatch(msg.Recipient, msg.RecipientAddress, msg.SerializedMessage, msg.SenderOptional));
        }

        private AckAndMessage TryDecodeMessageAndAck(ByteString pdu)
        {
            try
            {
                return _codec.DecodeMessage(pdu, _provider, LocalAddress);
            }
            catch (Exception ex)
            {
                throw new EndpointException("Error while decoding incoming Akka PDU", ex);
            }
        }

        #endregion

        #region Static members

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReaderProps(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher dispatcher,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null)
        {
            return
                Props.Create(
                    () =>
                        new EndpointReader(localAddress, remoteAddress, transport, settings, codec, dispatcher, inbound,
                            uid, receiveBuffers, reliableDeliverySupervisor))
                            .WithDispatcher(settings.Dispatcher);
        }

        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Dispatch;
using Akka.Dispatch.SysMsg;
using Akka.Event;
using Akka.Pattern;
using Akka.Remote.Serialization;
using Akka.Remote.Transport;
using Akka.Serialization;
using Akka.Util;
using Akka.Util.Internal;
using Google.Protobuf;
using SerializedMessage = Akka.Remote.Serialization.Proto.Msg.Payload;

namespace Akka.Remote
{
    /// <summary>
    /// INTERNAL API
    /// </summary>
    // ReSharper disable once InconsistentNaming
    internal interface IInboundMessageDispatcher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null);
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class DefaultMessageDispatcher : IInboundMessageDispatcher
    {
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ILoggingAdapter _log;
        private readonly IInternalActorRef _remoteDaemon;
        private readonly RemoteSettings _settings;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="provider">TBD</param>
        /// <param name="log">TBD</param>
        public DefaultMessageDispatcher(ExtendedActorSystem system, IRemoteActorRefProvider provider, ILoggingAdapter log)
        {
            _system = system;
            _provider = provider;
            _log = log;
            _remoteDaemon = provider.RemoteDaemon;
            _settings = provider.RemoteSettings;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        public void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null)
        {
            var payload = MessageSerializer.Deserialize(_system, message);
            var payloadClass = payload?.GetType();
            var sender = senderOption ?? _system.DeadLetters;
            var originalReceiver = recipient.Path;

            // message is intended for the RemoteDaemon, usually a command to create a remote actor
            if (recipient.Equals(_remoteDaemon))
            {
                if (_settings.UntrustedMode) _log.Debug("dropping daemon message in untrusted mode");
                else
                {
                    if (_settings.LogReceive)
                    {
                        var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                        _log.Debug("received daemon message [{0}]", msgLog);
                    }
                    _remoteDaemon.Tell(payload);
                }
            }

            //message is intended for a local recipient
            else if ((recipient is ILocalRef || recipient is RepointableActorRef) && recipient.IsLocal)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                    _log.Debug("received local message [{0}]", msgLog);
                }
                if (payload is ActorSelectionMessage sel)
                {
                    if (_settings.UntrustedMode
                        && (!_settings.TrustedSelectionPaths.Contains(FormatActorPath(sel))
                            || sel.Message is IPossiblyHarmful
                            || !recipient.Equals(_provider.RootGuardian)))
                    {
                        _log.Debug(
                            "operating in UntrustedMode, dropping inbound actor selection to [{0}], allow it" +
                            "by adding the path to 'akka.remote.trusted-selection-paths' in configuration",
                            FormatActorPath(sel));
                    }
                    else
                    {
                        //run the receive logic for ActorSelectionMessage here to make sure it is not stuck on busy user actor
                        ActorSelection.DeliverSelection(recipient, sender, sel);
                    }
                }
                else if (payload is IPossiblyHarmful && _settings.UntrustedMode)
                {
                    _log.Debug("operating in UntrustedMode, dropping inbound IPossiblyHarmful message of type {0}",
                        payload.GetType());
                }
                else if (payload is ISystemMessage systemMessage)
                {
                    recipient.SendSystemMessage(systemMessage);
                }
                else
                {
                    recipient.Tell(payload, sender);
                }
            }

            // message is intended for a remote-deployed recipient
            else if ((recipient is IRemoteRef || recipient is RepointableActorRef) && !recipient.IsLocal &&
                     !_settings.UntrustedMode)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = string.Format("RemoteMessage: {0} to {1}<+{2} from {3}", payload, recipient, originalReceiver, sender);
                    _log.Debug("received remote-destined message {0}", msgLog);
                }
                if (_provider.Transport.Addresses.Contains(recipientAddress))
                {
                    //if it was originally addressed to us but is in fact remote from our point of view (i.e. remote-deployed)
                    recipient.Tell(payload, sender);
                }
                else
                {
                    _log.Error(
                        "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                        payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
                }
            }
            else
            {
                _log.Error(
                    "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                    payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
            }
        }

        private static string FormatActorPath(ActorSelectionMessage sel)
        {
            return "/" + string.Join("/", sel.Elements.Select(x => x.ToString()));
        }
    }

    #region Endpoint Exception Types

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointException : AkkaException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="cause">The exception that is the cause of the current exception.</param>
        public EndpointException(string message, Exception cause = null) : base(message, cause) { }

#if SERIALIZATION
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected EndpointException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal interface IAssociationProblem { }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class ShutDownAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="cause">TBD</param>
        public ShutDownAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal sealed class InvalidAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TbD</param>
        /// <param name="cause">TBD</param>
        /// <param name="disassociateInfo">TBD</param>
        public InvalidAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null, DisassociateInfo? disassociateInfo = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            DisassociationInfo = disassociateInfo;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public DisassociateInfo? DisassociationInfo { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class HopelessAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="cause">TBD</param>
        public HopelessAssociation(Address localAddress, Address remoteAddress, int? uid = null, Exception cause = null)
            : base("Catastrophic association error.", cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            Uid = uid;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointDisassociatedException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointDisassociatedException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointDisassociatedException(string message)
            : base(message)
        {
        }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointAssociationException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointAssociationException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        public EndpointAssociationException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class OversizedPayloadException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OversizedPayloadException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public OversizedPayloadException(string message)
            : base(message)
        {
        }
    }

    #endregion

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class ReliableDeliverySupervisor : ReceiveActor
    {
        #region Internal message classes

        /// <summary>
        /// TBD
        /// </summary>
        public class IsIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly IsIdle Instance = new IsIdle();
            private IsIdle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class Idle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly Idle Instance = new Idle();
            private Idle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class TooLongIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly TooLongIdle Instance = new TooLongIdle();
            private TooLongIdle() { }
        }

        #endregion

        private readonly ILoggingAdapter _log = Context.GetLogger();

        private readonly Address _localAddress;
        private readonly Address _remoteAddress;
        private readonly int? _refuseUid;
        private readonly AkkaProtocolTransport _transport;
        private readonly RemoteSettings _settings;
        private AkkaPduCodec _codec;
        private AkkaProtocolHandle _currentHandle;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        public ReliableDeliverySupervisor(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers)
        {
            _localAddress = localAddress;
            _remoteAddress = remoteAddress;
            _refuseUid = refuseUid;
            _transport = transport;
            _settings = settings;
            _codec = codec;
            _currentHandle = handleOrActive;
            _receiveBuffers = receiveBuffers;
            Reset(); // needs to be called at startup
            _writer = CreateWriter(); // need to create writer at startup
            Uid = handleOrActive != null ? (int?)handleOrActive.HandshakeInfo.Uid : null;
            UidConfirmed = Uid.HasValue && (Uid != _refuseUid);

            if (Uid.HasValue && Uid == _refuseUid)
                throw new HopelessAssociation(localAddress, remoteAddress, Uid,
                    new InvalidOperationException(
                        $"The remote system [{remoteAddress}] has a UID [{Uid}] that has been quarantined. Association aborted."));

            Receiving();
            _autoResendTimer = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(_settings.SysResendTimeout, _settings.SysResendTimeout, Self, new AttemptSysMsgRedelivery(),
                    Self);
        }

        private readonly ICancelable _autoResendTimer;

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; set; }

        /// <summary>
        /// Processing of <see cref="Ack"/>s has to be delayed until the UID is discovered after a reconnect. Depending whether the
        /// UID matches the expected one, pending Acks can be processed or must be dropped. It is guaranteed that for any inbound
        /// connections (calling <see cref="CreateWriter"/>) the first message from that connection is <see cref="GotUid"/>, therefore it serves
        /// a separator.
        ///
        /// If we already have an inbound handle then UID is initially confirmed.
        /// (This actor is never restarted.)
        /// </summary>
        public bool UidConfirmed { get; private set; }

        private Deadline _bailoutAt = null;

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                if (ex is IAssociationProblem)
                    return Directive.Escalate;

                _log.Warning("Association with remote system {0} has failed; address is now gated for {1} ms. Reason is: [{2}]", _remoteAddress, _settings.RetryGateClosedFor.TotalMilliseconds, ex);
                UidConfirmed = false; // Need confirmation of UID again

                if ((_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any()) && _bailoutAt == null)
                    _bailoutAt = Deadline.Now + _settings.InitialSysMsgDeliveryTimeout;
                Become(() => Gated(writerTerminated: false, earlyUngateRequested: false));
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                return Directive.Stop;
            });
        }


        private ICancelable _maxSilenceTimer = null;
        private AckedSendBuffer<EndpointManager.Send> _resendBuffer;
        private long _seqCounter;

        private IActorRef _writer;

        private void Reset()
        {
            _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(_settings.SysMsgBufferSize);
            _seqCounter = 0L;
            _bailoutAt = null;
        }

        private SeqNo NextSeq()
        {
            var tmp = _seqCounter;
            _seqCounter++;
            return new SeqNo(tmp);
        }

        #region ActorBase methods and Behaviors

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            // All remaining messages in the buffer has to be delivered to dead letters. It is important to clear the sequence
            // number otherwise deadLetters will ignore it to avoid reporting system messages as dead letters while they are
            // still possibly retransmitted.
            // Such a situation may arise when the EndpointWriter is shut down, and all of its mailbox contents are delivered
            // to dead letters. These messages should be ignored, as they still live in resendBuffer and might be delivered to
            // the remote system later.
            foreach (var msg in _resendBuffer.Nacked.Concat(_resendBuffer.NonAcked))
            {
                Context.System.DeadLetters.Tell(msg.Copy(opt: null));
            }

            _log.Info("Removing receive buffers for [{0}]->[{1}]", _localAddress, _remoteAddress);
            _receiveBuffers.TryRemove(new EndpointManager.Link(_localAddress, _remoteAddress), out _);
            _autoResendTimer.Cancel();
            _maxSilenceTimer?.Cancel();
        }

        /// <summary>
        /// N/A
        /// </summary>
        /// <param name="reason">N/A</param>
        /// <exception cref="IllegalActorStateException">
        /// This exception is thrown automatically since <see cref="ReliableDeliverySupervisor"/> must not be restarted.
        /// </exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("BUG: ReliableDeliverySupervisor has been attempted to be restarted. This must not happen.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Receiving()
        {
            Receive<EndpointWriter.FlushAndStop>(flush =>
            {
                //Trying to serve until our last breath
                ResendAll();
                _writer.Tell(EndpointWriter.FlushAndStop.Instance);
                Become(FlushWait);
            });
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, or send a GotUid
            Receive<EndpointManager.Send>(send => HandleSend(send));
            Receive<Ack>(ack =>
            {
                // If we are not sure about the UID just ignore the ack. Ignoring is fine.
                if (UidConfirmed)
                {
                    try
                    {
                        _resendBuffer = _resendBuffer.Acknowledge(ack);
                    }
                    catch (Exception ex)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new IllegalStateException($"Error encountered while processing system message acknowledgement buffer: {_resendBuffer} ack: {ack}", ex));
                    }

                    ResendNacked();
                }
            });
            Receive<AttemptSysMsgRedelivery>(sysmsg =>
            {
                if (UidConfirmed) ResendAll();
            });
            Receive<Terminated>(terminated =>
            {
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                    Context.System.Scheduler.ScheduleTellOnce(_settings.SysResendTimeout, Self,
                        new AttemptSysMsgRedelivery(), Self);
                GoToIdle();
            });
            Receive<GotUid>(g =>
            {
                _bailoutAt = null;
                Context.Parent.Tell(g);
                //New system that has the same address as the old - need to start from fresh state
                UidConfirmed = true;
                if (Uid.HasValue && Uid.Value != g.Uid) Reset();
                Uid = g.Uid;
                ResendAll();
            });
            Receive<EndpointWriter.StopReading>(stopped =>
            {
                _writer.Forward(stopped); //forward the request
            });
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        private void GoToIdle()
        {
            if (_maxSilenceTimer == null)
                _maxSilenceTimer =
                    Context.System.Scheduler.ScheduleTellOnceCancelable(_settings.QuarantineSilentSystemTimeout, Self,
                        TooLongIdle.Instance, Self);
            Become(IdleBehavior);
        }

        private void GoToActive()
        {
            _maxSilenceTimer?.Cancel();
            _maxSilenceTimer = null;
            Become(Receiving);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="writerTerminated">TBD</param>
        /// <param name="earlyUngateRequested">TBD</param>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Gated(bool writerTerminated, bool earlyUngateRequested)
        {
            Receive<Terminated>(terminated =>
            {
                if (!writerTerminated)
                {
                    if (earlyUngateRequested)
                        Self.Tell(new Ungate());
                    else
                    {
                        Context.System.Scheduler.ScheduleTellOnce(_settings.RetryGateClosedFor, Self, new Ungate(), Self);
                    }
                }

                Become(() => Gated(true, earlyUngateRequested));
            });
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<Ungate>(ungate =>
            {
                if (!writerTerminated)
                {
                    // Ungate was sent from EndpointManager, but we must wait for Terminated first.
                    Become(() => Gated(false, true));
                }
                else if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                {
                    // If we talk to a system we have not talked to before (or has given up talking to in the past) stop
                    // system delivery attempts after the specified time. This act will drop the pending system messages and gate the
                    // remote address at the EndpointManager level stopping this actor. In case the remote system becomes reachable
                    // again it will be immediately quarantined due to out-of-sync system message buffer and becomes quarantined.
                    // In other words, this action is safe.
                    if (_bailoutAt != null && _bailoutAt.IsOverdue)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new TimeoutException("Delivery of system messages timed out and they were dropped"));
                    }

                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
                else
                {
                    GoToIdle();
                }
            });
            Receive<AttemptSysMsgRedelivery>(redelivery => { }); // Ignore
            Receive<EndpointManager.Send>(send => send.Message is ISystemMessage, send => TryBuffer(send.Copy(NextSeq())));
            Receive<EndpointManager.Send>(send => Context.System.DeadLetters.Tell(send));
            Receive<EndpointWriter.FlushAndStop>(flush => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
                Sender.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void IdleBehavior()
        {
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<EndpointManager.Send>(send =>
            {
                _writer = CreateWriter();
                //Resending will be triggered by the incoming GotUid message after the connection finished
                HandleSend(send);
                GoToActive();
            });

            Receive<AttemptSysMsgRedelivery>(sys =>
            {
                if (_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any())
                {
                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
            });
            Receive<TooLongIdle>(idle =>
            {
                HandleTooLongIdle();
            });
            Receive<EndpointWriter.FlushAndStop>(stop => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void FlushWait()
        {
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, which will do the inbound connection unstashing
            Receive<Terminated>(terminated =>
            {
                //Clear buffer to prevent sending system messages to dead letters -- at this point we are shutting down and
                //don't know if they were properly delivered or not
                _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(0);
                Context.Stop(Self);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion

        #region Static methods and Internal Message Types

        /// <summary>
        /// TBD
        /// </summary>
        public class AttemptSysMsgRedelivery { }

        /// <summary>
        /// TBD
        /// </summary>
        public class Ungate { }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class GotUid
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="uid">TBD</param>
            /// <param name="remoteAddress">TBD</param>
            public GotUid(int uid, Address remoteAddress)
            {
                Uid = uid;
                RemoteAddress = remoteAddress;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public int Uid { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public Address RemoteAddress { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReliableDeliverySupervisorProps(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    string dispatcher)
        {
            return
                Props.Create(
                    () =>
                        new ReliableDeliverySupervisor(handleOrActive, localAddress, remoteAddress, refuseUid, transport,
                            settings, codec, receiveBuffers))
                    .WithDispatcher(dispatcher);
        }

        #endregion

        // Extracted this method to solve a compiler issue with `Receive<TooLongIdle>`
        private void HandleTooLongIdle()
        {
            throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                new TimeoutException("Delivery of system messages timed out and they were dropped"));
        }

        private void HandleSend(EndpointManager.Send send)
        {
            if (send.Message is ISystemMessage)
            {
                var sequencedSend = send.Copy(NextSeq());
                TryBuffer(sequencedSend);
                // If we have not confirmed the remote UID we cannot transfer the system message at this point just buffer it.
                // GotUid will kick ResendAll() causing the messages to be properly written.
                // Flow control by not sending more when we already have many outstanding.
                if (UidConfirmed && _resendBuffer.NonAcked.Count <= _settings.SysResendLimit) _writer.Tell(sequencedSend);
            }
            else
            {
                _writer.Tell(send);
            }
        }

        private void ResendNacked()
        {
            _resendBuffer.Nacked.ForEach(nacked => _writer.Tell(nacked));
        }

        private void ResendAll()
        {
            ResendNacked();
            _resendBuffer.NonAcked.Take(_settings.SysResendLimit).ForEach(nonacked => _writer.Tell(nonacked));
        }

        private void TryBuffer(EndpointManager.Send s)
        {
            try
            {
                _resendBuffer = _resendBuffer.Buffer(s);
            }
            catch (Exception ex)
            {
                throw new HopelessAssociation(_localAddress, _remoteAddress, Uid, ex);
            }
        }

        #region Writer create

        private IActorRef CreateWriter()
        {
            var writer =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointWriter.EndpointWriterProps(_currentHandle, _localAddress, _remoteAddress, _refuseUid, _transport,
                            _settings, new AkkaPduProtobuffCodec(Context.System), _receiveBuffers, Self)
                            .WithDeploy(Deploy.Local)),
                    "endpointWriter");
            Context.Watch(writer);
            return writer;
        }

        #endregion

    }

    /// <summary>
    /// Abstract base class for <see cref="EndpointReader"/> classes
    /// </summary>
    internal abstract class EndpointActor : ReceiveActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        protected readonly Address LocalAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected Address RemoteAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected RemoteSettings Settings;
        /// <summary>
        /// TBD
        /// </summary>
        protected AkkaProtocolTransport Transport;

        private readonly ILoggingAdapter _log = Context.GetLogger();

        /// <summary>
        /// TBD
        /// </summary>
        protected readonly EventPublisher EventPublisher;
        /// <summary>
        /// TBD
        /// </summary>
        protected bool Inbound { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        protected EndpointActor(Address localAddress, Address remoteAddress, AkkaProtocolTransport transport,
            RemoteSettings settings)
        {
            EventPublisher = new EventPublisher(Context.System, _log, Logging.LogLevelFor(settings.RemoteLifecycleEventsLogLevel));
            LocalAddress = localAddress;
            RemoteAddress = remoteAddress;
            Transport = transport;
            Settings = settings;
        }

        #region Event publishing methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="ex">TBD</param>
        /// <param name="level">TBD</param>
        protected void PublishError(Exception ex, LogLevel level)
        {
            TryPublish(new AssociationErrorEvent(ex, LocalAddress, RemoteAddress, Inbound, level));
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void PublishDisassociated()
        {
            TryPublish(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        private void TryPublish(RemotingLifecycleEvent ev)
        {
            try
            {
                EventPublisher.NotifyListeners(ev);
            }
            catch (Exception ex)
            {
                _log.Error(ex, "Unable to publish error event to EventStream");
            }
        }

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointWriter : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointWriter(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                        base(localAddress, remoteAddress, transport, settings)
        {
            _refuseUid = refuseUid;
            _codec = codec;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _system = Context.System.AsInstanceOf<ExtendedActorSystem>();
            _provider = RARP.For(Context.System).Provider;
            _msgDispatcher = new DefaultMessageDispatcher(_system, _provider, _log);
            _receiveBuffers = receiveBuffers;
            Inbound = handleOrActive != null;
            _ackDeadline = NewAckDeadline();
            _handle = handleOrActive;
            _remoteMetrics = RemoteMetricsExtension.Create(Context.System.AsInstanceOf<ExtendedActorSystem>());

            if (_handle == null)
            {
                Initializing();
            }
            else
            {
                Writing();
            }
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly int? _refuseUid;
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private DisassociateInfo _stopReason = DisassociateInfo.Unknown;

        private IActorRef _reader;
        private readonly AtomicCounter _readerId = new AtomicCounter(0);
        private readonly IInboundMessageDispatcher _msgDispatcher;

        private Ack _lastAck = null;
        private Deadline _ackDeadline;
        private AkkaProtocolHandle _handle;

        private ICancelable _ackIdleTimerCancelable;

        // Use an internal buffer instead of Stash for efficiency
        // stash/unstashAll is slow when many messages are stashed
        // IMPORTANT: sender is not stored, so .Sender and forward must not be used in EndpointWriter
        private readonly LinkedList<object> _buffer = new LinkedList<object>();

        //buffer for IPriorityMessages - ensures that heartbeats get delivered before user-defined messages
        private readonly LinkedList<EndpointManager.Send> _prioBuffer = new LinkedList<EndpointManager.Send>();
        private long _largeBufferLogTimestamp = MonotonicClock.GetNanos();

        private readonly IRemoteMetrics _remoteMetrics;

        #region ActorBase methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel, false);
                return Directive.Escalate;
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="reason">TBD</param>
        /// <exception cref="IllegalActorStateException">TBD</exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("EndpointWriter must not be restarted");
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_handle == null)
            {
                var self = Self;
                AssociateAsync().PipeTo(self);
            }
            else
            {
                _reader = StartReadEndpoint(_handle);
            }

            var ackIdleInterval = new TimeSpan(Settings.SysMsgAckTimeout.Ticks / 2);
            _ackIdleTimerCancelable = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(ackIdleInterval, ackIdleInterval, Self, AckIdleCheckTimer.Instance, Self);
        }

        private async Task<object> AssociateAsync()
        {
            try
            {
                return new Handle(await Transport.Associate(RemoteAddress, _refuseUid).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                return new Status.Failure(e.InnerException ?? e);
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            _ackIdleTimerCancelable.CancelIfNotNull();

            foreach (var msg in _prioBuffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _prioBuffer.Clear();

            foreach (var msg in _buffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _buffer.Clear();

            if (_handle != null) _handle.Disassociate(_stopReason);
            EventPublisher.NotifyListeners(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        #endregion

        #region Receives

        private void Initializing()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<Status.Failure>(failure =>
            {
                if (failure.Cause is InvalidAssociationException)
                {
                    if (failure.Cause.InnerException == null)
                    {
                        PublishAndThrow(new InvalidAssociation(failure.Cause.Message, LocalAddress, RemoteAddress), LogLevel.WarningLevel);
                    }
                }

                PublishAndThrow(new InvalidAssociation($"Association failed with {RemoteAddress}", LocalAddress, RemoteAddress, failure.Cause), LogLevel.WarningLevel);
            });
            Receive<Handle>(handle =>
            {
                // Assert handle == None?
                Context.Parent.Tell(
                    new ReliableDeliverySupervisor.GotUid((int)handle.ProtocolHandle.HandshakeInfo.Uid, RemoteAddress));
                _handle = handle.ProtocolHandle;
                _reader = StartReadEndpoint(_handle);
                EventPublisher.NotifyListeners(new AssociatedEvent(LocalAddress, RemoteAddress, Inbound));
                BecomeWritingOrSendBufferedMessages();
            });
        }

        private void Buffering()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<BackoffTimer>(backoff => SendBufferedMessages());
            Receive<FlushAndStop>(stop =>
            {
                _buffer.AddLast(stop); //Flushing is postponed after the pending writes
                Context.System.Scheduler.ScheduleTellOnce(Settings.FlushWait, Self, FlushAndStopTimeout.Instance, Self);
            });
            Receive<FlushAndStopTimeout>(timeout =>
            {
                // enough, ready to flush
                DoFlushAndStop();
            });
        }

        private void Writing()
        {
            Receive<EndpointManager.Send>(s =>
            {
                if (!WriteSend(s))
                {
                    if (s.Seq == null) EnqueueInBuffer(s);
                    ScheduleBackoffTimer();
                    Become(Buffering);
                }
            });
            Receive<FlushAndStop>(flush => DoFlushAndStop());
            Receive<AckIdleCheckTimer>(ack =>
            {
                if (_ackDeadline.IsOverdue)
                {
                    TrySendPureAck();
                }
            });
        }

        private void Handoff()
        {
            Receive<Terminated>(terminated =>
            {
                _reader = StartReadEndpoint(_handle);
                BecomeWritingOrSendBufferedMessages();
            });
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        protected override void Unhandled(object message)
        {
            if (message is Terminated)
            {
                var t = message as Terminated;
                if (_reader == null || t.ActorRef.Equals(_reader))
                {
                    PublishAndThrow(new EndpointDisassociatedException("Disassociated"), LogLevel.DebugLevel);
                }
            }
            else if (message is StopReading)
            {
                var stop = message as StopReading;
                if (_reader != null)
                {
                    _reader.Tell(stop, stop.ReplyTo);
                }
                else
                {
                    // initializing, buffer and take care of it later when buffer is sent
                    EnqueueInBuffer(message);
                }
            }
            else if (message is TakeOver)
            {
                var takeover = message as TakeOver;

                // Shutdown old reader
                _handle.Disassociate();
                _handle = takeover.ProtocolHandle;
                takeover.ReplyTo.Tell(new TookOver(Self, _handle));
                Become(Handoff);
            }
            else if (message is FlushAndStop)
            {
                _stopReason = DisassociateInfo.Shutdown;
                Context.Stop(Self);
            }
            else if (message is OutboundAck)
            {
                var ack = message as OutboundAck;
                _lastAck = ack.Ack;
                if (_ackDeadline.IsOverdue)
                    TrySendPureAck();
            }
            else if (message is AckIdleCheckTimer || message is FlushAndStopTimeout || message is BackoffTimer)
            {
                //ignore
            }
            else
            {
                base.Unhandled(message);
            }
        }

        #endregion

        #region Internal methods

        private Deadline NewAckDeadline()
        {
            return Deadline.Now + Settings.SysMsgAckTimeout;
        }

        private void PublishAndThrow(Exception reason, LogLevel level, bool needToThrow = true)
        {
            reason.Match()
                .With<EndpointDisassociatedException>(endpoint => PublishDisassociated())
                .With<ShutDownAssociation>(shutdown => { }) // don't log an error for planned shutdowns
                .Default(msg => PublishError(reason, level));

            if (needToThrow)
            {
                throw reason;
            }
        }

        private IActorRef StartReadEndpoint(AkkaProtocolHandle handle)
        {
            var newReader =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointReader.ReaderProps(LocalAddress, RemoteAddress, Transport, Settings, _codec, _msgDispatcher,
                            Inbound, (int)handle.HandshakeInfo.Uid, _receiveBuffers, _reliableDeliverySupervisor)
                            .WithDeploy(Deploy.Local)),
                    string.Format("endpointReader-{0}-{1}", AddressUrlEncoder.Encode(RemoteAddress), _readerId.Next()));
            Context.Watch(newReader);
            handle.ReadHandlerSource.SetResult(new ActorHandleEventListener(newReader));
            return newReader;
        }

        /// <summary>
        /// Serializes the outbound message going onto the wire.
        /// </summary>
        /// <param name="msg">The C# object we intend to serialize.</param>
        /// <returns>The Akka.NET envelope containing the serialized message and addressing information.</returns>
        /// <remarks>Differs from JVM implementation due to Scala implicits.</remarks>
        private SerializedMessage SerializeMessage(object msg)
        {
            if (_handle == null)
            {
                throw new EndpointException("Internal error: No handle was present during serialization of outbound message.");
            }
            return MessageSerializer.Serialize(_system, _handle.LocalAddress, msg);
        }

        private int _writeCount = 0;
        private int _maxWriteCount = MaxWriteCount;
        private long _adaptiveBackoffNanos = 1000000L; // 1 ms
        private bool _fullBackoff = false;

        // FIXME remove these counters when tuning/testing is completed
        private int _fullBackoffCount = 1;
        private int _smallBackoffCount = 0;
        private int _noBackoffCount = 0;

        private void AdjustAdaptiveBackup()
        {
            _maxWriteCount = Math.Max(_writeCount, _maxWriteCount);
            if (_writeCount <= SendBufferBatchSize)
            {
                _fullBackoff = true;
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.2), MaxAdaptiveBackoffNanos);
            }
            else if (_writeCount >= _maxWriteCount * 0.6)
            {
                _adaptiveBackoffNanos = Math.Max(Convert.ToInt64(_adaptiveBackoffNanos * 0.9), MinAdaptiveBackoffNanos);
            }
            else if (_writeCount <= _maxWriteCount * 0.2)
            {
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.1), MaxAdaptiveBackoffNanos);
            }
            _writeCount = 0;
        }

        private void ScheduleBackoffTimer()
        {
            if (_fullBackoff)
            {
                _fullBackoffCount += 1;
                _fullBackoff = false;
                Context.System.Scheduler.ScheduleTellOnce(Settings.BackoffPeriod, Self, BackoffTimer.Instance, Self, null);
            }
            else
            {
                _smallBackoffCount += 1;
                var backoffDeadlineNanoTime = TimeSpan.FromTicks(_adaptiveBackoffNanos.ToTicks());

                Context.System.Scheduler.ScheduleTellOnce(backoffDeadlineNanoTime, Self, BackoffTimer.Instance, Self);
            }
        }

        private void DoFlushAndStop()
        {
            //Try to send last Ack message
            TrySendPureAck();
            _stopReason = DisassociateInfo.Shutdown;
            Context.Stop(Self);
        }

        private void TrySendPureAck()
        {
            if (_handle != null && _lastAck != null)
            {
                if (_handle.Write(_codec.ConstructPureAck(_lastAck)))
                {
                    _ackDeadline = NewAckDeadline();
                    _lastAck = null;
                }
            }
        }

        private void EnqueueInBuffer(object message)
        {
            var send = message as EndpointManager.Send;
            if (send?.Message is IPriorityMessage)
                _prioBuffer.AddLast(send);
            else if (send?.Message is ActorSelectionMessage &&
                     send.Message.AsInstanceOf<ActorSelectionMessage>().Message is IPriorityMessage)
            {
                _prioBuffer.AddLast(send);
            }
            else
            {
                _buffer.AddLast(message);
            }
        }

        private void BecomeWritingOrSendBufferedMessages()
        {
            if (!_buffer.Any())
            {
                Become(Writing);
            }
            else
            {
                Become(Buffering);
                SendBufferedMessages();
            }
        }

        private bool WriteSend(EndpointManager.Send send)
        {
            try
            {
                if (_handle == null)
                    throw new EndpointException(
                        "Internal error: Endpoint is in state Writing, but no association handle is present.");
                if (_provider.RemoteSettings.LogSend)
                {
                    _log.Debug("RemoteMessage: {0} to [{1}]<+[{2}] from [{3}]", send.Message,
                        send.Recipient, send.Recipient.Path, send.SenderOption ?? _system.DeadLetters);
                }

                var pdu = _codec.ConstructMessage(send.Recipient.LocalAddressToUse, send.Recipient,
                    this.SerializeMessage(send.Message), send.SenderOption, send.Seq, _lastAck);

                _remoteMetrics.LogPayloadBytes(send.Message, pdu.Length);

                if (pdu.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload sent to {0}: max allowed size {1} bytes, actual size of encoded {2} was {3} bytes.",
                            send.Recipient,
                            Transport.MaximumPayloadBytes,
                            send.Message.GetType(),
                            pdu.Length));
                    _log.Error(reason, "Transient association error (association remains live)");
                    return true;
                }
                else
                {
                    var ok = _handle.Write(pdu);

                    if (ok)
                    {
                        _ackDeadline = NewAckDeadline();
                        _lastAck = null;
                        return true;
                    }
                }
                return false;
            }
            catch (SerializationException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (ArgumentException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (EndpointException ex)
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel);
            }
            catch (Exception ex)
            {
                PublishAndThrow(new EndpointException("Failed to write message to the transport", ex),
                    LogLevel.ErrorLevel);
            }

            return false;
        }

        private void SendBufferedMessages()
        {
            bool SendDelegate(object msg)
            {
                switch (msg)
                {
                    case EndpointManager.Send s:
                        return WriteSend(s);
                    case FlushAndStop f:
                        DoFlushAndStop();
                        return false;
                    case StopReading stop:
                        _reader?.Tell(stop, stop.ReplyTo);
                        return true;
                    default:
                        return true;
                }
            }

            bool WriteLoop(int count)
            {
                if (count > 0 && _buffer.Any())
                {
                    if (SendDelegate(_buffer.First.Value))
                    {
                        _buffer.RemoveFirst();
                        _writeCount += 1;
                        return WriteLoop(count - 1);
                    }
                    return false;
                }

                return true;
            }

            bool WritePrioLoop()
            {
                if (!_prioBuffer.Any()) return true;
                if (WriteSend(_prioBuffer.First.Value))
                {
                    _prioBuffer.RemoveFirst();
                    return WritePrioLoop();
                }
                return false;
            }

            var size = _buffer.Count;

            var ok = WritePrioLoop() && WriteLoop(SendBufferBatchSize);
            if (!_buffer.Any() && !_prioBuffer.Any())
            {
                // FIXME remove this when testing/tuning is completed
                if (_log.IsDebugEnabled)
                {
                    _log.Debug("Drained buffer with maxWriteCount: {0}, fullBackoffCount: {1}," +
                               "smallBackoffCount: {2}, noBackoffCount: {3}," +
                               "adaptiveBackoff: {4}", _maxWriteCount, _fullBackoffCount, _smallBackoffCount, _noBackoffCount, _adaptiveBackoffNanos / 1000);
                }
                _fullBackoffCount = 1;
                _smallBackoffCount = 0;
                _noBackoffCount = 0;
                _writeCount = 0;
                _maxWriteCount = MaxWriteCount;
                Become(Writing);
            }
            else if (ok)
            {
                _noBackoffCount += 1;
                Self.Tell(BackoffTimer.Instance);
            }
            else
            {
                if (size > Settings.LogBufferSizeExceeding)
                {
                    var now = MonotonicClock.GetNanos();
                    if (now - _largeBufferLogTimestamp >= LogBufferSizeInterval)
                    {
                        _log.Warning("[{0}] buffered messages in EndpointWriter for [{1}]. You should probably implement flow control to avoid flooding the remote connection.", size, RemoteAddress);
                        _largeBufferLogTimestamp = now;
                    }
                }
            }

            AdjustAdaptiveBackup();
            ScheduleBackoffTimer();
        }

        #endregion

        #region Static methods and Internal messages

        // These settings are not configurable because wrong configuration will break the auto-tuning
        private const int SendBufferBatchSize = 5;
        private const long MinAdaptiveBackoffNanos = 300000L; // 0.3 ms
        private const long MaxAdaptiveBackoffNanos = 2000000L; // 2 ms
        private const long LogBufferSizeInterval = 5000000000L; // 5 s, in nanoseconds
        private const int MaxWriteCount = 50;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props EndpointWriterProps(AkkaProtocolHandle handleOrActive, Address localAddress,
                    Address remoteAddress, int? refuseUid, AkkaProtocolTransport transport, RemoteSettings settings,
                    AkkaPduCodec codec, ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers, IActorRef reliableDeliverySupervisor = null)
        {
            return Props.Create(
                () =>
                    new EndpointWriter(handleOrActive, localAddress, remoteAddress, refuseUid, transport, settings,
                        codec, receiveBuffers, reliableDeliverySupervisor));
        }

        /// <summary>
        /// This message signals that the current association maintained by the local <see cref="EndpointWriter"/> and
        /// <see cref="EndpointReader"/> is to be overridden by a new inbound association. This is needed to avoid parallel inbound
        /// associations from the same remote endpoint: when a parallel inbound association is detected, the old one is removed and the new
        /// one is used instead.
        /// </summary>
        public sealed class TakeOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// Create a new TakeOver command
            /// </summary>
            /// <param name="protocolHandle">The handle of the new association</param>
            /// <param name="replyTo">TBD</param>
            public TakeOver(AkkaProtocolHandle protocolHandle, IActorRef replyTo)
            {
                ProtocolHandle = protocolHandle;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class TookOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="protocolHandle">TBD</param>
            public TookOver(IActorRef writer, AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class BackoffTimer
        {
            private BackoffTimer() { }
            private static readonly BackoffTimer _instance = new BackoffTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static BackoffTimer Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class FlushAndStop
        {
            private FlushAndStop() { }
            private static readonly FlushAndStop _instance = new FlushAndStop();
            /// <summary>
            /// TBD
            /// </summary>
            public static FlushAndStop Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class AckIdleCheckTimer
        {
            private AckIdleCheckTimer() { }
            private static readonly AckIdleCheckTimer _instance = new AckIdleCheckTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static AckIdleCheckTimer Instance { get { return _instance; } }
        }

        private sealed class FlushAndStopTimeout
        {
            private FlushAndStopTimeout() { }
            private static readonly FlushAndStopTimeout _instance = new FlushAndStopTimeout();
            public static FlushAndStopTimeout Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Handle : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="protocolHandle">TBD</param>
            public Handle(AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StopReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="replyTo">TBD</param>
            public StopReading(IActorRef writer, IActorRef replyTo)
            {
                Writer = writer;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StoppedReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            public StoppedReading(IActorRef writer)
            {
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class OutboundAck
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="ack">TBD</param>
            public OutboundAck(Ack ack)
            {
                Ack = ack;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public Ack Ack { get; private set; }
        }

        private const string AckIdleTimerName = "AckIdleTimer";

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointReader : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="msgDispatch">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointReader(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher msgDispatch,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                    base(localAddress, remoteAddress, transport, settings)
        {
            _receiveBuffers = receiveBuffers;
            _msgDispatch = msgDispatch;
            Inbound = inbound;
            _uid = uid;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _codec = codec;
            _provider = RARP.For(Context.System).Provider;
            Reading();
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private readonly int _uid;
        private readonly IInboundMessageDispatcher _msgDispatch;

        private readonly IRemoteActorRefProvider _provider;
        private AckedReceiveBuffer<Message> _ackedReceiveBuffer = new AckedReceiveBuffer<Message>();

        #region ActorBase overrides

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_receiveBuffers.TryGetValue(new EndpointManager.Link(LocalAddress, RemoteAddress), out var resendState))
            {
                if(resendState.Uid == _uid)
                {
                    _ackedReceiveBuffer = resendState.Buffer;
                    DeliverAndAck();
                }
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            SaveState();
        }

        private void Reading()
        {
           
            Receive<InboundPayload>(inbound =>
            {
                var payload = inbound.Payload;
                if (payload.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload received: max allowed size {0} bytes, actual size {1} bytes.",
                            Transport.MaximumPayloadBytes,
                            payload.Length));
                    _log.Error(reason, "Transient error while reading from association (association remains live)");
                }
                else
                {
                    var ackAndMessage = TryDecodeMessageAndAck(payload);
                    if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                        _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
                    if (ackAndMessage.MessageOption != null)
                    {
                        if (ackAndMessage.MessageOption.ReliableDeliveryEnabled)
                        {
                            _ackedReceiveBuffer = _ackedReceiveBuffer.Receive(ackAndMessage.MessageOption);
                            DeliverAndAck();
                        }
                        else
                        {
                            try
                            {
                                _msgDispatch.Dispatch(ackAndMessage.MessageOption.Recipient,
                                    ackAndMessage.MessageOption.RecipientAddress,
                                    ackAndMessage.MessageOption.SerializedMessage,
                                    ackAndMessage.MessageOption.SenderOptional);
                            }
                            catch (SerializationException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (ArgumentException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (Exception e)
                            {
                                throw;
                            }
                        }
                    }
                }
            });
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                SaveState();
                Become(NotReading);
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        private void LogTransientSerializationError(Message msg, Exception error)
        {
            var sm = msg.SerializedMessage;
            _log.Warning(
              "Serializer not defined for message with serializer id [{0}] and manifest [{1}]. " +
                "Transient association error (association remains live). {2}",
              sm.SerializerId,
              sm.MessageManifest.IsEmpty ? "" : sm.MessageManifest.ToStringUtf8(),
              error.Message);
        }

        private void NotReading()
        {
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<InboundPayload>(payload =>
            {
                var ackAndMessage = TryDecodeMessageAndAck(payload.Payload);
                if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                    _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion



        #region Lifecycle event handlers

        private void SaveState()
        {
            EndpointManager.ResendState Merge(EndpointManager.ResendState current,
                EndpointManager.ResendState oldState)
            {
                if (current.Uid == oldState.Uid) return new EndpointManager.ResendState(_uid, oldState.Buffer.MergeFrom(current.Buffer));
                return current;
            }

            void UpdateSavedState(EndpointManager.Link key, EndpointManager.ResendState expectedState)
            {
                if (expectedState == null)
                {
                    if (!_receiveBuffers.TryAdd(key, new EndpointManager.ResendState(_uid, _ackedReceiveBuffer)))
                    {
                        _receiveBuffers.TryGetValue(key, out var prevValue);
                        UpdateSavedState(key, prevValue);
                    }
                }
                else if (!_receiveBuffers.TryUpdate(key,
                    Merge(new EndpointManager.ResendState(_uid, _ackedReceiveBuffer), expectedState), expectedState))
                {
                    _receiveBuffers.TryGetValue(key, out var prevValue);
                    UpdateSavedState(key, prevValue);
                }
            }

            var k = new EndpointManager.Link(LocalAddress, RemoteAddress);
            UpdateSavedState(k, !_receiveBuffers.TryGetValue(k, out var previousValue) ? null : previousValue);
        }

        private void HandleDisassociated(DisassociateInfo info)
        {
            switch (info)
            {
                case DisassociateInfo.Quarantined:
                    throw new InvalidAssociation("The remote system has quarantined this system. No further associations " +
                                                   "to the remote system are possible until this system is restarted.", LocalAddress, RemoteAddress, disassociateInfo: DisassociateInfo.Quarantined);
                case DisassociateInfo.Shutdown:
                    throw new ShutDownAssociation($"The remote system terminated the association because it is shutting down. Shut down address: {RemoteAddress}", LocalAddress, RemoteAddress);
                case DisassociateInfo.Unknown:
                default:
                    Context.Stop(Self);
                    break;
            }
        }

        private void DeliverAndAck()
        {
            var deliverable = _ackedReceiveBuffer.ExtractDeliverable();
            _ackedReceiveBuffer = deliverable.Buffer;

            // Notify writer that some messages can be acked
            Context.Parent.Tell(new EndpointWriter.OutboundAck(deliverable.Ack));
            deliverable.Deliverables.ForEach(msg => _msgDispatch.Dispatch(msg.Recipient, msg.RecipientAddress, msg.SerializedMessage, msg.SenderOptional));
        }

        private AckAndMessage TryDecodeMessageAndAck(ByteString pdu)
        {
            try
            {
                return _codec.DecodeMessage(pdu, _provider, LocalAddress);
            }
            catch (Exception ex)
            {
                throw new EndpointException("Error while decoding incoming Akka PDU", ex);
            }
        }

        #endregion

        #region Static members

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReaderProps(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher dispatcher,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null)
        {
            return
                Props.Create(
                    () =>
                        new EndpointReader(localAddress, remoteAddress, transport, settings, codec, dispatcher, inbound,
                            uid, receiveBuffers, reliableDeliverySupervisor))
                            .WithDispatcher(settings.Dispatcher);
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1936,46): warning CS0168: The variable 'e' is declared but never used,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1256,17): warning CS0618: 'AssociationHandle.Disassociate()' is obsolete: 'Use the method that states reasons to make sure disassociation reasons are logged.',D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(11,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1936,46): warning CS0168: The variable 'e' is declared but never used,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1256,17): warning CS0618: 'AssociationHandle.Disassociate()' is obsolete: 'Use the method that states reasons to make sure disassociation reasons are logged.',D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1403,34): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1405,39): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\core\Akka.Remote\Endpoint.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Dispatch;
using Akka.Dispatch.SysMsg;
using Akka.Event;
using Akka.Pattern;
using Akka.Remote.Serialization;
using Akka.Remote.Transport;
using Akka.Serialization;
using Akka.Util;
using Akka.Util.Internal;
using Google.Protobuf;
using SerializedMessage = Akka.Remote.Serialization.Proto.Msg.Payload;

namespace Akka.Remote
{
    /// <summary>
    /// INTERNAL API
    /// </summary>
    // ReSharper disable once InconsistentNaming
    internal interface IInboundMessageDispatcher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null);
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class DefaultMessageDispatcher : IInboundMessageDispatcher
    {
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ILoggingAdapter _log;
        private readonly IInternalActorRef _remoteDaemon;
        private readonly RemoteSettings _settings;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="provider">TBD</param>
        /// <param name="log">TBD</param>
        public DefaultMessageDispatcher(ExtendedActorSystem system, IRemoteActorRefProvider provider, ILoggingAdapter log)
        {
            _system = system;
            _provider = provider;
            _log = log;
            _remoteDaemon = provider.RemoteDaemon;
            _settings = provider.RemoteSettings;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        public void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null)
        {
            var payload = MessageSerializer.Deserialize(_system, message);
            var payloadClass = payload?.GetType();
            var sender = senderOption ?? _system.DeadLetters;
            var originalReceiver = recipient.Path;

            // message is intended for the RemoteDaemon, usually a command to create a remote actor
            if (recipient.Equals(_remoteDaemon))
            {
                if (_settings.UntrustedMode) _log.Debug("dropping daemon message in untrusted mode");
                else
                {
                    if (_settings.LogReceive)
                    {
                        var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                        _log.Debug("received daemon message [{0}]", msgLog);
                    }
                    _remoteDaemon.Tell(payload);
                }
            }

            //message is intended for a local recipient
            else if ((recipient is ILocalRef || recipient is RepointableActorRef) && recipient.IsLocal)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                    _log.Debug("received local message [{0}]", msgLog);
                }
                if (payload is ActorSelectionMessage sel)
                {
                    if (_settings.UntrustedMode
                        && (!_settings.TrustedSelectionPaths.Contains(FormatActorPath(sel))
                            || sel.Message is IPossiblyHarmful
                            || !recipient.Equals(_provider.RootGuardian)))
                    {
                        _log.Debug(
                            "operating in UntrustedMode, dropping inbound actor selection to [{0}], allow it" +
                            "by adding the path to 'akka.remote.trusted-selection-paths' in configuration",
                            FormatActorPath(sel));
                    }
                    else
                    {
                        //run the receive logic for ActorSelectionMessage here to make sure it is not stuck on busy user actor
                        ActorSelection.DeliverSelection(recipient, sender, sel);
                    }
                }
                else if (payload is IPossiblyHarmful && _settings.UntrustedMode)
                {
                    _log.Debug("operating in UntrustedMode, dropping inbound IPossiblyHarmful message of type {0}",
                        payload.GetType());
                }
                else if (payload is ISystemMessage systemMessage)
                {
                    recipient.SendSystemMessage(systemMessage);
                }
                else
                {
                    recipient.Tell(payload, sender);
                }
            }

            // message is intended for a remote-deployed recipient
            else if ((recipient is IRemoteRef || recipient is RepointableActorRef) && !recipient.IsLocal &&
                     !_settings.UntrustedMode)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = string.Format("RemoteMessage: {0} to {1}<+{2} from {3}", payload, recipient, originalReceiver, sender);
                    _log.Debug("received remote-destined message {0}", msgLog);
                }
                if (_provider.Transport.Addresses.Contains(recipientAddress))
                {
                    //if it was originally addressed to us but is in fact remote from our point of view (i.e. remote-deployed)
                    recipient.Tell(payload, sender);
                }
                else
                {
                    _log.Error(
                        "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                        payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
                }
            }
            else
            {
                _log.Error(
                    "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                    payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
            }
        }

        private static string FormatActorPath(ActorSelectionMessage sel)
        {
            return "/" + string.Join("/", sel.Elements.Select(x => x.ToString()));
        }
    }

    #region Endpoint Exception Types

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointException : AkkaException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="cause">The exception that is the cause of the current exception.</param>
        public EndpointException(string message, Exception cause = null) : base(message, cause) { }

#if SERIALIZATION
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected EndpointException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal interface IAssociationProblem { }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class ShutDownAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="cause">TBD</param>
        public ShutDownAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal sealed class InvalidAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TbD</param>
        /// <param name="cause">TBD</param>
        /// <param name="disassociateInfo">TBD</param>
        public InvalidAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null, DisassociateInfo? disassociateInfo = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            DisassociationInfo = disassociateInfo;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public DisassociateInfo? DisassociationInfo { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class HopelessAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="cause">TBD</param>
        public HopelessAssociation(Address localAddress, Address remoteAddress, int? uid = null, Exception cause = null)
            : base("Catastrophic association error.", cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            Uid = uid;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointDisassociatedException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointDisassociatedException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointDisassociatedException(string message)
            : base(message)
        {
        }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointAssociationException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointAssociationException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        public EndpointAssociationException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class OversizedPayloadException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OversizedPayloadException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public OversizedPayloadException(string message)
            : base(message)
        {
        }
    }

    #endregion

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class ReliableDeliverySupervisor : ReceiveActor
    {
        #region Internal message classes

        /// <summary>
        /// TBD
        /// </summary>
        public class IsIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly IsIdle Instance = new IsIdle();
            private IsIdle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class Idle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly Idle Instance = new Idle();
            private Idle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class TooLongIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly TooLongIdle Instance = new TooLongIdle();
            private TooLongIdle() { }
        }

        #endregion

        private readonly ILoggingAdapter _log = Context.GetLogger();

        private readonly Address _localAddress;
        private readonly Address _remoteAddress;
        private readonly int? _refuseUid;
        private readonly AkkaProtocolTransport _transport;
        private readonly RemoteSettings _settings;
        private AkkaPduCodec _codec;
        private AkkaProtocolHandle _currentHandle;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        public ReliableDeliverySupervisor(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers)
        {
            _localAddress = localAddress;
            _remoteAddress = remoteAddress;
            _refuseUid = refuseUid;
            _transport = transport;
            _settings = settings;
            _codec = codec;
            _currentHandle = handleOrActive;
            _receiveBuffers = receiveBuffers;
            Reset(); // needs to be called at startup
            _writer = CreateWriter(); // need to create writer at startup
            Uid = handleOrActive != null ? (int?)handleOrActive.HandshakeInfo.Uid : null;
            UidConfirmed = Uid.HasValue && (Uid != _refuseUid);

            if (Uid.HasValue && Uid == _refuseUid)
                throw new HopelessAssociation(localAddress, remoteAddress, Uid,
                    new InvalidOperationException(
                        $"The remote system [{remoteAddress}] has a UID [{Uid}] that has been quarantined. Association aborted."));

            Receiving();
            _autoResendTimer = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(_settings.SysResendTimeout, _settings.SysResendTimeout, Self, new AttemptSysMsgRedelivery(),
                    Self);
        }

        private readonly ICancelable _autoResendTimer;

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; set; }

        /// <summary>
        /// Processing of <see cref="Ack"/>s has to be delayed until the UID is discovered after a reconnect. Depending whether the
        /// UID matches the expected one, pending Acks can be processed or must be dropped. It is guaranteed that for any inbound
        /// connections (calling <see cref="CreateWriter"/>) the first message from that connection is <see cref="GotUid"/>, therefore it serves
        /// a separator.
        ///
        /// If we already have an inbound handle then UID is initially confirmed.
        /// (This actor is never restarted.)
        /// </summary>
        public bool UidConfirmed { get; private set; }

        private Deadline _bailoutAt = null;

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                if (ex is IAssociationProblem)
                    return Directive.Escalate;

                _log.Warning("Association with remote system {0} has failed; address is now gated for {1} ms. Reason is: [{2}]", _remoteAddress, _settings.RetryGateClosedFor.TotalMilliseconds, ex);
                UidConfirmed = false; // Need confirmation of UID again

                if ((_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any()) && _bailoutAt == null)
                    _bailoutAt = Deadline.Now + _settings.InitialSysMsgDeliveryTimeout;
                Become(() => Gated(writerTerminated: false, earlyUngateRequested: false));
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                return Directive.Stop;
            });
        }


        private ICancelable _maxSilenceTimer = null;
        private AckedSendBuffer<EndpointManager.Send> _resendBuffer;
        private long _seqCounter;

        private IActorRef _writer;

        private void Reset()
        {
            _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(_settings.SysMsgBufferSize);
            _seqCounter = 0L;
            _bailoutAt = null;
        }

        private SeqNo NextSeq()
        {
            var tmp = _seqCounter;
            _seqCounter++;
            return new SeqNo(tmp);
        }

        #region ActorBase methods and Behaviors

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            // All remaining messages in the buffer has to be delivered to dead letters. It is important to clear the sequence
            // number otherwise deadLetters will ignore it to avoid reporting system messages as dead letters while they are
            // still possibly retransmitted.
            // Such a situation may arise when the EndpointWriter is shut down, and all of its mailbox contents are delivered
            // to dead letters. These messages should be ignored, as they still live in resendBuffer and might be delivered to
            // the remote system later.
            foreach (var msg in _resendBuffer.Nacked.Concat(_resendBuffer.NonAcked))
            {
                Context.System.DeadLetters.Tell(msg.Copy(opt: null));
            }

            _log.Info("Removing receive buffers for [{0}]->[{1}]", _localAddress, _remoteAddress);
            _receiveBuffers.TryRemove(new EndpointManager.Link(_localAddress, _remoteAddress), out _);
            _autoResendTimer.Cancel();
            _maxSilenceTimer?.Cancel();
        }

        /// <summary>
        /// N/A
        /// </summary>
        /// <param name="reason">N/A</param>
        /// <exception cref="IllegalActorStateException">
        /// This exception is thrown automatically since <see cref="ReliableDeliverySupervisor"/> must not be restarted.
        /// </exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("BUG: ReliableDeliverySupervisor has been attempted to be restarted. This must not happen.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Receiving()
        {
            Receive<EndpointWriter.FlushAndStop>(flush =>
            {
                //Trying to serve until our last breath
                ResendAll();
                _writer.Tell(EndpointWriter.FlushAndStop.Instance);
                Become(FlushWait);
            });
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, or send a GotUid
            Receive<EndpointManager.Send>(send => HandleSend(send));
            Receive<Ack>(ack =>
            {
                // If we are not sure about the UID just ignore the ack. Ignoring is fine.
                if (UidConfirmed)
                {
                    try
                    {
                        _resendBuffer = _resendBuffer.Acknowledge(ack);
                    }
                    catch (Exception ex)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new IllegalStateException($"Error encountered while processing system message acknowledgement buffer: {_resendBuffer} ack: {ack}", ex));
                    }

                    ResendNacked();
                }
            });
            Receive<AttemptSysMsgRedelivery>(sysmsg =>
            {
                if (UidConfirmed) ResendAll();
            });
            Receive<Terminated>(terminated =>
            {
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                    Context.System.Scheduler.ScheduleTellOnce(_settings.SysResendTimeout, Self,
                        new AttemptSysMsgRedelivery(), Self);
                GoToIdle();
            });
            Receive<GotUid>(g =>
            {
                _bailoutAt = null;
                Context.Parent.Tell(g);
                //New system that has the same address as the old - need to start from fresh state
                UidConfirmed = true;
                if (Uid.HasValue && Uid.Value != g.Uid) Reset();
                Uid = g.Uid;
                ResendAll();
            });
            Receive<EndpointWriter.StopReading>(stopped =>
            {
                _writer.Forward(stopped); //forward the request
            });
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        private void GoToIdle()
        {
            if (_maxSilenceTimer == null)
                _maxSilenceTimer =
                    Context.System.Scheduler.ScheduleTellOnceCancelable(_settings.QuarantineSilentSystemTimeout, Self,
                        TooLongIdle.Instance, Self);
            Become(IdleBehavior);
        }

        private void GoToActive()
        {
            _maxSilenceTimer?.Cancel();
            _maxSilenceTimer = null;
            Become(Receiving);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="writerTerminated">TBD</param>
        /// <param name="earlyUngateRequested">TBD</param>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Gated(bool writerTerminated, bool earlyUngateRequested)
        {
            Receive<Terminated>(terminated =>
            {
                if (!writerTerminated)
                {
                    if (earlyUngateRequested)
                        Self.Tell(new Ungate());
                    else
                    {
                        Context.System.Scheduler.ScheduleTellOnce(_settings.RetryGateClosedFor, Self, new Ungate(), Self);
                    }
                }

                Become(() => Gated(true, earlyUngateRequested));
            });
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<Ungate>(ungate =>
            {
                if (!writerTerminated)
                {
                    // Ungate was sent from EndpointManager, but we must wait for Terminated first.
                    Become(() => Gated(false, true));
                }
                else if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                {
                    // If we talk to a system we have not talked to before (or has given up talking to in the past) stop
                    // system delivery attempts after the specified time. This act will drop the pending system messages and gate the
                    // remote address at the EndpointManager level stopping this actor. In case the remote system becomes reachable
                    // again it will be immediately quarantined due to out-of-sync system message buffer and becomes quarantined.
                    // In other words, this action is safe.
                    if (_bailoutAt != null && _bailoutAt.IsOverdue)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new TimeoutException("Delivery of system messages timed out and they were dropped"));
                    }

                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
                else
                {
                    GoToIdle();
                }
            });
            Receive<AttemptSysMsgRedelivery>(redelivery => { }); // Ignore
            Receive<EndpointManager.Send>(send => send.Message is ISystemMessage, send => TryBuffer(send.Copy(NextSeq())));
            Receive<EndpointManager.Send>(send => Context.System.DeadLetters.Tell(send));
            Receive<EndpointWriter.FlushAndStop>(flush => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
                Sender.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void IdleBehavior()
        {
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<EndpointManager.Send>(send =>
            {
                _writer = CreateWriter();
                //Resending will be triggered by the incoming GotUid message after the connection finished
                HandleSend(send);
                GoToActive();
            });

            Receive<AttemptSysMsgRedelivery>(sys =>
            {
                if (_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any())
                {
                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
            });
            Receive<TooLongIdle>(idle =>
            {
                HandleTooLongIdle();
            });
            Receive<EndpointWriter.FlushAndStop>(stop => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void FlushWait()
        {
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, which will do the inbound connection unstashing
            Receive<Terminated>(terminated =>
            {
                //Clear buffer to prevent sending system messages to dead letters -- at this point we are shutting down and
                //don't know if they were properly delivered or not
                _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(0);
                Context.Stop(Self);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion

        #region Static methods and Internal Message Types

        /// <summary>
        /// TBD
        /// </summary>
        public class AttemptSysMsgRedelivery { }

        /// <summary>
        /// TBD
        /// </summary>
        public class Ungate { }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class GotUid
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="uid">TBD</param>
            /// <param name="remoteAddress">TBD</param>
            public GotUid(int uid, Address remoteAddress)
            {
                Uid = uid;
                RemoteAddress = remoteAddress;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public int Uid { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public Address RemoteAddress { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReliableDeliverySupervisorProps(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    string dispatcher)
        {
            return
                Props.Create(
                    () =>
                        new ReliableDeliverySupervisor(handleOrActive, localAddress, remoteAddress, refuseUid, transport,
                            settings, codec, receiveBuffers))
                    .WithDispatcher(dispatcher);
        }

        #endregion

        // Extracted this method to solve a compiler issue with `Receive<TooLongIdle>`
        private void HandleTooLongIdle()
        {
            throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                new TimeoutException("Delivery of system messages timed out and they were dropped"));
        }

        private void HandleSend(EndpointManager.Send send)
        {
            if (send.Message is ISystemMessage)
            {
                var sequencedSend = send.Copy(NextSeq());
                TryBuffer(sequencedSend);
                // If we have not confirmed the remote UID we cannot transfer the system message at this point just buffer it.
                // GotUid will kick ResendAll() causing the messages to be properly written.
                // Flow control by not sending more when we already have many outstanding.
                if (UidConfirmed && _resendBuffer.NonAcked.Count <= _settings.SysResendLimit) _writer.Tell(sequencedSend);
            }
            else
            {
                _writer.Tell(send);
            }
        }

        private void ResendNacked()
        {
            _resendBuffer.Nacked.ForEach(nacked => _writer.Tell(nacked));
        }

        private void ResendAll()
        {
            ResendNacked();
            _resendBuffer.NonAcked.Take(_settings.SysResendLimit).ForEach(nonacked => _writer.Tell(nonacked));
        }

        private void TryBuffer(EndpointManager.Send s)
        {
            try
            {
                _resendBuffer = _resendBuffer.Buffer(s);
            }
            catch (Exception ex)
            {
                throw new HopelessAssociation(_localAddress, _remoteAddress, Uid, ex);
            }
        }

        #region Writer create

        private IActorRef CreateWriter()
        {
            var writer =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointWriter.EndpointWriterProps(_currentHandle, _localAddress, _remoteAddress, _refuseUid, _transport,
                            _settings, new AkkaPduProtobuffCodec(Context.System), _receiveBuffers, Self)
                            .WithDeploy(Deploy.Local)),
                    "endpointWriter");
            Context.Watch(writer);
            return writer;
        }

        #endregion

    }

    /// <summary>
    /// Abstract base class for <see cref="EndpointReader"/> classes
    /// </summary>
    internal abstract class EndpointActor : ReceiveActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        protected readonly Address LocalAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected Address RemoteAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected RemoteSettings Settings;
        /// <summary>
        /// TBD
        /// </summary>
        protected AkkaProtocolTransport Transport;

        private readonly ILoggingAdapter _log = Context.GetLogger();

        /// <summary>
        /// TBD
        /// </summary>
        protected readonly EventPublisher EventPublisher;
        /// <summary>
        /// TBD
        /// </summary>
        protected bool Inbound { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        protected EndpointActor(Address localAddress, Address remoteAddress, AkkaProtocolTransport transport,
            RemoteSettings settings)
        {
            EventPublisher = new EventPublisher(Context.System, _log, Logging.LogLevelFor(settings.RemoteLifecycleEventsLogLevel));
            LocalAddress = localAddress;
            RemoteAddress = remoteAddress;
            Transport = transport;
            Settings = settings;
        }

        #region Event publishing methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="ex">TBD</param>
        /// <param name="level">TBD</param>
        protected void PublishError(Exception ex, LogLevel level)
        {
            TryPublish(new AssociationErrorEvent(ex, LocalAddress, RemoteAddress, Inbound, level));
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void PublishDisassociated()
        {
            TryPublish(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        private void TryPublish(RemotingLifecycleEvent ev)
        {
            try
            {
                EventPublisher.NotifyListeners(ev);
            }
            catch (Exception ex)
            {
                _log.Error(ex, "Unable to publish error event to EventStream");
            }
        }

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointWriter : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointWriter(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                        base(localAddress, remoteAddress, transport, settings)
        {
            _refuseUid = refuseUid;
            _codec = codec;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _system = Context.System.AsInstanceOf<ExtendedActorSystem>();
            _provider = RARP.For(Context.System).Provider;
            _msgDispatcher = new DefaultMessageDispatcher(_system, _provider, _log);
            _receiveBuffers = receiveBuffers;
            Inbound = handleOrActive != null;
            _ackDeadline = NewAckDeadline();
            _handle = handleOrActive;
            _remoteMetrics = RemoteMetricsExtension.Create(Context.System.AsInstanceOf<ExtendedActorSystem>());

            if (_handle == null)
            {
                Initializing();
            }
            else
            {
                Writing();
            }
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly int? _refuseUid;
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private DisassociateInfo _stopReason = DisassociateInfo.Unknown;

        private IActorRef _reader;
        private readonly AtomicCounter _readerId = new AtomicCounter(0);
        private readonly IInboundMessageDispatcher _msgDispatcher;

        private Ack _lastAck = null;
        private Deadline _ackDeadline;
        private AkkaProtocolHandle _handle;

        private ICancelable _ackIdleTimerCancelable;

        // Use an internal buffer instead of Stash for efficiency
        // stash/unstashAll is slow when many messages are stashed
        // IMPORTANT: sender is not stored, so .Sender and forward must not be used in EndpointWriter
        private readonly LinkedList<object> _buffer = new LinkedList<object>();

        //buffer for IPriorityMessages - ensures that heartbeats get delivered before user-defined messages
        private readonly LinkedList<EndpointManager.Send> _prioBuffer = new LinkedList<EndpointManager.Send>();
        private long _largeBufferLogTimestamp = MonotonicClock.GetNanos();

        private readonly IRemoteMetrics _remoteMetrics;

        #region ActorBase methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel, false);
                return Directive.Escalate;
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="reason">TBD</param>
        /// <exception cref="IllegalActorStateException">TBD</exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("EndpointWriter must not be restarted");
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_handle == null)
            {
                var self = Self;
                AssociateAsync().PipeTo(self);
            }
            else
            {
                _reader = StartReadEndpoint(_handle);
            }

            var ackIdleInterval = new TimeSpan(Settings.SysMsgAckTimeout.Ticks / 2);
            _ackIdleTimerCancelable = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(ackIdleInterval, ackIdleInterval, Self, AckIdleCheckTimer.Instance, Self);
        }

        private async Task<object> AssociateAsync()
        {
            try
            {
                return new Handle(await Transport.Associate(RemoteAddress, _refuseUid).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                return new Status.Failure(e.InnerException ?? e);
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            _ackIdleTimerCancelable.CancelIfNotNull();

            foreach (var msg in _prioBuffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _prioBuffer.Clear();

            foreach (var msg in _buffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _buffer.Clear();

            if (_handle != null) _handle.Disassociate(_stopReason);
            EventPublisher.NotifyListeners(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        #endregion

        #region Receives

        private void Initializing()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<Status.Failure>(failure =>
            {
                if (failure.Cause is InvalidAssociationException)
                {
                    if (failure.Cause.InnerException == null)
                    {
                        PublishAndThrow(new InvalidAssociation(failure.Cause.Message, LocalAddress, RemoteAddress), LogLevel.WarningLevel);
                    }
                }

                PublishAndThrow(new InvalidAssociation($"Association failed with {RemoteAddress}", LocalAddress, RemoteAddress, failure.Cause), LogLevel.WarningLevel);
            });
            Receive<Handle>(handle =>
            {
                // Assert handle == None?
                Context.Parent.Tell(
                    new ReliableDeliverySupervisor.GotUid((int)handle.ProtocolHandle.HandshakeInfo.Uid, RemoteAddress));
                _handle = handle.ProtocolHandle;
                _reader = StartReadEndpoint(_handle);
                EventPublisher.NotifyListeners(new AssociatedEvent(LocalAddress, RemoteAddress, Inbound));
                BecomeWritingOrSendBufferedMessages();
            });
        }

        private void Buffering()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<BackoffTimer>(backoff => SendBufferedMessages());
            Receive<FlushAndStop>(stop =>
            {
                _buffer.AddLast(stop); //Flushing is postponed after the pending writes
                Context.System.Scheduler.ScheduleTellOnce(Settings.FlushWait, Self, FlushAndStopTimeout.Instance, Self);
            });
            Receive<FlushAndStopTimeout>(timeout =>
            {
                // enough, ready to flush
                DoFlushAndStop();
            });
        }

        private void Writing()
        {
            Receive<EndpointManager.Send>(s =>
            {
                if (!WriteSend(s))
                {
                    if (s.Seq == null) EnqueueInBuffer(s);
                    ScheduleBackoffTimer();
                    Become(Buffering);
                }
            });
            Receive<FlushAndStop>(flush => DoFlushAndStop());
            Receive<AckIdleCheckTimer>(ack =>
            {
                if (_ackDeadline.IsOverdue)
                {
                    TrySendPureAck();
                }
            });
        }

        private void Handoff()
        {
            Receive<Terminated>(terminated =>
            {
                _reader = StartReadEndpoint(_handle);
                BecomeWritingOrSendBufferedMessages();
            });
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        protected override void Unhandled(object message)
        {
            if (message is Terminated)
            {
                var t = message as Terminated;
                if (_reader == null || t.ActorRef.Equals(_reader))
                {
                    PublishAndThrow(new EndpointDisassociatedException("Disassociated"), LogLevel.DebugLevel);
                }
            }
            else if (message is StopReading)
            {
                var stop = message as StopReading;
                if (_reader != null)
                {
                    _reader.Tell(stop, stop.ReplyTo);
                }
                else
                {
                    // initializing, buffer and take care of it later when buffer is sent
                    EnqueueInBuffer(message);
                }
            }
            else if (message is TakeOver)
            {
                var takeover = message as TakeOver;

                // Shutdown old reader
                _handle.Disassociate();
                _handle = takeover.ProtocolHandle;
                takeover.ReplyTo.Tell(new TookOver(Self, _handle));
                Become(Handoff);
            }
            else if (message is FlushAndStop)
            {
                _stopReason = DisassociateInfo.Shutdown;
                Context.Stop(Self);
            }
            else if (message is OutboundAck)
            {
                var ack = message as OutboundAck;
                _lastAck = ack.Ack;
                if (_ackDeadline.IsOverdue)
                    TrySendPureAck();
            }
            else if (message is AckIdleCheckTimer || message is FlushAndStopTimeout || message is BackoffTimer)
            {
                //ignore
            }
            else
            {
                base.Unhandled(message);
            }
        }

        #endregion

        #region Internal methods

        private Deadline NewAckDeadline()
        {
            return Deadline.Now + Settings.SysMsgAckTimeout;
        }

        private void PublishAndThrow(Exception reason, LogLevel level, bool needToThrow = true)
        {
            reason.Match()
                .With<EndpointDisassociatedException>(endpoint => PublishDisassociated())
                .With<ShutDownAssociation>(shutdown => { }) // don't log an error for planned shutdowns
                .Default(msg => PublishError(reason, level));

            if (needToThrow)
            {
                throw reason;
            }
        }

        private IActorRef StartReadEndpoint(AkkaProtocolHandle handle)
        {
            var newReader =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointReader.ReaderProps(LocalAddress, RemoteAddress, Transport, Settings, _codec, _msgDispatcher,
                            Inbound, (int)handle.HandshakeInfo.Uid, _receiveBuffers, _reliableDeliverySupervisor)
                            .WithDeploy(Deploy.Local)),
                    string.Format("endpointReader-{0}-{1}", AddressUrlEncoder.Encode(RemoteAddress), _readerId.Next()));
            Context.Watch(newReader);
            handle.ReadHandlerSource.SetResult(new ActorHandleEventListener(newReader));
            return newReader;
        }

        /// <summary>
        /// Serializes the outbound message going onto the wire.
        /// </summary>
        /// <param name="msg">The C# object we intend to serialize.</param>
        /// <returns>The Akka.NET envelope containing the serialized message and addressing information.</returns>
        /// <remarks>Differs from JVM implementation due to Scala implicits.</remarks>
        private SerializedMessage SerializeMessage(object msg)
        {
            if (_handle == null)
            {
                throw new EndpointException("Internal error: No handle was present during serialization of outbound message.");
            }
            return MessageSerializer.Serialize(_system, _handle.LocalAddress, msg);
        }

        private int _writeCount = 0;
        private int _maxWriteCount = MaxWriteCount;
        private long _adaptiveBackoffNanos = 1000000L; // 1 ms
        private bool _fullBackoff = false;

        // FIXME remove these counters when tuning/testing is completed
        private int _fullBackoffCount = 1;
        private int _smallBackoffCount = 0;
        private int _noBackoffCount = 0;

        private void AdjustAdaptiveBackup()
        {
            _maxWriteCount = Math.Max(_writeCount, _maxWriteCount);
            if (_writeCount <= SendBufferBatchSize)
            {
                _fullBackoff = true;
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.2), MaxAdaptiveBackoffNanos);
            }
            else if (_writeCount >= _maxWriteCount * 0.6)
            {
                _adaptiveBackoffNanos = Math.Max(Convert.ToInt64(_adaptiveBackoffNanos * 0.9), MinAdaptiveBackoffNanos);
            }
            else if (_writeCount <= _maxWriteCount * 0.2)
            {
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.1), MaxAdaptiveBackoffNanos);
            }
            _writeCount = 0;
        }

        private void ScheduleBackoffTimer()
        {
            if (_fullBackoff)
            {
                _fullBackoffCount += 1;
                _fullBackoff = false;
                Context.System.Scheduler.ScheduleTellOnce(Settings.BackoffPeriod, Self, BackoffTimer.Instance, Self, null);
            }
            else
            {
                _smallBackoffCount += 1;
                var backoffDeadlineNanoTime = TimeSpan.FromTicks(_adaptiveBackoffNanos.ToTicks());

                Context.System.Scheduler.ScheduleTellOnce(backoffDeadlineNanoTime, Self, BackoffTimer.Instance, Self);
            }
        }

        private void DoFlushAndStop()
        {
            //Try to send last Ack message
            TrySendPureAck();
            _stopReason = DisassociateInfo.Shutdown;
            Context.Stop(Self);
        }

        private void TrySendPureAck()
        {
            if (_handle != null && _lastAck != null)
            {
                if (_handle.Write(_codec.ConstructPureAck(_lastAck)))
                {
                    _ackDeadline = NewAckDeadline();
                    _lastAck = null;
                }
            }
        }

        private void EnqueueInBuffer(object message)
        {
            var send = message as EndpointManager.Send;
            if (send != null && send.Message is IPriorityMessage)
                _prioBuffer.AddLast(send);
            else if (send != null && send.Message is ActorSelectionMessage &&
                     send.Message.AsInstanceOf<ActorSelectionMessage>().Message is IPriorityMessage)
            {
                _prioBuffer.AddLast(send);
            }
            else
            {
                _buffer.AddLast(message);
            }
        }

        private void BecomeWritingOrSendBufferedMessages()
        {
            if (!_buffer.Any())
            {
                Become(Writing);
            }
            else
            {
                Become(Buffering);
                SendBufferedMessages();
            }
        }

        private bool WriteSend(EndpointManager.Send send)
        {
            try
            {
                if (_handle == null)
                    throw new EndpointException(
                        "Internal error: Endpoint is in state Writing, but no association handle is present.");
                if (_provider.RemoteSettings.LogSend)
                {
                    _log.Debug("RemoteMessage: {0} to [{1}]<+[{2}] from [{3}]", send.Message,
                        send.Recipient, send.Recipient.Path, send.SenderOption ?? _system.DeadLetters);
                }

                var pdu = _codec.ConstructMessage(send.Recipient.LocalAddressToUse, send.Recipient,
                    this.SerializeMessage(send.Message), send.SenderOption, send.Seq, _lastAck);

                _remoteMetrics.LogPayloadBytes(send.Message, pdu.Length);

                if (pdu.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload sent to {0}: max allowed size {1} bytes, actual size of encoded {2} was {3} bytes.",
                            send.Recipient,
                            Transport.MaximumPayloadBytes,
                            send.Message.GetType(),
                            pdu.Length));
                    _log.Error(reason, "Transient association error (association remains live)");
                    return true;
                }
                else
                {
                    var ok = _handle.Write(pdu);

                    if (ok)
                    {
                        _ackDeadline = NewAckDeadline();
                        _lastAck = null;
                        return true;
                    }
                }
                return false;
            }
            catch (SerializationException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (ArgumentException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (EndpointException ex)
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel);
            }
            catch (Exception ex)
            {
                PublishAndThrow(new EndpointException("Failed to write message to the transport", ex),
                    LogLevel.ErrorLevel);
            }

            return false;
        }

        private void SendBufferedMessages()
        {
            bool SendDelegate(object msg)
            {
                switch (msg)
                {
                    case EndpointManager.Send s:
                        return WriteSend(s);
                    case FlushAndStop f:
                        DoFlushAndStop();
                        return false;
                    case StopReading stop:
                        _reader?.Tell(stop, stop.ReplyTo);
                        return true;
                    default:
                        return true;
                }
            }

            bool WriteLoop(int count)
            {
                if (count > 0 && _buffer.Any())
                {
                    if (SendDelegate(_buffer.First.Value))
                    {
                        _buffer.RemoveFirst();
                        _writeCount += 1;
                        return WriteLoop(count - 1);
                    }
                    return false;
                }

                return true;
            }

            bool WritePrioLoop()
            {
                if (!_prioBuffer.Any()) return true;
                if (WriteSend(_prioBuffer.First.Value))
                {
                    _prioBuffer.RemoveFirst();
                    return WritePrioLoop();
                }
                return false;
            }

            var size = _buffer.Count;

            var ok = WritePrioLoop() && WriteLoop(SendBufferBatchSize);
            if (!_buffer.Any() && !_prioBuffer.Any())
            {
                // FIXME remove this when testing/tuning is completed
                if (_log.IsDebugEnabled)
                {
                    _log.Debug("Drained buffer with maxWriteCount: {0}, fullBackoffCount: {1}," +
                               "smallBackoffCount: {2}, noBackoffCount: {3}," +
                               "adaptiveBackoff: {4}", _maxWriteCount, _fullBackoffCount, _smallBackoffCount, _noBackoffCount, _adaptiveBackoffNanos / 1000);
                }
                _fullBackoffCount = 1;
                _smallBackoffCount = 0;
                _noBackoffCount = 0;
                _writeCount = 0;
                _maxWriteCount = MaxWriteCount;
                Become(Writing);
            }
            else if (ok)
            {
                _noBackoffCount += 1;
                Self.Tell(BackoffTimer.Instance);
            }
            else
            {
                if (size > Settings.LogBufferSizeExceeding)
                {
                    var now = MonotonicClock.GetNanos();
                    if (now - _largeBufferLogTimestamp >= LogBufferSizeInterval)
                    {
                        _log.Warning("[{0}] buffered messages in EndpointWriter for [{1}]. You should probably implement flow control to avoid flooding the remote connection.", size, RemoteAddress);
                        _largeBufferLogTimestamp = now;
                    }
                }
            }

            AdjustAdaptiveBackup();
            ScheduleBackoffTimer();
        }

        #endregion

        #region Static methods and Internal messages

        // These settings are not configurable because wrong configuration will break the auto-tuning
        private const int SendBufferBatchSize = 5;
        private const long MinAdaptiveBackoffNanos = 300000L; // 0.3 ms
        private const long MaxAdaptiveBackoffNanos = 2000000L; // 2 ms
        private const long LogBufferSizeInterval = 5000000000L; // 5 s, in nanoseconds
        private const int MaxWriteCount = 50;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props EndpointWriterProps(AkkaProtocolHandle handleOrActive, Address localAddress,
                    Address remoteAddress, int? refuseUid, AkkaProtocolTransport transport, RemoteSettings settings,
                    AkkaPduCodec codec, ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers, IActorRef reliableDeliverySupervisor = null)
        {
            return Props.Create(
                () =>
                    new EndpointWriter(handleOrActive, localAddress, remoteAddress, refuseUid, transport, settings,
                        codec, receiveBuffers, reliableDeliverySupervisor));
        }

        /// <summary>
        /// This message signals that the current association maintained by the local <see cref="EndpointWriter"/> and
        /// <see cref="EndpointReader"/> is to be overridden by a new inbound association. This is needed to avoid parallel inbound
        /// associations from the same remote endpoint: when a parallel inbound association is detected, the old one is removed and the new
        /// one is used instead.
        /// </summary>
        public sealed class TakeOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// Create a new TakeOver command
            /// </summary>
            /// <param name="protocolHandle">The handle of the new association</param>
            /// <param name="replyTo">TBD</param>
            public TakeOver(AkkaProtocolHandle protocolHandle, IActorRef replyTo)
            {
                ProtocolHandle = protocolHandle;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class TookOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="protocolHandle">TBD</param>
            public TookOver(IActorRef writer, AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class BackoffTimer
        {
            private BackoffTimer() { }
            private static readonly BackoffTimer _instance = new BackoffTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static BackoffTimer Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class FlushAndStop
        {
            private FlushAndStop() { }
            private static readonly FlushAndStop _instance = new FlushAndStop();
            /// <summary>
            /// TBD
            /// </summary>
            public static FlushAndStop Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class AckIdleCheckTimer
        {
            private AckIdleCheckTimer() { }
            private static readonly AckIdleCheckTimer _instance = new AckIdleCheckTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static AckIdleCheckTimer Instance { get { return _instance; } }
        }

        private sealed class FlushAndStopTimeout
        {
            private FlushAndStopTimeout() { }
            private static readonly FlushAndStopTimeout _instance = new FlushAndStopTimeout();
            public static FlushAndStopTimeout Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Handle : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="protocolHandle">TBD</param>
            public Handle(AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StopReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="replyTo">TBD</param>
            public StopReading(IActorRef writer, IActorRef replyTo)
            {
                Writer = writer;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StoppedReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            public StoppedReading(IActorRef writer)
            {
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class OutboundAck
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="ack">TBD</param>
            public OutboundAck(Ack ack)
            {
                Ack = ack;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public Ack Ack { get; private set; }
        }

        private const string AckIdleTimerName = "AckIdleTimer";

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointReader : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="msgDispatch">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointReader(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher msgDispatch,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                    base(localAddress, remoteAddress, transport, settings)
        {
            _receiveBuffers = receiveBuffers;
            _msgDispatch = msgDispatch;
            Inbound = inbound;
            _uid = uid;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _codec = codec;
            _provider = RARP.For(Context.System).Provider;
            Reading();
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private readonly int _uid;
        private readonly IInboundMessageDispatcher _msgDispatch;

        private readonly IRemoteActorRefProvider _provider;
        private AckedReceiveBuffer<Message> _ackedReceiveBuffer = new AckedReceiveBuffer<Message>();

        #region ActorBase overrides

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_receiveBuffers.TryGetValue(new EndpointManager.Link(LocalAddress, RemoteAddress), out var resendState))
            {
                if(resendState.Uid == _uid)
                {
                    _ackedReceiveBuffer = resendState.Buffer;
                    DeliverAndAck();
                }
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            SaveState();
        }

        private void Reading()
        {
           
            Receive<InboundPayload>(inbound =>
            {
                var payload = inbound.Payload;
                if (payload.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload received: max allowed size {0} bytes, actual size {1} bytes.",
                            Transport.MaximumPayloadBytes,
                            payload.Length));
                    _log.Error(reason, "Transient error while reading from association (association remains live)");
                }
                else
                {
                    var ackAndMessage = TryDecodeMessageAndAck(payload);
                    if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                        _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
                    if (ackAndMessage.MessageOption != null)
                    {
                        if (ackAndMessage.MessageOption.ReliableDeliveryEnabled)
                        {
                            _ackedReceiveBuffer = _ackedReceiveBuffer.Receive(ackAndMessage.MessageOption);
                            DeliverAndAck();
                        }
                        else
                        {
                            try
                            {
                                _msgDispatch.Dispatch(ackAndMessage.MessageOption.Recipient,
                                    ackAndMessage.MessageOption.RecipientAddress,
                                    ackAndMessage.MessageOption.SerializedMessage,
                                    ackAndMessage.MessageOption.SenderOptional);
                            }
                            catch (SerializationException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (ArgumentException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (Exception e)
                            {
                                throw;
                            }
                        }
                    }
                }
            });
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                SaveState();
                Become(NotReading);
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        private void LogTransientSerializationError(Message msg, Exception error)
        {
            var sm = msg.SerializedMessage;
            _log.Warning(
              "Serializer not defined for message with serializer id [{0}] and manifest [{1}]. " +
                "Transient association error (association remains live). {2}",
              sm.SerializerId,
              sm.MessageManifest.IsEmpty ? "" : sm.MessageManifest.ToStringUtf8(),
              error.Message);
        }

        private void NotReading()
        {
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<InboundPayload>(payload =>
            {
                var ackAndMessage = TryDecodeMessageAndAck(payload.Payload);
                if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                    _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion



        #region Lifecycle event handlers

        private void SaveState()
        {
            EndpointManager.ResendState Merge(EndpointManager.ResendState current,
                EndpointManager.ResendState oldState)
            {
                if (current.Uid == oldState.Uid) return new EndpointManager.ResendState(_uid, oldState.Buffer.MergeFrom(current.Buffer));
                return current;
            }

            void UpdateSavedState(EndpointManager.Link key, EndpointManager.ResendState expectedState)
            {
                if (expectedState == null)
                {
                    if (!_receiveBuffers.TryAdd(key, new EndpointManager.ResendState(_uid, _ackedReceiveBuffer)))
                    {
                        _receiveBuffers.TryGetValue(key, out var prevValue);
                        UpdateSavedState(key, prevValue);
                    }
                }
                else if (!_receiveBuffers.TryUpdate(key,
                    Merge(new EndpointManager.ResendState(_uid, _ackedReceiveBuffer), expectedState), expectedState))
                {
                    _receiveBuffers.TryGetValue(key, out var prevValue);
                    UpdateSavedState(key, prevValue);
                }
            }

            var k = new EndpointManager.Link(LocalAddress, RemoteAddress);
            UpdateSavedState(k, !_receiveBuffers.TryGetValue(k, out var previousValue) ? null : previousValue);
        }

        private void HandleDisassociated(DisassociateInfo info)
        {
            switch (info)
            {
                case DisassociateInfo.Quarantined:
                    throw new InvalidAssociation("The remote system has quarantined this system. No further associations " +
                                                   "to the remote system are possible until this system is restarted.", LocalAddress, RemoteAddress, disassociateInfo: DisassociateInfo.Quarantined);
                case DisassociateInfo.Shutdown:
                    throw new ShutDownAssociation($"The remote system terminated the association because it is shutting down. Shut down address: {RemoteAddress}", LocalAddress, RemoteAddress);
                case DisassociateInfo.Unknown:
                default:
                    Context.Stop(Self);
                    break;
            }
        }

        private void DeliverAndAck()
        {
            var deliverable = _ackedReceiveBuffer.ExtractDeliverable();
            _ackedReceiveBuffer = deliverable.Buffer;

            // Notify writer that some messages can be acked
            Context.Parent.Tell(new EndpointWriter.OutboundAck(deliverable.Ack));
            deliverable.Deliverables.ForEach(msg => _msgDispatch.Dispatch(msg.Recipient, msg.RecipientAddress, msg.SerializedMessage, msg.SenderOptional));
        }

        private AckAndMessage TryDecodeMessageAndAck(ByteString pdu)
        {
            try
            {
                return _codec.DecodeMessage(pdu, _provider, LocalAddress);
            }
            catch (Exception ex)
            {
                throw new EndpointException("Error while decoding incoming Akka PDU", ex);
            }
        }

        #endregion

        #region Static members

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReaderProps(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher dispatcher,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null)
        {
            return
                Props.Create(
                    () =>
                        new EndpointReader(localAddress, remoteAddress, transport, settings, codec, dispatcher, inbound,
                            uid, receiveBuffers, reliableDeliverySupervisor))
                            .WithDispatcher(settings.Dispatcher);
        }

        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Dispatch;
using Akka.Dispatch.SysMsg;
using Akka.Event;
using Akka.Pattern;
using Akka.Remote.Serialization;
using Akka.Remote.Transport;
using Akka.Serialization;
using Akka.Util;
using Akka.Util.Internal;
using Google.Protobuf;
using SerializedMessage = Akka.Remote.Serialization.Proto.Msg.Payload;

namespace Akka.Remote
{
    /// <summary>
    /// INTERNAL API
    /// </summary>
    // ReSharper disable once InconsistentNaming
    internal interface IInboundMessageDispatcher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null);
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class DefaultMessageDispatcher : IInboundMessageDispatcher
    {
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ILoggingAdapter _log;
        private readonly IInternalActorRef _remoteDaemon;
        private readonly RemoteSettings _settings;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="provider">TBD</param>
        /// <param name="log">TBD</param>
        public DefaultMessageDispatcher(ExtendedActorSystem system, IRemoteActorRefProvider provider, ILoggingAdapter log)
        {
            _system = system;
            _provider = provider;
            _log = log;
            _remoteDaemon = provider.RemoteDaemon;
            _settings = provider.RemoteSettings;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="recipient">TBD</param>
        /// <param name="recipientAddress">TBD</param>
        /// <param name="message">TBD</param>
        /// <param name="senderOption">TBD</param>
        public void Dispatch(IInternalActorRef recipient, Address recipientAddress, SerializedMessage message,
            IActorRef senderOption = null)
        {
            var payload = MessageSerializer.Deserialize(_system, message);
            var payloadClass = payload?.GetType();
            var sender = senderOption ?? _system.DeadLetters;
            var originalReceiver = recipient.Path;

            // message is intended for the RemoteDaemon, usually a command to create a remote actor
            if (recipient.Equals(_remoteDaemon))
            {
                if (_settings.UntrustedMode) _log.Debug("dropping daemon message in untrusted mode");
                else
                {
                    if (_settings.LogReceive)
                    {
                        var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                        _log.Debug("received daemon message [{0}]", msgLog);
                    }
                    _remoteDaemon.Tell(payload);
                }
            }

            //message is intended for a local recipient
            else if ((recipient is ILocalRef || recipient is RepointableActorRef) && recipient.IsLocal)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = $"RemoteMessage: {payload} to {recipient}<+{originalReceiver} from {sender}";
                    _log.Debug("received local message [{0}]", msgLog);
                }
                if (payload is ActorSelectionMessage sel)
                {
                    if (_settings.UntrustedMode
                        && (!_settings.TrustedSelectionPaths.Contains(FormatActorPath(sel))
                            || sel.Message is IPossiblyHarmful
                            || !recipient.Equals(_provider.RootGuardian)))
                    {
                        _log.Debug(
                            "operating in UntrustedMode, dropping inbound actor selection to [{0}], allow it" +
                            "by adding the path to 'akka.remote.trusted-selection-paths' in configuration",
                            FormatActorPath(sel));
                    }
                    else
                    {
                        //run the receive logic for ActorSelectionMessage here to make sure it is not stuck on busy user actor
                        ActorSelection.DeliverSelection(recipient, sender, sel);
                    }
                }
                else if (payload is IPossiblyHarmful && _settings.UntrustedMode)
                {
                    _log.Debug("operating in UntrustedMode, dropping inbound IPossiblyHarmful message of type {0}",
                        payload.GetType());
                }
                else if (payload is ISystemMessage systemMessage)
                {
                    recipient.SendSystemMessage(systemMessage);
                }
                else
                {
                    recipient.Tell(payload, sender);
                }
            }

            // message is intended for a remote-deployed recipient
            else if ((recipient is IRemoteRef || recipient is RepointableActorRef) && !recipient.IsLocal &&
                     !_settings.UntrustedMode)
            {
                if (_settings.LogReceive)
                {
                    var msgLog = string.Format("RemoteMessage: {0} to {1}<+{2} from {3}", payload, recipient, originalReceiver, sender);
                    _log.Debug("received remote-destined message {0}", msgLog);
                }
                if (_provider.Transport.Addresses.Contains(recipientAddress))
                {
                    //if it was originally addressed to us but is in fact remote from our point of view (i.e. remote-deployed)
                    recipient.Tell(payload, sender);
                }
                else
                {
                    _log.Error(
                        "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                        payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
                }
            }
            else
            {
                _log.Error(
                    "Dropping message [{0}] for non-local recipient [{1}] arriving at [{2}] inbound addresses [{3}]",
                    payloadClass, recipient, recipientAddress, string.Join(",", _provider.Transport.Addresses));
            }
        }

        private static string FormatActorPath(ActorSelectionMessage sel)
        {
            return "/" + string.Join("/", sel.Elements.Select(x => x.ToString()));
        }
    }

    #region Endpoint Exception Types

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointException : AkkaException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="cause">The exception that is the cause of the current exception.</param>
        public EndpointException(string message, Exception cause = null) : base(message, cause) { }

#if SERIALIZATION
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected EndpointException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
#endif
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal interface IAssociationProblem { }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class ShutDownAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="cause">TBD</param>
        public ShutDownAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal sealed class InvalidAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TbD</param>
        /// <param name="cause">TBD</param>
        /// <param name="disassociateInfo">TBD</param>
        public InvalidAssociation(string message, Address localAddress, Address remoteAddress, Exception cause = null, DisassociateInfo? disassociateInfo = null)
            : base(message, cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            DisassociationInfo = disassociateInfo;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public DisassociateInfo? DisassociationInfo { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class HopelessAssociation : EndpointException, IAssociationProblem
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="cause">TBD</param>
        public HopelessAssociation(Address localAddress, Address remoteAddress, int? uid = null, Exception cause = null)
            : base("Catastrophic association error.", cause)
        {
            RemoteAddress = remoteAddress;
            LocalAddress = localAddress;
            Uid = uid;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public Address LocalAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public Address RemoteAddress { get; private set; }

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; private set; }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointDisassociatedException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointDisassociatedException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointDisassociatedException(string message)
            : base(message)
        {
        }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class EndpointAssociationException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public EndpointAssociationException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointAssociationException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        public EndpointAssociationException(string message, Exception innerException) : base(message, innerException) { }
    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal sealed class OversizedPayloadException : EndpointException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OversizedPayloadException"/> class.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public OversizedPayloadException(string message)
            : base(message)
        {
        }
    }

    #endregion

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class ReliableDeliverySupervisor : ReceiveActor
    {
        #region Internal message classes

        /// <summary>
        /// TBD
        /// </summary>
        public class IsIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly IsIdle Instance = new IsIdle();
            private IsIdle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class Idle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly Idle Instance = new Idle();
            private Idle() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public class TooLongIdle
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly TooLongIdle Instance = new TooLongIdle();
            private TooLongIdle() { }
        }

        #endregion

        private readonly ILoggingAdapter _log = Context.GetLogger();

        private readonly Address _localAddress;
        private readonly Address _remoteAddress;
        private readonly int? _refuseUid;
        private readonly AkkaProtocolTransport _transport;
        private readonly RemoteSettings _settings;
        private AkkaPduCodec _codec;
        private AkkaProtocolHandle _currentHandle;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        public ReliableDeliverySupervisor(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers)
        {
            _localAddress = localAddress;
            _remoteAddress = remoteAddress;
            _refuseUid = refuseUid;
            _transport = transport;
            _settings = settings;
            _codec = codec;
            _currentHandle = handleOrActive;
            _receiveBuffers = receiveBuffers;
            Reset(); // needs to be called at startup
            _writer = CreateWriter(); // need to create writer at startup
            Uid = handleOrActive != null ? (int?)handleOrActive.HandshakeInfo.Uid : null;
            UidConfirmed = Uid.HasValue && (Uid != _refuseUid);

            if (Uid.HasValue && Uid == _refuseUid)
                throw new HopelessAssociation(localAddress, remoteAddress, Uid,
                    new InvalidOperationException(
                        $"The remote system [{remoteAddress}] has a UID [{Uid}] that has been quarantined. Association aborted."));

            Receiving();
            _autoResendTimer = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(_settings.SysResendTimeout, _settings.SysResendTimeout, Self, new AttemptSysMsgRedelivery(),
                    Self);
        }

        private readonly ICancelable _autoResendTimer;

        /// <summary>
        /// TBD
        /// </summary>
        public int? Uid { get; set; }

        /// <summary>
        /// Processing of <see cref="Ack"/>s has to be delayed until the UID is discovered after a reconnect. Depending whether the
        /// UID matches the expected one, pending Acks can be processed or must be dropped. It is guaranteed that for any inbound
        /// connections (calling <see cref="CreateWriter"/>) the first message from that connection is <see cref="GotUid"/>, therefore it serves
        /// a separator.
        ///
        /// If we already have an inbound handle then UID is initially confirmed.
        /// (This actor is never restarted.)
        /// </summary>
        public bool UidConfirmed { get; private set; }

        private Deadline _bailoutAt = null;

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                if (ex is IAssociationProblem)
                    return Directive.Escalate;

                _log.Warning("Association with remote system {0} has failed; address is now gated for {1} ms. Reason is: [{2}]", _remoteAddress, _settings.RetryGateClosedFor.TotalMilliseconds, ex);
                UidConfirmed = false; // Need confirmation of UID again

                if ((_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any()) && _bailoutAt == null)
                    _bailoutAt = Deadline.Now + _settings.InitialSysMsgDeliveryTimeout;
                Become(() => Gated(writerTerminated: false, earlyUngateRequested: false));
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                return Directive.Stop;
            });
        }


        private ICancelable _maxSilenceTimer = null;
        private AckedSendBuffer<EndpointManager.Send> _resendBuffer;
        private long _seqCounter;

        private IActorRef _writer;

        private void Reset()
        {
            _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(_settings.SysMsgBufferSize);
            _seqCounter = 0L;
            _bailoutAt = null;
        }

        private SeqNo NextSeq()
        {
            var tmp = _seqCounter;
            _seqCounter++;
            return new SeqNo(tmp);
        }

        #region ActorBase methods and Behaviors

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            // All remaining messages in the buffer has to be delivered to dead letters. It is important to clear the sequence
            // number otherwise deadLetters will ignore it to avoid reporting system messages as dead letters while they are
            // still possibly retransmitted.
            // Such a situation may arise when the EndpointWriter is shut down, and all of its mailbox contents are delivered
            // to dead letters. These messages should be ignored, as they still live in resendBuffer and might be delivered to
            // the remote system later.
            foreach (var msg in _resendBuffer.Nacked.Concat(_resendBuffer.NonAcked))
            {
                Context.System.DeadLetters.Tell(msg.Copy(opt: null));
            }

            _log.Info("Removing receive buffers for [{0}]->[{1}]", _localAddress, _remoteAddress);
            _receiveBuffers.TryRemove(new EndpointManager.Link(_localAddress, _remoteAddress), out _);
            _autoResendTimer.Cancel();
            _maxSilenceTimer?.Cancel();
        }

        /// <summary>
        /// N/A
        /// </summary>
        /// <param name="reason">N/A</param>
        /// <exception cref="IllegalActorStateException">
        /// This exception is thrown automatically since <see cref="ReliableDeliverySupervisor"/> must not be restarted.
        /// </exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("BUG: ReliableDeliverySupervisor has been attempted to be restarted. This must not happen.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Receiving()
        {
            Receive<EndpointWriter.FlushAndStop>(flush =>
            {
                //Trying to serve until our last breath
                ResendAll();
                _writer.Tell(EndpointWriter.FlushAndStop.Instance);
                Become(FlushWait);
            });
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, or send a GotUid
            Receive<EndpointManager.Send>(send => HandleSend(send));
            Receive<Ack>(ack =>
            {
                // If we are not sure about the UID just ignore the ack. Ignoring is fine.
                if (UidConfirmed)
                {
                    try
                    {
                        _resendBuffer = _resendBuffer.Acknowledge(ack);
                    }
                    catch (Exception ex)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new IllegalStateException($"Error encountered while processing system message acknowledgement buffer: {_resendBuffer} ack: {ack}", ex));
                    }

                    ResendNacked();
                }
            });
            Receive<AttemptSysMsgRedelivery>(sysmsg =>
            {
                if (UidConfirmed) ResendAll();
            });
            Receive<Terminated>(terminated =>
            {
                _currentHandle = null;
                Context.Parent.Tell(new EndpointWriter.StoppedReading(Self));
                if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                    Context.System.Scheduler.ScheduleTellOnce(_settings.SysResendTimeout, Self,
                        new AttemptSysMsgRedelivery(), Self);
                GoToIdle();
            });
            Receive<GotUid>(g =>
            {
                _bailoutAt = null;
                Context.Parent.Tell(g);
                //New system that has the same address as the old - need to start from fresh state
                UidConfirmed = true;
                if (Uid.HasValue && Uid.Value != g.Uid) Reset();
                Uid = g.Uid;
                ResendAll();
            });
            Receive<EndpointWriter.StopReading>(stopped =>
            {
                _writer.Forward(stopped); //forward the request
            });
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        private void GoToIdle()
        {
            if (_maxSilenceTimer == null)
                _maxSilenceTimer =
                    Context.System.Scheduler.ScheduleTellOnceCancelable(_settings.QuarantineSilentSystemTimeout, Self,
                        TooLongIdle.Instance, Self);
            Become(IdleBehavior);
        }

        private void GoToActive()
        {
            _maxSilenceTimer?.Cancel();
            _maxSilenceTimer = null;
            Become(Receiving);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="writerTerminated">TBD</param>
        /// <param name="earlyUngateRequested">TBD</param>
        /// <exception cref="HopelessAssociation">TBD</exception>
        protected void Gated(bool writerTerminated, bool earlyUngateRequested)
        {
            Receive<Terminated>(terminated =>
            {
                if (!writerTerminated)
                {
                    if (earlyUngateRequested)
                        Self.Tell(new Ungate());
                    else
                    {
                        Context.System.Scheduler.ScheduleTellOnce(_settings.RetryGateClosedFor, Self, new Ungate(), Self);
                    }
                }

                Become(() => Gated(true, earlyUngateRequested));
            });
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<Ungate>(ungate =>
            {
                if (!writerTerminated)
                {
                    // Ungate was sent from EndpointManager, but we must wait for Terminated first.
                    Become(() => Gated(false, true));
                }
                else if (_resendBuffer.NonAcked.Any() || _resendBuffer.Nacked.Any())
                {
                    // If we talk to a system we have not talked to before (or has given up talking to in the past) stop
                    // system delivery attempts after the specified time. This act will drop the pending system messages and gate the
                    // remote address at the EndpointManager level stopping this actor. In case the remote system becomes reachable
                    // again it will be immediately quarantined due to out-of-sync system message buffer and becomes quarantined.
                    // In other words, this action is safe.
                    if (_bailoutAt != null && _bailoutAt.IsOverdue)
                    {
                        throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                            new TimeoutException("Delivery of system messages timed out and they were dropped"));
                    }

                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
                else
                {
                    GoToIdle();
                }
            });
            Receive<AttemptSysMsgRedelivery>(redelivery => { }); // Ignore
            Receive<EndpointManager.Send>(send => send.Message is ISystemMessage, send => TryBuffer(send.Copy(NextSeq())));
            Receive<EndpointManager.Send>(send => Context.System.DeadLetters.Tell(send));
            Receive<EndpointWriter.FlushAndStop>(flush => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
                Sender.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void IdleBehavior()
        {
            Receive<IsIdle>(idle => Sender.Tell(Idle.Instance));
            Receive<EndpointManager.Send>(send =>
            {
                _writer = CreateWriter();
                //Resending will be triggered by the incoming GotUid message after the connection finished
                HandleSend(send);
                GoToActive();
            });

            Receive<AttemptSysMsgRedelivery>(sys =>
            {
                if (_resendBuffer.Nacked.Any() || _resendBuffer.NonAcked.Any())
                {
                    _writer = CreateWriter();
                    //Resending will be triggered by the incoming GotUid message after the connection finished
                    GoToActive();
                }
            });
            Receive<TooLongIdle>(idle =>
            {
                HandleTooLongIdle();
            });
            Receive<EndpointWriter.FlushAndStop>(stop => Context.Stop(Self));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<Ungate>(_ => { }); //ok, not gated
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void FlushWait()
        {
            Receive<IsIdle>(idle => { }); // Do not reply, we will Terminate soon, which will do the inbound connection unstashing
            Receive<Terminated>(terminated =>
            {
                //Clear buffer to prevent sending system messages to dead letters -- at this point we are shutting down and
                //don't know if they were properly delivered or not
                _resendBuffer = new AckedSendBuffer<EndpointManager.Send>(0);
                Context.Stop(Self);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion

        #region Static methods and Internal Message Types

        /// <summary>
        /// TBD
        /// </summary>
        public class AttemptSysMsgRedelivery { }

        /// <summary>
        /// TBD
        /// </summary>
        public class Ungate { }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class GotUid
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="uid">TBD</param>
            /// <param name="remoteAddress">TBD</param>
            public GotUid(int uid, Address remoteAddress)
            {
                Uid = uid;
                RemoteAddress = remoteAddress;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public int Uid { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public Address RemoteAddress { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReliableDeliverySupervisorProps(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    string dispatcher)
        {
            return
                Props.Create(
                    () =>
                        new ReliableDeliverySupervisor(handleOrActive, localAddress, remoteAddress, refuseUid, transport,
                            settings, codec, receiveBuffers))
                    .WithDispatcher(dispatcher);
        }

        #endregion

        // Extracted this method to solve a compiler issue with `Receive<TooLongIdle>`
        private void HandleTooLongIdle()
        {
            throw new HopelessAssociation(_localAddress, _remoteAddress, Uid,
                new TimeoutException("Delivery of system messages timed out and they were dropped"));
        }

        private void HandleSend(EndpointManager.Send send)
        {
            if (send.Message is ISystemMessage)
            {
                var sequencedSend = send.Copy(NextSeq());
                TryBuffer(sequencedSend);
                // If we have not confirmed the remote UID we cannot transfer the system message at this point just buffer it.
                // GotUid will kick ResendAll() causing the messages to be properly written.
                // Flow control by not sending more when we already have many outstanding.
                if (UidConfirmed && _resendBuffer.NonAcked.Count <= _settings.SysResendLimit) _writer.Tell(sequencedSend);
            }
            else
            {
                _writer.Tell(send);
            }
        }

        private void ResendNacked()
        {
            _resendBuffer.Nacked.ForEach(nacked => _writer.Tell(nacked));
        }

        private void ResendAll()
        {
            ResendNacked();
            _resendBuffer.NonAcked.Take(_settings.SysResendLimit).ForEach(nonacked => _writer.Tell(nonacked));
        }

        private void TryBuffer(EndpointManager.Send s)
        {
            try
            {
                _resendBuffer = _resendBuffer.Buffer(s);
            }
            catch (Exception ex)
            {
                throw new HopelessAssociation(_localAddress, _remoteAddress, Uid, ex);
            }
        }

        #region Writer create

        private IActorRef CreateWriter()
        {
            var writer =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointWriter.EndpointWriterProps(_currentHandle, _localAddress, _remoteAddress, _refuseUid, _transport,
                            _settings, new AkkaPduProtobuffCodec(Context.System), _receiveBuffers, Self)
                            .WithDeploy(Deploy.Local)),
                    "endpointWriter");
            Context.Watch(writer);
            return writer;
        }

        #endregion

    }

    /// <summary>
    /// Abstract base class for <see cref="EndpointReader"/> classes
    /// </summary>
    internal abstract class EndpointActor : ReceiveActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        protected readonly Address LocalAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected Address RemoteAddress;
        /// <summary>
        /// TBD
        /// </summary>
        protected RemoteSettings Settings;
        /// <summary>
        /// TBD
        /// </summary>
        protected AkkaProtocolTransport Transport;

        private readonly ILoggingAdapter _log = Context.GetLogger();

        /// <summary>
        /// TBD
        /// </summary>
        protected readonly EventPublisher EventPublisher;
        /// <summary>
        /// TBD
        /// </summary>
        protected bool Inbound { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        protected EndpointActor(Address localAddress, Address remoteAddress, AkkaProtocolTransport transport,
            RemoteSettings settings)
        {
            EventPublisher = new EventPublisher(Context.System, _log, Logging.LogLevelFor(settings.RemoteLifecycleEventsLogLevel));
            LocalAddress = localAddress;
            RemoteAddress = remoteAddress;
            Transport = transport;
            Settings = settings;
        }

        #region Event publishing methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="ex">TBD</param>
        /// <param name="level">TBD</param>
        protected void PublishError(Exception ex, LogLevel level)
        {
            TryPublish(new AssociationErrorEvent(ex, LocalAddress, RemoteAddress, Inbound, level));
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected void PublishDisassociated()
        {
            TryPublish(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        private void TryPublish(RemotingLifecycleEvent ev)
        {
            try
            {
                EventPublisher.NotifyListeners(ev);
            }
            catch (Exception ex)
            {
                _log.Error(ex, "Unable to publish error event to EventStream");
            }
        }

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointWriter : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointWriter(
                    AkkaProtocolHandle handleOrActive,
                    Address localAddress,
                    Address remoteAddress,
                    int? refuseUid,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                        base(localAddress, remoteAddress, transport, settings)
        {
            _refuseUid = refuseUid;
            _codec = codec;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _system = Context.System.AsInstanceOf<ExtendedActorSystem>();
            _provider = RARP.For(Context.System).Provider;
            _msgDispatcher = new DefaultMessageDispatcher(_system, _provider, _log);
            _receiveBuffers = receiveBuffers;
            Inbound = handleOrActive != null;
            _ackDeadline = NewAckDeadline();
            _handle = handleOrActive;
            _remoteMetrics = RemoteMetricsExtension.Create(Context.System.AsInstanceOf<ExtendedActorSystem>());

            if (_handle == null)
            {
                Initializing();
            }
            else
            {
                Writing();
            }
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly int? _refuseUid;
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ExtendedActorSystem _system;
        private readonly IRemoteActorRefProvider _provider;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private DisassociateInfo _stopReason = DisassociateInfo.Unknown;

        private IActorRef _reader;
        private readonly AtomicCounter _readerId = new AtomicCounter(0);
        private readonly IInboundMessageDispatcher _msgDispatcher;

        private Ack _lastAck = null;
        private Deadline _ackDeadline;
        private AkkaProtocolHandle _handle;

        private ICancelable _ackIdleTimerCancelable;

        // Use an internal buffer instead of Stash for efficiency
        // stash/unstashAll is slow when many messages are stashed
        // IMPORTANT: sender is not stored, so .Sender and forward must not be used in EndpointWriter
        private readonly LinkedList<object> _buffer = new LinkedList<object>();

        //buffer for IPriorityMessages - ensures that heartbeats get delivered before user-defined messages
        private readonly LinkedList<EndpointManager.Send> _prioBuffer = new LinkedList<EndpointManager.Send>();
        private long _largeBufferLogTimestamp = MonotonicClock.GetNanos();

        private readonly IRemoteMetrics _remoteMetrics;

        #region ActorBase methods

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy()
        {
            return new OneForOneStrategy(ex =>
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel, false);
                return Directive.Escalate;
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="reason">TBD</param>
        /// <exception cref="IllegalActorStateException">TBD</exception>
        protected override void PostRestart(Exception reason)
        {
            throw new IllegalActorStateException("EndpointWriter must not be restarted");
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_handle == null)
            {
                var self = Self;
                AssociateAsync().PipeTo(self);
            }
            else
            {
                _reader = StartReadEndpoint(_handle);
            }

            var ackIdleInterval = new TimeSpan(Settings.SysMsgAckTimeout.Ticks / 2);
            _ackIdleTimerCancelable = Context.System.Scheduler.ScheduleTellRepeatedlyCancelable(ackIdleInterval, ackIdleInterval, Self, AckIdleCheckTimer.Instance, Self);
        }

        private async Task<object> AssociateAsync()
        {
            try
            {
                return new Handle(await Transport.Associate(RemoteAddress, _refuseUid).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                return new Status.Failure(e.InnerException ?? e);
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            _ackIdleTimerCancelable.CancelIfNotNull();

            foreach (var msg in _prioBuffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _prioBuffer.Clear();

            foreach (var msg in _buffer)
            {
                _system.DeadLetters.Tell(msg);
            }
            _buffer.Clear();

            if (_handle != null) _handle.Disassociate(_stopReason);
            EventPublisher.NotifyListeners(new DisassociatedEvent(LocalAddress, RemoteAddress, Inbound));
        }

        #endregion

        #region Receives

        private void Initializing()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<Status.Failure>(failure =>
            {
                if (failure.Cause is InvalidAssociationException)
                {
                    if (failure.Cause.InnerException == null)
                    {
                        PublishAndThrow(new InvalidAssociation(failure.Cause.Message, LocalAddress, RemoteAddress), LogLevel.WarningLevel);
                    }
                }

                PublishAndThrow(new InvalidAssociation($"Association failed with {RemoteAddress}", LocalAddress, RemoteAddress, failure.Cause), LogLevel.WarningLevel);
            });
            Receive<Handle>(handle =>
            {
                // Assert handle == None?
                Context.Parent.Tell(
                    new ReliableDeliverySupervisor.GotUid((int)handle.ProtocolHandle.HandshakeInfo.Uid, RemoteAddress));
                _handle = handle.ProtocolHandle;
                _reader = StartReadEndpoint(_handle);
                EventPublisher.NotifyListeners(new AssociatedEvent(LocalAddress, RemoteAddress, Inbound));
                BecomeWritingOrSendBufferedMessages();
            });
        }

        private void Buffering()
        {
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
            Receive<BackoffTimer>(backoff => SendBufferedMessages());
            Receive<FlushAndStop>(stop =>
            {
                _buffer.AddLast(stop); //Flushing is postponed after the pending writes
                Context.System.Scheduler.ScheduleTellOnce(Settings.FlushWait, Self, FlushAndStopTimeout.Instance, Self);
            });
            Receive<FlushAndStopTimeout>(timeout =>
            {
                // enough, ready to flush
                DoFlushAndStop();
            });
        }

        private void Writing()
        {
            Receive<EndpointManager.Send>(s =>
            {
                if (!WriteSend(s))
                {
                    if (s.Seq == null) EnqueueInBuffer(s);
                    ScheduleBackoffTimer();
                    Become(Buffering);
                }
            });
            Receive<FlushAndStop>(flush => DoFlushAndStop());
            Receive<AckIdleCheckTimer>(ack =>
            {
                if (_ackDeadline.IsOverdue)
                {
                    TrySendPureAck();
                }
            });
        }

        private void Handoff()
        {
            Receive<Terminated>(terminated =>
            {
                _reader = StartReadEndpoint(_handle);
                BecomeWritingOrSendBufferedMessages();
            });
            Receive<EndpointManager.Send>(send => EnqueueInBuffer(send));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        protected override void Unhandled(object message)
        {
            if (message is Terminated)
            {
                var t = message as Terminated;
                if (_reader == null || t.ActorRef.Equals(_reader))
                {
                    PublishAndThrow(new EndpointDisassociatedException("Disassociated"), LogLevel.DebugLevel);
                }
            }
            else if (message is StopReading)
            {
                var stop = message as StopReading;
                if (_reader != null)
                {
                    _reader.Tell(stop, stop.ReplyTo);
                }
                else
                {
                    // initializing, buffer and take care of it later when buffer is sent
                    EnqueueInBuffer(message);
                }
            }
            else if (message is TakeOver)
            {
                var takeover = message as TakeOver;

                // Shutdown old reader
                _handle.Disassociate();
                _handle = takeover.ProtocolHandle;
                takeover.ReplyTo.Tell(new TookOver(Self, _handle));
                Become(Handoff);
            }
            else if (message is FlushAndStop)
            {
                _stopReason = DisassociateInfo.Shutdown;
                Context.Stop(Self);
            }
            else if (message is OutboundAck)
            {
                var ack = message as OutboundAck;
                _lastAck = ack.Ack;
                if (_ackDeadline.IsOverdue)
                    TrySendPureAck();
            }
            else if (message is AckIdleCheckTimer || message is FlushAndStopTimeout || message is BackoffTimer)
            {
                //ignore
            }
            else
            {
                base.Unhandled(message);
            }
        }

        #endregion

        #region Internal methods

        private Deadline NewAckDeadline()
        {
            return Deadline.Now + Settings.SysMsgAckTimeout;
        }

        private void PublishAndThrow(Exception reason, LogLevel level, bool needToThrow = true)
        {
            reason.Match()
                .With<EndpointDisassociatedException>(endpoint => PublishDisassociated())
                .With<ShutDownAssociation>(shutdown => { }) // don't log an error for planned shutdowns
                .Default(msg => PublishError(reason, level));

            if (needToThrow)
            {
                throw reason;
            }
        }

        private IActorRef StartReadEndpoint(AkkaProtocolHandle handle)
        {
            var newReader =
                Context.ActorOf(RARP.For(Context.System)
                    .ConfigureDispatcher(
                        EndpointReader.ReaderProps(LocalAddress, RemoteAddress, Transport, Settings, _codec, _msgDispatcher,
                            Inbound, (int)handle.HandshakeInfo.Uid, _receiveBuffers, _reliableDeliverySupervisor)
                            .WithDeploy(Deploy.Local)),
                    string.Format("endpointReader-{0}-{1}", AddressUrlEncoder.Encode(RemoteAddress), _readerId.Next()));
            Context.Watch(newReader);
            handle.ReadHandlerSource.SetResult(new ActorHandleEventListener(newReader));
            return newReader;
        }

        /// <summary>
        /// Serializes the outbound message going onto the wire.
        /// </summary>
        /// <param name="msg">The C# object we intend to serialize.</param>
        /// <returns>The Akka.NET envelope containing the serialized message and addressing information.</returns>
        /// <remarks>Differs from JVM implementation due to Scala implicits.</remarks>
        private SerializedMessage SerializeMessage(object msg)
        {
            if (_handle == null)
            {
                throw new EndpointException("Internal error: No handle was present during serialization of outbound message.");
            }
            return MessageSerializer.Serialize(_system, _handle.LocalAddress, msg);
        }

        private int _writeCount = 0;
        private int _maxWriteCount = MaxWriteCount;
        private long _adaptiveBackoffNanos = 1000000L; // 1 ms
        private bool _fullBackoff = false;

        // FIXME remove these counters when tuning/testing is completed
        private int _fullBackoffCount = 1;
        private int _smallBackoffCount = 0;
        private int _noBackoffCount = 0;

        private void AdjustAdaptiveBackup()
        {
            _maxWriteCount = Math.Max(_writeCount, _maxWriteCount);
            if (_writeCount <= SendBufferBatchSize)
            {
                _fullBackoff = true;
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.2), MaxAdaptiveBackoffNanos);
            }
            else if (_writeCount >= _maxWriteCount * 0.6)
            {
                _adaptiveBackoffNanos = Math.Max(Convert.ToInt64(_adaptiveBackoffNanos * 0.9), MinAdaptiveBackoffNanos);
            }
            else if (_writeCount <= _maxWriteCount * 0.2)
            {
                _adaptiveBackoffNanos = Math.Min(Convert.ToInt64(_adaptiveBackoffNanos * 1.1), MaxAdaptiveBackoffNanos);
            }
            _writeCount = 0;
        }

        private void ScheduleBackoffTimer()
        {
            if (_fullBackoff)
            {
                _fullBackoffCount += 1;
                _fullBackoff = false;
                Context.System.Scheduler.ScheduleTellOnce(Settings.BackoffPeriod, Self, BackoffTimer.Instance, Self, null);
            }
            else
            {
                _smallBackoffCount += 1;
                var backoffDeadlineNanoTime = TimeSpan.FromTicks(_adaptiveBackoffNanos.ToTicks());

                Context.System.Scheduler.ScheduleTellOnce(backoffDeadlineNanoTime, Self, BackoffTimer.Instance, Self);
            }
        }

        private void DoFlushAndStop()
        {
            //Try to send last Ack message
            TrySendPureAck();
            _stopReason = DisassociateInfo.Shutdown;
            Context.Stop(Self);
        }

        private void TrySendPureAck()
        {
            if (_handle != null && _lastAck != null)
            {
                if (_handle.Write(_codec.ConstructPureAck(_lastAck)))
                {
                    _ackDeadline = NewAckDeadline();
                    _lastAck = null;
                }
            }
        }

        private void EnqueueInBuffer(object message)
        {
            if (message is EndpointManager.Send send && send.Message is IPriorityMessage)
                _prioBuffer.AddLast(send);
            else if (message is EndpointManager.Send send && send.Message is ActorSelectionMessage &&
                     send.Message.AsInstanceOf<ActorSelectionMessage>().Message is IPriorityMessage)
            {
                _prioBuffer.AddLast(send);
            }
            else
            {
                _buffer.AddLast(message);
            }
        }

        private void BecomeWritingOrSendBufferedMessages()
        {
            if (!_buffer.Any())
            {
                Become(Writing);
            }
            else
            {
                Become(Buffering);
                SendBufferedMessages();
            }
        }

        private bool WriteSend(EndpointManager.Send send)
        {
            try
            {
                if (_handle == null)
                    throw new EndpointException(
                        "Internal error: Endpoint is in state Writing, but no association handle is present.");
                if (_provider.RemoteSettings.LogSend)
                {
                    _log.Debug("RemoteMessage: {0} to [{1}]<+[{2}] from [{3}]", send.Message,
                        send.Recipient, send.Recipient.Path, send.SenderOption ?? _system.DeadLetters);
                }

                var pdu = _codec.ConstructMessage(send.Recipient.LocalAddressToUse, send.Recipient,
                    this.SerializeMessage(send.Message), send.SenderOption, send.Seq, _lastAck);

                _remoteMetrics.LogPayloadBytes(send.Message, pdu.Length);

                if (pdu.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload sent to {0}: max allowed size {1} bytes, actual size of encoded {2} was {3} bytes.",
                            send.Recipient,
                            Transport.MaximumPayloadBytes,
                            send.Message.GetType(),
                            pdu.Length));
                    _log.Error(reason, "Transient association error (association remains live)");
                    return true;
                }
                else
                {
                    var ok = _handle.Write(pdu);

                    if (ok)
                    {
                        _ackDeadline = NewAckDeadline();
                        _lastAck = null;
                        return true;
                    }
                }
                return false;
            }
            catch (SerializationException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (ArgumentException ex)
            {
                _log.Error(
                  ex,
                  "Serializer not defined for message type [{0}]. Transient association error (association remains live)",
                  send.Message.GetType());
                return true;
            }
            catch (EndpointException ex)
            {
                PublishAndThrow(ex, LogLevel.ErrorLevel);
            }
            catch (Exception ex)
            {
                PublishAndThrow(new EndpointException("Failed to write message to the transport", ex),
                    LogLevel.ErrorLevel);
            }

            return false;
        }

        private void SendBufferedMessages()
        {
            bool SendDelegate(object msg)
            {
                switch (msg)
                {
                    case EndpointManager.Send s:
                        return WriteSend(s);
                    case FlushAndStop f:
                        DoFlushAndStop();
                        return false;
                    case StopReading stop:
                        _reader?.Tell(stop, stop.ReplyTo);
                        return true;
                    default:
                        return true;
                }
            }

            bool WriteLoop(int count)
            {
                if (count > 0 && _buffer.Any())
                {
                    if (SendDelegate(_buffer.First.Value))
                    {
                        _buffer.RemoveFirst();
                        _writeCount += 1;
                        return WriteLoop(count - 1);
                    }
                    return false;
                }

                return true;
            }

            bool WritePrioLoop()
            {
                if (!_prioBuffer.Any()) return true;
                if (WriteSend(_prioBuffer.First.Value))
                {
                    _prioBuffer.RemoveFirst();
                    return WritePrioLoop();
                }
                return false;
            }

            var size = _buffer.Count;

            var ok = WritePrioLoop() && WriteLoop(SendBufferBatchSize);
            if (!_buffer.Any() && !_prioBuffer.Any())
            {
                // FIXME remove this when testing/tuning is completed
                if (_log.IsDebugEnabled)
                {
                    _log.Debug("Drained buffer with maxWriteCount: {0}, fullBackoffCount: {1}," +
                               "smallBackoffCount: {2}, noBackoffCount: {3}," +
                               "adaptiveBackoff: {4}", _maxWriteCount, _fullBackoffCount, _smallBackoffCount, _noBackoffCount, _adaptiveBackoffNanos / 1000);
                }
                _fullBackoffCount = 1;
                _smallBackoffCount = 0;
                _noBackoffCount = 0;
                _writeCount = 0;
                _maxWriteCount = MaxWriteCount;
                Become(Writing);
            }
            else if (ok)
            {
                _noBackoffCount += 1;
                Self.Tell(BackoffTimer.Instance);
            }
            else
            {
                if (size > Settings.LogBufferSizeExceeding)
                {
                    var now = MonotonicClock.GetNanos();
                    if (now - _largeBufferLogTimestamp >= LogBufferSizeInterval)
                    {
                        _log.Warning("[{0}] buffered messages in EndpointWriter for [{1}]. You should probably implement flow control to avoid flooding the remote connection.", size, RemoteAddress);
                        _largeBufferLogTimestamp = now;
                    }
                }
            }

            AdjustAdaptiveBackup();
            ScheduleBackoffTimer();
        }

        #endregion

        #region Static methods and Internal messages

        // These settings are not configurable because wrong configuration will break the auto-tuning
        private const int SendBufferBatchSize = 5;
        private const long MinAdaptiveBackoffNanos = 300000L; // 0.3 ms
        private const long MaxAdaptiveBackoffNanos = 2000000L; // 2 ms
        private const long LogBufferSizeInterval = 5000000000L; // 5 s, in nanoseconds
        private const int MaxWriteCount = 50;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="handleOrActive">TBD</param>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="refuseUid">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props EndpointWriterProps(AkkaProtocolHandle handleOrActive, Address localAddress,
                    Address remoteAddress, int? refuseUid, AkkaProtocolTransport transport, RemoteSettings settings,
                    AkkaPduCodec codec, ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers, IActorRef reliableDeliverySupervisor = null)
        {
            return Props.Create(
                () =>
                    new EndpointWriter(handleOrActive, localAddress, remoteAddress, refuseUid, transport, settings,
                        codec, receiveBuffers, reliableDeliverySupervisor));
        }

        /// <summary>
        /// This message signals that the current association maintained by the local <see cref="EndpointWriter"/> and
        /// <see cref="EndpointReader"/> is to be overridden by a new inbound association. This is needed to avoid parallel inbound
        /// associations from the same remote endpoint: when a parallel inbound association is detected, the old one is removed and the new
        /// one is used instead.
        /// </summary>
        public sealed class TakeOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// Create a new TakeOver command
            /// </summary>
            /// <param name="protocolHandle">The handle of the new association</param>
            /// <param name="replyTo">TBD</param>
            public TakeOver(AkkaProtocolHandle protocolHandle, IActorRef replyTo)
            {
                ProtocolHandle = protocolHandle;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class TookOver : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="protocolHandle">TBD</param>
            public TookOver(IActorRef writer, AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class BackoffTimer
        {
            private BackoffTimer() { }
            private static readonly BackoffTimer _instance = new BackoffTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static BackoffTimer Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class FlushAndStop
        {
            private FlushAndStop() { }
            private static readonly FlushAndStop _instance = new FlushAndStop();
            /// <summary>
            /// TBD
            /// </summary>
            public static FlushAndStop Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class AckIdleCheckTimer
        {
            private AckIdleCheckTimer() { }
            private static readonly AckIdleCheckTimer _instance = new AckIdleCheckTimer();
            /// <summary>
            /// TBD
            /// </summary>
            public static AckIdleCheckTimer Instance { get { return _instance; } }
        }

        private sealed class FlushAndStopTimeout
        {
            private FlushAndStopTimeout() { }
            private static readonly FlushAndStopTimeout _instance = new FlushAndStopTimeout();
            public static FlushAndStopTimeout Instance { get { return _instance; } }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Handle : INoSerializationVerificationNeeded
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="protocolHandle">TBD</param>
            public Handle(AkkaProtocolHandle protocolHandle)
            {
                ProtocolHandle = protocolHandle;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public AkkaProtocolHandle ProtocolHandle { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StopReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            /// <param name="replyTo">TBD</param>
            public StopReading(IActorRef writer, IActorRef replyTo)
            {
                Writer = writer;
                ReplyTo = replyTo;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef ReplyTo { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StoppedReading
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="writer">TBD</param>
            public StoppedReading(IActorRef writer)
            {
                Writer = writer;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public IActorRef Writer { get; private set; }
        }

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class OutboundAck
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="ack">TBD</param>
            public OutboundAck(Ack ack)
            {
                Ack = ack;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public Ack Ack { get; private set; }
        }

        private const string AckIdleTimerName = "AckIdleTimer";

        #endregion

    }

    /// <summary>
    /// INTERNAL API
    /// </summary>
    internal class EndpointReader : EndpointActor
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="msgDispatch">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        public EndpointReader(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher msgDispatch,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null) :
                    base(localAddress, remoteAddress, transport, settings)
        {
            _receiveBuffers = receiveBuffers;
            _msgDispatch = msgDispatch;
            Inbound = inbound;
            _uid = uid;
            _reliableDeliverySupervisor = reliableDeliverySupervisor;
            _codec = codec;
            _provider = RARP.For(Context.System).Provider;
            Reading();
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        private readonly AkkaPduCodec _codec;
        private readonly IActorRef _reliableDeliverySupervisor;
        private readonly ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> _receiveBuffers;
        private readonly int _uid;
        private readonly IInboundMessageDispatcher _msgDispatch;

        private readonly IRemoteActorRefProvider _provider;
        private AckedReceiveBuffer<Message> _ackedReceiveBuffer = new AckedReceiveBuffer<Message>();

        #region ActorBase overrides

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_receiveBuffers.TryGetValue(new EndpointManager.Link(LocalAddress, RemoteAddress), out var resendState))
            {
                if(resendState.Uid == _uid)
                {
                    _ackedReceiveBuffer = resendState.Buffer;
                    DeliverAndAck();
                }
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop()
        {
            SaveState();
        }

        private void Reading()
        {
           
            Receive<InboundPayload>(inbound =>
            {
                var payload = inbound.Payload;
                if (payload.Length > Transport.MaximumPayloadBytes)
                {
                    var reason = new OversizedPayloadException(
                        string.Format("Discarding oversized payload received: max allowed size {0} bytes, actual size {1} bytes.",
                            Transport.MaximumPayloadBytes,
                            payload.Length));
                    _log.Error(reason, "Transient error while reading from association (association remains live)");
                }
                else
                {
                    var ackAndMessage = TryDecodeMessageAndAck(payload);
                    if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                        _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
                    if (ackAndMessage.MessageOption != null)
                    {
                        if (ackAndMessage.MessageOption.ReliableDeliveryEnabled)
                        {
                            _ackedReceiveBuffer = _ackedReceiveBuffer.Receive(ackAndMessage.MessageOption);
                            DeliverAndAck();
                        }
                        else
                        {
                            try
                            {
                                _msgDispatch.Dispatch(ackAndMessage.MessageOption.Recipient,
                                    ackAndMessage.MessageOption.RecipientAddress,
                                    ackAndMessage.MessageOption.SerializedMessage,
                                    ackAndMessage.MessageOption.SenderOptional);
                            }
                            catch (SerializationException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (ArgumentException e)
                            {
                                LogTransientSerializationError(ackAndMessage.MessageOption, e);
                            }
                            catch (Exception e)
                            {
                                throw;
                            }
                        }
                    }
                }
            });
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop =>
            {
                SaveState();
                Become(NotReading);
                stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer));
            });
        }

        private void LogTransientSerializationError(Message msg, Exception error)
        {
            var sm = msg.SerializedMessage;
            _log.Warning(
              "Serializer not defined for message with serializer id [{0}] and manifest [{1}]. " +
                "Transient association error (association remains live). {2}",
              sm.SerializerId,
              sm.MessageManifest.IsEmpty ? "" : sm.MessageManifest.ToStringUtf8(),
              error.Message);
        }

        private void NotReading()
        {
            Receive<Disassociated>(disassociated => HandleDisassociated(disassociated.Info));
            Receive<EndpointWriter.StopReading>(stop => stop.ReplyTo.Tell(new EndpointWriter.StoppedReading(stop.Writer)));
            Receive<InboundPayload>(payload =>
            {
                var ackAndMessage = TryDecodeMessageAndAck(payload.Payload);
                if (ackAndMessage.AckOption != null && _reliableDeliverySupervisor != null)
                    _reliableDeliverySupervisor.Tell(ackAndMessage.AckOption);
            });
            ReceiveAny(o => { }); // ignore
        }

        #endregion



        #region Lifecycle event handlers

        private void SaveState()
        {
            EndpointManager.ResendState Merge(EndpointManager.ResendState current,
                EndpointManager.ResendState oldState)
            {
                if (current.Uid == oldState.Uid) return new EndpointManager.ResendState(_uid, oldState.Buffer.MergeFrom(current.Buffer));
                return current;
            }

            void UpdateSavedState(EndpointManager.Link key, EndpointManager.ResendState expectedState)
            {
                if (expectedState == null)
                {
                    if (!_receiveBuffers.TryAdd(key, new EndpointManager.ResendState(_uid, _ackedReceiveBuffer)))
                    {
                        _receiveBuffers.TryGetValue(key, out var prevValue);
                        UpdateSavedState(key, prevValue);
                    }
                }
                else if (!_receiveBuffers.TryUpdate(key,
                    Merge(new EndpointManager.ResendState(_uid, _ackedReceiveBuffer), expectedState), expectedState))
                {
                    _receiveBuffers.TryGetValue(key, out var prevValue);
                    UpdateSavedState(key, prevValue);
                }
            }

            var k = new EndpointManager.Link(LocalAddress, RemoteAddress);
            UpdateSavedState(k, !_receiveBuffers.TryGetValue(k, out var previousValue) ? null : previousValue);
        }

        private void HandleDisassociated(DisassociateInfo info)
        {
            switch (info)
            {
                case DisassociateInfo.Quarantined:
                    throw new InvalidAssociation("The remote system has quarantined this system. No further associations " +
                                                   "to the remote system are possible until this system is restarted.", LocalAddress, RemoteAddress, disassociateInfo: DisassociateInfo.Quarantined);
                case DisassociateInfo.Shutdown:
                    throw new ShutDownAssociation($"The remote system terminated the association because it is shutting down. Shut down address: {RemoteAddress}", LocalAddress, RemoteAddress);
                case DisassociateInfo.Unknown:
                default:
                    Context.Stop(Self);
                    break;
            }
        }

        private void DeliverAndAck()
        {
            var deliverable = _ackedReceiveBuffer.ExtractDeliverable();
            _ackedReceiveBuffer = deliverable.Buffer;

            // Notify writer that some messages can be acked
            Context.Parent.Tell(new EndpointWriter.OutboundAck(deliverable.Ack));
            deliverable.Deliverables.ForEach(msg => _msgDispatch.Dispatch(msg.Recipient, msg.RecipientAddress, msg.SerializedMessage, msg.SenderOptional));
        }

        private AckAndMessage TryDecodeMessageAndAck(ByteString pdu)
        {
            try
            {
                return _codec.DecodeMessage(pdu, _provider, LocalAddress);
            }
            catch (Exception ex)
            {
                throw new EndpointException("Error while decoding incoming Akka PDU", ex);
            }
        }

        #endregion

        #region Static members

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="localAddress">TBD</param>
        /// <param name="remoteAddress">TBD</param>
        /// <param name="transport">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="codec">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <param name="inbound">TBD</param>
        /// <param name="uid">TBD</param>
        /// <param name="receiveBuffers">TBD</param>
        /// <param name="reliableDeliverySupervisor">TBD</param>
        /// <returns>TBD</returns>
        public static Props ReaderProps(
                    Address localAddress,
                    Address remoteAddress,
                    AkkaProtocolTransport transport,
                    RemoteSettings settings,
                    AkkaPduCodec codec,
                    IInboundMessageDispatcher dispatcher,
                    bool inbound,
                    int uid,
                    ConcurrentDictionary<EndpointManager.Link, EndpointManager.ResendState> receiveBuffers,
                    IActorRef reliableDeliverySupervisor = null)
        {
            return
                Props.Create(
                    () =>
                        new EndpointReader(localAddress, remoteAddress, transport, settings, codec, dispatcher, inbound,
                            uid, receiveBuffers, reliableDeliverySupervisor))
                            .WithDispatcher(settings.Dispatcher);
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1936,46): warning CS0168: The variable 'e' is declared but never used,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1256,17): warning CS0618: 'AssociationHandle.Disassociate()' is obsolete: 'Use the method that states reasons to make sure disassociation reasons are logged.',D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(23,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1935,46): warning CS0168: The variable 'e' is declared but never used,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1256,17): warning CS0618: 'AssociationHandle.Disassociate()' is obsolete: 'Use the method that states reasons to make sure disassociation reasons are logged.',D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(1404,54): error CS0136: A local or parameter named 'send' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\core\Akka.Remote\Endpoint.cs(23,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\src\core\Akka.Remote\Routing\RemoteRouterConfig.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Akka.Actor;
using Akka.Routing;
using Akka.Util;
using Akka.Util.Internal;
using Akka.Configuration;

namespace Akka.Remote.Routing
{
    /// <summary>
    /// <see cref="RouterConfig"/> implementation for remote deployment of 
    /// routees on defined target nodes. Delegates other duties to the local <see cref="Pool"/>,
    /// which makes it possible to mix this with built-in routers such as <see cref="RoundRobinGroup"/> or custom routers.
    /// </summary>
    public sealed class RemoteRouterConfig : Pool, IEquatable<RouterConfig>
    {
        private readonly IEnumerator<Address> _nodeAddrEnumerator;
        private readonly AtomicCounter _childNameCounter = new AtomicCounter();

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoteRouterConfig"/> class.
        /// </summary>
        /// <param name="local">TBD</param>
        /// <param name="nodes">TBD</param>
        /// <exception cref="ArgumentException">
        /// This exception is thrown when the enumeration of specified nodes is empty.
        /// </exception>
        public RemoteRouterConfig(Pool local, IEnumerable<Address> nodes) 
            : base(local.NrOfInstances,local.Resizer,local.SupervisorStrategy,local.RouterDispatcher,local.UsePoolDispatcher)
        {
            if (!nodes.Any()) throw new ArgumentException("Must specify list of remote target nodes.", nameof(nodes));

            Local = local;
            Nodes = nodes.ToList();
            _nodeAddrEnumerator = Nodes.GetContinuousEnumerator();
        }

        /// <summary>
        /// TBD
        /// </summary>
        internal Pool Local { get; }

        /// <summary>
        /// TBD
        /// </summary>
        internal IList<Address> Nodes { get; }

        /// <summary>
        /// Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
        /// </summary>
        /// <param name="system">The ActorSystem this router belongs to.</param>
        /// <returns>The newly created router tied to the given system.</returns>
        public override Router CreateRouter(ActorSystem system)
        {
            return Local.CreateRouter(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override int GetNrOfInstances(ActorSystem system)
        {
            return Local.GetNrOfInstances(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="routeeProps">TBD</param>
        /// <param name="context">TBD</param>
        /// <returns>TBD</returns>
        internal override Routee NewRoutee(Props routeeProps, IActorContext context)
        {
            var name = "c" + _childNameCounter.IncrementAndGet();
            _nodeAddrEnumerator.MoveNext();

            var deploy = new Deploy(routeeProps.RouterConfig, new RemoteScope(_nodeAddrEnumerator.Current));

            // attachChild means that the provider will treat this call as if possibly done out of the wrong
            // context and use RepointableActorRef instead of LocalActorRef. Seems like a slightly sub-optimal
            // choice in a corner case (and hence not worth fixing).
            var actorRef = context.AsInstanceOf<ActorCell>()
                .AttachChild(Local.EnrichWithPoolDispatcher(routeeProps, context).WithDeploy(deploy), false, name);
            return new ActorRefRoutee(actorRef);
        }

        // TODO: why internal?
        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        internal override RouterActor CreateRouterActor()
        {
            return Local.CreateRouterActor();
        }

        /// <summary>
        /// Retrieve the strategy to use when supervising the pool.
        /// </summary>
        public override SupervisorStrategy SupervisorStrategy
        {
            get { return Local.SupervisorStrategy; }
        }

        /// <summary>
        /// Dispatcher ID to use for running the "head" actor, which handles supervision, death watch and router management messages.
        /// </summary>
        public override string RouterDispatcher
        {
            get { return Local.RouterDispatcher; }
        }

        /// <summary>
        /// Retrieve the resizer to use when dynamically allocating routees to the pool.
        /// </summary>
        public override Resizer Resizer
        {
            get { return Local.Resizer; }
        }

        /// <summary>
        /// Configures the current router with an auxiliary router for routes that it does not know how to handle.
        /// </summary>
        /// <param name="routerConfig">The router to use as an auxiliary source.</param>
        /// <exception cref="ConfigurationException">
        /// This exception is thrown when the specified router is another <see cref="RemoteRouterConfig"/>.
        /// This configuration is not allowed.
        /// </exception>
        /// <returns>The router configured with the auxiliary information.</returns>
        public override RouterConfig WithFallback(RouterConfig routerConfig)
        {
            var other = routerConfig as RemoteRouterConfig;
            if (other != null && other.Local is RemoteRouterConfig)
                throw new ConfigurationException("RemoteRouterConfig is not allowed to wrap a RemoteRouterConfig");
            if (other != null && other.Local != null)
                return Copy(Local.WithFallback(other.Local).AsInstanceOf<Pool>());
            return Copy(Local.WithFallback(routerConfig).AsInstanceOf<Pool>());
        }

        private RouterConfig Copy(Pool local = null, IEnumerable<Address> nodes = null)
        {
            return new RemoteRouterConfig(local ?? Local, nodes ?? Nodes);
        }

        /// <summary>
        /// Determines whether the specified router, is equal to this instance.
        /// </summary>
        /// <param name="other">The group to compare.</param>
        /// <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        public new bool Equals(RouterConfig other)
        {
            if (!base.Equals(other)) return false;
            var otherRemote = other as RemoteRouterConfig;
            if (otherRemote == null) return false; //should never be true due to the previous check
            return Local.Equals(otherRemote.Local) &&
                   Nodes.Intersect(otherRemote.Nodes).Count() == Nodes.Count;
        }

        /// <summary>
        /// Creates a surrogate representation of the current router.
        /// </summary>
        /// <param name="system">The actor system that owns this router.</param>
        /// <returns>The surrogate representation of the current router.</returns>
        public override ISurrogate ToSurrogate(ActorSystem system)
        {
            return new RemoteRouterConfigSurrogate
            {
                Local = Local,
                Nodes = Nodes.ToArray(),
            };
        }

        /// <summary>
        /// This class represents a surrogate of a <see cref="RemoteRouterConfig"/> router.
        /// Its main use is to help during the serialization process.
        /// </summary>
        public class RemoteRouterConfigSurrogate : ISurrogate
        {
            /// <summary>
            /// TBD
            /// </summary>
            public Pool Local { get; set; }
            /// <summary>
            /// TBD
            /// </summary>
            public Address[] Nodes { get; set; }

            /// <summary>
            /// Creates a <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.
            /// </summary>
            /// <param name="system">The actor system that owns this router.</param>
            /// <returns>The <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.</returns>
            public ISurrogated FromSurrogate(ActorSystem system)
            {
                return new RemoteRouterConfig(Local, Nodes);
            }
        }
    }
}


---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Akka.Actor;
using Akka.Routing;
using Akka.Util;
using Akka.Util.Internal;
using Akka.Configuration;

namespace Akka.Remote.Routing
{
    /// <summary>
    /// <see cref="RouterConfig"/> implementation for remote deployment of 
    /// routees on defined target nodes. Delegates other duties to the local <see cref="Pool"/>,
    /// which makes it possible to mix this with built-in routers such as <see cref="RoundRobinGroup"/> or custom routers.
    /// </summary>
    public sealed class RemoteRouterConfig : Pool, IEquatable<RouterConfig>
    {
        private readonly IEnumerator<Address> _nodeAddrEnumerator;
        private readonly AtomicCounter _childNameCounter = new AtomicCounter();

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoteRouterConfig"/> class.
        /// </summary>
        /// <param name="local">TBD</param>
        /// <param name="nodes">TBD</param>
        /// <exception cref="ArgumentException">
        /// This exception is thrown when the enumeration of specified nodes is empty.
        /// </exception>
        public RemoteRouterConfig(Pool local, IEnumerable<Address> nodes) 
            : base(local.NrOfInstances,local.Resizer,local.SupervisorStrategy,local.RouterDispatcher,local.UsePoolDispatcher)
        {
            if (!nodes.Any()) throw new ArgumentException("Must specify list of remote target nodes.", nameof(nodes));

            Local = local;
            Nodes = nodes.ToList();
            _nodeAddrEnumerator = Nodes.GetContinuousEnumerator();
        }

        /// <summary>
        /// TBD
        /// </summary>
        internal Pool Local { get; }

        /// <summary>
        /// TBD
        /// </summary>
        internal IList<Address> Nodes { get; }

        /// <summary>
        /// Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
        /// </summary>
        /// <param name="system">The ActorSystem this router belongs to.</param>
        /// <returns>The newly created router tied to the given system.</returns>
        public override Router CreateRouter(ActorSystem system)
        {
            return Local.CreateRouter(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override int GetNrOfInstances(ActorSystem system)
        {
            return Local.GetNrOfInstances(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="routeeProps">TBD</param>
        /// <param name="context">TBD</param>
        /// <returns>TBD</returns>
        internal override Routee NewRoutee(Props routeeProps, IActorContext context)
        {
            var name = "c" + _childNameCounter.IncrementAndGet();
            _nodeAddrEnumerator.MoveNext();

            var deploy = new Deploy(routeeProps.RouterConfig, new RemoteScope(_nodeAddrEnumerator.Current));

            // attachChild means that the provider will treat this call as if possibly done out of the wrong
            // context and use RepointableActorRef instead of LocalActorRef. Seems like a slightly sub-optimal
            // choice in a corner case (and hence not worth fixing).
            var actorRef = context.AsInstanceOf<ActorCell>()
                .AttachChild(Local.EnrichWithPoolDispatcher(routeeProps, context).WithDeploy(deploy), false, name);
            return new ActorRefRoutee(actorRef);
        }

        // TODO: why internal?
        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        internal override RouterActor CreateRouterActor()
        {
            return Local.CreateRouterActor();
        }

        /// <summary>
        /// Retrieve the strategy to use when supervising the pool.
        /// </summary>
        public override SupervisorStrategy SupervisorStrategy
        {
            get { return Local.SupervisorStrategy; }
        }

        /// <summary>
        /// Dispatcher ID to use for running the "head" actor, which handles supervision, death watch and router management messages.
        /// </summary>
        public override string RouterDispatcher
        {
            get { return Local.RouterDispatcher; }
        }

        /// <summary>
        /// Retrieve the resizer to use when dynamically allocating routees to the pool.
        /// </summary>
        public override Resizer Resizer
        {
            get { return Local.Resizer; }
        }

        /// <summary>
        /// Configures the current router with an auxiliary router for routes that it does not know how to handle.
        /// </summary>
        /// <param name="routerConfig">The router to use as an auxiliary source.</param>
        /// <exception cref="ConfigurationException">
        /// This exception is thrown when the specified router is another <see cref="RemoteRouterConfig"/>.
        /// This configuration is not allowed.
        /// </exception>
        /// <returns>The router configured with the auxiliary information.</returns>
        public override RouterConfig WithFallback(RouterConfig routerConfig)
        {
            var other = routerConfig as RemoteRouterConfig;
            if (other?.Local is RemoteRouterConfig)
                throw new ConfigurationException("RemoteRouterConfig is not allowed to wrap a RemoteRouterConfig");
            if (other?.Local != null)
                return Copy(Local.WithFallback(other.Local).AsInstanceOf<Pool>());
            return Copy(Local.WithFallback(routerConfig).AsInstanceOf<Pool>());
        }

        private RouterConfig Copy(Pool local = null, IEnumerable<Address> nodes = null)
        {
            return new RemoteRouterConfig(local ?? Local, nodes ?? Nodes);
        }

        /// <summary>
        /// Determines whether the specified router, is equal to this instance.
        /// </summary>
        /// <param name="other">The group to compare.</param>
        /// <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        public new bool Equals(RouterConfig other)
        {
            if (!base.Equals(other)) return false;
            var otherRemote = other as RemoteRouterConfig;
            if (otherRemote == null) return false; //should never be true due to the previous check
            return Local.Equals(otherRemote.Local) &&
                   Nodes.Intersect(otherRemote.Nodes).Count() == Nodes.Count;
        }

        /// <summary>
        /// Creates a surrogate representation of the current router.
        /// </summary>
        /// <param name="system">The actor system that owns this router.</param>
        /// <returns>The surrogate representation of the current router.</returns>
        public override ISurrogate ToSurrogate(ActorSystem system)
        {
            return new RemoteRouterConfigSurrogate
            {
                Local = Local,
                Nodes = Nodes.ToArray(),
            };
        }

        /// <summary>
        /// This class represents a surrogate of a <see cref="RemoteRouterConfig"/> router.
        /// Its main use is to help during the serialization process.
        /// </summary>
        public class RemoteRouterConfigSurrogate : ISurrogate
        {
            /// <summary>
            /// TBD
            /// </summary>
            public Pool Local { get; set; }
            /// <summary>
            /// TBD
            /// </summary>
            public Address[] Nodes { get; set; }

            /// <summary>
            /// Creates a <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.
            /// </summary>
            /// <param name="system">The actor system that owns this router.</param>
            /// <returns>The <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.</returns>
            public ISurrogated FromSurrogate(ActorSystem system)
            {
                return new RemoteRouterConfig(Local, Nodes);
            }
        }
    }
}


---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Remote\Routing\RemoteRouterConfig.cs(144,33): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\core\Akka.Remote\Routing\RemoteRouterConfig.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Akka.Actor;
using Akka.Routing;
using Akka.Util;
using Akka.Util.Internal;
using Akka.Configuration;

namespace Akka.Remote.Routing
{
    /// <summary>
    /// <see cref="RouterConfig"/> implementation for remote deployment of 
    /// routees on defined target nodes. Delegates other duties to the local <see cref="Pool"/>,
    /// which makes it possible to mix this with built-in routers such as <see cref="RoundRobinGroup"/> or custom routers.
    /// </summary>
    public sealed class RemoteRouterConfig : Pool, IEquatable<RouterConfig>
    {
        private readonly IEnumerator<Address> _nodeAddrEnumerator;
        private readonly AtomicCounter _childNameCounter = new AtomicCounter();

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoteRouterConfig"/> class.
        /// </summary>
        /// <param name="local">TBD</param>
        /// <param name="nodes">TBD</param>
        /// <exception cref="ArgumentException">
        /// This exception is thrown when the enumeration of specified nodes is empty.
        /// </exception>
        public RemoteRouterConfig(Pool local, IEnumerable<Address> nodes) 
            : base(local.NrOfInstances,local.Resizer,local.SupervisorStrategy,local.RouterDispatcher,local.UsePoolDispatcher)
        {
            if (!nodes.Any()) throw new ArgumentException("Must specify list of remote target nodes.", nameof(nodes));

            Local = local;
            Nodes = nodes.ToList();
            _nodeAddrEnumerator = Nodes.GetContinuousEnumerator();
        }

        /// <summary>
        /// TBD
        /// </summary>
        internal Pool Local { get; }

        /// <summary>
        /// TBD
        /// </summary>
        internal IList<Address> Nodes { get; }

        /// <summary>
        /// Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
        /// </summary>
        /// <param name="system">The ActorSystem this router belongs to.</param>
        /// <returns>The newly created router tied to the given system.</returns>
        public override Router CreateRouter(ActorSystem system)
        {
            return Local.CreateRouter(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override int GetNrOfInstances(ActorSystem system)
        {
            return Local.GetNrOfInstances(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="routeeProps">TBD</param>
        /// <param name="context">TBD</param>
        /// <returns>TBD</returns>
        internal override Routee NewRoutee(Props routeeProps, IActorContext context)
        {
            var name = "c" + _childNameCounter.IncrementAndGet();
            _nodeAddrEnumerator.MoveNext();

            var deploy = new Deploy(routeeProps.RouterConfig, new RemoteScope(_nodeAddrEnumerator.Current));

            // attachChild means that the provider will treat this call as if possibly done out of the wrong
            // context and use RepointableActorRef instead of LocalActorRef. Seems like a slightly sub-optimal
            // choice in a corner case (and hence not worth fixing).
            var actorRef = context.AsInstanceOf<ActorCell>()
                .AttachChild(Local.EnrichWithPoolDispatcher(routeeProps, context).WithDeploy(deploy), false, name);
            return new ActorRefRoutee(actorRef);
        }

        // TODO: why internal?
        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        internal override RouterActor CreateRouterActor()
        {
            return Local.CreateRouterActor();
        }

        /// <summary>
        /// Retrieve the strategy to use when supervising the pool.
        /// </summary>
        public override SupervisorStrategy SupervisorStrategy
        {
            get { return Local.SupervisorStrategy; }
        }

        /// <summary>
        /// Dispatcher ID to use for running the "head" actor, which handles supervision, death watch and router management messages.
        /// </summary>
        public override string RouterDispatcher
        {
            get { return Local.RouterDispatcher; }
        }

        /// <summary>
        /// Retrieve the resizer to use when dynamically allocating routees to the pool.
        /// </summary>
        public override Resizer Resizer
        {
            get { return Local.Resizer; }
        }

        /// <summary>
        /// Configures the current router with an auxiliary router for routes that it does not know how to handle.
        /// </summary>
        /// <param name="routerConfig">The router to use as an auxiliary source.</param>
        /// <exception cref="ConfigurationException">
        /// This exception is thrown when the specified router is another <see cref="RemoteRouterConfig"/>.
        /// This configuration is not allowed.
        /// </exception>
        /// <returns>The router configured with the auxiliary information.</returns>
        public override RouterConfig WithFallback(RouterConfig routerConfig)
        {
            var other = routerConfig as RemoteRouterConfig;
            if (other != null && other.Local is RemoteRouterConfig)
                throw new ConfigurationException("RemoteRouterConfig is not allowed to wrap a RemoteRouterConfig");
            if (other != null && other.Local != null)
                return Copy(Local.WithFallback(other.Local).AsInstanceOf<Pool>());
            return Copy(Local.WithFallback(routerConfig).AsInstanceOf<Pool>());
        }

        private RouterConfig Copy(Pool local = null, IEnumerable<Address> nodes = null)
        {
            return new RemoteRouterConfig(local ?? Local, nodes ?? Nodes);
        }

        /// <summary>
        /// Determines whether the specified router, is equal to this instance.
        /// </summary>
        /// <param name="other">The group to compare.</param>
        /// <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        public new bool Equals(RouterConfig other)
        {
            if (!base.Equals(other)) return false;
            var otherRemote = other as RemoteRouterConfig;
            if (otherRemote == null) return false; //should never be true due to the previous check
            return Local.Equals(otherRemote.Local) &&
                   Nodes.Intersect(otherRemote.Nodes).Count() == Nodes.Count;
        }

        /// <summary>
        /// Creates a surrogate representation of the current router.
        /// </summary>
        /// <param name="system">The actor system that owns this router.</param>
        /// <returns>The surrogate representation of the current router.</returns>
        public override ISurrogate ToSurrogate(ActorSystem system)
        {
            return new RemoteRouterConfigSurrogate
            {
                Local = Local,
                Nodes = Nodes.ToArray(),
            };
        }

        /// <summary>
        /// This class represents a surrogate of a <see cref="RemoteRouterConfig"/> router.
        /// Its main use is to help during the serialization process.
        /// </summary>
        public class RemoteRouterConfigSurrogate : ISurrogate
        {
            /// <summary>
            /// TBD
            /// </summary>
            public Pool Local { get; set; }
            /// <summary>
            /// TBD
            /// </summary>
            public Address[] Nodes { get; set; }

            /// <summary>
            /// Creates a <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.
            /// </summary>
            /// <param name="system">The actor system that owns this router.</param>
            /// <returns>The <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.</returns>
            public ISurrogated FromSurrogate(ActorSystem system)
            {
                return new RemoteRouterConfig(Local, Nodes);
            }
        }
    }
}


---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Akka.Actor;
using Akka.Routing;
using Akka.Util;
using Akka.Util.Internal;
using Akka.Configuration;

namespace Akka.Remote.Routing
{
    /// <summary>
    /// <see cref="RouterConfig"/> implementation for remote deployment of 
    /// routees on defined target nodes. Delegates other duties to the local <see cref="Pool"/>,
    /// which makes it possible to mix this with built-in routers such as <see cref="RoundRobinGroup"/> or custom routers.
    /// </summary>
    public sealed class RemoteRouterConfig : Pool, IEquatable<RouterConfig>
    {
        private readonly IEnumerator<Address> _nodeAddrEnumerator;
        private readonly AtomicCounter _childNameCounter = new AtomicCounter();

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoteRouterConfig"/> class.
        /// </summary>
        /// <param name="local">TBD</param>
        /// <param name="nodes">TBD</param>
        /// <exception cref="ArgumentException">
        /// This exception is thrown when the enumeration of specified nodes is empty.
        /// </exception>
        public RemoteRouterConfig(Pool local, IEnumerable<Address> nodes) 
            : base(local.NrOfInstances,local.Resizer,local.SupervisorStrategy,local.RouterDispatcher,local.UsePoolDispatcher)
        {
            if (!nodes.Any()) throw new ArgumentException("Must specify list of remote target nodes.", nameof(nodes));

            Local = local;
            Nodes = nodes.ToList();
            _nodeAddrEnumerator = Nodes.GetContinuousEnumerator();
        }

        /// <summary>
        /// TBD
        /// </summary>
        internal Pool Local { get; }

        /// <summary>
        /// TBD
        /// </summary>
        internal IList<Address> Nodes { get; }

        /// <summary>
        /// Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
        /// </summary>
        /// <param name="system">The ActorSystem this router belongs to.</param>
        /// <returns>The newly created router tied to the given system.</returns>
        public override Router CreateRouter(ActorSystem system)
        {
            return Local.CreateRouter(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override int GetNrOfInstances(ActorSystem system)
        {
            return Local.GetNrOfInstances(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="routeeProps">TBD</param>
        /// <param name="context">TBD</param>
        /// <returns>TBD</returns>
        internal override Routee NewRoutee(Props routeeProps, IActorContext context)
        {
            var name = "c" + _childNameCounter.IncrementAndGet();
            _nodeAddrEnumerator.MoveNext();

            var deploy = new Deploy(routeeProps.RouterConfig, new RemoteScope(_nodeAddrEnumerator.Current));

            // attachChild means that the provider will treat this call as if possibly done out of the wrong
            // context and use RepointableActorRef instead of LocalActorRef. Seems like a slightly sub-optimal
            // choice in a corner case (and hence not worth fixing).
            var actorRef = context.AsInstanceOf<ActorCell>()
                .AttachChild(Local.EnrichWithPoolDispatcher(routeeProps, context).WithDeploy(deploy), false, name);
            return new ActorRefRoutee(actorRef);
        }

        // TODO: why internal?
        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        internal override RouterActor CreateRouterActor()
        {
            return Local.CreateRouterActor();
        }

        /// <summary>
        /// Retrieve the strategy to use when supervising the pool.
        /// </summary>
        public override SupervisorStrategy SupervisorStrategy
        {
            get { return Local.SupervisorStrategy; }
        }

        /// <summary>
        /// Dispatcher ID to use for running the "head" actor, which handles supervision, death watch and router management messages.
        /// </summary>
        public override string RouterDispatcher
        {
            get { return Local.RouterDispatcher; }
        }

        /// <summary>
        /// Retrieve the resizer to use when dynamically allocating routees to the pool.
        /// </summary>
        public override Resizer Resizer
        {
            get { return Local.Resizer; }
        }

        /// <summary>
        /// Configures the current router with an auxiliary router for routes that it does not know how to handle.
        /// </summary>
        /// <param name="routerConfig">The router to use as an auxiliary source.</param>
        /// <exception cref="ConfigurationException">
        /// This exception is thrown when the specified router is another <see cref="RemoteRouterConfig"/>.
        /// This configuration is not allowed.
        /// </exception>
        /// <returns>The router configured with the auxiliary information.</returns>
        public override RouterConfig WithFallback(RouterConfig routerConfig)
        {
            if (routerConfig is RemoteRouterConfig other && other.Local is RemoteRouterConfig)
                throw new ConfigurationException("RemoteRouterConfig is not allowed to wrap a RemoteRouterConfig");

            if (routerConfig is RemoteRouterConfig other && other.Local != null)
                return Copy(Local.WithFallback(other.Local).AsInstanceOf<Pool>());
            return Copy(Local.WithFallback(routerConfig).AsInstanceOf<Pool>());
        }

        private RouterConfig Copy(Pool local = null, IEnumerable<Address> nodes = null)
        {
            return new RemoteRouterConfig(local ?? Local, nodes ?? Nodes);
        }

        /// <summary>
        /// Determines whether the specified router, is equal to this instance.
        /// </summary>
        /// <param name="other">The group to compare.</param>
        /// <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        public new bool Equals(RouterConfig other)
        {
            if (!base.Equals(other)) return false;
            var otherRemote = other as RemoteRouterConfig;
            if (otherRemote == null) return false; //should never be true due to the previous check
            return Local.Equals(otherRemote.Local) &&
                   Nodes.Intersect(otherRemote.Nodes).Count() == Nodes.Count;
        }

        /// <summary>
        /// Creates a surrogate representation of the current router.
        /// </summary>
        /// <param name="system">The actor system that owns this router.</param>
        /// <returns>The surrogate representation of the current router.</returns>
        public override ISurrogate ToSurrogate(ActorSystem system)
        {
            return new RemoteRouterConfigSurrogate
            {
                Local = Local,
                Nodes = Nodes.ToArray(),
            };
        }

        /// <summary>
        /// This class represents a surrogate of a <see cref="RemoteRouterConfig"/> router.
        /// Its main use is to help during the serialization process.
        /// </summary>
        public class RemoteRouterConfigSurrogate : ISurrogate
        {
            /// <summary>
            /// TBD
            /// </summary>
            public Pool Local { get; set; }
            /// <summary>
            /// TBD
            /// </summary>
            public Address[] Nodes { get; set; }

            /// <summary>
            /// Creates a <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.
            /// </summary>
            /// <param name="system">The actor system that owns this router.</param>
            /// <returns>The <see cref="RemoteRouterConfig"/> encapsulated by this surrogate.</returns>
            public ISurrogated FromSurrogate(ActorSystem system)
            {
                return new RemoteRouterConfig(Local, Nodes);
            }
        }
    }
}


---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Remote\Routing\RemoteRouterConfig.cs(146,52): error CS0128: A local variable or function named 'other' is already defined in this scope,D:\a\1\s\src\core\Akka.Remote\Routing\RemoteRouterConfig.cs(146,61): error CS0165: Use of unassigned local variable 'other'
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Actor.Internal;
using Akka.Annotations;
using Akka.Event;
using Akka.Pattern;
using Akka.Remote.Transport;
using Akka.Util;
using Akka.Util.Internal;
using DotNetty.Transport.Channels;
using Akka.Configuration;

namespace Akka.Remote.TestKit
{
    /// <summary>
    /// The Player is the client component of the
    /// test conductor extension. It registers with
    /// the conductor's controller
    ///  in order to participate in barriers and enable network failure injection
    /// </summary>
    partial class TestConductor //Player trait in JVM version
    {
        IActorRef _client;

        public IActorRef Client
        {
            get
            {
                if(_client == null) throw new IllegalStateException("TestConductor client not yet started");
                if(_system.WhenTerminated.IsCompleted) throw new IllegalStateException("TestConductor unavailable because system is terminated; you need to StartNewSystem() before this point");
                return _client;
            }
        }

        /// <summary>
        /// Connect to the conductor on the given port (the host is taken from setting
        /// `akka.testconductor.host`). The connection is made asynchronously, but you
        /// should await completion of the returned Future because that implies that
        /// all expected participants of this test have successfully connected (i.e.
        /// this is a first barrier in itself). The number of expected participants is
        /// set in <see cref="TestConductor"/>`.startController()`.
        /// </summary>
        public Task<Done> StartClient(RoleName name, IPEndPoint controllerAddr)
        {
            if(_client != null) throw new IllegalStateException("TestConductorClient already started");
                _client =
                _system.ActorOf(Props.Create(() => new ClientFSM(name, controllerAddr)), "TestConductorClient");

            //TODO: IRequiresMessageQueue
            var a = _system.ActorOf(Props.Create<WaitForClientFSMToConnect>());

            return a.Ask<Done>(_client);
        }

        private class WaitForClientFSMToConnect : UntypedActor
        {
            IActorRef _waiting;

            protected override void OnReceive(object message)
            {
                var fsm = message as IActorRef;
                if (fsm != null)
                {
                    _waiting = Sender;
                    fsm.Tell(new FSMBase.SubscribeTransitionCallBack(Self));
                    return;
                }
                var transition = message as FSMBase.Transition<ClientFSM.State>;
                if (transition != null)
                {
                    if (transition.From == ClientFSM.State.Connecting && transition.To == ClientFSM.State.AwaitDone)
                        return;
                    if (transition.From == ClientFSM.State.AwaitDone && transition.To == ClientFSM.State.Connected)
                    {
                        _waiting.Tell(Done.Instance);
                        Context.Stop(Self);
                        return;
                    }
                    _waiting.Tell(new Exception("unexpected transition: " + transition));
                    Context.Stop(Self);
                }
                var currentState = message as FSMBase.CurrentState<ClientFSM.State>;
                if (currentState != null)
                {
                    if (currentState.State == ClientFSM.State.Connected)
                    {
                        _waiting.Tell(Done.Instance);
                        Context.Stop(Self);
                        return;

                    }
                }
            }
        }

        /// <summary>
        /// Enter the named barriers, one after the other, in the order given. Will
        /// throw an exception in case of timeouts or other errors.
        /// </summary>
        public void Enter(string name)
        {
            Enter(Settings.BarrierTimeout, ImmutableList.Create(name));
        }

        /// <summary>
        /// Enter the named barriers, one after the other, in the order given. Will
        /// throw an exception in case of timeouts or other errors.
        /// </summary>
        public void Enter(TimeSpan timeout, ImmutableList<string> names)
        {
            _system.Log.Debug("entering barriers {0}", names.Aggregate((a, b) => "(" + a + "," + b + ")"));
            var stop = Deadline.Now + timeout;

            foreach (var name in names)
            {
                var barrierTimeout = stop.TimeLeft;
                if (barrierTimeout.Ticks < 0)
                {
                    _client.Tell(new ToServer<FailBarrier>(new FailBarrier(name)));
                    throw new TimeoutException("Server timed out while waiting for barrier " + name);
                }
                try
                {
                    var askTimeout = barrierTimeout + Settings.QueryTimeout;
                    // Need to force barrier to wait here, so we can pass along a "fail barrier" message in the event
                    // of a failed operation
                    var result = _client.Ask(new ToServer<EnterBarrier>(new EnterBarrier(name, barrierTimeout)), askTimeout).Result;
                }
                catch (AggregateException ex)
                {
                    _client.Tell(new ToServer<FailBarrier>(new FailBarrier(name)));
                    throw new TimeoutException("Client timed out while waiting for barrier " + name, ex);
                }
                catch (OperationCanceledException)
                {
                   _system.Log.Debug("OperationCanceledException was thrown instead of AggregateException");
                }
                _system.Log.Debug("passed barrier {0}", name);
            }
        }

        public Task<Address> GetAddressFor(RoleName name)
        {
            return _client.Ask<Address>(new ToServer<GetAddress>(new GetAddress(name)), Settings.QueryTimeout);
        }
    }

    /// <summary>
    /// This is the controlling entity on the player
    /// side: in a first step it registers itself with a symbolic name and its remote
    /// address at the <see cref="Controller"/>, then waits for the
    /// `Done` message which signals that all other expected test participants have
    /// done the same. After that, it will pass barrier requests to and from the
    /// coordinator and react to the Conductors’s
    /// requests for failure injection.
    /// 
    /// Note that you can't perform requests concurrently, e.g. enter barrier
    /// from one thread and ask for node address from another thread.
    /// 
    /// INTERNAL API.
    /// </summary>
    [InternalApi]
    class ClientFSM : FSM<ClientFSM.State, ClientFSM.Data>, ILoggingFSM
        //TODO: RequireMessageQueue
    {
        public enum State
        {
            Connecting,
            AwaitDone,
            Connected,
            Failed
        }

        internal class Data
        {
            readonly IChannel _channel;
            public IChannel Channel { get { return _channel; } }
            readonly (string, IActorRef)? _runningOp;
            public (string, IActorRef)? RunningOp => _runningOp;

            public Data(IChannel channel, (string, IActorRef)? runningOp)
            {
                _channel = channel;
                _runningOp = runningOp;
            }

            /// <inheritdoc/>
            protected bool Equals(Data other)
            {
                return Equals(_channel, other._channel) && Equals(_runningOp, other._runningOp);
            }

            /// <inheritdoc/>
            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != this.GetType()) return false;
                return Equals((Data) obj);
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                unchecked
                {
                    return ((_channel != null ? _channel.GetHashCode() : 0) * 397) 
                        ^ (_runningOp != null ? _runningOp.GetHashCode() : 0);
                }
            }

            /// <summary>
            /// Compares two specified <see cref="Data"/> for equality.
            /// </summary>
            /// <param name="left">The first <see cref="Data"/> used for comparison</param>
            /// <param name="right">The second <see cref="Data"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Data"/> are equal; otherwise <c>false</c></returns>
            public static bool operator ==(Data left, Data right)
            {
                return Equals(left, right);
            }

            /// <summary>
            /// Compares two specified <see cref="Data"/> for inequality.
            /// </summary>
            /// <param name="left">The first <see cref="Data"/> used for comparison</param>
            /// <param name="right">The second <see cref="Data"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Data"/> are not equal; otherwise <c>false</c></returns>
            public static bool operator !=(Data left, Data right)
            {
                return !Equals(left, right);
            }

            public Data Copy((string, IActorRef)? runningOp)
            {
                return new Data(Channel, runningOp);
            }
        }

        internal class Connected : INoSerializationVerificationNeeded
        {
            readonly IChannel _channel;
            public IChannel Channel{get { return _channel; }}

            public Connected(IChannel channel)
            {
                _channel = channel;
            }

            protected bool Equals(Connected other)
            {
                return Equals(_channel, other._channel);
            }

            /// <inheritdoc/>
            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != this.GetType()) return false;
                return Equals((Connected) obj);
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                return (_channel != null ? _channel.GetHashCode() : 0);
            }

            /// <summary>
            /// Compares two specified <see cref="Connected"/> for equality.
            /// </summary>
            /// <param name="left">The first <see cref="Connected"/> used for comparison</param>
            /// <param name="right">The second <see cref="Connected"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Connected"/> are equal; otherwise <c>false</c></returns>
            public static bool operator ==(Connected left, Connected right)
            {
                return Equals(left, right);
            }

            /// <summary>
            /// Compares two specified <see cref="Connected"/> for inequality.
            /// </summary>
            /// <param name="left">The first <see cref="Connected"/> used for comparison</param>
            /// <param name="right">The second <see cref="Connected"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Connected"/> are not equal; otherwise <c>false</c></returns>
            public static bool operator !=(Connected left, Connected right)
            {
                return !Equals(left, right);
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        internal class ConnectionFailure : Exception
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="ConnectionFailure"/> class.
            /// </summary>
            /// <param name="message">The message that describes the error.</param>
            public ConnectionFailure(string message) : base(message)
            {
            }
        }

        internal class Disconnected
        {
            private Disconnected() { }
            private static readonly Disconnected _instance = new Disconnected();

            public static Disconnected Instance
            {
                get
                {
                    return _instance;
                }
            }            
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        readonly TestConductorSettings _settings;
        readonly PlayerHandler _handler;
        readonly RoleName _name;

        public ClientFSM(RoleName name, IPEndPoint controllerAddr)
        {
            _settings = TestConductor.Get(Context.System).Settings;
            _handler = new PlayerHandler(controllerAddr, _settings.ClientReconnects, _settings.ReconnectBackoff,
                _settings.ClientSocketWorkerPoolSize, Self, Logging.GetLogger(Context.System, "PlayerHandler"),
                Context.System.Scheduler);
            _name = name;

            InitFSM();
        }

        public void InitFSM()
        {
            StartWith(State.Connecting, new Data(null, null));

            When(State.Connecting, @event =>
            {
                if (@event.FsmEvent is IClientOp)
                {
                    return Stay().Replying(new Status.Failure(new IllegalStateException("not connected yet")));
                }
                var connected = @event.FsmEvent as Connected;
                if (connected != null)
                {
                    connected.Channel.WriteAndFlushAsync(new Hello(_name.Name, TestConductor.Get(Context.System).Address));
                    return GoTo(State.AwaitDone).Using(new Data(connected.Channel, null));
                }
                if (@event.FsmEvent is ConnectionFailure)
                {
                    return GoTo(State.Failed);
                }
                if (@event.FsmEvent is StateTimeout)
                {
                    _log.Error($"Failed to connect to test conductor within {_settings.ConnectTimeout.TotalMilliseconds} ms.");
                    return GoTo(State.Failed);
                }

                return null;
            }, _settings.ConnectTimeout);

            When(State.AwaitDone, @event =>
            {
                if (@event.FsmEvent is Done)
                {
                    _log.Debug("received Done: starting test");
                    return GoTo(State.Connected);
                }
                if (@event.FsmEvent is INetworkOp)
                {
                    _log.Error("Received {0} instead of Done", @event.FsmEvent);
                    return GoTo(State.Failed);
                }
                if (@event.FsmEvent is IServerOp)
                {
                    return Stay().Replying(new Failure(new IllegalStateException("not connected yet")));
                }
                if (@event.FsmEvent is StateTimeout)
                {
                    _log.Error("connect timeout to TestConductor");
                    return GoTo(State.Failed);
                }
                return null;
            }, _settings.BarrierTimeout);

            When(State.Connected, @event =>
            {
                if (@event.FsmEvent is Disconnected)
                {
                    _log.Info("disconnected from TestConductor");
                    throw new ConnectionFailure("disconnect");
                }
                if(@event.FsmEvent is ToServer<Done> && @event.StateData.Channel != null)
                {
                    @event.StateData.Channel.WriteAndFlushAsync(Done.Instance);
                    return Stay();
                }
                var toServer = @event.FsmEvent as IToServer;
                if (toServer != null && @event.StateData.Channel != null &&
                    @event.StateData.RunningOp == null)
                {
                    @event.StateData.Channel.WriteAndFlushAsync(toServer.Msg);
                    string token = null;
                    var enterBarrier = @event.FsmEvent as ToServer<EnterBarrier>;
                    if (enterBarrier != null) token = enterBarrier.Msg.Name;
                    else
                    {
                        var getAddress = @event.FsmEvent as ToServer<GetAddress>;
                        if (getAddress != null) token = getAddress.Msg.Node.Name;
                    }
                    return Stay().Using(@event.StateData.Copy(runningOp: (token, Sender)));
                }
                if (toServer != null && @event.StateData.Channel != null &&
                    @event.StateData.RunningOp != null)
                {
                    _log.Error("cannot write {0} while waiting for {1}", toServer.Msg, @event.StateData.RunningOp);
                    return Stay();
                }
                if (@event.FsmEvent is IClientOp && @event.StateData.Channel != null)
                {
                    var barrierResult = @event.FsmEvent as BarrierResult;
                    if (barrierResult != null)
                    {
                        if (@event.StateData.RunningOp == null)
                        {
                            _log.Warning("did not expect {0}", @event.FsmEvent);
                        }
                        else
                        {
                            object response;
                            if (barrierResult.Name != @event.StateData.RunningOp.Value.Item1)
                            {
                                response =
                                    new Failure(
                                        new Exception("wrong barrier " + barrierResult + " received while waiting for " +
                                                      @event.StateData.RunningOp.Value.Item1));
                            }
                            else if (!barrierResult.Success)
                            {
                                response =
                                    new Failure(
                                        new Exception("barrier failed:" + @event.StateData.RunningOp.Value.Item1));
                            }
                            else
                            {
                                response = barrierResult.Name;
                            }
                            @event.StateData.RunningOp.Value.Item2.Tell(response);
                        }
                        return Stay().Using(@event.StateData.Copy(runningOp: null));
                    }
                    var addressReply = @event.FsmEvent as AddressReply;
                    if (addressReply != null)
                    {
                        if (@event.StateData.RunningOp == null)
                        {
                            _log.Warning("did not expect {0}", @event.FsmEvent);
                        }
                        else
                        {
                            @event.StateData.RunningOp.Value.Item2.Tell(addressReply.Addr);
                        }
                        return Stay().Using(@event.StateData.Copy(runningOp: null));
                    }
                    var throttleMsg = @event.FsmEvent as ThrottleMsg;
                    if (@event.FsmEvent is ThrottleMsg)
                    {
                        ThrottleMode mode;
                        if (throttleMsg.RateMBit < 0.0f) mode = Unthrottled.Instance;
                        else if (throttleMsg.RateMBit == 0.0f) mode = Blackhole.Instance;
                        else mode = new Transport.TokenBucket(1000, throttleMsg.RateMBit*125000, 0, 0);
                        var cmdTask =
                            TestConductor.Get(Context.System)
                                .Transport.ManagementCommand(new SetThrottle(throttleMsg.Target, throttleMsg.Direction,
                                    mode));

                        var self = Self;
                        cmdTask.ContinueWith(t =>
                        {
                            if (t.IsFaulted)
                                throw new ConfigurationException("Throttle was requested from the TestConductor, but no transport " +
                                    "adapters available that support throttling. Specify 'testTransport(on=true)' in your MultiNodeConfig");
                            self.Tell(new ToServer<Done>(Done.Instance));
                        });
                        return Stay();
                    }
                    if (@event.FsmEvent is DisconnectMsg)
                        return Stay(); //FIXME is this the right EC for the future below?
                    var terminateMsg = @event.FsmEvent as TerminateMsg;
                    if (terminateMsg != null)
                    {
                        _log.Info("Received TerminateMsg - shutting down...");
                        if (terminateMsg.ShutdownOrExit.IsLeft && terminateMsg.ShutdownOrExit.ToLeft().Value == false)
                        {
                            Context.System.Terminate();
                            return Stay();
                        }
                        if (terminateMsg.ShutdownOrExit.IsLeft && terminateMsg.ShutdownOrExit.ToLeft().Value == true)
                        {
                            Context.System.AsInstanceOf<ActorSystemImpl>().Abort();
                            return Stay();
                        }
                        if (terminateMsg.ShutdownOrExit.IsRight)
                        {
                            Environment.Exit(terminateMsg.ShutdownOrExit.ToRight().Value);
                            return Stay();
                        }
                    }
                    if (@event.FsmEvent is Done) return Stay(); //FIXME what should happen?
                }
                return null;
            });

            When(State.Failed, @event =>
            {
                if (@event.FsmEvent is IClientOp)
                {
                    return Stay().Replying(new Status.Failure(new Exception("cannot do " + @event.FsmEvent + " while failed")));
                }
                if (@event.FsmEvent is INetworkOp)
                {
                    _log.Warning("ignoring network message {0} while Failed", @event.FsmEvent);
                    return Stay();
                }
                return null;
            });

            OnTermination(e =>
            {
                _log.Info("Terminating connection to multi-node test controller due to [{0}]", e.Reason);
                if (e.StateData.Channel != null)
                {
                    var disconnectTimeout = TimeSpan.FromSeconds(2); //todo: make into setting loaded from HOCON
                    if (!e.StateData.Channel.CloseAsync().Wait(disconnectTimeout))
                    {
                        _log.Warning("Failed to disconnect from conductor within {0}", disconnectTimeout);
                    }
                }
            });

            Initialize();            
        }
    }

    /// <summary>
    /// This handler only forwards messages received from the conductor to the <see cref="ClientFSM"/>
    /// 
    /// INTERNAL API.
    /// </summary>
    internal class PlayerHandler : ChannelHandlerAdapter
    {
        readonly IPEndPoint _server;
        int _reconnects;
        readonly TimeSpan _backoff;
        readonly int _poolSize;
        readonly IActorRef _fsm;
        readonly ILoggingAdapter _log;
        readonly IScheduler _scheduler;
        private bool _loggedDisconnect = false;
        
        Deadline _nextAttempt;

        /// <summary>
        /// Shareable, since the handler may be added multiple times during reconnect
        /// </summary>
        public override bool IsSharable => true;

        public PlayerHandler(IPEndPoint server, int reconnects, TimeSpan backoff, int poolSize, IActorRef fsm,
            ILoggingAdapter log, IScheduler scheduler)
        {
            _server = server;
            _reconnects = reconnects;
            _backoff = backoff;
            _poolSize = poolSize;
            _fsm = fsm;
            _log = log;
            _scheduler = scheduler;

            Reconnect();
        }

        private static string FormatConnectionFailure(IChannelHandlerContext context, Exception exception)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Connection between [Local: {context.Channel.LocalAddress}] and [Remote: {context.Channel.RemoteAddress}] has failed.");
            sb.AppendLine($"Cause: {exception}");
            sb.AppendLine($"Trace: {exception.StackTrace}");
            return sb.ToString();
        }

        public override void ExceptionCaught(IChannelHandlerContext context, Exception exception)
        {
            _log.Debug("channel {0} exception {1}", context.Channel, exception);
            if (exception is ConnectException && _reconnects > 0)
            {
                _reconnects -= 1;
                if (_nextAttempt.IsOverdue)
                {
                    Reconnect();
                }
                else
                {
                    _scheduler.Advanced.ScheduleOnce(_nextAttempt.TimeLeft, Reconnect);
                }
                return;
            }
            _fsm.Tell(new ClientFSM.ConnectionFailure(FormatConnectionFailure(context, exception)));
        }

        private void Reconnect()
        {
            _log.Debug("Connecting...");
            _nextAttempt = Deadline.Now + _backoff;
            RemoteConnection.CreateConnection(Role.Client, _server, _poolSize, this).ContinueWith(tr =>
            {
                _log.Debug("Failed to connect.... Retrying again in {0}s. {1} attempts left.", _nextAttempt.TimeLeft,_reconnects);
                if (_reconnects > 0)
                {
                    _reconnects -= 1;
                    if (_nextAttempt.IsOverdue)
                    {
                        Reconnect();
                    }
                    else
                    {
                        _scheduler.Advanced.ScheduleOnce(_nextAttempt.TimeLeft, Reconnect);
                    }
                }
            }, TaskContinuationOptions.NotOnRanToCompletion);
        }

        public override void ChannelActive(IChannelHandlerContext context)
        {
            _log.Debug("connected to {0}", context.Channel.RemoteAddress);
            _fsm.Tell(new ClientFSM.Connected(context.Channel));
            context.FireChannelActive();
        }

        public override void ChannelInactive(IChannelHandlerContext context)
        {
            if (!_loggedDisconnect) //added this to help mute log messages
            {
                _loggedDisconnect = true;
                _log.Debug("disconnected from {0}", context.Channel.RemoteAddress);

            }
            _fsm.Tell(PoisonPill.Instance);

            // run outside of the Helios / DotNetty threadpool
            Task.Factory.StartNew(() =>
            {
                RemoteConnection.Shutdown(context.Channel);
                RemoteConnection.ReleaseAll(); // yep, let it run asynchronously.
            }, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default);
            context.FireChannelInactive();
        }

        public override void ChannelRead(IChannelHandlerContext context, object message)
        {
            var channel = context.Channel;
            _log.Debug("message from {0}, {1}", channel.RemoteAddress, message);
            if (message is INetworkOp)
            {
                _fsm.Tell(message);
                return;
            }
            _log.Info("server {0} sent garbage '{1}', disconnecting", channel.RemoteAddress, message);
            channel.CloseAsync();
        }

        public override Task CloseAsync(IChannelHandlerContext context)
        {
            _log.Info("Client: disconnecting {0} from {1}", context.Channel.LocalAddress, context.Channel.RemoteAddress);
            return base.CloseAsync(context);
        }
    }
}


---- Transformed Tree ----
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Akka.Actor;
using Akka.Actor.Internal;
using Akka.Annotations;
using Akka.Event;
using Akka.Pattern;
using Akka.Remote.Transport;
using Akka.Util;
using Akka.Util.Internal;
using DotNetty.Transport.Channels;
using Akka.Configuration;

namespace Akka.Remote.TestKit
{
    /// <summary>
    /// The Player is the client component of the
    /// test conductor extension. It registers with
    /// the conductor's controller
    ///  in order to participate in barriers and enable network failure injection
    /// </summary>
    partial class TestConductor //Player trait in JVM version
    {
        IActorRef _client;

        public IActorRef Client
        {
            get
            {
                if(_client == null) throw new IllegalStateException("TestConductor client not yet started");
                if(_system.WhenTerminated.IsCompleted) throw new IllegalStateException("TestConductor unavailable because system is terminated; you need to StartNewSystem() before this point");
                return _client;
            }
        }

        /// <summary>
        /// Connect to the conductor on the given port (the host is taken from setting
        /// `akka.testconductor.host`). The connection is made asynchronously, but you
        /// should await completion of the returned Future because that implies that
        /// all expected participants of this test have successfully connected (i.e.
        /// this is a first barrier in itself). The number of expected participants is
        /// set in <see cref="TestConductor"/>`.startController()`.
        /// </summary>
        public Task<Done> StartClient(RoleName name, IPEndPoint controllerAddr)
        {
            if(_client != null) throw new IllegalStateException("TestConductorClient already started");
                _client =
                _system.ActorOf(Props.Create(() => new ClientFSM(name, controllerAddr)), "TestConductorClient");

            //TODO: IRequiresMessageQueue
            var a = _system.ActorOf(Props.Create<WaitForClientFSMToConnect>());

            return a.Ask<Done>(_client);
        }

        private class WaitForClientFSMToConnect : UntypedActor
        {
            IActorRef _waiting;

            protected override void OnReceive(object message)
            {
                if (message is IActorRef fsm)
                {
                    _waiting = Sender;
                    fsm.Tell(new FSMBase.SubscribeTransitionCallBack(Self));
                    return;
                }

                if (message is FSMBase.Transition<ClientFSM.State> transition)
                {
                    if (transition.From == ClientFSM.State.Connecting && transition.To == ClientFSM.State.AwaitDone)
                        return;
                    if (transition.From == ClientFSM.State.AwaitDone && transition.To == ClientFSM.State.Connected)
                    {
                        _waiting.Tell(Done.Instance);
                        Context.Stop(Self);
                        return;
                    }
                    _waiting.Tell(new Exception("unexpected transition: " + transition));
                    Context.Stop(Self);
                }

                if (message is FSMBase.CurrentState<ClientFSM.State> currentState)
                {
                    if (currentState.State == ClientFSM.State.Connected)
                    {
                        _waiting.Tell(Done.Instance);
                        Context.Stop(Self);
                        return;

                    }
                }
            }
        }

        /// <summary>
        /// Enter the named barriers, one after the other, in the order given. Will
        /// throw an exception in case of timeouts or other errors.
        /// </summary>
        public void Enter(string name)
        {
            Enter(Settings.BarrierTimeout, ImmutableList.Create(name));
        }

        /// <summary>
        /// Enter the named barriers, one after the other, in the order given. Will
        /// throw an exception in case of timeouts or other errors.
        /// </summary>
        public void Enter(TimeSpan timeout, ImmutableList<string> names)
        {
            _system.Log.Debug("entering barriers {0}", names.Aggregate((a, b) => "(" + a + "," + b + ")"));
            var stop = Deadline.Now + timeout;

            foreach (var name in names)
            {
                var barrierTimeout = stop.TimeLeft;
                if (barrierTimeout.Ticks < 0)
                {
                    _client.Tell(new ToServer<FailBarrier>(new FailBarrier(name)));
                    throw new TimeoutException("Server timed out while waiting for barrier " + name);
                }
                try
                {
                    var askTimeout = barrierTimeout + Settings.QueryTimeout;
                    // Need to force barrier to wait here, so we can pass along a "fail barrier" message in the event
                    // of a failed operation
                    var result = _client.Ask(new ToServer<EnterBarrier>(new EnterBarrier(name, barrierTimeout)), askTimeout).Result;
                }
                catch (AggregateException ex)
                {
                    _client.Tell(new ToServer<FailBarrier>(new FailBarrier(name)));
                    throw new TimeoutException("Client timed out while waiting for barrier " + name, ex);
                }
                catch (OperationCanceledException)
                {
                   _system.Log.Debug("OperationCanceledException was thrown instead of AggregateException");
                }
                _system.Log.Debug("passed barrier {0}", name);
            }
        }

        public Task<Address> GetAddressFor(RoleName name)
        {
            return _client.Ask<Address>(new ToServer<GetAddress>(new GetAddress(name)), Settings.QueryTimeout);
        }
    }

    /// <summary>
    /// This is the controlling entity on the player
    /// side: in a first step it registers itself with a symbolic name and its remote
    /// address at the <see cref="Controller"/>, then waits for the
    /// `Done` message which signals that all other expected test participants have
    /// done the same. After that, it will pass barrier requests to and from the
    /// coordinator and react to the Conductors’s
    /// requests for failure injection.
    /// 
    /// Note that you can't perform requests concurrently, e.g. enter barrier
    /// from one thread and ask for node address from another thread.
    /// 
    /// INTERNAL API.
    /// </summary>
    [InternalApi]
    class ClientFSM : FSM<ClientFSM.State, ClientFSM.Data>, ILoggingFSM
        //TODO: RequireMessageQueue
    {
        public enum State
        {
            Connecting,
            AwaitDone,
            Connected,
            Failed
        }

        internal class Data
        {
            readonly IChannel _channel;
            public IChannel Channel { get { return _channel; } }
            readonly (string, IActorRef)? _runningOp;
            public (string, IActorRef)? RunningOp => _runningOp;

            public Data(IChannel channel, (string, IActorRef)? runningOp)
            {
                _channel = channel;
                _runningOp = runningOp;
            }

            /// <inheritdoc/>
            protected bool Equals(Data other)
            {
                return Equals(_channel, other._channel) && Equals(_runningOp, other._runningOp);
            }

            /// <inheritdoc/>
            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != this.GetType()) return false;
                return Equals((Data) obj);
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                unchecked
                {
                    return ((_channel != null ? _channel.GetHashCode() : 0) * 397) 
                        ^ (_runningOp != null ? _runningOp.GetHashCode() : 0);
                }
            }

            /// <summary>
            /// Compares two specified <see cref="Data"/> for equality.
            /// </summary>
            /// <param name="left">The first <see cref="Data"/> used for comparison</param>
            /// <param name="right">The second <see cref="Data"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Data"/> are equal; otherwise <c>false</c></returns>
            public static bool operator ==(Data left, Data right)
            {
                return Equals(left, right);
            }

            /// <summary>
            /// Compares two specified <see cref="Data"/> for inequality.
            /// </summary>
            /// <param name="left">The first <see cref="Data"/> used for comparison</param>
            /// <param name="right">The second <see cref="Data"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Data"/> are not equal; otherwise <c>false</c></returns>
            public static bool operator !=(Data left, Data right)
            {
                return !Equals(left, right);
            }

            public Data Copy((string, IActorRef)? runningOp)
            {
                return new Data(Channel, runningOp);
            }
        }

        internal class Connected : INoSerializationVerificationNeeded
        {
            readonly IChannel _channel;
            public IChannel Channel{get { return _channel; }}

            public Connected(IChannel channel)
            {
                _channel = channel;
            }

            protected bool Equals(Connected other)
            {
                return Equals(_channel, other._channel);
            }

            /// <inheritdoc/>
            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != this.GetType()) return false;
                return Equals((Connected) obj);
            }

            /// <inheritdoc/>
            public override int GetHashCode()
            {
                return (_channel != null ? _channel.GetHashCode() : 0);
            }

            /// <summary>
            /// Compares two specified <see cref="Connected"/> for equality.
            /// </summary>
            /// <param name="left">The first <see cref="Connected"/> used for comparison</param>
            /// <param name="right">The second <see cref="Connected"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Connected"/> are equal; otherwise <c>false</c></returns>
            public static bool operator ==(Connected left, Connected right)
            {
                return Equals(left, right);
            }

            /// <summary>
            /// Compares two specified <see cref="Connected"/> for inequality.
            /// </summary>
            /// <param name="left">The first <see cref="Connected"/> used for comparison</param>
            /// <param name="right">The second <see cref="Connected"/> used for comparison</param>
            /// <returns><c>true</c> if both <see cref="Connected"/> are not equal; otherwise <c>false</c></returns>
            public static bool operator !=(Connected left, Connected right)
            {
                return !Equals(left, right);
            }
        }

        /// <summary>
        /// TBD
        /// </summary>
        internal class ConnectionFailure : Exception
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="ConnectionFailure"/> class.
            /// </summary>
            /// <param name="message">The message that describes the error.</param>
            public ConnectionFailure(string message) : base(message)
            {
            }
        }

        internal class Disconnected
        {
            private Disconnected() { }
            private static readonly Disconnected _instance = new Disconnected();

            public static Disconnected Instance
            {
                get
                {
                    return _instance;
                }
            }            
        }

        private readonly ILoggingAdapter _log = Context.GetLogger();
        readonly TestConductorSettings _settings;
        readonly PlayerHandler _handler;
        readonly RoleName _name;

        public ClientFSM(RoleName name, IPEndPoint controllerAddr)
        {
            _settings = TestConductor.Get(Context.System).Settings;
            _handler = new PlayerHandler(controllerAddr, _settings.ClientReconnects, _settings.ReconnectBackoff,
                _settings.ClientSocketWorkerPoolSize, Self, Logging.GetLogger(Context.System, "PlayerHandler"),
                Context.System.Scheduler);
            _name = name;

            InitFSM();
        }

        public void InitFSM()
        {
            StartWith(State.Connecting, new Data(null, null));

            When(State.Connecting, @event =>
            {
                if (@event.FsmEvent is IClientOp)
                {
                    return Stay().Replying(new Status.Failure(new IllegalStateException("not connected yet")));
                }

                if (@event.FsmEvent is Connected connected)
                {
                    connected.Channel.WriteAndFlushAsync(new Hello(_name.Name, TestConductor.Get(Context.System).Address));
                    return GoTo(State.AwaitDone).Using(new Data(connected.Channel, null));
                }
                if (@event.FsmEvent is ConnectionFailure)
                {
                    return GoTo(State.Failed);
                }
                if (@event.FsmEvent is StateTimeout)
                {
                    _log.Error($"Failed to connect to test conductor within {_settings.ConnectTimeout.TotalMilliseconds} ms.");
                    return GoTo(State.Failed);
                }

                return null;
            }, _settings.ConnectTimeout);

            When(State.AwaitDone, @event =>
            {
                if (@event.FsmEvent is Done)
                {
                    _log.Debug("received Done: starting test");
                    return GoTo(State.Connected);
                }
                if (@event.FsmEvent is INetworkOp)
                {
                    _log.Error("Received {0} instead of Done", @event.FsmEvent);
                    return GoTo(State.Failed);
                }
                if (@event.FsmEvent is IServerOp)
                {
                    return Stay().Replying(new Failure(new IllegalStateException("not connected yet")));
                }
                if (@event.FsmEvent is StateTimeout)
                {
                    _log.Error("connect timeout to TestConductor");
                    return GoTo(State.Failed);
                }
                return null;
            }, _settings.BarrierTimeout);

            When(State.Connected, @event =>
            {
                if (@event.FsmEvent is Disconnected)
                {
                    _log.Info("disconnected from TestConductor");
                    throw new ConnectionFailure("disconnect");
                }
                if(@event.FsmEvent is ToServer<Done> && @event.StateData.Channel != null)
                {
                    @event.StateData.Channel.WriteAndFlushAsync(Done.Instance);
                    return Stay();
                }
                if (@event.FsmEvent is IToServer toServer && @event.StateData.Channel != null &&
                    @event.StateData.RunningOp == null)
                {
                    @event.StateData.Channel.WriteAndFlushAsync(toServer.Msg);
                    string token = null;

                    if (@event.FsmEvent is ToServer<EnterBarrier> enterBarrier) token = enterBarrier.Msg.Name;
                    else
                    {
                        if (@event.FsmEvent is ToServer<GetAddress> getAddress) token = getAddress.Msg.Node.Name;
                    }
                    return Stay().Using(@event.StateData.Copy(runningOp: (token, Sender)));
                }
                if (@event.FsmEvent is IToServer toServer && @event.StateData.Channel != null &&
                    @event.StateData.RunningOp != null)
                {
                    _log.Error("cannot write {0} while waiting for {1}", toServer.Msg, @event.StateData.RunningOp);
                    return Stay();
                }
                if (@event.FsmEvent is IClientOp && @event.StateData.Channel != null)
                {
                    if (@event.FsmEvent is BarrierResult barrierResult)
                    {
                        if (@event.StateData.RunningOp == null)
                        {
                            _log.Warning("did not expect {0}", @event.FsmEvent);
                        }
                        else
                        {
                            object response;
                            if (barrierResult.Name != @event.StateData.RunningOp.Value.Item1)
                            {
                                response =
                                    new Failure(
                                        new Exception("wrong barrier " + barrierResult + " received while waiting for " +
                                                      @event.StateData.RunningOp.Value.Item1));
                            }
                            else if (!barrierResult.Success)
                            {
                                response =
                                    new Failure(
                                        new Exception("barrier failed:" + @event.StateData.RunningOp.Value.Item1));
                            }
                            else
                            {
                                response = barrierResult.Name;
                            }
                            @event.StateData.RunningOp.Value.Item2.Tell(response);
                        }
                        return Stay().Using(@event.StateData.Copy(runningOp: null));
                    }

                    if (@event.FsmEvent is AddressReply addressReply)
                    {
                        if (@event.StateData.RunningOp == null)
                        {
                            _log.Warning("did not expect {0}", @event.FsmEvent);
                        }
                        else
                        {
                            @event.StateData.RunningOp.Value.Item2.Tell(addressReply.Addr);
                        }
                        return Stay().Using(@event.StateData.Copy(runningOp: null));
                    }
                    var throttleMsg = @event.FsmEvent as ThrottleMsg;
                    if (@event.FsmEvent is ThrottleMsg)
                    {
                        ThrottleMode mode;
                        if (throttleMsg.RateMBit < 0.0f) mode = Unthrottled.Instance;
                        else if (throttleMsg.RateMBit == 0.0f) mode = Blackhole.Instance;
                        else mode = new Transport.TokenBucket(1000, throttleMsg.RateMBit*125000, 0, 0);
                        var cmdTask =
                            TestConductor.Get(Context.System)
                                .Transport.ManagementCommand(new SetThrottle(throttleMsg.Target, throttleMsg.Direction,
                                    mode));

                        var self = Self;
                        cmdTask.ContinueWith(t =>
                        {
                            if (t.IsFaulted)
                                throw new ConfigurationException("Throttle was requested from the TestConductor, but no transport " +
                                    "adapters available that support throttling. Specify 'testTransport(on=true)' in your MultiNodeConfig");
                            self.Tell(new ToServer<Done>(Done.Instance));
                        });
                        return Stay();
                    }
                    if (@event.FsmEvent is DisconnectMsg)
                        return Stay(); //FIXME is this the right EC for the future below?

                    if (@event.FsmEvent is TerminateMsg terminateMsg)
                    {
                        _log.Info("Received TerminateMsg - shutting down...");
                        if (terminateMsg.ShutdownOrExit.IsLeft && terminateMsg.ShutdownOrExit.ToLeft().Value == false)
                        {
                            Context.System.Terminate();
                            return Stay();
                        }
                        if (terminateMsg.ShutdownOrExit.IsLeft && terminateMsg.ShutdownOrExit.ToLeft().Value == true)
                        {
                            Context.System.AsInstanceOf<ActorSystemImpl>().Abort();
                            return Stay();
                        }
                        if (terminateMsg.ShutdownOrExit.IsRight)
                        {
                            Environment.Exit(terminateMsg.ShutdownOrExit.ToRight().Value);
                            return Stay();
                        }
                    }
                    if (@event.FsmEvent is Done) return Stay(); //FIXME what should happen?
                }
                return null;
            });

            When(State.Failed, @event =>
            {
                if (@event.FsmEvent is IClientOp)
                {
                    return Stay().Replying(new Status.Failure(new Exception("cannot do " + @event.FsmEvent + " while failed")));
                }
                if (@event.FsmEvent is INetworkOp)
                {
                    _log.Warning("ignoring network message {0} while Failed", @event.FsmEvent);
                    return Stay();
                }
                return null;
            });

            OnTermination(e =>
            {
                _log.Info("Terminating connection to multi-node test controller due to [{0}]", e.Reason);
                if (e.StateData.Channel != null)
                {
                    var disconnectTimeout = TimeSpan.FromSeconds(2); //todo: make into setting loaded from HOCON
                    if (!e.StateData.Channel.CloseAsync().Wait(disconnectTimeout))
                    {
                        _log.Warning("Failed to disconnect from conductor within {0}", disconnectTimeout);
                    }
                }
            });

            Initialize();            
        }
    }

    /// <summary>
    /// This handler only forwards messages received from the conductor to the <see cref="ClientFSM"/>
    /// 
    /// INTERNAL API.
    /// </summary>
    internal class PlayerHandler : ChannelHandlerAdapter
    {
        readonly IPEndPoint _server;
        int _reconnects;
        readonly TimeSpan _backoff;
        readonly int _poolSize;
        readonly IActorRef _fsm;
        readonly ILoggingAdapter _log;
        readonly IScheduler _scheduler;
        private bool _loggedDisconnect = false;
        
        Deadline _nextAttempt;

        /// <summary>
        /// Shareable, since the handler may be added multiple times during reconnect
        /// </summary>
        public override bool IsSharable => true;

        public PlayerHandler(IPEndPoint server, int reconnects, TimeSpan backoff, int poolSize, IActorRef fsm,
            ILoggingAdapter log, IScheduler scheduler)
        {
            _server = server;
            _reconnects = reconnects;
            _backoff = backoff;
            _poolSize = poolSize;
            _fsm = fsm;
            _log = log;
            _scheduler = scheduler;

            Reconnect();
        }

        private static string FormatConnectionFailure(IChannelHandlerContext context, Exception exception)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Connection between [Local: {context.Channel.LocalAddress}] and [Remote: {context.Channel.RemoteAddress}] has failed.");
            sb.AppendLine($"Cause: {exception}");
            sb.AppendLine($"Trace: {exception.StackTrace}");
            return sb.ToString();
        }

        public override void ExceptionCaught(IChannelHandlerContext context, Exception exception)
        {
            _log.Debug("channel {0} exception {1}", context.Channel, exception);
            if (exception is ConnectException && _reconnects > 0)
            {
                _reconnects -= 1;
                if (_nextAttempt.IsOverdue)
                {
                    Reconnect();
                }
                else
                {
                    _scheduler.Advanced.ScheduleOnce(_nextAttempt.TimeLeft, Reconnect);
                }
                return;
            }
            _fsm.Tell(new ClientFSM.ConnectionFailure(FormatConnectionFailure(context, exception)));
        }

        private void Reconnect()
        {
            _log.Debug("Connecting...");
            _nextAttempt = Deadline.Now + _backoff;
            RemoteConnection.CreateConnection(Role.Client, _server, _poolSize, this).ContinueWith(tr =>
            {
                _log.Debug("Failed to connect.... Retrying again in {0}s. {1} attempts left.", _nextAttempt.TimeLeft,_reconnects);
                if (_reconnects > 0)
                {
                    _reconnects -= 1;
                    if (_nextAttempt.IsOverdue)
                    {
                        Reconnect();
                    }
                    else
                    {
                        _scheduler.Advanced.ScheduleOnce(_nextAttempt.TimeLeft, Reconnect);
                    }
                }
            }, TaskContinuationOptions.NotOnRanToCompletion);
        }

        public override void ChannelActive(IChannelHandlerContext context)
        {
            _log.Debug("connected to {0}", context.Channel.RemoteAddress);
            _fsm.Tell(new ClientFSM.Connected(context.Channel));
            context.FireChannelActive();
        }

        public override void ChannelInactive(IChannelHandlerContext context)
        {
            if (!_loggedDisconnect) //added this to help mute log messages
            {
                _loggedDisconnect = true;
                _log.Debug("disconnected from {0}", context.Channel.RemoteAddress);

            }
            _fsm.Tell(PoisonPill.Instance);

            // run outside of the Helios / DotNetty threadpool
            Task.Factory.StartNew(() =>
            {
                RemoteConnection.Shutdown(context.Channel);
                RemoteConnection.ReleaseAll(); // yep, let it run asynchronously.
            }, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default);
            context.FireChannelInactive();
        }

        public override void ChannelRead(IChannelHandlerContext context, object message)
        {
            var channel = context.Channel;
            _log.Debug("message from {0}, {1}", channel.RemoteAddress, message);
            if (message is INetworkOp)
            {
                _fsm.Tell(message);
                return;
            }
            _log.Info("server {0} sent garbage '{1}', disconnecting", channel.RemoteAddress, message);
            channel.CloseAsync();
        }

        public override Task CloseAsync(IChannelHandlerContext context)
        {
            _log.Info("Client: disconnecting {0} from {1}", context.Channel.LocalAddress, context.Channel.RemoteAddress);
            return base.CloseAsync(context);
        }
    }
}


---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs(670,17): warning CS4014: Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.,D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs(21,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs(666,17): warning CS4014: Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.,D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs(427,50): error CS0128: A local variable or function named 'toServer' is already defined in this scope,D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs(430,74): error CS0165: Use of unassigned local variable 'toServer',D:\a\1\s\src\core\Akka.Remote.TestKit\Player.cs(21,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 7 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\core\Akka.Persistence.Tests\Serialization\MessageSerializerRemotingSpec.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Akka.Actor;
using Akka.Configuration;
using Akka.TestKit;
using FluentAssertions;
using Xunit;

namespace Akka.Persistence.Tests.Serialization
{
    internal class Configs
    {
        public static readonly Config CustomSerializers = ConfigurationFactory.ParseString(@"
akka.actor {
  serializers {
    my-payload = ""Akka.Persistence.Tests.Serialization.MyPayloadSerializer, Akka.Persistence.Tests""
    old-payload = ""Akka.Persistence.Tests.Serialization.OldPayloadSerializer, Akka.Persistence.Tests""
    testserializer = ""Akka.Serialization.HyperionSerializer, Akka.Serialization.Hyperion""
  }
  serialization-bindings {
    ""Akka.Persistence.Tests.Serialization.MyPayload, Akka.Persistence.Tests"" = my-payload
    ""System.Object"" = testserializer
    # this entry was used when creating the data for the test
    # ""deserialize data when class is removed""
    #""Akka.Persistence.Tests.Serialization.OldPayload, Akka.Persistence.Tests"" = old-payload
  }
}");
        public static readonly Config Remote = ConfigurationFactory.ParseString(@"
akka {
  actor {
    provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""
  }
  remote {
    dot-netty.tcp {
      applied-adapters = []
      transport-protocol = tcp
      port = 0
      hostname = ""127.0.0.1""
      port = 0
    }
  }
  loglevel = ERROR
  log-dead-letters = 0
  log-dead-letters-during-shutdown = off
}");

        public static Config Config(params string[] configs)
        {
            return configs.Aggregate(ConfigurationFactory.Empty,
                (r, c) => r.WithFallback(ConfigurationFactory.ParseString(c)));
        }
        
        public static Config Config(params Config[] configs)
        {
            return configs.Aggregate(ConfigurationFactory.Empty,
                (r, c) => r.WithFallback(c));
        }
    }

    public class MyPayload
    {
        public string Data { get; private set; }

        public MyPayload(string data)
        {
            Data = data;
        }

        protected bool Equals(MyPayload other)
        {
            return string.Equals(Data, other.Data);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((MyPayload) obj);
        }

        public override int GetHashCode()
        {
            return (Data != null ? Data.GetHashCode() : 0);
        }
    }

    // TODO: temporary disabled
    public class MessageSerializerRemotingSpec : AkkaSpec
    {
        internal class LocalActor : ActorBase
        {
            private readonly int _port;

            public LocalActor(int port)
            {
                _port = port;
            }

            protected override bool Receive(object message)
            {
                Context.ActorSelection(string.Format("akka.tcp://remote@127.0.0.1:{0}/user/remote", _port))
                    .Tell(message, ActorRefs.NoSender);
                return true;
            }
        }

        internal class RemoteActor : ActorBase
        {
            protected override bool Receive(object message)
            {
                if (message is Persistent)
                {
                    var p = (Persistent) message;
                    if (p.Payload is MyPayload)
                    {
                        p.Sender.Tell("p" + ((MyPayload) p.Payload).Data);
                    }
                    else return false;
                }
                else if (message is AtomicWrite)
                {
                    var a = (AtomicWrite) message;
                    foreach (var p in (IEnumerable<IPersistentRepresentation>) a.Payload)
                    {
                        if (p.Payload is MyPayload)
                        {
                            p.Sender.Tell("p" + ((MyPayload) p.Payload).Data);
                        }
                    }
                }
                else return false;
                return true;
            }
        }

        private readonly ActorSystem _remoteSystem;
        private readonly IActorRef _localActor;

        private readonly Akka.Serialization.Serialization _serialization;

        public MessageSerializerRemotingSpec() : base(
            Configs.Config(
                Configs.Remote,
                Configs.CustomSerializers,
                ConfigurationFactory.FromResource<Persistence>("Akka.Persistence.persistence.conf") // for akka-persistence-message
                ))
        {
            _remoteSystem = ActorSystem.Create("remote",
                Configs.Remote.WithFallback(Configs.CustomSerializers)
                    .WithFallback(ConfigurationFactory.FromResource<Persistence>("Akka.Persistence.persistence.conf")));
            _localActor = Sys.ActorOf(Props.Create(() => new LocalActor(Port(_remoteSystem))), "local");

            _serialization = Sys.Serialization;

            _remoteSystem.ActorOf(Props.Create(() => new RemoteActor()), "remote");
        }

        private int Port(ActorSystem system)
        {
            return Address(system).Port.Value;
        }

        private Address Address(ActorSystem system)
        {
            return ((ExtendedActorSystem) system).Provider.DefaultAddress;
        }

        protected override void AfterTermination()
        {
            _remoteSystem.Terminate().Wait(TimeSpan.FromSeconds(2));
            base.AfterTermination();
        }

        [Fact]
        public void MessageSerializer_should_custom_serialize_Persistent_messages_during_remoting()
        {
            // this also verifies serialization of Persistent.Sender,
            // because the RemoteActor will reply to the Persistent.Sender
            _localActor.Tell(new Persistent(new MyPayload("a"), sender: TestActor));
            ExpectMsg("p.a.");
        }

        [Fact]
        public void MessageSerializer_should_custom_serialize_AtomicWrite_messages_during_remoting()
        {
            var p1 = new Persistent(new MyPayload("a"), sender: TestActor);
            var p2 = new Persistent(new MyPayload("b"), sender: TestActor);
            _localActor.Tell(new AtomicWrite(ImmutableList.Create(new IPersistentRepresentation[] {p1, p2})));
            Within(5.Seconds(), () => { 
                ExpectMsg("p.a.");
                ExpectMsg("p.b.");
            });
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Akka.Actor;
using Akka.Configuration;
using Akka.TestKit;
using FluentAssertions;
using Xunit;

namespace Akka.Persistence.Tests.Serialization
{
    internal class Configs
    {
        public static readonly Config CustomSerializers = ConfigurationFactory.ParseString(@"
akka.actor {
  serializers {
    my-payload = ""Akka.Persistence.Tests.Serialization.MyPayloadSerializer, Akka.Persistence.Tests""
    old-payload = ""Akka.Persistence.Tests.Serialization.OldPayloadSerializer, Akka.Persistence.Tests""
    testserializer = ""Akka.Serialization.HyperionSerializer, Akka.Serialization.Hyperion""
  }
  serialization-bindings {
    ""Akka.Persistence.Tests.Serialization.MyPayload, Akka.Persistence.Tests"" = my-payload
    ""System.Object"" = testserializer
    # this entry was used when creating the data for the test
    # ""deserialize data when class is removed""
    #""Akka.Persistence.Tests.Serialization.OldPayload, Akka.Persistence.Tests"" = old-payload
  }
}");
        public static readonly Config Remote = ConfigurationFactory.ParseString(@"
akka {
  actor {
    provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""
  }
  remote {
    dot-netty.tcp {
      applied-adapters = []
      transport-protocol = tcp
      port = 0
      hostname = ""127.0.0.1""
      port = 0
    }
  }
  loglevel = ERROR
  log-dead-letters = 0
  log-dead-letters-during-shutdown = off
}");

        public static Config Config(params string[] configs)
        {
            return configs.Aggregate(ConfigurationFactory.Empty,
                (r, c) => r.WithFallback(ConfigurationFactory.ParseString(c)));
        }
        
        public static Config Config(params Config[] configs)
        {
            return configs.Aggregate(ConfigurationFactory.Empty,
                (r, c) => r.WithFallback(c));
        }
    }

    public class MyPayload
    {
        public string Data { get; private set; }

        public MyPayload(string data)
        {
            Data = data;
        }

        protected bool Equals(MyPayload other)
        {
            return string.Equals(Data, other.Data);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((MyPayload) obj);
        }

        public override int GetHashCode()
        {
            return (Data != null ? Data.GetHashCode() : 0);
        }
    }

    // TODO: temporary disabled
    public class MessageSerializerRemotingSpec : AkkaSpec
    {
        internal class LocalActor : ActorBase
        {
            private readonly int _port;

            public LocalActor(int port)
            {
                _port = port;
            }

            protected override bool Receive(object message)
            {
                Context.ActorSelection(string.Format("akka.tcp://remote@127.0.0.1:{0}/user/remote", _port))
                    .Tell(message, ActorRefs.NoSender);
                return true;
            }
        }

        internal class RemoteActor : ActorBase
        {
            protected override bool Receive(object message)
            {
                if (message is Persistent p)
                {
                    if (p.Payload is MyPayload)
                    {
                        p.Sender.Tell("p" + ((MyPayload) p.Payload).Data);
                    }
                    else return false;
                }
                else if (message is AtomicWrite a)
                {
                    foreach (var p in (IEnumerable<IPersistentRepresentation>) a.Payload)
                    {
                        if (p.Payload is MyPayload)
                        {
                            p.Sender.Tell("p" + ((MyPayload) p.Payload).Data);
                        }
                    }
                }
                else return false;
                return true;
            }
        }

        private readonly ActorSystem _remoteSystem;
        private readonly IActorRef _localActor;

        private readonly Akka.Serialization.Serialization _serialization;

        public MessageSerializerRemotingSpec() : base(
            Configs.Config(
                Configs.Remote,
                Configs.CustomSerializers,
                ConfigurationFactory.FromResource<Persistence>("Akka.Persistence.persistence.conf") // for akka-persistence-message
                ))
        {
            _remoteSystem = ActorSystem.Create("remote",
                Configs.Remote.WithFallback(Configs.CustomSerializers)
                    .WithFallback(ConfigurationFactory.FromResource<Persistence>("Akka.Persistence.persistence.conf")));
            _localActor = Sys.ActorOf(Props.Create(() => new LocalActor(Port(_remoteSystem))), "local");

            _serialization = Sys.Serialization;

            _remoteSystem.ActorOf(Props.Create(() => new RemoteActor()), "remote");
        }

        private int Port(ActorSystem system)
        {
            return Address(system).Port.Value;
        }

        private Address Address(ActorSystem system)
        {
            return ((ExtendedActorSystem) system).Provider.DefaultAddress;
        }

        protected override void AfterTermination()
        {
            _remoteSystem.Terminate().Wait(TimeSpan.FromSeconds(2));
            base.AfterTermination();
        }

        [Fact]
        public void MessageSerializer_should_custom_serialize_Persistent_messages_during_remoting()
        {
            // this also verifies serialization of Persistent.Sender,
            // because the RemoteActor will reply to the Persistent.Sender
            _localActor.Tell(new Persistent(new MyPayload("a"), sender: TestActor));
            ExpectMsg("p.a.");
        }

        [Fact]
        public void MessageSerializer_should_custom_serialize_AtomicWrite_messages_during_remoting()
        {
            var p1 = new Persistent(new MyPayload("a"), sender: TestActor);
            var p2 = new Persistent(new MyPayload("b"), sender: TestActor);
            _localActor.Tell(new AtomicWrite(ImmutableList.Create(new IPersistentRepresentation[] {p1, p2})));
            Within(5.Seconds(), () => { 
                ExpectMsg("p.a.");
                ExpectMsg("p.b.");
            });
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Persistence.Tests\Serialization\MessageSerializerRemotingSpec.cs(131,34): error CS0136: A local or parameter named 'p' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 8 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Akka.Actor;

namespace Akka.Persistence
{
    /// <summary>
    /// TBD
    /// </summary>
    public partial class Eventsourced
    {
        /// <summary>
        /// TBD
        /// </summary>
        public static readonly Func<Envelope, bool> UnstashFilterPredicate =
            envelope => !(envelope.Message is WriteMessageSuccess || envelope.Message is ReplayedMessage);

        private void StartRecovery(Recovery recovery)
        {
            ChangeState(RecoveryStarted(recovery.ReplayMax));
            LoadSnapshot(SnapshotterId, recovery.FromSnapshot, recovery.ToSequenceNr);
        }

        private void RequestRecoveryPermit()
        {
            Extension.RecoveryPermitter().Tell(Akka.Persistence.RequestRecoveryPermit.Instance, Self);
            ChangeState(WaitingRecoveryPermit(Recovery));
        }

        protected internal override bool AroundReceive(Receive receive, object message)
        {
            _currentState.StateReceive(receive, message);
            return true;
        }

        /// <inheritdoc/>
        public override void AroundPreStart()
        {
            if (PersistenceId == null)
                throw new ArgumentNullException($"PersistenceId is [null] for PersistentActor [{Self.Path}]");
                
            // Fail fast on missing plugins.
            var j = Journal;
            var s = SnapshotStore;
            RequestRecoveryPermit();
            base.AroundPreStart();
        }

        /// <inheritdoc/>
        public override void AroundPreRestart(Exception cause, object message)
        {
            try
            {
                _internalStash.UnstashAll();
                Stash.UnstashAll(UnstashFilterPredicate);
            }
            finally
            {
                object inner;
                if (message is WriteMessageSuccess) inner = (message as WriteMessageSuccess).Persistent;
                else if (message is LoopMessageSuccess) inner = (message as LoopMessageSuccess).Message;
                else if (message is ReplayedMessage) inner = (message as ReplayedMessage).Persistent;
                else inner = message;

                FlushJournalBatch();
                base.AroundPreRestart(cause, inner);
            }
        }

        /// <inheritdoc/>
        public override void AroundPostRestart(Exception reason, object message)
        {
            RequestRecoveryPermit();
            base.AroundPostRestart(reason, message);
        }

        /// <inheritdoc/>
        public override void AroundPostStop()
        {
            try
            {
                _internalStash.UnstashAll();
                Stash.UnstashAll(UnstashFilterPredicate);
            }
            finally
            {
                base.AroundPostStop();
            }
        }

        /// <inheritdoc/>
        protected override void Unhandled(object message)
        {
            if (message is RecoveryCompleted) return; // ignore
            if (message is SaveSnapshotFailure)
            {
                var m = (SaveSnapshotFailure) message;
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to SaveSnapshot given metadata [{0}] due to: [{1}: {2}]", m.Metadata, m.Cause, m.Cause.Message);
            }
            if (message is DeleteSnapshotFailure)
            {
                var m = (DeleteSnapshotFailure) message;
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to DeleteSnapshot given metadata [{0}] due to: [{1}: {2}]", m.Metadata, m.Cause, m.Cause.Message);
            }
            if (message is DeleteSnapshotsFailure)
            {
                var m = (DeleteSnapshotsFailure) message;
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to DeleteSnapshots given criteria [{0}] due to: [{1}: {2}]", m.Criteria, m.Cause, m.Cause.Message);
            }
            if (message is DeleteMessagesFailure)
            {
                var m = (DeleteMessagesFailure) message;
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to DeleteMessages ToSequenceNr [{0}] for PersistenceId [{1}] due to: [{2}: {3}]", m.ToSequenceNr, PersistenceId, m.Cause, m.Cause.Message);
            }
            base.Unhandled(message);
        }
    }
}

---- Transformed Tree ----
using System;
using Akka.Actor;

namespace Akka.Persistence
{
    /// <summary>
    /// TBD
    /// </summary>
    public partial class Eventsourced
    {
        /// <summary>
        /// TBD
        /// </summary>
        public static readonly Func<Envelope, bool> UnstashFilterPredicate =
            envelope => !(envelope.Message is WriteMessageSuccess || envelope.Message is ReplayedMessage);

        private void StartRecovery(Recovery recovery)
        {
            ChangeState(RecoveryStarted(recovery.ReplayMax));
            LoadSnapshot(SnapshotterId, recovery.FromSnapshot, recovery.ToSequenceNr);
        }

        private void RequestRecoveryPermit()
        {
            Extension.RecoveryPermitter().Tell(Akka.Persistence.RequestRecoveryPermit.Instance, Self);
            ChangeState(WaitingRecoveryPermit(Recovery));
        }

        protected internal override bool AroundReceive(Receive receive, object message)
        {
            _currentState.StateReceive(receive, message);
            return true;
        }

        /// <inheritdoc/>
        public override void AroundPreStart()
        {
            if (PersistenceId == null)
                throw new ArgumentNullException($"PersistenceId is [null] for PersistentActor [{Self.Path}]");
                
            // Fail fast on missing plugins.
            var j = Journal;
            var s = SnapshotStore;
            RequestRecoveryPermit();
            base.AroundPreStart();
        }

        /// <inheritdoc/>
        public override void AroundPreRestart(Exception cause, object message)
        {
            try
            {
                _internalStash.UnstashAll();
                Stash.UnstashAll(UnstashFilterPredicate);
            }
            finally
            {
                object inner;
                if (message is WriteMessageSuccess) inner = (message as WriteMessageSuccess).Persistent;
                else if (message is LoopMessageSuccess) inner = (message as LoopMessageSuccess).Message;
                else if (message is ReplayedMessage) inner = (message as ReplayedMessage).Persistent;
                else inner = message;

                FlushJournalBatch();
                base.AroundPreRestart(cause, inner);
            }
        }

        /// <inheritdoc/>
        public override void AroundPostRestart(Exception reason, object message)
        {
            RequestRecoveryPermit();
            base.AroundPostRestart(reason, message);
        }

        /// <inheritdoc/>
        public override void AroundPostStop()
        {
            try
            {
                _internalStash.UnstashAll();
                Stash.UnstashAll(UnstashFilterPredicate);
            }
            finally
            {
                base.AroundPostStop();
            }
        }

        /// <inheritdoc/>
        protected override void Unhandled(object message)
        {
            if (message is RecoveryCompleted) return; // ignore
            if (message is SaveSnapshotFailure m)
            {
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to SaveSnapshot given metadata [{0}] due to: [{1}: {2}]", m.Metadata, m.Cause, m.Cause.Message);
            }
            if (message is DeleteSnapshotFailure m)
            {
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to DeleteSnapshot given metadata [{0}] due to: [{1}: {2}]", m.Metadata, m.Cause, m.Cause.Message);
            }
            if (message is DeleteSnapshotsFailure m)
            {
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to DeleteSnapshots given criteria [{0}] due to: [{1}: {2}]", m.Criteria, m.Cause, m.Cause.Message);
            }
            if (message is DeleteMessagesFailure m)
            {
                if (Log.IsWarningEnabled)
                    Log.Warning("Failed to DeleteMessages ToSequenceNr [{0}] for PersistenceId [{1}] due to: [{2}: {3}]", m.ToSequenceNr, PersistenceId, m.Cause, m.Cause.Message);
            }
            base.Unhandled(message);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs(106,50): error CS0128: A local variable or function named 'm' is already defined in this scope,D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs(111,51): error CS0128: A local variable or function named 'm' is already defined in this scope,D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs(114,104): error CS1061: 'SaveSnapshotFailure' does not contain a definition for 'Criteria' and no accessible extension method 'Criteria' accepting a first argument of type 'SaveSnapshotFailure' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs(116,50): error CS0128: A local variable or function named 'm' is already defined in this scope,D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs(119,125): error CS1061: 'SaveSnapshotFailure' does not contain a definition for 'ToSequenceNr' and no accessible extension method 'ToSequenceNr' accepting a first argument of type 'SaveSnapshotFailure' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\src\core\Akka.Persistence\Eventsourced.Lifecycle.cs(109,101): error CS0165: Use of unassigned local variable 'm'
######################################################################


######################################################################
Nr: 9 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\core\Akka.Persistence\Journal\PersistencePluginProxy.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Akka.Actor;
using Akka.Configuration;
using Akka.Event;
using Akka.Util.Internal;

namespace Akka.Persistence.Journal
{
    /// <summary>
    /// TBD
    /// </summary>
    public class PersistencePluginProxy : ActorBase, IWithUnboundedStash
    {
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class TargetLocation
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="address">TBD</param>
            public TargetLocation(Address address)
            {
                Address = address;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public Address Address { get; private set; }
        }

        private sealed class InitTimeout
        {
            public static readonly InitTimeout Instance = new InitTimeout();
            private InitTimeout() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="address">TBD</param>
        public static void SetTargetLocation(ActorSystem system, Address address)
        {
            var persistence = Persistence.Instance.Apply(system);
            persistence.JournalFor(null).Tell(new TargetLocation(address));
            if (string.IsNullOrEmpty(system.Settings.Config.GetString("akka.persistence.snapshot-store.plugin", null)))
                persistence.SnapshotStoreFor(null).Tell(new TargetLocation(address));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        public static void Start(ActorSystem system)
        {
            var persistence = Persistence.Instance.Apply(system);
            persistence.JournalFor(null);
            if (string.IsNullOrEmpty(system.Settings.Config.GetString("akka.persistence.snapshot-store.plugin", null)))
                persistence.SnapshotStoreFor(null);
        }

        private interface IPluginType
        {
            string Qualifier { get; }
        }

        private class Journal : IPluginType
        {
            public string Qualifier => "journal";
        }

        private class SnapshotStore : IPluginType
        {
            public string Qualifier => "snapshot-store";
        }

        private readonly Config _config;
        private readonly IPluginType _pluginType;
        private readonly TimeSpan _initTimeout;
        private readonly string _targetPluginId;
        private readonly bool _startTarget;
        private readonly Address _selfAddress;
        private readonly ILoggingAdapter _log = Context.GetLogger();

        /// <summary>
        /// Initializes a new instance of the <see cref="PersistencePluginProxy"/> class.
        /// </summary>
        /// <param name="config">The configuration used to configure the proxy.</param>
        /// <exception cref="ArgumentException">
        /// This exception is thrown when configuration is undefined for the plugin
        /// or an unknown plugin type is defined.
        /// </exception>
        public PersistencePluginProxy(Config config)
        {
            _config = config;
            var pluginId = Self.Path.Name;
            if (pluginId.Equals("akka.persistence.journal.proxy"))
                _pluginType = new Journal();
            else if (pluginId.Equals("akka.persistence.snapshot-store.proxy"))
                _pluginType = new SnapshotStore();
            else
                throw new ArgumentException($"Unknown plugin type: {pluginId}.");
            _initTimeout = config.GetTimeSpan("init-timeout", null);
            var key = "target-" + _pluginType.Qualifier + "-plugin";
            _targetPluginId = config.GetString(key, null);
            if (string.IsNullOrEmpty(_targetPluginId))
                throw new ArgumentException($"{pluginId}.{key} must be defined.");
            _startTarget = config.GetBoolean("start-target-" + _pluginType.Qualifier, false);

            _selfAddress = ((ExtendedActorSystem)Context.System).Provider.DefaultAddress;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public IStash Stash { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_startTarget)
            {
                IActorRef target = null;
                if (_pluginType is Journal)
                {
                    if (_log.IsInfoEnabled)
                        _log.Info("Starting target journal [{0}]", _targetPluginId);
                    target = Persistence.Instance.Apply(Context.System).JournalFor(_targetPluginId);
                }
                else if (_pluginType is SnapshotStore)
                {
                    if (_log.IsInfoEnabled)
                        _log.Info("Starting target snapshot-store [{0}]", _targetPluginId);
                    target = Persistence.Instance.Apply(Context.System).SnapshotStoreFor(_targetPluginId);
                }
                Context.Become(Active(target, true));
            }
            else
            {
                var targetAddressKey = "target-" + _pluginType.Qualifier + "-address";
                var targetAddress = _config.GetString(targetAddressKey, null);
                if (!string.IsNullOrEmpty(targetAddress))
                {
                    try
                    {
                        if (_log.IsInfoEnabled)
                            _log.Info("Setting target {0} address to {1}", _pluginType.Qualifier, targetAddress);
                        SetTargetLocation(Context.System, Address.Parse(targetAddress));
                    }
                    catch (UriFormatException)
                    {
                        if (_log.IsWarningEnabled)
                            _log.Warning("Invalid URL provided for target {0} address: {1}", _pluginType.Qualifier,
                                targetAddress);
                    }
                }
                Context.System.Scheduler.ScheduleTellOnce(_initTimeout, Self, InitTimeout.Instance, Self);
            }
            base.PreStart();
        }

        private TimeoutException TimeoutException()
        {
            return
                new TimeoutException(
                    $"Target {_pluginType.Qualifier} not initialized. Use `PersistencePluginProxy.SetTargetLocation` or set `target-{_pluginType.Qualifier}-address`.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <returns>TBD</returns>
        protected override bool Receive(object message)
        {
            return Init(message);
        }

        private bool Init(object message)
        {
            if (message is TargetLocation)
            {
                Context.SetReceiveTimeout(TimeSpan.FromSeconds(1)); // for retries
                Context.Become(Identifying(((TargetLocation)message).Address));
            }
            else if (message is InitTimeout)
            {
                if (_log.IsInfoEnabled)
                    _log.Info(
                        "Initialization timed-out (after {0}s), use `PersistencePluginProxy.SetTargetLocation` or set `target-{1}-address`",
                        _initTimeout.TotalSeconds, _pluginType.Qualifier);
                Context.Become(InitTimedOut());
                Stash.UnstashAll(); // will trigger appropriate failures
            }
            else if (message is Terminated)
            {
            }
            else
                Stash.Stash();
            return true;
        }

        private void BecomeIdentifying(Address address)
        {
            SendIdentify(address);
            Context.SetReceiveTimeout(TimeSpan.FromSeconds(1)); // for retries
            Context.Become(Identifying(address));
        }

        private void SendIdentify(Address address)
        {
            var sel = Context.ActorSelection(string.Format("{0}/system/{1}", new RootActorPath(address), _targetPluginId));
            if (_log.IsInfoEnabled)
                _log.Info("Trying to identify target + {0} at {1}", _pluginType.Qualifier, sel);
            sel.Tell(new Identify(_targetPluginId));
        }

        private Receive Identifying(Address address)
        {
            return message =>
            {
                if (message is ActorIdentity)
                {
                    var ai = (ActorIdentity)message;
                    if (_targetPluginId.Equals(ai.MessageId))
                    {
                        var target = ai.Subject;
                        if (_log.IsInfoEnabled)
                            _log.Info("Found target {0} at [{1}]", _pluginType.Qualifier, address);
                        Context.SetReceiveTimeout(null);
                        Context.Watch(target);
                        Stash.UnstashAll();
                        Context.Become(Active(target, address.Equals(_selfAddress)));
                    }
                    else
                    {
                        // will retry after ReceiveTimeout
                    }
                }
                else if (message is Terminated)
                {
                }
                else if (message is ReceiveTimeout)
                    SendIdentify(address);
                else return Init(message);
                return true;
            };
        }

        private Receive Active(IActorRef targetJournal, bool targetAtThisNode)
        {
            return message =>
            {
                if (message is TargetLocation)
                {
                    var address = ((TargetLocation)message).Address;
                    if (targetAtThisNode && !address.Equals(_selfAddress))
                        BecomeIdentifying(address);
                }
                else if (message is Terminated)
                {
                    var t = (Terminated)message;
                    if (t.ActorRef.Equals(targetJournal))
                    {
                        Context.Unwatch(targetJournal);
                        Context.Become(InitTimedOut());
                    }
                }
                else if (message is InitTimeout)
                {
                }
                else
                    targetJournal.Forward(message);
                return true;
            };
        }

        private Receive InitTimedOut()
        {
            return message =>
            {
                if (message is IJournalRequest)
                {
                    // exhaustive match
                    if (message is WriteMessages w)
                    {
                        var atomicWriteCount = w.Messages.Count(m => m is AtomicWrite);
                        w.PersistentActor.Tell(new WriteMessagesFailed(TimeoutException(), atomicWriteCount));
                        foreach (var m in w.Messages)
                        {
                            if (m is AtomicWrite)
                            {
                                foreach (var p in (IEnumerable<IPersistentRepresentation>)m.Payload)
                                {
                                    w.PersistentActor.Tell(new WriteMessageFailure(p, TimeoutException(),
                                        w.ActorInstanceId));
                                }
                            }
                            else if (m is NonPersistentMessage)
                            {
                                w.PersistentActor.Tell(new LoopMessageSuccess(m.Payload, w.ActorInstanceId));
                            }
                        }
                    }
                    else if (message is ReplayMessages)
                    {
                        var r = (ReplayMessages)message;
                        r.PersistentActor.Tell(new ReplayMessagesFailure(TimeoutException()));
                    }
                    else if (message is DeleteMessagesTo)
                    {
                        var d = (DeleteMessagesTo)message;
                        d.PersistentActor.Tell(new DeleteMessagesFailure(TimeoutException(), d.ToSequenceNr));
                    }
                }
                else if (message is ISnapshotRequest)
                {
                    // exhaustive match
                    if (message is LoadSnapshot)
                    {
                        var l = (LoadSnapshot)message;
                        Sender.Tell(new LoadSnapshotFailed(TimeoutException()));
                    }
                    else if (message is SaveSnapshot)
                    {
                        var s = (SaveSnapshot)message;
                        Sender.Tell(new SaveSnapshotFailure(s.Metadata, TimeoutException()));
                    }
                    else if (message is DeleteSnapshot)
                    {
                        var d = (DeleteSnapshot)message;
                        Sender.Tell(new DeleteSnapshotFailure(d.Metadata, TimeoutException()));
                    }
                    else if (message is DeleteSnapshots)
                    {
                        var d = (DeleteSnapshots)message;
                        Sender.Tell(new DeleteSnapshotsFailure(d.Criteria, TimeoutException()));
                    }
                }
                else if (message is TargetLocation)
                {
                    BecomeIdentifying(((TargetLocation)message).Address);
                }
                else if (message is Terminated)
                {
                }
                else
                {
                    var exception = TimeoutException();
                    if (_log.IsErrorEnabled)
                        _log.Error(exception, "Failed PersistencePluginProxyRequest: {0}", exception.Message);
                }
                return true;
            };
        }
    }

    /// <summary>
    /// <see cref="PersistencePluginProxyExtension"/> is an <see cref="IExtension"/> that enables initialization
    /// of the <see cref="PersistencePluginProxy"/> via configuration, without requiring any code changes or the
    /// creation of any actors.
    /// </summary>
    public class PersistencePluginProxyExtension : ExtensionIdProvider<PersistencePluginProxyExtension>, IExtension
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        public PersistencePluginProxyExtension(ActorSystem system)
        {
            PersistencePluginProxy.Start(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override PersistencePluginProxyExtension CreateExtension(ExtendedActorSystem system)
        {
            return new PersistencePluginProxyExtension(system);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Akka.Actor;
using Akka.Configuration;
using Akka.Event;
using Akka.Util.Internal;

namespace Akka.Persistence.Journal
{
    /// <summary>
    /// TBD
    /// </summary>
    public class PersistencePluginProxy : ActorBase, IWithUnboundedStash
    {
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class TargetLocation
        {
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="address">TBD</param>
            public TargetLocation(Address address)
            {
                Address = address;
            }

            /// <summary>
            /// TBD
            /// </summary>
            public Address Address { get; private set; }
        }

        private sealed class InitTimeout
        {
            public static readonly InitTimeout Instance = new InitTimeout();
            private InitTimeout() { }
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="address">TBD</param>
        public static void SetTargetLocation(ActorSystem system, Address address)
        {
            var persistence = Persistence.Instance.Apply(system);
            persistence.JournalFor(null).Tell(new TargetLocation(address));
            if (string.IsNullOrEmpty(system.Settings.Config.GetString("akka.persistence.snapshot-store.plugin", null)))
                persistence.SnapshotStoreFor(null).Tell(new TargetLocation(address));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        public static void Start(ActorSystem system)
        {
            var persistence = Persistence.Instance.Apply(system);
            persistence.JournalFor(null);
            if (string.IsNullOrEmpty(system.Settings.Config.GetString("akka.persistence.snapshot-store.plugin", null)))
                persistence.SnapshotStoreFor(null);
        }

        private interface IPluginType
        {
            string Qualifier { get; }
        }

        private class Journal : IPluginType
        {
            public string Qualifier => "journal";
        }

        private class SnapshotStore : IPluginType
        {
            public string Qualifier => "snapshot-store";
        }

        private readonly Config _config;
        private readonly IPluginType _pluginType;
        private readonly TimeSpan _initTimeout;
        private readonly string _targetPluginId;
        private readonly bool _startTarget;
        private readonly Address _selfAddress;
        private readonly ILoggingAdapter _log = Context.GetLogger();

        /// <summary>
        /// Initializes a new instance of the <see cref="PersistencePluginProxy"/> class.
        /// </summary>
        /// <param name="config">The configuration used to configure the proxy.</param>
        /// <exception cref="ArgumentException">
        /// This exception is thrown when configuration is undefined for the plugin
        /// or an unknown plugin type is defined.
        /// </exception>
        public PersistencePluginProxy(Config config)
        {
            _config = config;
            var pluginId = Self.Path.Name;
            if (pluginId.Equals("akka.persistence.journal.proxy"))
                _pluginType = new Journal();
            else if (pluginId.Equals("akka.persistence.snapshot-store.proxy"))
                _pluginType = new SnapshotStore();
            else
                throw new ArgumentException($"Unknown plugin type: {pluginId}.");
            _initTimeout = config.GetTimeSpan("init-timeout", null);
            var key = "target-" + _pluginType.Qualifier + "-plugin";
            _targetPluginId = config.GetString(key, null);
            if (string.IsNullOrEmpty(_targetPluginId))
                throw new ArgumentException($"{pluginId}.{key} must be defined.");
            _startTarget = config.GetBoolean("start-target-" + _pluginType.Qualifier, false);

            _selfAddress = ((ExtendedActorSystem)Context.System).Provider.DefaultAddress;
        }

        /// <summary>
        /// TBD
        /// </summary>
        public IStash Stash { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PreStart()
        {
            if (_startTarget)
            {
                IActorRef target = null;
                if (_pluginType is Journal)
                {
                    if (_log.IsInfoEnabled)
                        _log.Info("Starting target journal [{0}]", _targetPluginId);
                    target = Persistence.Instance.Apply(Context.System).JournalFor(_targetPluginId);
                }
                else if (_pluginType is SnapshotStore)
                {
                    if (_log.IsInfoEnabled)
                        _log.Info("Starting target snapshot-store [{0}]", _targetPluginId);
                    target = Persistence.Instance.Apply(Context.System).SnapshotStoreFor(_targetPluginId);
                }
                Context.Become(Active(target, true));
            }
            else
            {
                var targetAddressKey = "target-" + _pluginType.Qualifier + "-address";
                var targetAddress = _config.GetString(targetAddressKey, null);
                if (!string.IsNullOrEmpty(targetAddress))
                {
                    try
                    {
                        if (_log.IsInfoEnabled)
                            _log.Info("Setting target {0} address to {1}", _pluginType.Qualifier, targetAddress);
                        SetTargetLocation(Context.System, Address.Parse(targetAddress));
                    }
                    catch (UriFormatException)
                    {
                        if (_log.IsWarningEnabled)
                            _log.Warning("Invalid URL provided for target {0} address: {1}", _pluginType.Qualifier,
                                targetAddress);
                    }
                }
                Context.System.Scheduler.ScheduleTellOnce(_initTimeout, Self, InitTimeout.Instance, Self);
            }
            base.PreStart();
        }

        private TimeoutException TimeoutException()
        {
            return
                new TimeoutException(
                    $"Target {_pluginType.Qualifier} not initialized. Use `PersistencePluginProxy.SetTargetLocation` or set `target-{_pluginType.Qualifier}-address`.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <returns>TBD</returns>
        protected override bool Receive(object message)
        {
            return Init(message);
        }

        private bool Init(object message)
        {
            if (message is TargetLocation targetLocation)
            {
                Context.SetReceiveTimeout(TimeSpan.FromSeconds(1)); // for retries
                Context.Become(Identifying(targetLocation.Address));
            }
            else if (message is InitTimeout)
            {
                if (_log.IsInfoEnabled)
                    _log.Info(
                        "Initialization timed-out (after {0}s), use `PersistencePluginProxy.SetTargetLocation` or set `target-{1}-address`",
                        _initTimeout.TotalSeconds, _pluginType.Qualifier);
                Context.Become(InitTimedOut());
                Stash.UnstashAll(); // will trigger appropriate failures
            }
            else if (message is Terminated)
            {
            }
            else
                Stash.Stash();
            return true;
        }

        private void BecomeIdentifying(Address address)
        {
            SendIdentify(address);
            Context.SetReceiveTimeout(TimeSpan.FromSeconds(1)); // for retries
            Context.Become(Identifying(address));
        }

        private void SendIdentify(Address address)
        {
            var sel = Context.ActorSelection(string.Format("{0}/system/{1}", new RootActorPath(address), _targetPluginId));
            if (_log.IsInfoEnabled)
                _log.Info("Trying to identify target + {0} at {1}", _pluginType.Qualifier, sel);
            sel.Tell(new Identify(_targetPluginId));
        }

        private Receive Identifying(Address address)
        {
            return message =>
            {
                if (message is ActorIdentity ai)
                {
                    if (_targetPluginId.Equals(ai.MessageId))
                    {
                        var target = ai.Subject;
                        if (_log.IsInfoEnabled)
                            _log.Info("Found target {0} at [{1}]", _pluginType.Qualifier, address);
                        Context.SetReceiveTimeout(null);
                        Context.Watch(target);
                        Stash.UnstashAll();
                        Context.Become(Active(target, address.Equals(_selfAddress)));
                    }
                    else
                    {
                        // will retry after ReceiveTimeout
                    }
                }
                else if (message is Terminated)
                {
                }
                else if (message is ReceiveTimeout)
                    SendIdentify(address);
                else return Init(message);
                return true;
            };
        }

        private Receive Active(IActorRef targetJournal, bool targetAtThisNode)
        {
            return message =>
            {
                if (message is TargetLocation targetLocation)
                {
                    var address = targetLocation.Address;
                    if (targetAtThisNode && !address.Equals(_selfAddress))
                        BecomeIdentifying(address);
                }
                else if (message is Terminated t)
                {
                    if (t.ActorRef.Equals(targetJournal))
                    {
                        Context.Unwatch(targetJournal);
                        Context.Become(InitTimedOut());
                    }
                }
                else if (message is InitTimeout)
                {
                }
                else
                    targetJournal.Forward(message);
                return true;
            };
        }

        private Receive InitTimedOut()
        {
            return message =>
            {
                if (message is IJournalRequest)
                {
                    // exhaustive match
                    if (message is WriteMessages w)
                    {
                        var atomicWriteCount = w.Messages.Count(m => m is AtomicWrite);
                        w.PersistentActor.Tell(new WriteMessagesFailed(TimeoutException(), atomicWriteCount));
                        foreach (var m in w.Messages)
                        {
                            if (m is AtomicWrite)
                            {
                                foreach (var p in (IEnumerable<IPersistentRepresentation>)m.Payload)
                                {
                                    w.PersistentActor.Tell(new WriteMessageFailure(p, TimeoutException(),
                                        w.ActorInstanceId));
                                }
                            }
                            else if (m is NonPersistentMessage)
                            {
                                w.PersistentActor.Tell(new LoopMessageSuccess(m.Payload, w.ActorInstanceId));
                            }
                        }
                    }
                    else if (message is ReplayMessages r)
                    {
                        r.PersistentActor.Tell(new ReplayMessagesFailure(TimeoutException()));
                    }
                    else if (message is DeleteMessagesTo d)
                    {
                        d.PersistentActor.Tell(new DeleteMessagesFailure(TimeoutException(), d.ToSequenceNr));
                    }
                }
                else if (message is ISnapshotRequest)
                {
                    // exhaustive match
                    if (message is LoadSnapshot l)
                    {
                        Sender.Tell(new LoadSnapshotFailed(TimeoutException()));
                    }
                    else if (message is SaveSnapshot s)
                    {
                        Sender.Tell(new SaveSnapshotFailure(s.Metadata, TimeoutException()));
                    }
                    else if (message is DeleteSnapshot d)
                    {
                        Sender.Tell(new DeleteSnapshotFailure(d.Metadata, TimeoutException()));
                    }
                    else if (message is DeleteSnapshots d)
                    {
                        Sender.Tell(new DeleteSnapshotsFailure(d.Criteria, TimeoutException()));
                    }
                }
                else if (message is TargetLocation targetLocation)
                {
                    BecomeIdentifying(targetLocation.Address);
                }
                else if (message is Terminated)
                {
                }
                else
                {
                    var exception = TimeoutException();
                    if (_log.IsErrorEnabled)
                        _log.Error(exception, "Failed PersistencePluginProxyRequest: {0}", exception.Message);
                }
                return true;
            };
        }
    }

    /// <summary>
    /// <see cref="PersistencePluginProxyExtension"/> is an <see cref="IExtension"/> that enables initialization
    /// of the <see cref="PersistencePluginProxy"/> via configuration, without requiring any code changes or the
    /// creation of any actors.
    /// </summary>
    public class PersistencePluginProxyExtension : ExtensionIdProvider<PersistencePluginProxyExtension>, IExtension
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        public PersistencePluginProxyExtension(ActorSystem system)
        {
            PersistencePluginProxy.Start(system);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override PersistencePluginProxyExtension CreateExtension(ExtendedActorSystem system)
        {
            return new PersistencePluginProxyExtension(system);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\core\Akka.Persistence\Journal\PersistencePluginProxy.cs(14,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Persistence\Journal\PersistencePluginProxy.cs(341,57): error CS0136: A local or parameter named 'd' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\core\Akka.Persistence\Journal\PersistencePluginProxy.cs(14,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 10 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using Akka.Actor;
using Akka.Annotations;
using Akka.Dispatch;
using Akka.Event;
using Akka.Pattern;
using Akka.Streams.Implementation.Fusing;
using Akka.Util;
using Akka.Util.Internal;

namespace Akka.Streams.Implementation
{
    /// <summary>
    /// ExtendedActorMaterializer used by subtypes which materializer using GraphInterpreterShell
    /// </summary>
    public abstract class ExtendedActorMaterializer : ActorMaterializer
    {
        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <returns>TBD</returns>
        [InternalApi]
        public abstract TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser);

        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <returns>TBD</returns>
        [InternalApi]
        public abstract TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser, Attributes initialAttributes);

        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <param name="context">TBD</param>
        /// <param name="props">TBD</param>
        /// <returns>TBD</returns>
        [InternalApi]
        public override IActorRef ActorOf(MaterializationContext context, Props props)
        {
            var dispatcher = props.Deploy.Dispatcher == Deploy.NoDispatcherGiven
                ? EffectiveSettings(context.EffectiveAttributes).Dispatcher
                : props.Dispatcher;

            return ActorOf(props, context.StageName, dispatcher);
        }

        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <param name="props">TBD</param>
        /// <param name="name">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <exception cref="IllegalStateException">TBD</exception>
        /// <returns>TBD</returns>
        [InternalApi]
        protected IActorRef ActorOf(Props props, string name, string dispatcher)
        {
            var localActorRef = Supervisor as LocalActorRef;
            if (localActorRef != null)
                return ((ActorCell) localActorRef.Underlying).AttachChild(props.WithDispatcher(dispatcher),
                    isSystemService: false, name: name);


            var repointableActorRef = Supervisor as RepointableActorRef;
            if (repointableActorRef != null)
            {
                if (repointableActorRef.IsStarted)
                    return ((ActorCell)repointableActorRef.Underlying).AttachChild(props.WithDispatcher(dispatcher), isSystemService: false, name: name);

                var timeout = repointableActorRef.Underlying.System.Settings.CreationTimeout;
                var f = repointableActorRef.Ask<IActorRef>(new StreamSupervisor.Materialize(props.WithDispatcher(dispatcher), name), timeout);
                return f.Result;
            }

            throw new IllegalStateException($"Stream supervisor must be a local actor, was [{Supervisor.GetType()}]");
        }
    }

    /// <summary>
    /// TBD
    /// </summary>
    public sealed class ActorMaterializerImpl : ExtendedActorMaterializer
    {
        #region Materializer session implementation

        private sealed class ActorMaterializerSession : MaterializerSession
        {
            private static readonly MethodInfo ProcessorForMethod =
                typeof(ActorMaterializerSession).GetMethod("ProcessorFor",
                    BindingFlags.NonPublic | BindingFlags.Instance);
            private readonly ActorMaterializerImpl _materializer;
            private readonly Func<GraphInterpreterShell, IActorRef> _subflowFuser;
            private readonly string _flowName;
            private int _nextId;

            public ActorMaterializerSession(ActorMaterializerImpl materializer, IModule topLevel, Attributes initialAttributes, Func<GraphInterpreterShell, IActorRef> subflowFuser)
                : base(topLevel, initialAttributes)
            {
                _materializer = materializer;
                _subflowFuser = subflowFuser;
                _flowName = _materializer.CreateFlowName();
            }

            protected override object MaterializeAtomic(AtomicModule atomic, Attributes effectiveAttributes,
                IDictionary<IModule, object> materializedValues)
            {
                if(IsDebug)
                    Console.WriteLine($"materializing {atomic}");

                if (atomic is ISinkModule)
                {
                    var sink = (ISinkModule) atomic;
                    object materialized;
                    var subscriber = sink.Create(CreateMaterializationContext(effectiveAttributes), out materialized);
                    AssignPort(sink.Shape.Inlets.First(), subscriber);
                    materializedValues.Add(atomic, materialized);
                }
                else if (atomic is ISourceModule)
                {
                    var source = (ISourceModule) atomic;
                    object materialized;
                    var publisher = source.Create(CreateMaterializationContext(effectiveAttributes), out materialized);
                    AssignPort(source.Shape.Outlets.First(), publisher);
                    materializedValues.Add(atomic, materialized);
                }
                else if (atomic is IProcessorModule)
                {
                    var stage = atomic as IProcessorModule;
                    var t = stage.CreateProcessor();
                    var processor = t.Item1;
                    var materialized = t.Item2;

                    AssignPort(stage.In, UntypedSubscriber.FromTyped(processor));
                    AssignPort(stage.Out, UntypedPublisher.FromTyped(processor));
                    materializedValues.Add(atomic, materialized);
                }
                //else if (atomic is TlsModule)
                //{
                //})
                else if (atomic is GraphModule)
                {
                    var graph = (GraphModule) atomic;
                    MaterializeGraph(graph, effectiveAttributes, materializedValues);
                }
                else if (atomic is GraphStageModule)
                {
                    var stage = (GraphStageModule) atomic;
                    var graph =
                        new GraphModule(
                            GraphAssembly.Create(stage.Shape.Inlets, stage.Shape.Outlets, new[] {stage.Stage}),
                            stage.Shape, stage.Attributes, new IModule[] {stage});
                    MaterializeGraph(graph, effectiveAttributes, materializedValues);
                }

                return NotUsed.Instance;
            }

            private string StageName(Attributes attr) => $"{_flowName}-{_nextId++}-{attr.GetNameOrDefault()}";

            private MaterializationContext CreateMaterializationContext(Attributes effectiveAttributes)
                => new MaterializationContext(_materializer, effectiveAttributes, StageName(effectiveAttributes));

            private void MaterializeGraph(GraphModule graph, Attributes effectiveAttributes, IDictionary<IModule, object> materializedValues)
            {
                var calculatedSettings = _materializer.EffectiveSettings(effectiveAttributes);
                var t = graph.Assembly.Materialize(effectiveAttributes, graph.MaterializedValueIds, materializedValues, RegisterSource);
                var connections = t.Item1;
                var logics = t.Item2;

                var shell = new GraphInterpreterShell(graph.Assembly, connections, logics, graph.Shape, calculatedSettings, _materializer);
                var impl = _subflowFuser != null && !effectiveAttributes.Contains(Attributes.AsyncBoundary.Instance)
                    ? _subflowFuser(shell)
                    : _materializer.ActorOf(ActorGraphInterpreter.Props(shell), StageName(effectiveAttributes), calculatedSettings.Dispatcher);

                var i = 0;
                var inletsEnumerator = graph.Shape.Inlets.GetEnumerator();
                while (inletsEnumerator.MoveNext())
                {
                    var inlet = inletsEnumerator.Current;
                    var elementType = inlet.GetType().GetGenericArguments().First();
                    var subscriber = typeof(ActorGraphInterpreter.BoundarySubscriber<>).Instantiate(elementType, impl, shell, i);
                    AssignPort(inlet, UntypedSubscriber.FromTyped(subscriber));
                    i++;
                }

                i = 0;
                var outletsEnumerator = graph.Shape.Outlets.GetEnumerator();
                while (outletsEnumerator.MoveNext())
                {
                    var outlet = outletsEnumerator.Current;
                    var elementType = outlet.GetType().GetGenericArguments().First();
                    var publisher = typeof(ActorGraphInterpreter.BoundaryPublisher<>).Instantiate(elementType, impl, shell, i);
                    var message = new ActorGraphInterpreter.ExposedPublisher(shell, i, (IActorPublisher)publisher);
                    impl.Tell(message);
                    AssignPort(outletsEnumerator.Current, (IUntypedPublisher) publisher);
                    i++;
                }
            }
        }

        #endregion

        private readonly ActorSystem _system;
        private readonly ActorMaterializerSettings _settings;
        private readonly Dispatchers _dispatchers;
        private readonly IActorRef _supervisor;
        private readonly AtomicBoolean _haveShutDown;
        private readonly EnumerableActorName _flowNames;
        private ILoggingAdapter _logger;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="dispatchers">TBD</param>
        /// <param name="supervisor">TBD</param>
        /// <param name="haveShutDown">TBD</param>
        /// <param name="flowNames">TBD</param>
        /// <returns>TBD</returns>
        public ActorMaterializerImpl(ActorSystem system, ActorMaterializerSettings settings, Dispatchers dispatchers, IActorRef supervisor, AtomicBoolean haveShutDown, EnumerableActorName flowNames)
        {
            _system = system;
            _settings = settings;
            _dispatchers = dispatchers;
            _supervisor = supervisor;
            _haveShutDown = haveShutDown;
            _flowNames = flowNames;

            _executionContext = new Lazy<MessageDispatcher>(() => _dispatchers.Lookup(_settings.Dispatcher == Deploy.NoDispatcherGiven
                ? Dispatchers.DefaultDispatcherId
                : _settings.Dispatcher));

            if (_settings.IsFuzzingMode && !_system.Settings.Config.HasPath("akka.stream.secret-test-fuzzing-warning-disable"))
                Logger.Warning("Fuzzing mode is enabled on this system. If you see this warning on your production system then set 'akka.materializer.debug.fuzzing-mode' to off.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        public override bool IsShutdown => _haveShutDown.Value;

        /// <summary>
        /// TBD
        /// </summary>
        public override ActorMaterializerSettings Settings => _settings;

        /// <summary>
        /// TBD
        /// </summary>
        public override ActorSystem System => _system;

        /// <summary>
        /// INTERNAL API
        /// </summary>
        [InternalApi]
        public override IActorRef Supervisor => _supervisor;

        /// <summary>
        /// INTERNAL API
        /// </summary>
        [InternalApi]
        public override ILoggingAdapter Logger => _logger ?? (_logger = GetLogger());

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="name">TBD</param>
        /// <returns>TBD</returns>
        public override IMaterializer WithNamePrefix(string name)
            => new ActorMaterializerImpl(_system, _settings, _dispatchers, _supervisor, _haveShutDown, _flowNames.Copy(name));

        private string CreateFlowName() => _flowNames.Next();

        private Attributes DefaultInitialAttributes =>
            Attributes.CreateInputBuffer(_settings.InitialInputBufferSize, _settings.MaxInputBufferSize)
                .And(ActorAttributes.CreateDispatcher(_settings.Dispatcher))
                .And(ActorAttributes.CreateSupervisionStrategy(_settings.SupervisionDecider));

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="attributes">TBD</param>
        /// <returns>TBD</returns>
        public override ActorMaterializerSettings EffectiveSettings(Attributes attributes)
        {
            return attributes.AttributeList.Aggregate(Settings, (settings, attribute) =>
            {
                var buffer = attribute as Attributes.InputBuffer;
                if (buffer != null)
                    return settings.WithInputBuffer(buffer.Initial, buffer.Max);

                var dispatcher = attribute as ActorAttributes.Dispatcher;
                if (dispatcher != null)
                    return settings.WithDispatcher(dispatcher.Name);
                
                var strategy = attribute as ActorAttributes.SupervisionStrategy;
                if (strategy != null)
                    return settings.WithSupervisionStrategy(strategy.Decider);

                return settings;
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="delay">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public override ICancelable ScheduleOnce(TimeSpan delay, Action action)
            => _system.Scheduler.Advanced.ScheduleOnceCancelable(delay, action);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="initialDelay">TBD</param>
        /// <param name="interval">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public override ICancelable ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action)
            => _system.Scheduler.Advanced.ScheduleRepeatedlyCancelable(initialDelay, interval, action);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable) => Materialize(runnable, null,
            DefaultInitialAttributes);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser) 
            => Materialize(runnable, subFlowFuser, DefaultInitialAttributes);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Attributes initialAttributes) =>
            Materialize(runnable, null, initialAttributes);
        
        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <exception cref="IllegalStateException">TBD</exception>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser, Attributes initialAttributes)
        {
            var runnableGraph = _settings.IsAutoFusing
                ? Fusing.Fusing.Aggressive(runnable)
                : runnable;

            if (_haveShutDown.Value)
                throw new IllegalStateException("Attempted to call Materialize() after the ActorMaterializer has been shut down.");

            if (StreamLayout.IsDebug)
                StreamLayout.Validate(runnableGraph.Module);

            var session = new ActorMaterializerSession(this, runnableGraph.Module, initialAttributes, subFlowFuser);

            var matVal = session.Materialize();
            return (TMat) matVal;
        }

        /// <summary>
        /// Creates a new logging adapter.
        /// </summary>
        /// <param name="logSource">The source that produces the log events.</param>
        /// <returns>The newly created logging adapter.</returns>
        public override ILoggingAdapter MakeLogger(object logSource) => Logging.GetLogger(System, logSource);

        /// <summary>
        /// TBD
        /// </summary>
        public override MessageDispatcher ExecutionContext => _executionContext.Value;

        private readonly Lazy<MessageDispatcher> _executionContext;

        /// <summary>
        /// TBD
        /// </summary>
        public override void Shutdown()
        {
            if (_haveShutDown.CompareAndSet(false, true))
                Supervisor.Tell(PoisonPill.Instance);
        }

        private ILoggingAdapter GetLogger() => _system.Log;
    }

    /// <summary>
    /// TBD
    /// </summary>
    public class SubFusingActorMaterializerImpl : IMaterializer
    {
        private readonly ExtendedActorMaterializer _delegateMaterializer;
        private readonly Func<GraphInterpreterShell, IActorRef> _registerShell;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="delegateMaterializer">TBD</param>
        /// <param name="registerShell">TBD</param>
        public SubFusingActorMaterializerImpl(ExtendedActorMaterializer delegateMaterializer, Func<GraphInterpreterShell, IActorRef> registerShell)
        {
            _delegateMaterializer = delegateMaterializer;
            _registerShell = registerShell;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="namePrefix">TBD</param>
        /// <returns>TBD</returns>
        public IMaterializer WithNamePrefix(string namePrefix)
            => new SubFusingActorMaterializerImpl((ActorMaterializerImpl) _delegateMaterializer.WithNamePrefix(namePrefix), _registerShell);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <returns>TBD</returns>
        public TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable)
            => _delegateMaterializer.Materialize(runnable, _registerShell);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <returns>TBD</returns>
        public TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Attributes initialAttributes) =>
            _delegateMaterializer.Materialize(runnable, _registerShell, initialAttributes);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="delay">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public ICancelable ScheduleOnce(TimeSpan delay, Action action)
            => _delegateMaterializer.ScheduleOnce(delay, action);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="initialDelay">TBD</param>
        /// <param name="interval">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public ICancelable ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action)
            => _delegateMaterializer.ScheduleRepeatedly(initialDelay, interval, action);

        /// <summary>
        /// TBD
        /// </summary>
        public MessageDispatcher ExecutionContext => _delegateMaterializer.ExecutionContext;
    }

    /// <summary>
    /// TBD
    /// </summary>
    public class FlowNameCounter : ExtensionIdProvider<FlowNameCounter>, IExtension
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public static FlowNameCounter Instance(ActorSystem system)
            => system.WithExtension<FlowNameCounter, FlowNameCounter>();

        /// <summary>
        /// TBD
        /// </summary>
        public readonly AtomicCounterLong Counter = new AtomicCounterLong(0);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override FlowNameCounter CreateExtension(ExtendedActorSystem system) => new FlowNameCounter();
    }

    /// <summary>
    /// TBD
    /// </summary>
    public class StreamSupervisor : ActorBase
    {
        #region Messages

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Materialize : INoSerializationVerificationNeeded, IDeadLetterSuppression
        {
            /// <summary>
            /// TBD
            /// </summary>
            public readonly Props Props;

            /// <summary>
            /// TBD
            /// </summary>
            public readonly string Name;

            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="props">TBD</param>
            /// <param name="name">TBD</param>
            public Materialize(Props props, string name)
            {
                Props = props;
                Name = name;
            }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class GetChildren
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly GetChildren Instance = new GetChildren();
            private GetChildren() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StopChildren
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly StopChildren Instance = new StopChildren();
            private StopChildren() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StoppedChildren
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly StoppedChildren Instance = new StoppedChildren();
            private StoppedChildren() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class PrintDebugDump
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly PrintDebugDump Instance = new PrintDebugDump();
            private PrintDebugDump() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Children
        {
            /// <summary>
            /// TBD
            /// </summary>
            public readonly IImmutableSet<IActorRef> Refs;
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="refs">TBD</param>
            public Children(IImmutableSet<IActorRef> refs)
            {
                Refs = refs;
            }
        }

        #endregion

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="settings">TBD</param>
        /// <param name="haveShutdown">TBD</param>
        /// <returns>TBD</returns>
        public static Props Props(ActorMaterializerSettings settings, AtomicBoolean haveShutdown)
            => Actor.Props.Create(() => new StreamSupervisor(settings, haveShutdown)).WithDeploy(Deploy.Local);

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public static string NextName() => ActorName.Next();

        private static readonly EnumerableActorName ActorName = new EnumerableActorNameImpl("StreamSupervisor", new AtomicCounterLong(0L));

        /// <summary>
        /// TBD
        /// </summary>
        public readonly ActorMaterializerSettings Settings;
        /// <summary>
        /// TBD
        /// </summary>
        public readonly AtomicBoolean HaveShutdown;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="settings">TBD</param>
        /// <param name="haveShutdown">TBD</param>
        public StreamSupervisor(ActorMaterializerSettings settings, AtomicBoolean haveShutdown)
        {
            Settings = settings;
            HaveShutdown = haveShutdown;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy() => Actor.SupervisorStrategy.StoppingStrategy;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <returns>TBD</returns>
        protected override bool Receive(object message)
        {
            if (message is Materialize)
            {
                var materialize = (Materialize) message;
                Sender.Tell(Context.ActorOf(materialize.Props, materialize.Name));
            }
            else if (message is GetChildren)
                Sender.Tell(new Children(Context.GetChildren().ToImmutableHashSet()));
            else if (message is StopChildren)
            {
                foreach (var child in Context.GetChildren())
                    Context.Stop(child);

                Sender.Tell(StoppedChildren.Instance);
            }
            else
                return false;
            return true;
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop() => HaveShutdown.Value = true;
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using Akka.Actor;
using Akka.Annotations;
using Akka.Dispatch;
using Akka.Event;
using Akka.Pattern;
using Akka.Streams.Implementation.Fusing;
using Akka.Util;
using Akka.Util.Internal;

namespace Akka.Streams.Implementation
{
    /// <summary>
    /// ExtendedActorMaterializer used by subtypes which materializer using GraphInterpreterShell
    /// </summary>
    public abstract class ExtendedActorMaterializer : ActorMaterializer
    {
        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <returns>TBD</returns>
        [InternalApi]
        public abstract TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser);

        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <returns>TBD</returns>
        [InternalApi]
        public abstract TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser, Attributes initialAttributes);

        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <param name="context">TBD</param>
        /// <param name="props">TBD</param>
        /// <returns>TBD</returns>
        [InternalApi]
        public override IActorRef ActorOf(MaterializationContext context, Props props)
        {
            var dispatcher = props.Deploy.Dispatcher == Deploy.NoDispatcherGiven
                ? EffectiveSettings(context.EffectiveAttributes).Dispatcher
                : props.Dispatcher;

            return ActorOf(props, context.StageName, dispatcher);
        }

        /// <summary>
        /// INTERNAL API
        /// </summary>
        /// <param name="props">TBD</param>
        /// <param name="name">TBD</param>
        /// <param name="dispatcher">TBD</param>
        /// <exception cref="IllegalStateException">TBD</exception>
        /// <returns>TBD</returns>
        [InternalApi]
        protected IActorRef ActorOf(Props props, string name, string dispatcher)
        {
            var localActorRef = Supervisor as LocalActorRef;
            if (localActorRef != null)
                return ((ActorCell) localActorRef.Underlying).AttachChild(props.WithDispatcher(dispatcher),
                    isSystemService: false, name: name);


            var repointableActorRef = Supervisor as RepointableActorRef;
            if (repointableActorRef != null)
            {
                if (repointableActorRef.IsStarted)
                    return ((ActorCell)repointableActorRef.Underlying).AttachChild(props.WithDispatcher(dispatcher), isSystemService: false, name: name);

                var timeout = repointableActorRef.Underlying.System.Settings.CreationTimeout;
                var f = repointableActorRef.Ask<IActorRef>(new StreamSupervisor.Materialize(props.WithDispatcher(dispatcher), name), timeout);
                return f.Result;
            }

            throw new IllegalStateException($"Stream supervisor must be a local actor, was [{Supervisor.GetType()}]");
        }
    }

    /// <summary>
    /// TBD
    /// </summary>
    public sealed class ActorMaterializerImpl : ExtendedActorMaterializer
    {
        #region Materializer session implementation

        private sealed class ActorMaterializerSession : MaterializerSession
        {
            private static readonly MethodInfo ProcessorForMethod =
                typeof(ActorMaterializerSession).GetMethod("ProcessorFor",
                    BindingFlags.NonPublic | BindingFlags.Instance);
            private readonly ActorMaterializerImpl _materializer;
            private readonly Func<GraphInterpreterShell, IActorRef> _subflowFuser;
            private readonly string _flowName;
            private int _nextId;

            public ActorMaterializerSession(ActorMaterializerImpl materializer, IModule topLevel, Attributes initialAttributes, Func<GraphInterpreterShell, IActorRef> subflowFuser)
                : base(topLevel, initialAttributes)
            {
                _materializer = materializer;
                _subflowFuser = subflowFuser;
                _flowName = _materializer.CreateFlowName();
            }

            protected override object MaterializeAtomic(AtomicModule atomic, Attributes effectiveAttributes,
                IDictionary<IModule, object> materializedValues)
            {
                if(IsDebug)
                    Console.WriteLine($"materializing {atomic}");

                if (atomic is ISinkModule sink)
                {
                    object materialized;
                    var subscriber = sink.Create(CreateMaterializationContext(effectiveAttributes), out materialized);
                    AssignPort(sink.Shape.Inlets.First(), subscriber);
                    materializedValues.Add(atomic, materialized);
                }
                else if (atomic is ISourceModule source)
                {
                    object materialized;
                    var publisher = source.Create(CreateMaterializationContext(effectiveAttributes), out materialized);
                    AssignPort(source.Shape.Outlets.First(), publisher);
                    materializedValues.Add(atomic, materialized);
                }
                else if (atomic is IProcessorModule)
                {
                    var stage = atomic as IProcessorModule;
                    var t = stage.CreateProcessor();
                    var processor = t.Item1;
                    var materialized = t.Item2;

                    AssignPort(stage.In, UntypedSubscriber.FromTyped(processor));
                    AssignPort(stage.Out, UntypedPublisher.FromTyped(processor));
                    materializedValues.Add(atomic, materialized);
                }
                //else if (atomic is TlsModule)
                //{
                //})
                else if (atomic is GraphModule graph)
                {
                    MaterializeGraph(graph, effectiveAttributes, materializedValues);
                }
                else if (atomic is GraphStageModule stage)
                {
                    var graph =
                        new GraphModule(
                            GraphAssembly.Create(stage.Shape.Inlets, stage.Shape.Outlets, new[] {stage.Stage}),
                            stage.Shape, stage.Attributes, new IModule[] {stage});
                    MaterializeGraph(graph, effectiveAttributes, materializedValues);
                }

                return NotUsed.Instance;
            }

            private string StageName(Attributes attr) => $"{_flowName}-{_nextId++}-{attr.GetNameOrDefault()}";

            private MaterializationContext CreateMaterializationContext(Attributes effectiveAttributes)
                => new MaterializationContext(_materializer, effectiveAttributes, StageName(effectiveAttributes));

            private void MaterializeGraph(GraphModule graph, Attributes effectiveAttributes, IDictionary<IModule, object> materializedValues)
            {
                var calculatedSettings = _materializer.EffectiveSettings(effectiveAttributes);
                var t = graph.Assembly.Materialize(effectiveAttributes, graph.MaterializedValueIds, materializedValues, RegisterSource);
                var connections = t.Item1;
                var logics = t.Item2;

                var shell = new GraphInterpreterShell(graph.Assembly, connections, logics, graph.Shape, calculatedSettings, _materializer);
                var impl = _subflowFuser != null && !effectiveAttributes.Contains(Attributes.AsyncBoundary.Instance)
                    ? _subflowFuser(shell)
                    : _materializer.ActorOf(ActorGraphInterpreter.Props(shell), StageName(effectiveAttributes), calculatedSettings.Dispatcher);

                var i = 0;
                var inletsEnumerator = graph.Shape.Inlets.GetEnumerator();
                while (inletsEnumerator.MoveNext())
                {
                    var inlet = inletsEnumerator.Current;
                    var elementType = inlet.GetType().GetGenericArguments().First();
                    var subscriber = typeof(ActorGraphInterpreter.BoundarySubscriber<>).Instantiate(elementType, impl, shell, i);
                    AssignPort(inlet, UntypedSubscriber.FromTyped(subscriber));
                    i++;
                }

                i = 0;
                var outletsEnumerator = graph.Shape.Outlets.GetEnumerator();
                while (outletsEnumerator.MoveNext())
                {
                    var outlet = outletsEnumerator.Current;
                    var elementType = outlet.GetType().GetGenericArguments().First();
                    var publisher = typeof(ActorGraphInterpreter.BoundaryPublisher<>).Instantiate(elementType, impl, shell, i);
                    var message = new ActorGraphInterpreter.ExposedPublisher(shell, i, (IActorPublisher)publisher);
                    impl.Tell(message);
                    AssignPort(outletsEnumerator.Current, (IUntypedPublisher) publisher);
                    i++;
                }
            }
        }

        #endregion

        private readonly ActorSystem _system;
        private readonly ActorMaterializerSettings _settings;
        private readonly Dispatchers _dispatchers;
        private readonly IActorRef _supervisor;
        private readonly AtomicBoolean _haveShutDown;
        private readonly EnumerableActorName _flowNames;
        private ILoggingAdapter _logger;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <param name="settings">TBD</param>
        /// <param name="dispatchers">TBD</param>
        /// <param name="supervisor">TBD</param>
        /// <param name="haveShutDown">TBD</param>
        /// <param name="flowNames">TBD</param>
        /// <returns>TBD</returns>
        public ActorMaterializerImpl(ActorSystem system, ActorMaterializerSettings settings, Dispatchers dispatchers, IActorRef supervisor, AtomicBoolean haveShutDown, EnumerableActorName flowNames)
        {
            _system = system;
            _settings = settings;
            _dispatchers = dispatchers;
            _supervisor = supervisor;
            _haveShutDown = haveShutDown;
            _flowNames = flowNames;

            _executionContext = new Lazy<MessageDispatcher>(() => _dispatchers.Lookup(_settings.Dispatcher == Deploy.NoDispatcherGiven
                ? Dispatchers.DefaultDispatcherId
                : _settings.Dispatcher));

            if (_settings.IsFuzzingMode && !_system.Settings.Config.HasPath("akka.stream.secret-test-fuzzing-warning-disable"))
                Logger.Warning("Fuzzing mode is enabled on this system. If you see this warning on your production system then set 'akka.materializer.debug.fuzzing-mode' to off.");
        }

        /// <summary>
        /// TBD
        /// </summary>
        public override bool IsShutdown => _haveShutDown.Value;

        /// <summary>
        /// TBD
        /// </summary>
        public override ActorMaterializerSettings Settings => _settings;

        /// <summary>
        /// TBD
        /// </summary>
        public override ActorSystem System => _system;

        /// <summary>
        /// INTERNAL API
        /// </summary>
        [InternalApi]
        public override IActorRef Supervisor => _supervisor;

        /// <summary>
        /// INTERNAL API
        /// </summary>
        [InternalApi]
        public override ILoggingAdapter Logger => _logger ?? (_logger = GetLogger());

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="name">TBD</param>
        /// <returns>TBD</returns>
        public override IMaterializer WithNamePrefix(string name)
            => new ActorMaterializerImpl(_system, _settings, _dispatchers, _supervisor, _haveShutDown, _flowNames.Copy(name));

        private string CreateFlowName() => _flowNames.Next();

        private Attributes DefaultInitialAttributes =>
            Attributes.CreateInputBuffer(_settings.InitialInputBufferSize, _settings.MaxInputBufferSize)
                .And(ActorAttributes.CreateDispatcher(_settings.Dispatcher))
                .And(ActorAttributes.CreateSupervisionStrategy(_settings.SupervisionDecider));

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="attributes">TBD</param>
        /// <returns>TBD</returns>
        public override ActorMaterializerSettings EffectiveSettings(Attributes attributes)
        {
            return attributes.AttributeList.Aggregate(Settings, (settings, attribute) =>
            {
                var buffer = attribute as Attributes.InputBuffer;
                if (buffer != null)
                    return settings.WithInputBuffer(buffer.Initial, buffer.Max);

                var dispatcher = attribute as ActorAttributes.Dispatcher;
                if (dispatcher != null)
                    return settings.WithDispatcher(dispatcher.Name);
                
                var strategy = attribute as ActorAttributes.SupervisionStrategy;
                if (strategy != null)
                    return settings.WithSupervisionStrategy(strategy.Decider);

                return settings;
            });
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="delay">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public override ICancelable ScheduleOnce(TimeSpan delay, Action action)
            => _system.Scheduler.Advanced.ScheduleOnceCancelable(delay, action);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="initialDelay">TBD</param>
        /// <param name="interval">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public override ICancelable ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action)
            => _system.Scheduler.Advanced.ScheduleRepeatedlyCancelable(initialDelay, interval, action);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable) => Materialize(runnable, null,
            DefaultInitialAttributes);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser) 
            => Materialize(runnable, subFlowFuser, DefaultInitialAttributes);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Attributes initialAttributes) =>
            Materialize(runnable, null, initialAttributes);
        
        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="subFlowFuser">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <exception cref="IllegalStateException">TBD</exception>
        /// <returns>TBD</returns>
        public override TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Func<GraphInterpreterShell, IActorRef> subFlowFuser, Attributes initialAttributes)
        {
            var runnableGraph = _settings.IsAutoFusing
                ? Fusing.Fusing.Aggressive(runnable)
                : runnable;

            if (_haveShutDown.Value)
                throw new IllegalStateException("Attempted to call Materialize() after the ActorMaterializer has been shut down.");

            if (StreamLayout.IsDebug)
                StreamLayout.Validate(runnableGraph.Module);

            var session = new ActorMaterializerSession(this, runnableGraph.Module, initialAttributes, subFlowFuser);

            var matVal = session.Materialize();
            return (TMat) matVal;
        }

        /// <summary>
        /// Creates a new logging adapter.
        /// </summary>
        /// <param name="logSource">The source that produces the log events.</param>
        /// <returns>The newly created logging adapter.</returns>
        public override ILoggingAdapter MakeLogger(object logSource) => Logging.GetLogger(System, logSource);

        /// <summary>
        /// TBD
        /// </summary>
        public override MessageDispatcher ExecutionContext => _executionContext.Value;

        private readonly Lazy<MessageDispatcher> _executionContext;

        /// <summary>
        /// TBD
        /// </summary>
        public override void Shutdown()
        {
            if (_haveShutDown.CompareAndSet(false, true))
                Supervisor.Tell(PoisonPill.Instance);
        }

        private ILoggingAdapter GetLogger() => _system.Log;
    }

    /// <summary>
    /// TBD
    /// </summary>
    public class SubFusingActorMaterializerImpl : IMaterializer
    {
        private readonly ExtendedActorMaterializer _delegateMaterializer;
        private readonly Func<GraphInterpreterShell, IActorRef> _registerShell;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="delegateMaterializer">TBD</param>
        /// <param name="registerShell">TBD</param>
        public SubFusingActorMaterializerImpl(ExtendedActorMaterializer delegateMaterializer, Func<GraphInterpreterShell, IActorRef> registerShell)
        {
            _delegateMaterializer = delegateMaterializer;
            _registerShell = registerShell;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="namePrefix">TBD</param>
        /// <returns>TBD</returns>
        public IMaterializer WithNamePrefix(string namePrefix)
            => new SubFusingActorMaterializerImpl((ActorMaterializerImpl) _delegateMaterializer.WithNamePrefix(namePrefix), _registerShell);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <returns>TBD</returns>
        public TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable)
            => _delegateMaterializer.Materialize(runnable, _registerShell);

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="TMat">TBD</typeparam>
        /// <param name="runnable">TBD</param>
        /// <param name="initialAttributes">TBD</param>
        /// <returns>TBD</returns>
        public TMat Materialize<TMat>(IGraph<ClosedShape, TMat> runnable, Attributes initialAttributes) =>
            _delegateMaterializer.Materialize(runnable, _registerShell, initialAttributes);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="delay">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public ICancelable ScheduleOnce(TimeSpan delay, Action action)
            => _delegateMaterializer.ScheduleOnce(delay, action);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="initialDelay">TBD</param>
        /// <param name="interval">TBD</param>
        /// <param name="action">TBD</param>
        /// <returns>TBD</returns>
        public ICancelable ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action)
            => _delegateMaterializer.ScheduleRepeatedly(initialDelay, interval, action);

        /// <summary>
        /// TBD
        /// </summary>
        public MessageDispatcher ExecutionContext => _delegateMaterializer.ExecutionContext;
    }

    /// <summary>
    /// TBD
    /// </summary>
    public class FlowNameCounter : ExtensionIdProvider<FlowNameCounter>, IExtension
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public static FlowNameCounter Instance(ActorSystem system)
            => system.WithExtension<FlowNameCounter, FlowNameCounter>();

        /// <summary>
        /// TBD
        /// </summary>
        public readonly AtomicCounterLong Counter = new AtomicCounterLong(0);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="system">TBD</param>
        /// <returns>TBD</returns>
        public override FlowNameCounter CreateExtension(ExtendedActorSystem system) => new FlowNameCounter();
    }

    /// <summary>
    /// TBD
    /// </summary>
    public class StreamSupervisor : ActorBase
    {
        #region Messages

        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Materialize : INoSerializationVerificationNeeded, IDeadLetterSuppression
        {
            /// <summary>
            /// TBD
            /// </summary>
            public readonly Props Props;

            /// <summary>
            /// TBD
            /// </summary>
            public readonly string Name;

            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="props">TBD</param>
            /// <param name="name">TBD</param>
            public Materialize(Props props, string name)
            {
                Props = props;
                Name = name;
            }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class GetChildren
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly GetChildren Instance = new GetChildren();
            private GetChildren() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StopChildren
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly StopChildren Instance = new StopChildren();
            private StopChildren() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class StoppedChildren
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly StoppedChildren Instance = new StoppedChildren();
            private StoppedChildren() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class PrintDebugDump
        {
            /// <summary>
            /// TBD
            /// </summary>
            public static readonly PrintDebugDump Instance = new PrintDebugDump();
            private PrintDebugDump() { }
        }
        /// <summary>
        /// TBD
        /// </summary>
        public sealed class Children
        {
            /// <summary>
            /// TBD
            /// </summary>
            public readonly IImmutableSet<IActorRef> Refs;
            /// <summary>
            /// TBD
            /// </summary>
            /// <param name="refs">TBD</param>
            public Children(IImmutableSet<IActorRef> refs)
            {
                Refs = refs;
            }
        }

        #endregion

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="settings">TBD</param>
        /// <param name="haveShutdown">TBD</param>
        /// <returns>TBD</returns>
        public static Props Props(ActorMaterializerSettings settings, AtomicBoolean haveShutdown)
            => Actor.Props.Create(() => new StreamSupervisor(settings, haveShutdown)).WithDeploy(Deploy.Local);

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public static string NextName() => ActorName.Next();

        private static readonly EnumerableActorName ActorName = new EnumerableActorNameImpl("StreamSupervisor", new AtomicCounterLong(0L));

        /// <summary>
        /// TBD
        /// </summary>
        public readonly ActorMaterializerSettings Settings;
        /// <summary>
        /// TBD
        /// </summary>
        public readonly AtomicBoolean HaveShutdown;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="settings">TBD</param>
        /// <param name="haveShutdown">TBD</param>
        public StreamSupervisor(ActorMaterializerSettings settings, AtomicBoolean haveShutdown)
        {
            Settings = settings;
            HaveShutdown = haveShutdown;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        protected override SupervisorStrategy SupervisorStrategy() => Actor.SupervisorStrategy.StoppingStrategy;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="message">TBD</param>
        /// <returns>TBD</returns>
        protected override bool Receive(object message)
        {
            if (message is Materialize materialize)
            {
                Sender.Tell(Context.ActorOf(materialize.Props, materialize.Name));
            }
            else if (message is GetChildren)
                Sender.Tell(new Children(Context.GetChildren().ToImmutableHashSet()));
            else if (message is StopChildren)
            {
                foreach (var child in Context.GetChildren())
                    Context.Stop(child);

                Sender.Tell(StoppedChildren.Instance);
            }
            else
                return false;
            return true;
        }

        /// <summary>
        /// TBD
        /// </summary>
        protected override void PostStop() => HaveShutdown.Value = true;
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Streams\Implementation\ActorMaterializerImpl.cs(163,25): error CS0136: A local or parameter named 'graph' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 11 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedPublisher.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Akka.Streams.Util;
using Reactive.Streams;

namespace Akka.Streams
{
    /// <summary>
    /// TBD
    /// </summary>
    public interface IUntypedPublisher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        void Subscribe(IUntypedSubscriber subscriber);
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal abstract class UntypedPublisher : IUntypedPublisher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        public abstract void Subscribe(IUntypedSubscriber subscriber);

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public abstract object Unwrap();

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="publisher">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedPublisher FromTyped(object publisher)
        {
            var publishedType = publisher.GetType().GetPublishedType();
            return (UntypedPublisher) typeof(UntypedPublisherImpl<>).Instantiate(publishedType, publisher);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="publisher">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedPublisher FromTyped<T>(IPublisher<T> publisher)
        {
            return new UntypedPublisherImpl<T>(publisher);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="untypedPublisher">TBD</param>
        /// <returns>TBD</returns>
        public static object ToTyped(IUntypedPublisher untypedPublisher)
        {
            if (untypedPublisher is UntypedPublisher)
                return ((UntypedPublisher) untypedPublisher).Unwrap();
            return untypedPublisher;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="untypedPublisher">TBD</param>
        /// <returns>TBD</returns>
        public static IPublisher<T> ToTyped<T>(IUntypedPublisher untypedPublisher)
        {
            return (IPublisher<T>) ToTyped(untypedPublisher);
        }
    }

    /// <summary>
    /// TBD
    /// </summary>
    /// <typeparam name="T">TBD</typeparam>
    internal sealed class UntypedPublisherImpl<T> : UntypedPublisher
    {
        private readonly IPublisher<T> _publisher;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="publisher">TBD</param>
        public UntypedPublisherImpl(IPublisher<T> publisher)
        {
            _publisher = publisher;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        public override void Subscribe(IUntypedSubscriber subscriber)
        {
            _publisher.Subscribe(UntypedSubscriber.ToTyped<T>(subscriber));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override object Unwrap()
        {
            return _publisher;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override string ToString()
        {
            return _publisher.ToString();
        }
    }
}

---- Transformed Tree ----
using Akka.Streams.Util;
using Reactive.Streams;

namespace Akka.Streams
{
    /// <summary>
    /// TBD
    /// </summary>
    public interface IUntypedPublisher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        void Subscribe(IUntypedSubscriber subscriber);
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal abstract class UntypedPublisher : IUntypedPublisher
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        public abstract void Subscribe(IUntypedSubscriber subscriber);

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public abstract object Unwrap();

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="publisher">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedPublisher FromTyped(object publisher)
        {
            var publishedType = publisher.GetType().GetPublishedType();
            return (UntypedPublisher) typeof(UntypedPublisherImpl<>).Instantiate(publishedType, publisher);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="publisher">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedPublisher FromTyped<T>(IPublisher<T> publisher)
        {
            return new UntypedPublisherImpl<T>(publisher);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="untypedPublisher">TBD</param>
        /// <returns>TBD</returns>
        public static object ToTyped(IUntypedPublisher untypedPublisher)
        {
            if (untypedPublisher is UntypedPublisher untypedPublisher)
                return untypedPublisher.Unwrap();
            return untypedPublisher;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="untypedPublisher">TBD</param>
        /// <returns>TBD</returns>
        public static IPublisher<T> ToTyped<T>(IUntypedPublisher untypedPublisher)
        {
            return (IPublisher<T>) ToTyped(untypedPublisher);
        }
    }

    /// <summary>
    /// TBD
    /// </summary>
    /// <typeparam name="T">TBD</typeparam>
    internal sealed class UntypedPublisherImpl<T> : UntypedPublisher
    {
        private readonly IPublisher<T> _publisher;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="publisher">TBD</param>
        public UntypedPublisherImpl(IPublisher<T> publisher)
        {
            _publisher = publisher;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        public override void Subscribe(IUntypedSubscriber subscriber)
        {
            _publisher.Subscribe(UntypedSubscriber.ToTyped<T>(subscriber));
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override object Unwrap()
        {
            return _publisher;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override string ToString()
        {
            return _publisher.ToString();
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedPublisher.cs(71,17): error CS0841: Cannot use local variable 'untypedPublisher' before it is declared,D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedPublisher.cs(71,54): error CS0136: A local or parameter named 'untypedPublisher' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 12 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedSubscriber.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Akka.Streams.Util;
using Reactive.Streams;

namespace Akka.Streams
{
    /// <summary>
    /// TBD
    /// </summary>
    public interface IUntypedSubscriber
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscription">TBD</param>
        void OnSubscribe(ISubscription subscription);
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="element">TBD</param>
        void OnNext(object element);
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="cause">TBD</param>
        void OnError(Exception cause);
        /// <summary>
        /// TBD
        /// </summary>
        void OnComplete();
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal abstract class UntypedSubscriber : IUntypedSubscriber
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscription">TBD</param>
        public abstract void OnSubscribe(ISubscription subscription);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="element">TBD</param>
        public abstract void OnNext(object element);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="cause">TBD</param>
        public abstract void OnError(Exception cause);

        /// <summary>
        /// TBD
        /// </summary>
        public abstract void OnComplete();

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public abstract object Unwrap();

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedSubscriber FromTyped(object subscriber)
        {
            var subscribedType = subscriber.GetType().GetSubscribedType();
            return (UntypedSubscriber) typeof(UntypedSubscriberImpl<>).Instantiate(subscribedType, subscriber);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="subscriber">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedSubscriber FromTyped<T>(ISubscriber<T> subscriber)
        {
            return new UntypedSubscriberImpl<T>(subscriber);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="untypedSubscriber">TBD</param>
        /// <returns>TBD</returns>
        public static object ToTyped(IUntypedSubscriber untypedSubscriber)
        {
            if (untypedSubscriber is UntypedSubscriber)
                return ((UntypedSubscriber) untypedSubscriber).Unwrap();
            return untypedSubscriber;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="untypedSubscriber">TBD</param>
        /// <returns>TBD</returns>
        public static ISubscriber<T> ToTyped<T>(IUntypedSubscriber untypedSubscriber)
        {
            return (ISubscriber<T>) ToTyped(untypedSubscriber);
        }
    }

    /// <summary>
    /// TBD
    /// </summary>
    /// <typeparam name="T">TBD</typeparam>
    internal sealed class UntypedSubscriberImpl<T> : UntypedSubscriber
    {
        private readonly ISubscriber<T> _subscriber;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        public UntypedSubscriberImpl(ISubscriber<T> subscriber)
        {
            _subscriber = subscriber;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscription">TBD</param>
        public override void OnSubscribe(ISubscription subscription)
        {
            _subscriber.OnSubscribe(subscription);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="element">TBD</param>
        public override void OnNext(object element)
        {
            _subscriber.OnNext((T) element);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="cause">TBD</param>
        public override void OnError(Exception cause)
        {
            _subscriber.OnError(cause);
        }

        /// <summary>
        /// TBD
        /// </summary>
        public override void OnComplete()
        {
            _subscriber.OnComplete();
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override object Unwrap()
        {
            return _subscriber;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override string ToString()
        {
            return _subscriber.ToString();
        }
    }
}

---- Transformed Tree ----
using System;
using Akka.Streams.Util;
using Reactive.Streams;

namespace Akka.Streams
{
    /// <summary>
    /// TBD
    /// </summary>
    public interface IUntypedSubscriber
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscription">TBD</param>
        void OnSubscribe(ISubscription subscription);
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="element">TBD</param>
        void OnNext(object element);
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="cause">TBD</param>
        void OnError(Exception cause);
        /// <summary>
        /// TBD
        /// </summary>
        void OnComplete();
    }

    /// <summary>
    /// TBD
    /// </summary>
    internal abstract class UntypedSubscriber : IUntypedSubscriber
    {
        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscription">TBD</param>
        public abstract void OnSubscribe(ISubscription subscription);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="element">TBD</param>
        public abstract void OnNext(object element);

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="cause">TBD</param>
        public abstract void OnError(Exception cause);

        /// <summary>
        /// TBD
        /// </summary>
        public abstract void OnComplete();

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public abstract object Unwrap();

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedSubscriber FromTyped(object subscriber)
        {
            var subscribedType = subscriber.GetType().GetSubscribedType();
            return (UntypedSubscriber) typeof(UntypedSubscriberImpl<>).Instantiate(subscribedType, subscriber);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="subscriber">TBD</param>
        /// <returns>TBD</returns>
        public static UntypedSubscriber FromTyped<T>(ISubscriber<T> subscriber)
        {
            return new UntypedSubscriberImpl<T>(subscriber);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="untypedSubscriber">TBD</param>
        /// <returns>TBD</returns>
        public static object ToTyped(IUntypedSubscriber untypedSubscriber)
        {
            if (untypedSubscriber is UntypedSubscriber untypedSubscriber)
                return untypedSubscriber.Unwrap();
            return untypedSubscriber;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <typeparam name="T">TBD</typeparam>
        /// <param name="untypedSubscriber">TBD</param>
        /// <returns>TBD</returns>
        public static ISubscriber<T> ToTyped<T>(IUntypedSubscriber untypedSubscriber)
        {
            return (ISubscriber<T>) ToTyped(untypedSubscriber);
        }
    }

    /// <summary>
    /// TBD
    /// </summary>
    /// <typeparam name="T">TBD</typeparam>
    internal sealed class UntypedSubscriberImpl<T> : UntypedSubscriber
    {
        private readonly ISubscriber<T> _subscriber;

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscriber">TBD</param>
        public UntypedSubscriberImpl(ISubscriber<T> subscriber)
        {
            _subscriber = subscriber;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="subscription">TBD</param>
        public override void OnSubscribe(ISubscription subscription)
        {
            _subscriber.OnSubscribe(subscription);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="element">TBD</param>
        public override void OnNext(object element)
        {
            _subscriber.OnNext((T) element);
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <param name="cause">TBD</param>
        public override void OnError(Exception cause)
        {
            _subscriber.OnError(cause);
        }

        /// <summary>
        /// TBD
        /// </summary>
        public override void OnComplete()
        {
            _subscriber.OnComplete();
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override object Unwrap()
        {
            return _subscriber;
        }

        /// <summary>
        /// TBD
        /// </summary>
        /// <returns>TBD</returns>
        public override string ToString()
        {
            return _subscriber.ToString();
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedSubscriber.cs(103,17): error CS0841: Cannot use local variable 'untypedSubscriber' before it is declared,D:\a\1\s\src\core\Akka.Streams\Implementation\UntypedSubscriber.cs(103,56): error CS0136: A local or parameter named 'untypedSubscriber' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 13 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Tools.Tests.MultiNode\Singleton\ClusterSingletonManagerChaosSpec.cs
Description: Error: Unable to create valid SyntaxTree for document: ClusterSingletonManagerChaosSpec.cs. Caught exception: System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitEqualsValueClause(EqualsValueClauseSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitVariableDeclarator(VariableDeclaratorSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitVariableDeclaration(VariableDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 24
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitExpressionStatement(ExpressionStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Linq;
using Akka.Actor;
using Akka.Cluster.TestKit;
using Akka.Cluster.Tools.Singleton;
using Akka.Configuration;
using Akka.Remote.TestKit;
using Akka.TestKit;
using FluentAssertions;
using Akka.TestKit.TestEvent;
using Akka.TestKit.Internal;

namespace Akka.Cluster.Tools.Tests.MultiNode.Singleton
{
    public class ClusterSingletonManagerChaosConfig : MultiNodeConfig
    {
        public readonly RoleName Controller;
        public readonly RoleName First;
        public readonly RoleName Second;
        public readonly RoleName Third;
        public readonly RoleName Fourth;
        public readonly RoleName Fifth;
        public readonly RoleName Sixth;

        public ClusterSingletonManagerChaosConfig()
        {
            Controller = Role("controller");
            First = Role("_config.First");
            Second = Role("second");
            Third = Role("third");
            Fourth = Role("fourth");
            Fifth = Role("fifth");
            Sixth = Role("sixth");

            CommonConfig = ConfigurationFactory.ParseString(@"
                akka.loglevel = DEBUG
                akka.actor.provider = ""Akka.Cluster.ClusterActorRefProvider, Akka.Cluster""
                akka.remote.log-remote-lifecycle-events = off
                akka.cluster.auto-down-unreachable-after = 0s
            ")
            .WithFallback(ClusterSingletonManager.DefaultConfig())
            .WithFallback(ClusterSingletonProxy.DefaultConfig())
            .WithFallback(MultiNodeClusterSpec.ClusterConfig());
        }
    }

    public class ClusterSingletonManagerChaosSpec : MultiNodeClusterSpec
    {
        private class EchoStarted
        {
            public static readonly EchoStarted Instance = new EchoStarted();

            private EchoStarted() { }
        }

        private class EchoActor : ReceiveActor
        {
            public EchoActor(IActorRef testActor)
            {
                testActor.Tell(EchoStarted.Instance);
                ReceiveAny(_ => Sender.Tell(Self));
            }
        }

        private readonly ClusterSingletonManagerChaosConfig _config;

        public ClusterSingletonManagerChaosSpec() : this(new ClusterSingletonManagerChaosConfig())
        {
        }

        protected ClusterSingletonManagerChaosSpec(ClusterSingletonManagerChaosConfig config) : base(config, typeof(ClusterSingletonManagerChaosSpec))
        {
            _config = config;
        }

        protected override int InitialParticipantsValueFactory { get { return Roles.Count; } }

        [MultiNodeFact]
        public void ClusterSingletonManager_in_chaotic_cluster_specs()
        {
            ClusterSingletonManager_in_chaotic_cluster_should_startup_6_node_cluster();
            ClusterSingletonManager_in_chaotic_cluster_should_take_over_when_three_oldest_nodes_crash_in_6_nodes_cluster();
        }

        public void ClusterSingletonManager_in_chaotic_cluster_should_startup_6_node_cluster()
        {
            Within(TimeSpan.FromSeconds(60), () =>
            {
                var memberProbe = CreateTestProbe();
                Cluster.Subscribe(memberProbe.Ref, new[] { typeof(ClusterEvent.MemberUp) });
                memberProbe.ExpectMsg<ClusterEvent.CurrentClusterState>();

                Join(_config.First, _config.First);
                AwaitMemberUp(memberProbe, _config.First);
                RunOn(() =>
                {
                    ExpectMsg<EchoStarted>();
                }, _config.First);
                EnterBarrier("first-started");

                Join(_config.Second, _config.First);
                AwaitMemberUp(memberProbe, _config.Second, _config.First);

                Join(_config.Third, _config.First);
                AwaitMemberUp(memberProbe, _config.Third, _config.Second, _config.First);

                Join(_config.Fourth, _config.First);
                AwaitMemberUp(memberProbe, _config.Fourth, _config.Third, _config.Second, _config.First);

                Join(_config.Fifth, _config.First);
                AwaitMemberUp(memberProbe, _config.Fifth, _config.Fourth, _config.Third, _config.Second, _config.First);

                Join(_config.Sixth, _config.First);
                AwaitMemberUp(memberProbe, _config.Sixth, _config.Fifth, _config.Fourth, _config.Third, _config.Second, _config.First);

                RunOn(() =>
                {
                    Echo(_config.First).Tell("hello");
                    ExpectMsg<IActorRef>(TimeSpan.FromSeconds(3)).Path.Address
                        .Should()
                        .Be(GetAddress(_config.First));
                }, _config.Controller);

                EnterBarrier("first-verified");
            });
        }

        public void ClusterSingletonManager_in_chaotic_cluster_should_take_over_when_three_oldest_nodes_crash_in_6_nodes_cluster()
        {
            Within(TimeSpan.FromSeconds(90), () =>
            {

                // mute logging of deadLetters during shutdown of systems
                if (!Log.IsDebugEnabled)
                    Sys.EventStream.Publish(new Mute(new WarningFilter()));
                EnterBarrier("logs-muted");

                Crash(_config.First, _config.Second, _config.Third);
                EnterBarrier("after-crash");

                RunOn(() =>
                {
                    ExpectMsg<EchoStarted>();
                }, _config.Fourth);
                EnterBarrier("fourth-active");

                RunOn(() =>
                {
                    Echo(_config.Fourth).Tell("hello");
                    var address = ExpectMsg<IActorRef>(TimeSpan.FromSeconds(3)).Path.Address;
                    GetAddress(_config.Fourth).Should().Be(address);
                }, _config.Controller);
                EnterBarrier("fourth-verified");
            });
        }

        private void Join(RoleName from, RoleName to)
        {
            RunOn(() =>
            {
                Cluster.Join(GetAddress(to));
                CreateSingleton();
            }, from);
        }

        private IActorRef CreateSingleton()
        {
            return Sys.ActorOf(ClusterSingletonManager.Props(
                singletonProps: Props.Create(() => new EchoActor(TestActor)),
                terminationMessage: PoisonPill.Instance,
                settings: ClusterSingletonManagerSettings.Create(Sys)),
                name: "echo");
        }

        private void Crash(params RoleName[] roles)
        {
            RunOn(() =>
            {
                foreach (var roleName in roles)
                {
                    Log.Info("Shutdown [{0}]", GetAddress(roleName));
                    TestConductor.Exit(roleName, 0).Wait(TimeSpan.FromSeconds(10));
                }
            }, _config.Controller);
        }

        private ActorSelection Echo(RoleName oldest)
        {
            return Sys.ActorSelection(new RootActorPath(GetAddress(oldest)) / "user" / "echo" / "singleton");
        }

        private void AwaitMemberUp(TestProbe memberProbe, params RoleName[] nodes)
        {
            if (nodes.Length > 1)
            {
                RunOn(() =>
                {
                    memberProbe.ExpectMsg<ClusterEvent.MemberUp>(TimeSpan.FromSeconds(15)).Member.Address
                        .Should()
                        .Be(GetAddress(nodes.First()));
                }, nodes.Skip(1).ToArray());
            }

            RunOn(() =>
            {
                var roleNodes = nodes.Select(node => GetAddress(node));

                var addresses = memberProbe.ReceiveN(nodes.Length, TimeSpan.FromSeconds(15))
                    .Where(x => x is ClusterEvent.MemberUp)
                    .Select(x => (x as ClusterEvent.MemberUp).Member.Address);

                addresses.Except(roleNodes).Count().Should().Be(0);
            }, nodes.First());

            EnterBarrier(nodes.First().Name + "-up");
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 14 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\src\contrib\cluster\Akka.Cluster.Tools.Tests.MultiNode\Singleton\ClusterSingletonManagerSpec.cs
Description: Error: Unable to create valid SyntaxTree for document: ClusterSingletonManagerSpec.cs. Caught exception: System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitEqualsValueClause(EqualsValueClauseSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitVariableDeclarator(VariableDeclaratorSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitVariableDeclaration(VariableDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 24
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitExpressionStatement(ExpressionStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Linq;
using Akka.Actor;
using Akka.Cluster.TestKit;
using Akka.Cluster.Tools.Singleton;
using Akka.Configuration;
using Akka.Event;
using Akka.Remote.TestKit;
using Akka.TestKit;
using Akka.TestKit.Internal.StringMatcher;
using Akka.TestKit.TestEvent;
using FluentAssertions;

namespace Akka.Cluster.Tools.Tests.MultiNode.Singleton
{
    public class ClusterSingletonManagerSpecConfig : MultiNodeConfig
    {
        public readonly RoleName Controller;
        public readonly RoleName Observer;
        public readonly RoleName First;
        public readonly RoleName Second;
        public readonly RoleName Third;
        public readonly RoleName Fourth;
        public readonly RoleName Fifth;
        public readonly RoleName Sixth;

        public ClusterSingletonManagerSpecConfig()
        {
            Controller = Role("controller");
            Observer = Role("observer");
            First = Role("first");
            Second = Role("second");
            Third = Role("third");
            Fourth = Role("fourth");
            Fifth = Role("fifth");
            Sixth = Role("sixth");

            CommonConfig = ConfigurationFactory.ParseString(@"
                akka.loglevel = INFO
                akka.actor.provider = ""Akka.Cluster.ClusterActorRefProvider, Akka.Cluster""
                akka.remote.log-remote-lifecycle-events = off
                akka.cluster.auto-down-unreachable-after = 0s
            ")
            .WithFallback(ClusterSingletonManager.DefaultConfig())
            .WithFallback(ClusterSingletonProxy.DefaultConfig())
            .WithFallback(MultiNodeClusterSpec.ClusterConfig());

            NodeConfig(new[] { First, Second, Third, Fourth, Fifth, Sixth }, new[] { ConfigurationFactory.ParseString(@"akka.cluster.roles = [worker]") });
        }
    }

    /**
     * This channel is extremely strict with regards to
     * registration and unregistration of consumer to
     * be able to detect misbehaviour (e.g. two active
     * singleton instances).
     */
    internal class PointToPointChannel : UntypedActor
    {
        #region messages

        public sealed class UnregisterConsumer
        {
            public static readonly UnregisterConsumer Instance = new UnregisterConsumer();

            private UnregisterConsumer()
            {
            }
        }

        public sealed class RegisterConsumer
        {
            public static readonly RegisterConsumer Instance = new RegisterConsumer();

            private RegisterConsumer()
            {
            }
        }

        public sealed class RegistrationOk
        {
            public static readonly RegistrationOk Instance = new RegistrationOk();

            private RegistrationOk()
            {
            }
        }

        public sealed class UnexpectedRegistration
        {
            public static readonly UnexpectedRegistration Instance = new UnexpectedRegistration();

            private UnexpectedRegistration()
            {
            }
        }

        public sealed class UnregistrationOk
        {
            public static readonly UnregistrationOk Instance = new UnregistrationOk();

            private UnregistrationOk()
            {
            }
        }

        public sealed class UnexpectedUnregistration
        {
            public static readonly UnexpectedUnregistration Instance = new UnexpectedUnregistration();

            private UnexpectedUnregistration()
            {
            }
        }

        public sealed class Reset
        {
            public static readonly Reset Instance = new Reset();

            private Reset()
            {
            }
        }

        public sealed class ResetOk
        {
            public static readonly ResetOk Instance = new ResetOk();

            private ResetOk()
            {
            }
        }

        #endregion

        private readonly ILoggingAdapter _log = Context.GetLogger();

        public PointToPointChannel()
        {
            Become(Idle);
        }

        private void Idle(object message)
        {
            message.Match()
                .With<RegisterConsumer>(_ =>
                {
                    _log.Info("Register consumer [{0}]", Sender.Path);
                    Sender.Tell(RegistrationOk.Instance);
                    Context.Become(Active(Sender));
                })
                .With<UnregisterConsumer>(_ =>
                {
                    _log.Info("Unexpected unregistration: [{0}]", Sender.Path);
                    Sender.Tell(UnexpectedRegistration.Instance);
                    Context.Stop(Self);
                })
                .With<Reset>(_ => Sender.Tell(ResetOk.Instance))
                .Default(msg => { });
        }

        private UntypedReceive Active(IActorRef consumer)
        {
            return message =>
            {
                message.Match()
                    .With<UnregisterConsumer>(_ =>
                    {
                        if (Sender.Equals(consumer))
                        {
                            _log.Info("UnregistrationOk: [{0}]", Sender.Path);
                            Sender.Tell(UnregistrationOk.Instance);
                            Context.Become(Idle);
                        }
                        else
                        {
                            _log.Info("UnexpectedUnregistration: [{0}], expected: [{1}]", Sender.Path, consumer.Path);
                            Sender.Tell(UnexpectedUnregistration.Instance);
                            Context.Stop(Self);
                        }
                    })
                    .With<RegisterConsumer>(_ =>
                    {
                        _log.Info("Unexpected RegisterConsumer: [{0}], active consumer: [{1}]", Sender.Path, consumer.Path);
                        Sender.Tell(UnexpectedRegistration.Instance);
                        Context.Stop(Self);
                    })
                    .With<Reset>(_ =>
                    {
                        Context.Become(Idle);
                        Sender.Tell(ResetOk.Instance);
                    })
                    .Default(msg => consumer.Tell(msg));
            };
        }

        protected override void OnReceive(object message) { }
    }

    internal class Consumer : ReceiveActor
    {
        private readonly IActorRef _queue;
        private readonly IActorRef _delegateTo;
        private readonly ILoggingAdapter _log = Context.GetLogger();

        #region messages

        public sealed class Ping
        {
            public static readonly Ping Instance = new Ping();

            private Ping()
            {
            }
        }

        public sealed class Pong
        {
            public static readonly Pong Instance = new Pong();

            private Pong()
            {
            }
        }

        public sealed class End
        {
            public static readonly End Instance = new End();

            private End()
            {
            }
        }

        public sealed class GetCurrent
        {
            public static readonly GetCurrent Instance = new GetCurrent();

            private GetCurrent()
            {
            }
        }

        #endregion

        private int _current = 0;
        private bool stoppedBeforeUnregistration = true;

        public Consumer(IActorRef queue, IActorRef delegateTo)
        {
            _queue = queue;
            _delegateTo = delegateTo;

            Receive<int>(n => n <= _current, n => Context.Stop(Self));
            Receive<int>(n =>
            {
                _current = n;
                _delegateTo.Tell(n);
            });
            Receive<PointToPointChannel.RegistrationOk>(x => _delegateTo.Tell(x));
            Receive<PointToPointChannel.UnexpectedRegistration>(x => _delegateTo.Tell(x));
            Receive<GetCurrent>(_ => Sender.Tell(_current));
            Receive<End>(_ => queue.Tell(PointToPointChannel.UnregisterConsumer.Instance));
            Receive<PointToPointChannel.UnregistrationOk>(_ =>
            {
                stoppedBeforeUnregistration = false;
                Context.Stop(Self);
            });
            Receive<Ping>(_ => Sender.Tell(Pong.Instance));
        }

        protected override void PreStart()
        {
            _queue.Tell(PointToPointChannel.RegisterConsumer.Instance);
        }

        protected override void PostStop()
        {
            if (stoppedBeforeUnregistration)
            {
                _log.Warning("Stopped before unregistration");
            }
        }
    }

    public class ClusterSingletonManagerSpec : MultiNodeClusterSpec
    {
        #region Setup

        private readonly TestProbe _identifyProbe;
        private readonly ActorPath _controllerRootActorPath;
        private int _msg = 0;

        private readonly RoleName _controller;
        private readonly RoleName _observer;
        private readonly RoleName _first;
        private readonly RoleName _second;
        private readonly RoleName _third;
        private readonly RoleName _fourth;
        private readonly RoleName _fifth;
        private readonly RoleName _sixth;

        public int Msg { get { return ++_msg; } }

        public IActorRef Queue
        {
            get
            {
                // this is used from inside actor construction, i.e. other thread, and must therefore not call `node(controller`
                Sys.ActorSelection(_controllerRootActorPath / "user" / "queue").Tell(new Identify("queue"), _identifyProbe.Ref);
                return _identifyProbe.ExpectMsg<ActorIdentity>().Subject;
            }
        }

        public ClusterSingletonManagerSpec() : this(new ClusterSingletonManagerSpecConfig())
        {
        }

        protected ClusterSingletonManagerSpec(ClusterSingletonManagerSpecConfig config) : base(config, typeof(ClusterSingletonManagerSpec))
        {
            _controller = config.Controller;
            _observer = config.Observer;
            _first = config.First;
            _second = config.Second;
            _third = config.Third;
            _fourth = config.Fourth;
            _fifth = config.Fifth;
            _sixth = config.Sixth;

            _identifyProbe = CreateTestProbe();
            _controllerRootActorPath = Node(config.Controller);
        }

        private void Join(RoleName from, RoleName to)
        {
            RunOn(() =>
            {
                Cluster.Join(Node(to).Address);
                if (Cluster.SelfRoles.Contains("worker"))
                {
                    CreateSingleton();
                    CreateSingletonProxy();
                }
            }, from);
        }

        private void AwaitMemberUp(TestProbe memberProbe, params RoleName[] nodes)
        {
            if (nodes.Length > 1)
            {
                RunOn(() =>
                {
                    memberProbe.ExpectMsg<ClusterEvent.MemberUp>(TimeSpan.FromSeconds(15)).Member.Address
                        .Should()
                        .Be(Node(nodes.First()).Address);
                }, nodes.Skip(1).ToArray());
            }

            RunOn(() =>
            {
                var roleNodes = nodes.Select(node => Node(node).Address);

                var addresses = memberProbe.ReceiveN(nodes.Length, TimeSpan.FromSeconds(15))
                    .Where(x => x is ClusterEvent.MemberUp)
                    .Select(x => (x as ClusterEvent.MemberUp).Member.Address);

                addresses.Except(roleNodes).Count().Should().Be(0);
            }, nodes.First());

            EnterBarrier(nodes[0].Name + "-up");
        }

        private void CreateSingleton()
        {
            Sys.ActorOf(ClusterSingletonManager.Props(
                singletonProps: Props.Create(() => new Consumer(Queue, TestActor)),
                terminationMessage: Consumer.End.Instance,
                settings: ClusterSingletonManagerSettings.Create(Sys).WithRole("worker")),
                name: "consumer");
        }

        private void CreateSingletonProxy()
        {
            Sys.ActorOf(ClusterSingletonProxy.Props(
                singletonManagerPath: "/user/consumer",
                settings: ClusterSingletonProxySettings.Create(Sys).WithRole("worker")),
                name: "consumerProxy");
        }

        private void VerifyProxyMsg(RoleName oldest, RoleName proxyNode, int msg)
        {
            EnterBarrier("before-" + msg + "-proxy-verified");

            // send message to the proxy
            RunOn(() =>
            {
                // make sure that the proxy has received membership changes
                // and points to the current singleton
                var p = CreateTestProbe();
                var oldestAddress = Node(oldest).Address;
                Within(TimeSpan.FromSeconds(10), () =>
                {
                    AwaitAssert(() =>
                    {
                        Sys.ActorSelection("/user/consumerProxy").Tell(Consumer.Ping.Instance, p.Ref);
                        p.ExpectMsg<Consumer.Pong>(TimeSpan.FromSeconds(1));
                        var replyFromAddress = p.LastSender.Path.Address;
                        if (oldest.Equals(proxyNode))
                            replyFromAddress.HasLocalScope.Should().BeTrue();
                        else
                            replyFromAddress.Should().Be(oldestAddress);
                    });
                });

                // send a real message
                Sys.ActorSelection("/user/consumerProxy").Tell(msg);
            }, proxyNode);

            EnterBarrier($"sent-msg-{msg}");

            // expect a message on the oldest node
            RunOn(() =>
            {
                ExpectMsg(msg);
            }, oldest);

            EnterBarrier("after-" + msg + "-proxy-verified");
        }

        private ActorSelection GetConsumer(RoleName oldest)
        {
            return Sys.ActorSelection(new RootActorPath(Node(oldest).Address) / "user" / "consumer" / "singleton");
        }

        private void VerifyRegistration(RoleName oldest)
        {
            EnterBarrier("before-" + oldest.Name + "-registration-verified");

            RunOn(() =>
            {
                ExpectMsg<PointToPointChannel.RegistrationOk>();
                GetConsumer(oldest).Tell(Consumer.GetCurrent.Instance);
                ExpectMsg(0);
            }, oldest);

            EnterBarrier("after-" + oldest.Name + "-registration-verified");
        }

        private void VerifyMsg(RoleName oldest, int msg)
        {
            EnterBarrier("before-" + msg + "-verified");

            RunOn(() =>
            {
                Queue.Tell(msg);
                // make sure it's not terminated, which would be wrong
                ExpectNoMsg(TimeSpan.FromSeconds(1));
            }, _controller);

            RunOn(() =>
            {
                ExpectMsg(msg, TimeSpan.FromSeconds(5));
            }, oldest);

            RunOn(() =>
            {
                ExpectNoMsg(TimeSpan.FromSeconds(1));
            }, Roles.Where(r => r != oldest && r != _controller && r != _observer).ToArray());

            EnterBarrier("after-" + msg + "-verified");
        }

        private void Crash(params RoleName[] roles)
        {
            RunOn(() =>
            {
                Queue.Tell(PointToPointChannel.Reset.Instance);
                ExpectMsg<PointToPointChannel.ResetOk>();
                foreach (var role in roles)
                {
                    Log.Info("Shutdown [{0}]", GetAddress(role));
                    TestConductor.Exit(role, 0).Wait();
                }
            }, _controller);
        }

        #endregion


        [MultiNodeFact]
        public void ClusterSingletonManagerSpecs()
        {
            ClusterSingletonManager_should_startup_6_node_cluster();
            ClusterSingletonManager_should_let_the_proxy_messages_to_the_singleton_in_a_6_node_cluster();
            ClusterSingletonManager_should_handover_when_oldest_leaves_in_6_node_cluster();
            ClusterSingletonManager_should_takeover_when_oldest_crashes_in_5_node_cluster();
            ClusterSingletonManager_should_takeover_when_two_oldest_crash_in_3_node_cluster();
            ClusterSingletonManager_should_takeover_when_oldest_crashes_in_2_node_cluster();
        }

        public void ClusterSingletonManager_should_startup_6_node_cluster()
        {
            Within(TimeSpan.FromSeconds(60), () =>
            {
                var memberProbe = CreateTestProbe();
                Cluster.Subscribe(memberProbe.Ref, new[] { typeof(ClusterEvent.MemberUp) });
                memberProbe.ExpectMsg<ClusterEvent.CurrentClusterState>();

                RunOn(() =>
                {
                    // watch that it is not terminated, which would indicate misbehaviour
                    Watch(Sys.ActorOf(Props.Create<PointToPointChannel>(), "queue"));
                }, _controller);
                EnterBarrier("queue-started");

                Join(_first, _first);
                AwaitMemberUp(memberProbe, _first);
                VerifyRegistration(_first);
                VerifyMsg(_first, Msg);

                // join the observer node as well, which should not influence since it doesn't have the "worker" role
                Join(_observer, _first);
                AwaitMemberUp(memberProbe, _observer, _first);
                VerifyProxyMsg(_first, _first, Msg);

                Join(_second, _first);
                AwaitMemberUp(memberProbe, _second, _observer, _first);
                VerifyMsg(_first, Msg);
                VerifyProxyMsg(_first, _second, Msg);

                Join(_third, _first);
                AwaitMemberUp(memberProbe, _third, _second, _observer, _first);
                VerifyMsg(_first, Msg);
                VerifyProxyMsg(_first, _third, Msg);

                Join(_fourth, _first);
                AwaitMemberUp(memberProbe, _fourth, _third, _second, _observer, _first);
                VerifyMsg(_first, Msg);
                VerifyProxyMsg(_first, _fourth, Msg);

                Join(_fifth, _first);
                AwaitMemberUp(memberProbe, _fifth, _fourth, _third, _second, _observer, _first);
                VerifyMsg(_first, Msg);
                VerifyProxyMsg(_first, _fifth, Msg);

                Join(_sixth, _first);
                AwaitMemberUp(memberProbe, _sixth, _fifth, _fourth, _third, _second, _observer, _first);
                VerifyMsg(_first, Msg);
                VerifyProxyMsg(_first, _sixth, Msg);

                EnterBarrier("after-1");
            });
        }

        public void ClusterSingletonManager_should_let_the_proxy_messages_to_the_singleton_in_a_6_node_cluster()
        {
            Within(TimeSpan.FromSeconds(60), () =>
            {
                VerifyProxyMsg(_first, _first, Msg);
                VerifyProxyMsg(_first, _second, Msg);
                VerifyProxyMsg(_first, _third, Msg);
                VerifyProxyMsg(_first, _fourth, Msg);
                VerifyProxyMsg(_first, _fifth, Msg);
                VerifyProxyMsg(_first, _sixth, Msg);
            });
        }

        public void ClusterSingletonManager_should_handover_when_oldest_leaves_in_6_node_cluster()
        {
            Within(TimeSpan.FromSeconds(30), () =>
            {
                var leaveNode = _first;

                RunOn(() =>
                {
                    Cluster.Leave(GetAddress(leaveNode));
                }, leaveNode);

                VerifyRegistration(_second);
                VerifyMsg(_second, Msg);
                VerifyProxyMsg(_second, _second, Msg);
                VerifyProxyMsg(_second, _third, Msg);
                VerifyProxyMsg(_second, _fourth, Msg);
                VerifyProxyMsg(_second, _fifth, Msg);
                VerifyProxyMsg(_second, _sixth, Msg);

                RunOn(() =>
                {
                    Sys.ActorSelection("/user/consumer").Tell(new Identify("singleton"), _identifyProbe.Ref);
                    _identifyProbe.ExpectMsg<ActorIdentity>(i =>
                    {
                        if (i.MessageId.Equals("singleton") && i.Subject != null)
                        {
                            Watch(i.Subject);
                            ExpectTerminated(i.Subject);
                        }
                    });
                }, leaveNode);
                EnterBarrier("after-leave");
            });
        }

        public void ClusterSingletonManager_should_takeover_when_oldest_crashes_in_5_node_cluster()
        {
            Within(TimeSpan.FromSeconds(60), () =>
            {
                // mute logging of deadLetters during shutdown of systems
                if (!Log.IsDebugEnabled)
                    Sys.EventStream.Publish(new Mute(new DeadLettersFilter(new PredicateMatcher(s => true), new PredicateMatcher(s => true))));
                EnterBarrier("logs-muted");

                Crash(_second);
                VerifyRegistration(_third);
                VerifyMsg(_third, Msg);
                VerifyProxyMsg(_third, _third, Msg);
                VerifyProxyMsg(_third, _fourth, Msg);
                VerifyProxyMsg(_third, _fifth, Msg);
                VerifyProxyMsg(_third, _sixth, Msg);
            });
        }

        public void ClusterSingletonManager_should_takeover_when_two_oldest_crash_in_3_node_cluster()
        {
            Within(TimeSpan.FromSeconds(60), () =>
            {
                Crash(_third, _fourth);
                VerifyRegistration(_fifth);
                VerifyMsg(_fifth, Msg);
                VerifyProxyMsg(_fifth, _fifth, Msg);
                VerifyProxyMsg(_fifth, _sixth, Msg);
            });
        }

        public void ClusterSingletonManager_should_takeover_when_oldest_crashes_in_2_node_cluster()
        {
            Within(TimeSpan.FromSeconds(60), () =>
            {
                Crash(_fifth);
                VerifyRegistration(_sixth);
                VerifyMsg(_sixth, Msg);
                VerifyProxyMsg(_sixth, _sixth, Msg);
            });
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


