Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Z.EntityFramework.Plus.EF5
    #1 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 42, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #2 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 82, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #3 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityAdded.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityDeleted.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityModified.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedChild`2.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #25 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedProvider.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.EntityFramework.Plus.EF5.NET40
    #27 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 42, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #28 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 82, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #29 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityAdded.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityDeleted.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityModified.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedChild`2.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #51 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedProvider.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.EntityFramework.Plus.EF6
    #53 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 42, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #54 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 82, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #55 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #64 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #65 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #66 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LazyAsyncEnumerator\LazyAsyncEnumerator.cs, Line: 45, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #67 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #70 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityAdded.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityDeleted.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityModified.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #74 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #75 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #76 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryCache.Shared\QueryCacheItemTracker.cs, Line: 69, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #77 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferred.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #78 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbCommandTree.cs, Line: 26, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #80 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbProjectExpression.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterLazyLoading.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterProvider.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterProvider.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedChild`2.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #86 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedLazyLoading.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedProvider.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.EntityFramework.Plus.EF6.NET40
    #89 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 42, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #90 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF\DbParameter\DbParameter.CopyFrom.cs, Line: 82, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #91 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuery.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #95 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable\IQueryable.GetObjectQuerySafe.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #99 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #101 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\EF5_EF6\IQueryable`\IQueryable`.GetObjectQuery.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #102 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #104 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #105 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #106 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityAdded.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #107 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityDeleted.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #108 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\Audit\AuditEntityModified.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #109 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #110 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #111 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryCache.Shared\QueryCacheItemTracker.cs, Line: 69, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #112 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbCommandTree.cs, Line: 26, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #114 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbProjectExpression.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #115 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterLazyLoading.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #116 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #117 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterProvider.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #118 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterProvider.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #119 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedChild`2.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #120 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedLazyLoading.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #121 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #122 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedProvider.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.Test.EntityFramework.Plus.EF5
    #123 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\_Model\Methods\Insert.cs, Line: 45, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #124 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\_Model\Methods\Insert.cs, Line: 51, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #125 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\_Model\Methods\Insert.cs, Line: 57, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #126 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\_Model\Methods\Insert.cs, Line: 63, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #127 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\_Model\Methods\Insert.cs, Line: 69, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #128 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\_Model\Methods\Insert.cs, Line: 75, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #129 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntityModified\Inheritance_TPC.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #130 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntityModified\Inheritance_TPC.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #131 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntityModified\Inheritance_TPH.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntityModified\Inheritance_TPH.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #133 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntityModified\Inheritance_TPT.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntityModified\Inheritance_TPT.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftAdded\Inheritance_TPC.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #136 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftAdded\Inheritance_TPC.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #137 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftAdded\Inheritance_TPH.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftAdded\Inheritance_TPH.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #139 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftAdded\Inheritance_TPT.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #140 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftAdded\Inheritance_TPT.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #141 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftDeleted\Inheritance_TPC.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #142 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftDeleted\Inheritance_TPC.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #143 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftDeleted\Inheritance_TPH.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #144 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftDeleted\Inheritance_TPH.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #145 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftDeleted\Inheritance_TPT.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #146 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF5\Audit\EntitySoftDeleted\Inheritance_TPT.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.Test.EntityFramework.Plus.EF6
    #147 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\_Model\Methods\Insert.cs, Line: 46, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #148 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\_Model\Methods\Insert.cs, Line: 52, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #149 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\_Model\Methods\Insert.cs, Line: 58, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #150 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\_Model\Methods\Insert.cs, Line: 64, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #151 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\_Model\Methods\Insert.cs, Line: 70, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #152 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\_Model\Methods\Insert.cs, Line: 76, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #153 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntityModified\Inheritance_TPC.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #154 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntityModified\Inheritance_TPC.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #155 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntityModified\Inheritance_TPH.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #156 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntityModified\Inheritance_TPH.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #157 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntityModified\Inheritance_TPT.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #158 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntityModified\Inheritance_TPT.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftAdded\Inheritance_TPC.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftAdded\Inheritance_TPC.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftAdded\Inheritance_TPH.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftAdded\Inheritance_TPH.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftAdded\Inheritance_TPT.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #164 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftAdded\Inheritance_TPT.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #165 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftDeleted\Inheritance_TPC.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftDeleted\Inheritance_TPC.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftDeleted\Inheritance_TPH.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #168 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftDeleted\Inheritance_TPH.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #169 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftDeleted\Inheritance_TPT.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #170 Path: D:\a\1\s\src\test\Z.Test.EntityFramework.Plus.EF6\Audit\EntitySoftDeleted\Inheritance_TPT.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.EntityFramework.Plus.EFCore.NETStandard20
    #171 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LazyAsyncEnumerator\LazyAsyncEnumeratorCore.cs, Line: 39, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #172 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferred.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #179 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #180 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterChild`2.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #181 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterProvider.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.EntityFramework.Plus.EFCore3x.NETStandard20
    #183 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LazyAsyncEnumerator\LazyAsyncEnumeratorCore.cs, Line: 39, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #184 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #190 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferred.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #191 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #192 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryFuture.Shared\BaseQueryFuture.cs, Line: 650, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #193 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterChild`2.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #194 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #195 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterProvider.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #196 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedChild`2.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #197 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedProvider.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.EntityFramework.Plus.EFCore3x.NETStandard21
    #199 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LazyAsyncEnumerator\LazyAsyncEnumeratorCore.cs, Line: 39, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #200 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\_Internal\ExpressionExtensions.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #202 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessor.cs, Line: 30, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\src\shared\Z.EF.Plus._Core.Shared\LinqExpressionExtensions\LambdaExpression\LambdaExpression.GetPropertyOrFieldAccessors.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #204 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftAdded.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #205 Path: D:\a\1\s\src\shared\Z.EF.Plus.Audit.Shared\AuditConfiguration\SoftDeleted.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #206 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferred.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #207 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryDeferred.Shared\QueryDeferredExtensions.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #208 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryFuture.Shared\BaseQueryFuture.cs, Line: 650, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #209 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterChild`2.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #210 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #211 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterProvider.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #212 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedChild`2.cs, Line: 53, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #213 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedNullCollection.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #214 Path: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedProvider.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Z.Test.EntityFramework.Plus.EFCore20
    #215 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 45, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #216 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 51, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #217 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 57, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #218 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 63, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #219 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 69, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #220 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 75, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Z.Test.EntityFramework.Plus.EFCore30
    #221 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 45, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #222 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 51, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #223 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 57, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #224 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 63, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #225 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 69, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #226 Path: D:\a\1\s\src\Z.Test.EntityFramework.Plus.EFCore.Shared\_Model\Methods\Insert.cs, Line: 75, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



--- Rules Summary ---
R8: 177
R7: 30
R5: 17
R3: 2

--- Summary ---
Fixed ReSharper issues: 226
Fixed SonarQube issues: 19
Total fixed issues: 226

Finished in: 27 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbFilterExpression.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.Common.CommandTrees;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query interceptor filter database filter expression.</summary>
    public class QueryFilterInterceptorDbFilterExpression : DefaultExpressionVisitor
    {
        /// <summary>Identifier for the filter.</summary>
        public List<string> FilterID;

        /// <summary>Identifier for the hook.</summary>
        public string HookID;

        /// <summary>
        ///     Implements the visitor pattern for a predicate applied to filter an input set.
        /// </summary>
        /// <param name="expression">The filter expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbFilterExpression expression)
        {
            var predicate = expression.Predicate;
            var comparison = predicate as DbComparisonExpression;

            if (comparison != null)
            {
                var leftConstant = comparison.Left as DbConstantExpression;

                if (leftConstant != null)
                {
                    {
                        var valueString = leftConstant.Value as string;

                        if (valueString != null)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }

                var rightConstant = comparison.Right as DbConstantExpression;

                if (rightConstant != null)
                {
                    {
                        var valueString = rightConstant.Value as string;

                        if (valueString != null)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }
            }

            var baseExpression = base.Visit(expression);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.Common.CommandTrees;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query interceptor filter database filter expression.</summary>
    public class QueryFilterInterceptorDbFilterExpression : DefaultExpressionVisitor
    {
        /// <summary>Identifier for the filter.</summary>
        public List<string> FilterID;

        /// <summary>Identifier for the hook.</summary>
        public string HookID;

        /// <summary>
        ///     Implements the visitor pattern for a predicate applied to filter an input set.
        /// </summary>
        /// <param name="expression">The filter expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbFilterExpression expression)
        {
            var predicate = expression.Predicate;

            if (predicate is DbComparisonExpression comparison)
            {
                if (comparison.Left is DbConstantExpression leftConstant)
                {
                    {

                        if (leftConstant.Value is string valueString)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }

                if (comparison.Right is DbConstantExpression rightConstant)
                {
                    {
                        if (leftConstant.Value is string valueString)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }
            }

            var baseExpression = base.Visit(expression);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbFilterExpression.cs(69,29): error CS0165: Use of unassigned local variable 'leftConstant'
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Data.Entity;
using System.Data.Entity.Core.Common.CommandTrees;
using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure.Interception;
using Z.EntityFramework.Plus.QueryInterceptorFilter;

namespace Z.EntityFramework.Plus
{
    /// <summary>A database scan expression visitor.</summary>
    public class QueryFilterInterceptorDbScanExpression : DefaultExpressionVisitor
    {
        /// <summary>The context.</summary>
        public DbContext Context;

        /// <summary>The filtered expression.</summary>
        public DbExpression FilteredExpression;

        /// <summary>The filter query.</summary>
        public QueryFilterInterceptorApply FilterQuery;

        /// <summary>Context for the instance filter.</summary>
        public QueryFilterContextInterceptor InstanceFilterContext;

        /// <summary>
        ///     Implements the visitor pattern for a scan over an entity set or relationship set, as
        ///     indicated by the Target property.
        /// </summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbScanExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseType = expression.Target.ElementType;
            var fullName = baseType.FullName;

            baseExpression = ApplyFilter(baseExpression, fullName);

            return baseExpression;
        }

        /// <summary>Implements the visitor pattern for retrieving an instance property.</summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbPropertyExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseExpressionProperty = baseExpression as DbPropertyExpression;

            if (baseExpressionProperty == null)
            {
                return baseExpression;
            }

            var navProp = baseExpressionProperty.Property as NavigationProperty;
            if (navProp != null && baseExpression.ResultType.ToString().Contains("Transient.collection["))
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }
            else if (QueryFilterManager.AllowPropertyFilter && navProp != null)
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }

            return baseExpression;
        }

        /// <summary>Applies the filter.</summary>
        /// <param name="baseExpression">The base expression.</param>
        /// <param name="fullName">Name of the full.</param>
        /// <returns>A DbExpression.</returns>
        public DbExpression ApplyFilter(DbExpression baseExpression, string fullName)
        {
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetGlobalApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            var baseExpressionProperty = baseExpression as DbPropertyExpression;
                            NavigationProperty navProp = null;

                            if (baseExpressionProperty != null)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }

                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;

                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            var baseExpressionProperty = baseExpression as DbPropertyExpression;
                            NavigationProperty navProp = null;

                            if (baseExpressionProperty != null)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }
                            
                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;
 
                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }

            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Data.Entity;
using System.Data.Entity.Core.Common.CommandTrees;
using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure.Interception;
using Z.EntityFramework.Plus.QueryInterceptorFilter;

namespace Z.EntityFramework.Plus
{
    /// <summary>A database scan expression visitor.</summary>
    public class QueryFilterInterceptorDbScanExpression : DefaultExpressionVisitor
    {
        /// <summary>The context.</summary>
        public DbContext Context;

        /// <summary>The filtered expression.</summary>
        public DbExpression FilteredExpression;

        /// <summary>The filter query.</summary>
        public QueryFilterInterceptorApply FilterQuery;

        /// <summary>Context for the instance filter.</summary>
        public QueryFilterContextInterceptor InstanceFilterContext;

        /// <summary>
        ///     Implements the visitor pattern for a scan over an entity set or relationship set, as
        ///     indicated by the Target property.
        /// </summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbScanExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseType = expression.Target.ElementType;
            var fullName = baseType.FullName;

            baseExpression = ApplyFilter(baseExpression, fullName);

            return baseExpression;
        }

        /// <summary>Implements the visitor pattern for retrieving an instance property.</summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbPropertyExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseExpressionProperty = baseExpression as DbPropertyExpression;

            if (baseExpressionProperty == null)
            {
                return baseExpression;
            }

            if (baseExpressionProperty.Property is NavigationProperty navProp && baseExpression.ResultType.ToString().Contains("Transient.collection["))
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }
            else if (QueryFilterManager.AllowPropertyFilter && baseExpressionProperty.Property is NavigationProperty navProp)
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }

            return baseExpression;
        }

        /// <summary>Applies the filter.</summary>
        /// <param name="baseExpression">The base expression.</param>
        /// <param name="fullName">Name of the full.</param>
        /// <returns>A DbExpression.</returns>
        public DbExpression ApplyFilter(DbExpression baseExpression, string fullName)
        {
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetGlobalApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            NavigationProperty navProp = null;

                            if (baseExpression is DbPropertyExpression baseExpressionProperty)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }

                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;

                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            NavigationProperty navProp = null;

                            if (baseExpression is DbPropertyExpression baseExpressionProperty)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }
                            
                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;
 
                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }

            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(1,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(6,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(63,118): error CS0136: A local or parameter named 'navProp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(1,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(6,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbFilterExpression.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.Common.CommandTrees;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query interceptor filter database filter expression.</summary>
    public class QueryFilterInterceptorDbFilterExpression : DefaultExpressionVisitor
    {
        /// <summary>Identifier for the filter.</summary>
        public List<string> FilterID;

        /// <summary>Identifier for the hook.</summary>
        public string HookID;

        /// <summary>
        ///     Implements the visitor pattern for a predicate applied to filter an input set.
        /// </summary>
        /// <param name="expression">The filter expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbFilterExpression expression)
        {
            var predicate = expression.Predicate;
            var comparison = predicate as DbComparisonExpression;

            if (comparison != null)
            {
                var leftConstant = comparison.Left as DbConstantExpression;

                if (leftConstant != null)
                {
                    {
                        var valueString = leftConstant.Value as string;

                        if (valueString != null)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }

                var rightConstant = comparison.Right as DbConstantExpression;

                if (rightConstant != null)
                {
                    {
                        var valueString = rightConstant.Value as string;

                        if (valueString != null)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }
            }

            var baseExpression = base.Visit(expression);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.Common.CommandTrees;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query interceptor filter database filter expression.</summary>
    public class QueryFilterInterceptorDbFilterExpression : DefaultExpressionVisitor
    {
        /// <summary>Identifier for the filter.</summary>
        public List<string> FilterID;

        /// <summary>Identifier for the hook.</summary>
        public string HookID;

        /// <summary>
        ///     Implements the visitor pattern for a predicate applied to filter an input set.
        /// </summary>
        /// <param name="expression">The filter expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbFilterExpression expression)
        {
            var predicate = expression.Predicate;

            if (predicate is DbComparisonExpression comparison)
            {
                if (comparison.Left is DbConstantExpression leftConstant)
                {
                    {

                        if (leftConstant.Value is string valueString)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }

                if (comparison.Right is DbConstantExpression rightConstant)
                {
                    {
                        if (leftConstant.Value is string valueString)
                        {
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilter, StringComparison.InvariantCulture))
                            {
                                if (FilterID == null)
                                {
                                    FilterID = new List<string>();
                                }

                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);

                                // Add after visiting
                                FilterID.Add(valueString);

                                // It's a fake filter! Do nothing
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixHook, StringComparison.InvariantCulture))
                            {
                                HookID = valueString;

                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                            if (valueString.StartsWith(QueryFilterManager.PrefixFilterID, StringComparison.InvariantCulture))
                            {
                                // It's a fake filter! Do nothing
                                var baseInnerExpression = (DbFilterExpression)base.Visit(expression);
                                return baseInnerExpression.Input.Expression;
                            }
                        }
                    }
                }
            }

            var baseExpression = base.Visit(expression);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbFilterExpression.cs(69,29): error CS0165: Use of unassigned local variable 'leftConstant'
######################################################################


######################################################################
Nr: 14 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Data.Entity;
using System.Data.Entity.Core.Common.CommandTrees;
using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure.Interception;
using Z.EntityFramework.Plus.QueryInterceptorFilter;

namespace Z.EntityFramework.Plus
{
    /// <summary>A database scan expression visitor.</summary>
    public class QueryFilterInterceptorDbScanExpression : DefaultExpressionVisitor
    {
        /// <summary>The context.</summary>
        public DbContext Context;

        /// <summary>The filtered expression.</summary>
        public DbExpression FilteredExpression;

        /// <summary>The filter query.</summary>
        public QueryFilterInterceptorApply FilterQuery;

        /// <summary>Context for the instance filter.</summary>
        public QueryFilterContextInterceptor InstanceFilterContext;

        /// <summary>
        ///     Implements the visitor pattern for a scan over an entity set or relationship set, as
        ///     indicated by the Target property.
        /// </summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbScanExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseType = expression.Target.ElementType;
            var fullName = baseType.FullName;

            baseExpression = ApplyFilter(baseExpression, fullName);

            return baseExpression;
        }

        /// <summary>Implements the visitor pattern for retrieving an instance property.</summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbPropertyExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseExpressionProperty = baseExpression as DbPropertyExpression;

            if (baseExpressionProperty == null)
            {
                return baseExpression;
            }

            var navProp = baseExpressionProperty.Property as NavigationProperty;
            if (navProp != null && baseExpression.ResultType.ToString().Contains("Transient.collection["))
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }
            else if (QueryFilterManager.AllowPropertyFilter && navProp != null)
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }

            return baseExpression;
        }

        /// <summary>Applies the filter.</summary>
        /// <param name="baseExpression">The base expression.</param>
        /// <param name="fullName">Name of the full.</param>
        /// <returns>A DbExpression.</returns>
        public DbExpression ApplyFilter(DbExpression baseExpression, string fullName)
        {
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetGlobalApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            var baseExpressionProperty = baseExpression as DbPropertyExpression;
                            NavigationProperty navProp = null;

                            if (baseExpressionProperty != null)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }

                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;

                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            var baseExpressionProperty = baseExpression as DbPropertyExpression;
                            NavigationProperty navProp = null;

                            if (baseExpressionProperty != null)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }
                            
                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;
 
                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }

            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Data.Entity;
using System.Data.Entity.Core.Common.CommandTrees;
using System.Data.Entity.Core.Common.CommandTrees.ExpressionBuilder;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure.Interception;
using Z.EntityFramework.Plus.QueryInterceptorFilter;

namespace Z.EntityFramework.Plus
{
    /// <summary>A database scan expression visitor.</summary>
    public class QueryFilterInterceptorDbScanExpression : DefaultExpressionVisitor
    {
        /// <summary>The context.</summary>
        public DbContext Context;

        /// <summary>The filtered expression.</summary>
        public DbExpression FilteredExpression;

        /// <summary>The filter query.</summary>
        public QueryFilterInterceptorApply FilterQuery;

        /// <summary>Context for the instance filter.</summary>
        public QueryFilterContextInterceptor InstanceFilterContext;

        /// <summary>
        ///     Implements the visitor pattern for a scan over an entity set or relationship set, as
        ///     indicated by the Target property.
        /// </summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbScanExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseType = expression.Target.ElementType;
            var fullName = baseType.FullName;

            baseExpression = ApplyFilter(baseExpression, fullName);

            return baseExpression;
        }

        /// <summary>Implements the visitor pattern for retrieving an instance property.</summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The implemented visitor.</returns>
        public override DbExpression Visit(DbPropertyExpression expression)
        {
            var baseExpression = base.Visit(expression);
            var baseExpressionProperty = baseExpression as DbPropertyExpression;

            if (baseExpressionProperty == null)
            {
                return baseExpression;
            }

            if (baseExpressionProperty.Property is NavigationProperty navProp && baseExpression.ResultType.ToString().Contains("Transient.collection["))
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }
            else if (QueryFilterManager.AllowPropertyFilter && baseExpressionProperty.Property is NavigationProperty navProp)
            {
                var targetEntityType = navProp.ToEndMember.GetEntityType();
                var fullName = targetEntityType.FullName;

                baseExpression = ApplyFilter(baseExpression, fullName);
            }

            return baseExpression;
        }

        /// <summary>Applies the filter.</summary>
        /// <param name="baseExpression">The base expression.</param>
        /// <param name="fullName">Name of the full.</param>
        /// <returns>A DbExpression.</returns>
        public DbExpression ApplyFilter(DbExpression baseExpression, string fullName)
        {
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetGlobalApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            NavigationProperty navProp = null;

                            if (baseExpression is DbPropertyExpression baseExpressionProperty)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }

                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;

                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }
            if (InstanceFilterContext.TypeByEntitySetBase.ContainsKey(fullName))
            {
                var filters = InstanceFilterContext.GetApplicableFilter(fullName);
                var type = InstanceFilterContext.TypeByEntitySetBase[fullName];

                if (filters.Count > 0)
                {
                    foreach (var filter in filters)
                    {
                        var filterQueryEnabled = FilterQuery.IsEnabled(filter);
                        if ((filterQueryEnabled.HasValue && !filterQueryEnabled.Value)
                            || (!filterQueryEnabled.HasValue && !filter.IsTypeEnabled(type)))
                        {
                            continue;
                        }

                        var expression2 = filter.GetDbExpression(Context, type);

                        if (expression2 != null)
                        {
                            NavigationProperty navProp = null;

                            if (baseExpression is DbPropertyExpression baseExpressionProperty)
                            {
                                navProp = baseExpressionProperty.Property as NavigationProperty;
                            }
                            
                            if (QueryFilterManager.AllowPropertyFilter && navProp != null && !baseExpression.ResultType.ToString().Contains("Transient.collection["))
                            {
                                // Filter property
                                expression2 = DbExpressionBuilder.Take(expression2, 1);
                                expression2 = DbExpressionBuilder.Element(expression2);

                                baseExpression = expression2;
 
                            }
                            else
                            {
                                var visitor = new QueryFilterInterceptorDbProjectExpression();
                                visitor.DbScanExpression = baseExpression;
                                visitor.ParameterCollection = QueryFilterManager.DbExpressionParameterByHook[expression2];

                                var filetered = expression2.Accept(visitor);

                                baseExpression = filetered;
                            }
                        }
                    }
                }
            }

            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(1,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(6,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(63,118): error CS0136: A local or parameter named 'navProp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(1,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\shared\Z.EF.Plus.QueryFilterInterceptor.Shared\QueryFilterInterceptorDbScanExpression.cs(6,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 15 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilter.Shared\QueryIncludeFilterPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 16 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 17 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 18 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 19 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include filter expression reduce visitor.</summary>
    public class QueryIncludeFilterExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeFilterExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include filter expression reduce visitor.</summary>
    public class QueryIncludeFilterExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeFilterExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 20 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 21 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 22 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include filter expression reduce visitor.</summary>
    public class QueryIncludeFilterExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeFilterExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include filter expression reduce visitor.</summary>
    public class QueryIncludeFilterExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeFilterExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 23 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 24 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 25 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 26 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 27 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 28 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include filter expression reduce visitor.</summary>
    public class QueryIncludeFilterExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeFilterExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include filter expression reduce visitor.</summary>
    public class QueryIncludeFilterExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeFilterExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 29 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 30 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeFilterPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeFilterCore.Shared\QueryIncludeFilterPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 31 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    /// <summary>A query include optimized expression reduce visitor.</summary>
    public class QueryIncludeOptimizedExpressionReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression NodeToReduce;
        public Expression RootExpression;

        /// <summary>Adds a member expression.</summary>
        /// <param name="node">The node.</param>
        /// <param name="memberExpression">The member expression.</param>
        /// <param name="outExpression">[out] The out expression.</param>
        /// <returns>true if it succeeds, false if it fails.</returns>
        public bool AddMemberExpression(LambdaExpression node, MemberExpression memberExpression, out Expression outExpression)
        {
            outExpression = null;

            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                if (memberExpression == NodeToReduce)
                {
                    var reduceExpression = memberExpression.Expression;

                    var sourceType = node.Parameters[0].Type;
                    var elementType = reduceExpression.Type;

                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                    var lambdaMethod = typeof (Expression).GetMethods()
                        .Single(x => x.Name == "Lambda"
                                     && x.IsGenericMethod
                                     && x.GetParameters().Length == 2
                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);

                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                    outExpression = newExpression;
                    return true;
                }

                currentExpression = memberExpression.Expression;
            }

            return false;
        }

        /// <summary>
        ///     Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.
        /// </summary>
        /// <typeparam name="T">The type of the delegate.</typeparam>
        /// <param name="node">The expression to visit.</param>
        /// <returns>
        ///     The modified expression, if it or any subexpression was modified; otherwise, returns the
        ///     original expression.
        /// </returns>
        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    Expression outExpression;
                    if (AddMemberExpression(node, memberExpression, out outExpression))
                    {
                        return outExpression;
                    }
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            Expression outExpression;
                            if (AddMemberExpression(node, memberExpression, out outExpression))
                            {
                                return outExpression;
                            }
                        }

                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ALL Select && SelectMany method are modified but only the last is reduced
                            if (callExpression == NodeToReduce)
                            {
                                // ADD
                                // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                                // x => x.Many.Select(y => y.Many) to x => x.Many

                                var reduceExpression = callExpression.Arguments[0];

                                var isEnumerable = reduceExpression.Type.GetGenericArguments().Length == 1;

                                if (isEnumerable)
                                {
                                    var typeSource = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type.GetGenericArguments()[0];

                                    var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                                else
                                {
                                    var sourceType = node.Parameters[0].Type;
                                    var elementType = reduceExpression.Type;

                                    var genericFunc = typeof (Func<,>).MakeGenericType(sourceType, elementType);
                                    var lambdaMethod = typeof (Expression).GetMethods()
                                        .Single(x => x.Name == "Lambda"
                                                     && x.IsGenericMethod
                                                     && x.GetParameters().Length == 2
                                                     && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                    var newExpression = (LambdaExpression) lambdaMethod.Invoke(null, new object[] {reduceExpression, node.Parameters});

                                    return newExpression;
                                }
                            }

                            // TRY reduce lambda...
                            {
                                var visitor = new QueryIncludeOptimizedExpressionReduceVisitor();
                                visitor.RootExpression = callExpression.Arguments[1];
                                visitor.NodeToReduce = NodeToReduce;
                                var reducedExpression = visitor.Visit(callExpression.Arguments[1]);

                                if (reducedExpression != callExpression.Arguments[1])
                                {
                                    MethodCallExpression reducedMethod;

                                    // FIX method
                                    {
                                        var baseMethod = callExpression.Method.GetGenericMethodDefinition();
                                        var sourceType = callExpression.Arguments[0].Type.GetGenericArguments()[0];
                                        var elementType = callExpression.Method.Name == "SelectMany" ?
                                            reducedExpression.Type.GetGenericArguments()[1].GetGenericArguments()[0] :
                                            reducedExpression.Type.GetGenericArguments()[1];


                                        var genericMethod = baseMethod.MakeGenericMethod(sourceType, elementType);
                                        var arguments = callExpression.Arguments.ToList();
                                        arguments[1] = reducedExpression;

                                        reducedMethod = Expression.Call(null, genericMethod, arguments);
                                    }

                                    // FIX lambda expression
                                    {
                                        var typeSource = node.Parameters[0].Type;
                                        var elementType = reducedMethod.Type.GetGenericArguments()[0];

                                        var genericFunc = typeof (Func<,>).MakeGenericType(typeSource, typeof (IEnumerable<>).MakeGenericType(elementType));
                                        var lambdaMethod = typeof (Expression).GetMethods()
                                            .Single(x => x.Name == "Lambda"
                                                         && x.IsGenericMethod
                                                         && x.GetParameters().Length == 2
                                                         && !x.GetParameters()[1].ParameterType.IsArray).MakeGenericMethod(genericFunc);
                                        var newExpression = (Expression) lambdaMethod.Invoke(null, new object[] {reducedMethod, node.Parameters});

                                        return newExpression;
                                    }
                                }
                            }
                        }

                        currentNode = callExpression.Arguments[0];
                    }
                }
            }

            var baseExpression = base.VisitLambda(node);
            return baseExpression;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(90,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionReduceVisitor.cs(92,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 32 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedExpressionToReduceVisitor : ExpressionVisitor
    {
        public List<Expression> Expressions = new List<Expression>();
        public List<Expression> LambdaToChecks = new List<Expression>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            while ((memberExpression = currentExpression as MemberExpression) != null && memberExpression.Expression is MemberExpression)
            {
                Expressions.Add(memberExpression);

                currentExpression = memberExpression.Expression;
            }
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            Expressions.Add(callExpression);
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = callExpression.Arguments[0] as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                        }

                        break;
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(61,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedExpressionToReduceVisitor.cs(63,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 33 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;
                var memberExpression = node.Body as MemberExpression;

                if (memberExpression != null)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;
                        if (memberExpression != null)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Z.EntityFramework.Plus
{
    public class QueryIncludeOptimizedPathVisitor : ExpressionVisitor
    {
        public List<Expression> LambdaToChecks = new List<Expression>();
        public List<string> Paths = new List<string>();
        public Expression RootExpression;

        public void AddMemberExpression(MemberExpression memberExpression)
        {
            // ADD
            // x => x.Single.Single.Many to x => x.Single.Single
            // x => x.Single.Single to x => x.Single
            // 
            // NOT
            // x => x.Single

            Expression currentExpression = memberExpression;

            var reverseList = new List<string>();
            while ((memberExpression = currentExpression as MemberExpression) != null)
            {
                reverseList.Add(memberExpression.Member.Name);

                currentExpression = memberExpression.Expression;
            }
            reverseList.Reverse();
            Paths.AddRange(reverseList);
        }

        protected override Expression VisitLambda<T>(Expression<T> node)
        {
            if (node == RootExpression || LambdaToChecks.Contains(node))
            {
                var currentNode = node.Body;

                if (node.Body is MemberExpression memberExpression)
                {
                    AddMemberExpression(memberExpression);
                }
                else
                {
                    MethodCallExpression callExpression;
                    while ((callExpression = currentNode as MethodCallExpression) != null)
                    {
                        var isSelectMethod = callExpression.Method.ReflectedType != null
                                             && callExpression.Method.ReflectedType.FullName == "System.Linq.Enumerable"
                                             && (callExpression.Method.Name == "Select"
                                                 || callExpression.Method.Name == "SelectMany");

                        if (isSelectMethod)
                        {
                            // ADD
                            // x => x.Many.Select(y => Many.Select(z => z.Many) to x.Many.Select(y => y.Many)
                            // x => x.Many.Select(y => y.Many) to x => x.Many
                            LambdaToChecks.Add(callExpression.Arguments[1]);
                        }

                        currentNode = callExpression.Arguments[0];

                        // ONLY one member expression can exist by lambda expression
                        memberExpression = currentNode as MemberExpression;

                        if (node.Body is MemberExpression memberExpression)
                        {
                            AddMemberExpression(memberExpression);
                            break;
                        }
                    }
                }
            }

            return base.VisitLambda(node);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(65,25): error CS0841: Cannot use local variable 'memberExpression' before it is declared,D:\a\1\s\src\shared\Z.EF.Plus.QueryIncludeOptimized.Shared\QueryIncludeOptimizedPathVisitor.cs(67,59): error CS0136: A local or parameter named 'memberExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


