Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: ICSharpCode.Decompiler
    #1 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\CallBuilder.cs, Line: 299, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #2 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs, Line: 1676, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\CSharpDecompiler.cs, Line: 1723, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #4 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs, Line: 1058, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\ExpressionBuilder.cs, Line: 3057, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #6 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs, Line: 119, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #7 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs, Line: 179, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #9 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpAmbience.cs, Line: 67, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #11 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 2270, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 2316, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 2855, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 2974, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #15 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 442, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #16 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 446, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #17 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 450, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #18 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #19 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #20 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #21 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #22 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #23 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #24 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #25 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 525, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\CSharpOutputVisitor.cs, Line: 668, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs, Line: 109, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #28 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #29 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs, Line: 146, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #31 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs, Line: 150, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #32 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertMissingTokensDecorator.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs, Line: 234, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs, Line: 243, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #36 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs, Line: 287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertParenthesesVisitor.cs, Line: 355, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs, Line: 527, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs, Line: 530, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs, Line: 560, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpInvocationResolveResult.cs, Line: 110, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpOperators.cs, Line: 1137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1517, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1531, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1821, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1865, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1961, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1986, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 1997, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #50 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2275, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2319, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2324, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2397, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2421, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2425, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2429, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 2433, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 381, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpResolver.cs, Line: 396, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\MemberLookup.cs, Line: 757, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #61 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\MethodGroupResolveResult.cs, Line: 229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #62 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs, Line: 290, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs, Line: 359, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #64 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs, Line: 441, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #65 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs, Line: 508, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #66 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs, Line: 796, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #67 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs, Line: 798, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs, Line: 287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs, Line: 291, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #70 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs, Line: 401, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs, Line: 421, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs, Line: 528, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs, Line: 560, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #74 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs, Line: 333, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #75 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\StatementBuilder.cs, Line: 431, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #76 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs, Line: 532, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #77 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs, Line: 602, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs, Line: 830, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #79 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs, Line: 911, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #80 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstType.cs, Line: 137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\ComposedType.cs, Line: 150, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\ComposedType.cs, Line: 293, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\CSharpModifierToken.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\CSharpTokenNode.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\DocumentationReference.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AnonymousMethodExpression.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AnonymousTypeCreateExpression.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ArrayCreateExpression.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #89 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ArrayInitializerExpression.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #90 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AsExpression.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\AssignmentExpression.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\BaseReferenceExpression.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\BinaryOperatorExpression.cs, Line: 110, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\CastExpression.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #95 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\CheckedExpression.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ConditionalExpression.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\DefaultValueExpression.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\DirectionExpression.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #99 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ErrorExpression.cs, Line: 78, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\IdentifierExpression.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #101 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\IndexerExpression.cs, Line: 91, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #102 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\InterpolatedStringExpression.cs, Line: 137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\InterpolatedStringExpression.cs, Line: 173, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #104 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\InterpolatedStringExpression.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #105 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\InvocationExpression.cs, Line: 91, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #106 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\IsExpression.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #107 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\LambdaExpression.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #108 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\MemberReferenceExpression.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #109 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\NamedArgumentExpression.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #110 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\NamedExpression.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #111 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\NullReferenceExpression.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #112 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ObjectCreateExpression.cs, Line: 103, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\OutVarDeclarationExpression.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #114 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ParenthesizedExpression.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #115 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\PointerReferenceExpression.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #116 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\PrimitiveExpression.cs, Line: 148, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #117 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #118 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 214, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #119 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 267, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #120 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 303, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #121 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 412, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #122 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 451, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #123 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 496, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 538, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #125 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 585, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #126 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\QueryExpression.cs, Line: 82, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #127 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\SizeOfExpression.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #128 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\StackAllocExpression.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #129 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\SwitchExpression.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #130 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\SwitchExpression.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #131 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ThisReferenceExpression.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\ThrowExpression.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #133 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\TypeOfExpression.cs, Line: 82, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\TypeReferenceExpression.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UnaryOperatorExpression.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #136 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UncheckedExpression.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #137 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Expressions\UndocumentedExpression.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\Attribute.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #139 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\AttributeSection.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #140 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\Comment.cs, Line: 149, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #141 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\Constraint.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #142 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\DelegateDeclaration.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #143 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\ExternAliasDeclaration.cs, Line: 89, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #144 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\NamespaceDeclaration.cs, Line: 154, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #145 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\NamespaceDeclaration.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #146 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\PreProcessorDirective.cs, Line: 199, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #147 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\TypeDeclaration.cs, Line: 148, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #148 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\TypeParameterDeclaration.cs, Line: 110, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #149 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\UsingAliasDeclaration.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #150 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\UsingDeclaration.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #151 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\GeneralScope\UsingDeclaration.cs, Line: 76, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #152 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #153 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs, Line: 172, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #154 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs, Line: 194, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #155 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs, Line: 213, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #156 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs, Line: 220, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #157 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\IAnnotatable.cs, Line: 238, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #158 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Identifier.cs, Line: 170, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\MemberType.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\MemberType.cs, Line: 132, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\PrimitiveType.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\SimpleType.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\BlockStatement.cs, Line: 146, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #164 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\BreakStatement.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #165 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\CheckedStatement.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\ContinueStatement.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\DoWhileStatement.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #168 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\EmptyStatement.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #169 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\ExpressionStatement.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #170 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\FixedStatement.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #171 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\ForeachStatement.cs, Line: 102, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #172 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\ForStatement.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\GotoStatement.cs, Line: 134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\GotoStatement.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\GotoStatement.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\IfElseStatement.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\LabelStatement.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\LockStatement.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #179 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\ReturnStatement.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #180 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\SwitchStatement.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #181 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\SwitchStatement.cs, Line: 225, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\SwitchStatement.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #183 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\ThrowStatement.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\TryCatchStatement.cs, Line: 257, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\TryCatchStatement.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\UncheckedStatement.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\UnsafeStatement.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\UsingStatement.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\VariableDeclarationStatement.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #190 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\WhileStatement.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #191 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\YieldBreakStatement.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #192 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\Statements\YieldReturnStatement.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #193 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\SyntaxExtensions.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #194 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\SyntaxTree.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #195 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TextLocation.cs, Line: 202, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #196 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TextLocation.cs, Line: 215, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #197 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\Accessor.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\ConstructorDeclaration.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #199 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\ConstructorDeclaration.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #200 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\DestructorDeclaration.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\EnumMemberDeclaration.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #202 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\EventDeclaration.cs, Line: 145, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\EventDeclaration.cs, Line: 82, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #204 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\FieldDeclaration.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #205 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\FixedFieldDeclaration.cs, Line: 65, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #206 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\FixedVariableInitializer.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #207 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\IndexerDeclaration.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #208 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\MethodDeclaration.cs, Line: 96, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #209 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\OperatorDeclaration.cs, Line: 303, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #210 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\ParameterDeclaration.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #211 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\PropertyDeclaration.cs, Line: 103, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #212 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeMembers\VariableInitializer.cs, Line: 172, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #213 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs, Line: 1672, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #214 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs, Line: 499, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #215 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\TypeSystemAstBuilder.cs, Line: 912, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #216 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #217 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs, Line: 335, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #218 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\AddCheckedBlocks.cs, Line: 347, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #219 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #220 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs, Line: 177, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #221 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #222 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CombineQueryExpressions.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #223 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs, Line: 43, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #224 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #225 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\CustomPatterns.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #226 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\DecimalConstantTransform.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #227 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs, Line: 206, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #228 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\DeclareVariables.cs, Line: 281, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #229 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\EscapeInvalidIdentifiers.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #230 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #231 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceQueryExpressions.cs, Line: 265, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUnsafeModifier.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #233 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\IntroduceUnsafeModifier.cs, Line: 91, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #234 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs, Line: 1148, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #235 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs, Line: 668, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #236 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PatternStatementTransform.cs, Line: 739, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #237 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #238 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #239 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #240 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\PrettifyAssignments.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #241 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs, Line: 304, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #242 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\ReplaceMethodCallsWithOperators.cs, Line: 432, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #243 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\AliasNamespaceReference.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #244 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #245 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\MemberTypeOrNamespaceReference.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #246 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\ResolvedUsingScope.cs, Line: 140, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #247 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\ResolvedUsingScope.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #248 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #249 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\SimpleTypeOrNamespaceReference.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #250 Path: D:\a\1\s\ICSharpCode.Decompiler\CSharp\TypeSystem\TypeOrNamespaceReference.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #251 Path: D:\a\1\s\ICSharpCode.Decompiler\DecompileRun.cs, Line: 45, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #252 Path: D:\a\1\s\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs, Line: 182, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #253 Path: D:\a\1\s\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs, Line: 190, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #254 Path: D:\a\1\s\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #255 Path: D:\a\1\s\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #256 Path: D:\a\1\s\ICSharpCode.Decompiler\Disassembler\DisassemblerHelpers.cs, Line: 62, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #257 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #258 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #259 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\IdStringProvider.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #260 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\XmlDocumentationElement.cs, Line: 179, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #261 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\XmlDocumentationElement.cs, Line: 183, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #262 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\XmlDocumentationElement.cs, Line: 187, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #263 Path: D:\a\1\s\ICSharpCode.Decompiler\Documentation\XmlDocumentationElement.cs, Line: 229, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #264 Path: D:\a\1\s\ICSharpCode.Decompiler\FlowAnalysis\ControlFlowNode.cs, Line: 132, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #265 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs, Line: 327, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #266 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs, Line: 335, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs, Line: 573, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #268 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs, Line: 579, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #270 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\DetectPinnedRegions.cs, Line: 930, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #271 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ControlFlow\SymbolicExecution.cs, Line: 95, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #272 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1210, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #273 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1280, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #274 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1280, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #275 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1460, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #276 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1472, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #277 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1484, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #278 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1495, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #279 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 1506, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #280 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs, Line: 282, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #281 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1037, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #282 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1069, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #283 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #284 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #285 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #286 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1193, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #287 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1221, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #288 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1255, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #289 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1330, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #290 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1438, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1529, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #292 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1554, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #293 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1629, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #294 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1654, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #295 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1784, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #296 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1809, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1834, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #298 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 1940, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2085, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #300 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #301 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2154, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #302 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2225, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #303 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2262, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #304 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #305 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2365, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #306 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2440, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #307 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2579, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #308 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2684, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #309 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2712, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #310 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2740, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #311 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2780, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #312 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2809, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #313 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2846, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #314 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2883, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #315 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2920, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #316 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2957, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #317 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 2994, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #318 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3031, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #319 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3059, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #320 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #321 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #322 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3218, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #323 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3260, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #324 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3299, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #325 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3336, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #326 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3390, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #327 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3534, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #328 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3685, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #329 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3797, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #330 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3836, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #331 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3890, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #332 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 3935, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #333 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4048, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #334 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4187, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #335 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #336 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4302, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #337 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4356, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #338 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4481, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #339 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4523, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #340 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4560, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #341 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4597, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #342 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4639, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #343 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4722, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #344 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4854, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #345 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 4963, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #346 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5052, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #347 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5097, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #348 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5213, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #349 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5304, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #350 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5404, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #351 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5487, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #352 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5576, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #353 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5664, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #354 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5769, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #355 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5845, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #356 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5916, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #357 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 5987, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #358 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6058, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #359 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #360 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6212, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #361 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6354, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #362 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6406, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #363 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6434, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #364 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6488, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #365 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6584, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #366 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6680, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #367 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6705, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #368 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 6730, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #369 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 689, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #370 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 726, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #371 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 754, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #372 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8092, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #373 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #374 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8110, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #375 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #376 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #377 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #378 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #379 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #380 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #381 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8195, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #382 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8206, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #383 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8217, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #384 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8228, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #385 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8241, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #386 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8254, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #387 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8267, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #388 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8280, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #389 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8291, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #390 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8302, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #391 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8313, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #392 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8324, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #393 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8335, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #394 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8346, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #395 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 835, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #396 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8357, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #397 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8366, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #398 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8377, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #399 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8390, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #400 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8405, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #401 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8416, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #402 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8427, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #403 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8438, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #404 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8451, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #405 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8466, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #406 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8481, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8494, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8505, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8518, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #410 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8531, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #411 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8544, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #412 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8559, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #413 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8572, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #414 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8585, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #415 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8598, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #416 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 860, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #417 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8609, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #418 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8620, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #419 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8631, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #420 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8640, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #421 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8651, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #422 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8664, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #423 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8677, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #424 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8692, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #425 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8707, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #426 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8720, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #427 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8731, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #428 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8744, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #429 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 8755, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #430 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions.cs, Line: 885, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #431 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\Branch.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #432 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\CallInstruction.cs, Line: 166, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #433 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #434 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #435 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #436 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 148, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #437 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 160, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #438 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 172, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #439 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #440 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 190, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #441 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 204, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #442 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #443 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 228, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #444 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 234, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #445 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 270, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #446 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 289, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #447 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 308, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #448 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 338, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #449 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 522, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #450 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 528, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #451 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 542, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #452 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #453 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Instructions\PatternMatching.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #454 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformCollectionAndObjectInitializers.cs, Line: 484, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #455 Path: D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformExpressionTrees.cs, Line: 741, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #456 Path: D:\a\1\s\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\TextScanner.cs, Line: 133, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #457 Path: D:\a\1\s\ICSharpCode.Decompiler\Metadata\LightJson\Serialization\TextScanner.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #458 Path: D:\a\1\s\ICSharpCode.Decompiler\Output\TextTokenWriter.cs, Line: 209, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #459 Path: D:\a\1\s\ICSharpCode.Decompiler\Semantics\Conversion.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #460 Path: D:\a\1\s\ICSharpCode.Decompiler\Semantics\Conversion.cs, Line: 341, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #461 Path: D:\a\1\s\ICSharpCode.Decompiler\Semantics\Conversion.cs, Line: 400, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #462 Path: D:\a\1\s\ICSharpCode.Decompiler\Semantics\LocalResolveResult.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #463 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ArrayType.cs, Line: 220, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #464 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ArrayType.cs, Line: 91, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #465 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ByReferenceType.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #466 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ByReferenceType.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #467 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\AbstractFreezable.cs, Line: 65, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #468 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\DefaultAssemblyReference.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #469 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\GetClassTypeReference.cs, Line: 151, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #470 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\LocalFunctionMethod.cs, Line: 73, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #471 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\NestedTypeReference.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #472 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\NestedTypeReference.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #473 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\SpecializedMethod.cs, Line: 274, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #474 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\TypeParameterReference.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #475 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #476 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\InheritanceHelper.cs, Line: 141, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #477 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\IntersectionType.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #478 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\NullableType.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #479 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\NullableType.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #480 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ParameterizedType.cs, Line: 442, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #481 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\PointerType.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #482 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\PointerType.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #483 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ReflectionHelper.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #484 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #485 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #486 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #487 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs, Line: 516, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #488 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\TypeSystemExtensions.cs, Line: 549, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #489 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\VarArgInstanceMethod.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #490 Path: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\VarArgInstanceMethod.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #491 Path: D:\a\1\s\ICSharpCode.Decompiler\Util\BusyManager.cs, Line: 52, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #492 Path: D:\a\1\s\ICSharpCode.Decompiler\Util\Interval.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #493 Path: D:\a\1\s\ICSharpCode.Decompiler\Util\Interval.cs, Line: 110, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #494 Path: D:\a\1\s\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs, Line: 281, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #495 Path: D:\a\1\s\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs, Line: 408, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R8: 431
R5: 39
R9: 20
R2: 2
R7: 2
R4: 1

--- Summary ---
Fixed ReSharper issues: 493
Fixed SonarQube issues: 40
Total fixed issues: 495

Finished in: 0 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

using ICSharpCode.Decompiler.CSharp.OutputVisitor;
using ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching;
using ICSharpCode.Decompiler.TypeSystem;

namespace ICSharpCode.Decompiler.CSharp.Syntax
{
	public abstract class AstNode : AbstractAnnotatable, IFreezable, INode, ICloneable
	{
		// the Root role must be available when creating the null nodes, so we can't put it in the Roles class
		internal static readonly Role<AstNode> RootRole = new Role<AstNode>("Root");

		#region Null
		public static readonly AstNode Null = new NullAstNode();

		sealed class NullAstNode : AstNode
		{
			public override NodeType NodeType {
				get {
					return NodeType.Unknown;
				}
			}

			public override bool IsNull {
				get {
					return true;
				}
			}

			public override void AcceptVisitor(IAstVisitor visitor)
			{
				visitor.VisitNullNode(this);
			}

			public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
			{
				return visitor.VisitNullNode(this);
			}

			public override S AcceptVisitor<T, S>(IAstVisitor<T, S> visitor, T data)
			{
				return visitor.VisitNullNode(this, data);
			}

			protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
			{
				return other == null || other.IsNull;
			}
		}
		#endregion

		#region PatternPlaceholder
		public static implicit operator AstNode(PatternMatching.Pattern pattern)
		{
			return pattern != null ? new PatternPlaceholder(pattern) : null;
		}

		sealed class PatternPlaceholder : AstNode, INode
		{
			readonly PatternMatching.Pattern child;

			public PatternPlaceholder(PatternMatching.Pattern child)
			{
				this.child = child;
			}

			public override NodeType NodeType {
				get { return NodeType.Pattern; }
			}

			public override void AcceptVisitor(IAstVisitor visitor)
			{
				visitor.VisitPatternPlaceholder(this, child);
			}

			public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
			{
				return visitor.VisitPatternPlaceholder(this, child);
			}

			public override S AcceptVisitor<T, S>(IAstVisitor<T, S> visitor, T data)
			{
				return visitor.VisitPatternPlaceholder(this, child, data);
			}

			protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
			{
				return child.DoMatch(other, match);
			}

			bool PatternMatching.INode.DoMatchCollection(Role role, PatternMatching.INode pos, PatternMatching.Match match, PatternMatching.BacktrackingInfo backtrackingInfo)
			{
				return child.DoMatchCollection(role, pos, match, backtrackingInfo);
			}
		}
		#endregion

		AstNode parent;
		AstNode prevSibling;
		AstNode nextSibling;
		AstNode firstChild;
		AstNode lastChild;

		// Flags, from least significant to most significant bits:
		// - Role.RoleIndexBits: role index
		// - 1 bit: IsFrozen
		protected uint flags = RootRole.Index;
		// Derived classes may also use a few bits,
		// for example Identifier uses 1 bit for IsVerbatim

		const uint roleIndexMask = (1u << Role.RoleIndexBits) - 1;
		const uint frozenBit = 1u << Role.RoleIndexBits;
		protected const int AstNodeFlagsUsedBits = Role.RoleIndexBits + 1;

		protected AstNode()
		{
			if (IsNull)
				Freeze();
		}

		public bool IsFrozen {
			get { return (flags & frozenBit) != 0; }
		}

		public void Freeze()
		{
			if (!IsFrozen)
			{
				for (AstNode child = firstChild; child != null; child = child.nextSibling)
					child.Freeze();
				flags |= frozenBit;
			}
		}

		protected void ThrowIfFrozen()
		{
			if (IsFrozen)
				throw new InvalidOperationException("Cannot mutate frozen " + GetType().Name);
		}

		public abstract NodeType NodeType {
			get;
		}

		public virtual bool IsNull {
			get {
				return false;
			}
		}

		public virtual TextLocation StartLocation {
			get {
				var child = firstChild;
				if (child == null)
					return TextLocation.Empty;
				return child.StartLocation;
			}
		}

		public virtual TextLocation EndLocation {
			get {
				var child = lastChild;
				if (child == null)
					return TextLocation.Empty;
				return child.EndLocation;
			}
		}

		public AstNode Parent {
			get { return parent; }
		}

		public Role Role {
			get {
				return Role.GetByIndex(flags & roleIndexMask);
			}
			set {
				if (value == null)
					throw new ArgumentNullException(nameof(value));
				if (!value.IsValid(this))
					throw new ArgumentException("This node is not valid in the new role.");
				ThrowIfFrozen();
				SetRole(value);
			}
		}

		internal uint RoleIndex {
			get { return flags & roleIndexMask; }
		}

		void SetRole(Role role)
		{
			flags = (flags & ~roleIndexMask) | role.Index;
		}

		public AstNode NextSibling {
			get { return nextSibling; }
		}

		public AstNode PrevSibling {
			get { return prevSibling; }
		}

		public AstNode FirstChild {
			get { return firstChild; }
		}

		public AstNode LastChild {
			get { return lastChild; }
		}

		public bool HasChildren {
			get {
				return firstChild != null;
			}
		}

		public IEnumerable<AstNode> Children {
			get {
				AstNode next;
				for (AstNode cur = firstChild; cur != null; cur = next)
				{
					Debug.Assert(cur.parent == this);
					// Remember next before yielding cur.
					// This allows removing/replacing nodes while iterating through the list.
					next = cur.nextSibling;
					yield return cur;
				}
			}
		}

		/// <summary>
		/// Gets the ancestors of this node (excluding this node itself)
		/// </summary>
		public IEnumerable<AstNode> Ancestors {
			get {
				for (AstNode cur = parent; cur != null; cur = cur.parent)
				{
					yield return cur;
				}
			}
		}

		/// <summary>
		/// Gets the ancestors of this node (including this node itself)
		/// </summary>
		public IEnumerable<AstNode> AncestorsAndSelf {
			get {
				for (AstNode cur = this; cur != null; cur = cur.parent)
				{
					yield return cur;
				}
			}
		}

		/// <summary>
		/// Gets all descendants of this node (excluding this node itself) in pre-order.
		/// </summary>
		public IEnumerable<AstNode> Descendants {
			get { return GetDescendantsImpl(false); }
		}

		/// <summary>
		/// Gets all descendants of this node (including this node itself) in pre-order.
		/// </summary>
		public IEnumerable<AstNode> DescendantsAndSelf {
			get { return GetDescendantsImpl(true); }
		}

		public IEnumerable<AstNode> DescendantNodes(Func<AstNode, bool> descendIntoChildren = null)
		{
			return GetDescendantsImpl(false, descendIntoChildren);
		}

		public IEnumerable<AstNode> DescendantNodesAndSelf(Func<AstNode, bool> descendIntoChildren = null)
		{
			return GetDescendantsImpl(true, descendIntoChildren);
		}


		IEnumerable<AstNode> GetDescendantsImpl(bool includeSelf, Func<AstNode, bool> descendIntoChildren = null)
		{
			if (includeSelf)
			{
				yield return this;
				if (descendIntoChildren != null && !descendIntoChildren(this))
					yield break;
			}

			Stack<AstNode> nextStack = new Stack<AstNode>();
			nextStack.Push(null);
			AstNode pos = firstChild;
			while (pos != null)
			{
				// Remember next before yielding pos.
				// This allows removing/replacing nodes while iterating through the list.
				if (pos.nextSibling != null)
					nextStack.Push(pos.nextSibling);
				yield return pos;
				if (pos.firstChild != null && (descendIntoChildren == null || descendIntoChildren(pos)))
					pos = pos.firstChild;
				else
					pos = nextStack.Pop();
			}
		}

		/// <summary>
		/// Gets the first child with the specified role.
		/// Returns the role's null object if the child is not found.
		/// </summary>
		public T GetChildByRole<T>(Role<T> role) where T : AstNode
		{
			if (role == null)
				throw new ArgumentNullException(nameof(role));
			uint roleIndex = role.Index;
			for (var cur = firstChild; cur != null; cur = cur.nextSibling)
			{
				if ((cur.flags & roleIndexMask) == roleIndex)
					return (T)cur;
			}
			return role.NullObject;
		}

		public T GetParent<T>() where T : AstNode
		{
			return Ancestors.OfType<T>().FirstOrDefault();
		}

		public AstNode GetParent(Func<AstNode, bool> pred)
		{
			return Ancestors.FirstOrDefault(pred);
		}

		public AstNodeCollection<T> GetChildrenByRole<T>(Role<T> role) where T : AstNode
		{
			return new AstNodeCollection<T>(this, role);
		}

		protected void SetChildByRole<T>(Role<T> role, T newChild) where T : AstNode
		{
			AstNode oldChild = GetChildByRole(role);
			if (oldChild.IsNull)
				AddChild(newChild, role);
			else
				oldChild.ReplaceWith(newChild);
		}

		public void AddChild<T>(T child, Role<T> role) where T : AstNode
		{
			if (role == null)
				throw new ArgumentNullException(nameof(role));
			if (child == null || child.IsNull)
				return;
			ThrowIfFrozen();
			if (child == this)
				throw new ArgumentException("Cannot add a node to itself as a child.", nameof(child));
			if (child.parent != null)
				throw new ArgumentException("Node is already used in another tree.", nameof(child));
			if (child.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(child));
			AddChildUnsafe(child, role);
		}

		public void AddChildWithExistingRole(AstNode child)
		{
			if (child == null || child.IsNull)
				return;
			ThrowIfFrozen();
			if (child == this)
				throw new ArgumentException("Cannot add a node to itself as a child.", nameof(child));
			if (child.parent != null)
				throw new ArgumentException("Node is already used in another tree.", nameof(child));
			if (child.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(child));
			AddChildUnsafe(child, child.Role);
		}

		/// <summary>
		/// Adds a child without performing any safety checks.
		/// </summary>
		internal void AddChildUnsafe(AstNode child, Role role)
		{
			child.parent = this;
			child.SetRole(role);
			if (firstChild == null)
			{
				lastChild = firstChild = child;
			}
			else
			{
				lastChild.nextSibling = child;
				child.prevSibling = lastChild;
				lastChild = child;
			}
		}

		public void InsertChildBefore<T>(AstNode nextSibling, T child, Role<T> role) where T : AstNode
		{
			if (role == null)
				throw new ArgumentNullException(nameof(role));
			if (nextSibling == null || nextSibling.IsNull)
			{
				AddChild(child, role);
				return;
			}

			if (child == null || child.IsNull)
				return;
			ThrowIfFrozen();
			if (child.parent != null)
				throw new ArgumentException("Node is already used in another tree.", nameof(child));
			if (child.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(child));
			if (nextSibling.parent != this)
				throw new ArgumentException("NextSibling is not a child of this node.", nameof(nextSibling));
			// No need to test for "Cannot add children to null nodes",
			// as there isn't any valid nextSibling in null nodes.
			InsertChildBeforeUnsafe(nextSibling, child, role);
		}

		internal void InsertChildBeforeUnsafe(AstNode nextSibling, AstNode child, Role role)
		{
			child.parent = this;
			child.SetRole(role);
			child.nextSibling = nextSibling;
			child.prevSibling = nextSibling.prevSibling;

			if (nextSibling.prevSibling != null)
			{
				Debug.Assert(nextSibling.prevSibling.nextSibling == nextSibling);
				nextSibling.prevSibling.nextSibling = child;
			}
			else
			{
				Debug.Assert(firstChild == nextSibling);
				firstChild = child;
			}
			nextSibling.prevSibling = child;
		}

		public void InsertChildAfter<T>(AstNode prevSibling, T child, Role<T> role) where T : AstNode
		{
			InsertChildBefore((prevSibling == null || prevSibling.IsNull) ? firstChild : prevSibling.nextSibling, child, role);
		}

		/// <summary>
		/// Removes this node from its parent.
		/// </summary>
		public void Remove()
		{
			if (parent != null)
			{
				ThrowIfFrozen();
				if (prevSibling != null)
				{
					Debug.Assert(prevSibling.nextSibling == this);
					prevSibling.nextSibling = nextSibling;
				}
				else
				{
					Debug.Assert(parent.firstChild == this);
					parent.firstChild = nextSibling;
				}
				if (nextSibling != null)
				{
					Debug.Assert(nextSibling.prevSibling == this);
					nextSibling.prevSibling = prevSibling;
				}
				else
				{
					Debug.Assert(parent.lastChild == this);
					parent.lastChild = prevSibling;
				}
				parent = null;
				prevSibling = null;
				nextSibling = null;
			}
		}

		/// <summary>
		/// Replaces this node with the new node.
		/// </summary>
		public void ReplaceWith(AstNode newNode)
		{
			if (newNode == null || newNode.IsNull)
			{
				Remove();
				return;
			}
			if (newNode == this)
				return; // nothing to do...
			if (parent == null)
			{
				throw new InvalidOperationException(this.IsNull ? "Cannot replace the null nodes" : "Cannot replace the root node");
			}
			ThrowIfFrozen();
			// Because this method doesn't statically check the new node's type with the role,
			// we perform a runtime test:
			if (!this.Role.IsValid(newNode))
			{
				throw new ArgumentException(string.Format("The new node '{0}' is not valid in the role {1}", newNode.GetType().Name, this.Role.ToString()), nameof(newNode));
			}
			if (newNode.parent != null)
			{
				// newNode is used within this tree?
				if (newNode.Ancestors.Contains(this))
				{
					// e.g. "parenthesizedExpr.ReplaceWith(parenthesizedExpr.Expression);"
					// enable automatic removal
					newNode.Remove();
				}
				else
				{
					throw new ArgumentException("Node is already used in another tree.", nameof(newNode));
				}
			}
			if (newNode.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(newNode));

			newNode.parent = parent;
			newNode.SetRole(this.Role);
			newNode.prevSibling = prevSibling;
			newNode.nextSibling = nextSibling;

			if (prevSibling != null)
			{
				Debug.Assert(prevSibling.nextSibling == this);
				prevSibling.nextSibling = newNode;
			}
			else
			{
				Debug.Assert(parent.firstChild == this);
				parent.firstChild = newNode;
			}
			if (nextSibling != null)
			{
				Debug.Assert(nextSibling.prevSibling == this);
				nextSibling.prevSibling = newNode;
			}
			else
			{
				Debug.Assert(parent.lastChild == this);
				parent.lastChild = newNode;
			}
			parent = null;
			prevSibling = null;
			nextSibling = null;
		}

		public AstNode ReplaceWith(Func<AstNode, AstNode> replaceFunction)
		{
			if (replaceFunction == null)
				throw new ArgumentNullException(nameof(replaceFunction));
			if (parent == null)
			{
				throw new InvalidOperationException(this.IsNull ? "Cannot replace the null nodes" : "Cannot replace the root node");
			}
			AstNode oldParent = parent;
			AstNode oldSuccessor = nextSibling;
			Role oldRole = this.Role;
			Remove();
			AstNode replacement = replaceFunction(this);
			if (oldSuccessor != null && oldSuccessor.parent != oldParent)
				throw new InvalidOperationException("replace function changed nextSibling of node being replaced?");
			if (!(replacement == null || replacement.IsNull))
			{
				if (replacement.parent != null)
					throw new InvalidOperationException("replace function must return the root of a tree");
				if (!oldRole.IsValid(replacement))
				{
					throw new InvalidOperationException(string.Format("The new node '{0}' is not valid in the role {1}", replacement.GetType().Name, oldRole.ToString()));
				}

				if (oldSuccessor != null)
					oldParent.InsertChildBeforeUnsafe(oldSuccessor, replacement, oldRole);
				else
					oldParent.AddChildUnsafe(replacement, oldRole);
			}
			return replacement;
		}

		/// <summary>
		/// Clones the whole subtree starting at this AST node.
		/// </summary>
		/// <remarks>Annotations are copied over to the new nodes; and any annotations implementing ICloneable will be cloned.</remarks>
		public AstNode Clone()
		{
			AstNode copy = (AstNode)MemberwiseClone();
			// First, reset the shallow pointer copies
			copy.parent = null;
			copy.firstChild = null;
			copy.lastChild = null;
			copy.prevSibling = null;
			copy.nextSibling = null;
			copy.flags &= ~frozenBit; // unfreeze the copy

			// Then perform a deep copy:
			for (AstNode cur = firstChild; cur != null; cur = cur.nextSibling)
			{
				copy.AddChildUnsafe(cur.Clone(), cur.Role);
			}

			// Finally, clone the annotation, if necessary
			copy.CloneAnnotations();

			return copy;
		}

		object ICloneable.Clone()
		{
			return Clone();
		}

		public abstract void AcceptVisitor(IAstVisitor visitor);

		public abstract T AcceptVisitor<T>(IAstVisitor<T> visitor);

		public abstract S AcceptVisitor<T, S>(IAstVisitor<T, S> visitor, T data);

		#region Pattern Matching
		protected static bool MatchString(string pattern, string text)
		{
			return PatternMatching.Pattern.MatchString(pattern, text);
		}

		protected internal abstract bool DoMatch(AstNode other, PatternMatching.Match match);

		bool PatternMatching.INode.DoMatch(PatternMatching.INode other, PatternMatching.Match match)
		{
			AstNode o = other as AstNode;
			// try matching if other is null, or if other is an AstNode
			return (other == null || o != null) && DoMatch(o, match);
		}

		bool PatternMatching.INode.DoMatchCollection(Role role, PatternMatching.INode pos, PatternMatching.Match match, PatternMatching.BacktrackingInfo backtrackingInfo)
		{
			AstNode o = pos as AstNode;
			return (pos == null || o != null) && DoMatch(o, match);
		}

		PatternMatching.INode PatternMatching.INode.NextSibling {
			get { return nextSibling; }
		}

		PatternMatching.INode PatternMatching.INode.FirstChild {
			get { return firstChild; }
		}

		#endregion

		public AstNode GetNextNode()
		{
			if (NextSibling != null)
				return NextSibling;
			if (Parent != null)
				return Parent.GetNextNode();
			return null;
		}

		/// <summary>
		/// Gets the next node which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetNextNode(Func<AstNode, bool> pred)
		{
			var next = GetNextNode();
			while (next != null && !pred(next))
				next = next.GetNextNode();
			return next;
		}

		public AstNode GetPrevNode()
		{
			if (PrevSibling != null)
				return PrevSibling;
			if (Parent != null)
				return Parent.GetPrevNode();
			return null;
		}

		/// <summary>
		/// Gets the previous node which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetPrevNode(Func<AstNode, bool> pred)
		{
			var prev = GetPrevNode();
			while (prev != null && !pred(prev))
				prev = prev.GetPrevNode();
			return prev;
		}
		// filters all non c# nodes (comments, white spaces or pre processor directives)
		public AstNode GetCSharpNodeBefore(AstNode node)
		{
			var n = node.PrevSibling;
			while (n != null)
			{
				if (n.Role != Roles.Comment)
					return n;
				n = n.GetPrevNode();
			}
			return null;
		}

		/// <summary>
		/// Gets the next sibling which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetNextSibling(Func<AstNode, bool> pred)
		{
			var next = NextSibling;
			while (next != null && !pred(next))
				next = next.NextSibling;
			return next;
		}

		/// <summary>
		/// Gets the next sibling which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetPrevSibling(Func<AstNode, bool> pred)
		{
			var prev = PrevSibling;
			while (prev != null && !pred(prev))
				prev = prev.PrevSibling;
			return prev;
		}

		#region GetNodeAt
		/// <summary>
		/// Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public AstNode GetNodeAt(int line, int column, Predicate<AstNode> pred = null)
		{
			return GetNodeAt(new TextLocation(line, column), pred);
		}

		/// <summary>
		/// Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public AstNode GetNodeAt(TextLocation location, Predicate<AstNode> pred = null)
		{
			AstNode result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location < child.EndLocation)
				{
					if (pred == null || pred(child))
						result = child;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}

		/// <summary>
		/// Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public T GetNodeAt<T>(int line, int column) where T : AstNode
		{
			return GetNodeAt<T>(new TextLocation(line, column));
		}

		/// <summary>
		/// Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public T GetNodeAt<T>(TextLocation location) where T : AstNode
		{
			T result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location < child.EndLocation)
				{
					if (child is T t)
						result = t;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}

		#endregion

		#region GetAdjacentNodeAt
		/// <summary>
		/// Gets the node specified by pred at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public AstNode GetAdjacentNodeAt(int line, int column, Predicate<AstNode> pred = null)
		{
			return GetAdjacentNodeAt(new TextLocation(line, column), pred);
		}

		/// <summary>
		/// Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public AstNode GetAdjacentNodeAt(TextLocation location, Predicate<AstNode> pred = null)
		{
			AstNode result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location <= child.EndLocation)
				{
					if (pred == null || pred(child))
						result = child;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}

		/// <summary>
		/// Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public T GetAdjacentNodeAt<T>(int line, int column) where T : AstNode
		{
			return GetAdjacentNodeAt<T>(new TextLocation(line, column));
		}

		/// <summary>
		/// Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public T GetAdjacentNodeAt<T>(TextLocation location) where T : AstNode
		{
			T result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location <= child.EndLocation)
				{
					if (child is T t)
						result = t;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}
		#endregion


		/// <summary>
		/// Gets the node that fully contains the range from startLocation to endLocation.
		/// </summary>
		public AstNode GetNodeContaining(TextLocation startLocation, TextLocation endLocation)
		{
			for (AstNode child = firstChild; child != null; child = child.nextSibling)
			{
				if (child.StartLocation <= startLocation && endLocation <= child.EndLocation)
					return child.GetNodeContaining(startLocation, endLocation);
			}
			return this;
		}

		/// <summary>
		/// Returns the root nodes of all subtrees that are fully contained in the specified region.
		/// </summary>
		public IEnumerable<AstNode> GetNodesBetween(int startLine, int startColumn, int endLine, int endColumn)
		{
			return GetNodesBetween(new TextLocation(startLine, startColumn), new TextLocation(endLine, endColumn));
		}

		/// <summary>
		/// Returns the root nodes of all subtrees that are fully contained between <paramref name="start"/> and <paramref name="end"/> (inclusive).
		/// </summary>
		public IEnumerable<AstNode> GetNodesBetween(TextLocation start, TextLocation end)
		{
			AstNode node = this;
			while (node != null)
			{
				AstNode next;
				if (start <= node.StartLocation && node.EndLocation <= end)
				{
					// Remember next before yielding node.
					// This allows iteration to continue when the caller removes/replaces the node.
					next = node.GetNextNode();
					yield return node;
				}
				else
				{
					if (node.EndLocation <= start)
					{
						next = node.GetNextNode();
					}
					else
					{
						next = node.FirstChild;
					}
				}

				if (next != null && next.StartLocation > end)
					yield break;
				node = next;
			}
		}

		/// <summary>
		/// Gets the node as formatted C# output.
		/// </summary>
		/// <param name='formattingOptions'>
		/// Formatting options.
		/// </param>
		public virtual string ToString(CSharpFormattingOptions formattingOptions)
		{
			if (IsNull)
				return "";
			var w = new StringWriter();
			AcceptVisitor(new CSharpOutputVisitor(w, formattingOptions ?? FormattingOptionsFactory.CreateMono()));
			return w.ToString();
		}

		public sealed override string ToString()
		{
			return ToString(null);
		}

		/// <summary>
		/// Returns true, if the given coordinates (line, column) are in the node.
		/// </summary>
		/// <returns>
		/// True, if the given coordinates are between StartLocation and EndLocation (exclusive); otherwise, false.
		/// </returns>
		public bool Contains(int line, int column)
		{
			return Contains(new TextLocation(line, column));
		}

		/// <summary>
		/// Returns true, if the given coordinates are in the node.
		/// </summary>
		/// <returns>
		/// True, if location is between StartLocation and EndLocation (exclusive); otherwise, false.
		/// </returns>
		public bool Contains(TextLocation location)
		{
			return this.StartLocation <= location && location < this.EndLocation;
		}

		/// <summary>
		/// Returns true, if the given coordinates (line, column) are in the node.
		/// </summary>
		/// <returns>
		/// True, if the given coordinates are between StartLocation and EndLocation (inclusive); otherwise, false.
		/// </returns>
		public bool IsInside(int line, int column)
		{
			return IsInside(new TextLocation(line, column));
		}

		/// <summary>
		/// Returns true, if the given coordinates are in the node.
		/// </summary>
		/// <returns>
		/// True, if location is between StartLocation and EndLocation (inclusive); otherwise, false.
		/// </returns>
		public bool IsInside(TextLocation location)
		{
			return this.StartLocation <= location && location <= this.EndLocation;
		}

		public override void AddAnnotation(object annotation)
		{
			if (this.IsNull)
				throw new InvalidOperationException("Cannot add annotations to the null node");
			base.AddAnnotation(annotation);
		}

		internal string DebugToString()
		{
			if (IsNull)
				return "Null";
			string text = ToString();
			text = text.TrimEnd().Replace("\t", "").Replace(Environment.NewLine, " ");
			if (text.Length > 100)
				return text.Substring(0, 97) + "...";
			else
				return text;
		}
	}
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

using ICSharpCode.Decompiler.CSharp.OutputVisitor;
using ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching;
using ICSharpCode.Decompiler.TypeSystem;

namespace ICSharpCode.Decompiler.CSharp.Syntax
{
	public abstract class AstNode : AbstractAnnotatable, IFreezable, INode, ICloneable
	{
		// the Root role must be available when creating the null nodes, so we can't put it in the Roles class
		internal static readonly Role<AstNode> RootRole = new Role<AstNode>("Root");

		#region Null
		public static readonly AstNode Null = new NullAstNode();

		sealed class NullAstNode : AstNode
		{
			public override NodeType NodeType {
				get {
					return NodeType.Unknown;
				}
			}

			public override bool IsNull {
				get {
					return true;
				}
			}

			public override void AcceptVisitor(IAstVisitor visitor)
			{
				visitor.VisitNullNode(this);
			}

			public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
			{
				return visitor.VisitNullNode(this);
			}

			public override S AcceptVisitor<T, S>(IAstVisitor<T, S> visitor, T data)
			{
				return visitor.VisitNullNode(this, data);
			}

			protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
			{
				return other == null || other.IsNull;
			}
		}
		#endregion

		#region PatternPlaceholder
		public static implicit operator AstNode(PatternMatching.Pattern pattern)
		{
			return pattern != null ? new PatternPlaceholder(pattern) : null;
		}

		sealed class PatternPlaceholder : AstNode, INode
		{
			readonly PatternMatching.Pattern child;

			public PatternPlaceholder(PatternMatching.Pattern child)
			{
				this.child = child;
			}

			public override NodeType NodeType {
				get { return NodeType.Pattern; }
			}

			public override void AcceptVisitor(IAstVisitor visitor)
			{
				visitor.VisitPatternPlaceholder(this, child);
			}

			public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
			{
				return visitor.VisitPatternPlaceholder(this, child);
			}

			public override S AcceptVisitor<T, S>(IAstVisitor<T, S> visitor, T data)
			{
				return visitor.VisitPatternPlaceholder(this, child, data);
			}

			protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
			{
				return child.DoMatch(other, match);
			}

			bool PatternMatching.INode.DoMatchCollection(Role role, PatternMatching.INode pos, PatternMatching.Match match, PatternMatching.BacktrackingInfo backtrackingInfo)
			{
				return child.DoMatchCollection(role, pos, match, backtrackingInfo);
			}
		}
		#endregion

		AstNode parent;
		AstNode prevSibling;
		AstNode nextSibling;
		AstNode firstChild;
		AstNode lastChild;

		// Flags, from least significant to most significant bits:
		// - Role.RoleIndexBits: role index
		// - 1 bit: IsFrozen
		protected uint flags = RootRole.Index;
		// Derived classes may also use a few bits,
		// for example Identifier uses 1 bit for IsVerbatim

		const uint roleIndexMask = (1u << Role.RoleIndexBits) - 1;
		const uint frozenBit = 1u << Role.RoleIndexBits;
		protected const int AstNodeFlagsUsedBits = Role.RoleIndexBits + 1;

		protected AstNode()
		{
			if (IsNull)
				Freeze();
		}

		public bool IsFrozen {
			get { return (flags & frozenBit) != 0; }
		}

		public void Freeze()
		{
			if (!IsFrozen)
			{
				for (AstNode child = firstChild; child != null; child = child.nextSibling)
					child.Freeze();
				flags |= frozenBit;
			}
		}

		protected void ThrowIfFrozen()
		{
			if (IsFrozen)
				throw new InvalidOperationException("Cannot mutate frozen " + GetType().Name);
		}

		public abstract NodeType NodeType {
			get;
		}

		public virtual bool IsNull {
			get {
				return false;
			}
		}

		public virtual TextLocation StartLocation {
			get {
				var child = firstChild;
				if (child == null)
					return TextLocation.Empty;
				return child.StartLocation;
			}
		}

		public virtual TextLocation EndLocation {
			get {
				var child = lastChild;
				if (child == null)
					return TextLocation.Empty;
				return child.EndLocation;
			}
		}

		public AstNode Parent {
			get { return parent; }
		}

		public Role Role {
			get {
				return Role.GetByIndex(flags & roleIndexMask);
			}
			set {
				if (value == null)
					throw new ArgumentNullException(nameof(value));
				if (!value.IsValid(this))
					throw new ArgumentException("This node is not valid in the new role.");
				ThrowIfFrozen();
				SetRole(value);
			}
		}

		internal uint RoleIndex {
			get { return flags & roleIndexMask; }
		}

		void SetRole(Role role)
		{
			flags = (flags & ~roleIndexMask) | role.Index;
		}

		public AstNode NextSibling {
			get { return nextSibling; }
		}

		public AstNode PrevSibling {
			get { return prevSibling; }
		}

		public AstNode FirstChild {
			get { return firstChild; }
		}

		public AstNode LastChild {
			get { return lastChild; }
		}

		public bool HasChildren {
			get {
				return firstChild != null;
			}
		}

		public IEnumerable<AstNode> Children {
			get {
				AstNode next;
				for (AstNode cur = firstChild; cur != null; cur = next)
				{
					Debug.Assert(cur.parent == this);
					// Remember next before yielding cur.
					// This allows removing/replacing nodes while iterating through the list.
					next = cur.nextSibling;
					yield return cur;
				}
			}
		}

		/// <summary>
		/// Gets the ancestors of this node (excluding this node itself)
		/// </summary>
		public IEnumerable<AstNode> Ancestors {
			get {
				for (AstNode cur = parent; cur != null; cur = cur.parent)
				{
					yield return cur;
				}
			}
		}

		/// <summary>
		/// Gets the ancestors of this node (including this node itself)
		/// </summary>
		public IEnumerable<AstNode> AncestorsAndSelf {
			get {
				for (AstNode cur = this; cur != null; cur = cur.parent)
				{
					yield return cur;
				}
			}
		}

		/// <summary>
		/// Gets all descendants of this node (excluding this node itself) in pre-order.
		/// </summary>
		public IEnumerable<AstNode> Descendants {
			get { return GetDescendantsImpl(false); }
		}

		/// <summary>
		/// Gets all descendants of this node (including this node itself) in pre-order.
		/// </summary>
		public IEnumerable<AstNode> DescendantsAndSelf {
			get { return GetDescendantsImpl(true); }
		}

		public IEnumerable<AstNode> DescendantNodes(Func<AstNode, bool> descendIntoChildren = null)
		{
			return GetDescendantsImpl(false, descendIntoChildren);
		}

		public IEnumerable<AstNode> DescendantNodesAndSelf(Func<AstNode, bool> descendIntoChildren = null)
		{
			return GetDescendantsImpl(true, descendIntoChildren);
		}


		IEnumerable<AstNode> GetDescendantsImpl(bool includeSelf, Func<AstNode, bool> descendIntoChildren = null)
		{
			if (includeSelf)
			{
				yield return this;
				if (descendIntoChildren != null && !descendIntoChildren(this))
					yield break;
			}

			Stack<AstNode> nextStack = new Stack<AstNode>();
			nextStack.Push(null);
			AstNode pos = firstChild;
			while (pos != null)
			{
				// Remember next before yielding pos.
				// This allows removing/replacing nodes while iterating through the list.
				if (pos.nextSibling != null)
					nextStack.Push(pos.nextSibling);
				yield return pos;
				if (pos.firstChild != null && (descendIntoChildren == null || descendIntoChildren(pos)))
					pos = pos.firstChild;
				else
					pos = nextStack.Pop();
			}
		}

		/// <summary>
		/// Gets the first child with the specified role.
		/// Returns the role's null object if the child is not found.
		/// </summary>
		public T GetChildByRole<T>(Role<T> role) where T : AstNode
		{
			if (role == null)
				throw new ArgumentNullException(nameof(role));
			uint roleIndex = role.Index;
			for (var cur = firstChild; cur != null; cur = cur.nextSibling)
			{
				if ((cur.flags & roleIndexMask) == roleIndex)
					return (T)cur;
			}
			return role.NullObject;
		}

		public T GetParent<T>() where T : AstNode
		{
			return Ancestors.OfType<T>().FirstOrDefault();
		}

		public AstNode GetParent(Func<AstNode, bool> pred)
		{
			return Ancestors.FirstOrDefault(pred);
		}

		public AstNodeCollection<T> GetChildrenByRole<T>(Role<T> role) where T : AstNode
		{
			return new AstNodeCollection<T>(this, role);
		}

		protected void SetChildByRole<T>(Role<T> role, T newChild) where T : AstNode
		{
			AstNode oldChild = GetChildByRole(role);
			if (oldChild.IsNull)
				AddChild(newChild, role);
			else
				oldChild.ReplaceWith(newChild);
		}

		public void AddChild<T>(T child, Role<T> role) where T : AstNode
		{
			if (role == null)
				throw new ArgumentNullException(nameof(role));
			if (child == null || child.IsNull)
				return;
			ThrowIfFrozen();
			if (child == this)
				throw new ArgumentException("Cannot add a node to itself as a child.", nameof(child));
			if (child.parent != null)
				throw new ArgumentException("Node is already used in another tree.", nameof(child));
			if (child.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(child));
			AddChildUnsafe(child, role);
		}

		public void AddChildWithExistingRole(AstNode child)
		{
			if (child == null || child.IsNull)
				return;
			ThrowIfFrozen();
			if (child == this)
				throw new ArgumentException("Cannot add a node to itself as a child.", nameof(child));
			if (child.parent != null)
				throw new ArgumentException("Node is already used in another tree.", nameof(child));
			if (child.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(child));
			AddChildUnsafe(child, child.Role);
		}

		/// <summary>
		/// Adds a child without performing any safety checks.
		/// </summary>
		internal void AddChildUnsafe(AstNode child, Role role)
		{
			child.parent = this;
			child.SetRole(role);
			if (firstChild == null)
			{
				lastChild = firstChild = child;
			}
			else
			{
				lastChild.nextSibling = child;
				child.prevSibling = lastChild;
				lastChild = child;
			}
		}

		public void InsertChildBefore<T>(AstNode nextSibling, T child, Role<T> role) where T : AstNode
		{
			if (role == null)
				throw new ArgumentNullException(nameof(role));
			if (nextSibling == null || nextSibling.IsNull)
			{
				AddChild(child, role);
				return;
			}

			if (child == null || child.IsNull)
				return;
			ThrowIfFrozen();
			if (child.parent != null)
				throw new ArgumentException("Node is already used in another tree.", nameof(child));
			if (child.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(child));
			if (nextSibling.parent != this)
				throw new ArgumentException("NextSibling is not a child of this node.", nameof(nextSibling));
			// No need to test for "Cannot add children to null nodes",
			// as there isn't any valid nextSibling in null nodes.
			InsertChildBeforeUnsafe(nextSibling, child, role);
		}

		internal void InsertChildBeforeUnsafe(AstNode nextSibling, AstNode child, Role role)
		{
			child.parent = this;
			child.SetRole(role);
			child.nextSibling = nextSibling;
			child.prevSibling = nextSibling.prevSibling;

			if (nextSibling.prevSibling != null)
			{
				Debug.Assert(nextSibling.prevSibling.nextSibling == nextSibling);
				nextSibling.prevSibling.nextSibling = child;
			}
			else
			{
				Debug.Assert(firstChild == nextSibling);
				firstChild = child;
			}
			nextSibling.prevSibling = child;
		}

		public void InsertChildAfter<T>(AstNode prevSibling, T child, Role<T> role) where T : AstNode
		{
			InsertChildBefore((prevSibling == null || prevSibling.IsNull) ? firstChild : prevSibling.nextSibling, child, role);
		}

		/// <summary>
		/// Removes this node from its parent.
		/// </summary>
		public void Remove()
		{
			if (parent != null)
			{
				ThrowIfFrozen();
				if (prevSibling != null)
				{
					Debug.Assert(prevSibling.nextSibling == this);
					prevSibling.nextSibling = nextSibling;
				}
				else
				{
					Debug.Assert(parent.firstChild == this);
					parent.firstChild = nextSibling;
				}
				if (nextSibling != null)
				{
					Debug.Assert(nextSibling.prevSibling == this);
					nextSibling.prevSibling = prevSibling;
				}
				else
				{
					Debug.Assert(parent.lastChild == this);
					parent.lastChild = prevSibling;
				}
				parent = null;
				prevSibling = null;
				nextSibling = null;
			}
		}

		/// <summary>
		/// Replaces this node with the new node.
		/// </summary>
		public void ReplaceWith(AstNode newNode)
		{
			if (newNode == null || newNode.IsNull)
			{
				Remove();
				return;
			}
			if (newNode == this)
				return; // nothing to do...
			if (parent == null)
			{
				throw new InvalidOperationException(this.IsNull ? "Cannot replace the null nodes" : "Cannot replace the root node");
			}
			ThrowIfFrozen();
			// Because this method doesn't statically check the new node's type with the role,
			// we perform a runtime test:
			if (!this.Role.IsValid(newNode))
			{
				throw new ArgumentException(string.Format("The new node '{0}' is not valid in the role {1}", newNode.GetType().Name, this.Role.ToString()), nameof(newNode));
			}
			if (newNode.parent != null)
			{
				// newNode is used within this tree?
				if (newNode.Ancestors.Contains(this))
				{
					// e.g. "parenthesizedExpr.ReplaceWith(parenthesizedExpr.Expression);"
					// enable automatic removal
					newNode.Remove();
				}
				else
				{
					throw new ArgumentException("Node is already used in another tree.", nameof(newNode));
				}
			}
			if (newNode.IsFrozen)
				throw new ArgumentException("Cannot add a frozen node.", nameof(newNode));

			newNode.parent = parent;
			newNode.SetRole(this.Role);
			newNode.prevSibling = prevSibling;
			newNode.nextSibling = nextSibling;

			if (prevSibling != null)
			{
				Debug.Assert(prevSibling.nextSibling == this);
				prevSibling.nextSibling = newNode;
			}
			else
			{
				Debug.Assert(parent.firstChild == this);
				parent.firstChild = newNode;
			}
			if (nextSibling != null)
			{
				Debug.Assert(nextSibling.prevSibling == this);
				nextSibling.prevSibling = newNode;
			}
			else
			{
				Debug.Assert(parent.lastChild == this);
				parent.lastChild = newNode;
			}
			parent = null;
			prevSibling = null;
			nextSibling = null;
		}

		public AstNode ReplaceWith(Func<AstNode, AstNode> replaceFunction)
		{
			if (replaceFunction == null)
				throw new ArgumentNullException(nameof(replaceFunction));
			if (parent == null)
			{
				throw new InvalidOperationException(this.IsNull ? "Cannot replace the null nodes" : "Cannot replace the root node");
			}
			AstNode oldParent = parent;
			AstNode oldSuccessor = nextSibling;
			Role oldRole = this.Role;
			Remove();
			AstNode replacement = replaceFunction(this);
			if (oldSuccessor != null && oldSuccessor.parent != oldParent)
				throw new InvalidOperationException("replace function changed nextSibling of node being replaced?");
			if (!(replacement == null || replacement.IsNull))
			{
				if (replacement.parent != null)
					throw new InvalidOperationException("replace function must return the root of a tree");
				if (!oldRole.IsValid(replacement))
				{
					throw new InvalidOperationException(string.Format("The new node '{0}' is not valid in the role {1}", replacement.GetType().Name, oldRole.ToString()));
				}

				if (oldSuccessor != null)
					oldParent.InsertChildBeforeUnsafe(oldSuccessor, replacement, oldRole);
				else
					oldParent.AddChildUnsafe(replacement, oldRole);
			}
			return replacement;
		}

		/// <summary>
		/// Clones the whole subtree starting at this AST node.
		/// </summary>
		/// <remarks>Annotations are copied over to the new nodes; and any annotations implementing ICloneable will be cloned.</remarks>
		public AstNode Clone()
		{
			AstNode copy = (AstNode)MemberwiseClone();
			// First, reset the shallow pointer copies
			copy.parent = null;
			copy.firstChild = null;
			copy.lastChild = null;
			copy.prevSibling = null;
			copy.nextSibling = null;
			copy.flags &= ~frozenBit; // unfreeze the copy

			// Then perform a deep copy:
			for (AstNode cur = firstChild; cur != null; cur = cur.nextSibling)
			{
				copy.AddChildUnsafe(cur.Clone(), cur.Role);
			}

			// Finally, clone the annotation, if necessary
			copy.CloneAnnotations();

			return copy;
		}

		object ICloneable.Clone()
		{
			return Clone();
		}

		public abstract void AcceptVisitor(IAstVisitor visitor);

		public abstract T AcceptVisitor<T>(IAstVisitor<T> visitor);

		public abstract S AcceptVisitor<T, S>(IAstVisitor<T, S> visitor, T data);

		#region Pattern Matching
		protected static bool MatchString(string pattern, string text)
		{
			return PatternMatching.Pattern.MatchString(pattern, text);
		}

		protected internal abstract bool DoMatch(AstNode other, PatternMatching.Match match);

		bool PatternMatching.INode.DoMatch(PatternMatching.INode other, PatternMatching.Match match)
		{
			// try matching if other is null, or if other is an AstNode
			return (other == null || other is AstNode o) && DoMatch(o, match);
		}

		bool PatternMatching.INode.DoMatchCollection(Role role, PatternMatching.INode pos, PatternMatching.Match match, PatternMatching.BacktrackingInfo backtrackingInfo)
		{
			return (pos == null || pos is AstNode o) && DoMatch(o, match);
		}

		PatternMatching.INode PatternMatching.INode.NextSibling {
			get { return nextSibling; }
		}

		PatternMatching.INode PatternMatching.INode.FirstChild {
			get { return firstChild; }
		}

		#endregion

		public AstNode GetNextNode()
		{
			if (NextSibling != null)
				return NextSibling;
			if (Parent != null)
				return Parent.GetNextNode();
			return null;
		}

		/// <summary>
		/// Gets the next node which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetNextNode(Func<AstNode, bool> pred)
		{
			var next = GetNextNode();
			while (next != null && !pred(next))
				next = next.GetNextNode();
			return next;
		}

		public AstNode GetPrevNode()
		{
			if (PrevSibling != null)
				return PrevSibling;
			if (Parent != null)
				return Parent.GetPrevNode();
			return null;
		}

		/// <summary>
		/// Gets the previous node which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetPrevNode(Func<AstNode, bool> pred)
		{
			var prev = GetPrevNode();
			while (prev != null && !pred(prev))
				prev = prev.GetPrevNode();
			return prev;
		}
		// filters all non c# nodes (comments, white spaces or pre processor directives)
		public AstNode GetCSharpNodeBefore(AstNode node)
		{
			var n = node.PrevSibling;
			while (n != null)
			{
				if (n.Role != Roles.Comment)
					return n;
				n = n.GetPrevNode();
			}
			return null;
		}

		/// <summary>
		/// Gets the next sibling which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetNextSibling(Func<AstNode, bool> pred)
		{
			var next = NextSibling;
			while (next != null && !pred(next))
				next = next.NextSibling;
			return next;
		}

		/// <summary>
		/// Gets the next sibling which fullfills a given predicate
		/// </summary>
		/// <returns>The next node.</returns>
		/// <param name="pred">The predicate.</param>
		public AstNode GetPrevSibling(Func<AstNode, bool> pred)
		{
			var prev = PrevSibling;
			while (prev != null && !pred(prev))
				prev = prev.PrevSibling;
			return prev;
		}

		#region GetNodeAt
		/// <summary>
		/// Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public AstNode GetNodeAt(int line, int column, Predicate<AstNode> pred = null)
		{
			return GetNodeAt(new TextLocation(line, column), pred);
		}

		/// <summary>
		/// Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public AstNode GetNodeAt(TextLocation location, Predicate<AstNode> pred = null)
		{
			AstNode result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location < child.EndLocation)
				{
					if (pred == null || pred(child))
						result = child;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}

		/// <summary>
		/// Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public T GetNodeAt<T>(int line, int column) where T : AstNode
		{
			return GetNodeAt<T>(new TextLocation(line, column));
		}

		/// <summary>
		/// Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End exclusive)
		/// </summary>
		public T GetNodeAt<T>(TextLocation location) where T : AstNode
		{
			T result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location < child.EndLocation)
				{
					if (child is T t)
						result = t;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}

		#endregion

		#region GetAdjacentNodeAt
		/// <summary>
		/// Gets the node specified by pred at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public AstNode GetAdjacentNodeAt(int line, int column, Predicate<AstNode> pred = null)
		{
			return GetAdjacentNodeAt(new TextLocation(line, column), pred);
		}

		/// <summary>
		/// Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public AstNode GetAdjacentNodeAt(TextLocation location, Predicate<AstNode> pred = null)
		{
			AstNode result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location <= child.EndLocation)
				{
					if (pred == null || pred(child))
						result = child;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}

		/// <summary>
		/// Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public T GetAdjacentNodeAt<T>(int line, int column) where T : AstNode
		{
			return GetAdjacentNodeAt<T>(new TextLocation(line, column));
		}

		/// <summary>
		/// Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
		/// the current method declaration.
		/// (End inclusive)
		/// </summary>
		public T GetAdjacentNodeAt<T>(TextLocation location) where T : AstNode
		{
			T result = null;
			AstNode node = this;
			while (node.LastChild != null)
			{
				var child = node.LastChild;
				while (child != null && child.StartLocation > location)
					child = child.prevSibling;
				if (child != null && location <= child.EndLocation)
				{
					if (child is T t)
						result = t;
					node = child;
				}
				else
				{
					// found no better child node - therefore the parent is the right one.
					break;
				}
			}
			return result;
		}
		#endregion


		/// <summary>
		/// Gets the node that fully contains the range from startLocation to endLocation.
		/// </summary>
		public AstNode GetNodeContaining(TextLocation startLocation, TextLocation endLocation)
		{
			for (AstNode child = firstChild; child != null; child = child.nextSibling)
			{
				if (child.StartLocation <= startLocation && endLocation <= child.EndLocation)
					return child.GetNodeContaining(startLocation, endLocation);
			}
			return this;
		}

		/// <summary>
		/// Returns the root nodes of all subtrees that are fully contained in the specified region.
		/// </summary>
		public IEnumerable<AstNode> GetNodesBetween(int startLine, int startColumn, int endLine, int endColumn)
		{
			return GetNodesBetween(new TextLocation(startLine, startColumn), new TextLocation(endLine, endColumn));
		}

		/// <summary>
		/// Returns the root nodes of all subtrees that are fully contained between <paramref name="start"/> and <paramref name="end"/> (inclusive).
		/// </summary>
		public IEnumerable<AstNode> GetNodesBetween(TextLocation start, TextLocation end)
		{
			AstNode node = this;
			while (node != null)
			{
				AstNode next;
				if (start <= node.StartLocation && node.EndLocation <= end)
				{
					// Remember next before yielding node.
					// This allows iteration to continue when the caller removes/replaces the node.
					next = node.GetNextNode();
					yield return node;
				}
				else
				{
					if (node.EndLocation <= start)
					{
						next = node.GetNextNode();
					}
					else
					{
						next = node.FirstChild;
					}
				}

				if (next != null && next.StartLocation > end)
					yield break;
				node = next;
			}
		}

		/// <summary>
		/// Gets the node as formatted C# output.
		/// </summary>
		/// <param name='formattingOptions'>
		/// Formatting options.
		/// </param>
		public virtual string ToString(CSharpFormattingOptions formattingOptions)
		{
			if (IsNull)
				return "";
			var w = new StringWriter();
			AcceptVisitor(new CSharpOutputVisitor(w, formattingOptions ?? FormattingOptionsFactory.CreateMono()));
			return w.ToString();
		}

		public sealed override string ToString()
		{
			return ToString(null);
		}

		/// <summary>
		/// Returns true, if the given coordinates (line, column) are in the node.
		/// </summary>
		/// <returns>
		/// True, if the given coordinates are between StartLocation and EndLocation (exclusive); otherwise, false.
		/// </returns>
		public bool Contains(int line, int column)
		{
			return Contains(new TextLocation(line, column));
		}

		/// <summary>
		/// Returns true, if the given coordinates are in the node.
		/// </summary>
		/// <returns>
		/// True, if location is between StartLocation and EndLocation (exclusive); otherwise, false.
		/// </returns>
		public bool Contains(TextLocation location)
		{
			return this.StartLocation <= location && location < this.EndLocation;
		}

		/// <summary>
		/// Returns true, if the given coordinates (line, column) are in the node.
		/// </summary>
		/// <returns>
		/// True, if the given coordinates are between StartLocation and EndLocation (inclusive); otherwise, false.
		/// </returns>
		public bool IsInside(int line, int column)
		{
			return IsInside(new TextLocation(line, column));
		}

		/// <summary>
		/// Returns true, if the given coordinates are in the node.
		/// </summary>
		/// <returns>
		/// True, if location is between StartLocation and EndLocation (inclusive); otherwise, false.
		/// </returns>
		public bool IsInside(TextLocation location)
		{
			return this.StartLocation <= location && location <= this.EndLocation;
		}

		public override void AddAnnotation(object annotation)
		{
			if (this.IsNull)
				throw new InvalidOperationException("Cannot add annotations to the null node");
			base.AddAnnotation(annotation);
		}

		internal string DebugToString()
		{
			if (IsNull)
				return "Null";
			string text = ToString();
			text = text.TrimEnd().Replace("\t", "").Replace(Environment.NewLine, " ");
			if (text.Length > 100)
				return text.Substring(0, 97) + "...";
			else
				return text;
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs(662,60): error CS0165: Use of unassigned local variable 'o',D:\a\1\s\ICSharpCode.Decompiler\CSharp\Syntax\AstNode.cs(667,56): error CS0165: Use of unassigned local variable 'o'
######################################################################


######################################################################
Nr: 2 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertRequiredSpacesDecorator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;

using ICSharpCode.Decompiler.CSharp.Syntax;

namespace ICSharpCode.Decompiler.CSharp.OutputVisitor
{
	class InsertRequiredSpacesDecorator : DecoratingTokenWriter
	{
		/// <summary>
		/// Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
		/// </summary>
		LastWritten lastWritten;

		enum LastWritten
		{
			Whitespace,
			Other,
			KeywordOrIdentifier,
			Plus,
			Minus,
			Ampersand,
			QuestionMark,
			Division
		}

		public InsertRequiredSpacesDecorator(TokenWriter writer)
			: base(writer)
		{
		}

		public override void WriteIdentifier(Identifier identifier)
		{
			if (identifier.IsVerbatim || CSharpOutputVisitor.IsKeyword(identifier.Name, identifier))
			{
				if (lastWritten == LastWritten.KeywordOrIdentifier)
				{
					// this space is not strictly required, so we call Space()
					Space();
				}
			}
			else if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				// this space is strictly required, so we directly call the formatter
				base.Space();
			}
			base.WriteIdentifier(identifier);
			lastWritten = LastWritten.KeywordOrIdentifier;
		}

		public override void WriteKeyword(Role role, string keyword)
		{
			if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				Space();
			}
			base.WriteKeyword(role, keyword);
			lastWritten = LastWritten.KeywordOrIdentifier;
		}

		public override void WriteToken(Role role, string token)
		{
			// Avoid that two +, - or ? tokens are combined into a ++, -- or ?? token.
			// Note that we don't need to handle tokens like = because there's no valid
			// C# program that contains the single token twice in a row.
			// (for +, - and &, this can happen with unary operators;
			// for ?, this can happen in "a is int? ? b : c" or "a as int? ?? 0";
			// and for /, this can happen with "1/ *ptr" or "1/ //comment".)
			if (lastWritten == LastWritten.Plus && token[0] == '+' ||
				lastWritten == LastWritten.Minus && token[0] == '-' ||
				lastWritten == LastWritten.Ampersand && token[0] == '&' ||
				lastWritten == LastWritten.QuestionMark && token[0] == '?' ||
				lastWritten == LastWritten.Division && token[0] == '*')
			{
				base.Space();
			}
			base.WriteToken(role, token);
			if (token == "+")
			{
				lastWritten = LastWritten.Plus;
			}
			else if (token == "-")
			{
				lastWritten = LastWritten.Minus;
			}
			else if (token == "&")
			{
				lastWritten = LastWritten.Ampersand;
			}
			else if (token == "?")
			{
				lastWritten = LastWritten.QuestionMark;
			}
			else if (token == "/")
			{
				lastWritten = LastWritten.Division;
			}
			else
			{
				lastWritten = LastWritten.Other;
			}
		}

		public override void Space()
		{
			base.Space();
			lastWritten = LastWritten.Whitespace;
		}

		public override void NewLine()
		{
			base.NewLine();
			lastWritten = LastWritten.Whitespace;
		}

		public override void WriteComment(CommentType commentType, string content)
		{
			if (lastWritten == LastWritten.Division)
			{
				// When there's a comment starting after a division operator
				// "1.0 / /*comment*/a", then we need to insert a space in front of the comment.
				base.Space();
			}
			base.WriteComment(commentType, content);
			lastWritten = LastWritten.Whitespace;
		}

		public override void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument)
		{
			base.WritePreProcessorDirective(type, argument);
			lastWritten = LastWritten.Whitespace;
		}

		public override void WritePrimitiveValue(object value, LiteralFormat format = LiteralFormat.None)
		{
			if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				Space();
			}
			base.WritePrimitiveValue(value, format);
			if (value == null || value is bool)
				return;
			if (value is string)
			{
				lastWritten = LastWritten.Other;
			}
			else if (value is char)
			{
				lastWritten = LastWritten.Other;
			}
			else if (value is decimal)
			{
				lastWritten = LastWritten.Other;
			}
			else if (value is float)
			{
				float f = (float)value;
				if (float.IsInfinity(f) || float.IsNaN(f))
					return;
				lastWritten = LastWritten.Other;
			}
			else if (value is double)
			{
				double f = (double)value;
				if (double.IsInfinity(f) || double.IsNaN(f))
					return;
				// needs space if identifier follows number;
				// this avoids mistaking the following identifier as type suffix
				lastWritten = LastWritten.KeywordOrIdentifier;
			}
			else if (value is IFormattable)
			{
				// needs space if identifier follows number;
				// this avoids mistaking the following identifier as type suffix
				lastWritten = LastWritten.KeywordOrIdentifier;
			}
			else
			{
				lastWritten = LastWritten.Other;
			}
		}

		public override void WritePrimitiveType(string type)
		{
			if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				Space();
			}
			base.WritePrimitiveType(type);
			if (type == "new")
			{
				lastWritten = LastWritten.Other;
			}
			else
			{
				lastWritten = LastWritten.KeywordOrIdentifier;
			}
		}
	}
}
---- Transformed Tree ----
using System;

using ICSharpCode.Decompiler.CSharp.Syntax;

namespace ICSharpCode.Decompiler.CSharp.OutputVisitor
{
	class InsertRequiredSpacesDecorator : DecoratingTokenWriter
	{
		/// <summary>
		/// Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
		/// </summary>
		LastWritten lastWritten;

		enum LastWritten
		{
			Whitespace,
			Other,
			KeywordOrIdentifier,
			Plus,
			Minus,
			Ampersand,
			QuestionMark,
			Division
		}

		public InsertRequiredSpacesDecorator(TokenWriter writer)
			: base(writer)
		{
		}

		public override void WriteIdentifier(Identifier identifier)
		{
			if (identifier.IsVerbatim || CSharpOutputVisitor.IsKeyword(identifier.Name, identifier))
			{
				if (lastWritten == LastWritten.KeywordOrIdentifier)
				{
					// this space is not strictly required, so we call Space()
					Space();
				}
			}
			else if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				// this space is strictly required, so we directly call the formatter
				base.Space();
			}
			base.WriteIdentifier(identifier);
			lastWritten = LastWritten.KeywordOrIdentifier;
		}

		public override void WriteKeyword(Role role, string keyword)
		{
			if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				Space();
			}
			base.WriteKeyword(role, keyword);
			lastWritten = LastWritten.KeywordOrIdentifier;
		}

		public override void WriteToken(Role role, string token)
		{
			// Avoid that two +, - or ? tokens are combined into a ++, -- or ?? token.
			// Note that we don't need to handle tokens like = because there's no valid
			// C# program that contains the single token twice in a row.
			// (for +, - and &, this can happen with unary operators;
			// for ?, this can happen in "a is int? ? b : c" or "a as int? ?? 0";
			// and for /, this can happen with "1/ *ptr" or "1/ //comment".)
			if (lastWritten == LastWritten.Plus && token[0] == '+' ||
				lastWritten == LastWritten.Minus && token[0] == '-' ||
				lastWritten == LastWritten.Ampersand && token[0] == '&' ||
				lastWritten == LastWritten.QuestionMark && token[0] == '?' ||
				lastWritten == LastWritten.Division && token[0] == '*')
			{
				base.Space();
			}
			base.WriteToken(role, token);
			if (token == "+")
			{
				lastWritten = LastWritten.Plus;
			}
			else if (token == "-")
			{
				lastWritten = LastWritten.Minus;
			}
			else if (token == "&")
			{
				lastWritten = LastWritten.Ampersand;
			}
			else if (token == "?")
			{
				lastWritten = LastWritten.QuestionMark;
			}
			else if (token == "/")
			{
				lastWritten = LastWritten.Division;
			}
			else
			{
				lastWritten = LastWritten.Other;
			}
		}

		public override void Space()
		{
			base.Space();
			lastWritten = LastWritten.Whitespace;
		}

		public override void NewLine()
		{
			base.NewLine();
			lastWritten = LastWritten.Whitespace;
		}

		public override void WriteComment(CommentType commentType, string content)
		{
			if (lastWritten == LastWritten.Division)
			{
				// When there's a comment starting after a division operator
				// "1.0 / /*comment*/a", then we need to insert a space in front of the comment.
				base.Space();
			}
			base.WriteComment(commentType, content);
			lastWritten = LastWritten.Whitespace;
		}

		public override void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument)
		{
			base.WritePreProcessorDirective(type, argument);
			lastWritten = LastWritten.Whitespace;
		}

		public override void WritePrimitiveValue(object value, LiteralFormat format = LiteralFormat.None)
		{
			if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				Space();
			}
			base.WritePrimitiveValue(value, format);
			if (value == null || value is bool)
				return;
			if (value is string)
			{
				lastWritten = LastWritten.Other;
			}
			else if (value is char)
			{
				lastWritten = LastWritten.Other;
			}
			else if (value is decimal)
			{
				lastWritten = LastWritten.Other;
			}
			else if (value is float f)
			{
				if (float.IsInfinity(f) || float.IsNaN(f))
					return;
				lastWritten = LastWritten.Other;
			}
			else if (value is double f)
			{
				if (double.IsInfinity(f) || double.IsNaN(f))
					return;
				// needs space if identifier follows number;
				// this avoids mistaking the following identifier as type suffix
				lastWritten = LastWritten.KeywordOrIdentifier;
			}
			else if (value is IFormattable)
			{
				// needs space if identifier follows number;
				// this avoids mistaking the following identifier as type suffix
				lastWritten = LastWritten.KeywordOrIdentifier;
			}
			else
			{
				lastWritten = LastWritten.Other;
			}
		}

		public override void WritePrimitiveType(string type)
		{
			if (lastWritten == LastWritten.KeywordOrIdentifier)
			{
				Space();
			}
			base.WritePrimitiveType(type);
			if (type == "new")
			{
				lastWritten = LastWritten.Other;
			}
			else
			{
				lastWritten = LastWritten.KeywordOrIdentifier;
			}
		}
	}
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\InsertRequiredSpacesDecorator.cs(178,29): error CS0136: A local or parameter named 'f' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 3 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Globalization;
using System.IO;
using System.Text;

using ICSharpCode.Decompiler.CSharp.Syntax;

namespace ICSharpCode.Decompiler.CSharp.OutputVisitor
{
	/// <summary>
	/// Writes C# code into a TextWriter.
	/// </summary>
	public class TextWriterTokenWriter : TokenWriter, ILocatable
	{
		readonly TextWriter textWriter;
		bool needsIndent = true;
		bool isAtStartOfLine = true;
		int line, column;

		public int Indentation { get; set; }

		public TextLocation Location {
			get { return new TextLocation(line, column + (needsIndent ? Indentation * IndentationString.Length : 0)); }
		}

		public string IndentationString { get; set; }

		public int Length { get; private set; }

		public TextWriterTokenWriter(TextWriter textWriter)
		{
			if (textWriter == null)
				throw new ArgumentNullException(nameof(textWriter));
			this.textWriter = textWriter;
			this.IndentationString = "\t";
			this.line = 1;
			this.column = 1;
		}

		public override void WriteIdentifier(Identifier identifier)
		{
			WriteIndentation();
			if (identifier.IsVerbatim || CSharpOutputVisitor.IsKeyword(identifier.Name, identifier))
			{
				textWriter.Write('@');
				column++;
				Length++;
			}
			string name = EscapeIdentifier(identifier.Name);
			textWriter.Write(name);
			column += name.Length;
			Length += name.Length;
			isAtStartOfLine = false;
		}

		public override void WriteKeyword(Role role, string keyword)
		{
			WriteIndentation();
			column += keyword.Length;
			Length += keyword.Length;
			textWriter.Write(keyword);
			isAtStartOfLine = false;
		}

		public override void WriteToken(Role role, string token)
		{
			WriteIndentation();
			column += token.Length;
			Length += token.Length;
			textWriter.Write(token);
			isAtStartOfLine = false;
		}

		public override void Space()
		{
			WriteIndentation();
			column++;
			Length++;
			textWriter.Write(' ');
		}

		protected void WriteIndentation()
		{
			if (needsIndent)
			{
				needsIndent = false;
				for (int i = 0; i < Indentation; i++)
				{
					textWriter.Write(this.IndentationString);
				}
				column += Indentation * IndentationString.Length;
				Length += Indentation * IndentationString.Length;
			}
		}

		public override void NewLine()
		{
			textWriter.WriteLine();
			column = 1;
			line++;
			Length += textWriter.NewLine.Length;
			needsIndent = true;
			isAtStartOfLine = true;
		}

		public override void Indent()
		{
			Indentation++;
		}

		public override void Unindent()
		{
			Indentation--;
		}

		public override void WriteComment(CommentType commentType, string content)
		{
			WriteIndentation();
			switch (commentType)
			{
				case CommentType.SingleLine:
					textWriter.Write("//");
					textWriter.WriteLine(content);
					Length += 2 + content.Length + textWriter.NewLine.Length;
					column = 1;
					line++;
					needsIndent = true;
					isAtStartOfLine = true;
					break;
				case CommentType.MultiLine:
					textWriter.Write("/*");
					textWriter.Write(content);
					textWriter.Write("*/");
					Length += 4 + content.Length;
					column += 2;
					UpdateEndLocation(content, ref line, ref column);
					column += 2;
					isAtStartOfLine = false;
					break;
				case CommentType.Documentation:
					textWriter.Write("///");
					textWriter.WriteLine(content);
					Length += 3 + content.Length + textWriter.NewLine.Length;
					column = 1;
					line++;
					needsIndent = true;
					isAtStartOfLine = true;
					break;
				case CommentType.MultiLineDocumentation:
					textWriter.Write("/**");
					textWriter.Write(content);
					textWriter.Write("*/");
					Length += 5 + content.Length;
					column += 3;
					UpdateEndLocation(content, ref line, ref column);
					column += 2;
					isAtStartOfLine = false;
					break;
				default:
					textWriter.Write(content);
					column += content.Length;
					Length += content.Length;
					break;
			}
		}

		static void UpdateEndLocation(string content, ref int line, ref int column)
		{
			if (string.IsNullOrEmpty(content))
				return;
			for (int i = 0; i < content.Length; i++)
			{
				char ch = content[i];
				switch (ch)
				{
					case '\r':
						if (i + 1 < content.Length && content[i + 1] == '\n')
							i++;
						goto case '\n';
					case '\n':
						line++;
						column = 0;
						break;
				}
				column++;
			}
		}

		public override void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument)
		{
			// pre-processor directive must start on its own line
			if (!isAtStartOfLine)
				NewLine();
			WriteIndentation();
			textWriter.Write('#');
			string directive = type.ToString().ToLowerInvariant();
			textWriter.Write(directive);
			column += 1 + directive.Length;
			Length += 1 + directive.Length;
			if (!string.IsNullOrEmpty(argument))
			{
				textWriter.Write(' ');
				textWriter.Write(argument);
				column += 1 + argument.Length;
				Length += 1 + argument.Length;
			}
			NewLine();
		}

		public static string PrintPrimitiveValue(object value)
		{
			TextWriter writer = new StringWriter();
			TextWriterTokenWriter tokenWriter = new TextWriterTokenWriter(writer);
			tokenWriter.WritePrimitiveValue(value);
			return writer.ToString();
		}

		public override void WritePrimitiveValue(object value, LiteralFormat format = LiteralFormat.None)
		{
			if (value == null)
			{
				// usually NullReferenceExpression should be used for this, but we'll handle it anyways
				textWriter.Write("null");
				column += 4;
				Length += 4;
				return;
			}

			if (value is bool)
			{
				if ((bool)value)
				{
					textWriter.Write("true");
					column += 4;
					Length += 4;
				}
				else
				{
					textWriter.Write("false");
					column += 5;
					Length += 5;
				}
				return;
			}

			if (value is string)
			{
				string tmp = ConvertString(value.ToString());
				column += tmp.Length + 2;
				Length += tmp.Length + 2;
				textWriter.Write('"');
				textWriter.Write(tmp);
				textWriter.Write('"');
			}
			else if (value is char)
			{
				string tmp = ConvertCharLiteral((char)value);
				column += tmp.Length + 2;
				Length += tmp.Length + 2;
				textWriter.Write('\'');
				textWriter.Write(tmp);
				textWriter.Write('\'');
			}
			else if (value is decimal)
			{
				string str = ((decimal)value).ToString(NumberFormatInfo.InvariantInfo) + "m";
				column += str.Length;
				Length += str.Length;
				textWriter.Write(str);
			}
			else if (value is float)
			{
				float f = (float)value;
				if (float.IsInfinity(f) || float.IsNaN(f))
				{
					// Strictly speaking, these aren't PrimitiveExpressions;
					// but we still support writing these to make life easier for code generators.
					textWriter.Write("float");
					column += 5;
					Length += 5;
					WriteToken(Roles.Dot, ".");
					if (float.IsPositiveInfinity(f))
					{
						textWriter.Write("PositiveInfinity");
						column += "PositiveInfinity".Length;
						Length += "PositiveInfinity".Length;
					}
					else if (float.IsNegativeInfinity(f))
					{
						textWriter.Write("NegativeInfinity");
						column += "NegativeInfinity".Length;
						Length += "NegativeInfinity".Length;
					}
					else
					{
						textWriter.Write("NaN");
						column += 3;
						Length += 3;
					}
					return;
				}
				var str = f.ToString("R", NumberFormatInfo.InvariantInfo) + "f";
				if (f == 0 && 1 / f == float.NegativeInfinity && str[0] != '-')
				{
					// negative zero is a special case
					// (again, not a primitive expression, but it's better to handle
					// the special case here than to do it in all code generators)
					str = '-' + str;
				}
				column += str.Length;
				Length += str.Length;
				textWriter.Write(str);
			}
			else if (value is double)
			{
				double f = (double)value;
				if (double.IsInfinity(f) || double.IsNaN(f))
				{
					// Strictly speaking, these aren't PrimitiveExpressions;
					// but we still support writing these to make life easier for code generators.
					textWriter.Write("double");
					column += 6;
					Length += 6;
					WriteToken(Roles.Dot, ".");
					if (double.IsPositiveInfinity(f))
					{
						textWriter.Write("PositiveInfinity");
						column += "PositiveInfinity".Length;
						Length += "PositiveInfinity".Length;
					}
					else if (double.IsNegativeInfinity(f))
					{
						textWriter.Write("NegativeInfinity");
						column += "NegativeInfinity".Length;
						Length += "NegativeInfinity".Length;
					}
					else
					{
						textWriter.Write("NaN");
						column += 3;
						Length += 3;
					}
					return;
				}
				string number = f.ToString("R", NumberFormatInfo.InvariantInfo);
				if (f == 0 && 1 / f == double.NegativeInfinity && number[0] != '-')
				{
					// negative zero is a special case
					// (again, not a primitive expression, but it's better to handle
					// the special case here than to do it in all code generators)
					number = '-' + number;
				}
				if (number.IndexOf('.') < 0 && number.IndexOf('E') < 0)
				{
					number += ".0";
				}
				textWriter.Write(number);
				column += number.Length;
				Length += number.Length;
			}
			else if (value is IFormattable)
			{
				StringBuilder b = new StringBuilder();
				if (format == LiteralFormat.HexadecimalNumber)
				{
					b.Append("0x");
					b.Append(((IFormattable)value).ToString("X", NumberFormatInfo.InvariantInfo));
				}
				else
				{
					b.Append(((IFormattable)value).ToString(null, NumberFormatInfo.InvariantInfo));
				}
				if (value is uint || value is ulong)
				{
					b.Append("u");
				}
				if (value is long || value is ulong)
				{
					b.Append("L");
				}
				textWriter.Write(b.ToString());
				column += b.Length;
				Length += b.Length;
			}
			else
			{
				textWriter.Write(value.ToString());
				int length = value.ToString().Length;
				column += length;
				Length += length;
			}
		}

		public override void WriteInterpolatedText(string text)
		{
			textWriter.Write(ConvertString(text));
		}

		/// <summary>
		/// Gets the escape sequence for the specified character within a char literal.
		/// Does not include the single quotes surrounding the char literal.
		/// </summary>
		public static string ConvertCharLiteral(char ch)
		{
			if (ch == '\'')
			{
				return "\\'";
			}
			return ConvertChar(ch) ?? ch.ToString();
		}

		/// <summary>
		/// Gets the escape sequence for the specified character.
		/// </summary>
		/// <remarks>This method does not convert ' or ".</remarks>
		static string ConvertChar(char ch)
		{
			switch (ch)
			{
				case '\\':
					return "\\\\";
				case '\0':
					return "\\0";
				case '\a':
					return "\\a";
				case '\b':
					return "\\b";
				case '\f':
					return "\\f";
				case '\n':
					return "\\n";
				case '\r':
					return "\\r";
				case '\t':
					return "\\t";
				case '\v':
					return "\\v";
				case ' ':
				case '_':
				case '`':
				case '^':
					// ASCII characters we allow directly in the output even though we don't use
					// other Unicode characters of the same category.
					return null;
				case '\ufffd':
					return "\\u" + ((int)ch).ToString("x4");
				default:
					switch (char.GetUnicodeCategory(ch))
					{
						case UnicodeCategory.NonSpacingMark:
						case UnicodeCategory.SpacingCombiningMark:
						case UnicodeCategory.EnclosingMark:
						case UnicodeCategory.LineSeparator:
						case UnicodeCategory.ParagraphSeparator:
						case UnicodeCategory.Control:
						case UnicodeCategory.Format:
						case UnicodeCategory.Surrogate:
						case UnicodeCategory.PrivateUse:
						case UnicodeCategory.ConnectorPunctuation:
						case UnicodeCategory.ModifierSymbol:
						case UnicodeCategory.OtherNotAssigned:
						case UnicodeCategory.SpaceSeparator:
							return "\\u" + ((int)ch).ToString("x4");
						default:
							return null;
					}
			}
		}

		/// <summary>
		/// Converts special characters to escape sequences within the given string.
		/// </summary>
		public static string ConvertString(string str)
		{
			StringBuilder sb = new StringBuilder();
			foreach (char ch in str)
			{
				string s = ch == '"' ? "\\\"" : ConvertChar(ch);
				if (s != null)
					sb.Append(s);
				else
					sb.Append(ch);
			}
			return sb.ToString();
		}

		public static string EscapeIdentifier(string identifier)
		{
			if (string.IsNullOrEmpty(identifier))
				return identifier;
			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < identifier.Length; i++)
			{
				if (IsPrintableIdentifierChar(identifier, i))
				{
					if (char.IsSurrogatePair(identifier, i))
					{
						sb.Append(identifier.Substring(i, 2));
						i++;
					}
					else
					{
						sb.Append(identifier[i]);
					}
				}
				else
				{
					if (char.IsSurrogatePair(identifier, i))
					{
						sb.AppendFormat("\\U{0:x8}", char.ConvertToUtf32(identifier, i));
						i++;
					}
					else
					{
						sb.AppendFormat("\\u{0:x4}", (int)identifier[i]);
					}
				}
			}
			return sb.ToString();
		}

		public static bool ContainsNonPrintableIdentifierChar(string identifier)
		{
			if (string.IsNullOrEmpty(identifier))
				return false;

			for (int i = 0; i < identifier.Length; i++)
			{
				if (char.IsWhiteSpace(identifier[i]))
					return true;
				if (!IsPrintableIdentifierChar(identifier, i))
					return true;
			}

			return false;
		}

		static bool IsPrintableIdentifierChar(string identifier, int index)
		{
			switch (identifier[index])
			{
				case '\\':
					return false;
				case ' ':
				case '_':
				case '`':
				case '^':
					return true;
			}
			switch (char.GetUnicodeCategory(identifier, index))
			{
				case UnicodeCategory.NonSpacingMark:
				case UnicodeCategory.SpacingCombiningMark:
				case UnicodeCategory.EnclosingMark:
				case UnicodeCategory.LineSeparator:
				case UnicodeCategory.ParagraphSeparator:
				case UnicodeCategory.Control:
				case UnicodeCategory.Format:
				case UnicodeCategory.Surrogate:
				case UnicodeCategory.PrivateUse:
				case UnicodeCategory.ConnectorPunctuation:
				case UnicodeCategory.ModifierSymbol:
				case UnicodeCategory.OtherNotAssigned:
				case UnicodeCategory.SpaceSeparator:
					return false;
				default:
					return true;
			}
		}

		public override void WritePrimitiveType(string type)
		{
			textWriter.Write(type);
			column += type.Length;
			Length += type.Length;
			if (type == "new")
			{
				textWriter.Write("()");
				column += 2;
				Length += 2;
			}
		}

		public override void StartNode(AstNode node)
		{
			// Write out the indentation, so that overrides of this method
			// can rely use the current output length to identify the position of the node
			// in the output.
			WriteIndentation();
		}

		public override void EndNode(AstNode node)
		{
		}
	}
}

---- Transformed Tree ----
using System;
using System.Globalization;
using System.IO;
using System.Text;

using ICSharpCode.Decompiler.CSharp.Syntax;

namespace ICSharpCode.Decompiler.CSharp.OutputVisitor
{
	/// <summary>
	/// Writes C# code into a TextWriter.
	/// </summary>
	public class TextWriterTokenWriter : TokenWriter, ILocatable
	{
		readonly TextWriter textWriter;
		bool needsIndent = true;
		bool isAtStartOfLine = true;
		int line, column;

		public int Indentation { get; set; }

		public TextLocation Location {
			get { return new TextLocation(line, column + (needsIndent ? Indentation * IndentationString.Length : 0)); }
		}

		public string IndentationString { get; set; }

		public int Length { get; private set; }

		public TextWriterTokenWriter(TextWriter textWriter)
		{
			if (textWriter == null)
				throw new ArgumentNullException(nameof(textWriter));
			this.textWriter = textWriter;
			this.IndentationString = "\t";
			this.line = 1;
			this.column = 1;
		}

		public override void WriteIdentifier(Identifier identifier)
		{
			WriteIndentation();
			if (identifier.IsVerbatim || CSharpOutputVisitor.IsKeyword(identifier.Name, identifier))
			{
				textWriter.Write('@');
				column++;
				Length++;
			}
			string name = EscapeIdentifier(identifier.Name);
			textWriter.Write(name);
			column += name.Length;
			Length += name.Length;
			isAtStartOfLine = false;
		}

		public override void WriteKeyword(Role role, string keyword)
		{
			WriteIndentation();
			column += keyword.Length;
			Length += keyword.Length;
			textWriter.Write(keyword);
			isAtStartOfLine = false;
		}

		public override void WriteToken(Role role, string token)
		{
			WriteIndentation();
			column += token.Length;
			Length += token.Length;
			textWriter.Write(token);
			isAtStartOfLine = false;
		}

		public override void Space()
		{
			WriteIndentation();
			column++;
			Length++;
			textWriter.Write(' ');
		}

		protected void WriteIndentation()
		{
			if (needsIndent)
			{
				needsIndent = false;
				for (int i = 0; i < Indentation; i++)
				{
					textWriter.Write(this.IndentationString);
				}
				column += Indentation * IndentationString.Length;
				Length += Indentation * IndentationString.Length;
			}
		}

		public override void NewLine()
		{
			textWriter.WriteLine();
			column = 1;
			line++;
			Length += textWriter.NewLine.Length;
			needsIndent = true;
			isAtStartOfLine = true;
		}

		public override void Indent()
		{
			Indentation++;
		}

		public override void Unindent()
		{
			Indentation--;
		}

		public override void WriteComment(CommentType commentType, string content)
		{
			WriteIndentation();
			switch (commentType)
			{
				case CommentType.SingleLine:
					textWriter.Write("//");
					textWriter.WriteLine(content);
					Length += 2 + content.Length + textWriter.NewLine.Length;
					column = 1;
					line++;
					needsIndent = true;
					isAtStartOfLine = true;
					break;
				case CommentType.MultiLine:
					textWriter.Write("/*");
					textWriter.Write(content);
					textWriter.Write("*/");
					Length += 4 + content.Length;
					column += 2;
					UpdateEndLocation(content, ref line, ref column);
					column += 2;
					isAtStartOfLine = false;
					break;
				case CommentType.Documentation:
					textWriter.Write("///");
					textWriter.WriteLine(content);
					Length += 3 + content.Length + textWriter.NewLine.Length;
					column = 1;
					line++;
					needsIndent = true;
					isAtStartOfLine = true;
					break;
				case CommentType.MultiLineDocumentation:
					textWriter.Write("/**");
					textWriter.Write(content);
					textWriter.Write("*/");
					Length += 5 + content.Length;
					column += 3;
					UpdateEndLocation(content, ref line, ref column);
					column += 2;
					isAtStartOfLine = false;
					break;
				default:
					textWriter.Write(content);
					column += content.Length;
					Length += content.Length;
					break;
			}
		}

		static void UpdateEndLocation(string content, ref int line, ref int column)
		{
			if (string.IsNullOrEmpty(content))
				return;
			for (int i = 0; i < content.Length; i++)
			{
				char ch = content[i];
				switch (ch)
				{
					case '\r':
						if (i + 1 < content.Length && content[i + 1] == '\n')
							i++;
						goto case '\n';
					case '\n':
						line++;
						column = 0;
						break;
				}
				column++;
			}
		}

		public override void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument)
		{
			// pre-processor directive must start on its own line
			if (!isAtStartOfLine)
				NewLine();
			WriteIndentation();
			textWriter.Write('#');
			string directive = type.ToString().ToLowerInvariant();
			textWriter.Write(directive);
			column += 1 + directive.Length;
			Length += 1 + directive.Length;
			if (!string.IsNullOrEmpty(argument))
			{
				textWriter.Write(' ');
				textWriter.Write(argument);
				column += 1 + argument.Length;
				Length += 1 + argument.Length;
			}
			NewLine();
		}

		public static string PrintPrimitiveValue(object value)
		{
			TextWriter writer = new StringWriter();
			TextWriterTokenWriter tokenWriter = new TextWriterTokenWriter(writer);
			tokenWriter.WritePrimitiveValue(value);
			return writer.ToString();
		}

		public override void WritePrimitiveValue(object value, LiteralFormat format = LiteralFormat.None)
		{
			if (value == null)
			{
				// usually NullReferenceExpression should be used for this, but we'll handle it anyways
				textWriter.Write("null");
				column += 4;
				Length += 4;
				return;
			}

			if (value is bool)
			{
				if ((bool)value)
				{
					textWriter.Write("true");
					column += 4;
					Length += 4;
				}
				else
				{
					textWriter.Write("false");
					column += 5;
					Length += 5;
				}
				return;
			}

			if (value is string)
			{
				string tmp = ConvertString(value.ToString());
				column += tmp.Length + 2;
				Length += tmp.Length + 2;
				textWriter.Write('"');
				textWriter.Write(tmp);
				textWriter.Write('"');
			}
			else if (value is char c)
			{
				string tmp = ConvertCharLiteral(c);
				column += tmp.Length + 2;
				Length += tmp.Length + 2;
				textWriter.Write('\'');
				textWriter.Write(tmp);
				textWriter.Write('\'');
			}
			else if (value is decimal d)
			{
				string str = d.ToString(NumberFormatInfo.InvariantInfo) + "m";
				column += str.Length;
				Length += str.Length;
				textWriter.Write(str);
			}
			else if (value is float f)
			{
				if (float.IsInfinity(f) || float.IsNaN(f))
				{
					// Strictly speaking, these aren't PrimitiveExpressions;
					// but we still support writing these to make life easier for code generators.
					textWriter.Write("float");
					column += 5;
					Length += 5;
					WriteToken(Roles.Dot, ".");
					if (float.IsPositiveInfinity(f))
					{
						textWriter.Write("PositiveInfinity");
						column += "PositiveInfinity".Length;
						Length += "PositiveInfinity".Length;
					}
					else if (float.IsNegativeInfinity(f))
					{
						textWriter.Write("NegativeInfinity");
						column += "NegativeInfinity".Length;
						Length += "NegativeInfinity".Length;
					}
					else
					{
						textWriter.Write("NaN");
						column += 3;
						Length += 3;
					}
					return;
				}
				var str = f.ToString("R", NumberFormatInfo.InvariantInfo) + "f";
				if (f == 0 && 1 / f == float.NegativeInfinity && str[0] != '-')
				{
					// negative zero is a special case
					// (again, not a primitive expression, but it's better to handle
					// the special case here than to do it in all code generators)
					str = '-' + str;
				}
				column += str.Length;
				Length += str.Length;
				textWriter.Write(str);
			}
			else if (value is double f)
			{
				if (double.IsInfinity(f) || double.IsNaN(f))
				{
					// Strictly speaking, these aren't PrimitiveExpressions;
					// but we still support writing these to make life easier for code generators.
					textWriter.Write("double");
					column += 6;
					Length += 6;
					WriteToken(Roles.Dot, ".");
					if (double.IsPositiveInfinity(f))
					{
						textWriter.Write("PositiveInfinity");
						column += "PositiveInfinity".Length;
						Length += "PositiveInfinity".Length;
					}
					else if (double.IsNegativeInfinity(f))
					{
						textWriter.Write("NegativeInfinity");
						column += "NegativeInfinity".Length;
						Length += "NegativeInfinity".Length;
					}
					else
					{
						textWriter.Write("NaN");
						column += 3;
						Length += 3;
					}
					return;
				}
				string number = f.ToString("R", NumberFormatInfo.InvariantInfo);
				if (f == 0 && 1 / f == double.NegativeInfinity && number[0] != '-')
				{
					// negative zero is a special case
					// (again, not a primitive expression, but it's better to handle
					// the special case here than to do it in all code generators)
					number = '-' + number;
				}
				if (number.IndexOf('.') < 0 && number.IndexOf('E') < 0)
				{
					number += ".0";
				}
				textWriter.Write(number);
				column += number.Length;
				Length += number.Length;
			}
			else if (value is IFormattable iFormattable)
			{
				StringBuilder b = new StringBuilder();
				if (format == LiteralFormat.HexadecimalNumber)
				{
					b.Append("0x");
					b.Append(iFormattable.ToString("X", NumberFormatInfo.InvariantInfo));
				}
				else
				{
					b.Append(((IFormattable)value).ToString(null, NumberFormatInfo.InvariantInfo));
				}
				if (value is uint || value is ulong)
				{
					b.Append("u");
				}
				if (value is long || value is ulong)
				{
					b.Append("L");
				}
				textWriter.Write(b.ToString());
				column += b.Length;
				Length += b.Length;
			}
			else
			{
				textWriter.Write(value.ToString());
				int length = value.ToString().Length;
				column += length;
				Length += length;
			}
		}

		public override void WriteInterpolatedText(string text)
		{
			textWriter.Write(ConvertString(text));
		}

		/// <summary>
		/// Gets the escape sequence for the specified character within a char literal.
		/// Does not include the single quotes surrounding the char literal.
		/// </summary>
		public static string ConvertCharLiteral(char ch)
		{
			if (ch == '\'')
			{
				return "\\'";
			}
			return ConvertChar(ch) ?? ch.ToString();
		}

		/// <summary>
		/// Gets the escape sequence for the specified character.
		/// </summary>
		/// <remarks>This method does not convert ' or ".</remarks>
		static string ConvertChar(char ch)
		{
			switch (ch)
			{
				case '\\':
					return "\\\\";
				case '\0':
					return "\\0";
				case '\a':
					return "\\a";
				case '\b':
					return "\\b";
				case '\f':
					return "\\f";
				case '\n':
					return "\\n";
				case '\r':
					return "\\r";
				case '\t':
					return "\\t";
				case '\v':
					return "\\v";
				case ' ':
				case '_':
				case '`':
				case '^':
					// ASCII characters we allow directly in the output even though we don't use
					// other Unicode characters of the same category.
					return null;
				case '\ufffd':
					return "\\u" + ((int)ch).ToString("x4");
				default:
					switch (char.GetUnicodeCategory(ch))
					{
						case UnicodeCategory.NonSpacingMark:
						case UnicodeCategory.SpacingCombiningMark:
						case UnicodeCategory.EnclosingMark:
						case UnicodeCategory.LineSeparator:
						case UnicodeCategory.ParagraphSeparator:
						case UnicodeCategory.Control:
						case UnicodeCategory.Format:
						case UnicodeCategory.Surrogate:
						case UnicodeCategory.PrivateUse:
						case UnicodeCategory.ConnectorPunctuation:
						case UnicodeCategory.ModifierSymbol:
						case UnicodeCategory.OtherNotAssigned:
						case UnicodeCategory.SpaceSeparator:
							return "\\u" + ((int)ch).ToString("x4");
						default:
							return null;
					}
			}
		}

		/// <summary>
		/// Converts special characters to escape sequences within the given string.
		/// </summary>
		public static string ConvertString(string str)
		{
			StringBuilder sb = new StringBuilder();
			foreach (char ch in str)
			{
				string s = ch == '"' ? "\\\"" : ConvertChar(ch);
				if (s != null)
					sb.Append(s);
				else
					sb.Append(ch);
			}
			return sb.ToString();
		}

		public static string EscapeIdentifier(string identifier)
		{
			if (string.IsNullOrEmpty(identifier))
				return identifier;
			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < identifier.Length; i++)
			{
				if (IsPrintableIdentifierChar(identifier, i))
				{
					if (char.IsSurrogatePair(identifier, i))
					{
						sb.Append(identifier.Substring(i, 2));
						i++;
					}
					else
					{
						sb.Append(identifier[i]);
					}
				}
				else
				{
					if (char.IsSurrogatePair(identifier, i))
					{
						sb.AppendFormat("\\U{0:x8}", char.ConvertToUtf32(identifier, i));
						i++;
					}
					else
					{
						sb.AppendFormat("\\u{0:x4}", (int)identifier[i]);
					}
				}
			}
			return sb.ToString();
		}

		public static bool ContainsNonPrintableIdentifierChar(string identifier)
		{
			if (string.IsNullOrEmpty(identifier))
				return false;

			for (int i = 0; i < identifier.Length; i++)
			{
				if (char.IsWhiteSpace(identifier[i]))
					return true;
				if (!IsPrintableIdentifierChar(identifier, i))
					return true;
			}

			return false;
		}

		static bool IsPrintableIdentifierChar(string identifier, int index)
		{
			switch (identifier[index])
			{
				case '\\':
					return false;
				case ' ':
				case '_':
				case '`':
				case '^':
					return true;
			}
			switch (char.GetUnicodeCategory(identifier, index))
			{
				case UnicodeCategory.NonSpacingMark:
				case UnicodeCategory.SpacingCombiningMark:
				case UnicodeCategory.EnclosingMark:
				case UnicodeCategory.LineSeparator:
				case UnicodeCategory.ParagraphSeparator:
				case UnicodeCategory.Control:
				case UnicodeCategory.Format:
				case UnicodeCategory.Surrogate:
				case UnicodeCategory.PrivateUse:
				case UnicodeCategory.ConnectorPunctuation:
				case UnicodeCategory.ModifierSymbol:
				case UnicodeCategory.OtherNotAssigned:
				case UnicodeCategory.SpaceSeparator:
					return false;
				default:
					return true;
			}
		}

		public override void WritePrimitiveType(string type)
		{
			textWriter.Write(type);
			column += type.Length;
			Length += type.Length;
			if (type == "new")
			{
				textWriter.Write("()");
				column += 2;
				Length += 2;
			}
		}

		public override void StartNode(AstNode node)
		{
			// Write out the indentation, so that overrides of this method
			// can rely use the current output length to identify the position of the node
			// in the output.
			WriteIndentation();
		}

		public override void EndNode(AstNode node)
		{
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\CSharp\OutputVisitor\TextWriterTokenWriter.cs(331,29): error CS0136: A local or parameter named 'f' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\CSharpConversions.cs
Description: Error: Unable to create valid SyntaxTree for document: CSharpConversions.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (s is ParameterizedType ps && t is ParameterizedType pt)
				{
					// C# 4.0 spec: 13.1.3.2 Variance Conversion
					for (int i = 0; i < def.TypeParameters.Count; i++)
					{
						IType si = ps.GetTypeArgument(i);
						IType ti = pt.GetTypeArgument(i);
						if (IdentityConversion(si, ti))
							continue;
						ITypeParameter xi = def.TypeParameters[i];
						switch (xi.Variance)
						{
							case VarianceModifier.Covariant:
								if (!ImplicitReferenceConversion(si, ti, subtypeCheckNestingDepth))
									return false;
								break;
							case VarianceModifier.Contravariant:
								if (!ImplicitReferenceConversion(ti, si, subtypeCheckNestingDepth))
									return false;
								break;
							default:
								return false;
						}
					}
				}
				else if (s is ParameterizedType ps || t is ParameterizedType pt)
				{
					return false; // only of of them is parameterized, or counts don't match? -> not valid conversion
				}
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (s is ParameterizedType ps && t is ParameterizedType pt)
				{
					// C# 4.0 spec: 13.1.3.2 Variance Conversion
					for (int i = 0; i < def.TypeParameters.Count; i++)
					{
						IType si = ps.GetTypeArgument(i);
						IType ti = pt.GetTypeArgument(i);
						if (IdentityConversion(si, ti))
							continue;
						ITypeParameter xi = def.TypeParameters[i];
						switch (xi.Variance)
						{
							case VarianceModifier.Covariant:
								if (!ImplicitReferenceConversion(si, ti, subtypeCheckNestingDepth))
									return false;
								break;
							case VarianceModifier.Contravariant:
								if (!ImplicitReferenceConversion(ti, si, subtypeCheckNestingDepth))
									return false;
								break;
							default:
								return false;
						}
					}
				}
				else if (s is ParameterizedType ps || t is ParameterizedType pt)
				{
					return false; // only of of them is parameterized, or counts don't match? -> not valid conversion
				}
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;

using ICSharpCode.Decompiler.Semantics;
using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.CSharp.Resolver
{
	/// <summary>
	/// Contains logic that determines whether an implicit conversion exists between two types.
	/// </summary>
	/// <remarks>
	/// This class is thread-safe.
	/// </remarks>
	public sealed class CSharpConversions
	{
		readonly ConcurrentDictionary<TypePair, Conversion> implicitConversionCache = new ConcurrentDictionary<TypePair, Conversion>();
		readonly ICompilation compilation;

		public CSharpConversions(ICompilation compilation)
		{
			if (compilation == null)
				throw new ArgumentNullException(nameof(compilation));
			this.compilation = compilation;
		}

		/// <summary>
		/// Gets the Conversions instance for the specified <see cref="ICompilation"/>.
		/// This will make use of the context's cache manager to reuse the Conversions instance.
		/// </summary>
		public static CSharpConversions Get(ICompilation compilation)
		{
			if (compilation == null)
				throw new ArgumentNullException(nameof(compilation));
			CacheManager cache = compilation.CacheManager;
			CSharpConversions operators = (CSharpConversions)cache.GetShared(typeof(CSharpConversions));
			if (operators == null)
			{
				operators = (CSharpConversions)cache.GetOrAddShared(typeof(CSharpConversions), new CSharpConversions(compilation));
			}
			return operators;
		}

		#region TypePair (for caching)
		struct TypePair : IEquatable<TypePair>
		{
			public readonly IType FromType;
			public readonly IType ToType;

			public TypePair(IType fromType, IType toType)
			{
				Debug.Assert(fromType != null && toType != null);
				this.FromType = fromType;
				this.ToType = toType;
			}

			public override bool Equals(object obj)
			{
				return (obj is TypePair) && Equals((TypePair)obj);
			}

			public bool Equals(TypePair other)
			{
				return object.Equals(this.FromType, other.FromType) && object.Equals(this.ToType, other.ToType);
			}

			public override int GetHashCode()
			{
				unchecked
				{
					return 1000000007 * FromType.GetHashCode() + 1000000009 * ToType.GetHashCode();
				}
			}
		}
		#endregion

		#region ImplicitConversion
		private Conversion ImplicitConversion(ResolveResult resolveResult, IType toType, bool allowUserDefined, bool allowTuple)
		{
			Conversion c;
			if (resolveResult.IsCompileTimeConstant)
			{
				c = ImplicitEnumerationConversion(resolveResult, toType);
				if (c.IsValid)
					return c;
				if (ImplicitConstantExpressionConversion(resolveResult, toType))
					return Conversion.ImplicitConstantExpressionConversion;
				c = StandardImplicitConversion(resolveResult.Type, toType, allowTuple);
				if (c != Conversion.None)
					return c;
				if (allowUserDefined)
				{
					c = UserDefinedImplicitConversion(resolveResult, resolveResult.Type, toType);
					if (c != Conversion.None)
						return c;
				}
			}
			else
			{
				if (allowTuple && resolveResult is TupleResolveResult tupleRR)
				{
					c = TupleConversion(tupleRR, toType, isExplicit: false);
					if (c != Conversion.None)
						return c;
				}
				if (resolveResult is ThrowResolveResult)
				{
					return Conversion.ThrowExpressionConversion;
				}
				if (allowUserDefined && allowTuple)
				{
					// if allowUserDefined and allowTuple are true, we might as well use the cache
					c = ImplicitConversion(resolveResult.Type, toType);
				}
				else
				{
					c = ImplicitConversion(resolveResult.Type, toType, allowUserDefined, allowTuple);
				}
				if (c != Conversion.None)
					return c;
			}
			if (resolveResult is InterpolatedStringResolveResult isrr)
			{
				if (toType.IsKnownType(KnownTypeCode.IFormattable) || toType.IsKnownType(KnownTypeCode.FormattableString))
					return Conversion.ImplicitInterpolatedStringConversion;
			}
			if (resolveResult.Type.Kind == TypeKind.Dynamic)
				return Conversion.ImplicitDynamicConversion;
			c = AnonymousFunctionConversion(resolveResult, toType);
			if (c != Conversion.None)
				return c;
			c = MethodGroupConversion(resolveResult, toType);
			return c;
		}

		private Conversion ImplicitConversion(IType fromType, IType toType, bool allowUserDefined, bool allowTuple)
		{
			// C# 4.0 spec: 6.1
			var c = StandardImplicitConversion(fromType, toType, allowTuple);
			if (c == Conversion.None && allowUserDefined)
			{
				c = UserDefinedImplicitConversion(null, fromType, toType);
			}
			return c;
		}

		public Conversion ImplicitConversion(ResolveResult resolveResult, IType toType)
		{
			if (resolveResult == null)
				throw new ArgumentNullException(nameof(resolveResult));
			return ImplicitConversion(resolveResult, toType, allowUserDefined: true, allowTuple: true);
		}

		public Conversion ImplicitConversion(IType fromType, IType toType)
		{
			if (fromType == null)
				throw new ArgumentNullException(nameof(fromType));
			if (toType == null)
				throw new ArgumentNullException(nameof(toType));

			TypePair pair = new TypePair(fromType, toType);
			if (implicitConversionCache.TryGetValue(pair, out Conversion c))
				return c;

			c = ImplicitConversion(fromType, toType, allowUserDefined: true, allowTuple: true);

			implicitConversionCache[pair] = c;
			return c;
		}

		public Conversion StandardImplicitConversion(IType fromType, IType toType)
		{
			if (fromType == null)
				throw new ArgumentNullException(nameof(fromType));
			if (toType == null)
				throw new ArgumentNullException(nameof(toType));
			return StandardImplicitConversion(fromType, toType, allowTupleConversion: true);
		}

		Conversion StandardImplicitConversion(IType fromType, IType toType, bool allowTupleConversion)
		{
			// C# 4.0 spec: 6.3.1
			if (IdentityConversion(fromType, toType))
				return Conversion.IdentityConversion;
			if (ImplicitNumericConversion(fromType, toType))
				return Conversion.ImplicitNumericConversion;
			Conversion c = ImplicitNullableConversion(fromType, toType);
			if (c != Conversion.None)
				return c;
			if (NullLiteralConversion(fromType, toType))
				return Conversion.NullLiteralConversion;
			if (ImplicitReferenceConversion(fromType, toType, 0))
				return Conversion.ImplicitReferenceConversion;
			if (IsBoxingConversion(fromType, toType))
				return Conversion.BoxingConversion;
			if (ImplicitTypeParameterConversion(fromType, toType))
			{
				// Implicit type parameter conversions that aren't also
				// reference conversions are considered to be boxing conversions
				return Conversion.BoxingConversion;
			}
			if (ImplicitPointerConversion(fromType, toType))
				return Conversion.ImplicitPointerConversion;
			if (allowTupleConversion)
			{
				c = TupleConversion(fromType, toType, isExplicit: false);
				if (c != Conversion.None)
					return c;
			}
			return Conversion.None;
		}

		/// <summary>
		/// Gets whether the type 'fromType' is convertible to 'toType'
		/// using one of the conversions allowed when satisying constraints (4.4.4)
		/// </summary>
		public bool IsConstraintConvertible(IType fromType, IType toType)
		{
			if (fromType == null)
				throw new ArgumentNullException(nameof(fromType));
			if (toType == null)
				throw new ArgumentNullException(nameof(toType));

			if (IdentityConversion(fromType, toType))
				return true;
			if (ImplicitReferenceConversion(fromType, toType, 0))
				return true;
			if (NullableType.IsNullable(fromType))
			{
				// An 'object' constraint still allows nullable value types
				// (object constraints don't exist in C#, but are inserted by DefaultResolvedTypeParameter.DirectBaseTypes)
				if (toType.IsKnownType(KnownTypeCode.Object))
					return true;
			}
			else
			{
				if (IsBoxingConversion(fromType, toType))
					return true;
			}
			if (ImplicitTypeParameterConversion(fromType, toType))
				return true;
			return false;
		}
		#endregion

		#region ExplicitConversion
		public Conversion ExplicitConversion(ResolveResult resolveResult, IType toType)
		{
			if (resolveResult == null)
				throw new ArgumentNullException(nameof(resolveResult));
			if (toType == null)
				throw new ArgumentNullException(nameof(toType));

			if (resolveResult.Type.Kind == TypeKind.Dynamic)
				return Conversion.ExplicitDynamicConversion;
			Conversion c = ImplicitConversion(resolveResult, toType, allowUserDefined: false, allowTuple: false);
			if (c != Conversion.None)
				return c;
			if (resolveResult is TupleResolveResult tupleRR)
			{
				c = TupleConversion(tupleRR, toType, isExplicit: true);
				if (c != Conversion.None)
					return c;
			}
			c = ExplicitConversionImpl(resolveResult.Type, toType);
			if (c != Conversion.None)
				return c;
			return UserDefinedExplicitConversion(resolveResult, resolveResult.Type, toType);
		}

		public Conversion ExplicitConversion(IType fromType, IType toType)
		{
			if (fromType == null)
				throw new ArgumentNullException(nameof(fromType));
			if (toType == null)
				throw new ArgumentNullException(nameof(toType));

			Conversion c = ImplicitConversion(fromType, toType, allowUserDefined: false, allowTuple: false);
			if (c != Conversion.None)
				return c;
			c = ExplicitConversionImpl(fromType, toType);
			if (c != Conversion.None)
				return c;
			return UserDefinedExplicitConversion(null, fromType, toType);
		}

		Conversion ExplicitConversionImpl(IType fromType, IType toType)
		{
			// This method is called after we already checked for implicit conversions,
			// so any remaining conversions must be explicit.
			if (AnyNumericConversion(fromType, toType))
				return Conversion.ExplicitNumericConversion;
			if (ExplicitEnumerationConversion(fromType, toType))
				return Conversion.EnumerationConversion(false, false);
			Conversion c = ExplicitNullableConversion(fromType, toType);
			if (c != Conversion.None)
				return c;
			if (ExplicitReferenceConversion(fromType, toType))
				return Conversion.ExplicitReferenceConversion;
			if (UnboxingConversion(fromType, toType))
				return Conversion.UnboxingConversion;
			c = ExplicitTypeParameterConversion(fromType, toType);
			if (c != Conversion.None)
				return c;
			if (ExplicitPointerConversion(fromType, toType))
				return Conversion.ExplicitPointerConversion;
			return TupleConversion(fromType, toType, isExplicit: true);
		}
		#endregion

		#region Identity Conversion
		/// <summary>
		/// Gets whether there is an identity conversion from <paramref name="fromType"/> to <paramref name="toType"/>
		/// </summary>
		public bool IdentityConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.1
			fromType = fromType.AcceptVisitor(NormalizeTypeVisitor.TypeErasure);
			toType = toType.AcceptVisitor(NormalizeTypeVisitor.TypeErasure);
			return fromType.Equals(toType);
		}
		#endregion

		#region Numeric Conversions
		static readonly bool[,] implicitNumericConversionLookup = {
			//       to:   short  ushort  int   uint   long   ulong
			// from:
			/* char   */ { false, true , true , true , true , true  },
			/* sbyte  */ { true , false, true , false, true , false },
			/* byte   */ { true , true , true , true , true , true  },
			/* short  */ { true , false, true , false, true , false },
			/* ushort */ { false, true , true , true , true , true  },
			/* int    */ { false, false, true , false, true , false },
			/* uint   */ { false, false, false, true , true , true  },
			/* long   */ { false, false, false, false, true , false },
			/* ulong  */ { false, false, false, false, false, true  },
		};

		bool ImplicitNumericConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.2

			TypeCode from = ReflectionHelper.GetTypeCode(fromType);
			if (from == TypeCode.Empty)
			{
				// When converting from a native-sized integer, treat it as 64-bits
				switch (fromType.Kind)
				{
					case TypeKind.NInt:
						from = TypeCode.Int64;
						break;
					case TypeKind.NUInt:
						from = TypeCode.UInt64;
						break;
				}
			}
			TypeCode to = ReflectionHelper.GetTypeCode(toType);
			if (to == TypeCode.Empty)
			{
				// When converting to a native-sized integer, only 32-bits can be stored safely
				switch (toType.Kind)
				{
					case TypeKind.NInt:
						to = TypeCode.Int32;
						break;
					case TypeKind.NUInt:
						to = TypeCode.UInt32;
						break;
				}
			}
			if (to >= TypeCode.Single && to <= TypeCode.Decimal)
			{
				// Conversions to float/double/decimal exist from all integral types,
				// and there's a conversion from float to double.
				return from >= TypeCode.Char && from <= TypeCode.UInt64
					|| from == TypeCode.Single && to == TypeCode.Double;
			}
			else
			{
				// Conversions to integral types: look at the table
				return from >= TypeCode.Char && from <= TypeCode.UInt64
					&& to >= TypeCode.Int16 && to <= TypeCode.UInt64
					&& implicitNumericConversionLookup[from - TypeCode.Char, to - TypeCode.Int16];
			}
		}

		bool IsNumericType(IType type)
		{
			switch (type.Kind)
			{
				case TypeKind.NInt:
				case TypeKind.NUInt:
					return true;
			}
			TypeCode c = ReflectionHelper.GetTypeCode(type);
			return c >= TypeCode.Char && c <= TypeCode.Decimal;
		}

		bool AnyNumericConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.2 + 6.2.1
			return IsNumericType(fromType) && IsNumericType(toType);
		}
		#endregion

		#region Enumeration Conversions
		Conversion ImplicitEnumerationConversion(ResolveResult rr, IType toType)
		{
			// C# 4.0 spec: 6.1.3
			Debug.Assert(rr.IsCompileTimeConstant);
			TypeCode constantType = ReflectionHelper.GetTypeCode(rr.Type);
			if (constantType >= TypeCode.SByte && constantType <= TypeCode.Decimal && Convert.ToDouble(rr.ConstantValue) == 0)
			{
				if (NullableType.GetUnderlyingType(toType).Kind == TypeKind.Enum)
				{
					return Conversion.EnumerationConversion(true, NullableType.IsNullable(toType));
				}
			}
			return Conversion.None;
		}

		bool ExplicitEnumerationConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.2.2
			if (fromType.Kind == TypeKind.Enum)
			{
				return toType.Kind == TypeKind.Enum || IsNumericType(toType);
			}
			else if (IsNumericType(fromType))
			{
				return toType.Kind == TypeKind.Enum;
			}
			return false;
		}
		#endregion

		#region Nullable Conversions
		Conversion ImplicitNullableConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.4
			if (NullableType.IsNullable(toType))
			{
				IType t = NullableType.GetUnderlyingType(toType);
				IType s = NullableType.GetUnderlyingType(fromType); // might or might not be nullable
				if (IdentityConversion(s, t))
					return Conversion.ImplicitNullableConversion;
				if (ImplicitNumericConversion(s, t))
					return Conversion.ImplicitLiftedNumericConversion;
			}
			return Conversion.None;
		}

		Conversion ExplicitNullableConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.4
			if (NullableType.IsNullable(toType) || NullableType.IsNullable(fromType))
			{
				IType t = NullableType.GetUnderlyingType(toType);
				IType s = NullableType.GetUnderlyingType(fromType);
				if (IdentityConversion(s, t))
					return Conversion.ExplicitNullableConversion;
				if (AnyNumericConversion(s, t))
					return Conversion.ExplicitLiftedNumericConversion;
				if (ExplicitEnumerationConversion(s, t))
					return Conversion.EnumerationConversion(false, true);
			}
			return Conversion.None;
		}
		#endregion

		#region Null Literal Conversion
		bool NullLiteralConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.5
			if (fromType.Kind == TypeKind.Null)
			{
				return NullableType.IsNullable(toType) || toType.IsReferenceType == true;
			}
			else
			{
				return false;
			}
		}
		#endregion

		#region Implicit Reference Conversion
		public bool IsImplicitReferenceConversion(IType fromType, IType toType)
		{
			return ImplicitReferenceConversion(fromType, toType, 0);
		}

		bool ImplicitReferenceConversion(IType fromType, IType toType, int subtypeCheckNestingDepth)
		{
			// C# 4.0 spec: 6.1.6

			// reference conversions are possible:
			// - if both types are known to be reference types
			// - if both types are type parameters and fromType has a class constraint
			//     (ImplicitTypeParameterConversionWithClassConstraintOnlyOnT)
			if (!(fromType.IsReferenceType == true && toType.IsReferenceType != false))
				return false;

			ArrayType fromArray = fromType as ArrayType;
			if (fromArray != null)
			{
				ArrayType toArray = toType as ArrayType;
				if (toArray != null)
				{
					// array covariance (the broken kind)
					return fromArray.Dimensions == toArray.Dimensions
						&& ImplicitReferenceConversion(fromArray.ElementType, toArray.ElementType, subtypeCheckNestingDepth);
				}
				// conversion from single-dimensional array S[] to IList<T>:
				IType toTypeArgument = UnpackGenericArrayInterface(toType);
				if (fromArray.Dimensions == 1 && toTypeArgument != null)
				{
					// array covariance plays a part here as well (string[] is IList<object>)
					return IdentityConversion(fromArray.ElementType, toTypeArgument)
						|| ImplicitReferenceConversion(fromArray.ElementType, toTypeArgument, subtypeCheckNestingDepth);
				}
				// conversion from any array to System.Array and the interfaces it implements:
				IType systemArray = compilation.FindType(KnownTypeCode.Array);
				return ImplicitReferenceConversion(systemArray, toType, subtypeCheckNestingDepth);
			}

			// now comes the hard part: traverse the inheritance chain and figure out generics+variance
			return IsSubtypeOf(fromType, toType, subtypeCheckNestingDepth);
		}

		/// <summary>
		/// For IList{T}, ICollection{T}, IEnumerable{T} and IReadOnlyList{T}, returns T.
		/// Otherwise, returns null.
		/// </summary>
		IType UnpackGenericArrayInterface(IType interfaceType)
		{
			ParameterizedType pt = interfaceType as ParameterizedType;
			if (pt != null)
			{
				switch (pt.GetDefinition()?.KnownTypeCode)
				{
					case KnownTypeCode.IListOfT:
					case KnownTypeCode.ICollectionOfT:
					case KnownTypeCode.IEnumerableOfT:
					case KnownTypeCode.IReadOnlyListOfT:
						return pt.GetTypeArgument(0);
				}
			}
			return null;
		}

		// Determines whether s is a subtype of t.
		// Helper method used for ImplicitReferenceConversion, BoxingConversion and ImplicitTypeParameterConversion

		bool IsSubtypeOf(IType s, IType t, int subtypeCheckNestingDepth)
		{
			// conversion to dynamic + object are always possible
			if (t.Kind == TypeKind.Dynamic || t.IsKnownType(KnownTypeCode.Object))
				return true;
			if (subtypeCheckNestingDepth > 10)
			{
				// Subtyping in C# is undecidable
				// (see "On Decidability of Nominal Subtyping with Variance" by Andrew J. Kennedy and Benjamin C. Pierce),
				// so we'll prevent infinite recursions by putting a limit on the nesting depth of variance conversions.

				// No real C# code should use generics nested more than 10 levels deep, and even if they do, most of
				// those nestings should not involve variance.
				return false;
			}
			// let GetAllBaseTypes do the work for us
			foreach (IType baseType in s.GetAllBaseTypes())
			{
				if (IdentityOrVarianceConversion(baseType, t, subtypeCheckNestingDepth + 1))
					return true;
			}
			return false;
		}

		bool IdentityOrVarianceConversion(IType s, IType t, int subtypeCheckNestingDepth)
		{
			ITypeDefinition def = s.GetDefinition();
			if (def != null)
			{
				if (!def.Equals(t.GetDefinition()))
					return false;
				ParameterizedType ps = s as ParameterizedType;
				ParameterizedType pt = t as ParameterizedType;
				if (ps != null && pt != null)
				{
					// C# 4.0 spec: 13.1.3.2 Variance Conversion
					for (int i = 0; i < def.TypeParameters.Count; i++)
					{
						IType si = ps.GetTypeArgument(i);
						IType ti = pt.GetTypeArgument(i);
						if (IdentityConversion(si, ti))
							continue;
						ITypeParameter xi = def.TypeParameters[i];
						switch (xi.Variance)
						{
							case VarianceModifier.Covariant:
								if (!ImplicitReferenceConversion(si, ti, subtypeCheckNestingDepth))
									return false;
								break;
							case VarianceModifier.Contravariant:
								if (!ImplicitReferenceConversion(ti, si, subtypeCheckNestingDepth))
									return false;
								break;
							default:
								return false;
						}
					}
				}
				else if (ps != null || pt != null)
				{
					return false; // only of of them is parameterized, or counts don't match? -> not valid conversion
				}
				return true;
			}
			else
			{
				// not type definitions? we still need to check for equal types (e.g. s and t might be type parameters)
				return s.Equals(t);
			}
		}
		#endregion

		#region Explicit Reference Conversion
		bool ExplicitReferenceConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.2.4

			// test that the types are reference types:
			if (toType.IsReferenceType != true)
				return false;
			if (fromType.IsReferenceType != true)
			{
				// special case:
				// converting from F to T is a reference conversion where T : class, F
				// (because F actually must be a reference type as well, even though C# doesn't treat it as one)
				if (fromType.Kind == TypeKind.TypeParameter)
					return IsSubtypeOf(toType, fromType, 0);
				return false;
			}

			if (toType.Kind == TypeKind.Array)
			{
				ArrayType toArray = (ArrayType)toType;
				if (fromType.Kind == TypeKind.Array)
				{
					// Array covariance
					ArrayType fromArray = (ArrayType)fromType;
					if (fromArray.Dimensions != toArray.Dimensions)
						return false;
					return ExplicitReferenceConversion(fromArray.ElementType, toArray.ElementType);
				}
				IType fromTypeArgument = UnpackGenericArrayInterface(fromType);
				if (fromTypeArgument != null && toArray.Dimensions == 1)
				{
					return ExplicitReferenceConversion(fromTypeArgument, toArray.ElementType)
						|| IdentityConversion(fromTypeArgument, toArray.ElementType);
				}
				// Otherwise treat the array like a sealed class - require implicit conversion in the opposite direction
				return IsImplicitReferenceConversion(toType, fromType);
			}
			else if (fromType.Kind == TypeKind.Array)
			{
				ArrayType fromArray = (ArrayType)fromType;
				IType toTypeArgument = UnpackGenericArrayInterface(toType);
				if (toTypeArgument != null && fromArray.Dimensions == 1)
				{
					return ExplicitReferenceConversion(fromArray.ElementType, toTypeArgument);
				}
				// Otherwise treat the array like a sealed class
				return IsImplicitReferenceConversion(fromType, toType);
			}
			else if (fromType.Kind == TypeKind.Delegate && toType.Kind == TypeKind.Delegate)
			{
				ITypeDefinition def = fromType.GetDefinition();
				if (def == null || !def.Equals(toType.GetDefinition()))
					return false;
				ParameterizedType ps = fromType as ParameterizedType;
				ParameterizedType pt = toType as ParameterizedType;
				if (ps == null || pt == null)
				{
					// non-generic delegate - return true for the identity conversion
					return ps == null && pt == null;
				}
				for (int i = 0; i < def.TypeParameters.Count; i++)
				{
					IType si = ps.GetTypeArgument(i);
					IType ti = pt.GetTypeArgument(i);
					if (IdentityConversion(si, ti))
						continue;
					ITypeParameter xi = def.TypeParameters[i];
					switch (xi.Variance)
					{
						case VarianceModifier.Covariant:
							if (!ExplicitReferenceConversion(si, ti))
								return false;
							break;
						case VarianceModifier.Contravariant:
							if (!(si.IsReferenceType == true && ti.IsReferenceType == true))
								return false;
							break;
						default:
							return false;
					}
				}
				return true;
			}
			else if (IsSealedReferenceType(fromType))
			{
				// If the source type is sealed, explicit conversions can't do anything more than implicit ones
				return IsImplicitReferenceConversion(fromType, toType);
			}
			else if (IsSealedReferenceType(toType))
			{
				// The the target type is sealed, there must be an implicit conversion in the opposite direction
				return IsImplicitReferenceConversion(toType, fromType);
			}
			else
			{
				if (fromType.Kind == TypeKind.Interface || toType.Kind == TypeKind.Interface)
					return true;
				else
					return IsImplicitReferenceConversion(toType, fromType)
						|| IsImplicitReferenceConversion(fromType, toType);
			}
		}

		bool IsSealedReferenceType(IType type)
		{
			TypeKind kind = type.Kind;
			return kind == TypeKind.Class && type.GetDefinition().IsSealed
				|| kind == TypeKind.Delegate;
		}
		#endregion

		#region Boxing Conversions
		bool IsBoxingConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.1.7
			fromType = NullableType.GetUnderlyingType(fromType);
			if (fromType.IsReferenceType == false && toType.IsReferenceType == true)
				return IsSubtypeOf(fromType, toType, 0);
			else
				return false;
		}

		/// <summary>
		/// Gets whether the conversion from fromType to toType is a boxing conversion,
		/// or an implicit conversion involving a type parameter that might be
		/// a boxing conversion when instantiated with a value type.
		/// </summary>
		public bool IsBoxingConversionOrInvolvingTypeParameter(IType fromType, IType toType)
		{
			return IsBoxingConversion(fromType, toType)
				|| ImplicitTypeParameterConversion(fromType, toType);
		}

		bool UnboxingConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 6.2.5
			toType = NullableType.GetUnderlyingType(toType);
			if (fromType.IsReferenceType == true && toType.IsReferenceType == false)
				return IsSubtypeOf(toType, fromType, 0);
			else
				return false;
		}
		#endregion

		#region Implicit Constant-Expression Conversion
		bool ImplicitConstantExpressionConversion(ResolveResult rr, IType toType)
		{
			if (rr == null || !rr.IsCompileTimeConstant)
				return false;
			// C# 4.0 spec: 6.1.9
			TypeCode fromTypeCode = ReflectionHelper.GetTypeCode(rr.Type);
			toType = NullableType.GetUnderlyingType(toType);
			TypeCode toTypeCode = ReflectionHelper.GetTypeCode(toType);
			if (toType.Kind == TypeKind.NUInt)
			{
				toTypeCode = TypeCode.UInt32;
			}
			if (fromTypeCode == TypeCode.Int64)
			{
				long val = (long)rr.ConstantValue;
				return val >= 0 && toTypeCode == TypeCode.UInt64;
			}
			else if (fromTypeCode == TypeCode.Int32)
			{
				object cv = rr.ConstantValue;
				if (cv == null)
					return false;
				int val = (int)cv;
				switch (toTypeCode)
				{
					case TypeCode.SByte:
						return val >= SByte.MinValue && val <= SByte.MaxValue;
					case TypeCode.Byte:
						return val >= Byte.MinValue && val <= Byte.MaxValue;
					case TypeCode.Int16:
						return val >= Int16.MinValue && val <= Int16.MaxValue;
					case TypeCode.UInt16:
						return val >= UInt16.MinValue && val <= UInt16.MaxValue;
					case TypeCode.UInt32:
					case TypeCode.UInt64:
						return val >= 0;
				}
			}
			return false;
		}
		#endregion

		#region Conversions involving type parameters
		/// <summary>
		/// Implicit conversions involving type parameters.
		/// </summary>
		bool ImplicitTypeParameterConversion(IType fromType, IType toType)
		{
			if (fromType.Kind != TypeKind.TypeParameter)
				return false; // not a type parameter
			if (fromType.IsReferenceType == true)
				return false; // already handled by ImplicitReferenceConversion
			return IsSubtypeOf(fromType, toType, 0);
		}

		Conversion ExplicitTypeParameterConversion(IType fromType, IType toType)
		{
			if (toType.Kind == TypeKind.TypeParameter)
			{
				// Explicit type parameter conversions that aren't also
				// reference conversions are considered to be unboxing conversions
				if (fromType.Kind == TypeKind.Interface || IsSubtypeOf(toType, fromType, 0))
					return Conversion.UnboxingConversion;
			}
			else
			{
				if (fromType.Kind == TypeKind.TypeParameter && toType.Kind == TypeKind.Interface)
					return Conversion.BoxingConversion;
			}
			return Conversion.None;
		}
		#endregion

		#region Pointer Conversions
		bool ImplicitPointerConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 18.4 Pointer conversions
			if (fromType.Kind.IsAnyPointer() && toType is PointerType && toType.ReflectionName == "System.Void*")
				return true;
			if (fromType.Kind == TypeKind.Null && toType.Kind.IsAnyPointer())
				return true;
			if (fromType is FunctionPointerType fromFnPtr && toType is FunctionPointerType toFnPtr
				&& fromFnPtr.CallingConvention == toFnPtr.CallingConvention
				&& fromFnPtr.ParameterTypes.Length == toFnPtr.ParameterTypes.Length)
			{
				// Variance applies to function pointer types
				const int nestingDepth = 0;
				if (!(IdentityConversion(fromFnPtr.ReturnType, toFnPtr.ReturnType)
					|| ImplicitReferenceConversion(fromFnPtr.ReturnType, toFnPtr.ReturnType, nestingDepth)))
				{
					return false;
				}
				foreach (var (fromPT, toPT) in fromFnPtr.ParameterTypes.Zip(toFnPtr.ParameterTypes))
				{
					if (!(IdentityConversion(toPT, fromPT)
						|| ImplicitReferenceConversion(toPT, fromPT, nestingDepth)))
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		bool ExplicitPointerConversion(IType fromType, IType toType)
		{
			// C# 4.0 spec: 18.4 Pointer conversions
			if (fromType.Kind.IsAnyPointer())
			{
				return toType.Kind.IsAnyPointer() || IsIntegerType(toType);
			}
			else
			{
				return toType.Kind.IsAnyPointer() && IsIntegerType(fromType);
			}
		}

		bool IsIntegerType(IType type)
		{
			switch (type.Kind)
			{
				case TypeKind.NInt:
				case TypeKind.NUInt:
					return true;
			}
			TypeCode c = ReflectionHelper.GetTypeCode(type);
			return c >= TypeCode.SByte && c <= TypeCode.UInt64;
		}
		#endregion

		#region User-Defined Conversions
		/// <summary>
		/// Gets whether type A is encompassed by type B.
		/// </summary>
		bool IsEncompassedBy(IType a, IType b)
		{
			return a.Kind != TypeKind.Interface && b.Kind != TypeKind.Interface && StandardImplicitConversion(a, b).IsValid;
		}

		bool IsEncompassingOrEncompassedBy(IType a, IType b)
		{
			return a.Kind != TypeKind.Interface && b.Kind != TypeKind.Interface
				&& (StandardImplicitConversion(a, b).IsValid || StandardImplicitConversion(b, a).IsValid);
		}

		IType FindMostEncompassedType(IEnumerable<IType> candidates)
		{
			IType best = null;
			foreach (var current in candidates)
			{
				if (best == null || IsEncompassedBy(current, best))
					best = current;
				else if (!IsEncompassedBy(best, current))
					return null;    // Ambiguous
			}
			return best;
		}

		IType FindMostEncompassingType(IEnumerable<IType> candidates)
		{
			IType best = null;
			foreach (var current in candidates)
			{
				if (best == null || IsEncompassedBy(best, current))
					best = current;
				else if (!IsEncompassedBy(current, best))
					return null;    // Ambiguous
			}
			return best;
		}

		Conversion SelectOperator(IType mostSpecificSource, IType mostSpecificTarget, IList<OperatorInfo> operators, bool isImplicit, IType source, IType target)
		{
			var selected = operators.Where(op => op.SourceType.Equals(mostSpecificSource) && op.TargetType.Equals(mostSpecificTarget)).ToList();
			if (selected.Count == 0)
				return Conversion.None;

			if (selected.Count == 1)
				return Conversion.UserDefinedConversion(selected[0].Method, isLifted: selected[0].IsLifted, isImplicit: isImplicit, conversionBeforeUserDefinedOperator: ExplicitConversion(source, mostSpecificSource), conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget, target));

			int nNonLifted = selected.Count(s => !s.IsLifted);
			if (nNonLifted == 1)
			{
				var op = selected.First(s => !s.IsLifted);
				return Conversion.UserDefinedConversion(op.Method, isLifted: op.IsLifted, isImplicit: isImplicit, conversionBeforeUserDefinedOperator: ExplicitConversion(source, mostSpecificSource), conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget, target));
			}

			return Conversion.UserDefinedConversion(selected[0].Method, isLifted: selected[0].IsLifted, isImplicit: isImplicit, isAmbiguous: true, conversionBeforeUserDefinedOperator: ExplicitConversion(source, mostSpecificSource), conversionAfterUserDefinedOperator: ExplicitConversion(mostSpecificTarget, target));
		}

		Conversion UserDefinedImplicitConversion(ResolveResult fromResult, IType fromType, IType toType)
		{
			// C# 4.0 spec 6.4.4 User-defined implicit conversions
			var operators = GetApplicableConversionOperators(fromResult, fromType, toType, false);

			if (operators.Count > 0)
			{
				var mostSpecificSource = operators.Any(op => op.SourceType.Equals(fromType)) ? fromType : FindMostEncompassedType(operators.Select(op => op.SourceType));
				if (mostSpecificSource == null)
					return Conversion.UserDefinedConversion(operators[0].Method, isImplicit: true, isLifted: operators[0].IsLifted, isAmbiguous: true, conversionBeforeUserDefinedOperator: Conversion.None, conversionAfterUserDefinedOperator: Conversion.None);
				var mostSpecificTarget = operators.Any(op => op.TargetType.Equals(toType)) ? toType : FindMostEncompassingType(operators.Select(op => op.TargetType));
				if (mostSpecificTarget == null)
				{
					if (NullableType.IsNullable(toType))
						return UserDefinedImplicitConversion(fromResult, fromType, NullableType.GetUnderlyingType(toType));
					else
						return Conversion.UserDefinedConversion(operators[0].Method, isImplicit: true, isLifted: operators[0].IsLifted, isAmbiguous: true, conversionBeforeUserDefinedOperator: Conversion.None, conversionAfterUserDefinedOperator: Conversion.None);
				}

				var selected = SelectOperator(mostSpecificSource, mostSpecificTarget, operators, true, fromType, toType);
				if (selected != Conversion.None)
				{
					if (selected.IsLifted && NullableType.IsNullable(toType))
					{
						// Prefer A -> B -> B? over A -> A? -> B?
						var other = UserDefinedImplicitConversion(fromResult, fromType, NullableType.GetUnderlyingType(toType));
						if (other != Conversion.None)
							return other;
					}
					return selected;
				}
				else if (NullableType.IsNullable(toType))
					return UserDefinedImplicitConversion(fromResult, fromType, NullableType.GetUnderlyingType(toType));
				else
					return Conversion.None;
			}
			else
			{
				return Conversion.None;
			}
		}

		Conversion UserDefinedExplicitConversion(ResolveResult fromResult, IType fromType, IType toType)
		{
			// C# 4.0 spec 6.4.5 User-defined explicit conversions
			var operators = GetApplicableConversionOperators(fromResult, fromType, toType, true);
			if (operators.Count > 0)
			{
				IType mostSpecificSource;
				if (operators.Any(op => op.SourceType.Equals(fromType)))
				{
					mostSpecificSource = fromType;
				}
				else
				{
					var operatorsWithSourceEncompassingFromType = operators.Where(op => IsEncompassedBy(fromType, op.SourceType) || ImplicitConstantExpressionConversion(fromResult, NullableType.GetUnderlyingType(op.SourceType))).ToList();
					if (operatorsWithSourceEncompassingFromType.Any())
						mostSpecificSource = FindMostEncompassedType(operatorsWithSourceEncompassingFromType.Select(op => op.SourceType));
					else
						mostSpecificSource = FindMostEncompassingType(operators.Select(op => op.SourceType));
				}
				if (mostSpecificSource == null)
					return Conversion.UserDefinedConversion(operators[0].Method, isImplicit: false, isLifted: operators[0].IsLifted, isAmbiguous: true, conversionBeforeUserDefinedOperator: Conversion.None, conversionAfterUserDefinedOperator: Conversion.None);

				IType mostSpecificTarget;
				if (operators.Any(op => op.TargetType.Equals(toType)))
					mostSpecificTarget = toType;
				else if (operators.Any(op => IsEncompassedBy(op.TargetType, toType)))
					mostSpecificTarget = FindMostEncompassingType(operators.Where(op => IsEncompassedBy(op.TargetType, toType)).Select(op => op.TargetType));
				else
					mostSpecificTarget = FindMostEncompassedType(operators.Select(op => op.TargetType));
				if (mostSpecificTarget == null)
				{
					if (NullableType.IsNullable(toType))
						return UserDefinedExplicitConversion(fromResult, fromType, NullableType.GetUnderlyingType(toType));
					else
						return Conversion.UserDefinedConversion(operators[0].Method, isImplicit: false, isLifted: operators[0].IsLifted, isAmbiguous: true, conversionBeforeUserDefinedOperator: Conversion.None, conversionAfterUserDefinedOperator: Conversion.None);
				}

				var selected = SelectOperator(mostSpecificSource, mostSpecificTarget, operators, false, fromType, toType);
				if (selected != Conversion.None)
				{
					if (selected.IsLifted && NullableType.IsNullable(toType))
					{
						// Prefer A -> B -> B? over A -> A? -> B?
						var other = UserDefinedImplicitConversion(fromResult, fromType, NullableType.GetUnderlyingType(toType));
						if (other != Conversion.None)
							return other;
					}
					return selected;
				}
				else if (NullableType.IsNullable(toType))
					return UserDefinedExplicitConversion(fromResult, fromType, NullableType.GetUnderlyingType(toType));
				else if (NullableType.IsNullable(fromType))
					return UserDefinedExplicitConversion(null, NullableType.GetUnderlyingType(fromType), toType);   // A? -> A -> B
				else
					return Conversion.None;
			}
			else
			{
				return Conversion.None;
			}
		}

		class OperatorInfo
		{
			public readonly IMethod Method;
			public readonly IType SourceType;
			public readonly IType TargetType;
			public readonly bool IsLifted;

			public OperatorInfo(IMethod method, IType sourceType, IType targetType, bool isLifted)
			{
				this.Method = method;
				this.SourceType = sourceType;
				this.TargetType = targetType;
				this.IsLifted = isLifted;
			}
		}

		static IType UnderlyingTypeForConversion(IType type)
		{
			if (type.Kind == TypeKind.ByReference)
			{
				type = ((ByReferenceType)type).ElementType;
			}
			return NullableType.GetUnderlyingType(type);
		}

		List<OperatorInfo> GetApplicableConversionOperators(ResolveResult fromResult, IType fromType, IType toType, bool isExplicit)
		{
			// Find the candidate operators:
			Predicate<IMethod> opFilter;
			if (isExplicit)
				opFilter = m => m.IsStatic && m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1;
			else
				opFilter = m => m.IsStatic && m.IsOperator && m.Name == "op_Implicit" && m.Parameters.Count == 1;

			var operators = UnderlyingTypeForConversion(fromType).GetMethods(opFilter)
				.Concat(UnderlyingTypeForConversion(toType).GetMethods(opFilter)).Distinct();
			// Determine whether one of them is applicable:
			List<OperatorInfo> result = new List<OperatorInfo>();
			foreach (IMethod op in operators)
			{
				IType sourceType = op.Parameters[0].Type;
				if (sourceType.Kind == TypeKind.ByReference && op.Parameters[0].IsIn && fromType.Kind != TypeKind.ByReference)
				{
					sourceType = ((ByReferenceType)sourceType).ElementType;
				}
				IType targetType = op.ReturnType;
				// Try if the operator is applicable:
				bool isApplicable;
				if (isExplicit)
				{
					isApplicable = (IsEncompassingOrEncompassedBy(fromType, sourceType) || ImplicitConstantExpressionConversion(fromResult, sourceType))
						&& IsEncompassingOrEncompassedBy(targetType, toType);
				}
				else
				{
					isApplicable = (IsEncompassedBy(fromType, sourceType) || ImplicitConstantExpressionConversion(fromResult, sourceType))
						&& IsEncompassedBy(targetType, toType);
				}
				// Try if the operator is applicable in lifted form:
				if (isApplicable)
				{
					result.Add(new OperatorInfo(op, sourceType, targetType, false));
				}
				if (NullableType.IsNonNullableValueType(sourceType))
				{
					// An operator can be applicable in both lifted and non-lifted form in case of explicit conversions
					IType liftedSourceType = NullableType.Create(compilation, sourceType);
					IType liftedTargetType = NullableType.IsNonNullableValueType(targetType) ? NullableType.Create(compilation, targetType) : targetType;
					if (isExplicit)
					{
						isApplicable = IsEncompassingOrEncompassedBy(fromType, liftedSourceType)
							&& IsEncompassingOrEncompassedBy(liftedTargetType, toType);
					}
					else
					{
						isApplicable = IsEncompassedBy(fromType, liftedSourceType) && IsEncompassedBy(liftedTargetType, toType);
					}

					if (isApplicable)
					{
						result.Add(new OperatorInfo(op, liftedSourceType, liftedTargetType, true));
					}
				}
			}
			return result;
		}
		#endregion

		#region AnonymousFunctionConversion
		Conversion AnonymousFunctionConversion(ResolveResult resolveResult, IType toType)
		{
			// C# 5.0 spec 6.5 Anonymous function conversions
			LambdaResolveResult f = resolveResult as LambdaResolveResult;
			if (f == null)
				return Conversion.None;
			if (!f.IsAnonymousMethod)
			{
				// It's a lambda, so conversions to expression trees exist
				// (even if the conversion leads to a compile-time error, e.g. for statement lambdas)
				toType = UnpackExpressionTreeType(toType);
			}
			IMethod d = toType.GetDelegateInvokeMethod();
			if (d == null)
				return Conversion.None;

			IType[] dParamTypes = new IType[d.Parameters.Count];
			for (int i = 0; i < dParamTypes.Length; i++)
			{
				dParamTypes[i] = d.Parameters[i].Type;
			}
			IType dReturnType = d.ReturnType;

			if (f.HasParameterList)
			{
				// If F contains an anonymous-function-signature, then D and F have the same number of parameters.
				if (d.Parameters.Count != f.Parameters.Count)
					return Conversion.None;

				if (f.IsImplicitlyTyped)
				{
					// If F has an implicitly typed parameter list, D has no ref or out parameters.
					foreach (IParameter p in d.Parameters)
					{
						if (p.ReferenceKind != ReferenceKind.None)
							return Conversion.None;
					}
				}
				else
				{
					// If F has an explicitly typed parameter list, each parameter in D has the same type
					// and modifiers as the corresponding parameter in F.
					for (int i = 0; i < f.Parameters.Count; i++)
					{
						IParameter pD = d.Parameters[i];
						IParameter pF = f.Parameters[i];
						if (pD.ReferenceKind != pF.ReferenceKind)
							return Conversion.None;
						if (!IdentityConversion(dParamTypes[i], pF.Type))
							return Conversion.None;
					}
				}
			}
			else
			{
				// If F does not contain an anonymous-function-signature, then D may have zero or more parameters of any
				// type, as long as no parameter of D has the out parameter modifier.
				foreach (IParameter p in d.Parameters)
				{
					if (p.IsOut)
						return Conversion.None;
				}
			}

			return f.IsValid(dParamTypes, dReturnType, this);
		}

		static IType UnpackExpressionTreeType(IType type)
		{
			ParameterizedType pt = type as ParameterizedType;
			if (pt != null && pt.TypeParameterCount == 1 && pt.Name == "Expression" && pt.Namespace == "System.Linq.Expressions")
			{
				return pt.GetTypeArgument(0);
			}
			else
			{
				return type;
			}
		}
		#endregion

		#region MethodGroupConversion
		Conversion MethodGroupConversion(ResolveResult resolveResult, IType toType)
		{
			// C# 4.0 spec 6.6 Method group conversions
			MethodGroupResolveResult rr = resolveResult as MethodGroupResolveResult;
			if (rr == null)
				return Conversion.None;
			IMethod invoke = toType.GetDelegateInvokeMethod();
			if (invoke == null)
				return Conversion.None;

			ResolveResult[] args = new ResolveResult[invoke.Parameters.Count];
			for (int i = 0; i < args.Length; i++)
			{
				IParameter param = invoke.Parameters[i];
				IType parameterType = param.Type;
				if (param.ReferenceKind != ReferenceKind.None && parameterType.Kind == TypeKind.ByReference)
				{
					parameterType = ((ByReferenceType)parameterType).ElementType;
					args[i] = new ByReferenceResolveResult(parameterType, param.ReferenceKind);
				}
				else
				{
					args[i] = new ResolveResult(parameterType);
				}
			}
			var or = rr.PerformOverloadResolution(
				compilation, args,
				allowExpandingParams: false,
				allowOptionalParameters: false,
				allowImplicitIn: false,
				conversions: this
			);
			if (or.FoundApplicableCandidate)
			{
				IMethod method = (IMethod)or.GetBestCandidateWithSubstitutedTypeArguments();
				var thisRR = rr.TargetResult as ThisResolveResult;
				bool isVirtual = method.IsOverridable && !(thisRR != null && thisRR.CausesNonVirtualInvocation);
				bool isValid = !or.IsAmbiguous && IsDelegateCompatible(method, invoke, or.IsExtensionMethodInvocation);
				bool delegateCapturesFirstArgument = or.IsExtensionMethodInvocation || !method.IsStatic;
				if (isValid)
					return Conversion.MethodGroupConversion(method, isVirtual, delegateCapturesFirstArgument);
				else
					return Conversion.InvalidMethodGroupConversion(method, isVirtual, delegateCapturesFirstArgument);
			}
			else
			{
				return Conversion.None;
			}
		}

		/// <summary>
		/// Gets whether a <paramref name="method"/> is compatible with a delegate type.
		/// 15.2 Delegate compatibility
		/// </summary>
		/// <param name="method">The method to test for compatibility</param>
		/// <param name="delegateType">The delegate type</param>
		public bool IsDelegateCompatible(IMethod method, IType delegateType)
		{
			if (method == null)
				throw new ArgumentNullException(nameof(method));
			if (delegateType == null)
				throw new ArgumentNullException(nameof(delegateType));
			IMethod invoke = delegateType.GetDelegateInvokeMethod();
			if (invoke == null)
				return false;
			return IsDelegateCompatible(method, invoke, false);
		}

		/// <summary>
		/// Gets whether a method <paramref name="m"/> is compatible with a delegate type.
		/// 15.2 Delegate compatibility
		/// </summary>
		/// <param name="m">The method to test for compatibility</param>
		/// <param name="invoke">The invoke method of the delegate</param>
		/// <param name="isExtensionMethodInvocation">Gets whether m is accessed using extension method syntax.
		/// If this parameter is true, the first parameter of <paramref name="m"/> will be ignored.</param>
		bool IsDelegateCompatible(IMethod m, IMethod invoke, bool isExtensionMethodInvocation)
		{
			if (m == null)
				throw new ArgumentNullException(nameof(m));
			if (invoke == null)
				throw new ArgumentNullException(nameof(invoke));
			int firstParameterInM = isExtensionMethodInvocation ? 1 : 0;
			if (m.Parameters.Count - firstParameterInM != invoke.Parameters.Count)
				return false;
			for (int i = 0; i < invoke.Parameters.Count; i++)
			{
				var pm = m.Parameters[firstParameterInM + i];
				var pd = invoke.Parameters[i];
				// ret/out/in must match
				if (pm.ReferenceKind != pd.ReferenceKind)
					return false;
				if (pm.ReferenceKind != ReferenceKind.None)
				{
					// ref/out/in parameters must have same types
					if (!pm.Type.Equals(pd.Type))
						return false;
				}
				else
				{
					// non-ref/out parameters must have an identity or reference conversion from pd to pm
					if (!IdentityConversion(pd.Type, pm.Type) && !IsImplicitReferenceConversion(pd.Type, pm.Type))
						return false;
				}
			}
			// check return type compatibility
			return IdentityConversion(m.ReturnType, invoke.ReturnType)
				|| IsImplicitReferenceConversion(m.ReturnType, invoke.ReturnType);
		}
		#endregion

		#region Tuple Conversion
		Conversion TupleConversion(TupleResolveResult fromRR, IType toType, bool isExplicit)
		{
			var fromElements = fromRR.Elements;
			var toElements = TupleType.GetTupleElementTypes(toType);
			if (toElements.IsDefault || fromElements.Length != toElements.Length)
				return Conversion.None;
			Conversion[] elementConversions = new Conversion[fromElements.Length];
			for (int i = 0; i < elementConversions.Length; i++)
			{
				Conversion c;
				if (isExplicit)
				{
					c = ExplicitConversion(fromElements[i], toElements[i]);
				}
				else
				{
					c = ImplicitConversion(fromElements[i], toElements[i]);
				}
				if (!c.IsValid)
					return Conversion.None;
				elementConversions[i] = c;
			}
			return Conversion.TupleConversion(elementConversions.ToImmutableArray());
		}

		Conversion TupleConversion(IType fromType, IType toType, bool isExplicit)
		{
			var fromElements = TupleType.GetTupleElementTypes(fromType);
			if (fromElements.IsDefaultOrEmpty)
				return Conversion.None;
			var toElements = TupleType.GetTupleElementTypes(toType);
			if (toElements.IsDefault || fromElements.Length != toElements.Length)
				return Conversion.None;
			Conversion[] elementConversions = new Conversion[fromElements.Length];
			for (int i = 0; i < elementConversions.Length; i++)
			{
				Conversion c;
				if (isExplicit)
				{
					c = ExplicitConversion(fromElements[i], toElements[i]);
				}
				else
				{
					c = ImplicitConversion(fromElements[i], toElements[i]);
				}
				if (!c.IsValid)
					return Conversion.None;
				elementConversions[i] = c;
			}
			return Conversion.TupleConversion(elementConversions.ToImmutableArray());
		}
		#endregion

		#region BetterConversion
		/// <summary>
		/// Gets the better conversion (C# 4.0 spec, 7.5.3.3)
		/// </summary>
		/// <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
		public int BetterConversion(ResolveResult resolveResult, IType t1, IType t2)
		{
			LambdaResolveResult lambda = resolveResult as LambdaResolveResult;
			if (lambda != null)
			{
				if (!lambda.IsAnonymousMethod)
				{
					t1 = UnpackExpressionTreeType(t1);
					t2 = UnpackExpressionTreeType(t2);
				}
				IMethod m1 = t1.GetDelegateInvokeMethod();
				IMethod m2 = t2.GetDelegateInvokeMethod();
				if (m1 == null || m2 == null)
					return 0;
				if (m1.Parameters.Count != m2.Parameters.Count)
					return 0;
				IType[] parameterTypes = new IType[m1.Parameters.Count];
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					parameterTypes[i] = m1.Parameters[i].Type;
					if (!parameterTypes[i].Equals(m2.Parameters[i].Type))
						return 0;
				}
				if (lambda.HasParameterList && parameterTypes.Length != lambda.Parameters.Count)
					return 0;

				IType ret1 = m1.ReturnType;
				IType ret2 = m2.ReturnType;
				if (ret1.Kind == TypeKind.Void && ret2.Kind != TypeKind.Void)
					return 2;
				if (ret1.Kind != TypeKind.Void && ret2.Kind == TypeKind.Void)
					return 1;

				IType inferredRet = lambda.GetInferredReturnType(parameterTypes);
				int r = BetterConversion(inferredRet, ret1, ret2);
				if (r == 0 && lambda.IsAsync)
				{
					ret1 = UnpackTask(ret1);
					ret2 = UnpackTask(ret2);
					inferredRet = UnpackTask(inferredRet);
					if (ret1 != null && ret2 != null && inferredRet != null)
						r = BetterConversion(inferredRet, ret1, ret2);
				}
				return r;
			}
			else
			{
				return BetterConversion(resolveResult.Type, t1, t2);
			}
		}

		/// <summary>
		/// Unpacks the generic Task[T]. Returns null if the input is not Task[T].
		/// </summary>
		static IType UnpackTask(IType type)
		{
			ParameterizedType pt = type as ParameterizedType;
			if (pt != null && pt.TypeParameterCount == 1 && pt.Name == "Task" && pt.Namespace == "System.Threading.Tasks")
			{
				return pt.GetTypeArgument(0);
			}
			return null;
		}

		/// <summary>
		/// Gets the better conversion (C# 4.0 spec, 7.5.3.4)
		/// </summary>
		/// <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
		public int BetterConversion(IType s, IType t1, IType t2)
		{
			bool ident1 = IdentityConversion(s, t1);
			bool ident2 = IdentityConversion(s, t2);
			if (ident1 && !ident2)
				return 1;
			if (ident2 && !ident1)
				return 2;
			return BetterConversionTarget(t1, t2);
		}

		/// <summary>
		/// Gets the better conversion target (C# 4.0 spec, 7.5.3.5)
		/// </summary>
		/// <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
		int BetterConversionTarget(IType t1, IType t2)
		{
			bool t1To2 = ImplicitConversion(t1, t2).IsValid;
			bool t2To1 = ImplicitConversion(t2, t1).IsValid;
			if (t1To2 && !t2To1)
				return 1;
			if (t2To1 && !t1To2)
				return 2;
			TypeCode t1Code = ReflectionHelper.GetTypeCode(t1);
			TypeCode t2Code = ReflectionHelper.GetTypeCode(t2);
			if (IsBetterIntegralType(t1Code, t2Code))
				return 1;
			if (IsBetterIntegralType(t2Code, t1Code))
				return 2;
			return 0;
		}

		bool IsBetterIntegralType(TypeCode t1, TypeCode t2)
		{
			// signed types are better than unsigned types
			switch (t1)
			{
				case TypeCode.SByte:
					return t2 == TypeCode.Byte || t2 == TypeCode.UInt16 || t2 == TypeCode.UInt32 || t2 == TypeCode.UInt64;
				case TypeCode.Int16:
					return t2 == TypeCode.UInt16 || t2 == TypeCode.UInt32 || t2 == TypeCode.UInt64;
				case TypeCode.Int32:
					return t2 == TypeCode.UInt32 || t2 == TypeCode.UInt64;
				case TypeCode.Int64:
					return t2 == TypeCode.UInt64;
				default:
					return false;
			}
		}
		#endregion
	}
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\OverloadResolution.cs
Description: Error: Unable to create valid SyntaxTree for document: OverloadResolution.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (t1 is TypeWithElementType tew1 && t2 is TypeWithElementType tew2)
			{
				return MoreSpecificFormalParameter(tew1.ElementType, tew2.ElementType);
			}
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (t1 is TypeWithElementType tew1 && t2 is TypeWithElementType tew2)
			{
				return MoreSpecificFormalParameter(tew1.ElementType, tew2.ElementType);
			}
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using ICSharpCode.Decompiler.Semantics;
using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.TypeSystem.Implementation;
using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.CSharp.Resolver
{
	/// <summary>
	/// C# overload resolution (C# 4.0 spec: 7.5).
	/// </summary>
	public class OverloadResolution
	{
		sealed class Candidate
		{
			public readonly IParameterizedMember Member;

			/// <summary>
			/// Returns the normal form candidate, if this is an expanded candidate.
			/// </summary>
			public readonly bool IsExpandedForm;

			/// <summary>
			/// Gets the parameter types. In the first step, these are the types without any substition.
			/// After type inference, substitutions will be performed.
			/// </summary>
			public readonly IType[] ParameterTypes;

			/// <summary>
			/// argument index -> parameter index; -1 for arguments that could not be mapped
			/// </summary>
			public int[] ArgumentToParameterMap;

			public OverloadResolutionErrors Errors;
			public int ErrorCount;

			public bool HasUnmappedOptionalParameters;

			public IType[] InferredTypes;

			/// <summary>
			/// Gets the original member parameters (before any substitution!)
			/// </summary>
			public readonly IReadOnlyList<IParameter> Parameters;

			/// <summary>
			/// Gets the original method type parameters (before any substitution!)
			/// </summary>
			public readonly IReadOnlyList<ITypeParameter> TypeParameters;

			/// <summary>
			/// Conversions applied to the arguments.
			/// This field is set by the CheckApplicability step.
			/// </summary>
			public Conversion[] ArgumentConversions;

			public bool IsGenericMethod {
				get {
					IMethod method = Member as IMethod;
					return method != null && method.TypeParameters.Count > 0;
				}
			}

			public int ArgumentsPassedToParamsArray {
				get {
					int count = 0;
					if (IsExpandedForm)
					{
						int paramsParameterIndex = this.Parameters.Count - 1;
						foreach (int parameterIndex in ArgumentToParameterMap)
						{
							if (parameterIndex == paramsParameterIndex)
								count++;
						}
					}
					return count;
				}
			}

			public Candidate(IParameterizedMember member, bool isExpanded)
			{
				this.Member = member;
				this.IsExpandedForm = isExpanded;
				IParameterizedMember memberDefinition = (IParameterizedMember)member.MemberDefinition;
				// For specificialized methods, go back to the original parameters:
				// (without any type parameter substitution, not even class type parameters)
				// We'll re-substitute them as part of RunTypeInference().
				this.Parameters = memberDefinition.Parameters;
				IMethod methodDefinition = memberDefinition as IMethod;
				if (methodDefinition != null && methodDefinition.TypeParameters.Count > 0)
				{
					this.TypeParameters = methodDefinition.TypeParameters;
				}
				this.ParameterTypes = new IType[this.Parameters.Count];
			}

			public void AddError(OverloadResolutionErrors newError)
			{
				this.Errors |= newError;
				if (!IsApplicable(newError))
					this.ErrorCount++;
			}
		}

		readonly ICompilation compilation;
		readonly ResolveResult[] arguments;
		readonly string[] argumentNames;
		readonly CSharpConversions conversions;
		//List<Candidate> candidates = new List<Candidate>();
		Candidate bestCandidate;
		Candidate bestCandidateAmbiguousWith;
		IType[] explicitlyGivenTypeArguments;
		bool bestCandidateWasValidated;
		OverloadResolutionErrors bestCandidateValidationResult;

		#region Constructor
		public OverloadResolution(ICompilation compilation, ResolveResult[] arguments, string[] argumentNames = null, IType[] typeArguments = null, CSharpConversions conversions = null)
		{
			if (compilation == null)
				throw new ArgumentNullException(nameof(compilation));
			if (arguments == null)
				throw new ArgumentNullException(nameof(arguments));
			if (argumentNames == null)
				argumentNames = new string[arguments.Length];
			else if (argumentNames.Length != arguments.Length)
				throw new ArgumentException("argumentsNames.Length must be equal to arguments.Length");
			this.compilation = compilation;
			this.arguments = arguments;
			this.argumentNames = argumentNames;

			// keep explicitlyGivenTypeArguments==null when no type arguments were specified
			if (typeArguments != null && typeArguments.Length > 0)
				this.explicitlyGivenTypeArguments = typeArguments;

			this.conversions = conversions ?? CSharpConversions.Get(compilation);
			this.AllowExpandingParams = true;
			this.AllowOptionalParameters = true;
		}
		#endregion

		#region Input Properties
		/// <summary>
		/// Gets/Sets whether the methods are extension methods that are being called using extension method syntax.
		/// </summary>
		/// <remarks>
		/// Setting this property to true restricts the possible conversions on the first argument to
		/// implicit identity, reference, or boxing conversions.
		/// </remarks>
		public bool IsExtensionMethodInvocation { get; set; }

		/// <summary>
		/// Gets/Sets whether expanding 'params' into individual elements is allowed.
		/// The default value is true.
		/// </summary>
		public bool AllowExpandingParams { get; set; }

		/// <summary>
		/// Gets/Sets whether optional parameters may be left at their default value.
		/// The default value is true.
		/// If this property is set to false, optional parameters will be treated like regular parameters.
		/// </summary>
		public bool AllowOptionalParameters { get; set; }

		/// <summary>
		/// Gets/Sets whether a value argument can be passed to an `in` reference parameter.
		/// </summary>
		public bool AllowImplicitIn { get; set; } = true;

		/// <summary>
		/// Gets/Sets whether ConversionResolveResults created by this OverloadResolution
		/// instance apply overflow checking.
		/// The default value is false.
		/// </summary>
		public bool CheckForOverflow { get; set; }

		/// <summary>
		/// Gets the arguments for which this OverloadResolution instance was created.
		/// </summary>
		public IList<ResolveResult> Arguments {
			get { return arguments; }
		}
		#endregion

		#region AddCandidate
		/// <summary>
		/// Adds a candidate to overload resolution.
		/// </summary>
		/// <param name="member">The candidate member to add.</param>
		/// <returns>The errors that prevent the member from being applicable, if any.
		/// Note: this method does not return errors that do not affect applicability.</returns>
		public OverloadResolutionErrors AddCandidate(IParameterizedMember member)
		{
			return AddCandidate(member, OverloadResolutionErrors.None);
		}

		/// <summary>
		/// Adds a candidate to overload resolution.
		/// </summary>
		/// <param name="member">The candidate member to add.</param>
		/// <param name="additionalErrors">Additional errors that apply to the candidate.
		/// This is used to represent errors during member lookup (e.g. OverloadResolutionErrors.Inaccessible)
		/// in overload resolution.</param>
		/// <returns>The errors that prevent the member from being applicable, if any.
		/// Note: this method does not return errors that do not affect applicability.</returns>
		public OverloadResolutionErrors AddCandidate(IParameterizedMember member, OverloadResolutionErrors additionalErrors)
		{
			if (member == null)
				throw new ArgumentNullException(nameof(member));

			Candidate c = new Candidate(member, false);
			c.AddError(additionalErrors);
			if (CalculateCandidate(c))
			{
				//candidates.Add(c);
			}

			if (this.AllowExpandingParams && member.Parameters.Count > 0
				&& member.Parameters[member.Parameters.Count - 1].IsParams)
			{
				Candidate expandedCandidate = new Candidate(member, true);
				expandedCandidate.AddError(additionalErrors);
				// consider expanded form only if it isn't obviously wrong
				if (CalculateCandidate(expandedCandidate))
				{
					//candidates.Add(expandedCandidate);

					if (expandedCandidate.ErrorCount < c.ErrorCount)
						return expandedCandidate.Errors;
				}
			}
			return c.Errors;
		}

		/// <summary>
		/// Calculates applicability etc. for the candidate.
		/// </summary>
		/// <returns>True if the calculation was successful, false if the candidate should be removed without reporting an error</returns>
		bool CalculateCandidate(Candidate candidate)
		{
			if (!ResolveParameterTypes(candidate, false))
				return false;
			MapCorrespondingParameters(candidate);
			RunTypeInference(candidate);
			CheckApplicability(candidate);
			ConsiderIfNewCandidateIsBest(candidate);
			return true;
		}

		bool ResolveParameterTypes(Candidate candidate, bool useSpecializedParameters)
		{
			for (int i = 0; i < candidate.Parameters.Count; i++)
			{
				IType type;
				if (useSpecializedParameters)
				{
					// Use the parameter type of the specialized non-generic method or indexer
					Debug.Assert(!candidate.IsGenericMethod);
					type = candidate.Member.Parameters[i].Type;
				}
				else
				{
					// Use the type of the original formal parameter
					type = candidate.Parameters[i].Type;
				}
				if (candidate.IsExpandedForm && i == candidate.Parameters.Count - 1)
				{
					ArrayType arrayType = type as ArrayType;
					if (arrayType != null && arrayType.Dimensions == 1)
						type = arrayType.ElementType;
					else
						return false; // error: cannot unpack params-array. abort considering the expanded form for this candidate
				}
				candidate.ParameterTypes[i] = type;
			}
			return true;
		}
		#endregion

		#region AddMethodLists
		/// <summary>
		/// Adds all candidates from the method lists.
		/// 
		/// This method implements the logic that causes applicable methods in derived types to hide
		/// all methods in base types.
		/// </summary>
		/// <param name="methodLists">The methods, grouped by declaring type. Base types must come first in the list.</param>
		public void AddMethodLists(IReadOnlyList<MethodListWithDeclaringType> methodLists)
		{
			if (methodLists == null)
				throw new ArgumentNullException(nameof(methodLists));
			// Base types come first, so go through the list backwards (derived types first)
			bool[] isHiddenByDerivedType;
			if (methodLists.Count > 1)
				isHiddenByDerivedType = new bool[methodLists.Count];
			else
				isHiddenByDerivedType = null;
			for (int i = methodLists.Count - 1; i >= 0; i--)
			{
				if (isHiddenByDerivedType != null && isHiddenByDerivedType[i])
				{
					Log.WriteLine("  Skipping methods in {0} because they are hidden by an applicable method in a derived type", methodLists[i].DeclaringType);
					continue;
				}

				MethodListWithDeclaringType methodList = methodLists[i];
				bool foundApplicableCandidateInCurrentList = false;

				for (int j = 0; j < methodList.Count; j++)
				{
					IParameterizedMember method = methodList[j];
					Log.Indent();
					OverloadResolutionErrors errors = AddCandidate(method);
					Log.Unindent();
					LogCandidateAddingResult("  Candidate", method, errors);

					foundApplicableCandidateInCurrentList |= IsApplicable(errors);
				}

				if (foundApplicableCandidateInCurrentList && i > 0)
				{
					foreach (IType baseType in methodList.DeclaringType.GetAllBaseTypes())
					{
						for (int j = 0; j < i; j++)
						{
							if (!isHiddenByDerivedType[j] && baseType.Equals(methodLists[j].DeclaringType))
								isHiddenByDerivedType[j] = true;
						}
					}
				}
			}
		}

		[Conditional("DEBUG")]
		internal void LogCandidateAddingResult(string text, IParameterizedMember method, OverloadResolutionErrors errors)
		{
#if DEBUG
			Log.WriteLine(string.Format("{0} {1} = {2}{3}",
										text, method,
										errors == OverloadResolutionErrors.None ? "Success" : errors.ToString(),
										this.BestCandidate == method ? " (best candidate so far)" :
										this.BestCandidateAmbiguousWith == method ? " (ambiguous)" : ""
									   ));
#endif
		}
		#endregion

		#region MapCorrespondingParameters
		void MapCorrespondingParameters(Candidate candidate)
		{
			// C# 4.0 spec: 7.5.1.1 Corresponding parameters
			// Updated for C# 7.2 non-trailing named arguments
			candidate.ArgumentToParameterMap = new int[arguments.Length];
			bool hasPositionalArgument = false;
			// go backwards, so that hasPositionalArgument tells us whether there
			// are non-trailing named arguments
			for (int i = arguments.Length - 1; i >= 0; i--)
			{
				candidate.ArgumentToParameterMap[i] = -1;
				if (argumentNames[i] == null || hasPositionalArgument)
				{
					hasPositionalArgument = true;
					// positional argument or non-trailing named argument
					if (i < candidate.ParameterTypes.Length)
					{
						candidate.ArgumentToParameterMap[i] = i;
						if (argumentNames[i] != null && argumentNames[i] != candidate.Parameters[i].Name)
						{
							// non-trailing named argument must match name
							candidate.AddError(OverloadResolutionErrors.NoParameterFoundForNamedArgument);
						}
					}
					else if (candidate.IsExpandedForm)
					{
						candidate.ArgumentToParameterMap[i] = candidate.ParameterTypes.Length - 1;
						if (argumentNames[i] != null)
						{
							// can't use non-trailing named argument here
							candidate.AddError(OverloadResolutionErrors.NoParameterFoundForNamedArgument);
						}
					}
					else
					{
						candidate.AddError(OverloadResolutionErrors.TooManyPositionalArguments);
					}
				}
				else
				{
					// (trailing) named argument
					for (int j = 0; j < candidate.Parameters.Count; j++)
					{
						if (argumentNames[i] == candidate.Parameters[j].Name)
						{
							candidate.ArgumentToParameterMap[i] = j;
						}
					}
					if (candidate.ArgumentToParameterMap[i] < 0)
						candidate.AddError(OverloadResolutionErrors.NoParameterFoundForNamedArgument);
				}
			}
		}
		#endregion

		#region RunTypeInference
		void RunTypeInference(Candidate candidate)
		{
			if (candidate.TypeParameters == null)
			{
				if (explicitlyGivenTypeArguments != null)
				{
					// method does not expect type arguments, but was given some
					candidate.AddError(OverloadResolutionErrors.WrongNumberOfTypeArguments);
				}
				// Grab new parameter types:
				ResolveParameterTypes(candidate, true);
				return;
			}
			ParameterizedType parameterizedDeclaringType = candidate.Member.DeclaringType as ParameterizedType;
			IReadOnlyList<IType> classTypeArguments;
			if (parameterizedDeclaringType != null)
			{
				classTypeArguments = parameterizedDeclaringType.TypeArguments;
			}
			else
			{
				classTypeArguments = null;
			}
			// The method is generic:
			if (explicitlyGivenTypeArguments != null)
			{
				if (explicitlyGivenTypeArguments.Length == candidate.TypeParameters.Count)
				{
					candidate.InferredTypes = explicitlyGivenTypeArguments;
				}
				else
				{
					candidate.AddError(OverloadResolutionErrors.WrongNumberOfTypeArguments);
					// wrong number of type arguments given, so truncate the list or pad with UnknownType
					candidate.InferredTypes = new IType[candidate.TypeParameters.Count];
					for (int i = 0; i < candidate.InferredTypes.Length; i++)
					{
						if (i < explicitlyGivenTypeArguments.Length)
							candidate.InferredTypes[i] = explicitlyGivenTypeArguments[i];
						else
							candidate.InferredTypes[i] = SpecialType.UnknownType;
					}
				}
			}
			else
			{
				TypeInference ti = new TypeInference(compilation, conversions);
				IType[] parameterTypes = candidate.ArgumentToParameterMap
					.SelectReadOnlyArray(parameterIndex => parameterIndex >= 0 ? candidate.ParameterTypes[parameterIndex] : SpecialType.UnknownType);
				bool success;
				candidate.InferredTypes = ti.InferTypeArguments(candidate.TypeParameters, arguments, parameterTypes, out success, classTypeArguments);
				if (!success)
					candidate.AddError(OverloadResolutionErrors.TypeInferenceFailed);
			}
			// Now substitute in the formal parameters:
			var substitution = new ConstraintValidatingSubstitution(classTypeArguments, candidate.InferredTypes, this);
			for (int i = 0; i < candidate.ParameterTypes.Length; i++)
			{
				candidate.ParameterTypes[i] = candidate.ParameterTypes[i].AcceptVisitor(substitution);
			}
			if (!substitution.ConstraintsValid)
				candidate.AddError(OverloadResolutionErrors.ConstructedTypeDoesNotSatisfyConstraint);
		}

		sealed class ConstraintValidatingSubstitution : TypeParameterSubstitution
		{
			readonly CSharpConversions conversions;
			public bool ConstraintsValid = true;

			public ConstraintValidatingSubstitution(IReadOnlyList<IType> classTypeArguments, IReadOnlyList<IType> methodTypeArguments, OverloadResolution overloadResolution)
				: base(classTypeArguments, methodTypeArguments)
			{
				this.conversions = overloadResolution.conversions;
			}

			public override IType VisitParameterizedType(ParameterizedType type)
			{
				IType newType = base.VisitParameterizedType(type);
				if (newType != type && ConstraintsValid)
				{
					// something was changed, so we need to validate the constraints
					ParameterizedType newParameterizedType = newType as ParameterizedType;
					if (newParameterizedType != null)
					{
						// C# 4.0 spec: 4.4.4 Satisfying constraints
						var typeParameters = newParameterizedType.TypeParameters;
						var substitution = newParameterizedType.GetSubstitution();
						for (int i = 0; i < typeParameters.Count; i++)
						{
							if (!ValidateConstraints(typeParameters[i], newParameterizedType.GetTypeArgument(i), substitution, conversions))
							{
								ConstraintsValid = false;
								break;
							}
						}
					}
				}
				return newType;
			}
		}
		#endregion

		#region Validate Constraints
		OverloadResolutionErrors ValidateMethodConstraints(Candidate candidate)
		{
			// If type inference already failed, we won't check the constraints:
			if ((candidate.Errors & OverloadResolutionErrors.TypeInferenceFailed) != 0)
				return OverloadResolutionErrors.None;

			if (candidate.TypeParameters == null || candidate.TypeParameters.Count == 0)
				return OverloadResolutionErrors.None; // the method isn't generic
			var substitution = GetSubstitution(candidate);
			for (int i = 0; i < candidate.TypeParameters.Count; i++)
			{
				if (!ValidateConstraints(candidate.TypeParameters[i], substitution.MethodTypeArguments[i], substitution))
					return OverloadResolutionErrors.MethodConstraintsNotSatisfied;
			}
			return OverloadResolutionErrors.None;
		}

		/// <summary>
		/// Validates whether the given type argument satisfies the constraints for the given type parameter.
		/// </summary>
		/// <param name="typeParameter">The type parameter.</param>
		/// <param name="typeArgument">The type argument.</param>
		/// <param name="substitution">The substitution that defines how type parameters are replaced with type arguments.
		/// The substitution is used to check constraints that depend on other type parameters (or recursively on the same type parameter).
		/// May be null if no substitution should be used.</param>
		/// <returns>True if the constraints are satisfied; false otherwise.</returns>
		public static bool ValidateConstraints(ITypeParameter typeParameter, IType typeArgument, TypeVisitor substitution = null)
		{
			if (typeParameter == null)
				throw new ArgumentNullException(nameof(typeParameter));
			if (typeArgument == null)
				throw new ArgumentNullException(nameof(typeArgument));
			return ValidateConstraints(typeParameter, typeArgument, substitution, CSharpConversions.Get(typeParameter.Owner.Compilation));
		}

		internal static bool ValidateConstraints(ITypeParameter typeParameter, IType typeArgument, TypeVisitor substitution, CSharpConversions conversions)
		{
			switch (typeArgument.Kind)
			{ // void, null, and pointers cannot be used as type arguments
				case TypeKind.Void:
				case TypeKind.Null:
				case TypeKind.Pointer:
					return false;
			}
			if (typeParameter.HasReferenceTypeConstraint)
			{
				if (typeArgument.IsReferenceType != true)
					return false;
			}
			if (typeParameter.HasValueTypeConstraint)
			{
				if (!NullableType.IsNonNullableValueType(typeArgument))
					return false;
			}
			if (typeParameter.HasDefaultConstructorConstraint)
			{
				ITypeDefinition def = typeArgument.GetDefinition();
				if (def != null && def.IsAbstract)
					return false;
				var ctors = typeArgument.GetConstructors(
					m => m.Parameters.Count == 0 && m.Accessibility == Accessibility.Public,
					GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions
				);
				if (!ctors.Any())
					return false;
			}
			foreach (IType constraintType in typeParameter.DirectBaseTypes)
			{
				IType c = constraintType;
				if (substitution != null)
					c = c.AcceptVisitor(substitution);
				if (!conversions.IsConstraintConvertible(typeArgument, c))
					return false;
			}
			return true;
		}
		#endregion

		#region CheckApplicability
		/// <summary>
		/// Returns whether a candidate with the given errors is still considered to be applicable.
		/// </summary>
		public static bool IsApplicable(OverloadResolutionErrors errors)
		{
			const OverloadResolutionErrors errorsThatDoNotMatterForApplicability =
				OverloadResolutionErrors.AmbiguousMatch | OverloadResolutionErrors.MethodConstraintsNotSatisfied;
			return (errors & ~errorsThatDoNotMatterForApplicability) == OverloadResolutionErrors.None;
		}

		void CheckApplicability(Candidate candidate)
		{
			// C# 4.0 spec: 7.5.3.1 Applicable function member

			// Test whether parameters were mapped the correct number of arguments:
			int[] argumentCountPerParameter = new int[candidate.ParameterTypes.Length];
			foreach (int parameterIndex in candidate.ArgumentToParameterMap)
			{
				if (parameterIndex >= 0)
					argumentCountPerParameter[parameterIndex]++;
			}
			for (int i = 0; i < argumentCountPerParameter.Length; i++)
			{
				if (candidate.IsExpandedForm && i == argumentCountPerParameter.Length - 1)
					continue; // any number of arguments is fine for the params-array
				if (argumentCountPerParameter[i] == 0)
				{
					if (this.AllowOptionalParameters && candidate.Parameters[i].IsOptional)
						candidate.HasUnmappedOptionalParameters = true;
					else
						candidate.AddError(OverloadResolutionErrors.MissingArgumentForRequiredParameter);
				}
				else if (argumentCountPerParameter[i] > 1)
				{
					candidate.AddError(OverloadResolutionErrors.MultipleArgumentsForSingleParameter);
				}
			}

			candidate.ArgumentConversions = new Conversion[arguments.Length];
			// Test whether argument passing mode matches the parameter passing mode
			for (int i = 0; i < arguments.Length; i++)
			{
				int parameterIndex = candidate.ArgumentToParameterMap[i];
				if (parameterIndex < 0)
				{
					candidate.ArgumentConversions[i] = Conversion.None;
					continue;
				}

				ReferenceKind paramRefKind = candidate.Parameters[parameterIndex].ReferenceKind;
				if (arguments[i] is ByReferenceResolveResult brrr)
				{
					if (brrr.ReferenceKind != paramRefKind)
						candidate.AddError(OverloadResolutionErrors.ParameterPassingModeMismatch);
				}
				else if (arguments[i] is OutVarResolveResult)
				{
					if (paramRefKind != ReferenceKind.Out)
						candidate.AddError(OverloadResolutionErrors.ParameterPassingModeMismatch);
					// 'out var decl' arguments are compatible with any out parameter
					continue;
				}
				else
				{
					// AllowImplicitIn: `in` parameters can be filled implicitly without `in` DirectionExpression
					// IsExtensionMethodInvocation: `this ref` and `this in` parameters can be filled implicitly
					if (((paramRefKind == ReferenceKind.In && AllowImplicitIn)
						|| (IsExtensionMethodInvocation && parameterIndex == 0 && (paramRefKind == ReferenceKind.In || paramRefKind == ReferenceKind.Ref))
						) && candidate.ParameterTypes[parameterIndex].SkipModifiers() is ByReferenceType brt)
					{
						// Treat the parameter as if it was not declared "in" for the following steps
						// (applicability + better function member)
						candidate.ParameterTypes[parameterIndex] = brt.ElementType;
					}
					else if (paramRefKind != ReferenceKind.None)
					{
						candidate.AddError(OverloadResolutionErrors.ParameterPassingModeMismatch);
					}
				}
				IType parameterType = candidate.ParameterTypes[parameterIndex];
				Conversion c = conversions.ImplicitConversion(arguments[i], parameterType);
				candidate.ArgumentConversions[i] = c;
				if (IsExtensionMethodInvocation && parameterIndex == 0)
				{
					// First parameter to extension method must be an identity, reference or boxing conversion
					if (!(c == Conversion.IdentityConversion || c == Conversion.ImplicitReferenceConversion || c == Conversion.BoxingConversion))
						candidate.AddError(OverloadResolutionErrors.ArgumentTypeMismatch);
				}
				else
				{
					if ((!c.IsValid && !c.IsUserDefined && !c.IsMethodGroupConversion) && parameterType.Kind != TypeKind.Unknown)
						candidate.AddError(OverloadResolutionErrors.ArgumentTypeMismatch);
				}
			}
		}
		#endregion

		#region BetterFunctionMember
		/// <summary>
		/// Returns 1 if c1 is better than c2; 2 if c2 is better than c1; or 0 if neither is better.
		/// </summary>
		int BetterFunctionMember(Candidate c1, Candidate c2)
		{
			// prefer applicable members (part of heuristic that produces a best candidate even if none is applicable)
			if (c1.ErrorCount == 0 && c2.ErrorCount > 0)
				return 1;
			if (c1.ErrorCount > 0 && c2.ErrorCount == 0)
				return 2;

			// C# 4.0 spec: 7.5.3.2 Better function member
			bool c1IsBetter = false;
			bool c2IsBetter = false;
			bool parameterTypesEqual = true;
			for (int i = 0; i < arguments.Length; i++)
			{
				int p1 = c1.ArgumentToParameterMap[i];
				int p2 = c2.ArgumentToParameterMap[i];
				if (p1 >= 0 && p2 < 0)
				{
					c1IsBetter = true;
				}
				else if (p1 < 0 && p2 >= 0)
				{
					c2IsBetter = true;
				}
				else if (p1 >= 0 && p2 >= 0)
				{
					if (!conversions.IdentityConversion(c1.ParameterTypes[p1], c2.ParameterTypes[p2]))
						parameterTypesEqual = false;
					switch (conversions.BetterConversion(arguments[i], c1.ParameterTypes[p1], c2.ParameterTypes[p2]))
					{
						case 1:
							c1IsBetter = true;
							break;
						case 2:
							c2IsBetter = true;
							break;
					}
				}
			}
			if (c1IsBetter && !c2IsBetter)
				return 1;
			if (!c1IsBetter && c2IsBetter)
				return 2;

			// prefer members with less errors (part of heuristic that produces a best candidate even if none is applicable)
			if (c1.ErrorCount < c2.ErrorCount)
				return 1;
			if (c1.ErrorCount > c2.ErrorCount)
				return 2;

			if (!c1IsBetter && !c2IsBetter && parameterTypesEqual)
			{
				// we need the tie-breaking rules

				// non-generic methods are better
				if (!c1.IsGenericMethod && c2.IsGenericMethod)
					return 1;
				else if (c1.IsGenericMethod && !c2.IsGenericMethod)
					return 2;

				// non-expanded members are better
				if (!c1.IsExpandedForm && c2.IsExpandedForm)
					return 1;
				else if (c1.IsExpandedForm && !c2.IsExpandedForm)
					return 2;

				// prefer the member with less arguments mapped to the params-array
				int r = c1.ArgumentsPassedToParamsArray.CompareTo(c2.ArgumentsPassedToParamsArray);
				if (r < 0)
					return 1;
				else if (r > 0)
					return 2;

				// prefer the member where no default values need to be substituted
				if (!c1.HasUnmappedOptionalParameters && c2.HasUnmappedOptionalParameters)
					return 1;
				else if (c1.HasUnmappedOptionalParameters && !c2.HasUnmappedOptionalParameters)
					return 2;

				// compare the formal parameters
				r = MoreSpecificFormalParameters(c1, c2);
				if (r != 0)
					return r;

				// prefer non-lifted operators
				ILiftedOperator lift1 = c1.Member as ILiftedOperator;
				ILiftedOperator lift2 = c2.Member as ILiftedOperator;
				if (lift1 == null && lift2 != null)
					return 1;
				if (lift1 != null && lift2 == null)
					return 2;
			}
			return 0;
		}

		int MoreSpecificFormalParameters(Candidate c1, Candidate c2)
		{
			// prefer the member with more formal parmeters (in case both have different number of optional parameters)
			int r = c1.Parameters.Count.CompareTo(c2.Parameters.Count);
			if (r > 0)
				return 1;
			else if (r < 0)
				return 2;

			return MoreSpecificFormalParameters(c1.Parameters.Select(p => p.Type), c2.Parameters.Select(p => p.Type));
		}

		static int MoreSpecificFormalParameters(IEnumerable<IType> t1, IEnumerable<IType> t2)
		{
			bool c1IsBetter = false;
			bool c2IsBetter = false;
			foreach (var pair in t1.Zip(t2, (a, b) => new { Item1 = a, Item2 = b }))
			{
				switch (MoreSpecificFormalParameter(pair.Item1, pair.Item2))
				{
					case 1:
						c1IsBetter = true;
						break;
					case 2:
						c2IsBetter = true;
						break;
				}
			}
			if (c1IsBetter && !c2IsBetter)
				return 1;
			if (!c1IsBetter && c2IsBetter)
				return 2;
			return 0;
		}

		static int MoreSpecificFormalParameter(IType t1, IType t2)
		{
			if ((t1 is ITypeParameter) && !(t2 is ITypeParameter))
				return 2;
			if ((t2 is ITypeParameter) && !(t1 is ITypeParameter))
				return 1;

			ParameterizedType p1 = t1 as ParameterizedType;
			ParameterizedType p2 = t2 as ParameterizedType;
			if (p1 != null && p2 != null && p1.TypeParameterCount == p2.TypeParameterCount)
			{
				int r = MoreSpecificFormalParameters(p1.TypeArguments, p2.TypeArguments);
				if (r > 0)
					return r;
			}
			TypeWithElementType tew1 = t1 as TypeWithElementType;
			TypeWithElementType tew2 = t2 as TypeWithElementType;
			if (tew1 != null && tew2 != null)
			{
				return MoreSpecificFormalParameter(tew1.ElementType, tew2.ElementType);
			}
			return 0;
		}
		#endregion

		#region ConsiderIfNewCandidateIsBest
		void ConsiderIfNewCandidateIsBest(Candidate candidate)
		{
			if (bestCandidate == null)
			{
				bestCandidate = candidate;
				bestCandidateWasValidated = false;
			}
			else
			{
				switch (BetterFunctionMember(candidate, bestCandidate))
				{
					case 0:
						// Overwrite 'bestCandidateAmbiguousWith' so that API users can
						// detect the set of all ambiguous methods if they look at
						// bestCandidateAmbiguousWith after each step.
						bestCandidateAmbiguousWith = candidate;
						break;
					case 1:
						bestCandidate = candidate;
						bestCandidateWasValidated = false;
						bestCandidateAmbiguousWith = null;
						break;
						// case 2: best candidate stays best
				}
			}
		}
		#endregion

		#region Output Properties
		public IParameterizedMember BestCandidate {
			get { return bestCandidate != null ? bestCandidate.Member : null; }
		}

		/// <summary>
		/// Returns the errors that apply to the best candidate.
		/// This includes additional errors that do not affect applicability (e.g. AmbiguousMatch, MethodConstraintsNotSatisfied)
		/// </summary>
		public OverloadResolutionErrors BestCandidateErrors {
			get {
				if (bestCandidate == null)
					return OverloadResolutionErrors.None;
				if (!bestCandidateWasValidated)
				{
					bestCandidateValidationResult = ValidateMethodConstraints(bestCandidate);
					bestCandidateWasValidated = true;
				}
				OverloadResolutionErrors err = bestCandidate.Errors | bestCandidateValidationResult;
				if (bestCandidateAmbiguousWith != null)
					err |= OverloadResolutionErrors.AmbiguousMatch;
				return err;
			}
		}

		public bool FoundApplicableCandidate {
			get { return bestCandidate != null && IsApplicable(bestCandidate.Errors); }
		}

		public IParameterizedMember BestCandidateAmbiguousWith {
			get { return bestCandidateAmbiguousWith != null ? bestCandidateAmbiguousWith.Member : null; }
		}

		public bool BestCandidateIsExpandedForm {
			get { return bestCandidate != null ? bestCandidate.IsExpandedForm : false; }
		}

		public bool IsAmbiguous {
			get { return bestCandidateAmbiguousWith != null; }
		}

		public IReadOnlyList<IType> InferredTypeArguments {
			get {
				if (bestCandidate != null && bestCandidate.InferredTypes != null)
					return bestCandidate.InferredTypes;
				else
					return EmptyList<IType>.Instance;
			}
		}

		/// <summary>
		/// Gets the implicit conversions that are being applied to the arguments.
		/// </summary>
		public IList<Conversion> ArgumentConversions {
			get {
				if (bestCandidate != null && bestCandidate.ArgumentConversions != null)
					return bestCandidate.ArgumentConversions;
				else
					return Enumerable.Repeat(Conversion.None, arguments.Length).ToList();
			}
		}

		/// <summary>
		/// Gets an array that maps argument indices to parameter indices.
		/// For arguments that could not be mapped to any parameter, the value will be -1.
		/// 
		/// parameterIndex = GetArgumentToParameterMap()[argumentIndex]
		/// </summary>
		public IReadOnlyList<int> GetArgumentToParameterMap()
		{
			if (bestCandidate != null)
				return bestCandidate.ArgumentToParameterMap;
			else
				return null;
		}

		/// <summary>
		/// Returns the arguments for the method call in the order they were provided (not in the order of the parameters).
		/// Arguments are wrapped in a <see cref="ConversionResolveResult"/> if an implicit conversion is being applied
		/// to them when calling the method.
		/// </summary>
		public IList<ResolveResult> GetArgumentsWithConversions()
		{
			if (bestCandidate == null)
				return arguments;
			else
				return GetArgumentsWithConversions(null, null);
		}

		/// <summary>
		/// Returns the arguments for the method call in the order they were provided (not in the order of the parameters).
		/// Arguments are wrapped in a <see cref="ConversionResolveResult"/> if an implicit conversion is being applied
		/// to them when calling the method.
		/// For arguments where an explicit argument name was provided, the argument will
		/// be wrapped in a <see cref="NamedArgumentResolveResult"/>.
		/// </summary>
		public IList<ResolveResult> GetArgumentsWithConversionsAndNames()
		{
			if (bestCandidate == null)
				return arguments;
			else
				return GetArgumentsWithConversions(null, GetBestCandidateWithSubstitutedTypeArguments());
		}

		IList<ResolveResult> GetArgumentsWithConversions(ResolveResult targetResolveResult, IParameterizedMember bestCandidateForNamedArguments)
		{
			var conversions = this.ArgumentConversions;
			ResolveResult[] args = new ResolveResult[arguments.Length];
			for (int i = 0; i < args.Length; i++)
			{
				var argument = arguments[i];
				if (this.IsExtensionMethodInvocation && i == 0 && targetResolveResult != null)
					argument = targetResolveResult;
				int parameterIndex = bestCandidate.ArgumentToParameterMap[i];
				if (parameterIndex >= 0 && conversions[i] != Conversion.IdentityConversion)
				{
					// Wrap argument in ConversionResolveResult
					IType parameterType = bestCandidate.ParameterTypes[parameterIndex];
					if (parameterType.Kind != TypeKind.Unknown)
					{
						if (arguments[i].IsCompileTimeConstant && conversions[i].IsValid && !conversions[i].IsUserDefined)
						{
							argument = new CSharpResolver(compilation).WithCheckForOverflow(CheckForOverflow).ResolveCast(parameterType, argument);
						}
						else
						{
							argument = new ConversionResolveResult(parameterType, argument, conversions[i], CheckForOverflow);
						}
					}
				}
				if (bestCandidateForNamedArguments != null && argumentNames[i] != null)
				{
					// Wrap argument in NamedArgumentResolveResult
					if (parameterIndex >= 0)
					{
						argument = new NamedArgumentResolveResult(bestCandidateForNamedArguments.Parameters[parameterIndex], argument, bestCandidateForNamedArguments);
					}
					else
					{
						argument = new NamedArgumentResolveResult(argumentNames[i], argument);
					}
				}
				args[i] = argument;
			}
			return args;
		}

		public IParameterizedMember GetBestCandidateWithSubstitutedTypeArguments()
		{
			if (bestCandidate == null)
				return null;
			IMethod method = bestCandidate.Member as IMethod;
			if (method != null && method.TypeParameters.Count > 0)
			{
				return ((IMethod)method.MemberDefinition).Specialize(GetSubstitution(bestCandidate));
			}
			else
			{
				return bestCandidate.Member;
			}
		}

		TypeParameterSubstitution GetSubstitution(Candidate candidate)
		{
			// Do not compose the substitutions, but merge them.
			// This is required for InvocationTests.SubstituteClassAndMethodTypeParametersAtOnce
			return new TypeParameterSubstitution(candidate.Member.Substitution.ClassTypeArguments, candidate.InferredTypes);
		}

		/// <summary>
		/// Creates a ResolveResult representing the result of overload resolution.
		/// </summary>
		/// <param name="targetResolveResult">
		/// The target expression of the call. May be <c>null</c> for static methods/constructors.
		/// </param>
		/// <param name="initializerStatements">
		/// Statements for Objects/Collections initializer.
		/// <see cref="InvocationResolveResult.InitializerStatements"/>
		/// </param>
		/// <param name="returnTypeOverride">
		/// If not null, use this instead of the ReturnType of the member as the type of the created resolve result.
		/// </param>
		public CSharpInvocationResolveResult CreateResolveResult(ResolveResult targetResolveResult, IList<ResolveResult> initializerStatements = null, IType returnTypeOverride = null)
		{
			IParameterizedMember member = GetBestCandidateWithSubstitutedTypeArguments();
			if (member == null)
				throw new InvalidOperationException();

			return new CSharpInvocationResolveResult(
				this.IsExtensionMethodInvocation ? new TypeResolveResult(member.DeclaringType ?? SpecialType.UnknownType) : targetResolveResult,
				member,
				GetArgumentsWithConversions(targetResolveResult, member),
				this.BestCandidateErrors,
				this.IsExtensionMethodInvocation,
				this.BestCandidateIsExpandedForm,
				isDelegateInvocation: false,
				argumentToParameterMap: this.GetArgumentToParameterMap(),
				initializerStatements: initializerStatements,
				returnTypeOverride: returnTypeOverride);
		}
		#endregion
	}
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Resolver\TypeInference.cs
Description: Error: Unable to create valid SyntaxTree for document: TypeInference.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (U is ByReferenceType brU && V is ByReferenceType brV)
			{
				MakeExactInference(brU.ElementType, brV.ElementType);
				return;
			}
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (U is ByReferenceType brU && V is ByReferenceType brV)
			{
				MakeExactInference(brU.ElementType, brV.ElementType);
				return;
			}
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using ICSharpCode.Decompiler.Semantics;
using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.TypeSystem.Implementation;
using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.CSharp.Resolver
{
	public enum TypeInferenceAlgorithm
	{
		/// <summary>
		/// C# 4.0 type inference.
		/// </summary>
		CSharp4,
		/// <summary>
		/// Improved algorithm (not part of any specification) using FindTypeInBounds for fixing.
		/// </summary>
		Improved,
		/// <summary>
		/// Improved algorithm (not part of any specification) using FindTypeInBounds for fixing;
		/// uses <see cref="IntersectionType"/> to report all results (in case of ambiguities).
		/// </summary>
		ImprovedReturnAllResults
	}

	/// <summary>
	/// Implements C# 4.0 Type Inference (7.5.2).
	/// </summary>
	public sealed class TypeInference
	{
		readonly ICompilation compilation;
		readonly CSharpConversions conversions;
		TypeInferenceAlgorithm algorithm = TypeInferenceAlgorithm.CSharp4;

		// determines the maximum generic nesting level; necessary to avoid infinite recursion in 'Improved' mode.
		const int maxNestingLevel = 5;
		int nestingLevel;

		#region Constructor
		public TypeInference(ICompilation compilation)
		{
			if (compilation == null)
				throw new ArgumentNullException(nameof(compilation));
			this.compilation = compilation;
			this.conversions = CSharpConversions.Get(compilation);
		}

		internal TypeInference(ICompilation compilation, CSharpConversions conversions)
		{
			Debug.Assert(compilation != null);
			Debug.Assert(conversions != null);
			this.compilation = compilation;
			this.conversions = conversions;
		}
		#endregion

		#region Properties
		/// <summary>
		/// Gets/Sets the type inference algorithm used.
		/// </summary>
		public TypeInferenceAlgorithm Algorithm {
			get { return algorithm; }
			set { algorithm = value; }
		}

		TypeInference CreateNestedInstance()
		{
			TypeInference c = new TypeInference(compilation, conversions);
			c.algorithm = algorithm;
			c.nestingLevel = nestingLevel + 1;
			return c;
		}
		#endregion

		TP[] typeParameters;
		IType[] parameterTypes;
		ResolveResult[] arguments;
		bool[,] dependencyMatrix;
		IReadOnlyList<IType> classTypeArguments;

		#region InferTypeArguments (main function)
		/// <summary>
		/// Performs type inference.
		/// </summary>
		/// <param name="typeParameters">The method type parameters that should be inferred.</param>
		/// <param name="arguments">The arguments passed to the method.</param>
		/// <param name="parameterTypes">The parameter types of the method.</param>
		/// <param name="success">Out: whether type inference was successful</param>
		/// <param name="classTypeArguments">
		/// Class type arguments. These are substituted for class type parameters in the formal parameter types
		/// when inferring a method group or lambda.
		/// </param>
		/// <returns>The inferred type arguments.</returns>
		public IType[] InferTypeArguments(IReadOnlyList<ITypeParameter> typeParameters, IReadOnlyList<ResolveResult> arguments, IReadOnlyList<IType> parameterTypes, out bool success, IReadOnlyList<IType> classTypeArguments = null)
		{
			if (typeParameters == null)
				throw new ArgumentNullException(nameof(typeParameters));
			if (arguments == null)
				throw new ArgumentNullException(nameof(arguments));
			if (parameterTypes == null)
				throw new ArgumentNullException(nameof(parameterTypes));
			try
			{
				this.typeParameters = new TP[typeParameters.Count];
				for (int i = 0; i < this.typeParameters.Length; i++)
				{
					if (i != typeParameters[i].Index)
						throw new ArgumentException("Type parameter has wrong index");
					if (typeParameters[i].OwnerType != SymbolKind.Method)
						throw new ArgumentException("Type parameter must be owned by a method");
					this.typeParameters[i] = new TP(typeParameters[i]);
				}
				this.parameterTypes = new IType[Math.Min(arguments.Count, parameterTypes.Count)];
				this.arguments = new ResolveResult[this.parameterTypes.Length];
				for (int i = 0; i < this.parameterTypes.Length; i++)
				{
					if (arguments[i] == null || parameterTypes[i] == null)
						throw new ArgumentNullException();
					this.arguments[i] = arguments[i];
					this.parameterTypes[i] = parameterTypes[i];
				}
				this.classTypeArguments = classTypeArguments;
				Log.WriteLine("Type Inference");
				Log.WriteLine("  Signature: M<" + string.Join<TP>(", ", this.typeParameters) + ">"
							  + "(" + string.Join<IType>(", ", this.parameterTypes) + ")");
				Log.WriteCollection("  Arguments: ", arguments);
				Log.Indent();

				PhaseOne();
				success = PhaseTwo();

				Log.Unindent();
				Log.WriteLine("  Type inference finished " + (success ? "successfully" : "with errors") + ": " +
							  "M<" + string.Join(", ", this.typeParameters.Select(tp => tp.FixedTo ?? SpecialType.UnknownType)) + ">");
				return this.typeParameters.Select(tp => tp.FixedTo ?? SpecialType.UnknownType).ToArray();
			}
			finally
			{
				Reset();
			}
		}

		void Reset()
		{
			// clean up so that memory used by the operation can be garbage collected as soon as possible
			this.typeParameters = null;
			this.parameterTypes = null;
			this.arguments = null;
			this.dependencyMatrix = null;
			this.classTypeArguments = null;
		}

		/// <summary>
		/// Infers type arguments for the <paramref name="typeParameters"/> occurring in the <paramref name="targetType"/>
		/// so that the resulting type (after substition) satisfies the given bounds.
		/// </summary>
		public IType[] InferTypeArgumentsFromBounds(IReadOnlyList<ITypeParameter> typeParameters, IType targetType, IEnumerable<IType> lowerBounds, IEnumerable<IType> upperBounds, out bool success)
		{
			if (typeParameters == null)
				throw new ArgumentNullException(nameof(typeParameters));
			if (targetType == null)
				throw new ArgumentNullException(nameof(targetType));
			if (lowerBounds == null)
				throw new ArgumentNullException(nameof(lowerBounds));
			if (upperBounds == null)
				throw new ArgumentNullException(nameof(upperBounds));
			this.typeParameters = new TP[typeParameters.Count];
			for (int i = 0; i < this.typeParameters.Length; i++)
			{
				if (i != typeParameters[i].Index)
					throw new ArgumentException("Type parameter has wrong index");
				this.typeParameters[i] = new TP(typeParameters[i]);
			}
			foreach (IType b in lowerBounds)
			{
				MakeLowerBoundInference(b, targetType);
			}
			foreach (IType b in upperBounds)
			{
				MakeUpperBoundInference(b, targetType);
			}
			IType[] result = new IType[this.typeParameters.Length];
			success = true;
			for (int i = 0; i < result.Length; i++)
			{
				success &= Fix(this.typeParameters[i]);
				result[i] = this.typeParameters[i].FixedTo ?? SpecialType.UnknownType;
			}
			Reset();
			return result;
		}
		#endregion

		sealed class TP
		{
			public readonly HashSet<IType> LowerBounds = new HashSet<IType>();
			public readonly HashSet<IType> UpperBounds = new HashSet<IType>();
			public IType ExactBound;
			public bool MultipleDifferentExactBounds;
			public readonly ITypeParameter TypeParameter;
			public IType FixedTo;

			public bool IsFixed {
				get { return FixedTo != null; }
			}

			public bool HasBounds {
				get { return LowerBounds.Count > 0 || UpperBounds.Count > 0 || ExactBound != null; }
			}

			public TP(ITypeParameter typeParameter)
			{
				if (typeParameter == null)
					throw new ArgumentNullException(nameof(typeParameter));
				this.TypeParameter = typeParameter;
			}

			public void AddExactBound(IType type)
			{
				// Exact bounds need to stored separately, not just as Lower+Upper bounds,
				// due to TypeInferenceTests.GenericArgumentImplicitlyConvertibleToAndFromAnotherTypeList (see #281)
				if (ExactBound == null)
					ExactBound = type;
				else if (!ExactBound.Equals(type))
					MultipleDifferentExactBounds = true;
			}

			public override string ToString()
			{
				return TypeParameter.Name;
			}
		}

		sealed class OccursInVisitor : TypeVisitor
		{
			readonly TP[] tp;
			public readonly bool[] Occurs;

			public OccursInVisitor(TypeInference typeInference)
			{
				this.tp = typeInference.typeParameters;
				this.Occurs = new bool[tp.Length];
			}

			public override IType VisitTypeParameter(ITypeParameter type)
			{
				int index = type.Index;
				if (index < tp.Length && tp[index].TypeParameter == type)
					Occurs[index] = true;
				return base.VisitTypeParameter(type);
			}
		}

		#region Inference Phases
		void PhaseOne()
		{
			// C# 4.0 spec: 7.5.2.1 The first phase
			Log.WriteLine("Phase One");
			for (int i = 0; i < arguments.Length; i++)
			{
				ResolveResult Ei = arguments[i];
				IType Ti = parameterTypes[i];

				LambdaResolveResult lrr = Ei as LambdaResolveResult;
				if (lrr != null)
				{
					MakeExplicitParameterTypeInference(lrr, Ti);
				}
				if (lrr != null || Ei is MethodGroupResolveResult)
				{
					// this is not in the spec???
					if (OutputTypeContainsUnfixed(Ei, Ti) && !InputTypesContainsUnfixed(Ei, Ti))
					{
						MakeOutputTypeInference(Ei, Ti);
					}
				}

				if (IsValidType(Ei.Type))
				{
					if (Ti is ByReferenceType)
					{
						MakeExactInference(Ei.Type, Ti);
					}
					else
					{
						MakeLowerBoundInference(Ei.Type, Ti);
					}
				}
			}
		}

		static bool IsValidType(IType type)
		{
			return type.Kind != TypeKind.Unknown && type.Kind != TypeKind.Null && type.Kind != TypeKind.None;
		}

		bool PhaseTwo()
		{
			// C# 4.0 spec: 7.5.2.2 The second phase
			Log.WriteLine("Phase Two");
			// AllunfixedtypevariablesXiwhichdonotdependonanyXjarefixed.
			List<TP> typeParametersToFix = new List<TP>();
			foreach (TP Xi in typeParameters)
			{
				if (Xi.IsFixed == false)
				{
					if (!typeParameters.Any((TP Xj) => !Xj.IsFixed && DependsOn(Xi, Xj)))
					{
						typeParametersToFix.Add(Xi);
					}
				}
			}
			// Ifnosuchtypevariablesexist,allunfixedtypevariablesXiarefixedforwhichallofthefollowinghold:
			if (typeParametersToFix.Count == 0)
			{
				Log.WriteLine("Type parameters cannot be fixed due to dependency cycles");
				Log.WriteLine("Trying to break the cycle by fixing any TPs that have non-empty bounds...");
				foreach (TP Xi in typeParameters)
				{
					// Xihasanonemptysetofbounds
					if (!Xi.IsFixed && Xi.HasBounds)
					{
						// ThereisatleastonetypevariableXj thatdependsonXi
						if (typeParameters.Any((TP Xj) => DependsOn(Xj, Xi)))
						{
							typeParametersToFix.Add(Xi);
						}
					}
				}
			}
			// now fix 'em
			bool errorDuringFix = false;
			foreach (TP tp in typeParametersToFix)
			{
				if (!Fix(tp))
					errorDuringFix = true;
			}
			if (errorDuringFix)
				return false;
			bool unfixedTypeVariablesExist = typeParameters.Any((TP X) => X.IsFixed == false);
			if (typeParametersToFix.Count == 0 && unfixedTypeVariablesExist)
			{
				// Ifnosuchtypevariablesexistandtherearestillunfixedtypevariables,typeinferencefails.
				Log.WriteLine("Type inference fails: there are still unfixed TPs remaining");
				return false;
			}
			else if (!unfixedTypeVariablesExist)
			{
				// Otherwise,ifnofurtherunfixedtypevariablesexist,typeinferencesucceeds.
				return true;
			}
			else
			{
				// Otherwise,forallargumentseiwithcorrespondingparametertypeTi
				for (int i = 0; i < arguments.Length; i++)
				{
					ResolveResult Ei = arguments[i];
					IType Ti = parameterTypes[i];
					// wheretheoutputtypes(7.4.2.4)containunfixedtypevariablesXj
					// buttheinputtypes(7.4.2.3)donot
					if (OutputTypeContainsUnfixed(Ei, Ti) && !InputTypesContainsUnfixed(Ei, Ti))
					{
						// anoutputtypeinference(7.4.2.6)ismadeforeiwithtypeTi.
						Log.WriteLine("MakeOutputTypeInference for argument #" + i);
						MakeOutputTypeInference(Ei, Ti);
					}
				}
				// Thenthesecondphaseisrepeated.
				return PhaseTwo();
			}
		}
		#endregion

		#region Input Types / Output Types (7.5.2.3 + 7.5.2.4)
		IType[] InputTypes(ResolveResult e, IType t)
		{
			// C# 4.0 spec: 7.5.2.3 Input types
			LambdaResolveResult lrr = e as LambdaResolveResult;
			if (lrr != null && lrr.IsImplicitlyTyped || e is MethodGroupResolveResult)
			{
				IMethod m = GetDelegateOrExpressionTreeSignature(t);
				if (m != null)
				{
					IType[] inputTypes = new IType[m.Parameters.Count];
					for (int i = 0; i < inputTypes.Length; i++)
					{
						inputTypes[i] = m.Parameters[i].Type;
					}
					return inputTypes;
				}
			}
			return Empty<IType>.Array;
		}

		IType[] OutputTypes(ResolveResult e, IType t)
		{
			// C# 4.0 spec: 7.5.2.4 Output types
			LambdaResolveResult lrr = e as LambdaResolveResult;
			if (lrr != null || e is MethodGroupResolveResult)
			{
				IMethod m = GetDelegateOrExpressionTreeSignature(t);
				if (m != null)
				{
					return new[] { m.ReturnType };
				}
			}
			return Empty<IType>.Array;
		}

		static IMethod GetDelegateOrExpressionTreeSignature(IType t)
		{
			if (t.TypeParameterCount == 1 && t.Name == "Expression"
				&& t.Namespace == "System.Linq.Expressions")
			{
				t = t.TypeArguments[0];
			}
			return t.GetDelegateInvokeMethod();
		}

		bool InputTypesContainsUnfixed(ResolveResult argument, IType parameterType)
		{
			return AnyTypeContainsUnfixedParameter(InputTypes(argument, parameterType));
		}

		bool OutputTypeContainsUnfixed(ResolveResult argument, IType parameterType)
		{
			return AnyTypeContainsUnfixedParameter(OutputTypes(argument, parameterType));
		}

		bool AnyTypeContainsUnfixedParameter(IEnumerable<IType> types)
		{
			OccursInVisitor o = new OccursInVisitor(this);
			foreach (var type in types)
			{
				type.AcceptVisitor(o);
			}
			for (int i = 0; i < typeParameters.Length; i++)
			{
				if (!typeParameters[i].IsFixed && o.Occurs[i])
					return true;
			}
			return false;
		}
		#endregion

		#region DependsOn (7.5.2.5)
		// C# 4.0 spec: 7.5.2.5 Dependance

		void CalculateDependencyMatrix()
		{
			int n = typeParameters.Length;
			dependencyMatrix = new bool[n, n];
			for (int k = 0; k < arguments.Length; k++)
			{
				OccursInVisitor input = new OccursInVisitor(this);
				OccursInVisitor output = new OccursInVisitor(this);
				foreach (var type in InputTypes(arguments[k], parameterTypes[k]))
				{
					type.AcceptVisitor(input);
				}
				foreach (var type in OutputTypes(arguments[k], parameterTypes[k]))
				{
					type.AcceptVisitor(output);
				}
				for (int i = 0; i < n; i++)
				{
					for (int j = 0; j < n; j++)
					{
						dependencyMatrix[i, j] |= input.Occurs[j] && output.Occurs[i];
					}
				}
			}
			// calculate transitive closure using Warshall's algorithm:
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < n; j++)
				{
					if (dependencyMatrix[i, j])
					{
						for (int k = 0; k < n; k++)
						{
							if (dependencyMatrix[j, k])
								dependencyMatrix[i, k] = true;
						}
					}
				}
			}
		}

		bool DependsOn(TP x, TP y)
		{
			if (dependencyMatrix == null)
				CalculateDependencyMatrix();
			// x depends on y
			return dependencyMatrix[x.TypeParameter.Index, y.TypeParameter.Index];
		}
		#endregion

		#region MakeOutputTypeInference (7.5.2.6)
		void MakeOutputTypeInference(ResolveResult e, IType t)
		{
			Log.WriteLine(" MakeOutputTypeInference from " + e + " to " + t);
			// If E is an anonymous function with inferred return type  U (7.5.2.12) and T is a delegate type or expression
			// tree type with return type Tb, then a lower-bound inference (7.5.2.9) is made from U to Tb.
			LambdaResolveResult lrr = e as LambdaResolveResult;
			if (lrr != null)
			{
				IMethod m = GetDelegateOrExpressionTreeSignature(t);
				if (m != null)
				{
					IType inferredReturnType;
					if (lrr.IsImplicitlyTyped)
					{
						if (m.Parameters.Count != lrr.Parameters.Count)
							return; // cannot infer due to mismatched parameter lists
						TypeParameterSubstitution substitution = GetSubstitutionForFixedTPs();
						IType[] inferredParameterTypes = new IType[m.Parameters.Count];
						for (int i = 0; i < inferredParameterTypes.Length; i++)
						{
							IType parameterType = m.Parameters[i].Type;
							inferredParameterTypes[i] = parameterType.AcceptVisitor(substitution);
						}
						inferredReturnType = lrr.GetInferredReturnType(inferredParameterTypes);
					}
					else
					{
						inferredReturnType = lrr.GetInferredReturnType(null);
					}
					MakeLowerBoundInference(inferredReturnType, m.ReturnType);
					return;
				}
			}
			// Otherwise,ifEisamethodgroupandTisadelegatetypeorexpressiontreetype
			// with parametertypesT1TkandreturntypeTb,andoverloadresolution
			// ofEwiththetypesT1Tkyieldsasingle methodwithreturntypeU,thenalower-bound
			// inferenceismadefromUto Tb.
			MethodGroupResolveResult mgrr = e as MethodGroupResolveResult;
			if (mgrr != null)
			{
				IMethod m = GetDelegateOrExpressionTreeSignature(t);
				if (m != null)
				{
					ResolveResult[] args = new ResolveResult[m.Parameters.Count];
					TypeParameterSubstitution substitution = GetSubstitutionForFixedTPs();
					for (int i = 0; i < args.Length; i++)
					{
						IParameter param = m.Parameters[i];
						IType parameterType = param.Type.AcceptVisitor(substitution);
						if ((param.ReferenceKind != ReferenceKind.None) && parameterType.Kind == TypeKind.ByReference)
						{
							parameterType = ((ByReferenceType)parameterType).ElementType;
							args[i] = new ByReferenceResolveResult(parameterType, param.ReferenceKind);
						}
						else
						{
							args[i] = new ResolveResult(parameterType);
						}
					}
					var or = mgrr.PerformOverloadResolution(
						compilation, args,
						allowExpandingParams: false,
						allowOptionalParameters: false,
						allowImplicitIn: false
					);
					if (or.FoundApplicableCandidate && or.BestCandidateAmbiguousWith == null)
					{
						IType returnType = or.GetBestCandidateWithSubstitutedTypeArguments().ReturnType;
						MakeLowerBoundInference(returnType, m.ReturnType);
					}
				}
				return;
			}
			// Otherwise, if E is an expression with type U, then a lower-bound inference is made from U to T.
			if (IsValidType(e.Type))
			{
				MakeLowerBoundInference(e.Type, t);
			}
		}

		TypeParameterSubstitution GetSubstitutionForFixedTPs()
		{
			IType[] fixedTypes = new IType[typeParameters.Length];
			for (int i = 0; i < fixedTypes.Length; i++)
			{
				fixedTypes[i] = typeParameters[i].FixedTo ?? SpecialType.UnknownType;
			}
			return new TypeParameterSubstitution(classTypeArguments, fixedTypes);
		}
		#endregion

		#region MakeExplicitParameterTypeInference (7.5.2.7)
		void MakeExplicitParameterTypeInference(LambdaResolveResult e, IType t)
		{
			// C# 4.0 spec: 7.5.2.7 Explicit parameter type inferences
			if (e.IsImplicitlyTyped || !e.HasParameterList)
				return;
			Log.WriteLine(" MakeExplicitParameterTypeInference from " + e + " to " + t);
			IMethod m = GetDelegateOrExpressionTreeSignature(t);
			if (m == null)
				return;
			for (int i = 0; i < e.Parameters.Count && i < m.Parameters.Count; i++)
			{
				MakeExactInference(e.Parameters[i].Type, m.Parameters[i].Type);
			}
		}
		#endregion

		#region MakeExactInference (7.5.2.8)
		/// <summary>
		/// Make exact inference from U to V.
		/// C# 4.0 spec: 7.5.2.8 Exact inferences
		/// </summary>
		void MakeExactInference(IType U, IType V)
		{
			Log.WriteLine("MakeExactInference from " + U + " to " + V);

			if (U.Nullability == V.Nullability)
			{
				U = U.WithoutNullability();
				V = V.WithoutNullability();
			}

			// IfVisoneoftheunfixedXithenUisaddedtothesetofboundsforXi.
			TP tp = GetTPForType(V);
			if (tp != null && tp.IsFixed == false)
			{
				Log.WriteLine(" Add exact bound '" + U + "' to " + tp);
				tp.AddExactBound(U);
				return;
			}
			// Handle by reference types:
			ByReferenceType brU = U as ByReferenceType;
			ByReferenceType brV = V as ByReferenceType;
			if (brU != null && brV != null)
			{
				MakeExactInference(brU.ElementType, brV.ElementType);
				return;
			}
			// Handle array types:
			ArrayType arrU = U as ArrayType;
			ArrayType arrV = V as ArrayType;
			if (arrU != null && arrV != null && arrU.Dimensions == arrV.Dimensions)
			{
				MakeExactInference(arrU.ElementType, arrV.ElementType);
				return;
			}
			// Handle parameterized type:
			ParameterizedType pU = U.TupleUnderlyingTypeOrSelf() as ParameterizedType;
			ParameterizedType pV = V.TupleUnderlyingTypeOrSelf() as ParameterizedType;
			if (pU != null && pV != null
				&& object.Equals(pU.GenericType, pV.GenericType)
				&& pU.TypeParameterCount == pV.TypeParameterCount)
			{
				Log.Indent();
				for (int i = 0; i < pU.TypeParameterCount; i++)
				{
					MakeExactInference(pU.GetTypeArgument(i), pV.GetTypeArgument(i));
				}
				Log.Unindent();
				return;
			}
			// Handle pointer types:
			if (U is PointerType ptrU && V is PointerType ptrV)
			{
				MakeExactInference(ptrU.ElementType, ptrV.ElementType);
				return;
			}
			if (U is FunctionPointerType fnPtrU && V is FunctionPointerType fnPtrV)
			{
				MakeExactInference(fnPtrU.ReturnType, fnPtrV.ReturnType);
				foreach (var (ptU, ptV) in fnPtrU.ParameterTypes.Zip(fnPtrV.ParameterTypes))
				{
					MakeExactInference(ptU, ptV);
				}
				return;
			}
		}

		TP GetTPForType(IType v)
		{
			if (v is NullabilityAnnotatedTypeParameter natp)
			{
				v = natp.OriginalTypeParameter;
			}
			if (v is ITypeParameter p)
			{
				int index = p.Index;
				if (index < typeParameters.Length && typeParameters[index].TypeParameter == p)
					return typeParameters[index];
			}
			return null;
		}
		#endregion

		#region MakeLowerBoundInference (7.5.2.9)
		/// <summary>
		/// Make lower bound inference from U to V.
		/// C# 4.0 spec: 7.5.2.9 Lower-bound inferences
		/// </summary>
		void MakeLowerBoundInference(IType U, IType V)
		{
			Log.WriteLine(" MakeLowerBoundInference from " + U + " to " + V);
			if (U.Nullability == V.Nullability)
			{
				U = U.WithoutNullability();
				V = V.WithoutNullability();
			}

			// IfVisoneoftheunfixedXithenUisaddedtothesetofboundsforXi.
			TP tp = GetTPForType(V);
			if (tp != null && tp.IsFixed == false)
			{
				Log.WriteLine("  Add lower bound '" + U + "' to " + tp);
				tp.LowerBounds.Add(U);
				return;
			}
			// Handle nullable covariance:
			if (NullableType.IsNullable(U) && NullableType.IsNullable(V))
			{
				MakeLowerBoundInference(NullableType.GetUnderlyingType(U), NullableType.GetUnderlyingType(V));
				return;
			}
			// Handle by reference types:
			ByReferenceType brU = U as ByReferenceType;
			ByReferenceType brV = V as ByReferenceType;
			if (brU != null && brV != null)
			{
				MakeExactInference(brU.ElementType, brV.ElementType);
				return;
			}
			// Handle array types:
			ArrayType arrU = U as ArrayType;
			ArrayType arrV = V as ArrayType;
			ParameterizedType pV = V.TupleUnderlyingTypeOrSelf() as ParameterizedType;
			if (arrU != null && arrV != null && arrU.Dimensions == arrV.Dimensions)
			{
				MakeLowerBoundInference(arrU.ElementType, arrV.ElementType);
				return;
			}
			else if (arrU != null && IsGenericInterfaceImplementedByArray(pV) && arrU.Dimensions == 1)
			{
				MakeLowerBoundInference(arrU.ElementType, pV.GetTypeArgument(0));
				return;
			}
			// Handle parameterized types:
			if (pV != null)
			{
				ParameterizedType uniqueBaseType = null;
				foreach (IType baseU in U.GetAllBaseTypes())
				{
					ParameterizedType pU = baseU.TupleUnderlyingTypeOrSelf() as ParameterizedType;
					if (pU != null && object.Equals(pU.GenericType, pV.GenericType) && pU.TypeParameterCount == pV.TypeParameterCount)
					{
						if (uniqueBaseType == null)
							uniqueBaseType = pU;
						else
							return; // cannot make an inference because it's not unique
					}
				}
				Log.Indent();
				if (uniqueBaseType != null)
				{
					for (int i = 0; i < uniqueBaseType.TypeParameterCount; i++)
					{
						IType Ui = uniqueBaseType.GetTypeArgument(i);
						IType Vi = pV.GetTypeArgument(i);
						if (Ui.IsReferenceType == true)
						{
							// look for variance
							ITypeParameter Xi = pV.TypeParameters[i];
							switch (Xi.Variance)
							{
								case VarianceModifier.Covariant:
									MakeLowerBoundInference(Ui, Vi);
									break;
								case VarianceModifier.Contravariant:
									MakeUpperBoundInference(Ui, Vi);
									break;
								default: // invariant
									MakeExactInference(Ui, Vi);
									break;
							}
						}
						else
						{
							// not known to be a reference type
							MakeExactInference(Ui, Vi);
						}
					}
				}
				Log.Unindent();
				return;
			}
			// Handle pointer types:
			if (U is PointerType ptrU && V is PointerType ptrV)
			{
				MakeExactInference(ptrU.ElementType, ptrV.ElementType);
				return;
			}
			if (U is FunctionPointerType fnPtrU && V is FunctionPointerType fnPtrV)
			{
				MakeLowerBoundInference(fnPtrU.ReturnType, fnPtrV.ReturnType);
				foreach (var (ptU, ptV) in fnPtrU.ParameterTypes.Zip(fnPtrV.ParameterTypes))
				{
					MakeUpperBoundInference(ptU, ptV);
				}
				return;
			}
		}

		static bool IsGenericInterfaceImplementedByArray(ParameterizedType rt)
		{
			if (rt == null || rt.TypeParameterCount != 1)
				return false;
			switch (rt.GetDefinition()?.KnownTypeCode)
			{
				case KnownTypeCode.IEnumerableOfT:
				case KnownTypeCode.ICollectionOfT:
				case KnownTypeCode.IListOfT:
				case KnownTypeCode.IReadOnlyCollectionOfT:
				case KnownTypeCode.IReadOnlyListOfT:
					return true;
				default:
					return false;
			}
		}
		#endregion

		#region MakeUpperBoundInference (7.5.2.10)
		/// <summary>
		/// Make upper bound inference from U to V.
		/// C# 4.0 spec: 7.5.2.10 Upper-bound inferences
		/// </summary>
		void MakeUpperBoundInference(IType U, IType V)
		{
			Log.WriteLine(" MakeUpperBoundInference from " + U + " to " + V);
			if (U.Nullability == V.Nullability)
			{
				U = U.WithoutNullability();
				V = V.WithoutNullability();
			}

			// IfVisoneoftheunfixedXithenUisaddedtothesetofboundsforXi.
			TP tp = GetTPForType(V);
			if (tp != null && tp.IsFixed == false)
			{
				Log.WriteLine("  Add upper bound '" + U + "' to " + tp);
				tp.UpperBounds.Add(U);
				return;
			}

			// Handle array types:
			ArrayType arrU = U as ArrayType;
			ArrayType arrV = V as ArrayType;
			ParameterizedType pU = U.TupleUnderlyingTypeOrSelf() as ParameterizedType;
			if (arrV != null && arrU != null && arrU.Dimensions == arrV.Dimensions)
			{
				MakeUpperBoundInference(arrU.ElementType, arrV.ElementType);
				return;
			}
			else if (arrV != null && IsGenericInterfaceImplementedByArray(pU) && arrV.Dimensions == 1)
			{
				MakeUpperBoundInference(pU.GetTypeArgument(0), arrV.ElementType);
				return;
			}
			// Handle parameterized types:
			if (pU != null)
			{
				ParameterizedType uniqueBaseType = null;
				foreach (IType baseV in V.GetAllBaseTypes())
				{
					ParameterizedType pV = baseV.TupleUnderlyingTypeOrSelf() as ParameterizedType;
					if (pV != null && object.Equals(pU.GenericType, pV.GenericType) && pU.TypeParameterCount == pV.TypeParameterCount)
					{
						if (uniqueBaseType == null)
							uniqueBaseType = pV;
						else
							return; // cannot make an inference because it's not unique
					}
				}
				Log.Indent();
				if (uniqueBaseType != null)
				{
					for (int i = 0; i < uniqueBaseType.TypeParameterCount; i++)
					{
						IType Ui = pU.GetTypeArgument(i);
						IType Vi = uniqueBaseType.GetTypeArgument(i);
						if (Ui.IsReferenceType == true)
						{
							// look for variance
							ITypeParameter Xi = pU.TypeParameters[i];
							switch (Xi.Variance)
							{
								case VarianceModifier.Covariant:
									MakeUpperBoundInference(Ui, Vi);
									break;
								case VarianceModifier.Contravariant:
									MakeLowerBoundInference(Ui, Vi);
									break;
								default: // invariant
									MakeExactInference(Ui, Vi);
									break;
							}
						}
						else
						{
							// not known to be a reference type
							MakeExactInference(Ui, Vi);
						}
					}
				}
				Log.Unindent();
				return;
			}
			// Handle pointer types:
			if (U is PointerType ptrU && V is PointerType ptrV)
			{
				MakeExactInference(ptrU.ElementType, ptrV.ElementType);
				return;
			}
			if (U is FunctionPointerType fnPtrU && V is FunctionPointerType fnPtrV)
			{
				MakeUpperBoundInference(fnPtrU.ReturnType, fnPtrV.ReturnType);
				foreach (var (ptU, ptV) in fnPtrU.ParameterTypes.Zip(fnPtrV.ParameterTypes))
				{
					MakeLowerBoundInference(ptU, ptV);
				}
				return;
			}
		}
		#endregion

		#region Fixing (7.5.2.11)
		bool Fix(TP tp)
		{
			Log.WriteLine(" Trying to fix " + tp);
			Debug.Assert(!tp.IsFixed);
			if (tp.ExactBound != null)
			{
				// the exact bound will always be the result
				tp.FixedTo = tp.ExactBound;
				// check validity
				if (tp.MultipleDifferentExactBounds)
					return false;
				return tp.LowerBounds.All(b => conversions.ImplicitConversion(b, tp.FixedTo).IsValid)
					&& tp.UpperBounds.All(b => conversions.ImplicitConversion(tp.FixedTo, b).IsValid);
			}
			Log.Indent();
			var types = CreateNestedInstance().FindTypesInBounds(tp.LowerBounds.ToArray(), tp.UpperBounds.ToArray());
			Log.Unindent();
			if (algorithm == TypeInferenceAlgorithm.ImprovedReturnAllResults)
			{
				tp.FixedTo = IntersectionType.Create(types);
				Log.WriteLine("  T was fixed " + (types.Count >= 1 ? "successfully" : "(with errors)") + " to " + tp.FixedTo);
				return types.Count >= 1;
			}
			else
			{
				tp.FixedTo = GetFirstTypePreferNonInterfaces(types);
				Log.WriteLine("  T was fixed " + (types.Count == 1 ? "successfully" : "(with errors)") + " to " + tp.FixedTo);
				return types.Count == 1;
			}
		}
		#endregion

		#region Finding the best common type of a set of expresssions
		/// <summary>
		/// Gets the best common type (C# 4.0 spec: 7.5.2.14) of a set of expressions.
		/// </summary>
		public IType GetBestCommonType(IList<ResolveResult> expressions, out bool success)
		{
			if (expressions == null)
				throw new ArgumentNullException(nameof(expressions));
			if (expressions.Count == 1)
			{
				success = IsValidType(expressions[0].Type);
				return expressions[0].Type;
			}
			Log.WriteCollection("GetBestCommonType() for ", expressions);
			try
			{
				ITypeParameter tp = DummyTypeParameter.GetMethodTypeParameter(0);
				this.typeParameters = new TP[1] { new TP(tp) };
				foreach (ResolveResult r in expressions)
				{
					MakeOutputTypeInference(r, tp);
				}
				success = Fix(typeParameters[0]);
				return typeParameters[0].FixedTo ?? SpecialType.UnknownType;
			}
			finally
			{
				Reset();
			}
		}
		#endregion

		#region FindTypeInBounds
		/// <summary>
		/// Finds a type that satisfies the given lower and upper bounds.
		/// </summary>
		public IType FindTypeInBounds(IReadOnlyList<IType> lowerBounds, IReadOnlyList<IType> upperBounds)
		{
			if (lowerBounds == null)
				throw new ArgumentNullException(nameof(lowerBounds));
			if (upperBounds == null)
				throw new ArgumentNullException(nameof(upperBounds));

			var result = FindTypesInBounds(lowerBounds, upperBounds);

			if (algorithm == TypeInferenceAlgorithm.ImprovedReturnAllResults)
			{
				return IntersectionType.Create(result);
			}
			else
			{
				// return any of the candidates (prefer non-interfaces)
				return GetFirstTypePreferNonInterfaces(result);
			}
		}

		static IType GetFirstTypePreferNonInterfaces(IReadOnlyList<IType> result)
		{
			return result.FirstOrDefault(c => c.Kind != TypeKind.Interface)
				?? result.FirstOrDefault() ?? SpecialType.UnknownType;
		}

		IReadOnlyList<IType> FindTypesInBounds(IReadOnlyList<IType> lowerBounds, IReadOnlyList<IType> upperBounds)
		{
			// If there's only a single type; return that single type.
			// If both inputs are empty, return the empty list.
			if (lowerBounds.Count == 0 && upperBounds.Count <= 1)
				return upperBounds;
			if (upperBounds.Count == 0 && lowerBounds.Count <= 1)
				return lowerBounds;
			if (nestingLevel > maxNestingLevel)
				return EmptyList<IType>.Instance;

			// Finds a type X so that "LB <: X <: UB"
			Log.WriteCollection("FindTypesInBound, LowerBounds=", lowerBounds);
			Log.WriteCollection("FindTypesInBound, UpperBounds=", upperBounds);

			// First try the Fixing algorithm from the C# spec (7.5.2.11)
			List<IType> candidateTypes = lowerBounds.Union(upperBounds)
				.Where(c => lowerBounds.All(b => conversions.ImplicitConversion(b, c).IsValid))
				.Where(c => upperBounds.All(b => conversions.ImplicitConversion(c, b).IsValid))
				.ToList(); // evaluate the query only once

			Log.WriteCollection("FindTypesInBound, Candidates=", candidateTypes);

			// According to the C# specification, we need to pick the most specific
			// of the candidate types. (the type which has conversions to all others)
			// However, csc actually seems to choose the least specific.
			candidateTypes = candidateTypes.Where(
				c => candidateTypes.All(o => conversions.ImplicitConversion(o, c).IsValid)
			).ToList();

			// If the specified algorithm produces a single candidate, we return
			// that candidate.
			// We also return the whole candidate list if we're not using the improved
			// algorithm.
			if (candidateTypes.Count == 1 || !(algorithm == TypeInferenceAlgorithm.Improved || algorithm == TypeInferenceAlgorithm.ImprovedReturnAllResults))
			{
				return candidateTypes;
			}
			candidateTypes.Clear();

			// Now try the improved algorithm
			Log.Indent();
			List<ITypeDefinition> candidateTypeDefinitions;
			if (lowerBounds.Count > 0)
			{
				// Find candidates by using the lower bounds:
				var hashSet = new HashSet<ITypeDefinition>(lowerBounds[0].GetAllBaseTypeDefinitions());
				for (int i = 1; i < lowerBounds.Count; i++)
				{
					hashSet.IntersectWith(lowerBounds[i].GetAllBaseTypeDefinitions());
				}
				candidateTypeDefinitions = hashSet.ToList();
			}
			else
			{
				// Find candidates by looking at all classes in the project:
				candidateTypeDefinitions = compilation.GetAllTypeDefinitions().ToList();
			}

			// Now filter out candidates that violate the upper bounds:
			foreach (IType ub in upperBounds)
			{
				ITypeDefinition ubDef = ub.GetDefinition();
				if (ubDef != null)
				{
					candidateTypeDefinitions.RemoveAll(c => !c.IsDerivedFrom(ubDef));
				}
			}

			foreach (ITypeDefinition candidateDef in candidateTypeDefinitions)
			{
				// determine the type parameters for the candidate:
				IType candidate;
				if (candidateDef.TypeParameterCount == 0)
				{
					candidate = candidateDef;
				}
				else
				{
					Log.WriteLine("Inferring arguments for candidate type definition: " + candidateDef);
					bool success;
					IType[] result = InferTypeArgumentsFromBounds(
						candidateDef.TypeParameters,
						new ParameterizedType(candidateDef, candidateDef.TypeParameters),
						lowerBounds, upperBounds,
						out success);
					if (success)
					{
						candidate = new ParameterizedType(candidateDef, result);
					}
					else
					{
						Log.WriteLine("Inference failed; ignoring candidate");
						continue;
					}
				}
				Log.WriteLine("Candidate type: " + candidate);

				if (upperBounds.Count == 0)
				{
					// if there were only lower bounds, we aim for the most specific candidate:

					// if this candidate isn't made redundant by an existing, more specific candidate:
					if (!candidateTypes.Any(c => c.GetDefinition().IsDerivedFrom(candidateDef)))
					{
						// remove all existing candidates made redundant by this candidate:
						candidateTypes.RemoveAll(c => candidateDef.IsDerivedFrom(c.GetDefinition()));
						// add new candidate
						candidateTypes.Add(candidate);
					}
				}
				else
				{
					// if there were upper bounds, we aim for the least specific candidate:

					// if this candidate isn't made redundant by an existing, less specific candidate:
					if (!candidateTypes.Any(c => candidateDef.IsDerivedFrom(c.GetDefinition())))
					{
						// remove all existing candidates made redundant by this candidate:
						candidateTypes.RemoveAll(c => c.GetDefinition().IsDerivedFrom(candidateDef));
						// add new candidate
						candidateTypes.Add(candidate);
					}
				}
			}
			Log.Unindent();
			return candidateTypes;
		}
		#endregion
	}
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\TransformFieldAndConstructorInitializers.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq;

using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching;
using ICSharpCode.Decompiler.TypeSystem;

using SRM = System.Reflection.Metadata;

namespace ICSharpCode.Decompiler.CSharp.Transforms
{
	/// <summary>
	/// This transform moves field initializers at the start of constructors to their respective field declarations
	/// and transforms this-/base-ctor calls in constructors to constructor initializers.
	/// </summary>
	public class TransformFieldAndConstructorInitializers : DepthFirstAstVisitor, IAstTransform
	{
		TransformContext context;

		public void Run(AstNode node, TransformContext context)
		{
			this.context = context;

			try
			{
				// If we're viewing some set of members (fields are direct children of SyntaxTree),
				// we also need to handle those:
				HandleInstanceFieldInitializers(node.Children);
				HandleStaticFieldInitializers(node.Children);

				node.AcceptVisitor(this);

				RemoveSingleEmptyConstructor(node.Children, context.CurrentTypeDefinition);
			}
			finally
			{
				this.context = null;
			}
		}

		public override void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration)
		{
			if (!(constructorDeclaration.Body.Statements.FirstOrDefault() is ExpressionStatement stmt))
				return;
			var currentCtor = (IMethod)constructorDeclaration.GetSymbol();
			ConstructorInitializer ci;
			switch (stmt.Expression)
			{
				// Pattern for reference types:
				// this..ctor(...);
				case InvocationExpression invocation:
					if (!(invocation.Target is MemberReferenceExpression mre) || mre.MemberName != ".ctor")
						return;
					if (!(invocation.GetSymbol() is IMethod ctor && ctor.IsConstructor))
						return;
					ci = new ConstructorInitializer();
					var target = mre.Target;
					// Ignore casts, those might be added if references are missing.
					if (target is CastExpression cast)
						target = cast.Expression;
					if (target is ThisReferenceExpression)
						ci.ConstructorInitializerType = ConstructorInitializerType.This;
					else if (target is BaseReferenceExpression)
						ci.ConstructorInitializerType = ConstructorInitializerType.Base;
					else
						return;
					// Move arguments from invocation to initializer:
					invocation.Arguments.MoveTo(ci.Arguments);
					// Add the initializer: (unless it is the default 'base()')
					if (!(ci.ConstructorInitializerType == ConstructorInitializerType.Base && ci.Arguments.Count == 0))
						constructorDeclaration.Initializer = ci.CopyAnnotationsFrom(invocation);
					// Remove the statement:
					stmt.Remove();
					break;
				// Pattern for value types:
				// this = new TSelf(...);
				case AssignmentExpression assignment:
					if (!(assignment.Right is ObjectCreateExpression oce && oce.GetSymbol() is IMethod ctor2 && ctor2.DeclaringTypeDefinition == currentCtor.DeclaringTypeDefinition))
						return;
					ci = new ConstructorInitializer();
					if (assignment.Left is ThisReferenceExpression)
						ci.ConstructorInitializerType = ConstructorInitializerType.This;
					else
						return;
					// Move arguments from invocation to initializer:
					oce.Arguments.MoveTo(ci.Arguments);
					// Add the initializer: (unless it is the default 'base()')
					if (!(ci.ConstructorInitializerType == ConstructorInitializerType.Base && ci.Arguments.Count == 0))
						constructorDeclaration.Initializer = ci.CopyAnnotationsFrom(oce);
					// Remove the statement:
					stmt.Remove();
					break;
				default:
					return;
			}
			if (context.DecompileRun.RecordDecompilers.TryGetValue(currentCtor.DeclaringTypeDefinition, out var record)
				&& currentCtor.Equals(record.PrimaryConstructor)
				&& ci.ConstructorInitializerType == ConstructorInitializerType.Base)
			{
				if (constructorDeclaration.Parent is TypeDeclaration { BaseTypes: { Count: >= 1 } } typeDecl)
				{
					var baseType = typeDecl.BaseTypes.First();
					var newBaseType = new InvocationAstType();
					baseType.ReplaceWith(newBaseType);
					newBaseType.BaseType = baseType;
					ci.Arguments.MoveTo(newBaseType.Arguments);
				}
				constructorDeclaration.Remove();
			}
		}

		static readonly ExpressionStatement fieldInitializerPattern = new ExpressionStatement {
			Expression = new AssignmentExpression {
				Left = new Choice {
					new NamedNode("fieldAccess", new MemberReferenceExpression {
										 Target = new ThisReferenceExpression(),
										 MemberName = Pattern.AnyString
									 }),
					new NamedNode("fieldAccess", new IdentifierExpression(Pattern.AnyString))
				},
				Operator = AssignmentOperatorType.Assign,
				Right = new AnyNode("initializer")
			}
		};

		static readonly AstNode thisCallPattern = new ExpressionStatement(new InvocationExpression(new MemberReferenceExpression(new ThisReferenceExpression(), ".ctor"), new Repeat(new AnyNode())));

		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			// Handle initializers on instance fields
			HandleInstanceFieldInitializers(typeDeclaration.Members);

			// Now convert base constructor calls to initializers:
			base.VisitTypeDeclaration(typeDeclaration);

			// Remove single empty constructor:
			RemoveSingleEmptyConstructor(typeDeclaration.Members, (ITypeDefinition)typeDeclaration.GetSymbol());

			// Handle initializers on static fields:
			HandleStaticFieldInitializers(typeDeclaration.Members);
		}

		void HandleInstanceFieldInitializers(IEnumerable<AstNode> members)
		{
			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray();
			var instanceCtorsNotChainingWithThis = instanceCtors.Where(ctor => !thisCallPattern.IsMatch(ctor.Body.Statements.FirstOrDefault())).ToArray();
			if (instanceCtorsNotChainingWithThis.Length > 0)
			{
				var ctorMethodDef = instanceCtorsNotChainingWithThis[0].GetSymbol() as IMethod;
				if (ctorMethodDef != null && ctorMethodDef.DeclaringType.IsReferenceType == false)
					return;

				bool ctorIsUnsafe = instanceCtorsNotChainingWithThis.All(c => c.HasModifier(Modifiers.Unsafe));

				if (!context.DecompileRun.RecordDecompilers.TryGetValue(ctorMethodDef.DeclaringTypeDefinition, out var record))
					record = null;

				// Recognize field or property initializers:
				// Translate first statement in all ctors (if all ctors have the same statement) into an initializer.
				bool allSame;
				do
				{
					Match m = fieldInitializerPattern.Match(instanceCtorsNotChainingWithThis[0].Body.FirstOrDefault());
					if (!m.Success)
						break;
					IMember fieldOrPropertyOrEvent = (m.Get<AstNode>("fieldAccess").Single().GetSymbol() as IMember)?.MemberDefinition;
					if (!(fieldOrPropertyOrEvent is IField) && !(fieldOrPropertyOrEvent is IProperty) && !(fieldOrPropertyOrEvent is IEvent))
						break;
					var fieldOrPropertyOrEventDecl = members.FirstOrDefault(f => f.GetSymbol() == fieldOrPropertyOrEvent) as EntityDeclaration;
					// Cannot transform if it is a custom event.
					if (fieldOrPropertyOrEventDecl is CustomEventDeclaration)
						break;


					Expression initializer = m.Get<Expression>("initializer").Single();
					// 'this'/'base' cannot be used in initializers
					if (initializer.DescendantsAndSelf.Any(n => n is ThisReferenceExpression || n is BaseReferenceExpression))
						break;

					if (initializer.Annotation<ILVariableResolveResult>()?.Variable.Kind == IL.VariableKind.Parameter)
					{
						// remove record ctor parameter assignments
						if (IsPropertyDeclaredByPrimaryCtor(fieldOrPropertyOrEvent as IProperty, record))
							initializer.Remove();
						else
							break;
					}
					else
					{
						// cannot transform if member is not found
						if (fieldOrPropertyOrEventDecl == null)
							break;
					}

					allSame = true;
					for (int i = 1; i < instanceCtorsNotChainingWithThis.Length; i++)
					{
						var otherMatch = fieldInitializerPattern.Match(instanceCtorsNotChainingWithThis[i].Body.FirstOrDefault());
						if (!otherMatch.Success)
						{
							allSame = false;
							break;
						}
						var otherMember = (otherMatch.Get<AstNode>("fieldAccess").Single().GetSymbol() as IMember)?.MemberDefinition;
						if (!otherMember.Equals(fieldOrPropertyOrEvent))
							allSame = false;
						if (!initializer.IsMatch(otherMatch.Get<AstNode>("initializer").Single()))
							allSame = false;
					}
					if (allSame)
					{
						foreach (var ctor in instanceCtorsNotChainingWithThis)
							ctor.Body.First().Remove();
						if (fieldOrPropertyOrEventDecl == null)
							continue;
						if (ctorIsUnsafe && IntroduceUnsafeModifier.IsUnsafe(initializer))
						{
							fieldOrPropertyOrEventDecl.Modifiers |= Modifiers.Unsafe;
						}
						if (fieldOrPropertyOrEventDecl is PropertyDeclaration pd)
						{
							pd.Initializer = initializer.Detach();
						}
						else
						{
							fieldOrPropertyOrEventDecl.GetChildrenByRole(Roles.Variable).Single().Initializer = initializer.Detach();
						}
					}
				} while (allSame);
			}
		}

		bool IsPropertyDeclaredByPrimaryCtor(IProperty p, RecordDecompiler record)
		{
			if (p == null || record == null)
				return false;
			return record.IsPropertyDeclaredByPrimaryConstructor(p);
		}

		void RemoveSingleEmptyConstructor(IEnumerable<AstNode> members, ITypeDefinition contextTypeDefinition)
		{
			// if we're outside of a type definition skip this altogether
			if (contextTypeDefinition == null)
				return;
			// first get non-static constructor declarations from the AST
			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray();
			// if there's exactly one ctor and it's part of a type declaration or there's more than one member in the current selection
			// we can remove the constructor. (We do not want to hide the constructor if the user explicitly selected it in the tree view.) 
			if (instanceCtors.Length == 1 && (instanceCtors[0].Parent is TypeDeclaration || members.Skip(1).Any()))
			{
				var ctor = instanceCtors[0];
				// dynamically create a pattern of an empty ctor
				ConstructorDeclaration emptyCtorPattern = new ConstructorDeclaration();
				emptyCtorPattern.Modifiers = contextTypeDefinition.IsAbstract ? Modifiers.Protected : Modifiers.Public;
				if (ctor.HasModifier(Modifiers.Unsafe))
					emptyCtorPattern.Modifiers |= Modifiers.Unsafe;
				emptyCtorPattern.Body = new BlockStatement();

				if (emptyCtorPattern.IsMatch(ctor))
				{
					bool retainBecauseOfDocumentation = ctor.GetSymbol() is IMethod ctorMethod
						&& context.Settings.ShowXmlDocumentation
						&& context.DecompileRun.DocumentationProvider?.GetDocumentation(ctorMethod) != null;
					if (!retainBecauseOfDocumentation)
						ctor.Remove();
				}
			}
		}

		void HandleStaticFieldInitializers(IEnumerable<AstNode> members)
		{
			// Translate static constructor into field initializers if the class is BeforeFieldInit
			var staticCtor = members.OfType<ConstructorDeclaration>().FirstOrDefault(c => (c.Modifiers & Modifiers.Static) == Modifiers.Static);
			if (staticCtor != null)
			{
				bool ctorIsUnsafe = staticCtor.HasModifier(Modifiers.Unsafe);
				IMethod ctorMethod = staticCtor.GetSymbol() as IMethod;
				if (!ctorMethod.MetadataToken.IsNil)
				{
					var metadata = context.TypeSystem.MainModule.PEFile.Metadata;
					SRM.MethodDefinition ctorMethodDef = metadata.GetMethodDefinition((SRM.MethodDefinitionHandle)ctorMethod.MetadataToken);
					SRM.TypeDefinition declaringType = metadata.GetTypeDefinition(ctorMethodDef.GetDeclaringType());
					if (declaringType.HasFlag(System.Reflection.TypeAttributes.BeforeFieldInit))
					{
						while (true)
						{
							ExpressionStatement es = staticCtor.Body.Statements.FirstOrDefault() as ExpressionStatement;
							if (es == null)
								break;
							AssignmentExpression assignment = es.Expression as AssignmentExpression;
							if (assignment == null || assignment.Operator != AssignmentOperatorType.Assign)
								break;
							IMember fieldOrProperty = (assignment.Left.GetSymbol() as IMember)?.MemberDefinition;
							if (!(fieldOrProperty is IField || fieldOrProperty is IProperty) || !fieldOrProperty.IsStatic)
								break;
							var fieldOrPropertyDecl = members.FirstOrDefault(f => f.GetSymbol() == fieldOrProperty) as EntityDeclaration;
							if (fieldOrPropertyDecl == null)
								break;
							if (ctorIsUnsafe && IntroduceUnsafeModifier.IsUnsafe(assignment.Right))
							{
								fieldOrPropertyDecl.Modifiers |= Modifiers.Unsafe;
							}
							if (fieldOrPropertyDecl is FieldDeclaration fd)
								fd.Variables.Single().Initializer = assignment.Right.Detach();
							else if (fieldOrPropertyDecl is PropertyDeclaration pd)
								pd.Initializer = assignment.Right.Detach();
							else
								break;
							es.Remove();
						}
						if (staticCtor.Body.Statements.Count == 0)
							staticCtor.Remove();
					}
				}
			}
		}
	}
}

---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq;

using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching;
using ICSharpCode.Decompiler.TypeSystem;

using SRM = System.Reflection.Metadata;

namespace ICSharpCode.Decompiler.CSharp.Transforms
{
	/// <summary>
	/// This transform moves field initializers at the start of constructors to their respective field declarations
	/// and transforms this-/base-ctor calls in constructors to constructor initializers.
	/// </summary>
	public class TransformFieldAndConstructorInitializers : DepthFirstAstVisitor, IAstTransform
	{
		TransformContext context;

		public void Run(AstNode node, TransformContext context)
		{
			this.context = context;

			try
			{
				// If we're viewing some set of members (fields are direct children of SyntaxTree),
				// we also need to handle those:
				HandleInstanceFieldInitializers(node.Children);
				HandleStaticFieldInitializers(node.Children);

				node.AcceptVisitor(this);

				RemoveSingleEmptyConstructor(node.Children, context.CurrentTypeDefinition);
			}
			finally
			{
				this.context = null;
			}
		}

		public override void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration)
		{
			if (!(constructorDeclaration.Body.Statements.FirstOrDefault() is ExpressionStatement stmt))
				return;
			var currentCtor = (IMethod)constructorDeclaration.GetSymbol();
			ConstructorInitializer ci;
			switch (stmt.Expression)
			{
				// Pattern for reference types:
				// this..ctor(...);
				case InvocationExpression invocation:
					if (!(invocation.Target is MemberReferenceExpression mre) || mre.MemberName != ".ctor")
						return;
					if (!(invocation.GetSymbol() is IMethod ctor && ctor.IsConstructor))
						return;
					ci = new ConstructorInitializer();
					var target = mre.Target;
					// Ignore casts, those might be added if references are missing.
					if (target is CastExpression cast)
						target = cast.Expression;
					if (target is ThisReferenceExpression)
						ci.ConstructorInitializerType = ConstructorInitializerType.This;
					else if (target is BaseReferenceExpression)
						ci.ConstructorInitializerType = ConstructorInitializerType.Base;
					else
						return;
					// Move arguments from invocation to initializer:
					invocation.Arguments.MoveTo(ci.Arguments);
					// Add the initializer: (unless it is the default 'base()')
					if (!(ci.ConstructorInitializerType == ConstructorInitializerType.Base && ci.Arguments.Count == 0))
						constructorDeclaration.Initializer = ci.CopyAnnotationsFrom(invocation);
					// Remove the statement:
					stmt.Remove();
					break;
				// Pattern for value types:
				// this = new TSelf(...);
				case AssignmentExpression assignment:
					if (!(assignment.Right is ObjectCreateExpression oce && oce.GetSymbol() is IMethod ctor2 && ctor2.DeclaringTypeDefinition == currentCtor.DeclaringTypeDefinition))
						return;
					ci = new ConstructorInitializer();
					if (assignment.Left is ThisReferenceExpression)
						ci.ConstructorInitializerType = ConstructorInitializerType.This;
					else
						return;
					// Move arguments from invocation to initializer:
					oce.Arguments.MoveTo(ci.Arguments);
					// Add the initializer: (unless it is the default 'base()')
					if (!(ci.ConstructorInitializerType == ConstructorInitializerType.Base && ci.Arguments.Count == 0))
						constructorDeclaration.Initializer = ci.CopyAnnotationsFrom(oce);
					// Remove the statement:
					stmt.Remove();
					break;
				default:
					return;
			}
			if (context.DecompileRun.RecordDecompilers.TryGetValue(currentCtor.DeclaringTypeDefinition, out var record)
				&& currentCtor.Equals(record.PrimaryConstructor)
				&& ci.ConstructorInitializerType == ConstructorInitializerType.Base)
			{
				if (constructorDeclaration.Parent is TypeDeclaration { BaseTypes: { Count: >= 1 } } typeDecl)
				{
					var baseType = typeDecl.BaseTypes.First();
					var newBaseType = new InvocationAstType();
					baseType.ReplaceWith(newBaseType);
					newBaseType.BaseType = baseType;
					ci.Arguments.MoveTo(newBaseType.Arguments);
				}
				constructorDeclaration.Remove();
			}
		}

		static readonly ExpressionStatement fieldInitializerPattern = new ExpressionStatement {
			Expression = new AssignmentExpression {
				Left = new Choice {
					new NamedNode("fieldAccess", new MemberReferenceExpression {
										 Target = new ThisReferenceExpression(),
										 MemberName = Pattern.AnyString
									 }),
					new NamedNode("fieldAccess", new IdentifierExpression(Pattern.AnyString))
				},
				Operator = AssignmentOperatorType.Assign,
				Right = new AnyNode("initializer")
			}
		};

		static readonly AstNode thisCallPattern = new ExpressionStatement(new InvocationExpression(new MemberReferenceExpression(new ThisReferenceExpression(), ".ctor"), new Repeat(new AnyNode())));

		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			// Handle initializers on instance fields
			HandleInstanceFieldInitializers(typeDeclaration.Members);

			// Now convert base constructor calls to initializers:
			base.VisitTypeDeclaration(typeDeclaration);

			// Remove single empty constructor:
			RemoveSingleEmptyConstructor(typeDeclaration.Members, (ITypeDefinition)typeDeclaration.GetSymbol());

			// Handle initializers on static fields:
			HandleStaticFieldInitializers(typeDeclaration.Members);
		}

		void HandleInstanceFieldInitializers(IEnumerable<AstNode> members)
		{
			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray();
			var instanceCtorsNotChainingWithThis = instanceCtors.Where(ctor => !thisCallPattern.IsMatch(ctor.Body.Statements.FirstOrDefault())).ToArray();
			if (instanceCtorsNotChainingWithThis.Length > 0)
			{
				if (instanceCtorsNotChainingWithThis[0].GetSymbol() is IMethod ctorMethodDef && ctorMethodDef.DeclaringType.IsReferenceType == false)
					return;

				bool ctorIsUnsafe = instanceCtorsNotChainingWithThis.All(c => c.HasModifier(Modifiers.Unsafe));

				if (!context.DecompileRun.RecordDecompilers.TryGetValue(ctorMethodDef.DeclaringTypeDefinition, out var record))
					record = null;

				// Recognize field or property initializers:
				// Translate first statement in all ctors (if all ctors have the same statement) into an initializer.
				bool allSame;
				do
				{
					Match m = fieldInitializerPattern.Match(instanceCtorsNotChainingWithThis[0].Body.FirstOrDefault());
					if (!m.Success)
						break;
					IMember fieldOrPropertyOrEvent = (m.Get<AstNode>("fieldAccess").Single().GetSymbol() as IMember)?.MemberDefinition;
					if (!(fieldOrPropertyOrEvent is IField) && !(fieldOrPropertyOrEvent is IProperty) && !(fieldOrPropertyOrEvent is IEvent))
						break;
					var fieldOrPropertyOrEventDecl = members.FirstOrDefault(f => f.GetSymbol() == fieldOrPropertyOrEvent) as EntityDeclaration;
					// Cannot transform if it is a custom event.
					if (fieldOrPropertyOrEventDecl is CustomEventDeclaration)
						break;


					Expression initializer = m.Get<Expression>("initializer").Single();
					// 'this'/'base' cannot be used in initializers
					if (initializer.DescendantsAndSelf.Any(n => n is ThisReferenceExpression || n is BaseReferenceExpression))
						break;

					if (initializer.Annotation<ILVariableResolveResult>()?.Variable.Kind == IL.VariableKind.Parameter)
					{
						// remove record ctor parameter assignments
						if (IsPropertyDeclaredByPrimaryCtor(fieldOrPropertyOrEvent as IProperty, record))
							initializer.Remove();
						else
							break;
					}
					else
					{
						// cannot transform if member is not found
						if (fieldOrPropertyOrEventDecl == null)
							break;
					}

					allSame = true;
					for (int i = 1; i < instanceCtorsNotChainingWithThis.Length; i++)
					{
						var otherMatch = fieldInitializerPattern.Match(instanceCtorsNotChainingWithThis[i].Body.FirstOrDefault());
						if (!otherMatch.Success)
						{
							allSame = false;
							break;
						}
						var otherMember = (otherMatch.Get<AstNode>("fieldAccess").Single().GetSymbol() as IMember)?.MemberDefinition;
						if (!otherMember.Equals(fieldOrPropertyOrEvent))
							allSame = false;
						if (!initializer.IsMatch(otherMatch.Get<AstNode>("initializer").Single()))
							allSame = false;
					}
					if (allSame)
					{
						foreach (var ctor in instanceCtorsNotChainingWithThis)
							ctor.Body.First().Remove();
						if (fieldOrPropertyOrEventDecl == null)
							continue;
						if (ctorIsUnsafe && IntroduceUnsafeModifier.IsUnsafe(initializer))
						{
							fieldOrPropertyOrEventDecl.Modifiers |= Modifiers.Unsafe;
						}
						if (fieldOrPropertyOrEventDecl is PropertyDeclaration pd)
						{
							pd.Initializer = initializer.Detach();
						}
						else
						{
							fieldOrPropertyOrEventDecl.GetChildrenByRole(Roles.Variable).Single().Initializer = initializer.Detach();
						}
					}
				} while (allSame);
			}
		}

		bool IsPropertyDeclaredByPrimaryCtor(IProperty p, RecordDecompiler record)
		{
			if (p == null || record == null)
				return false;
			return record.IsPropertyDeclaredByPrimaryConstructor(p);
		}

		void RemoveSingleEmptyConstructor(IEnumerable<AstNode> members, ITypeDefinition contextTypeDefinition)
		{
			// if we're outside of a type definition skip this altogether
			if (contextTypeDefinition == null)
				return;
			// first get non-static constructor declarations from the AST
			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray();
			// if there's exactly one ctor and it's part of a type declaration or there's more than one member in the current selection
			// we can remove the constructor. (We do not want to hide the constructor if the user explicitly selected it in the tree view.) 
			if (instanceCtors.Length == 1 && (instanceCtors[0].Parent is TypeDeclaration || members.Skip(1).Any()))
			{
				var ctor = instanceCtors[0];
				// dynamically create a pattern of an empty ctor
				ConstructorDeclaration emptyCtorPattern = new ConstructorDeclaration();
				emptyCtorPattern.Modifiers = contextTypeDefinition.IsAbstract ? Modifiers.Protected : Modifiers.Public;
				if (ctor.HasModifier(Modifiers.Unsafe))
					emptyCtorPattern.Modifiers |= Modifiers.Unsafe;
				emptyCtorPattern.Body = new BlockStatement();

				if (emptyCtorPattern.IsMatch(ctor))
				{
					bool retainBecauseOfDocumentation = ctor.GetSymbol() is IMethod ctorMethod
						&& context.Settings.ShowXmlDocumentation
						&& context.DecompileRun.DocumentationProvider?.GetDocumentation(ctorMethod) != null;
					if (!retainBecauseOfDocumentation)
						ctor.Remove();
				}
			}
		}

		void HandleStaticFieldInitializers(IEnumerable<AstNode> members)
		{
			// Translate static constructor into field initializers if the class is BeforeFieldInit
			var staticCtor = members.OfType<ConstructorDeclaration>().FirstOrDefault(c => (c.Modifiers & Modifiers.Static) == Modifiers.Static);
			if (staticCtor != null)
			{
				bool ctorIsUnsafe = staticCtor.HasModifier(Modifiers.Unsafe);
				IMethod ctorMethod = staticCtor.GetSymbol() as IMethod;
				if (!ctorMethod.MetadataToken.IsNil)
				{
					var metadata = context.TypeSystem.MainModule.PEFile.Metadata;
					SRM.MethodDefinition ctorMethodDef = metadata.GetMethodDefinition((SRM.MethodDefinitionHandle)ctorMethod.MetadataToken);
					SRM.TypeDefinition declaringType = metadata.GetTypeDefinition(ctorMethodDef.GetDeclaringType());
					if (declaringType.HasFlag(System.Reflection.TypeAttributes.BeforeFieldInit))
					{
						while (true)
						{
							ExpressionStatement es = staticCtor.Body.Statements.FirstOrDefault() as ExpressionStatement;
							if (es == null)
								break;
							AssignmentExpression assignment = es.Expression as AssignmentExpression;
							if (assignment == null || assignment.Operator != AssignmentOperatorType.Assign)
								break;
							IMember fieldOrProperty = (assignment.Left.GetSymbol() as IMember)?.MemberDefinition;
							if (!(fieldOrProperty is IField || fieldOrProperty is IProperty) || !fieldOrProperty.IsStatic)
								break;
							var fieldOrPropertyDecl = members.FirstOrDefault(f => f.GetSymbol() == fieldOrProperty) as EntityDeclaration;
							if (fieldOrPropertyDecl == null)
								break;
							if (ctorIsUnsafe && IntroduceUnsafeModifier.IsUnsafe(assignment.Right))
							{
								fieldOrPropertyDecl.Modifiers |= Modifiers.Unsafe;
							}
							if (fieldOrPropertyDecl is FieldDeclaration fd)
								fd.Variables.Single().Initializer = assignment.Right.Detach();
							else if (fieldOrPropertyDecl is PropertyDeclaration pd)
								pd.Initializer = assignment.Right.Detach();
							else
								break;
							es.Remove();
						}
						if (staticCtor.Body.Statements.Count == 0)
							staticCtor.Remove();
					}
				}
			}
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\CSharp\Transforms\TransformFieldAndConstructorInitializers.cs(172,61): error CS0165: Use of unassigned local variable 'ctorMethodDef'
######################################################################


######################################################################
Nr: 8 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Xml;

namespace ICSharpCode.Decompiler.Util
{
#if INSIDE_SYSTEM_WEB
	internal
#else
	public
#endif
	class ResXResourceWriter : IDisposable
	{
		#region Local Variables
		private string filename;
		private Stream stream;
		private TextWriter textwriter;
		private XmlTextWriter writer;
		private bool written;
		private string base_path;
		#endregion    // Local Variables

		#region Static Fields
		public static readonly string BinSerializedObjectMimeType = "application/x-microsoft.net.object.binary.base64";
		public static readonly string ByteArraySerializedObjectMimeType = "application/x-microsoft.net.object.bytearray.base64";
		public static readonly string DefaultSerializedObjectMimeType = BinSerializedObjectMimeType;
		public static readonly string ResMimeType = "text/microsoft-resx";
		public static readonly string SoapSerializedObjectMimeType = "application/x-microsoft.net.object.soap.base64";
		public static readonly string Version = "2.0";
		#endregion  // Static Fields

		#region Constructors & Destructor
		public ResXResourceWriter(Stream stream)
		{
			if (stream == null)
				throw new ArgumentNullException(nameof(stream));

			if (!stream.CanWrite)
				throw new ArgumentException("stream is not writable.", nameof(stream));

			this.stream = stream;
		}

		public ResXResourceWriter(TextWriter textWriter)
		{
			if (textWriter == null)
				throw new ArgumentNullException(nameof(textWriter));

			this.textwriter = textWriter;
		}

		public ResXResourceWriter(string fileName)
		{
			if (fileName == null)
				throw new ArgumentNullException(nameof(fileName));

			this.filename = fileName;
		}

		~ResXResourceWriter()
		{
			Dispose(false);
		}
		#endregion // Constructors & Destructor

		const string WinFormsAssemblyName = ", System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
		const string ResXNullRefTypeName = "System.Resources.ResXNullRef" + WinFormsAssemblyName;

		void InitWriter()
		{
			if (filename != null)
				stream = File.Open(filename, FileMode.Create);
			if (textwriter == null)
				textwriter = new StreamWriter(stream, Encoding.UTF8);

			writer = new XmlTextWriter(textwriter);
			writer.Formatting = Formatting.Indented;
			writer.WriteStartDocument();
			writer.WriteStartElement("root");
			writer.WriteRaw(schema);
			WriteHeader("resmimetype", "text/microsoft-resx");
			WriteHeader("version", "1.3");
			WriteHeader("reader", "System.Resources.ResXResourceReader" + WinFormsAssemblyName);
			WriteHeader("writer", "System.Resources.ResXResourceWriter" + WinFormsAssemblyName);
		}

		void WriteHeader(string name, string value)
		{
			writer.WriteStartElement("resheader");
			writer.WriteAttributeString("name", name);
			writer.WriteStartElement("value");
			writer.WriteString(value);
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		void WriteNiceBase64(byte[] value, int offset, int length)
		{
			string b64;
			StringBuilder sb;
			int pos;
			int inc;
			string ins;

			b64 = Convert.ToBase64String(value, offset, length);

			// Wild guess; two extra newlines, and one newline/tab pair for every 80 chars
			sb = new StringBuilder(b64, b64.Length + ((b64.Length + 160) / 80) * 3);
			pos = 0;
			inc = 80 + Environment.NewLine.Length + 1;
			ins = Environment.NewLine + "\t";
			while (pos < sb.Length)
			{
				sb.Insert(pos, ins);
				pos += inc;
			}
			sb.Insert(sb.Length, Environment.NewLine);
			writer.WriteString(sb.ToString());
		}

		void WriteBytes(string name, Type type, byte[] value, int offset, int length, string comment)
		{
			writer.WriteStartElement("data");
			writer.WriteAttributeString("name", name);

			if (type != null)
			{
				writer.WriteAttributeString("type", type.AssemblyQualifiedName);
				// byte[] should never get a mimetype, otherwise MS.NET won't be able
				// to parse the data.
				if (type != typeof(byte[]))
					writer.WriteAttributeString("mimetype", ByteArraySerializedObjectMimeType);
				writer.WriteStartElement("value");
				WriteNiceBase64(value, offset, length);
			}
			else
			{
				writer.WriteAttributeString("mimetype", BinSerializedObjectMimeType);
				writer.WriteStartElement("value");
				writer.WriteBase64(value, offset, length);
			}

			writer.WriteEndElement();

			if (!(comment == null || comment.Equals(String.Empty)))
			{
				writer.WriteStartElement("comment");
				writer.WriteString(comment);
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
		}

		void WriteBytes(string name, Type type, byte[] value, string comment)
		{
			WriteBytes(name, type, value, 0, value.Length, comment);
		}

		void WriteString(string name, string value)
		{
			WriteString(name, value, null);
		}
		void WriteString(string name, string value, string type)
		{
			WriteString(name, value, type, String.Empty);
		}
		void WriteString(string name, string value, string type, string comment)
		{
			writer.WriteStartElement("data");
			writer.WriteAttributeString("name", name);
			if (type != null)
				writer.WriteAttributeString("type", type);
			writer.WriteStartElement("value");
			writer.WriteString(value);
			writer.WriteEndElement();
			if (!(comment == null || comment.Equals(String.Empty)))
			{
				writer.WriteStartElement("comment");
				writer.WriteString(comment);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
			writer.WriteWhitespace("\n  ");
		}

		public void AddResource(string name, byte[] value)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			WriteBytes(name, value.GetType(), value, null);
		}

		public void AddResource(string name, object value)
		{
			AddResource(name, value, String.Empty);
		}

		private void AddResource(string name, object value, string comment)
		{
			if (value is string)
			{
				AddResource(name, (string)value, comment);
				return;
			}

			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			if (value is byte[])
			{
				WriteBytes(name, value.GetType(), (byte[])value, comment);
				return;
			}
			if (value is ResourceSerializedObject rso)
			{
				var bytes = rso.GetBytes();
				WriteBytes(name, null, bytes, 0, bytes.Length, comment);
				return;
			}

			if (value == null)
			{
				// nulls written as ResXNullRef
				WriteString(name, "", ResXNullRefTypeName, comment);
				return;
			}

			if (value != null && !value.GetType().IsSerializable)
				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable.", name, value.GetType().Name));

			TypeConverter converter = TypeDescriptor.GetConverter(value);

			if (converter != null && converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string)))
			{
				string str = (string)converter.ConvertToInvariantString(value);
				WriteString(name, str, value.GetType().AssemblyQualifiedName, comment);
				return;
			}

			if (converter != null && converter.CanConvertTo(typeof(byte[])) && converter.CanConvertFrom(typeof(byte[])))
			{
				byte[] b = (byte[])converter.ConvertTo(value, typeof(byte[]));
				WriteBytes(name, value.GetType(), b, comment);
				return;
			}

			MemoryStream ms = new MemoryStream();
			BinaryFormatter fmt = new BinaryFormatter();
			try
			{
				fmt.Serialize(ms, value);
			}
			catch (Exception e)
			{
				throw new InvalidOperationException("Cannot add a " + value.GetType() +
									 "because it cannot be serialized: " +
									 e.Message);
			}

			WriteBytes(name, null, ms.GetBuffer(), 0, (int)ms.Length, comment);
			ms.Close();
		}

		public void AddResource(string name, string value)
		{
			AddResource(name, value, string.Empty);
		}

		private void AddResource(string name, string value, string comment)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			WriteString(name, value, null, comment);
		}

		public void AddMetadata(string name, string value)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			writer.WriteStartElement("metadata");
			writer.WriteAttributeString("name", name);
			writer.WriteAttributeString("xml:space", "preserve");

			writer.WriteElementString("value", value);

			writer.WriteEndElement();
		}

		public void AddMetadata(string name, byte[] value)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			writer.WriteStartElement("metadata");
			writer.WriteAttributeString("name", name);

			writer.WriteAttributeString("type", value.GetType().AssemblyQualifiedName);

			writer.WriteStartElement("value");
			WriteNiceBase64(value, 0, value.Length);
			writer.WriteEndElement();

			writer.WriteEndElement();
		}

		public void AddMetadata(string name, object value)
		{
			if (value is string)
			{
				AddMetadata(name, (string)value);
				return;
			}

			if (value is byte[])
			{
				AddMetadata(name, (byte[])value);
				return;
			}

			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (!value.GetType().IsSerializable)
				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable.", name, value.GetType().Name));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			Type type = value.GetType();

			TypeConverter converter = TypeDescriptor.GetConverter(value);
			if (converter != null && converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string)))
			{
				string str = (string)converter.ConvertToInvariantString(value);
				writer.WriteStartElement("metadata");
				writer.WriteAttributeString("name", name);
				if (type != null)
					writer.WriteAttributeString("type", type.AssemblyQualifiedName);
				writer.WriteStartElement("value");
				writer.WriteString(str);
				writer.WriteEndElement();
				writer.WriteEndElement();
				writer.WriteWhitespace("\n  ");
				return;
			}

			if (converter != null && converter.CanConvertTo(typeof(byte[])) && converter.CanConvertFrom(typeof(byte[])))
			{
				byte[] b = (byte[])converter.ConvertTo(value, typeof(byte[]));
				writer.WriteStartElement("metadata");
				writer.WriteAttributeString("name", name);

				if (type != null)
				{
					writer.WriteAttributeString("type", type.AssemblyQualifiedName);
					writer.WriteAttributeString("mimetype", ByteArraySerializedObjectMimeType);
					writer.WriteStartElement("value");
					WriteNiceBase64(b, 0, b.Length);
				}
				else
				{
					writer.WriteAttributeString("mimetype", BinSerializedObjectMimeType);
					writer.WriteStartElement("value");
					writer.WriteBase64(b, 0, b.Length);
				}

				writer.WriteEndElement();
				writer.WriteEndElement();
				return;
			}

			MemoryStream ms = new MemoryStream();
			BinaryFormatter fmt = new BinaryFormatter();
			try
			{
				fmt.Serialize(ms, value);
			}
			catch (Exception e)
			{
				throw new InvalidOperationException("Cannot add a " + value.GetType() +
									 "because it cannot be serialized: " +
									 e.Message);
			}

			writer.WriteStartElement("metadata");
			writer.WriteAttributeString("name", name);

			if (type != null)
			{
				writer.WriteAttributeString("type", type.AssemblyQualifiedName);
				writer.WriteAttributeString("mimetype", ByteArraySerializedObjectMimeType);
				writer.WriteStartElement("value");
				WriteNiceBase64(ms.GetBuffer(), 0, ms.GetBuffer().Length);
			}
			else
			{
				writer.WriteAttributeString("mimetype", BinSerializedObjectMimeType);
				writer.WriteStartElement("value");
				writer.WriteBase64(ms.GetBuffer(), 0, ms.GetBuffer().Length);
			}

			writer.WriteEndElement();
			writer.WriteEndElement();
			ms.Close();
		}

		public void Close()
		{
			if (writer != null)
			{
				if (!written)
				{
					Generate();
				}

				writer.Close();
				stream = null;
				filename = null;
				textwriter = null;
			}
		}

		public virtual void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public void Generate()
		{
			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			written = true;
			writer.WriteEndElement();
			writer.Flush();
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
				Close();
		}

		static string schema = @"
	<xsd:schema id='root' xmlns='' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:msdata='urn:schemas-microsoft-com:xml-msdata'>
		<xsd:element name='root' msdata:IsDataSet='true'>
			<xsd:complexType>
				<xsd:choice maxOccurs='unbounded'>
					<xsd:element name='data'>
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name='value' type='xsd:string' minOccurs='0' msdata:Ordinal='1' />
								<xsd:element name='comment' type='xsd:string' minOccurs='0' msdata:Ordinal='2' />
							</xsd:sequence>
							<xsd:attribute name='name' type='xsd:string' msdata:Ordinal='1' />
							<xsd:attribute name='type' type='xsd:string' msdata:Ordinal='3' />
							<xsd:attribute name='mimetype' type='xsd:string' msdata:Ordinal='4' />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name='resheader'>
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name='value' type='xsd:string' minOccurs='0' msdata:Ordinal='1' />
							</xsd:sequence>
							<xsd:attribute name='name' type='xsd:string' use='required' />
						</xsd:complexType>
					</xsd:element>
				</xsd:choice>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
".Replace("'", "\"").Replace("\t", "  ");

		#region Public Properties
		public string BasePath {
			get { return base_path; }
			set { base_path = value; }
		}
		#endregion
	}
}

---- Transformed Tree ----
using System;
using System.ComponentModel;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Xml;

namespace ICSharpCode.Decompiler.Util
{
#if INSIDE_SYSTEM_WEB
	internal
#else
	public
#endif
	class ResXResourceWriter : IDisposable
	{
		#region Local Variables
		private string filename;
		private Stream stream;
		private TextWriter textwriter;
		private XmlTextWriter writer;
		private bool written;
		private string base_path;
		#endregion    // Local Variables

		#region Static Fields
		public static readonly string BinSerializedObjectMimeType = "application/x-microsoft.net.object.binary.base64";
		public static readonly string ByteArraySerializedObjectMimeType = "application/x-microsoft.net.object.bytearray.base64";
		public static readonly string DefaultSerializedObjectMimeType = BinSerializedObjectMimeType;
		public static readonly string ResMimeType = "text/microsoft-resx";
		public static readonly string SoapSerializedObjectMimeType = "application/x-microsoft.net.object.soap.base64";
		public static readonly string Version = "2.0";
		#endregion  // Static Fields

		#region Constructors & Destructor
		public ResXResourceWriter(Stream stream)
		{
			if (stream == null)
				throw new ArgumentNullException(nameof(stream));

			if (!stream.CanWrite)
				throw new ArgumentException("stream is not writable.", nameof(stream));

			this.stream = stream;
		}

		public ResXResourceWriter(TextWriter textWriter)
		{
			if (textWriter == null)
				throw new ArgumentNullException(nameof(textWriter));

			this.textwriter = textWriter;
		}

		public ResXResourceWriter(string fileName)
		{
			if (fileName == null)
				throw new ArgumentNullException(nameof(fileName));

			this.filename = fileName;
		}

		~ResXResourceWriter()
		{
			Dispose(false);
		}
		#endregion // Constructors & Destructor

		const string WinFormsAssemblyName = ", System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
		const string ResXNullRefTypeName = "System.Resources.ResXNullRef" + WinFormsAssemblyName;

		void InitWriter()
		{
			if (filename != null)
				stream = File.Open(filename, FileMode.Create);
			if (textwriter == null)
				textwriter = new StreamWriter(stream, Encoding.UTF8);

			writer = new XmlTextWriter(textwriter);
			writer.Formatting = Formatting.Indented;
			writer.WriteStartDocument();
			writer.WriteStartElement("root");
			writer.WriteRaw(schema);
			WriteHeader("resmimetype", "text/microsoft-resx");
			WriteHeader("version", "1.3");
			WriteHeader("reader", "System.Resources.ResXResourceReader" + WinFormsAssemblyName);
			WriteHeader("writer", "System.Resources.ResXResourceWriter" + WinFormsAssemblyName);
		}

		void WriteHeader(string name, string value)
		{
			writer.WriteStartElement("resheader");
			writer.WriteAttributeString("name", name);
			writer.WriteStartElement("value");
			writer.WriteString(value);
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		void WriteNiceBase64(byte[] value, int offset, int length)
		{
			string b64;
			StringBuilder sb;
			int pos;
			int inc;
			string ins;

			b64 = Convert.ToBase64String(value, offset, length);

			// Wild guess; two extra newlines, and one newline/tab pair for every 80 chars
			sb = new StringBuilder(b64, b64.Length + ((b64.Length + 160) / 80) * 3);
			pos = 0;
			inc = 80 + Environment.NewLine.Length + 1;
			ins = Environment.NewLine + "\t";
			while (pos < sb.Length)
			{
				sb.Insert(pos, ins);
				pos += inc;
			}
			sb.Insert(sb.Length, Environment.NewLine);
			writer.WriteString(sb.ToString());
		}

		void WriteBytes(string name, Type type, byte[] value, int offset, int length, string comment)
		{
			writer.WriteStartElement("data");
			writer.WriteAttributeString("name", name);

			if (type != null)
			{
				writer.WriteAttributeString("type", type.AssemblyQualifiedName);
				// byte[] should never get a mimetype, otherwise MS.NET won't be able
				// to parse the data.
				if (type != typeof(byte[]))
					writer.WriteAttributeString("mimetype", ByteArraySerializedObjectMimeType);
				writer.WriteStartElement("value");
				WriteNiceBase64(value, offset, length);
			}
			else
			{
				writer.WriteAttributeString("mimetype", BinSerializedObjectMimeType);
				writer.WriteStartElement("value");
				writer.WriteBase64(value, offset, length);
			}

			writer.WriteEndElement();

			if (!(comment == null || comment.Equals(String.Empty)))
			{
				writer.WriteStartElement("comment");
				writer.WriteString(comment);
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
		}

		void WriteBytes(string name, Type type, byte[] value, string comment)
		{
			WriteBytes(name, type, value, 0, value.Length, comment);
		}

		void WriteString(string name, string value)
		{
			WriteString(name, value, null);
		}
		void WriteString(string name, string value, string type)
		{
			WriteString(name, value, type, String.Empty);
		}
		void WriteString(string name, string value, string type, string comment)
		{
			writer.WriteStartElement("data");
			writer.WriteAttributeString("name", name);
			if (type != null)
				writer.WriteAttributeString("type", type);
			writer.WriteStartElement("value");
			writer.WriteString(value);
			writer.WriteEndElement();
			if (!(comment == null || comment.Equals(String.Empty)))
			{
				writer.WriteStartElement("comment");
				writer.WriteString(comment);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
			writer.WriteWhitespace("\n  ");
		}

		public void AddResource(string name, byte[] value)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			WriteBytes(name, value.GetType(), value, null);
		}

		public void AddResource(string name, object value)
		{
			AddResource(name, value, String.Empty);
		}

		private void AddResource(string name, object value, string comment)
		{
			if (value is string s)
			{
				AddResource(name, s, comment);
				return;
			}

			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			if (value is byte[] bytes)
			{
				WriteBytes(name, value.GetType(), bytes, comment);
				return;
			}
			if (value is ResourceSerializedObject rso)
			{
				var bytes = rso.GetBytes();
				WriteBytes(name, null, bytes, 0, bytes.Length, comment);
				return;
			}

			if (value == null)
			{
				// nulls written as ResXNullRef
				WriteString(name, "", ResXNullRefTypeName, comment);
				return;
			}

			if (value != null && !value.GetType().IsSerializable)
				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable.", name, value.GetType().Name));

			TypeConverter converter = TypeDescriptor.GetConverter(value);

			if (converter != null && converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string)))
			{
				string str = (string)converter.ConvertToInvariantString(value);
				WriteString(name, str, value.GetType().AssemblyQualifiedName, comment);
				return;
			}

			if (converter != null && converter.CanConvertTo(typeof(byte[])) && converter.CanConvertFrom(typeof(byte[])))
			{
				byte[] b = (byte[])converter.ConvertTo(value, typeof(byte[]));
				WriteBytes(name, value.GetType(), b, comment);
				return;
			}

			MemoryStream ms = new MemoryStream();
			BinaryFormatter fmt = new BinaryFormatter();
			try
			{
				fmt.Serialize(ms, value);
			}
			catch (Exception e)
			{
				throw new InvalidOperationException("Cannot add a " + value.GetType() +
									 "because it cannot be serialized: " +
									 e.Message);
			}

			WriteBytes(name, null, ms.GetBuffer(), 0, (int)ms.Length, comment);
			ms.Close();
		}

		public void AddResource(string name, string value)
		{
			AddResource(name, value, string.Empty);
		}

		private void AddResource(string name, string value, string comment)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			WriteString(name, value, null, comment);
		}

		public void AddMetadata(string name, string value)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			writer.WriteStartElement("metadata");
			writer.WriteAttributeString("name", name);
			writer.WriteAttributeString("xml:space", "preserve");

			writer.WriteElementString("value", value);

			writer.WriteEndElement();
		}

		public void AddMetadata(string name, byte[] value)
		{
			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			writer.WriteStartElement("metadata");
			writer.WriteAttributeString("name", name);

			writer.WriteAttributeString("type", value.GetType().AssemblyQualifiedName);

			writer.WriteStartElement("value");
			WriteNiceBase64(value, 0, value.Length);
			writer.WriteEndElement();

			writer.WriteEndElement();
		}

		public void AddMetadata(string name, object value)
		{
			if (value is string s)
			{
				AddMetadata(name, s);
				return;
			}

			if (value is byte[] bytes)
			{
				AddMetadata(name, bytes);
				return;
			}

			if (name == null)
				throw new ArgumentNullException(nameof(name));

			if (value == null)
				throw new ArgumentNullException(nameof(value));

			if (!value.GetType().IsSerializable)
				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable.", name, value.GetType().Name));

			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			if (writer == null)
				InitWriter();

			Type type = value.GetType();

			TypeConverter converter = TypeDescriptor.GetConverter(value);
			if (converter != null && converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string)))
			{
				string str = (string)converter.ConvertToInvariantString(value);
				writer.WriteStartElement("metadata");
				writer.WriteAttributeString("name", name);
				if (type != null)
					writer.WriteAttributeString("type", type.AssemblyQualifiedName);
				writer.WriteStartElement("value");
				writer.WriteString(str);
				writer.WriteEndElement();
				writer.WriteEndElement();
				writer.WriteWhitespace("\n  ");
				return;
			}

			if (converter != null && converter.CanConvertTo(typeof(byte[])) && converter.CanConvertFrom(typeof(byte[])))
			{
				byte[] b = (byte[])converter.ConvertTo(value, typeof(byte[]));
				writer.WriteStartElement("metadata");
				writer.WriteAttributeString("name", name);

				if (type != null)
				{
					writer.WriteAttributeString("type", type.AssemblyQualifiedName);
					writer.WriteAttributeString("mimetype", ByteArraySerializedObjectMimeType);
					writer.WriteStartElement("value");
					WriteNiceBase64(b, 0, b.Length);
				}
				else
				{
					writer.WriteAttributeString("mimetype", BinSerializedObjectMimeType);
					writer.WriteStartElement("value");
					writer.WriteBase64(b, 0, b.Length);
				}

				writer.WriteEndElement();
				writer.WriteEndElement();
				return;
			}

			MemoryStream ms = new MemoryStream();
			BinaryFormatter fmt = new BinaryFormatter();
			try
			{
				fmt.Serialize(ms, value);
			}
			catch (Exception e)
			{
				throw new InvalidOperationException("Cannot add a " + value.GetType() +
									 "because it cannot be serialized: " +
									 e.Message);
			}

			writer.WriteStartElement("metadata");
			writer.WriteAttributeString("name", name);

			if (type != null)
			{
				writer.WriteAttributeString("type", type.AssemblyQualifiedName);
				writer.WriteAttributeString("mimetype", ByteArraySerializedObjectMimeType);
				writer.WriteStartElement("value");
				WriteNiceBase64(ms.GetBuffer(), 0, ms.GetBuffer().Length);
			}
			else
			{
				writer.WriteAttributeString("mimetype", BinSerializedObjectMimeType);
				writer.WriteStartElement("value");
				writer.WriteBase64(ms.GetBuffer(), 0, ms.GetBuffer().Length);
			}

			writer.WriteEndElement();
			writer.WriteEndElement();
			ms.Close();
		}

		public void Close()
		{
			if (writer != null)
			{
				if (!written)
				{
					Generate();
				}

				writer.Close();
				stream = null;
				filename = null;
				textwriter = null;
			}
		}

		public virtual void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public void Generate()
		{
			if (written)
				throw new InvalidOperationException("The resource is already generated.");

			written = true;
			writer.WriteEndElement();
			writer.Flush();
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
				Close();
		}

		static string schema = @"
	<xsd:schema id='root' xmlns='' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:msdata='urn:schemas-microsoft-com:xml-msdata'>
		<xsd:element name='root' msdata:IsDataSet='true'>
			<xsd:complexType>
				<xsd:choice maxOccurs='unbounded'>
					<xsd:element name='data'>
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name='value' type='xsd:string' minOccurs='0' msdata:Ordinal='1' />
								<xsd:element name='comment' type='xsd:string' minOccurs='0' msdata:Ordinal='2' />
							</xsd:sequence>
							<xsd:attribute name='name' type='xsd:string' msdata:Ordinal='1' />
							<xsd:attribute name='type' type='xsd:string' msdata:Ordinal='3' />
							<xsd:attribute name='mimetype' type='xsd:string' msdata:Ordinal='4' />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name='resheader'>
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name='value' type='xsd:string' minOccurs='0' msdata:Ordinal='1' />
							</xsd:sequence>
							<xsd:attribute name='name' type='xsd:string' use='required' />
						</xsd:complexType>
					</xsd:element>
				</xsd:choice>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
".Replace("'", "\"").Replace("\t", "  ");

		#region Public Properties
		public string BasePath {
			get { return base_path; }
			set { base_path = value; }
		}
		#endregion
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\Util\ResXResourceWriter.cs(268,9): error CS0136: A local or parameter named 'bytes' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 9 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Reflection.Metadata.Ecma335;
using System.Threading;

using ICSharpCode.Decompiler.Disassembler;
using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.Util;

using ArrayType = ICSharpCode.Decompiler.TypeSystem.ArrayType;
using ByReferenceType = ICSharpCode.Decompiler.TypeSystem.ByReferenceType;
using PinnedType = ICSharpCode.Decompiler.TypeSystem.Implementation.PinnedType;

namespace ICSharpCode.Decompiler.IL
{
	/// <summary>
	/// Reads IL bytecodes and converts them into ILAst instructions.
	/// </summary>
	/// <remarks>
	/// Instances of this class are not thread-safe. Use separate instances to decompile multiple members in parallel.
	/// </remarks>
	public class ILReader
	{
		readonly ICompilation compilation;
		readonly MetadataModule module;
		readonly MetadataReader metadata;

		public bool UseDebugSymbols { get; set; }
		public DebugInfo.IDebugInfoProvider DebugInfo { get; set; }
		public List<string> Warnings { get; } = new List<string>();

		// List of candidate locations for sequence points. Includes empty il stack locations, any nop instructions, and the instruction following
		// a call instruction. 
		public List<int> SequencePointCandidates { get; private set; }

		/// <summary>
		/// Creates a new ILReader instance.
		/// </summary>
		/// <param name="module">
		/// The module used to resolve metadata tokens in the type system.
		/// </param>
		public ILReader(MetadataModule module)
		{
			if (module == null)
				throw new ArgumentNullException(nameof(module));
			this.module = module;
			this.compilation = module.Compilation;
			this.metadata = module.metadata;
			this.SequencePointCandidates = new List<int>();
		}

		GenericContext genericContext;
		IMethod method;
		MethodBodyBlock body;
		StackType methodReturnStackType;
		BlobReader reader;
		ImmutableStack<ILVariable> currentStack;
		ILVariable[] parameterVariables;
		ILVariable[] localVariables;
		BitArray isBranchTarget;
		BlockContainer mainContainer;
		List<ILInstruction> instructionBuilder;
		int currentInstructionStart;

		// Dictionary that stores stacks for each IL instruction
		Dictionary<int, ImmutableStack<ILVariable>> stackByOffset;
		Dictionary<ExceptionRegion, ILVariable> variableByExceptionHandler;
		UnionFind<ILVariable> unionFind;
		List<(ILVariable, ILVariable)> stackMismatchPairs;
		IEnumerable<ILVariable> stackVariables;

		void Init(MethodDefinitionHandle methodDefinitionHandle, MethodBodyBlock body, GenericContext genericContext)
		{
			if (body == null)
				throw new ArgumentNullException(nameof(body));
			if (methodDefinitionHandle.IsNil)
				throw new ArgumentException("methodDefinitionHandle.IsNil");
			this.method = module.GetDefinition(methodDefinitionHandle);
			if (genericContext.ClassTypeParameters == null && genericContext.MethodTypeParameters == null)
			{
				// no generic context specified: use the method's own type parameters
				genericContext = new GenericContext(method);
			}
			else
			{
				// generic context specified, so specialize the method for it:
				this.method = this.method.Specialize(genericContext.ToSubstitution());
			}
			this.genericContext = genericContext;
			this.body = body;
			this.reader = body.GetILReader();
			this.currentStack = ImmutableStack<ILVariable>.Empty;
			this.unionFind = new UnionFind<ILVariable>();
			this.stackMismatchPairs = new List<(ILVariable, ILVariable)>();
			this.methodReturnStackType = method.ReturnType.GetStackType();
			InitParameterVariables();
			localVariables = InitLocalVariables();
			if (body.LocalVariablesInitialized)
			{
				foreach (var v in localVariables)
				{
					v.HasInitialValue = true;
				}
			}
			this.mainContainer = new BlockContainer(expectedResultType: methodReturnStackType);
			this.instructionBuilder = new List<ILInstruction>();
			this.isBranchTarget = new BitArray(reader.Length);
			this.stackByOffset = new Dictionary<int, ImmutableStack<ILVariable>>();
			this.variableByExceptionHandler = new Dictionary<ExceptionRegion, ILVariable>();
		}

		EntityHandle ReadAndDecodeMetadataToken()
		{
			int token = reader.ReadInt32();
			if (token <= 0)
			{
				// SRM uses negative tokens as "virtual tokens" and can get confused
				// if we manually create them.
				// Row-IDs < 1 are always invalid.
				throw new BadImageFormatException("Invalid metadata token");
			}
			return MetadataTokens.EntityHandle(token);
		}

		IType ReadAndDecodeTypeReference()
		{
			var typeReference = ReadAndDecodeMetadataToken();
			return module.ResolveType(typeReference, genericContext);
		}

		IMethod ReadAndDecodeMethodReference()
		{
			var methodReference = ReadAndDecodeMetadataToken();
			return module.ResolveMethod(methodReference, genericContext);
		}

		IField ReadAndDecodeFieldReference()
		{
			var fieldReference = ReadAndDecodeMetadataToken();
			var f = module.ResolveEntity(fieldReference, genericContext) as IField;
			if (f == null)
				throw new BadImageFormatException("Invalid field token");
			return f;
		}

		ILVariable[] InitLocalVariables()
		{
			if (body.LocalSignature.IsNil)
				return Empty<ILVariable>.Array;
			ImmutableArray<IType> variableTypes;
			try
			{
				variableTypes = module.DecodeLocalSignature(body.LocalSignature, genericContext);
			}
			catch (BadImageFormatException ex)
			{
				Warnings.Add("Error decoding local variables: " + ex.Message);
				variableTypes = ImmutableArray<IType>.Empty;
			}
			var localVariables = new ILVariable[variableTypes.Length];
			foreach (var (index, type) in variableTypes.WithIndex())
			{
				localVariables[index] = CreateILVariable(index, type);
			}
			return localVariables;
		}

		void InitParameterVariables()
		{
			int popCount = method.Parameters.Count;
			if (!method.IsStatic)
				popCount++;
			if (method.Parameters.LastOrDefault()?.Type == SpecialType.ArgList)
				popCount--;
			parameterVariables = new ILVariable[popCount];
			int paramIndex = 0;
			int offset = 0;
			if (!method.IsStatic)
			{
				offset = 1;
				IType declaringType = method.DeclaringType;
				if (declaringType.IsUnbound())
				{
					// If method is a definition (and not specialized), the declaring type is also just a definition,
					// and needs to be converted into a normally usable type.
					declaringType = new ParameterizedType(declaringType, declaringType.TypeParameters);
				}
				ILVariable ilVar = CreateILVariable(-1, declaringType, "this");
				ilVar.IsRefReadOnly = method.ThisIsRefReadOnly;
				parameterVariables[paramIndex++] = ilVar;
			}
			while (paramIndex < parameterVariables.Length)
			{
				IParameter parameter = method.Parameters[paramIndex - offset];
				ILVariable ilVar = CreateILVariable(paramIndex - offset, parameter.Type, parameter.Name);
				ilVar.IsRefReadOnly = parameter.IsIn;
				parameterVariables[paramIndex] = ilVar;
				paramIndex++;
			}
			Debug.Assert(paramIndex == parameterVariables.Length);
		}

		ILVariable CreateILVariable(int index, IType type)
		{
			VariableKind kind;
			if (type.SkipModifiers() is PinnedType pinned)
			{
				kind = VariableKind.PinnedLocal;
				type = pinned.ElementType;
			}
			else
			{
				kind = VariableKind.Local;
			}
			ILVariable ilVar = new ILVariable(kind, type, index);
			if (!UseDebugSymbols || DebugInfo == null || !DebugInfo.TryGetName((MethodDefinitionHandle)method.MetadataToken, index, out string name))
			{
				ilVar.Name = "V_" + index;
				ilVar.HasGeneratedName = true;
			}
			else if (string.IsNullOrWhiteSpace(name))
			{
				ilVar.Name = "V_" + index;
				ilVar.HasGeneratedName = true;
			}
			else
			{
				ilVar.Name = name;
			}
			return ilVar;
		}

		ILVariable CreateILVariable(int index, IType parameterType, string name)
		{
			Debug.Assert(!parameterType.IsUnbound());
			ITypeDefinition def = parameterType.GetDefinition();
			if (def != null && index < 0 && def.IsReferenceType == false)
			{
				parameterType = new ByReferenceType(parameterType);
			}
			var ilVar = new ILVariable(VariableKind.Parameter, parameterType, index);
			Debug.Assert(ilVar.StoreCount == 1); // count the initial store when the method is called with an argument
			if (index < 0)
				ilVar.Name = "this";
			else if (string.IsNullOrEmpty(name))
				ilVar.Name = "P_" + index;
			else
				ilVar.Name = name;
			return ilVar;
		}

		/// <summary>
		/// Warn when invalid IL is detected.
		/// ILSpy should be able to handle invalid IL; but this method can be helpful for debugging the ILReader,
		/// as this method should not get called when processing valid IL.
		/// </summary>
		void Warn(string message)
		{
			Warnings.Add(string.Format("IL_{0:x4}: {1}", currentInstructionStart, message));
		}

		ImmutableStack<ILVariable> MergeStacks(ImmutableStack<ILVariable> a, ImmutableStack<ILVariable> b)
		{
			if (CheckStackCompatibleWithoutAdjustments(a, b))
			{
				// We only need to union the input variables, but can 
				// otherwise re-use the existing stack.
				ImmutableStack<ILVariable> output = a;
				while (!a.IsEmpty && !b.IsEmpty)
				{
					Debug.Assert(a.Peek().StackType == b.Peek().StackType);
					unionFind.Merge(a.Peek(), b.Peek());
					a = a.Pop();
					b = b.Pop();
				}
				return output;
			}
			else if (a.Count() != b.Count())
			{
				// Let's not try to merge mismatched stacks.
				Warn("Incompatible stack heights: " + a.Count() + " vs " + b.Count());
				return a;
			}
			else
			{
				// The more complex case where the stacks don't match exactly.
				var output = new List<ILVariable>();
				while (!a.IsEmpty && !b.IsEmpty)
				{
					var varA = a.Peek();
					var varB = b.Peek();
					if (varA.StackType == varB.StackType)
					{
						unionFind.Merge(varA, varB);
						output.Add(varA);
					}
					else
					{
						if (!IsValidTypeStackTypeMerge(varA.StackType, varB.StackType))
						{
							Warn("Incompatible stack types: " + varA.StackType + " vs " + varB.StackType);
						}
						if (varA.StackType > varB.StackType)
						{
							output.Add(varA);
							// every store to varB should also store to varA
							stackMismatchPairs.Add((varB, varA));
						}
						else
						{
							output.Add(varB);
							// every store to varA should also store to varB
							stackMismatchPairs.Add((varA, varB));
						}
					}
					a = a.Pop();
					b = b.Pop();
				}
				// because we built up output by popping from the input stacks, we need to reverse it to get back the original order
				output.Reverse();
				return ImmutableStack.CreateRange(output);
			}
		}

		static bool CheckStackCompatibleWithoutAdjustments(ImmutableStack<ILVariable> a, ImmutableStack<ILVariable> b)
		{
			while (!a.IsEmpty && !b.IsEmpty)
			{
				if (a.Peek().StackType != b.Peek().StackType)
					return false;
				a = a.Pop();
				b = b.Pop();
			}
			return a.IsEmpty && b.IsEmpty;
		}

		private bool IsValidTypeStackTypeMerge(StackType stackType1, StackType stackType2)
		{
			if (stackType1 == StackType.I && stackType2 == StackType.I4)
				return true;
			if (stackType1 == StackType.I4 && stackType2 == StackType.I)
				return true;
			if (stackType1 == StackType.F4 && stackType2 == StackType.F8)
				return true;
			if (stackType1 == StackType.F8 && stackType2 == StackType.F4)
				return true;
			// allow merging unknown type with any other type
			return stackType1 == StackType.Unknown || stackType2 == StackType.Unknown;
		}

		/// <summary>
		/// Stores the given stack for a branch to `offset`.
		/// 
		/// The stack may be modified if stack adjustments are necessary. (e.g. implicit I4->I conversion)
		/// </summary>
		void StoreStackForOffset(int offset, ref ImmutableStack<ILVariable> stack)
		{
			if (stackByOffset.TryGetValue(offset, out var existing))
			{
				stack = MergeStacks(existing, stack);
				if (stack != existing)
					stackByOffset[offset] = stack;
			}
			else
			{
				stackByOffset.Add(offset, stack);
			}
		}

		void ReadInstructions(CancellationToken cancellationToken)
		{
			// Fill isBranchTarget and branchStackDict based on exception handlers
			foreach (var eh in body.ExceptionRegions)
			{
				ImmutableStack<ILVariable> ehStack = null;
				if (eh.Kind == ExceptionRegionKind.Catch)
				{
					var catchType = module.ResolveType(eh.CatchType, genericContext);
					var v = new ILVariable(VariableKind.ExceptionStackSlot, catchType, eh.HandlerOffset) {
						Name = "E_" + eh.HandlerOffset,
						HasGeneratedName = true
					};
					variableByExceptionHandler.Add(eh, v);
					ehStack = ImmutableStack.Create(v);
				}
				else if (eh.Kind == ExceptionRegionKind.Filter)
				{
					var v = new ILVariable(VariableKind.ExceptionStackSlot, compilation.FindType(KnownTypeCode.Object), eh.HandlerOffset) {
						Name = "E_" + eh.HandlerOffset,
						HasGeneratedName = true
					};
					variableByExceptionHandler.Add(eh, v);
					ehStack = ImmutableStack.Create(v);
				}
				else
				{
					ehStack = ImmutableStack<ILVariable>.Empty;
				}
				if (eh.FilterOffset != -1)
				{
					isBranchTarget[eh.FilterOffset] = true;
					StoreStackForOffset(eh.FilterOffset, ref ehStack);
				}
				if (eh.HandlerOffset != -1)
				{
					isBranchTarget[eh.HandlerOffset] = true;
					StoreStackForOffset(eh.HandlerOffset, ref ehStack);
				}
			}

			reader.Reset();
			while (reader.RemainingBytes > 0)
			{
				cancellationToken.ThrowIfCancellationRequested();
				int start = reader.Offset;
				StoreStackForOffset(start, ref currentStack);
				currentInstructionStart = start;
				bool startedWithEmptyStack = currentStack.IsEmpty;
				ILInstruction decodedInstruction;
				try
				{
					decodedInstruction = DecodeInstruction();
				}
				catch (BadImageFormatException ex)
				{
					decodedInstruction = new InvalidBranch(ex.Message);
				}
				if (decodedInstruction.ResultType == StackType.Unknown && decodedInstruction.OpCode != OpCode.InvalidBranch && UnpackPush(decodedInstruction).OpCode != OpCode.InvalidExpression)
					Warn("Unknown result type (might be due to invalid IL or missing references)");
				decodedInstruction.CheckInvariant(ILPhase.InILReader);
				int end = reader.Offset;
				decodedInstruction.AddILRange(new Interval(start, end));
				UnpackPush(decodedInstruction).AddILRange(decodedInstruction);
				instructionBuilder.Add(decodedInstruction);
				if (decodedInstruction.HasDirectFlag(InstructionFlags.EndPointUnreachable))
				{
					if (!stackByOffset.TryGetValue(end, out currentStack))
					{
						currentStack = ImmutableStack<ILVariable>.Empty;
					}
				}

				if (IsSequencePointInstruction(decodedInstruction) || startedWithEmptyStack)
				{
					this.SequencePointCandidates.Add(decodedInstruction.StartILOffset);
				}
			}

			var visitor = new CollectStackVariablesVisitor(unionFind);
			for (int i = 0; i < instructionBuilder.Count; i++)
			{
				instructionBuilder[i] = instructionBuilder[i].AcceptVisitor(visitor);
			}
			stackVariables = visitor.variables;
			InsertStackAdjustments();
		}

		private bool IsSequencePointInstruction(ILInstruction instruction)
		{
			if (instruction.OpCode == OpCode.Nop ||
				(this.instructionBuilder.Count > 0 &&
				this.instructionBuilder.Last().OpCode == OpCode.Call ||
				this.instructionBuilder.Last().OpCode == OpCode.CallIndirect ||
				this.instructionBuilder.Last().OpCode == OpCode.CallVirt))
			{

				return true;
			}
			else
			{
				return false;
			}
		}

		void InsertStackAdjustments()
		{
			if (stackMismatchPairs.Count == 0)
				return;
			var dict = new MultiDictionary<ILVariable, ILVariable>();
			foreach (var (origA, origB) in stackMismatchPairs)
			{
				var a = unionFind.Find(origA);
				var b = unionFind.Find(origB);
				Debug.Assert(a.StackType < b.StackType);
				// For every store to a, insert a converting store to b.
				if (!dict[a].Contains(b))
					dict.Add(a, b);
			}
			var newInstructions = new List<ILInstruction>();
			foreach (var inst in instructionBuilder)
			{
				newInstructions.Add(inst);
				if (inst is StLoc store)
				{
					foreach (var additionalVar in dict[store.Variable])
					{
						ILInstruction value = new LdLoc(store.Variable);
						value = new Conv(value, additionalVar.StackType.ToPrimitiveType(), false, Sign.Signed);
						newInstructions.Add(new StLoc(additionalVar, value) {
							IsStackAdjustment = true,
						}.WithILRange(inst));
					}
				}
			}
			instructionBuilder = newInstructions;
		}

		/// <summary>
		/// Debugging helper: writes the decoded instruction stream interleaved with the inferred evaluation stack layout.
		/// </summary>
		public void WriteTypedIL(MethodDefinitionHandle method, MethodBodyBlock body,
			ITextOutput output, GenericContext genericContext = default, CancellationToken cancellationToken = default)
		{
			Init(method, body, genericContext);
			ReadInstructions(cancellationToken);
			foreach (var inst in instructionBuilder)
			{
				if (inst is StLoc stloc && stloc.IsStackAdjustment)
				{
					output.Write("          ");
					inst.WriteTo(output, new ILAstWritingOptions());
					output.WriteLine();
					continue;
				}
				output.Write("   [");
				bool isFirstElement = true;
				foreach (var element in stackByOffset[inst.StartILOffset])
				{
					if (isFirstElement)
						isFirstElement = false;
					else
						output.Write(", ");
					output.WriteLocalReference(element.Name, element);
					output.Write(":");
					output.Write(element.StackType);
				}
				output.Write(']');
				output.WriteLine();
				if (isBranchTarget[inst.StartILOffset])
					output.Write('*');
				else
					output.Write(' ');
				output.WriteLocalReference("IL_" + inst.StartILOffset.ToString("x4"), inst.StartILOffset, isDefinition: true);
				output.Write(": ");
				inst.WriteTo(output, new ILAstWritingOptions());
				output.WriteLine();
			}
			new Disassembler.MethodBodyDisassembler(output, cancellationToken) { DetectControlStructure = false }
				.WriteExceptionHandlers(module.PEFile, method, body);
		}

		/// <summary>
		/// Decodes the specified method body and returns an ILFunction.
		/// </summary>
		public ILFunction ReadIL(MethodDefinitionHandle method, MethodBodyBlock body, GenericContext genericContext = default, ILFunctionKind kind = ILFunctionKind.TopLevelFunction, CancellationToken cancellationToken = default)
		{
			cancellationToken.ThrowIfCancellationRequested();
			Init(method, body, genericContext);
			ReadInstructions(cancellationToken);
			var blockBuilder = new BlockBuilder(body, variableByExceptionHandler);
			blockBuilder.CreateBlocks(mainContainer, instructionBuilder, isBranchTarget, cancellationToken);
			var function = new ILFunction(this.method, body.GetCodeSize(), this.genericContext, mainContainer, kind);
			function.Variables.AddRange(parameterVariables);
			function.Variables.AddRange(localVariables);
			function.Variables.AddRange(stackVariables);
			function.Variables.AddRange(variableByExceptionHandler.Values);
			function.AddRef(); // mark the root node
			var removedBlocks = new List<Block>();
			foreach (var c in function.Descendants.OfType<BlockContainer>())
			{
				var newOrder = c.TopologicalSort(deleteUnreachableBlocks: true);
				if (newOrder.Count < c.Blocks.Count)
				{
					removedBlocks.AddRange(c.Blocks.Except(newOrder));
				}
				c.Blocks.ReplaceList(newOrder);
			}
			if (removedBlocks.Count > 0)
			{
				removedBlocks.SortBy(b => b.StartILOffset);
				function.Warnings.Add("Discarded unreachable code: "
							+ string.Join(", ", removedBlocks.Select(b => $"IL_{b.StartILOffset:x4}")));
			}

			this.SequencePointCandidates.Sort();
			function.SequencePointCandidates = this.SequencePointCandidates;

			function.Warnings.AddRange(Warnings);
			return function;
		}

		static ILInstruction UnpackPush(ILInstruction inst)
		{
			ILVariable v;
			ILInstruction inner;
			if (inst.MatchStLoc(out v, out inner) && v.Kind == VariableKind.StackSlot)
				return inner;
			else
				return inst;
		}

		ILInstruction Neg()
		{
			switch (PeekStackType())
			{
				case StackType.I4:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcI4(0), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.I:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new Conv(new LdcI4(0), PrimitiveType.I, false, Sign.None), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.I8:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcI8(0), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.F4:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcF4(0), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.F8:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcF8(0), Pop(), checkForOverflow: false, sign: Sign.None));
				default:
					Warn("Unsupported input type for neg.");
					goto case StackType.I4;
			}
		}

		ILInstruction DecodeInstruction()
		{
			if (reader.RemainingBytes == 0)
				return new InvalidBranch("Unexpected end of body");
			var opCode = ILParser.DecodeOpCode(ref reader);
			switch (opCode)
			{
				case ILOpCode.Constrained:
					return DecodeConstrainedCall();
				case ILOpCode.Readonly:
					return DecodeReadonly();
				case ILOpCode.Tail:
					return DecodeTailCall();
				case ILOpCode.Unaligned:
					return DecodeUnaligned();
				case ILOpCode.Volatile:
					return DecodeVolatile();
				case ILOpCode.Add:
					return BinaryNumeric(BinaryNumericOperator.Add);
				case ILOpCode.Add_ovf:
					return BinaryNumeric(BinaryNumericOperator.Add, true, Sign.Signed);
				case ILOpCode.Add_ovf_un:
					return BinaryNumeric(BinaryNumericOperator.Add, true, Sign.Unsigned);
				case ILOpCode.And:
					return BinaryNumeric(BinaryNumericOperator.BitAnd);
				case ILOpCode.Arglist:
					return Push(new Arglist());
				case ILOpCode.Beq:
					return DecodeComparisonBranch(opCode, ComparisonKind.Equality);
				case ILOpCode.Beq_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.Equality);
				case ILOpCode.Bge:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual);
				case ILOpCode.Bge_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual);
				case ILOpCode.Bge_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual, un: true);
				case ILOpCode.Bge_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual, un: true);
				case ILOpCode.Bgt:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan);
				case ILOpCode.Bgt_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan);
				case ILOpCode.Bgt_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan, un: true);
				case ILOpCode.Bgt_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan, un: true);
				case ILOpCode.Ble:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual);
				case ILOpCode.Ble_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual);
				case ILOpCode.Ble_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual, un: true);
				case ILOpCode.Ble_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual, un: true);
				case ILOpCode.Blt:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan);
				case ILOpCode.Blt_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan);
				case ILOpCode.Blt_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan, un: true);
				case ILOpCode.Blt_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan, un: true);
				case ILOpCode.Bne_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.Inequality, un: true);
				case ILOpCode.Bne_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.Inequality, un: true);
				case ILOpCode.Br:
					return DecodeUnconditionalBranch(opCode);
				case ILOpCode.Br_s:
					return DecodeUnconditionalBranch(opCode);
				case ILOpCode.Break:
					return new DebugBreak();
				case ILOpCode.Brfalse:
					return DecodeConditionalBranch(opCode, true);
				case ILOpCode.Brfalse_s:
					return DecodeConditionalBranch(opCode, true);
				case ILOpCode.Brtrue:
					return DecodeConditionalBranch(opCode, false);
				case ILOpCode.Brtrue_s:
					return DecodeConditionalBranch(opCode, false);
				case ILOpCode.Call:
					return DecodeCall(OpCode.Call);
				case ILOpCode.Callvirt:
					return DecodeCall(OpCode.CallVirt);
				case ILOpCode.Calli:
					return DecodeCallIndirect();
				case ILOpCode.Ceq:
					return Push(Comparison(ComparisonKind.Equality));
				case ILOpCode.Cgt:
					return Push(Comparison(ComparisonKind.GreaterThan));
				case ILOpCode.Cgt_un:
					return Push(Comparison(ComparisonKind.GreaterThan, un: true));
				case ILOpCode.Clt:
					return Push(Comparison(ComparisonKind.LessThan));
				case ILOpCode.Clt_un:
					return Push(Comparison(ComparisonKind.LessThan, un: true));
				case ILOpCode.Ckfinite:
					return new Ckfinite(Peek());
				case ILOpCode.Conv_i1:
					return Push(new Conv(Pop(), PrimitiveType.I1, false, Sign.None));
				case ILOpCode.Conv_i2:
					return Push(new Conv(Pop(), PrimitiveType.I2, false, Sign.None));
				case ILOpCode.Conv_i4:
					return Push(new Conv(Pop(), PrimitiveType.I4, false, Sign.None));
				case ILOpCode.Conv_i8:
					return Push(new Conv(Pop(), PrimitiveType.I8, false, Sign.None));
				case ILOpCode.Conv_r4:
					return Push(new Conv(Pop(), PrimitiveType.R4, false, Sign.Signed));
				case ILOpCode.Conv_r8:
					return Push(new Conv(Pop(), PrimitiveType.R8, false, Sign.Signed));
				case ILOpCode.Conv_u1:
					return Push(new Conv(Pop(), PrimitiveType.U1, false, Sign.None));
				case ILOpCode.Conv_u2:
					return Push(new Conv(Pop(), PrimitiveType.U2, false, Sign.None));
				case ILOpCode.Conv_u4:
					return Push(new Conv(Pop(), PrimitiveType.U4, false, Sign.None));
				case ILOpCode.Conv_u8:
					return Push(new Conv(Pop(), PrimitiveType.U8, false, Sign.None));
				case ILOpCode.Conv_i:
					return Push(new Conv(Pop(), PrimitiveType.I, false, Sign.None));
				case ILOpCode.Conv_u:
					return Push(new Conv(Pop(), PrimitiveType.U, false, Sign.None));
				case ILOpCode.Conv_r_un:
					return Push(new Conv(Pop(), PrimitiveType.R, false, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i1:
					return Push(new Conv(Pop(), PrimitiveType.I1, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i2:
					return Push(new Conv(Pop(), PrimitiveType.I2, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i4:
					return Push(new Conv(Pop(), PrimitiveType.I4, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i8:
					return Push(new Conv(Pop(), PrimitiveType.I8, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u1:
					return Push(new Conv(Pop(), PrimitiveType.U1, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u2:
					return Push(new Conv(Pop(), PrimitiveType.U2, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u4:
					return Push(new Conv(Pop(), PrimitiveType.U4, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u8:
					return Push(new Conv(Pop(), PrimitiveType.U8, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i:
					return Push(new Conv(Pop(), PrimitiveType.I, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u:
					return Push(new Conv(Pop(), PrimitiveType.U, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i1_un:
					return Push(new Conv(Pop(), PrimitiveType.I1, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i2_un:
					return Push(new Conv(Pop(), PrimitiveType.I2, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i4_un:
					return Push(new Conv(Pop(), PrimitiveType.I4, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i8_un:
					return Push(new Conv(Pop(), PrimitiveType.I8, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u1_un:
					return Push(new Conv(Pop(), PrimitiveType.U1, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u2_un:
					return Push(new Conv(Pop(), PrimitiveType.U2, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u4_un:
					return Push(new Conv(Pop(), PrimitiveType.U4, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u8_un:
					return Push(new Conv(Pop(), PrimitiveType.U8, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i_un:
					return Push(new Conv(Pop(), PrimitiveType.I, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u_un:
					return Push(new Conv(Pop(), PrimitiveType.U, true, Sign.Unsigned));
				case ILOpCode.Cpblk:
					return new Cpblk(size: Pop(StackType.I4), sourceAddress: PopPointer(), destAddress: PopPointer());
				case ILOpCode.Div:
					return BinaryNumeric(BinaryNumericOperator.Div, false, Sign.Signed);
				case ILOpCode.Div_un:
					return BinaryNumeric(BinaryNumericOperator.Div, false, Sign.Unsigned);
				case ILOpCode.Dup:
					return Push(Peek());
				case ILOpCode.Endfilter:
					return new Leave(null, Pop());
				case ILOpCode.Endfinally:
					return new Leave(null);
				case ILOpCode.Initblk:
					return new Initblk(size: Pop(StackType.I4), value: Pop(StackType.I4), address: PopPointer());
				case ILOpCode.Jmp:
					return DecodeJmp();
				case ILOpCode.Ldarg:
				case ILOpCode.Ldarg_s:
					return Push(Ldarg(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Ldarg_0:
					return Push(Ldarg(0));
				case ILOpCode.Ldarg_1:
					return Push(Ldarg(1));
				case ILOpCode.Ldarg_2:
					return Push(Ldarg(2));
				case ILOpCode.Ldarg_3:
					return Push(Ldarg(3));
				case ILOpCode.Ldarga:
				case ILOpCode.Ldarga_s:
					return Push(Ldarga(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Ldc_i4:
					return Push(new LdcI4(reader.ReadInt32()));
				case ILOpCode.Ldc_i8:
					return Push(new LdcI8(reader.ReadInt64()));
				case ILOpCode.Ldc_r4:
					return Push(new LdcF4(reader.ReadSingle()));
				case ILOpCode.Ldc_r8:
					return Push(new LdcF8(reader.ReadDouble()));
				case ILOpCode.Ldc_i4_m1:
					return Push(new LdcI4(-1));
				case ILOpCode.Ldc_i4_0:
					return Push(new LdcI4(0));
				case ILOpCode.Ldc_i4_1:
					return Push(new LdcI4(1));
				case ILOpCode.Ldc_i4_2:
					return Push(new LdcI4(2));
				case ILOpCode.Ldc_i4_3:
					return Push(new LdcI4(3));
				case ILOpCode.Ldc_i4_4:
					return Push(new LdcI4(4));
				case ILOpCode.Ldc_i4_5:
					return Push(new LdcI4(5));
				case ILOpCode.Ldc_i4_6:
					return Push(new LdcI4(6));
				case ILOpCode.Ldc_i4_7:
					return Push(new LdcI4(7));
				case ILOpCode.Ldc_i4_8:
					return Push(new LdcI4(8));
				case ILOpCode.Ldc_i4_s:
					return Push(new LdcI4(reader.ReadSByte()));
				case ILOpCode.Ldnull:
					return Push(new LdNull());
				case ILOpCode.Ldstr:
					return Push(DecodeLdstr());
				case ILOpCode.Ldftn:
					return Push(new LdFtn(ReadAndDecodeMethodReference()));
				case ILOpCode.Ldind_i1:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.SByte)));
				case ILOpCode.Ldind_i2:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Int16)));
				case ILOpCode.Ldind_i4:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Int32)));
				case ILOpCode.Ldind_i8:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Int64)));
				case ILOpCode.Ldind_u1:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Byte)));
				case ILOpCode.Ldind_u2:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.UInt16)));
				case ILOpCode.Ldind_u4:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.UInt32)));
				case ILOpCode.Ldind_r4:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Single)));
				case ILOpCode.Ldind_r8:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Double)));
				case ILOpCode.Ldind_i:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.IntPtr)));
				case ILOpCode.Ldind_ref:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Object)));
				case ILOpCode.Ldloc:
				case ILOpCode.Ldloc_s:
					return Push(Ldloc(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Ldloc_0:
					return Push(Ldloc(0));
				case ILOpCode.Ldloc_1:
					return Push(Ldloc(1));
				case ILOpCode.Ldloc_2:
					return Push(Ldloc(2));
				case ILOpCode.Ldloc_3:
					return Push(Ldloc(3));
				case ILOpCode.Ldloca:
				case ILOpCode.Ldloca_s:
					return Push(Ldloca(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Leave:
					return DecodeUnconditionalBranch(opCode, isLeave: true);
				case ILOpCode.Leave_s:
					return DecodeUnconditionalBranch(opCode, isLeave: true);
				case ILOpCode.Localloc:
					return Push(new LocAlloc(Pop()));
				case ILOpCode.Mul:
					return BinaryNumeric(BinaryNumericOperator.Mul, false, Sign.None);
				case ILOpCode.Mul_ovf:
					return BinaryNumeric(BinaryNumericOperator.Mul, true, Sign.Signed);
				case ILOpCode.Mul_ovf_un:
					return BinaryNumeric(BinaryNumericOperator.Mul, true, Sign.Unsigned);
				case ILOpCode.Neg:
					return Neg();
				case ILOpCode.Newobj:
					return DecodeCall(OpCode.NewObj);
				case ILOpCode.Nop:
					return new Nop();
				case ILOpCode.Not:
					return Push(new BitNot(Pop()));
				case ILOpCode.Or:
					return BinaryNumeric(BinaryNumericOperator.BitOr);
				case ILOpCode.Pop:
					Pop();
					return new Nop() { Kind = NopKind.Pop };
				case ILOpCode.Rem:
					return BinaryNumeric(BinaryNumericOperator.Rem, false, Sign.Signed);
				case ILOpCode.Rem_un:
					return BinaryNumeric(BinaryNumericOperator.Rem, false, Sign.Unsigned);
				case ILOpCode.Ret:
					return Return();
				case ILOpCode.Shl:
					return BinaryNumeric(BinaryNumericOperator.ShiftLeft, false, Sign.None);
				case ILOpCode.Shr:
					return BinaryNumeric(BinaryNumericOperator.ShiftRight, false, Sign.Signed);
				case ILOpCode.Shr_un:
					return BinaryNumeric(BinaryNumericOperator.ShiftRight, false, Sign.Unsigned);
				case ILOpCode.Starg:
				case ILOpCode.Starg_s:
					return Starg(ILParser.DecodeIndex(ref reader, opCode));
				case ILOpCode.Stind_i1:
					return new StObj(value: Pop(StackType.I4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.SByte));
				case ILOpCode.Stind_i2:
					return new StObj(value: Pop(StackType.I4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Int16));
				case ILOpCode.Stind_i4:
					return new StObj(value: Pop(StackType.I4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Int32));
				case ILOpCode.Stind_i8:
					return new StObj(value: Pop(StackType.I8), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Int64));
				case ILOpCode.Stind_r4:
					return new StObj(value: Pop(StackType.F4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Single));
				case ILOpCode.Stind_r8:
					return new StObj(value: Pop(StackType.F8), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Double));
				case ILOpCode.Stind_i:
					return new StObj(value: Pop(StackType.I), target: PopPointer(), type: compilation.FindType(KnownTypeCode.IntPtr));
				case ILOpCode.Stind_ref:
					return new StObj(value: Pop(StackType.O), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Object));
				case ILOpCode.Stloc:
				case ILOpCode.Stloc_s:
					return Stloc(ILParser.DecodeIndex(ref reader, opCode));
				case ILOpCode.Stloc_0:
					return Stloc(0);
				case ILOpCode.Stloc_1:
					return Stloc(1);
				case ILOpCode.Stloc_2:
					return Stloc(2);
				case ILOpCode.Stloc_3:
					return Stloc(3);
				case ILOpCode.Sub:
					return BinaryNumeric(BinaryNumericOperator.Sub, false, Sign.None);
				case ILOpCode.Sub_ovf:
					return BinaryNumeric(BinaryNumericOperator.Sub, true, Sign.Signed);
				case ILOpCode.Sub_ovf_un:
					return BinaryNumeric(BinaryNumericOperator.Sub, true, Sign.Unsigned);
				case ILOpCode.Switch:
					return DecodeSwitch();
				case ILOpCode.Xor:
					return BinaryNumeric(BinaryNumericOperator.BitXor);
				case ILOpCode.Box:
				{
					var type = ReadAndDecodeTypeReference();
					return Push(new Box(Pop(type.GetStackType()), type));
				}
				case ILOpCode.Castclass:
					return Push(new CastClass(Pop(StackType.O), ReadAndDecodeTypeReference()));
				case ILOpCode.Cpobj:
				{
					var type = ReadAndDecodeTypeReference();
					var ld = new LdObj(PopPointer(), type);
					return new StObj(PopPointer(), ld, type);
				}
				case ILOpCode.Initobj:
					return InitObj(PopPointer(), ReadAndDecodeTypeReference());
				case ILOpCode.Isinst:
					return Push(new IsInst(Pop(StackType.O), ReadAndDecodeTypeReference()));
				case ILOpCode.Ldelem:
					return LdElem(ReadAndDecodeTypeReference());
				case ILOpCode.Ldelem_i1:
					return LdElem(compilation.FindType(KnownTypeCode.SByte));
				case ILOpCode.Ldelem_i2:
					return LdElem(compilation.FindType(KnownTypeCode.Int16));
				case ILOpCode.Ldelem_i4:
					return LdElem(compilation.FindType(KnownTypeCode.Int32));
				case ILOpCode.Ldelem_i8:
					return LdElem(compilation.FindType(KnownTypeCode.Int64));
				case ILOpCode.Ldelem_u1:
					return LdElem(compilation.FindType(KnownTypeCode.Byte));
				case ILOpCode.Ldelem_u2:
					return LdElem(compilation.FindType(KnownTypeCode.UInt16));
				case ILOpCode.Ldelem_u4:
					return LdElem(compilation.FindType(KnownTypeCode.UInt32));
				case ILOpCode.Ldelem_r4:
					return LdElem(compilation.FindType(KnownTypeCode.Single));
				case ILOpCode.Ldelem_r8:
					return LdElem(compilation.FindType(KnownTypeCode.Double));
				case ILOpCode.Ldelem_i:
					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));
				case ILOpCode.Ldelem_ref:
					return LdElem(compilation.FindType(KnownTypeCode.Object));
				case ILOpCode.Ldelema:
					return Push(new LdElema(indices: Pop(), array: Pop(), type: ReadAndDecodeTypeReference()));
				case ILOpCode.Ldfld:
				{
					var field = ReadAndDecodeFieldReference();
					return Push(new LdObj(new LdFlda(PopLdFldTarget(field), field) { DelayExceptions = true }, field.Type));
				}
				case ILOpCode.Ldflda:
				{
					var field = ReadAndDecodeFieldReference();
					return Push(new LdFlda(PopFieldTarget(field), field));
				}
				case ILOpCode.Stfld:
				{
					var field = ReadAndDecodeFieldReference();
					return new StObj(value: Pop(field.Type.GetStackType()), target: new LdFlda(PopFieldTarget(field), field) { DelayExceptions = true }, type: field.Type);
				}
				case ILOpCode.Ldlen:
					return Push(new LdLen(StackType.I, Pop(StackType.O)));
				case ILOpCode.Ldobj:
					return Push(new LdObj(PopPointer(), ReadAndDecodeTypeReference()));
				case ILOpCode.Ldsfld:
				{
					var field = ReadAndDecodeFieldReference();
					return Push(new LdObj(new LdsFlda(field), field.Type));
				}
				case ILOpCode.Ldsflda:
					return Push(new LdsFlda(ReadAndDecodeFieldReference()));
				case ILOpCode.Stsfld:
				{
					var field = ReadAndDecodeFieldReference();
					return new StObj(value: Pop(field.Type.GetStackType()), target: new LdsFlda(field), type: field.Type);
				}
				case ILOpCode.Ldtoken:
					return Push(LdToken(ReadAndDecodeMetadataToken()));
				case ILOpCode.Ldvirtftn:
					return Push(new LdVirtFtn(Pop(), ReadAndDecodeMethodReference()));
				case ILOpCode.Mkrefany:
					return Push(new MakeRefAny(PopPointer(), ReadAndDecodeTypeReference()));
				case ILOpCode.Newarr:
					return Push(new NewArr(ReadAndDecodeTypeReference(), Pop()));
				case ILOpCode.Refanytype:
					return Push(new RefAnyType(Pop()));
				case ILOpCode.Refanyval:
					return Push(new RefAnyValue(Pop(), ReadAndDecodeTypeReference()));
				case ILOpCode.Rethrow:
					return new Rethrow();
				case ILOpCode.Sizeof:
					return Push(new SizeOf(ReadAndDecodeTypeReference()));
				case ILOpCode.Stelem:
					return StElem(ReadAndDecodeTypeReference());
				case ILOpCode.Stelem_i1:
					return StElem(compilation.FindType(KnownTypeCode.SByte));
				case ILOpCode.Stelem_i2:
					return StElem(compilation.FindType(KnownTypeCode.Int16));
				case ILOpCode.Stelem_i4:
					return StElem(compilation.FindType(KnownTypeCode.Int32));
				case ILOpCode.Stelem_i8:
					return StElem(compilation.FindType(KnownTypeCode.Int64));
				case ILOpCode.Stelem_r4:
					return StElem(compilation.FindType(KnownTypeCode.Single));
				case ILOpCode.Stelem_r8:
					return StElem(compilation.FindType(KnownTypeCode.Double));
				case ILOpCode.Stelem_i:
					return StElem(compilation.FindType(KnownTypeCode.IntPtr));
				case ILOpCode.Stelem_ref:
					return StElem(compilation.FindType(KnownTypeCode.Object));
				case ILOpCode.Stobj:
				{
					var type = ReadAndDecodeTypeReference();
					return new StObj(value: Pop(type.GetStackType()), target: PopPointer(), type: type);
				}
				case ILOpCode.Throw:
					return new Throw(Pop());
				case ILOpCode.Unbox:
					return Push(new Unbox(Pop(), ReadAndDecodeTypeReference()));
				case ILOpCode.Unbox_any:
					return Push(new UnboxAny(Pop(), ReadAndDecodeTypeReference()));
				default:
					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");
			}
		}

		StackType PeekStackType()
		{
			if (currentStack.IsEmpty)
				return StackType.Unknown;
			else
				return currentStack.Peek().StackType;
		}

		class CollectStackVariablesVisitor : ILVisitor<ILInstruction>
		{
			readonly UnionFind<ILVariable> unionFind;
			internal readonly HashSet<ILVariable> variables = new HashSet<ILVariable>();

			public CollectStackVariablesVisitor(UnionFind<ILVariable> unionFind)
			{
				Debug.Assert(unionFind != null);
				this.unionFind = unionFind;
			}

			protected override ILInstruction Default(ILInstruction inst)
			{
				foreach (var child in inst.Children)
				{
					var newChild = child.AcceptVisitor(this);
					if (newChild != child)
						child.ReplaceWith(newChild);
				}
				return inst;
			}

			protected internal override ILInstruction VisitLdLoc(LdLoc inst)
			{
				base.VisitLdLoc(inst);
				if (inst.Variable.Kind == VariableKind.StackSlot)
				{
					var variable = unionFind.Find(inst.Variable);
					if (variables.Add(variable))
						variable.Name = "S_" + (variables.Count - 1);
					return new LdLoc(variable).WithILRange(inst);
				}
				return inst;
			}

			protected internal override ILInstruction VisitStLoc(StLoc inst)
			{
				base.VisitStLoc(inst);
				if (inst.Variable.Kind == VariableKind.StackSlot)
				{
					var variable = unionFind.Find(inst.Variable);
					if (variables.Add(variable))
						variable.Name = "S_" + (variables.Count - 1);
					return new StLoc(variable, inst.Value).WithILRange(inst);
				}
				return inst;
			}
		}

		ILInstruction Push(ILInstruction inst)
		{
			Debug.Assert(inst.ResultType != StackType.Void);
			IType type = compilation.FindType(inst.ResultType.ToKnownTypeCode());
			var v = new ILVariable(VariableKind.StackSlot, type, inst.ResultType);
			v.HasGeneratedName = true;
			currentStack = currentStack.Push(v);
			return new StLoc(v, inst);
		}

		ILInstruction Peek()
		{
			if (currentStack.IsEmpty)
			{
				return new InvalidExpression("Stack underflow").WithILRange(new Interval(reader.Offset, reader.Offset));
			}
			return new LdLoc(currentStack.Peek());
		}

		ILInstruction Pop()
		{
			if (currentStack.IsEmpty)
			{
				return new InvalidExpression("Stack underflow").WithILRange(new Interval(reader.Offset, reader.Offset));
			}
			ILVariable v;
			currentStack = currentStack.Pop(out v);
			return new LdLoc(v);
		}

		ILInstruction Pop(StackType expectedType)
		{
			ILInstruction inst = Pop();
			return Cast(inst, expectedType, Warnings, reader.Offset);
		}

		internal static ILInstruction Cast(ILInstruction inst, StackType expectedType, List<string> warnings, int ilOffset)
		{
			if (expectedType != inst.ResultType)
			{
				if (inst is InvalidExpression)
				{
					((InvalidExpression)inst).ExpectedResultType = expectedType;
				}
				else if (expectedType == StackType.I && inst.ResultType == StackType.I4)
				{
					// IL allows implicit I4->I conversions
					inst = new Conv(inst, PrimitiveType.I, false, Sign.None);
				}
				else if (expectedType == StackType.I4 && inst.ResultType == StackType.I)
				{
					// C++/CLI also sometimes implicitly converts in the other direction:
					inst = new Conv(inst, PrimitiveType.I4, false, Sign.None);
				}
				else if (expectedType == StackType.Unknown)
				{
					inst = new Conv(inst, PrimitiveType.Unknown, false, Sign.None);
				}
				else if (inst.ResultType == StackType.Ref)
				{
					// Implicitly stop GC tracking; this occurs when passing the result of 'ldloca' or 'ldsflda'
					// to a method expecting a native pointer.
					inst = new Conv(inst, PrimitiveType.I, false, Sign.None);
					switch (expectedType)
					{
						case StackType.I4:
							inst = new Conv(inst, PrimitiveType.I4, false, Sign.None);
							break;
						case StackType.I:
							break;
						case StackType.I8:
							inst = new Conv(inst, PrimitiveType.I8, false, Sign.None);
							break;
						default:
							Warn($"Expected {expectedType}, but got {StackType.Ref}");
							inst = new Conv(inst, expectedType.ToPrimitiveType(), false, Sign.None);
							break;
					}
				}
				else if (expectedType == StackType.Ref)
				{
					// implicitly start GC tracking / object to interior
					if (!inst.ResultType.IsIntegerType() && inst.ResultType != StackType.O)
					{
						// We also handle the invalid to-ref cases here because the else case
						// below uses expectedType.ToKnownTypeCode(), which doesn't work for Ref.
						Warn($"Expected {expectedType}, but got {inst.ResultType}");
					}
					inst = new Conv(inst, PrimitiveType.Ref, false, Sign.None);
				}
				else if (expectedType == StackType.F8 && inst.ResultType == StackType.F4)
				{
					// IL allows implicit F4->F8 conversions, because in IL F4 and F8 are the same.
					inst = new Conv(inst, PrimitiveType.R8, false, Sign.Signed);
				}
				else if (expectedType == StackType.F4 && inst.ResultType == StackType.F8)
				{
					// IL allows implicit F8->F4 conversions, because in IL F4 and F8 are the same.
					inst = new Conv(inst, PrimitiveType.R4, false, Sign.Signed);
				}
				else
				{
					Warn($"Expected {expectedType}, but got {inst.ResultType}");
					inst = new Conv(inst, expectedType.ToPrimitiveType(), false, Sign.Signed);
				}
			}
			return inst;

			void Warn(string message)
			{
				if (warnings != null)
				{
					warnings.Add(string.Format("IL_{0:x4}: {1}", ilOffset, message));
				}
			}
		}

		ILInstruction PopPointer()
		{
			ILInstruction inst = Pop();
			switch (inst.ResultType)
			{
				case StackType.I4:
				case StackType.I8:
				case StackType.Unknown:
					return new Conv(inst, PrimitiveType.I, false, Sign.None);
				case StackType.I:
				case StackType.Ref:
					return inst;
				default:
					Warn("Expected native int or pointer, but got " + inst.ResultType);
					return new Conv(inst, PrimitiveType.I, false, Sign.None);
			}
		}

		ILInstruction PopFieldTarget(IField field)
		{
			switch (field.DeclaringType.IsReferenceType)
			{
				case true:
					return Pop(StackType.O);
				case false:
					return PopPointer();
				default:
					// field in unresolved type
					var stackType = PeekStackType();
					if (stackType == StackType.O || stackType == StackType.Unknown)
						return Pop();
					else
						return PopPointer();
			}
		}

		/// <summary>
		/// Like PopFieldTarget, but supports ldfld's special behavior for fields of temporary value types.
		/// </summary>
		ILInstruction PopLdFldTarget(IField field)
		{
			switch (field.DeclaringType.IsReferenceType)
			{
				case true:
					return Pop(StackType.O);
				case false:
					// field of value type: ldfld can handle temporaries
					if (PeekStackType() == StackType.O || PeekStackType() == StackType.Unknown)
						return new AddressOf(Pop(), field.DeclaringType);
					else
						return PopPointer();
				default:
					// field in unresolved type
					if (PeekStackType() == StackType.O || PeekStackType() == StackType.Unknown)
						return Pop();
					else
						return PopPointer();
			}
		}

		private ILInstruction Return()
		{
			if (methodReturnStackType == StackType.Void)
				return new IL.Leave(mainContainer);
			else
				return new IL.Leave(mainContainer, Pop(methodReturnStackType));
		}

		private ILInstruction DecodeLdstr()
		{
			return new LdStr(ILParser.DecodeUserString(ref reader, metadata));
		}

		private ILInstruction Ldarg(int v)
		{
			if (v >= 0 && v < parameterVariables.Length)
			{
				return new LdLoc(parameterVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldarg {v} (out-of-bounds)");
			}
		}

		private ILInstruction Ldarga(int v)
		{
			if (v >= 0 && v < parameterVariables.Length)
			{
				return new LdLoca(parameterVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldarga {v} (out-of-bounds)");
			}
		}

		private ILInstruction Starg(int v)
		{
			if (v >= 0 && v < parameterVariables.Length)
			{
				return new StLoc(parameterVariables[v], Pop(parameterVariables[v].StackType));
			}
			else
			{
				Pop();
				return new InvalidExpression($"starg {v} (out-of-bounds)");
			}
		}

		private ILInstruction Ldloc(int v)
		{
			if (v >= 0 && v < localVariables.Length)
			{
				return new LdLoc(localVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldloc {v} (out-of-bounds)");
			}
		}

		private ILInstruction Ldloca(int v)
		{
			if (v >= 0 && v < localVariables.Length)
			{
				return new LdLoca(localVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldloca {v} (out-of-bounds)");
			}
		}

		private ILInstruction Stloc(int v)
		{
			if (v >= 0 && v < localVariables.Length)
			{
				return new StLoc(localVariables[v], Pop(localVariables[v].StackType)) {
					ILStackWasEmpty = currentStack.IsEmpty
				};
			}
			else
			{
				Pop();
				return new InvalidExpression($"stloc {v} (out-of-bounds)");
			}
		}

		private ILInstruction LdElem(IType type)
		{
			return Push(new LdObj(new LdElema(indices: Pop(), array: Pop(), type: type) { DelayExceptions = true }, type));
		}

		private ILInstruction StElem(IType type)
		{
			var value = Pop(type.GetStackType());
			var index = Pop();
			var array = Pop();
			return new StObj(new LdElema(type, array, index) { DelayExceptions = true }, value, type);
		}

		ILInstruction InitObj(ILInstruction target, IType type)
		{
			var value = new DefaultValue(type);
			value.ILStackWasEmpty = currentStack.IsEmpty;
			return new StObj(target, value, type);
		}

		IType constrainedPrefix;

		private ILInstruction DecodeConstrainedCall()
		{
			constrainedPrefix = ReadAndDecodeTypeReference();
			var inst = DecodeInstruction();
			var call = UnpackPush(inst) as CallInstruction;
			if (call != null)
				Debug.Assert(call.ConstrainedTo == constrainedPrefix);
			else
				Warn("Ignored invalid 'constrained' prefix");
			constrainedPrefix = null;
			return inst;
		}

		private ILInstruction DecodeTailCall()
		{
			var inst = DecodeInstruction();
			var call = UnpackPush(inst) as CallInstruction;
			if (call != null)
				call.IsTail = true;
			else
				Warn("Ignored invalid 'tail' prefix");
			return inst;
		}

		private ILInstruction DecodeUnaligned()
		{
			byte alignment = reader.ReadByte();
			var inst = DecodeInstruction();
			var sup = UnpackPush(inst) as ISupportsUnalignedPrefix;
			if (sup != null)
				sup.UnalignedPrefix = alignment;
			else
				Warn("Ignored invalid 'unaligned' prefix");
			return inst;
		}

		private ILInstruction DecodeVolatile()
		{
			var inst = DecodeInstruction();
			var svp = UnpackPush(inst) as ISupportsVolatilePrefix;
			if (svp != null)
				svp.IsVolatile = true;
			else
				Warn("Ignored invalid 'volatile' prefix");
			return inst;
		}

		private ILInstruction DecodeReadonly()
		{
			var inst = DecodeInstruction();
			var ldelema = UnpackPush(inst) as LdElema;
			if (ldelema != null)
				ldelema.IsReadOnly = true;
			else
				Warn("Ignored invalid 'readonly' prefix");
			return inst;
		}

		ILInstruction DecodeCall(OpCode opCode)
		{
			var method = ReadAndDecodeMethodReference();
			int firstArgument = (opCode != OpCode.NewObj && !method.IsStatic) ? 1 : 0;
			var arguments = new ILInstruction[firstArgument + method.Parameters.Count];
			for (int i = method.Parameters.Count - 1; i >= 0; i--)
			{
				arguments[firstArgument + i] = Pop(method.Parameters[i].Type.GetStackType());
			}
			if (firstArgument == 1)
			{
				arguments[0] = Pop(CallInstruction.ExpectedTypeForThisPointer(constrainedPrefix ?? method.DeclaringType));
			}
			switch (method.DeclaringType.Kind)
			{
				case TypeKind.Array:
				{
					var elementType = ((ArrayType)method.DeclaringType).ElementType;
					if (opCode == OpCode.NewObj)
						return Push(new NewArr(elementType, arguments));
					if (method.Name == "Set")
					{
						var target = arguments[0];
						var value = arguments.Last();
						var indices = arguments.Skip(1).Take(arguments.Length - 2).ToArray();
						return new StObj(new LdElema(elementType, target, indices) { DelayExceptions = true }, value, elementType);
					}
					if (method.Name == "Get")
					{
						var target = arguments[0];
						var indices = arguments.Skip(1).ToArray();
						return Push(new LdObj(new LdElema(elementType, target, indices) { DelayExceptions = true }, elementType));
					}
					if (method.Name == "Address")
					{
						var target = arguments[0];
						var indices = arguments.Skip(1).ToArray();
						return Push(new LdElema(elementType, target, indices));
					}
					Warn("Unknown method called on array type: " + method.Name);
					goto default;
				}
				case TypeKind.Struct when method.IsConstructor && !method.IsStatic && opCode == OpCode.Call
					&& method.ReturnType.Kind == TypeKind.Void:
				{
					// "call Struct.ctor(target, ...)" doesn't exist in C#,
					// the next best equivalent is an assignment `*target = new Struct(...);`.
					// So we represent this call as "stobj Struct(target, newobj Struct.ctor(...))".
					// This needs to happen early (not as a transform) because the StObj.TargetSlot has
					// restricted inlining (doesn't accept ldflda when exceptions aren't delayed).
					var newobj = new NewObj(method);
					newobj.ILStackWasEmpty = currentStack.IsEmpty;
					newobj.ConstrainedTo = constrainedPrefix;
					newobj.Arguments.AddRange(arguments.Skip(1));
					return new StObj(arguments[0], newobj, method.DeclaringType);
				}
				default:
					var call = CallInstruction.Create(opCode, method);
					call.ILStackWasEmpty = currentStack.IsEmpty;
					call.ConstrainedTo = constrainedPrefix;
					call.Arguments.AddRange(arguments);
					if (call.ResultType != StackType.Void)
						return Push(call);
					return call;
			}
		}

		ILInstruction DecodeCallIndirect()
		{
			var signatureHandle = (StandaloneSignatureHandle)ReadAndDecodeMetadataToken();
			var (header, fpt) = module.DecodeMethodSignature(signatureHandle, genericContext);
			var functionPointer = Pop(StackType.I);
			int firstArgument = header.IsInstance ? 1 : 0;
			var arguments = new ILInstruction[firstArgument + fpt.ParameterTypes.Length];
			for (int i = fpt.ParameterTypes.Length - 1; i >= 0; i--)
			{
				arguments[firstArgument + i] = Pop(fpt.ParameterTypes[i].GetStackType());
			}
			if (firstArgument == 1)
			{
				arguments[0] = Pop();
			}
			var call = new CallIndirect(
				header.IsInstance,
				header.HasExplicitThis,
				fpt,
				functionPointer,
				arguments
			);
			if (call.ResultType != StackType.Void)
				return Push(call);
			else
				return call;
		}

		ILInstruction Comparison(ComparisonKind kind, bool un = false)
		{
			var right = Pop();
			var left = Pop();

			if ((left.ResultType == StackType.O || left.ResultType == StackType.Ref) && right.ResultType.IsIntegerType())
			{
				// C++/CLI sometimes compares object references with integers.
				// Also happens with Ref==I in Unsafe.IsNullRef().
				if (right.ResultType == StackType.I4)
				{
					// ensure we compare at least native integer size
					right = new Conv(right, PrimitiveType.I, false, Sign.None);
				}
				left = new Conv(left, right.ResultType.ToPrimitiveType(), false, Sign.None);
			}
			else if ((right.ResultType == StackType.O || right.ResultType == StackType.Ref) && left.ResultType.IsIntegerType())
			{
				if (left.ResultType == StackType.I4)
				{
					left = new Conv(left, PrimitiveType.I, false, Sign.None);
				}
				right = new Conv(right, left.ResultType.ToPrimitiveType(), false, Sign.None);
			}

			// make implicit integer conversions explicit:
			MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I, conversionType: PrimitiveType.I);
			MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I8, conversionType: PrimitiveType.I8);
			MakeExplicitConversion(sourceType: StackType.I, targetType: StackType.I8, conversionType: PrimitiveType.I8);

			// Based on Table 4: Binary Comparison or Branch Operation
			if (left.ResultType.IsFloatType() && right.ResultType.IsFloatType())
			{
				if (left.ResultType != right.ResultType)
				{
					// make the implicit F4->F8 conversion explicit:
					MakeExplicitConversion(StackType.F4, StackType.F8, PrimitiveType.R8);
				}
				if (un)
				{
					// for floats, 'un' means 'unordered'
					return Comp.LogicNot(new Comp(kind.Negate(), Sign.None, left, right));
				}
				else
				{
					return new Comp(kind, Sign.None, left, right);
				}
			}
			else if (left.ResultType.IsIntegerType() && right.ResultType.IsIntegerType() && !kind.IsEqualityOrInequality())
			{
				// integer comparison where the sign matters
				Debug.Assert(right.ResultType.IsIntegerType());
				return new Comp(kind, un ? Sign.Unsigned : Sign.Signed, left, right);
			}
			else if (left.ResultType == right.ResultType)
			{
				// integer equality, object reference or managed reference comparison
				return new Comp(kind, Sign.None, left, right);
			}
			else
			{
				Warn($"Invalid comparison between {left.ResultType} and {right.ResultType}");
				if (left.ResultType < right.ResultType)
				{
					left = new Conv(left, right.ResultType.ToPrimitiveType(), false, Sign.Signed);
				}
				else
				{
					right = new Conv(right, left.ResultType.ToPrimitiveType(), false, Sign.Signed);
				}
				return new Comp(kind, Sign.None, left, right);
			}

			void MakeExplicitConversion(StackType sourceType, StackType targetType, PrimitiveType conversionType)
			{
				if (left.ResultType == sourceType && right.ResultType == targetType)
				{
					left = new Conv(left, conversionType, false, Sign.None);
				}
				else if (left.ResultType == targetType && right.ResultType == sourceType)
				{
					right = new Conv(right, conversionType, false, Sign.None);
				}
			}
		}

		bool IsInvalidBranch(int target) => target < 0 || target >= reader.Length;

		ILInstruction DecodeComparisonBranch(ILOpCode opCode, ComparisonKind kind, bool un = false)
		{
			int start = reader.Offset - 1; // opCode is always one byte in this case
			int target = ILParser.DecodeBranchTarget(ref reader, opCode);
			var condition = Comparison(kind, un);
			condition.AddILRange(new Interval(start, reader.Offset));
			if (!IsInvalidBranch(target))
			{
				MarkBranchTarget(target);
				return new IfInstruction(condition, new Branch(target));
			}
			else
			{
				return new IfInstruction(condition, new InvalidBranch("Invalid branch target"));
			}
		}

		ILInstruction DecodeConditionalBranch(ILOpCode opCode, bool negate)
		{
			int target = ILParser.DecodeBranchTarget(ref reader, opCode);
			ILInstruction condition = Pop();
			switch (condition.ResultType)
			{
				case StackType.O:
					// introduce explicit comparison with null
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, condition, new LdNull());
					break;
				case StackType.I:
					// introduce explicit comparison with 0
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, condition, new Conv(new LdcI4(0), PrimitiveType.I, false, Sign.None));
					break;
				case StackType.I8:
					// introduce explicit comparison with 0
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, condition, new LdcI8(0));
					break;
				case StackType.Ref:
					// introduce explicit comparison with null ref
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, new Conv(condition, PrimitiveType.I, false, Sign.None), new Conv(new LdcI4(0), PrimitiveType.I, false, Sign.None));
					break;
				case StackType.I4:
					if (negate)
					{
						condition = Comp.LogicNot(condition);
					}
					break;
				default:
					condition = new Conv(condition, PrimitiveType.I4, false, Sign.None);
					if (negate)
					{
						condition = Comp.LogicNot(condition);
					}
					break;
			}
			if (!IsInvalidBranch(target))
			{
				MarkBranchTarget(target);
				return new IfInstruction(condition, new Branch(target));
			}
			else
			{
				return new IfInstruction(condition, new InvalidBranch("Invalid branch target"));
			}
		}

		ILInstruction DecodeUnconditionalBranch(ILOpCode opCode, bool isLeave = false)
		{
			int target = ILParser.DecodeBranchTarget(ref reader, opCode);
			if (isLeave)
			{
				currentStack = currentStack.Clear();
			}
			if (!IsInvalidBranch(target))
			{
				MarkBranchTarget(target);
				return new Branch(target);
			}
			else
			{
				return new InvalidBranch("Invalid branch target");
			}
		}

		void MarkBranchTarget(int targetILOffset)
		{
			isBranchTarget[targetILOffset] = true;
			StoreStackForOffset(targetILOffset, ref currentStack);
		}

		ILInstruction DecodeSwitch()
		{
			var targets = ILParser.DecodeSwitchTargets(ref reader);
			var instr = new SwitchInstruction(Pop(StackType.I4));

			for (int i = 0; i < targets.Length; i++)
			{
				var section = new SwitchSection();
				section.Labels = new LongSet(i);
				int target = targets[i];
				if (!IsInvalidBranch(target))
				{
					MarkBranchTarget(target);
					section.Body = new Branch(target);
				}
				else
				{
					section.Body = new InvalidBranch("Invalid branch target");
				}
				instr.Sections.Add(section);
			}
			var defaultSection = new SwitchSection();
			defaultSection.Labels = new LongSet(new LongInterval(0, targets.Length)).Invert();
			defaultSection.Body = new Nop();
			instr.Sections.Add(defaultSection);
			return instr;
		}

		ILInstruction BinaryNumeric(BinaryNumericOperator @operator, bool checkForOverflow = false, Sign sign = Sign.None)
		{
			var right = Pop();
			var left = Pop();
			if (@operator != BinaryNumericOperator.Add && @operator != BinaryNumericOperator.Sub)
			{
				// we are treating all Refs as I, make the conversion explicit
				if (left.ResultType == StackType.Ref)
				{
					left = new Conv(left, PrimitiveType.I, false, Sign.None);
				}
				if (right.ResultType == StackType.Ref)
				{
					right = new Conv(right, PrimitiveType.I, false, Sign.None);
				}
			}
			if (@operator != BinaryNumericOperator.ShiftLeft && @operator != BinaryNumericOperator.ShiftRight)
			{
				// make the implicit I4->I conversion explicit:
				MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I, conversionType: PrimitiveType.I);
				// I4->I8 conversion:
				MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I8, conversionType: PrimitiveType.I8);
				// I->I8 conversion:
				MakeExplicitConversion(sourceType: StackType.I, targetType: StackType.I8, conversionType: PrimitiveType.I8);
				// F4->F8 conversion:
				MakeExplicitConversion(sourceType: StackType.F4, targetType: StackType.F8, conversionType: PrimitiveType.R8);
			}
			return Push(new BinaryNumericInstruction(@operator, left, right, checkForOverflow, sign));

			void MakeExplicitConversion(StackType sourceType, StackType targetType, PrimitiveType conversionType)
			{
				if (left.ResultType == sourceType && right.ResultType == targetType)
				{
					left = new Conv(left, conversionType, false, Sign.None);
				}
				else if (left.ResultType == targetType && right.ResultType == sourceType)
				{
					right = new Conv(right, conversionType, false, Sign.None);
				}
			}
		}

		ILInstruction DecodeJmp()
		{
			IMethod method = ReadAndDecodeMethodReference();
			// Translate jmp into tail call:
			Call call = new Call(method);
			call.IsTail = true;
			call.ILStackWasEmpty = true;
			if (!method.IsStatic)
			{
				call.Arguments.Add(Ldarg(0));
			}
			foreach (var p in method.Parameters)
			{
				call.Arguments.Add(Ldarg(call.Arguments.Count));
			}
			return new Leave(mainContainer, call);
		}

		ILInstruction LdToken(EntityHandle token)
		{
			if (token.Kind.IsTypeKind())
				return new LdTypeToken(module.ResolveType(token, genericContext));
			if (token.Kind.IsMemberKind())
			{
				var entity = module.ResolveEntity(token, genericContext);
				if (entity is IMember member)
					return new LdMemberToken(member);
			}
			throw new BadImageFormatException("Invalid metadata token for ldtoken instruction.");
		}
	}
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Reflection.Metadata.Ecma335;
using System.Threading;

using ICSharpCode.Decompiler.Disassembler;
using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.Util;

using ArrayType = ICSharpCode.Decompiler.TypeSystem.ArrayType;
using ByReferenceType = ICSharpCode.Decompiler.TypeSystem.ByReferenceType;
using PinnedType = ICSharpCode.Decompiler.TypeSystem.Implementation.PinnedType;

namespace ICSharpCode.Decompiler.IL
{
	/// <summary>
	/// Reads IL bytecodes and converts them into ILAst instructions.
	/// </summary>
	/// <remarks>
	/// Instances of this class are not thread-safe. Use separate instances to decompile multiple members in parallel.
	/// </remarks>
	public class ILReader
	{
		readonly ICompilation compilation;
		readonly MetadataModule module;
		readonly MetadataReader metadata;

		public bool UseDebugSymbols { get; set; }
		public DebugInfo.IDebugInfoProvider DebugInfo { get; set; }
		public List<string> Warnings { get; } = new List<string>();

		// List of candidate locations for sequence points. Includes empty il stack locations, any nop instructions, and the instruction following
		// a call instruction. 
		public List<int> SequencePointCandidates { get; private set; }

		/// <summary>
		/// Creates a new ILReader instance.
		/// </summary>
		/// <param name="module">
		/// The module used to resolve metadata tokens in the type system.
		/// </param>
		public ILReader(MetadataModule module)
		{
			if (module == null)
				throw new ArgumentNullException(nameof(module));
			this.module = module;
			this.compilation = module.Compilation;
			this.metadata = module.metadata;
			this.SequencePointCandidates = new List<int>();
		}

		GenericContext genericContext;
		IMethod method;
		MethodBodyBlock body;
		StackType methodReturnStackType;
		BlobReader reader;
		ImmutableStack<ILVariable> currentStack;
		ILVariable[] parameterVariables;
		ILVariable[] localVariables;
		BitArray isBranchTarget;
		BlockContainer mainContainer;
		List<ILInstruction> instructionBuilder;
		int currentInstructionStart;

		// Dictionary that stores stacks for each IL instruction
		Dictionary<int, ImmutableStack<ILVariable>> stackByOffset;
		Dictionary<ExceptionRegion, ILVariable> variableByExceptionHandler;
		UnionFind<ILVariable> unionFind;
		List<(ILVariable, ILVariable)> stackMismatchPairs;
		IEnumerable<ILVariable> stackVariables;

		void Init(MethodDefinitionHandle methodDefinitionHandle, MethodBodyBlock body, GenericContext genericContext)
		{
			if (body == null)
				throw new ArgumentNullException(nameof(body));
			if (methodDefinitionHandle.IsNil)
				throw new ArgumentException("methodDefinitionHandle.IsNil");
			this.method = module.GetDefinition(methodDefinitionHandle);
			if (genericContext.ClassTypeParameters == null && genericContext.MethodTypeParameters == null)
			{
				// no generic context specified: use the method's own type parameters
				genericContext = new GenericContext(method);
			}
			else
			{
				// generic context specified, so specialize the method for it:
				this.method = this.method.Specialize(genericContext.ToSubstitution());
			}
			this.genericContext = genericContext;
			this.body = body;
			this.reader = body.GetILReader();
			this.currentStack = ImmutableStack<ILVariable>.Empty;
			this.unionFind = new UnionFind<ILVariable>();
			this.stackMismatchPairs = new List<(ILVariable, ILVariable)>();
			this.methodReturnStackType = method.ReturnType.GetStackType();
			InitParameterVariables();
			localVariables = InitLocalVariables();
			if (body.LocalVariablesInitialized)
			{
				foreach (var v in localVariables)
				{
					v.HasInitialValue = true;
				}
			}
			this.mainContainer = new BlockContainer(expectedResultType: methodReturnStackType);
			this.instructionBuilder = new List<ILInstruction>();
			this.isBranchTarget = new BitArray(reader.Length);
			this.stackByOffset = new Dictionary<int, ImmutableStack<ILVariable>>();
			this.variableByExceptionHandler = new Dictionary<ExceptionRegion, ILVariable>();
		}

		EntityHandle ReadAndDecodeMetadataToken()
		{
			int token = reader.ReadInt32();
			if (token <= 0)
			{
				// SRM uses negative tokens as "virtual tokens" and can get confused
				// if we manually create them.
				// Row-IDs < 1 are always invalid.
				throw new BadImageFormatException("Invalid metadata token");
			}
			return MetadataTokens.EntityHandle(token);
		}

		IType ReadAndDecodeTypeReference()
		{
			var typeReference = ReadAndDecodeMetadataToken();
			return module.ResolveType(typeReference, genericContext);
		}

		IMethod ReadAndDecodeMethodReference()
		{
			var methodReference = ReadAndDecodeMetadataToken();
			return module.ResolveMethod(methodReference, genericContext);
		}

		IField ReadAndDecodeFieldReference()
		{
			var fieldReference = ReadAndDecodeMetadataToken();
			var f = module.ResolveEntity(fieldReference, genericContext) as IField;
			if (f == null)
				throw new BadImageFormatException("Invalid field token");
			return f;
		}

		ILVariable[] InitLocalVariables()
		{
			if (body.LocalSignature.IsNil)
				return Empty<ILVariable>.Array;
			ImmutableArray<IType> variableTypes;
			try
			{
				variableTypes = module.DecodeLocalSignature(body.LocalSignature, genericContext);
			}
			catch (BadImageFormatException ex)
			{
				Warnings.Add("Error decoding local variables: " + ex.Message);
				variableTypes = ImmutableArray<IType>.Empty;
			}
			var localVariables = new ILVariable[variableTypes.Length];
			foreach (var (index, type) in variableTypes.WithIndex())
			{
				localVariables[index] = CreateILVariable(index, type);
			}
			return localVariables;
		}

		void InitParameterVariables()
		{
			int popCount = method.Parameters.Count;
			if (!method.IsStatic)
				popCount++;
			if (method.Parameters.LastOrDefault()?.Type == SpecialType.ArgList)
				popCount--;
			parameterVariables = new ILVariable[popCount];
			int paramIndex = 0;
			int offset = 0;
			if (!method.IsStatic)
			{
				offset = 1;
				IType declaringType = method.DeclaringType;
				if (declaringType.IsUnbound())
				{
					// If method is a definition (and not specialized), the declaring type is also just a definition,
					// and needs to be converted into a normally usable type.
					declaringType = new ParameterizedType(declaringType, declaringType.TypeParameters);
				}
				ILVariable ilVar = CreateILVariable(-1, declaringType, "this");
				ilVar.IsRefReadOnly = method.ThisIsRefReadOnly;
				parameterVariables[paramIndex++] = ilVar;
			}
			while (paramIndex < parameterVariables.Length)
			{
				IParameter parameter = method.Parameters[paramIndex - offset];
				ILVariable ilVar = CreateILVariable(paramIndex - offset, parameter.Type, parameter.Name);
				ilVar.IsRefReadOnly = parameter.IsIn;
				parameterVariables[paramIndex] = ilVar;
				paramIndex++;
			}
			Debug.Assert(paramIndex == parameterVariables.Length);
		}

		ILVariable CreateILVariable(int index, IType type)
		{
			VariableKind kind;
			if (type.SkipModifiers() is PinnedType pinned)
			{
				kind = VariableKind.PinnedLocal;
				type = pinned.ElementType;
			}
			else
			{
				kind = VariableKind.Local;
			}
			ILVariable ilVar = new ILVariable(kind, type, index);
			if (!UseDebugSymbols || DebugInfo == null || !DebugInfo.TryGetName((MethodDefinitionHandle)method.MetadataToken, index, out string name))
			{
				ilVar.Name = "V_" + index;
				ilVar.HasGeneratedName = true;
			}
			else if (string.IsNullOrWhiteSpace(name))
			{
				ilVar.Name = "V_" + index;
				ilVar.HasGeneratedName = true;
			}
			else
			{
				ilVar.Name = name;
			}
			return ilVar;
		}

		ILVariable CreateILVariable(int index, IType parameterType, string name)
		{
			Debug.Assert(!parameterType.IsUnbound());
			ITypeDefinition def = parameterType.GetDefinition();
			if (def != null && index < 0 && def.IsReferenceType == false)
			{
				parameterType = new ByReferenceType(parameterType);
			}
			var ilVar = new ILVariable(VariableKind.Parameter, parameterType, index);
			Debug.Assert(ilVar.StoreCount == 1); // count the initial store when the method is called with an argument
			if (index < 0)
				ilVar.Name = "this";
			else if (string.IsNullOrEmpty(name))
				ilVar.Name = "P_" + index;
			else
				ilVar.Name = name;
			return ilVar;
		}

		/// <summary>
		/// Warn when invalid IL is detected.
		/// ILSpy should be able to handle invalid IL; but this method can be helpful for debugging the ILReader,
		/// as this method should not get called when processing valid IL.
		/// </summary>
		void Warn(string message)
		{
			Warnings.Add(string.Format("IL_{0:x4}: {1}", currentInstructionStart, message));
		}

		ImmutableStack<ILVariable> MergeStacks(ImmutableStack<ILVariable> a, ImmutableStack<ILVariable> b)
		{
			if (CheckStackCompatibleWithoutAdjustments(a, b))
			{
				// We only need to union the input variables, but can 
				// otherwise re-use the existing stack.
				ImmutableStack<ILVariable> output = a;
				while (!a.IsEmpty && !b.IsEmpty)
				{
					Debug.Assert(a.Peek().StackType == b.Peek().StackType);
					unionFind.Merge(a.Peek(), b.Peek());
					a = a.Pop();
					b = b.Pop();
				}
				return output;
			}
			else if (a.Count != b.Count)
			{
				// Let's not try to merge mismatched stacks.
				Warn("Incompatible stack heights: " + a.Count + " vs " + b.Count);
				return a;
			}
			else
			{
				// The more complex case where the stacks don't match exactly.
				var output = new List<ILVariable>();
				while (!a.IsEmpty && !b.IsEmpty)
				{
					var varA = a.Peek();
					var varB = b.Peek();
					if (varA.StackType == varB.StackType)
					{
						unionFind.Merge(varA, varB);
						output.Add(varA);
					}
					else
					{
						if (!IsValidTypeStackTypeMerge(varA.StackType, varB.StackType))
						{
							Warn("Incompatible stack types: " + varA.StackType + " vs " + varB.StackType);
						}
						if (varA.StackType > varB.StackType)
						{
							output.Add(varA);
							// every store to varB should also store to varA
							stackMismatchPairs.Add((varB, varA));
						}
						else
						{
							output.Add(varB);
							// every store to varA should also store to varB
							stackMismatchPairs.Add((varA, varB));
						}
					}
					a = a.Pop();
					b = b.Pop();
				}
				// because we built up output by popping from the input stacks, we need to reverse it to get back the original order
				output.Reverse();
				return ImmutableStack.CreateRange(output);
			}
		}

		static bool CheckStackCompatibleWithoutAdjustments(ImmutableStack<ILVariable> a, ImmutableStack<ILVariable> b)
		{
			while (!a.IsEmpty && !b.IsEmpty)
			{
				if (a.Peek().StackType != b.Peek().StackType)
					return false;
				a = a.Pop();
				b = b.Pop();
			}
			return a.IsEmpty && b.IsEmpty;
		}

		private bool IsValidTypeStackTypeMerge(StackType stackType1, StackType stackType2)
		{
			if (stackType1 == StackType.I && stackType2 == StackType.I4)
				return true;
			if (stackType1 == StackType.I4 && stackType2 == StackType.I)
				return true;
			if (stackType1 == StackType.F4 && stackType2 == StackType.F8)
				return true;
			if (stackType1 == StackType.F8 && stackType2 == StackType.F4)
				return true;
			// allow merging unknown type with any other type
			return stackType1 == StackType.Unknown || stackType2 == StackType.Unknown;
		}

		/// <summary>
		/// Stores the given stack for a branch to `offset`.
		/// 
		/// The stack may be modified if stack adjustments are necessary. (e.g. implicit I4->I conversion)
		/// </summary>
		void StoreStackForOffset(int offset, ref ImmutableStack<ILVariable> stack)
		{
			if (stackByOffset.TryGetValue(offset, out var existing))
			{
				stack = MergeStacks(existing, stack);
				if (stack != existing)
					stackByOffset[offset] = stack;
			}
			else
			{
				stackByOffset.Add(offset, stack);
			}
		}

		void ReadInstructions(CancellationToken cancellationToken)
		{
			// Fill isBranchTarget and branchStackDict based on exception handlers
			foreach (var eh in body.ExceptionRegions)
			{
				ImmutableStack<ILVariable> ehStack = null;
				if (eh.Kind == ExceptionRegionKind.Catch)
				{
					var catchType = module.ResolveType(eh.CatchType, genericContext);
					var v = new ILVariable(VariableKind.ExceptionStackSlot, catchType, eh.HandlerOffset) {
						Name = "E_" + eh.HandlerOffset,
						HasGeneratedName = true
					};
					variableByExceptionHandler.Add(eh, v);
					ehStack = ImmutableStack.Create(v);
				}
				else if (eh.Kind == ExceptionRegionKind.Filter)
				{
					var v = new ILVariable(VariableKind.ExceptionStackSlot, compilation.FindType(KnownTypeCode.Object), eh.HandlerOffset) {
						Name = "E_" + eh.HandlerOffset,
						HasGeneratedName = true
					};
					variableByExceptionHandler.Add(eh, v);
					ehStack = ImmutableStack.Create(v);
				}
				else
				{
					ehStack = ImmutableStack<ILVariable>.Empty;
				}
				if (eh.FilterOffset != -1)
				{
					isBranchTarget[eh.FilterOffset] = true;
					StoreStackForOffset(eh.FilterOffset, ref ehStack);
				}
				if (eh.HandlerOffset != -1)
				{
					isBranchTarget[eh.HandlerOffset] = true;
					StoreStackForOffset(eh.HandlerOffset, ref ehStack);
				}
			}

			reader.Reset();
			while (reader.RemainingBytes > 0)
			{
				cancellationToken.ThrowIfCancellationRequested();
				int start = reader.Offset;
				StoreStackForOffset(start, ref currentStack);
				currentInstructionStart = start;
				bool startedWithEmptyStack = currentStack.IsEmpty;
				ILInstruction decodedInstruction;
				try
				{
					decodedInstruction = DecodeInstruction();
				}
				catch (BadImageFormatException ex)
				{
					decodedInstruction = new InvalidBranch(ex.Message);
				}
				if (decodedInstruction.ResultType == StackType.Unknown && decodedInstruction.OpCode != OpCode.InvalidBranch && UnpackPush(decodedInstruction).OpCode != OpCode.InvalidExpression)
					Warn("Unknown result type (might be due to invalid IL or missing references)");
				decodedInstruction.CheckInvariant(ILPhase.InILReader);
				int end = reader.Offset;
				decodedInstruction.AddILRange(new Interval(start, end));
				UnpackPush(decodedInstruction).AddILRange(decodedInstruction);
				instructionBuilder.Add(decodedInstruction);
				if (decodedInstruction.HasDirectFlag(InstructionFlags.EndPointUnreachable))
				{
					if (!stackByOffset.TryGetValue(end, out currentStack))
					{
						currentStack = ImmutableStack<ILVariable>.Empty;
					}
				}

				if (IsSequencePointInstruction(decodedInstruction) || startedWithEmptyStack)
				{
					this.SequencePointCandidates.Add(decodedInstruction.StartILOffset);
				}
			}

			var visitor = new CollectStackVariablesVisitor(unionFind);
			for (int i = 0; i < instructionBuilder.Count; i++)
			{
				instructionBuilder[i] = instructionBuilder[i].AcceptVisitor(visitor);
			}
			stackVariables = visitor.variables;
			InsertStackAdjustments();
		}

		private bool IsSequencePointInstruction(ILInstruction instruction)
		{
			if (instruction.OpCode == OpCode.Nop ||
				(this.instructionBuilder.Count > 0 &&
				this.instructionBuilder.Last().OpCode == OpCode.Call ||
				this.instructionBuilder.Last().OpCode == OpCode.CallIndirect ||
				this.instructionBuilder.Last().OpCode == OpCode.CallVirt))
			{

				return true;
			}
			else
			{
				return false;
			}
		}

		void InsertStackAdjustments()
		{
			if (stackMismatchPairs.Count == 0)
				return;
			var dict = new MultiDictionary<ILVariable, ILVariable>();
			foreach (var (origA, origB) in stackMismatchPairs)
			{
				var a = unionFind.Find(origA);
				var b = unionFind.Find(origB);
				Debug.Assert(a.StackType < b.StackType);
				// For every store to a, insert a converting store to b.
				if (!dict[a].Contains(b))
					dict.Add(a, b);
			}
			var newInstructions = new List<ILInstruction>();
			foreach (var inst in instructionBuilder)
			{
				newInstructions.Add(inst);
				if (inst is StLoc store)
				{
					foreach (var additionalVar in dict[store.Variable])
					{
						ILInstruction value = new LdLoc(store.Variable);
						value = new Conv(value, additionalVar.StackType.ToPrimitiveType(), false, Sign.Signed);
						newInstructions.Add(new StLoc(additionalVar, value) {
							IsStackAdjustment = true,
						}.WithILRange(inst));
					}
				}
			}
			instructionBuilder = newInstructions;
		}

		/// <summary>
		/// Debugging helper: writes the decoded instruction stream interleaved with the inferred evaluation stack layout.
		/// </summary>
		public void WriteTypedIL(MethodDefinitionHandle method, MethodBodyBlock body,
			ITextOutput output, GenericContext genericContext = default, CancellationToken cancellationToken = default)
		{
			Init(method, body, genericContext);
			ReadInstructions(cancellationToken);
			foreach (var inst in instructionBuilder)
			{
				if (inst is StLoc stloc && stloc.IsStackAdjustment)
				{
					output.Write("          ");
					inst.WriteTo(output, new ILAstWritingOptions());
					output.WriteLine();
					continue;
				}
				output.Write("   [");
				bool isFirstElement = true;
				foreach (var element in stackByOffset[inst.StartILOffset])
				{
					if (isFirstElement)
						isFirstElement = false;
					else
						output.Write(", ");
					output.WriteLocalReference(element.Name, element);
					output.Write(":");
					output.Write(element.StackType);
				}
				output.Write(']');
				output.WriteLine();
				if (isBranchTarget[inst.StartILOffset])
					output.Write('*');
				else
					output.Write(' ');
				output.WriteLocalReference("IL_" + inst.StartILOffset.ToString("x4"), inst.StartILOffset, isDefinition: true);
				output.Write(": ");
				inst.WriteTo(output, new ILAstWritingOptions());
				output.WriteLine();
			}
			new Disassembler.MethodBodyDisassembler(output, cancellationToken) { DetectControlStructure = false }
				.WriteExceptionHandlers(module.PEFile, method, body);
		}

		/// <summary>
		/// Decodes the specified method body and returns an ILFunction.
		/// </summary>
		public ILFunction ReadIL(MethodDefinitionHandle method, MethodBodyBlock body, GenericContext genericContext = default, ILFunctionKind kind = ILFunctionKind.TopLevelFunction, CancellationToken cancellationToken = default)
		{
			cancellationToken.ThrowIfCancellationRequested();
			Init(method, body, genericContext);
			ReadInstructions(cancellationToken);
			var blockBuilder = new BlockBuilder(body, variableByExceptionHandler);
			blockBuilder.CreateBlocks(mainContainer, instructionBuilder, isBranchTarget, cancellationToken);
			var function = new ILFunction(this.method, body.GetCodeSize(), this.genericContext, mainContainer, kind);
			function.Variables.AddRange(parameterVariables);
			function.Variables.AddRange(localVariables);
			function.Variables.AddRange(stackVariables);
			function.Variables.AddRange(variableByExceptionHandler.Values);
			function.AddRef(); // mark the root node
			var removedBlocks = new List<Block>();
			foreach (var c in function.Descendants.OfType<BlockContainer>())
			{
				var newOrder = c.TopologicalSort(deleteUnreachableBlocks: true);
				if (newOrder.Count < c.Blocks.Count)
				{
					removedBlocks.AddRange(c.Blocks.Except(newOrder));
				}
				c.Blocks.ReplaceList(newOrder);
			}
			if (removedBlocks.Count > 0)
			{
				removedBlocks.SortBy(b => b.StartILOffset);
				function.Warnings.Add("Discarded unreachable code: "
							+ string.Join(", ", removedBlocks.Select(b => $"IL_{b.StartILOffset:x4}")));
			}

			this.SequencePointCandidates.Sort();
			function.SequencePointCandidates = this.SequencePointCandidates;

			function.Warnings.AddRange(Warnings);
			return function;
		}

		static ILInstruction UnpackPush(ILInstruction inst)
		{
			ILVariable v;
			ILInstruction inner;
			if (inst.MatchStLoc(out v, out inner) && v.Kind == VariableKind.StackSlot)
				return inner;
			else
				return inst;
		}

		ILInstruction Neg()
		{
			switch (PeekStackType())
			{
				case StackType.I4:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcI4(0), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.I:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new Conv(new LdcI4(0), PrimitiveType.I, false, Sign.None), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.I8:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcI8(0), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.F4:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcF4(0), Pop(), checkForOverflow: false, sign: Sign.None));
				case StackType.F8:
					return Push(new BinaryNumericInstruction(BinaryNumericOperator.Sub, new LdcF8(0), Pop(), checkForOverflow: false, sign: Sign.None));
				default:
					Warn("Unsupported input type for neg.");
					goto case StackType.I4;
			}
		}

		ILInstruction DecodeInstruction()
		{
			if (reader.RemainingBytes == 0)
				return new InvalidBranch("Unexpected end of body");
			var opCode = ILParser.DecodeOpCode(ref reader);
			switch (opCode)
			{
				case ILOpCode.Constrained:
					return DecodeConstrainedCall();
				case ILOpCode.Readonly:
					return DecodeReadonly();
				case ILOpCode.Tail:
					return DecodeTailCall();
				case ILOpCode.Unaligned:
					return DecodeUnaligned();
				case ILOpCode.Volatile:
					return DecodeVolatile();
				case ILOpCode.Add:
					return BinaryNumeric(BinaryNumericOperator.Add);
				case ILOpCode.Add_ovf:
					return BinaryNumeric(BinaryNumericOperator.Add, true, Sign.Signed);
				case ILOpCode.Add_ovf_un:
					return BinaryNumeric(BinaryNumericOperator.Add, true, Sign.Unsigned);
				case ILOpCode.And:
					return BinaryNumeric(BinaryNumericOperator.BitAnd);
				case ILOpCode.Arglist:
					return Push(new Arglist());
				case ILOpCode.Beq:
					return DecodeComparisonBranch(opCode, ComparisonKind.Equality);
				case ILOpCode.Beq_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.Equality);
				case ILOpCode.Bge:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual);
				case ILOpCode.Bge_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual);
				case ILOpCode.Bge_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual, un: true);
				case ILOpCode.Bge_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThanOrEqual, un: true);
				case ILOpCode.Bgt:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan);
				case ILOpCode.Bgt_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan);
				case ILOpCode.Bgt_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan, un: true);
				case ILOpCode.Bgt_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.GreaterThan, un: true);
				case ILOpCode.Ble:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual);
				case ILOpCode.Ble_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual);
				case ILOpCode.Ble_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual, un: true);
				case ILOpCode.Ble_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThanOrEqual, un: true);
				case ILOpCode.Blt:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan);
				case ILOpCode.Blt_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan);
				case ILOpCode.Blt_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan, un: true);
				case ILOpCode.Blt_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.LessThan, un: true);
				case ILOpCode.Bne_un:
					return DecodeComparisonBranch(opCode, ComparisonKind.Inequality, un: true);
				case ILOpCode.Bne_un_s:
					return DecodeComparisonBranch(opCode, ComparisonKind.Inequality, un: true);
				case ILOpCode.Br:
					return DecodeUnconditionalBranch(opCode);
				case ILOpCode.Br_s:
					return DecodeUnconditionalBranch(opCode);
				case ILOpCode.Break:
					return new DebugBreak();
				case ILOpCode.Brfalse:
					return DecodeConditionalBranch(opCode, true);
				case ILOpCode.Brfalse_s:
					return DecodeConditionalBranch(opCode, true);
				case ILOpCode.Brtrue:
					return DecodeConditionalBranch(opCode, false);
				case ILOpCode.Brtrue_s:
					return DecodeConditionalBranch(opCode, false);
				case ILOpCode.Call:
					return DecodeCall(OpCode.Call);
				case ILOpCode.Callvirt:
					return DecodeCall(OpCode.CallVirt);
				case ILOpCode.Calli:
					return DecodeCallIndirect();
				case ILOpCode.Ceq:
					return Push(Comparison(ComparisonKind.Equality));
				case ILOpCode.Cgt:
					return Push(Comparison(ComparisonKind.GreaterThan));
				case ILOpCode.Cgt_un:
					return Push(Comparison(ComparisonKind.GreaterThan, un: true));
				case ILOpCode.Clt:
					return Push(Comparison(ComparisonKind.LessThan));
				case ILOpCode.Clt_un:
					return Push(Comparison(ComparisonKind.LessThan, un: true));
				case ILOpCode.Ckfinite:
					return new Ckfinite(Peek());
				case ILOpCode.Conv_i1:
					return Push(new Conv(Pop(), PrimitiveType.I1, false, Sign.None));
				case ILOpCode.Conv_i2:
					return Push(new Conv(Pop(), PrimitiveType.I2, false, Sign.None));
				case ILOpCode.Conv_i4:
					return Push(new Conv(Pop(), PrimitiveType.I4, false, Sign.None));
				case ILOpCode.Conv_i8:
					return Push(new Conv(Pop(), PrimitiveType.I8, false, Sign.None));
				case ILOpCode.Conv_r4:
					return Push(new Conv(Pop(), PrimitiveType.R4, false, Sign.Signed));
				case ILOpCode.Conv_r8:
					return Push(new Conv(Pop(), PrimitiveType.R8, false, Sign.Signed));
				case ILOpCode.Conv_u1:
					return Push(new Conv(Pop(), PrimitiveType.U1, false, Sign.None));
				case ILOpCode.Conv_u2:
					return Push(new Conv(Pop(), PrimitiveType.U2, false, Sign.None));
				case ILOpCode.Conv_u4:
					return Push(new Conv(Pop(), PrimitiveType.U4, false, Sign.None));
				case ILOpCode.Conv_u8:
					return Push(new Conv(Pop(), PrimitiveType.U8, false, Sign.None));
				case ILOpCode.Conv_i:
					return Push(new Conv(Pop(), PrimitiveType.I, false, Sign.None));
				case ILOpCode.Conv_u:
					return Push(new Conv(Pop(), PrimitiveType.U, false, Sign.None));
				case ILOpCode.Conv_r_un:
					return Push(new Conv(Pop(), PrimitiveType.R, false, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i1:
					return Push(new Conv(Pop(), PrimitiveType.I1, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i2:
					return Push(new Conv(Pop(), PrimitiveType.I2, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i4:
					return Push(new Conv(Pop(), PrimitiveType.I4, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i8:
					return Push(new Conv(Pop(), PrimitiveType.I8, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u1:
					return Push(new Conv(Pop(), PrimitiveType.U1, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u2:
					return Push(new Conv(Pop(), PrimitiveType.U2, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u4:
					return Push(new Conv(Pop(), PrimitiveType.U4, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u8:
					return Push(new Conv(Pop(), PrimitiveType.U8, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i:
					return Push(new Conv(Pop(), PrimitiveType.I, true, Sign.Signed));
				case ILOpCode.Conv_ovf_u:
					return Push(new Conv(Pop(), PrimitiveType.U, true, Sign.Signed));
				case ILOpCode.Conv_ovf_i1_un:
					return Push(new Conv(Pop(), PrimitiveType.I1, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i2_un:
					return Push(new Conv(Pop(), PrimitiveType.I2, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i4_un:
					return Push(new Conv(Pop(), PrimitiveType.I4, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i8_un:
					return Push(new Conv(Pop(), PrimitiveType.I8, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u1_un:
					return Push(new Conv(Pop(), PrimitiveType.U1, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u2_un:
					return Push(new Conv(Pop(), PrimitiveType.U2, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u4_un:
					return Push(new Conv(Pop(), PrimitiveType.U4, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u8_un:
					return Push(new Conv(Pop(), PrimitiveType.U8, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_i_un:
					return Push(new Conv(Pop(), PrimitiveType.I, true, Sign.Unsigned));
				case ILOpCode.Conv_ovf_u_un:
					return Push(new Conv(Pop(), PrimitiveType.U, true, Sign.Unsigned));
				case ILOpCode.Cpblk:
					return new Cpblk(size: Pop(StackType.I4), sourceAddress: PopPointer(), destAddress: PopPointer());
				case ILOpCode.Div:
					return BinaryNumeric(BinaryNumericOperator.Div, false, Sign.Signed);
				case ILOpCode.Div_un:
					return BinaryNumeric(BinaryNumericOperator.Div, false, Sign.Unsigned);
				case ILOpCode.Dup:
					return Push(Peek());
				case ILOpCode.Endfilter:
					return new Leave(null, Pop());
				case ILOpCode.Endfinally:
					return new Leave(null);
				case ILOpCode.Initblk:
					return new Initblk(size: Pop(StackType.I4), value: Pop(StackType.I4), address: PopPointer());
				case ILOpCode.Jmp:
					return DecodeJmp();
				case ILOpCode.Ldarg:
				case ILOpCode.Ldarg_s:
					return Push(Ldarg(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Ldarg_0:
					return Push(Ldarg(0));
				case ILOpCode.Ldarg_1:
					return Push(Ldarg(1));
				case ILOpCode.Ldarg_2:
					return Push(Ldarg(2));
				case ILOpCode.Ldarg_3:
					return Push(Ldarg(3));
				case ILOpCode.Ldarga:
				case ILOpCode.Ldarga_s:
					return Push(Ldarga(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Ldc_i4:
					return Push(new LdcI4(reader.ReadInt32()));
				case ILOpCode.Ldc_i8:
					return Push(new LdcI8(reader.ReadInt64()));
				case ILOpCode.Ldc_r4:
					return Push(new LdcF4(reader.ReadSingle()));
				case ILOpCode.Ldc_r8:
					return Push(new LdcF8(reader.ReadDouble()));
				case ILOpCode.Ldc_i4_m1:
					return Push(new LdcI4(-1));
				case ILOpCode.Ldc_i4_0:
					return Push(new LdcI4(0));
				case ILOpCode.Ldc_i4_1:
					return Push(new LdcI4(1));
				case ILOpCode.Ldc_i4_2:
					return Push(new LdcI4(2));
				case ILOpCode.Ldc_i4_3:
					return Push(new LdcI4(3));
				case ILOpCode.Ldc_i4_4:
					return Push(new LdcI4(4));
				case ILOpCode.Ldc_i4_5:
					return Push(new LdcI4(5));
				case ILOpCode.Ldc_i4_6:
					return Push(new LdcI4(6));
				case ILOpCode.Ldc_i4_7:
					return Push(new LdcI4(7));
				case ILOpCode.Ldc_i4_8:
					return Push(new LdcI4(8));
				case ILOpCode.Ldc_i4_s:
					return Push(new LdcI4(reader.ReadSByte()));
				case ILOpCode.Ldnull:
					return Push(new LdNull());
				case ILOpCode.Ldstr:
					return Push(DecodeLdstr());
				case ILOpCode.Ldftn:
					return Push(new LdFtn(ReadAndDecodeMethodReference()));
				case ILOpCode.Ldind_i1:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.SByte)));
				case ILOpCode.Ldind_i2:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Int16)));
				case ILOpCode.Ldind_i4:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Int32)));
				case ILOpCode.Ldind_i8:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Int64)));
				case ILOpCode.Ldind_u1:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Byte)));
				case ILOpCode.Ldind_u2:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.UInt16)));
				case ILOpCode.Ldind_u4:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.UInt32)));
				case ILOpCode.Ldind_r4:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Single)));
				case ILOpCode.Ldind_r8:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Double)));
				case ILOpCode.Ldind_i:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.IntPtr)));
				case ILOpCode.Ldind_ref:
					return Push(new LdObj(PopPointer(), compilation.FindType(KnownTypeCode.Object)));
				case ILOpCode.Ldloc:
				case ILOpCode.Ldloc_s:
					return Push(Ldloc(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Ldloc_0:
					return Push(Ldloc(0));
				case ILOpCode.Ldloc_1:
					return Push(Ldloc(1));
				case ILOpCode.Ldloc_2:
					return Push(Ldloc(2));
				case ILOpCode.Ldloc_3:
					return Push(Ldloc(3));
				case ILOpCode.Ldloca:
				case ILOpCode.Ldloca_s:
					return Push(Ldloca(ILParser.DecodeIndex(ref reader, opCode)));
				case ILOpCode.Leave:
					return DecodeUnconditionalBranch(opCode, isLeave: true);
				case ILOpCode.Leave_s:
					return DecodeUnconditionalBranch(opCode, isLeave: true);
				case ILOpCode.Localloc:
					return Push(new LocAlloc(Pop()));
				case ILOpCode.Mul:
					return BinaryNumeric(BinaryNumericOperator.Mul, false, Sign.None);
				case ILOpCode.Mul_ovf:
					return BinaryNumeric(BinaryNumericOperator.Mul, true, Sign.Signed);
				case ILOpCode.Mul_ovf_un:
					return BinaryNumeric(BinaryNumericOperator.Mul, true, Sign.Unsigned);
				case ILOpCode.Neg:
					return Neg();
				case ILOpCode.Newobj:
					return DecodeCall(OpCode.NewObj);
				case ILOpCode.Nop:
					return new Nop();
				case ILOpCode.Not:
					return Push(new BitNot(Pop()));
				case ILOpCode.Or:
					return BinaryNumeric(BinaryNumericOperator.BitOr);
				case ILOpCode.Pop:
					Pop();
					return new Nop() { Kind = NopKind.Pop };
				case ILOpCode.Rem:
					return BinaryNumeric(BinaryNumericOperator.Rem, false, Sign.Signed);
				case ILOpCode.Rem_un:
					return BinaryNumeric(BinaryNumericOperator.Rem, false, Sign.Unsigned);
				case ILOpCode.Ret:
					return Return();
				case ILOpCode.Shl:
					return BinaryNumeric(BinaryNumericOperator.ShiftLeft, false, Sign.None);
				case ILOpCode.Shr:
					return BinaryNumeric(BinaryNumericOperator.ShiftRight, false, Sign.Signed);
				case ILOpCode.Shr_un:
					return BinaryNumeric(BinaryNumericOperator.ShiftRight, false, Sign.Unsigned);
				case ILOpCode.Starg:
				case ILOpCode.Starg_s:
					return Starg(ILParser.DecodeIndex(ref reader, opCode));
				case ILOpCode.Stind_i1:
					return new StObj(value: Pop(StackType.I4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.SByte));
				case ILOpCode.Stind_i2:
					return new StObj(value: Pop(StackType.I4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Int16));
				case ILOpCode.Stind_i4:
					return new StObj(value: Pop(StackType.I4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Int32));
				case ILOpCode.Stind_i8:
					return new StObj(value: Pop(StackType.I8), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Int64));
				case ILOpCode.Stind_r4:
					return new StObj(value: Pop(StackType.F4), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Single));
				case ILOpCode.Stind_r8:
					return new StObj(value: Pop(StackType.F8), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Double));
				case ILOpCode.Stind_i:
					return new StObj(value: Pop(StackType.I), target: PopPointer(), type: compilation.FindType(KnownTypeCode.IntPtr));
				case ILOpCode.Stind_ref:
					return new StObj(value: Pop(StackType.O), target: PopPointer(), type: compilation.FindType(KnownTypeCode.Object));
				case ILOpCode.Stloc:
				case ILOpCode.Stloc_s:
					return Stloc(ILParser.DecodeIndex(ref reader, opCode));
				case ILOpCode.Stloc_0:
					return Stloc(0);
				case ILOpCode.Stloc_1:
					return Stloc(1);
				case ILOpCode.Stloc_2:
					return Stloc(2);
				case ILOpCode.Stloc_3:
					return Stloc(3);
				case ILOpCode.Sub:
					return BinaryNumeric(BinaryNumericOperator.Sub, false, Sign.None);
				case ILOpCode.Sub_ovf:
					return BinaryNumeric(BinaryNumericOperator.Sub, true, Sign.Signed);
				case ILOpCode.Sub_ovf_un:
					return BinaryNumeric(BinaryNumericOperator.Sub, true, Sign.Unsigned);
				case ILOpCode.Switch:
					return DecodeSwitch();
				case ILOpCode.Xor:
					return BinaryNumeric(BinaryNumericOperator.BitXor);
				case ILOpCode.Box:
				{
					var type = ReadAndDecodeTypeReference();
					return Push(new Box(Pop(type.GetStackType()), type));
				}
				case ILOpCode.Castclass:
					return Push(new CastClass(Pop(StackType.O), ReadAndDecodeTypeReference()));
				case ILOpCode.Cpobj:
				{
					var type = ReadAndDecodeTypeReference();
					var ld = new LdObj(PopPointer(), type);
					return new StObj(PopPointer(), ld, type);
				}
				case ILOpCode.Initobj:
					return InitObj(PopPointer(), ReadAndDecodeTypeReference());
				case ILOpCode.Isinst:
					return Push(new IsInst(Pop(StackType.O), ReadAndDecodeTypeReference()));
				case ILOpCode.Ldelem:
					return LdElem(ReadAndDecodeTypeReference());
				case ILOpCode.Ldelem_i1:
					return LdElem(compilation.FindType(KnownTypeCode.SByte));
				case ILOpCode.Ldelem_i2:
					return LdElem(compilation.FindType(KnownTypeCode.Int16));
				case ILOpCode.Ldelem_i4:
					return LdElem(compilation.FindType(KnownTypeCode.Int32));
				case ILOpCode.Ldelem_i8:
					return LdElem(compilation.FindType(KnownTypeCode.Int64));
				case ILOpCode.Ldelem_u1:
					return LdElem(compilation.FindType(KnownTypeCode.Byte));
				case ILOpCode.Ldelem_u2:
					return LdElem(compilation.FindType(KnownTypeCode.UInt16));
				case ILOpCode.Ldelem_u4:
					return LdElem(compilation.FindType(KnownTypeCode.UInt32));
				case ILOpCode.Ldelem_r4:
					return LdElem(compilation.FindType(KnownTypeCode.Single));
				case ILOpCode.Ldelem_r8:
					return LdElem(compilation.FindType(KnownTypeCode.Double));
				case ILOpCode.Ldelem_i:
					return LdElem(compilation.FindType(KnownTypeCode.IntPtr));
				case ILOpCode.Ldelem_ref:
					return LdElem(compilation.FindType(KnownTypeCode.Object));
				case ILOpCode.Ldelema:
					return Push(new LdElema(indices: Pop(), array: Pop(), type: ReadAndDecodeTypeReference()));
				case ILOpCode.Ldfld:
				{
					var field = ReadAndDecodeFieldReference();
					return Push(new LdObj(new LdFlda(PopLdFldTarget(field), field) { DelayExceptions = true }, field.Type));
				}
				case ILOpCode.Ldflda:
				{
					var field = ReadAndDecodeFieldReference();
					return Push(new LdFlda(PopFieldTarget(field), field));
				}
				case ILOpCode.Stfld:
				{
					var field = ReadAndDecodeFieldReference();
					return new StObj(value: Pop(field.Type.GetStackType()), target: new LdFlda(PopFieldTarget(field), field) { DelayExceptions = true }, type: field.Type);
				}
				case ILOpCode.Ldlen:
					return Push(new LdLen(StackType.I, Pop(StackType.O)));
				case ILOpCode.Ldobj:
					return Push(new LdObj(PopPointer(), ReadAndDecodeTypeReference()));
				case ILOpCode.Ldsfld:
				{
					var field = ReadAndDecodeFieldReference();
					return Push(new LdObj(new LdsFlda(field), field.Type));
				}
				case ILOpCode.Ldsflda:
					return Push(new LdsFlda(ReadAndDecodeFieldReference()));
				case ILOpCode.Stsfld:
				{
					var field = ReadAndDecodeFieldReference();
					return new StObj(value: Pop(field.Type.GetStackType()), target: new LdsFlda(field), type: field.Type);
				}
				case ILOpCode.Ldtoken:
					return Push(LdToken(ReadAndDecodeMetadataToken()));
				case ILOpCode.Ldvirtftn:
					return Push(new LdVirtFtn(Pop(), ReadAndDecodeMethodReference()));
				case ILOpCode.Mkrefany:
					return Push(new MakeRefAny(PopPointer(), ReadAndDecodeTypeReference()));
				case ILOpCode.Newarr:
					return Push(new NewArr(ReadAndDecodeTypeReference(), Pop()));
				case ILOpCode.Refanytype:
					return Push(new RefAnyType(Pop()));
				case ILOpCode.Refanyval:
					return Push(new RefAnyValue(Pop(), ReadAndDecodeTypeReference()));
				case ILOpCode.Rethrow:
					return new Rethrow();
				case ILOpCode.Sizeof:
					return Push(new SizeOf(ReadAndDecodeTypeReference()));
				case ILOpCode.Stelem:
					return StElem(ReadAndDecodeTypeReference());
				case ILOpCode.Stelem_i1:
					return StElem(compilation.FindType(KnownTypeCode.SByte));
				case ILOpCode.Stelem_i2:
					return StElem(compilation.FindType(KnownTypeCode.Int16));
				case ILOpCode.Stelem_i4:
					return StElem(compilation.FindType(KnownTypeCode.Int32));
				case ILOpCode.Stelem_i8:
					return StElem(compilation.FindType(KnownTypeCode.Int64));
				case ILOpCode.Stelem_r4:
					return StElem(compilation.FindType(KnownTypeCode.Single));
				case ILOpCode.Stelem_r8:
					return StElem(compilation.FindType(KnownTypeCode.Double));
				case ILOpCode.Stelem_i:
					return StElem(compilation.FindType(KnownTypeCode.IntPtr));
				case ILOpCode.Stelem_ref:
					return StElem(compilation.FindType(KnownTypeCode.Object));
				case ILOpCode.Stobj:
				{
					var type = ReadAndDecodeTypeReference();
					return new StObj(value: Pop(type.GetStackType()), target: PopPointer(), type: type);
				}
				case ILOpCode.Throw:
					return new Throw(Pop());
				case ILOpCode.Unbox:
					return Push(new Unbox(Pop(), ReadAndDecodeTypeReference()));
				case ILOpCode.Unbox_any:
					return Push(new UnboxAny(Pop(), ReadAndDecodeTypeReference()));
				default:
					return new InvalidBranch($"Unknown opcode: 0x{(int)opCode:X2}");
			}
		}

		StackType PeekStackType()
		{
			if (currentStack.IsEmpty)
				return StackType.Unknown;
			else
				return currentStack.Peek().StackType;
		}

		class CollectStackVariablesVisitor : ILVisitor<ILInstruction>
		{
			readonly UnionFind<ILVariable> unionFind;
			internal readonly HashSet<ILVariable> variables = new HashSet<ILVariable>();

			public CollectStackVariablesVisitor(UnionFind<ILVariable> unionFind)
			{
				Debug.Assert(unionFind != null);
				this.unionFind = unionFind;
			}

			protected override ILInstruction Default(ILInstruction inst)
			{
				foreach (var child in inst.Children)
				{
					var newChild = child.AcceptVisitor(this);
					if (newChild != child)
						child.ReplaceWith(newChild);
				}
				return inst;
			}

			protected internal override ILInstruction VisitLdLoc(LdLoc inst)
			{
				base.VisitLdLoc(inst);
				if (inst.Variable.Kind == VariableKind.StackSlot)
				{
					var variable = unionFind.Find(inst.Variable);
					if (variables.Add(variable))
						variable.Name = "S_" + (variables.Count - 1);
					return new LdLoc(variable).WithILRange(inst);
				}
				return inst;
			}

			protected internal override ILInstruction VisitStLoc(StLoc inst)
			{
				base.VisitStLoc(inst);
				if (inst.Variable.Kind == VariableKind.StackSlot)
				{
					var variable = unionFind.Find(inst.Variable);
					if (variables.Add(variable))
						variable.Name = "S_" + (variables.Count - 1);
					return new StLoc(variable, inst.Value).WithILRange(inst);
				}
				return inst;
			}
		}

		ILInstruction Push(ILInstruction inst)
		{
			Debug.Assert(inst.ResultType != StackType.Void);
			IType type = compilation.FindType(inst.ResultType.ToKnownTypeCode());
			var v = new ILVariable(VariableKind.StackSlot, type, inst.ResultType);
			v.HasGeneratedName = true;
			currentStack = currentStack.Push(v);
			return new StLoc(v, inst);
		}

		ILInstruction Peek()
		{
			if (currentStack.IsEmpty)
			{
				return new InvalidExpression("Stack underflow").WithILRange(new Interval(reader.Offset, reader.Offset));
			}
			return new LdLoc(currentStack.Peek());
		}

		ILInstruction Pop()
		{
			if (currentStack.IsEmpty)
			{
				return new InvalidExpression("Stack underflow").WithILRange(new Interval(reader.Offset, reader.Offset));
			}
			ILVariable v;
			currentStack = currentStack.Pop(out v);
			return new LdLoc(v);
		}

		ILInstruction Pop(StackType expectedType)
		{
			ILInstruction inst = Pop();
			return Cast(inst, expectedType, Warnings, reader.Offset);
		}

		internal static ILInstruction Cast(ILInstruction inst, StackType expectedType, List<string> warnings, int ilOffset)
		{
			if (expectedType != inst.ResultType)
			{
				if (inst is InvalidExpression)
				{
					((InvalidExpression)inst).ExpectedResultType = expectedType;
				}
				else if (expectedType == StackType.I && inst.ResultType == StackType.I4)
				{
					// IL allows implicit I4->I conversions
					inst = new Conv(inst, PrimitiveType.I, false, Sign.None);
				}
				else if (expectedType == StackType.I4 && inst.ResultType == StackType.I)
				{
					// C++/CLI also sometimes implicitly converts in the other direction:
					inst = new Conv(inst, PrimitiveType.I4, false, Sign.None);
				}
				else if (expectedType == StackType.Unknown)
				{
					inst = new Conv(inst, PrimitiveType.Unknown, false, Sign.None);
				}
				else if (inst.ResultType == StackType.Ref)
				{
					// Implicitly stop GC tracking; this occurs when passing the result of 'ldloca' or 'ldsflda'
					// to a method expecting a native pointer.
					inst = new Conv(inst, PrimitiveType.I, false, Sign.None);
					switch (expectedType)
					{
						case StackType.I4:
							inst = new Conv(inst, PrimitiveType.I4, false, Sign.None);
							break;
						case StackType.I:
							break;
						case StackType.I8:
							inst = new Conv(inst, PrimitiveType.I8, false, Sign.None);
							break;
						default:
							Warn($"Expected {expectedType}, but got {StackType.Ref}");
							inst = new Conv(inst, expectedType.ToPrimitiveType(), false, Sign.None);
							break;
					}
				}
				else if (expectedType == StackType.Ref)
				{
					// implicitly start GC tracking / object to interior
					if (!inst.ResultType.IsIntegerType() && inst.ResultType != StackType.O)
					{
						// We also handle the invalid to-ref cases here because the else case
						// below uses expectedType.ToKnownTypeCode(), which doesn't work for Ref.
						Warn($"Expected {expectedType}, but got {inst.ResultType}");
					}
					inst = new Conv(inst, PrimitiveType.Ref, false, Sign.None);
				}
				else if (expectedType == StackType.F8 && inst.ResultType == StackType.F4)
				{
					// IL allows implicit F4->F8 conversions, because in IL F4 and F8 are the same.
					inst = new Conv(inst, PrimitiveType.R8, false, Sign.Signed);
				}
				else if (expectedType == StackType.F4 && inst.ResultType == StackType.F8)
				{
					// IL allows implicit F8->F4 conversions, because in IL F4 and F8 are the same.
					inst = new Conv(inst, PrimitiveType.R4, false, Sign.Signed);
				}
				else
				{
					Warn($"Expected {expectedType}, but got {inst.ResultType}");
					inst = new Conv(inst, expectedType.ToPrimitiveType(), false, Sign.Signed);
				}
			}
			return inst;

			void Warn(string message)
			{
				if (warnings != null)
				{
					warnings.Add(string.Format("IL_{0:x4}: {1}", ilOffset, message));
				}
			}
		}

		ILInstruction PopPointer()
		{
			ILInstruction inst = Pop();
			switch (inst.ResultType)
			{
				case StackType.I4:
				case StackType.I8:
				case StackType.Unknown:
					return new Conv(inst, PrimitiveType.I, false, Sign.None);
				case StackType.I:
				case StackType.Ref:
					return inst;
				default:
					Warn("Expected native int or pointer, but got " + inst.ResultType);
					return new Conv(inst, PrimitiveType.I, false, Sign.None);
			}
		}

		ILInstruction PopFieldTarget(IField field)
		{
			switch (field.DeclaringType.IsReferenceType)
			{
				case true:
					return Pop(StackType.O);
				case false:
					return PopPointer();
				default:
					// field in unresolved type
					var stackType = PeekStackType();
					if (stackType == StackType.O || stackType == StackType.Unknown)
						return Pop();
					else
						return PopPointer();
			}
		}

		/// <summary>
		/// Like PopFieldTarget, but supports ldfld's special behavior for fields of temporary value types.
		/// </summary>
		ILInstruction PopLdFldTarget(IField field)
		{
			switch (field.DeclaringType.IsReferenceType)
			{
				case true:
					return Pop(StackType.O);
				case false:
					// field of value type: ldfld can handle temporaries
					if (PeekStackType() == StackType.O || PeekStackType() == StackType.Unknown)
						return new AddressOf(Pop(), field.DeclaringType);
					else
						return PopPointer();
				default:
					// field in unresolved type
					if (PeekStackType() == StackType.O || PeekStackType() == StackType.Unknown)
						return Pop();
					else
						return PopPointer();
			}
		}

		private ILInstruction Return()
		{
			if (methodReturnStackType == StackType.Void)
				return new IL.Leave(mainContainer);
			else
				return new IL.Leave(mainContainer, Pop(methodReturnStackType));
		}

		private ILInstruction DecodeLdstr()
		{
			return new LdStr(ILParser.DecodeUserString(ref reader, metadata));
		}

		private ILInstruction Ldarg(int v)
		{
			if (v >= 0 && v < parameterVariables.Length)
			{
				return new LdLoc(parameterVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldarg {v} (out-of-bounds)");
			}
		}

		private ILInstruction Ldarga(int v)
		{
			if (v >= 0 && v < parameterVariables.Length)
			{
				return new LdLoca(parameterVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldarga {v} (out-of-bounds)");
			}
		}

		private ILInstruction Starg(int v)
		{
			if (v >= 0 && v < parameterVariables.Length)
			{
				return new StLoc(parameterVariables[v], Pop(parameterVariables[v].StackType));
			}
			else
			{
				Pop();
				return new InvalidExpression($"starg {v} (out-of-bounds)");
			}
		}

		private ILInstruction Ldloc(int v)
		{
			if (v >= 0 && v < localVariables.Length)
			{
				return new LdLoc(localVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldloc {v} (out-of-bounds)");
			}
		}

		private ILInstruction Ldloca(int v)
		{
			if (v >= 0 && v < localVariables.Length)
			{
				return new LdLoca(localVariables[v]);
			}
			else
			{
				return new InvalidExpression($"ldloca {v} (out-of-bounds)");
			}
		}

		private ILInstruction Stloc(int v)
		{
			if (v >= 0 && v < localVariables.Length)
			{
				return new StLoc(localVariables[v], Pop(localVariables[v].StackType)) {
					ILStackWasEmpty = currentStack.IsEmpty
				};
			}
			else
			{
				Pop();
				return new InvalidExpression($"stloc {v} (out-of-bounds)");
			}
		}

		private ILInstruction LdElem(IType type)
		{
			return Push(new LdObj(new LdElema(indices: Pop(), array: Pop(), type: type) { DelayExceptions = true }, type));
		}

		private ILInstruction StElem(IType type)
		{
			var value = Pop(type.GetStackType());
			var index = Pop();
			var array = Pop();
			return new StObj(new LdElema(type, array, index) { DelayExceptions = true }, value, type);
		}

		ILInstruction InitObj(ILInstruction target, IType type)
		{
			var value = new DefaultValue(type);
			value.ILStackWasEmpty = currentStack.IsEmpty;
			return new StObj(target, value, type);
		}

		IType constrainedPrefix;

		private ILInstruction DecodeConstrainedCall()
		{
			constrainedPrefix = ReadAndDecodeTypeReference();
			var inst = DecodeInstruction();
			var call = UnpackPush(inst) as CallInstruction;
			if (call != null)
				Debug.Assert(call.ConstrainedTo == constrainedPrefix);
			else
				Warn("Ignored invalid 'constrained' prefix");
			constrainedPrefix = null;
			return inst;
		}

		private ILInstruction DecodeTailCall()
		{
			var inst = DecodeInstruction();
			var call = UnpackPush(inst) as CallInstruction;
			if (call != null)
				call.IsTail = true;
			else
				Warn("Ignored invalid 'tail' prefix");
			return inst;
		}

		private ILInstruction DecodeUnaligned()
		{
			byte alignment = reader.ReadByte();
			var inst = DecodeInstruction();
			var sup = UnpackPush(inst) as ISupportsUnalignedPrefix;
			if (sup != null)
				sup.UnalignedPrefix = alignment;
			else
				Warn("Ignored invalid 'unaligned' prefix");
			return inst;
		}

		private ILInstruction DecodeVolatile()
		{
			var inst = DecodeInstruction();
			var svp = UnpackPush(inst) as ISupportsVolatilePrefix;
			if (svp != null)
				svp.IsVolatile = true;
			else
				Warn("Ignored invalid 'volatile' prefix");
			return inst;
		}

		private ILInstruction DecodeReadonly()
		{
			var inst = DecodeInstruction();
			var ldelema = UnpackPush(inst) as LdElema;
			if (ldelema != null)
				ldelema.IsReadOnly = true;
			else
				Warn("Ignored invalid 'readonly' prefix");
			return inst;
		}

		ILInstruction DecodeCall(OpCode opCode)
		{
			var method = ReadAndDecodeMethodReference();
			int firstArgument = (opCode != OpCode.NewObj && !method.IsStatic) ? 1 : 0;
			var arguments = new ILInstruction[firstArgument + method.Parameters.Count];
			for (int i = method.Parameters.Count - 1; i >= 0; i--)
			{
				arguments[firstArgument + i] = Pop(method.Parameters[i].Type.GetStackType());
			}
			if (firstArgument == 1)
			{
				arguments[0] = Pop(CallInstruction.ExpectedTypeForThisPointer(constrainedPrefix ?? method.DeclaringType));
			}
			switch (method.DeclaringType.Kind)
			{
				case TypeKind.Array:
				{
					var elementType = ((ArrayType)method.DeclaringType).ElementType;
					if (opCode == OpCode.NewObj)
						return Push(new NewArr(elementType, arguments));
					if (method.Name == "Set")
					{
						var target = arguments[0];
						var value = arguments.Last();
						var indices = arguments.Skip(1).Take(arguments.Length - 2).ToArray();
						return new StObj(new LdElema(elementType, target, indices) { DelayExceptions = true }, value, elementType);
					}
					if (method.Name == "Get")
					{
						var target = arguments[0];
						var indices = arguments.Skip(1).ToArray();
						return Push(new LdObj(new LdElema(elementType, target, indices) { DelayExceptions = true }, elementType));
					}
					if (method.Name == "Address")
					{
						var target = arguments[0];
						var indices = arguments.Skip(1).ToArray();
						return Push(new LdElema(elementType, target, indices));
					}
					Warn("Unknown method called on array type: " + method.Name);
					goto default;
				}
				case TypeKind.Struct when method.IsConstructor && !method.IsStatic && opCode == OpCode.Call
					&& method.ReturnType.Kind == TypeKind.Void:
				{
					// "call Struct.ctor(target, ...)" doesn't exist in C#,
					// the next best equivalent is an assignment `*target = new Struct(...);`.
					// So we represent this call as "stobj Struct(target, newobj Struct.ctor(...))".
					// This needs to happen early (not as a transform) because the StObj.TargetSlot has
					// restricted inlining (doesn't accept ldflda when exceptions aren't delayed).
					var newobj = new NewObj(method);
					newobj.ILStackWasEmpty = currentStack.IsEmpty;
					newobj.ConstrainedTo = constrainedPrefix;
					newobj.Arguments.AddRange(arguments.Skip(1));
					return new StObj(arguments[0], newobj, method.DeclaringType);
				}
				default:
					var call = CallInstruction.Create(opCode, method);
					call.ILStackWasEmpty = currentStack.IsEmpty;
					call.ConstrainedTo = constrainedPrefix;
					call.Arguments.AddRange(arguments);
					if (call.ResultType != StackType.Void)
						return Push(call);
					return call;
			}
		}

		ILInstruction DecodeCallIndirect()
		{
			var signatureHandle = (StandaloneSignatureHandle)ReadAndDecodeMetadataToken();
			var (header, fpt) = module.DecodeMethodSignature(signatureHandle, genericContext);
			var functionPointer = Pop(StackType.I);
			int firstArgument = header.IsInstance ? 1 : 0;
			var arguments = new ILInstruction[firstArgument + fpt.ParameterTypes.Length];
			for (int i = fpt.ParameterTypes.Length - 1; i >= 0; i--)
			{
				arguments[firstArgument + i] = Pop(fpt.ParameterTypes[i].GetStackType());
			}
			if (firstArgument == 1)
			{
				arguments[0] = Pop();
			}
			var call = new CallIndirect(
				header.IsInstance,
				header.HasExplicitThis,
				fpt,
				functionPointer,
				arguments
			);
			if (call.ResultType != StackType.Void)
				return Push(call);
			else
				return call;
		}

		ILInstruction Comparison(ComparisonKind kind, bool un = false)
		{
			var right = Pop();
			var left = Pop();

			if ((left.ResultType == StackType.O || left.ResultType == StackType.Ref) && right.ResultType.IsIntegerType())
			{
				// C++/CLI sometimes compares object references with integers.
				// Also happens with Ref==I in Unsafe.IsNullRef().
				if (right.ResultType == StackType.I4)
				{
					// ensure we compare at least native integer size
					right = new Conv(right, PrimitiveType.I, false, Sign.None);
				}
				left = new Conv(left, right.ResultType.ToPrimitiveType(), false, Sign.None);
			}
			else if ((right.ResultType == StackType.O || right.ResultType == StackType.Ref) && left.ResultType.IsIntegerType())
			{
				if (left.ResultType == StackType.I4)
				{
					left = new Conv(left, PrimitiveType.I, false, Sign.None);
				}
				right = new Conv(right, left.ResultType.ToPrimitiveType(), false, Sign.None);
			}

			// make implicit integer conversions explicit:
			MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I, conversionType: PrimitiveType.I);
			MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I8, conversionType: PrimitiveType.I8);
			MakeExplicitConversion(sourceType: StackType.I, targetType: StackType.I8, conversionType: PrimitiveType.I8);

			// Based on Table 4: Binary Comparison or Branch Operation
			if (left.ResultType.IsFloatType() && right.ResultType.IsFloatType())
			{
				if (left.ResultType != right.ResultType)
				{
					// make the implicit F4->F8 conversion explicit:
					MakeExplicitConversion(StackType.F4, StackType.F8, PrimitiveType.R8);
				}
				if (un)
				{
					// for floats, 'un' means 'unordered'
					return Comp.LogicNot(new Comp(kind.Negate(), Sign.None, left, right));
				}
				else
				{
					return new Comp(kind, Sign.None, left, right);
				}
			}
			else if (left.ResultType.IsIntegerType() && right.ResultType.IsIntegerType() && !kind.IsEqualityOrInequality())
			{
				// integer comparison where the sign matters
				Debug.Assert(right.ResultType.IsIntegerType());
				return new Comp(kind, un ? Sign.Unsigned : Sign.Signed, left, right);
			}
			else if (left.ResultType == right.ResultType)
			{
				// integer equality, object reference or managed reference comparison
				return new Comp(kind, Sign.None, left, right);
			}
			else
			{
				Warn($"Invalid comparison between {left.ResultType} and {right.ResultType}");
				if (left.ResultType < right.ResultType)
				{
					left = new Conv(left, right.ResultType.ToPrimitiveType(), false, Sign.Signed);
				}
				else
				{
					right = new Conv(right, left.ResultType.ToPrimitiveType(), false, Sign.Signed);
				}
				return new Comp(kind, Sign.None, left, right);
			}

			void MakeExplicitConversion(StackType sourceType, StackType targetType, PrimitiveType conversionType)
			{
				if (left.ResultType == sourceType && right.ResultType == targetType)
				{
					left = new Conv(left, conversionType, false, Sign.None);
				}
				else if (left.ResultType == targetType && right.ResultType == sourceType)
				{
					right = new Conv(right, conversionType, false, Sign.None);
				}
			}
		}

		bool IsInvalidBranch(int target) => target < 0 || target >= reader.Length;

		ILInstruction DecodeComparisonBranch(ILOpCode opCode, ComparisonKind kind, bool un = false)
		{
			int start = reader.Offset - 1; // opCode is always one byte in this case
			int target = ILParser.DecodeBranchTarget(ref reader, opCode);
			var condition = Comparison(kind, un);
			condition.AddILRange(new Interval(start, reader.Offset));
			if (!IsInvalidBranch(target))
			{
				MarkBranchTarget(target);
				return new IfInstruction(condition, new Branch(target));
			}
			else
			{
				return new IfInstruction(condition, new InvalidBranch("Invalid branch target"));
			}
		}

		ILInstruction DecodeConditionalBranch(ILOpCode opCode, bool negate)
		{
			int target = ILParser.DecodeBranchTarget(ref reader, opCode);
			ILInstruction condition = Pop();
			switch (condition.ResultType)
			{
				case StackType.O:
					// introduce explicit comparison with null
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, condition, new LdNull());
					break;
				case StackType.I:
					// introduce explicit comparison with 0
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, condition, new Conv(new LdcI4(0), PrimitiveType.I, false, Sign.None));
					break;
				case StackType.I8:
					// introduce explicit comparison with 0
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, condition, new LdcI8(0));
					break;
				case StackType.Ref:
					// introduce explicit comparison with null ref
					condition = new Comp(
						negate ? ComparisonKind.Equality : ComparisonKind.Inequality,
						Sign.None, new Conv(condition, PrimitiveType.I, false, Sign.None), new Conv(new LdcI4(0), PrimitiveType.I, false, Sign.None));
					break;
				case StackType.I4:
					if (negate)
					{
						condition = Comp.LogicNot(condition);
					}
					break;
				default:
					condition = new Conv(condition, PrimitiveType.I4, false, Sign.None);
					if (negate)
					{
						condition = Comp.LogicNot(condition);
					}
					break;
			}
			if (!IsInvalidBranch(target))
			{
				MarkBranchTarget(target);
				return new IfInstruction(condition, new Branch(target));
			}
			else
			{
				return new IfInstruction(condition, new InvalidBranch("Invalid branch target"));
			}
		}

		ILInstruction DecodeUnconditionalBranch(ILOpCode opCode, bool isLeave = false)
		{
			int target = ILParser.DecodeBranchTarget(ref reader, opCode);
			if (isLeave)
			{
				currentStack = currentStack.Clear();
			}
			if (!IsInvalidBranch(target))
			{
				MarkBranchTarget(target);
				return new Branch(target);
			}
			else
			{
				return new InvalidBranch("Invalid branch target");
			}
		}

		void MarkBranchTarget(int targetILOffset)
		{
			isBranchTarget[targetILOffset] = true;
			StoreStackForOffset(targetILOffset, ref currentStack);
		}

		ILInstruction DecodeSwitch()
		{
			var targets = ILParser.DecodeSwitchTargets(ref reader);
			var instr = new SwitchInstruction(Pop(StackType.I4));

			for (int i = 0; i < targets.Length; i++)
			{
				var section = new SwitchSection();
				section.Labels = new LongSet(i);
				int target = targets[i];
				if (!IsInvalidBranch(target))
				{
					MarkBranchTarget(target);
					section.Body = new Branch(target);
				}
				else
				{
					section.Body = new InvalidBranch("Invalid branch target");
				}
				instr.Sections.Add(section);
			}
			var defaultSection = new SwitchSection();
			defaultSection.Labels = new LongSet(new LongInterval(0, targets.Length)).Invert();
			defaultSection.Body = new Nop();
			instr.Sections.Add(defaultSection);
			return instr;
		}

		ILInstruction BinaryNumeric(BinaryNumericOperator @operator, bool checkForOverflow = false, Sign sign = Sign.None)
		{
			var right = Pop();
			var left = Pop();
			if (@operator != BinaryNumericOperator.Add && @operator != BinaryNumericOperator.Sub)
			{
				// we are treating all Refs as I, make the conversion explicit
				if (left.ResultType == StackType.Ref)
				{
					left = new Conv(left, PrimitiveType.I, false, Sign.None);
				}
				if (right.ResultType == StackType.Ref)
				{
					right = new Conv(right, PrimitiveType.I, false, Sign.None);
				}
			}
			if (@operator != BinaryNumericOperator.ShiftLeft && @operator != BinaryNumericOperator.ShiftRight)
			{
				// make the implicit I4->I conversion explicit:
				MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I, conversionType: PrimitiveType.I);
				// I4->I8 conversion:
				MakeExplicitConversion(sourceType: StackType.I4, targetType: StackType.I8, conversionType: PrimitiveType.I8);
				// I->I8 conversion:
				MakeExplicitConversion(sourceType: StackType.I, targetType: StackType.I8, conversionType: PrimitiveType.I8);
				// F4->F8 conversion:
				MakeExplicitConversion(sourceType: StackType.F4, targetType: StackType.F8, conversionType: PrimitiveType.R8);
			}
			return Push(new BinaryNumericInstruction(@operator, left, right, checkForOverflow, sign));

			void MakeExplicitConversion(StackType sourceType, StackType targetType, PrimitiveType conversionType)
			{
				if (left.ResultType == sourceType && right.ResultType == targetType)
				{
					left = new Conv(left, conversionType, false, Sign.None);
				}
				else if (left.ResultType == targetType && right.ResultType == sourceType)
				{
					right = new Conv(right, conversionType, false, Sign.None);
				}
			}
		}

		ILInstruction DecodeJmp()
		{
			IMethod method = ReadAndDecodeMethodReference();
			// Translate jmp into tail call:
			Call call = new Call(method);
			call.IsTail = true;
			call.ILStackWasEmpty = true;
			if (!method.IsStatic)
			{
				call.Arguments.Add(Ldarg(0));
			}
			foreach (var p in method.Parameters)
			{
				call.Arguments.Add(Ldarg(call.Arguments.Count));
			}
			return new Leave(mainContainer, call);
		}

		ILInstruction LdToken(EntityHandle token)
		{
			if (token.Kind.IsTypeKind())
				return new LdTypeToken(module.ResolveType(token, genericContext));
			if (token.Kind.IsMemberKind())
			{
				var entity = module.ResolveEntity(token, genericContext);
				if (entity is IMember member)
					return new LdMemberToken(member);
			}
			throw new BadImageFormatException("Invalid metadata token for ldtoken instruction.");
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs(301,13): error CS0019: Operator '!=' cannot be applied to operands of type 'method group' and 'method group',D:\a\1\s\ICSharpCode.Decompiler\IL\ILReader.cs(304,10): error CS0019: Operator '+' cannot be applied to operands of type 'string' and 'method group'
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Diagnostics;
using System.Linq;

using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.TypeSystem.Implementation;
using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.IL.Transforms
{
	/// <summary>
	/// Constructs compound assignments and inline assignments.
	/// </summary>
	/// <remarks>
	/// This is a statement transform;
	/// but some portions are executed as an expression transform instead
	/// (with HandleCompoundAssign() as entry point)
	/// </remarks>
	public class TransformAssignment : IStatementTransform
	{
		StatementTransformContext context;

		void IStatementTransform.Run(Block block, int pos, StatementTransformContext context)
		{
			this.context = context;
			if (context.Settings.MakeAssignmentExpressions)
			{
				if (TransformInlineAssignmentStObjOrCall(block, pos) || TransformInlineAssignmentLocal(block, pos))
				{
					// both inline assignments create a top-level stloc which might affect inlining
					context.RequestRerun();
					return;
				}
			}
			if (context.Settings.IntroduceIncrementAndDecrement)
			{
				if (TransformPostIncDecOperatorWithInlineStore(block, pos)
					|| TransformPostIncDecOperator(block, pos))
				{
					// again, new top-level stloc might need inlining:
					context.RequestRerun();
					return;
				}
			}
		}

		/// <code>
		/// stloc s(value)
		/// stloc l(ldloc s)
		/// stobj(..., ldloc s)
		///   where ... is pure and does not use s or l,
		///   and where neither the 'stloc s' nor the 'stobj' truncates
		/// -->
		/// stloc l(stobj (..., value))
		/// </code>
		/// e.g. used for inline assignment to instance field
		/// 
		/// -or-
		/// 
		/// <code>
		/// stloc s(value)
		/// stobj (..., ldloc s)
		///   where ... is pure and does not use s, and where the 'stobj' does not truncate
		/// -->
		/// stloc s(stobj (..., value))
		/// </code>
		/// e.g. used for inline assignment to static field
		/// 
		/// -or-
		/// 
		/// <code>
		/// stloc s(value)
		/// call set_Property(..., ldloc s)
		///   where the '...' arguments are pure and not using 's'
		/// -->
		/// stloc s(Block InlineAssign { call set_Property(..., stloc i(value)); final: ldloc i })
		///   new temporary 'i' has type of the property; transform only valid if 'stloc i' doesn't truncate
		/// </code>
		bool TransformInlineAssignmentStObjOrCall(Block block, int pos)
		{
			var inst = block.Instructions[pos] as StLoc;
			// in some cases it can be a compiler-generated local
			if (inst == null || (inst.Variable.Kind != VariableKind.StackSlot && inst.Variable.Kind != VariableKind.Local))
				return false;
			if (IsImplicitTruncation(inst.Value, inst.Variable.Type, context.TypeSystem))
			{
				// 'stloc s' is implicitly truncating the value
				return false;
			}
			ILVariable local;
			int nextPos;
			if (block.Instructions[pos + 1] is StLoc localStore)
			{ // with extra local
				if (localStore.Variable.Kind != VariableKind.Local || !localStore.Value.MatchLdLoc(inst.Variable))
					return false;
				// if we're using an extra local, we'll delete "s", so check that that doesn't have any additional uses
				if (!(inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 2))
					return false;
				local = localStore.Variable;
				nextPos = pos + 2;
			}
			else
			{
				local = inst.Variable;
				localStore = null;
				nextPos = pos + 1;
			}
			if (block.Instructions[nextPos] is StObj stobj)
			{
				if (!stobj.Value.MatchLdLoc(inst.Variable))
					return false;
				if (!SemanticHelper.IsPure(stobj.Target.Flags) || inst.Variable.IsUsedWithin(stobj.Target))
					return false;
				var pointerType = stobj.Target.InferType(context.TypeSystem);
				IType newType = stobj.Type;
				if (TypeUtils.IsCompatiblePointerTypeForMemoryAccess(pointerType, stobj.Type))
				{
					if (pointerType is ByReferenceType byref)
						newType = byref.ElementType;
					else if (pointerType is PointerType pointer)
						newType = pointer.ElementType;
				}
				if (IsImplicitTruncation(inst.Value, newType, context.TypeSystem))
				{
					// 'stobj' is implicitly truncating the value
					return false;
				}
				context.Step("Inline assignment stobj", stobj);
				stobj.Type = newType;
				block.Instructions.Remove(localStore);
				block.Instructions.Remove(stobj);
				stobj.Value = inst.Value;
				inst.ReplaceWith(new StLoc(local, stobj));
				// note: our caller will trigger a re-run, which will call HandleStObjCompoundAssign if applicable
				return true;
			}
			else if (block.Instructions[nextPos] is CallInstruction call)
			{
				// call must be a setter call:
				if (!(call.OpCode == OpCode.Call || call.OpCode == OpCode.CallVirt))
					return false;
				if (call.ResultType != StackType.Void || call.Arguments.Count == 0)
					return false;
				IProperty property = call.Method.AccessorOwner as IProperty;
				if (property == null)
					return false;
				if (!call.Method.Equals(property.Setter))
					return false;
				if (!(property.IsIndexer || property.Setter.Parameters.Count == 1))
				{
					// this is a parameterized property, which cannot be expressed as C# code.
					// setter calls are not valid in expression context, if property syntax cannot be used.
					return false;
				}
				if (!call.Arguments.Last().MatchLdLoc(inst.Variable))
					return false;
				foreach (var arg in call.Arguments.SkipLast(1))
				{
					if (!SemanticHelper.IsPure(arg.Flags) || inst.Variable.IsUsedWithin(arg))
						return false;
				}
				if (IsImplicitTruncation(inst.Value, call.Method.Parameters.Last().Type, context.TypeSystem))
				{
					// setter call is implicitly truncating the value
					return false;
				}
				// stloc s(Block InlineAssign { call set_Property(..., stloc i(value)); final: ldloc i })
				context.Step("Inline assignment call", call);
				block.Instructions.Remove(localStore);
				block.Instructions.Remove(call);
				var newVar = context.Function.RegisterVariable(VariableKind.StackSlot, call.Method.Parameters.Last().Type);
				call.Arguments[call.Arguments.Count - 1] = new StLoc(newVar, inst.Value);
				var inlineBlock = new Block(BlockKind.CallInlineAssign) {
					Instructions = { call },
					FinalInstruction = new LdLoc(newVar)
				};
				inst.ReplaceWith(new StLoc(local, inlineBlock));
				// because the ExpressionTransforms don't look into inline blocks, manually trigger HandleCallCompoundAssign
				if (HandleCompoundAssign(call, context))
				{
					// if we did construct a compound assignment, it should have made our inline block redundant:
					Debug.Assert(!inlineBlock.IsConnected);
				}
				return true;
			}
			else
			{
				return false;
			}
		}

		static ILInstruction UnwrapSmallIntegerConv(ILInstruction inst, out Conv conv)
		{
			conv = inst as Conv;
			if (conv != null && conv.Kind == ConversionKind.Truncate && conv.TargetType.IsSmallIntegerType())
			{
				// for compound assignments to small integers, the compiler emits a "conv" instruction
				return conv.Argument;
			}
			else
			{
				return inst;
			}
		}

		static bool ValidateCompoundAssign(BinaryNumericInstruction binary, Conv conv, IType targetType, DecompilerSettings settings)
		{
			if (!NumericCompoundAssign.IsBinaryCompatibleWithType(binary, targetType, settings))
				return false;
			if (conv != null && !(conv.TargetType == targetType.ToPrimitiveType() && conv.CheckForOverflow == binary.CheckForOverflow))
				return false; // conv does not match binary operation
			return true;
		}

		static bool MatchingGetterAndSetterCalls(CallInstruction getterCall, CallInstruction setterCall, out Action<ILTransformContext> finalizeMatch)
		{
			finalizeMatch = null;
			if (getterCall == null || setterCall == null || !IsSameMember(getterCall.Method.AccessorOwner, setterCall.Method.AccessorOwner))
				return false;
			if (setterCall.OpCode != getterCall.OpCode)
				return false;
			var owner = getterCall.Method.AccessorOwner as IProperty;
			if (owner == null || !IsSameMember(getterCall.Method, owner.Getter) || !IsSameMember(setterCall.Method, owner.Setter))
				return false;
			if (setterCall.Arguments.Count != getterCall.Arguments.Count + 1)
				return false;
			// Ensure that same arguments are passed to getterCall and setterCall:
			for (int j = 0; j < getterCall.Arguments.Count; j++)
			{
				if (setterCall.Arguments[j].MatchStLoc(out var v) && v.IsSingleDefinition && v.LoadCount == 1)
				{
					if (getterCall.Arguments[j].MatchLdLoc(v))
					{
						// OK, setter call argument is saved in temporary that is re-used for getter call
						if (finalizeMatch == null)
						{
							finalizeMatch = AdjustArguments;
						}
						continue;
					}
				}
				if (!SemanticHelper.IsPure(getterCall.Arguments[j].Flags))
					return false;
				if (!getterCall.Arguments[j].Match(setterCall.Arguments[j]).Success)
					return false;
			}
			return true;

			void AdjustArguments(ILTransformContext context)
			{
				Debug.Assert(setterCall.Arguments.Count == getterCall.Arguments.Count + 1);
				for (int j = 0; j < getterCall.Arguments.Count; j++)
				{
					if (setterCall.Arguments[j].MatchStLoc(out var v, out var value))
					{
						Debug.Assert(v.IsSingleDefinition && v.LoadCount == 1);
						Debug.Assert(getterCall.Arguments[j].MatchLdLoc(v));
						getterCall.Arguments[j] = value;
					}
				}
			}
		}

		/// <summary>
		/// Transform compound assignments where the return value is not being used,
		/// or where there's an inlined assignment within the setter call.
		/// 
		/// Patterns handled:
		/// 1.
		///   callvirt set_Property(ldloc S_1, binary.op(callvirt get_Property(ldloc S_1), value))
		///   ==> compound.op.new(callvirt get_Property(ldloc S_1), value)
		/// 2.
		///   callvirt set_Property(ldloc S_1, stloc v(binary.op(callvirt get_Property(ldloc S_1), value)))
		///   ==> stloc v(compound.op.new(callvirt get_Property(ldloc S_1), value))
		/// 3.
		///   stobj(target, binary.op(ldobj(target), ...))
		///     where target is pure
		///   => compound.op(target, ...)
		/// </summary>
		/// <remarks>
		/// Called by ExpressionTransforms, or after the inline-assignment transform for setters.
		/// </remarks>
		internal static bool HandleCompoundAssign(ILInstruction compoundStore, StatementTransformContext context)
		{
			if (!context.Settings.MakeAssignmentExpressions || !context.Settings.IntroduceIncrementAndDecrement)
				return false;
			if (compoundStore is CallInstruction && compoundStore.SlotInfo != Block.InstructionSlot)
			{
				// replacing 'call set_Property' with a compound assignment instruction
				// changes the return value of the expression, so this is only valid on block-level.
				return false;
			}
			if (!IsCompoundStore(compoundStore, out var targetType, out var setterValue, context.TypeSystem))
				return false;
			// targetType = The type of the property/field/etc. being stored to.
			// setterValue = The value being stored.
			var storeInSetter = setterValue as StLoc;
			if (storeInSetter != null)
			{
				// We'll move the stloc to top-level:
				// callvirt set_Property(ldloc S_1, stloc v(binary.op(callvirt get_Property(ldloc S_1), value)))
				// ==> stloc v(compound.op.new(callvirt get_Property(ldloc S_1), value))
				setterValue = storeInSetter.Value;
				if (storeInSetter.Variable.Type.IsSmallIntegerType())
				{
					// 'stloc v' implicitly truncates the value.
					// Ensure that type of 'v' matches the type of the property:
					if (storeInSetter.Variable.Type.GetSize() != targetType.GetSize())
						return false;
					if (storeInSetter.Variable.Type.GetSign() != targetType.GetSign())
						return false;
				}
			}
			ILInstruction newInst;
			if (UnwrapSmallIntegerConv(setterValue, out var smallIntConv) is BinaryNumericInstruction binary)
			{
				if (compoundStore is StLoc)
				{
					// transform local variables only for user-defined operators
					return false;
				}
				if (!IsMatchingCompoundLoad(binary.Left, compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				if (!ValidateCompoundAssign(binary, smallIntConv, targetType, context.Settings))
					return false;
				context.Step($"Compound assignment (binary.numeric)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new NumericCompoundAssign(
					binary, target, targetKind, binary.Right,
					targetType, CompoundEvalMode.EvaluatesToNewValue);
			}
			else if (setterValue is Call operatorCall && operatorCall.Method.IsOperator)
			{
				if (operatorCall.Arguments.Count == 0)
					return false;
				if (!IsMatchingCompoundLoad(operatorCall.Arguments[0], compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				ILInstruction rhs;
				if (operatorCall.Arguments.Count == 2)
				{
					if (CSharp.ExpressionBuilder.GetAssignmentOperatorTypeFromMetadataName(operatorCall.Method.Name) == null)
						return false;
					rhs = operatorCall.Arguments[1];
				}
				else if (operatorCall.Arguments.Count == 1)
				{
					if (!(operatorCall.Method.Name == "op_Increment" || operatorCall.Method.Name == "op_Decrement"))
						return false;
					// use a dummy node so that we don't need a dedicated instruction for user-defined unary operator calls
					rhs = new LdcI4(1);
				}
				else
				{
					return false;
				}
				if (operatorCall.IsLifted)
					return false; // TODO: add tests and think about whether nullables need special considerations
				context.Step($"Compound assignment (user-defined binary)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new UserDefinedCompoundAssign(operatorCall.Method, CompoundEvalMode.EvaluatesToNewValue,
					target, targetKind, rhs);
			}
			else if (setterValue is DynamicBinaryOperatorInstruction dynamicBinaryOp)
			{
				if (!IsMatchingCompoundLoad(dynamicBinaryOp.Left, compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				context.Step($"Compound assignment (dynamic binary)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new DynamicCompoundAssign(dynamicBinaryOp.Operation, dynamicBinaryOp.BinderFlags, target, dynamicBinaryOp.LeftArgumentInfo, dynamicBinaryOp.Right, dynamicBinaryOp.RightArgumentInfo, targetKind);
			}
			else if (setterValue is Call concatCall && UserDefinedCompoundAssign.IsStringConcat(concatCall.Method))
			{
				// setterValue is a string.Concat() invocation
				if (compoundStore is StLoc)
				{
					// transform local variables only for user-defined operators
					return false;
				}
				if (concatCall.Arguments.Count != 2)
					return false; // for now we only support binary compound assignments
				if (!targetType.IsKnownType(KnownTypeCode.String))
					return false;
				if (!IsMatchingCompoundLoad(concatCall.Arguments[0], compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				context.Step($"Compound assignment (string concatenation)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new UserDefinedCompoundAssign(concatCall.Method, CompoundEvalMode.EvaluatesToNewValue,
					target, targetKind, concatCall.Arguments[1]);
			}
			else
			{
				return false;
			}
			newInst.AddILRange(setterValue);
			if (storeInSetter != null)
			{
				storeInSetter.Value = newInst;
				newInst = storeInSetter;
				context.RequestRerun(); // moving stloc to top-level might trigger inlining
			}
			compoundStore.ReplaceWith(newInst);
			if (newInst.Parent is Block inlineAssignBlock && inlineAssignBlock.Kind == BlockKind.CallInlineAssign)
			{
				// It's possible that we first replaced the instruction in an inline-assign helper block.
				// In such a situation, we know from the block invariant that we're have a storeInSetter.
				Debug.Assert(storeInSetter != null);
				Debug.Assert(storeInSetter.Variable.IsSingleDefinition && storeInSetter.Variable.LoadCount == 1);
				Debug.Assert(inlineAssignBlock.Instructions.Single() == storeInSetter);
				Debug.Assert(inlineAssignBlock.FinalInstruction.MatchLdLoc(storeInSetter.Variable));
				// Block CallInlineAssign { stloc I_0(compound.op(...)); final: ldloc I_0 }
				// --> compound.op(...)
				inlineAssignBlock.ReplaceWith(storeInSetter.Value);
			}
			return true;
		}

		/// <code>
		/// stloc s(value)
		/// stloc l(ldloc s)
		///   where neither 'stloc s' nor 'stloc l' truncates the value
		/// -->
		/// stloc s(stloc l(value))
		/// </code>
		bool TransformInlineAssignmentLocal(Block block, int pos)
		{
			var inst = block.Instructions[pos] as StLoc;
			var nextInst = block.Instructions.ElementAtOrDefault(pos + 1) as StLoc;
			if (inst == null || nextInst == null)
				return false;
			if (inst.Variable.Kind != VariableKind.StackSlot)
				return false;
			if (!(nextInst.Variable.Kind == VariableKind.Local || nextInst.Variable.Kind == VariableKind.Parameter))
				return false;
			if (!nextInst.Value.MatchLdLoc(inst.Variable))
				return false;
			if (IsImplicitTruncation(inst.Value, inst.Variable.Type, context.TypeSystem))
			{
				// 'stloc s' is implicitly truncating the stack value
				return false;
			}
			if (IsImplicitTruncation(inst.Value, nextInst.Variable.Type, context.TypeSystem))
			{
				// 'stloc l' is implicitly truncating the stack value
				return false;
			}
			if (nextInst.Variable.StackType == StackType.Ref)
			{
				// ref locals need to be initialized when they are declared, so
				// we can only use inline assignments when we know that the
				// ref local is definitely assigned.
				// We don't have an easy way to check for that in this transform,
				// so avoid inline assignments to ref locals for now.
				return false;
			}
			context.Step("Inline assignment to local variable", inst);
			var value = inst.Value;
			var var = nextInst.Variable;
			var stackVar = inst.Variable;
			block.Instructions.RemoveAt(pos);
			nextInst.ReplaceWith(new StLoc(stackVar, new StLoc(var, value)));
			return true;
		}

		/// <summary>
		/// Gets whether 'stobj type(..., value)' would evaluate to a different value than 'value'
		/// due to implicit truncation.
		/// </summary>
		static internal bool IsImplicitTruncation(ILInstruction value, IType type, ICompilation compilation, bool allowNullableValue = false)
		{
			if (!type.IsSmallIntegerType())
			{
				// Implicit truncation in ILAst only happens for small integer types;
				// other types of implicit truncation in IL cause the ILReader to insert
				// conv instructions.
				return false;
			}
			// With small integer types, test whether the value might be changed by
			// truncation (based on type.GetSize()) followed by sign/zero extension (based on type.GetSign()).
			// (it's OK to have false-positives here if we're unsure)
			if (value.MatchLdcI4(out int val))
			{
				switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode)
				{
					case KnownTypeCode.Boolean:
						return !(val == 0 || val == 1);
					case KnownTypeCode.Byte:
						return !(val >= byte.MinValue && val <= byte.MaxValue);
					case KnownTypeCode.SByte:
						return !(val >= sbyte.MinValue && val <= sbyte.MaxValue);
					case KnownTypeCode.Int16:
						return !(val >= short.MinValue && val <= short.MaxValue);
					case KnownTypeCode.UInt16:
					case KnownTypeCode.Char:
						return !(val >= ushort.MinValue && val <= ushort.MaxValue);
				}
			}
			else if (value is Conv conv)
			{
				return conv.TargetType != type.ToPrimitiveType();
			}
			else if (value is Comp)
			{
				return false; // comp returns 0 or 1, which always fits
			}
			else if (value is BinaryNumericInstruction bni)
			{
				switch (bni.Operator)
				{
					case BinaryNumericOperator.BitAnd:
					case BinaryNumericOperator.BitOr:
					case BinaryNumericOperator.BitXor:
						// If both input values fit into the type without truncation,
						// the result of a binary operator will also fit.
						return IsImplicitTruncation(bni.Left, type, compilation, allowNullableValue)
							|| IsImplicitTruncation(bni.Right, type, compilation, allowNullableValue);
				}
			}
			else if (value is IfInstruction ifInst)
			{
				return IsImplicitTruncation(ifInst.TrueInst, type, compilation, allowNullableValue)
					|| IsImplicitTruncation(ifInst.FalseInst, type, compilation, allowNullableValue);
			}
			else
			{
				IType inferredType = value.InferType(compilation);
				if (allowNullableValue)
				{
					inferredType = NullableType.GetUnderlyingType(inferredType);
				}
				if (inferredType.Kind != TypeKind.Unknown)
				{
					return !(inferredType.GetSize() <= type.GetSize() && inferredType.GetSign() == type.GetSign());
				}
			}
			return true;
		}

		/// <summary>
		/// Gets whether 'inst' is a possible store for use as a compound store.
		/// </summary>
		/// <remarks>
		/// Output parameters:
		/// storeType: The type of the value being stored.
		/// value: The value being stored (will be analyzed further to detect compound assignments)
		/// 
		/// Every IsCompoundStore() call should be followed by an IsMatchingCompoundLoad() call.
		/// </remarks>
		static bool IsCompoundStore(ILInstruction inst, out IType storeType,
			out ILInstruction value, ICompilation compilation)
		{
			value = null;
			storeType = null;
			if (inst is StObj stobj)
			{
				// stobj.Type may just be 'int' (due to stind.i4) when we're actually operating on a 'ref MyEnum'.
				// Try to determine the real type of the object we're modifying:
				storeType = stobj.Target.InferType(compilation);
				if (storeType is ByReferenceType refType)
				{
					if (TypeUtils.IsCompatibleTypeForMemoryAccess(refType.ElementType, stobj.Type))
					{
						storeType = refType.ElementType;
					}
					else
					{
						storeType = stobj.Type;
					}
				}
				else if (storeType is PointerType pointerType)
				{
					if (TypeUtils.IsCompatibleTypeForMemoryAccess(pointerType.ElementType, stobj.Type))
					{
						storeType = pointerType.ElementType;
					}
					else
					{
						storeType = stobj.Type;
					}
				}
				else
				{
					storeType = stobj.Type;
				}
				value = stobj.Value;
				return SemanticHelper.IsPure(stobj.Target.Flags);
			}
			else if (inst is CallInstruction call && (call.OpCode == OpCode.Call || call.OpCode == OpCode.CallVirt))
			{
				if (call.Method.Parameters.Count == 0)
				{
					return false;
				}
				foreach (var arg in call.Arguments.SkipLast(1))
				{
					if (arg.MatchStLoc(out var v) && v.IsSingleDefinition && v.LoadCount == 1)
					{
						continue; // OK, IsMatchingCompoundLoad can perform an adjustment in this special case
					}
					if (!SemanticHelper.IsPure(arg.Flags))
					{
						return false;
					}
				}
				storeType = call.Method.Parameters.Last().Type;
				value = call.Arguments.Last();
				return IsSameMember(call.Method, (call.Method.AccessorOwner as IProperty)?.Setter);
			}
			else if (inst is StLoc stloc && (stloc.Variable.Kind == VariableKind.Local || stloc.Variable.Kind == VariableKind.Parameter))
			{
				storeType = stloc.Variable.Type;
				value = stloc.Value;
				return true;
			}
			else
			{
				return false;
			}
		}

		/// <summary>
		/// Checks whether 'load' and 'store' both access the same store, and can be combined to a compound assignment.
		/// </summary>
		/// <param name="load">The load instruction to test.</param>
		/// <param name="store">The compound store to test against. Must have previously been tested via IsCompoundStore()</param>
		/// <param name="target">The target to use for the compound assignment instruction.</param>
		/// <param name="targetKind">The target kind to use for the compound assignment instruction.</param>
		/// <param name="finalizeMatch">If set to a non-null value, call this delegate to fix up minor mismatches between getter and setter.</param>
		/// <param name="forbiddenVariable">
		/// If given a non-null value, this function returns false if the forbiddenVariable is used in the load/store instructions.
		/// Some transforms effectively move a store around,
		/// which is only valid if the variable stored to does not occur in the compound load/store.
		/// </param>
		/// <param name="previousInstruction">
		/// Instruction preceding the load.
		/// </param>
		static bool IsMatchingCompoundLoad(ILInstruction load, ILInstruction store,
			out ILInstruction target, out CompoundTargetKind targetKind,
			out Action<ILTransformContext> finalizeMatch,
			ILVariable forbiddenVariable = null,
			ILInstruction previousInstruction = null)
		{
			target = null;
			targetKind = 0;
			finalizeMatch = null;
			if (load is LdObj ldobj && store is StObj stobj)
			{
				Debug.Assert(SemanticHelper.IsPure(stobj.Target.Flags));
				if (!SemanticHelper.IsPure(ldobj.Target.Flags))
					return false;
				if (forbiddenVariable != null && forbiddenVariable.IsUsedWithin(ldobj.Target))
					return false;
				target = ldobj.Target;
				targetKind = CompoundTargetKind.Address;
				if (ldobj.Target.Match(stobj.Target).Success)
				{
					return true;
				}
				else if (IsDuplicatedAddressComputation(stobj.Target, ldobj.Target))
				{
					// Use S_0 as target, so that S_0 can later be eliminated by inlining.
					// (we can't eliminate previousInstruction right now, because it's before the transform's starting instruction)
					target = stobj.Target;
					return true;
				}
				else
				{
					return false;
				}
			}
			else if (MatchingGetterAndSetterCalls(load as CallInstruction, store as CallInstruction, out finalizeMatch))
			{
				if (forbiddenVariable != null && forbiddenVariable.IsUsedWithin(load))
					return false;
				target = load;
				targetKind = CompoundTargetKind.Property;
				return true;
			}
			else if (load is LdLoc ldloc && store is StLoc stloc && ILVariableEqualityComparer.Instance.Equals(ldloc.Variable, stloc.Variable))
			{
				if (ILVariableEqualityComparer.Instance.Equals(ldloc.Variable, forbiddenVariable))
					return false;
				target = new LdLoca(ldloc.Variable).WithILRange(ldloc);
				targetKind = CompoundTargetKind.Address;
				finalizeMatch = context => context.Function.RecombineVariables(ldloc.Variable, stloc.Variable);
				return true;
			}
			else
			{
				return false;
			}

			bool IsDuplicatedAddressComputation(ILInstruction storeTarget, ILInstruction loadTarget)
			{
				// Sometimes roslyn duplicates the address calculation:
				// stloc S_0(ldloc refParam)
				// stloc V_0(ldobj System.Int32(ldloc refParam))
				// stobj System.Int32(ldloc S_0, binary.add.i4(ldloc V_0, ldc.i4 1))
				while (storeTarget is LdFlda storeLdFlda && loadTarget is LdFlda loadLdFlda)
				{
					if (!storeLdFlda.Field.Equals(loadLdFlda.Field))
						return false;
					storeTarget = storeLdFlda.Target;
					loadTarget = loadLdFlda.Target;
				}
				if (!storeTarget.MatchLdLoc(out var s))
					return false;
				if (!(s.Kind == VariableKind.StackSlot && s.IsSingleDefinition && s != forbiddenVariable))
					return false;
				if (s.StoreInstructions.SingleOrDefault() != previousInstruction)
					return false;
				return previousInstruction is StLoc addressStore && addressStore.Value.Match(loadTarget).Success;
			}
		}

		/// <code>
		/// stobj(target, binary.add(stloc l(ldobj(target)), ldc.i4 1))
		///   where target is pure and does not use 'l', and the 'stloc l' does not truncate
		/// -->
		/// stloc l(compound.op.old(ldobj(target), ldc.i4 1))
		/// 
		///  -or-
		/// 
		/// call set_Prop(args..., binary.add(stloc l(call get_Prop(args...)), ldc.i4 1))
		///   where args.. are pure and do not use 'l', and the 'stloc l' does not truncate
		/// -->
		/// stloc l(compound.op.old(call get_Prop(target), ldc.i4 1))
		/// </code>
		/// <remarks>
		/// This pattern is used for post-increment by legacy csc.
		/// 
		/// Even though this transform operates only on a single expression, it's not an expression transform
		/// as the result value of the expression changes (this is OK only for statements in a block).
		/// </remarks>
		bool TransformPostIncDecOperatorWithInlineStore(Block block, int pos)
		{
			var store = block.Instructions[pos];
			if (!IsCompoundStore(store, out var targetType, out var value, context.TypeSystem))
			{
				return false;
			}
			StLoc stloc;
			var binary = UnwrapSmallIntegerConv(value, out var conv) as BinaryNumericInstruction;
			if (binary != null && (binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1)))
			{
				if (!(binary.Operator == BinaryNumericOperator.Add || binary.Operator == BinaryNumericOperator.Sub))
					return false;
				if (!ValidateCompoundAssign(binary, conv, targetType, context.Settings))
					return false;
				stloc = binary.Left as StLoc;
			}
			else if (value is Call operatorCall && operatorCall.Method.IsOperator && operatorCall.Arguments.Count == 1)
			{
				if (!(operatorCall.Method.Name == "op_Increment" || operatorCall.Method.Name == "op_Decrement"))
					return false;
				if (operatorCall.IsLifted)
					return false; // TODO: add tests and think about whether nullables need special considerations
				stloc = operatorCall.Arguments[0] as StLoc;
			}
			else
			{
				return false;
			}
			if (stloc == null)
				return false;
			if (!(stloc.Variable.Kind == VariableKind.Local || stloc.Variable.Kind == VariableKind.StackSlot))
				return false;
			if (!IsMatchingCompoundLoad(stloc.Value, store, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: stloc.Variable))
				return false;
			if (IsImplicitTruncation(stloc.Value, stloc.Variable.Type, context.TypeSystem))
				return false;
			context.Step("TransformPostIncDecOperatorWithInlineStore", store);
			finalizeMatch?.Invoke(context);
			if (binary != null)
			{
				block.Instructions[pos] = new StLoc(stloc.Variable, new NumericCompoundAssign(
					binary, target, targetKind, binary.Right, targetType, CompoundEvalMode.EvaluatesToOldValue));
			}
			else
			{
				Call operatorCall = (Call)value;
				block.Instructions[pos] = new StLoc(stloc.Variable, new UserDefinedCompoundAssign(
					operatorCall.Method, CompoundEvalMode.EvaluatesToOldValue, target, targetKind, new LdcI4(1)));
			}
			return true;
		}

		/// <code>
		/// stloc tmp(ldobj(target))
		/// stobj(target, binary.op(ldloc tmp, ldc.i4 1))
		///   target is pure and does not use 'tmp', 'stloc does not truncate'
		/// -->
		/// stloc tmp(compound.op.old(ldobj(target), ldc.i4 1))
		/// </code>
		/// This is usually followed by inlining or eliminating 'tmp'.
		/// 
		/// Local variables use a similar pattern, also detected by this function:
		/// <code>
		/// stloc tmp(ldloc target)
		/// stloc target(binary.op(ldloc tmp, ldc.i4 1))
		/// -->
		/// stloc tmp(compound.op.old(ldloca target, ldc.i4 1))
		/// </code>
		/// <remarks>
		/// This pattern occurs with legacy csc for static fields, and with Roslyn for most post-increments.
		/// </remarks>
		bool TransformPostIncDecOperator(Block block, int i)
		{
			var inst = block.Instructions[i] as StLoc;
			var store = block.Instructions.ElementAtOrDefault(i + 1);
			if (inst == null || store == null)
				return false;
			var tmpVar = inst.Variable;
			if (!IsCompoundStore(store, out var targetType, out var value, context.TypeSystem))
				return false;
			if (IsImplicitTruncation(inst.Value, targetType, context.TypeSystem))
			{
				// 'stloc tmp' is implicitly truncating the value
				return false;
			}
			if (!IsMatchingCompoundLoad(inst.Value, store, out var target, out var targetKind, out var finalizeMatch,
				forbiddenVariable: inst.Variable,
				previousInstruction: block.Instructions.ElementAtOrDefault(i - 1)))
			{
				return false;
			}
			if (UnwrapSmallIntegerConv(value, out var conv) is BinaryNumericInstruction binary)
			{
				if (!binary.Left.MatchLdLoc(tmpVar) || !(binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1)))
					return false;
				if (!(binary.Operator == BinaryNumericOperator.Add || binary.Operator == BinaryNumericOperator.Sub))
					return false;
				if (!ValidateCompoundAssign(binary, conv, targetType, context.Settings))
					return false;
				context.Step("TransformPostIncDecOperator (builtin)", inst);
				finalizeMatch?.Invoke(context);
				inst.Value = new NumericCompoundAssign(binary, target, targetKind, binary.Right,
					targetType, CompoundEvalMode.EvaluatesToOldValue);
			}
			else if (value is Call operatorCall && operatorCall.Method.IsOperator && operatorCall.Arguments.Count == 1)
			{
				if (!operatorCall.Arguments[0].MatchLdLoc(tmpVar))
					return false;
				if (!(operatorCall.Method.Name == "op_Increment" || operatorCall.Method.Name == "op_Decrement"))
					return false;
				if (operatorCall.IsLifted)
					return false; // TODO: add tests and think about whether nullables need special considerations
				context.Step("TransformPostIncDecOperator (user-defined)", inst);
				finalizeMatch?.Invoke(context);
				inst.Value = new UserDefinedCompoundAssign(operatorCall.Method,
					CompoundEvalMode.EvaluatesToOldValue, target, targetKind, new LdcI4(1));
			}
			else
			{
				return false;
			}
			block.Instructions.RemoveAt(i + 1);
			if (inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 0)
			{
				// dead store -> it was a statement-level post-increment
				inst.ReplaceWith(inst.Value);
			}
			return true;
		}

		static bool IsSameMember(IMember a, IMember b)
		{
			if (a == null || b == null)
				return false;
			a = a.MemberDefinition;
			b = b.MemberDefinition;
			return a.Equals(b);
		}
	}
}

---- Transformed Tree ----
using System;
using System.Diagnostics;
using System.Linq;

using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.TypeSystem.Implementation;
using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.IL.Transforms
{
	/// <summary>
	/// Constructs compound assignments and inline assignments.
	/// </summary>
	/// <remarks>
	/// This is a statement transform;
	/// but some portions are executed as an expression transform instead
	/// (with HandleCompoundAssign() as entry point)
	/// </remarks>
	public class TransformAssignment : IStatementTransform
	{
		StatementTransformContext context;

		void IStatementTransform.Run(Block block, int pos, StatementTransformContext context)
		{
			this.context = context;
			if (context.Settings.MakeAssignmentExpressions)
			{
				if (TransformInlineAssignmentStObjOrCall(block, pos) || TransformInlineAssignmentLocal(block, pos))
				{
					// both inline assignments create a top-level stloc which might affect inlining
					context.RequestRerun();
					return;
				}
			}
			if (context.Settings.IntroduceIncrementAndDecrement)
			{
				if (TransformPostIncDecOperatorWithInlineStore(block, pos)
					|| TransformPostIncDecOperator(block, pos))
				{
					// again, new top-level stloc might need inlining:
					context.RequestRerun();
					return;
				}
			}
		}

		/// <code>
		/// stloc s(value)
		/// stloc l(ldloc s)
		/// stobj(..., ldloc s)
		///   where ... is pure and does not use s or l,
		///   and where neither the 'stloc s' nor the 'stobj' truncates
		/// -->
		/// stloc l(stobj (..., value))
		/// </code>
		/// e.g. used for inline assignment to instance field
		/// 
		/// -or-
		/// 
		/// <code>
		/// stloc s(value)
		/// stobj (..., ldloc s)
		///   where ... is pure and does not use s, and where the 'stobj' does not truncate
		/// -->
		/// stloc s(stobj (..., value))
		/// </code>
		/// e.g. used for inline assignment to static field
		/// 
		/// -or-
		/// 
		/// <code>
		/// stloc s(value)
		/// call set_Property(..., ldloc s)
		///   where the '...' arguments are pure and not using 's'
		/// -->
		/// stloc s(Block InlineAssign { call set_Property(..., stloc i(value)); final: ldloc i })
		///   new temporary 'i' has type of the property; transform only valid if 'stloc i' doesn't truncate
		/// </code>
		bool TransformInlineAssignmentStObjOrCall(Block block, int pos)
		{
			var inst = block.Instructions[pos] as StLoc;
			// in some cases it can be a compiler-generated local
			if (inst == null || (inst.Variable.Kind != VariableKind.StackSlot && inst.Variable.Kind != VariableKind.Local))
				return false;
			if (IsImplicitTruncation(inst.Value, inst.Variable.Type, context.TypeSystem))
			{
				// 'stloc s' is implicitly truncating the value
				return false;
			}
			ILVariable local;
			int nextPos;
			if (block.Instructions[pos + 1] is StLoc localStore)
			{ // with extra local
				if (localStore.Variable.Kind != VariableKind.Local || !localStore.Value.MatchLdLoc(inst.Variable))
					return false;
				// if we're using an extra local, we'll delete "s", so check that that doesn't have any additional uses
				if (!(inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 2))
					return false;
				local = localStore.Variable;
				nextPos = pos + 2;
			}
			else
			{
				local = inst.Variable;
				localStore = null;
				nextPos = pos + 1;
			}
			if (block.Instructions[nextPos] is StObj stobj)
			{
				if (!stobj.Value.MatchLdLoc(inst.Variable))
					return false;
				if (!SemanticHelper.IsPure(stobj.Target.Flags) || inst.Variable.IsUsedWithin(stobj.Target))
					return false;
				var pointerType = stobj.Target.InferType(context.TypeSystem);
				IType newType = stobj.Type;
				if (TypeUtils.IsCompatiblePointerTypeForMemoryAccess(pointerType, stobj.Type))
				{
					if (pointerType is ByReferenceType byref)
						newType = byref.ElementType;
					else if (pointerType is PointerType pointer)
						newType = pointer.ElementType;
				}
				if (IsImplicitTruncation(inst.Value, newType, context.TypeSystem))
				{
					// 'stobj' is implicitly truncating the value
					return false;
				}
				context.Step("Inline assignment stobj", stobj);
				stobj.Type = newType;
				block.Instructions.Remove(localStore);
				block.Instructions.Remove(stobj);
				stobj.Value = inst.Value;
				inst.ReplaceWith(new StLoc(local, stobj));
				// note: our caller will trigger a re-run, which will call HandleStObjCompoundAssign if applicable
				return true;
			}
			else if (block.Instructions[nextPos] is CallInstruction call)
			{
				// call must be a setter call:
				if (!(call.OpCode == OpCode.Call || call.OpCode == OpCode.CallVirt))
					return false;
				if (call.ResultType != StackType.Void || call.Arguments.Count == 0)
					return false;
				IProperty property = call.Method.AccessorOwner as IProperty;
				if (property == null)
					return false;
				if (!call.Method.Equals(property.Setter))
					return false;
				if (!(property.IsIndexer || property.Setter.Parameters.Count == 1))
				{
					// this is a parameterized property, which cannot be expressed as C# code.
					// setter calls are not valid in expression context, if property syntax cannot be used.
					return false;
				}
				if (!call.Arguments.Last().MatchLdLoc(inst.Variable))
					return false;
				foreach (var arg in call.Arguments.SkipLast(1))
				{
					if (!SemanticHelper.IsPure(arg.Flags) || inst.Variable.IsUsedWithin(arg))
						return false;
				}
				if (IsImplicitTruncation(inst.Value, call.Method.Parameters.Last().Type, context.TypeSystem))
				{
					// setter call is implicitly truncating the value
					return false;
				}
				// stloc s(Block InlineAssign { call set_Property(..., stloc i(value)); final: ldloc i })
				context.Step("Inline assignment call", call);
				block.Instructions.Remove(localStore);
				block.Instructions.Remove(call);
				var newVar = context.Function.RegisterVariable(VariableKind.StackSlot, call.Method.Parameters.Last().Type);
				call.Arguments[call.Arguments.Count - 1] = new StLoc(newVar, inst.Value);
				var inlineBlock = new Block(BlockKind.CallInlineAssign) {
					Instructions = { call },
					FinalInstruction = new LdLoc(newVar)
				};
				inst.ReplaceWith(new StLoc(local, inlineBlock));
				// because the ExpressionTransforms don't look into inline blocks, manually trigger HandleCallCompoundAssign
				if (HandleCompoundAssign(call, context))
				{
					// if we did construct a compound assignment, it should have made our inline block redundant:
					Debug.Assert(!inlineBlock.IsConnected);
				}
				return true;
			}
			else
			{
				return false;
			}
		}

		static ILInstruction UnwrapSmallIntegerConv(ILInstruction inst, out Conv conv)
		{
			conv = inst as Conv;
			if (conv != null && conv.Kind == ConversionKind.Truncate && conv.TargetType.IsSmallIntegerType())
			{
				// for compound assignments to small integers, the compiler emits a "conv" instruction
				return conv.Argument;
			}
			else
			{
				return inst;
			}
		}

		static bool ValidateCompoundAssign(BinaryNumericInstruction binary, Conv conv, IType targetType, DecompilerSettings settings)
		{
			if (!NumericCompoundAssign.IsBinaryCompatibleWithType(binary, targetType, settings))
				return false;
			if (conv != null && !(conv.TargetType == targetType.ToPrimitiveType() && conv.CheckForOverflow == binary.CheckForOverflow))
				return false; // conv does not match binary operation
			return true;
		}

		static bool MatchingGetterAndSetterCalls(CallInstruction getterCall, CallInstruction setterCall, out Action<ILTransformContext> finalizeMatch)
		{
			finalizeMatch = null;
			if (getterCall == null || setterCall == null || !IsSameMember(getterCall.Method.AccessorOwner, setterCall.Method.AccessorOwner))
				return false;
			if (setterCall.OpCode != getterCall.OpCode)
				return false;
			var owner = getterCall.Method.AccessorOwner as IProperty;
			if (owner == null || !IsSameMember(getterCall.Method, owner.Getter) || !IsSameMember(setterCall.Method, owner.Setter))
				return false;
			if (setterCall.Arguments.Count != getterCall.Arguments.Count + 1)
				return false;
			// Ensure that same arguments are passed to getterCall and setterCall:
			for (int j = 0; j < getterCall.Arguments.Count; j++)
			{
				if (setterCall.Arguments[j].MatchStLoc(out var v) && v.IsSingleDefinition && v.LoadCount == 1)
				{
					if (getterCall.Arguments[j].MatchLdLoc(v))
					{
						// OK, setter call argument is saved in temporary that is re-used for getter call
						if (finalizeMatch == null)
						{
							finalizeMatch = AdjustArguments;
						}
						continue;
					}
				}
				if (!SemanticHelper.IsPure(getterCall.Arguments[j].Flags))
					return false;
				if (!getterCall.Arguments[j].Match(setterCall.Arguments[j]).Success)
					return false;
			}
			return true;

			void AdjustArguments(ILTransformContext context)
			{
				Debug.Assert(setterCall.Arguments.Count == getterCall.Arguments.Count + 1);
				for (int j = 0; j < getterCall.Arguments.Count; j++)
				{
					if (setterCall.Arguments[j].MatchStLoc(out var v, out var value))
					{
						Debug.Assert(v.IsSingleDefinition && v.LoadCount == 1);
						Debug.Assert(getterCall.Arguments[j].MatchLdLoc(v));
						getterCall.Arguments[j] = value;
					}
				}
			}
		}

		/// <summary>
		/// Transform compound assignments where the return value is not being used,
		/// or where there's an inlined assignment within the setter call.
		/// 
		/// Patterns handled:
		/// 1.
		///   callvirt set_Property(ldloc S_1, binary.op(callvirt get_Property(ldloc S_1), value))
		///   ==> compound.op.new(callvirt get_Property(ldloc S_1), value)
		/// 2.
		///   callvirt set_Property(ldloc S_1, stloc v(binary.op(callvirt get_Property(ldloc S_1), value)))
		///   ==> stloc v(compound.op.new(callvirt get_Property(ldloc S_1), value))
		/// 3.
		///   stobj(target, binary.op(ldobj(target), ...))
		///     where target is pure
		///   => compound.op(target, ...)
		/// </summary>
		/// <remarks>
		/// Called by ExpressionTransforms, or after the inline-assignment transform for setters.
		/// </remarks>
		internal static bool HandleCompoundAssign(ILInstruction compoundStore, StatementTransformContext context)
		{
			if (!context.Settings.MakeAssignmentExpressions || !context.Settings.IntroduceIncrementAndDecrement)
				return false;
			if (compoundStore is CallInstruction && compoundStore.SlotInfo != Block.InstructionSlot)
			{
				// replacing 'call set_Property' with a compound assignment instruction
				// changes the return value of the expression, so this is only valid on block-level.
				return false;
			}
			if (!IsCompoundStore(compoundStore, out var targetType, out var setterValue, context.TypeSystem))
				return false;

			// targetType = The type of the property/field/etc. being stored to.			// setterValue = The value being stored.
			if (setterValue is StLoc storeInSetter)
			{
				// We'll move the stloc to top-level:
				// callvirt set_Property(ldloc S_1, stloc v(binary.op(callvirt get_Property(ldloc S_1), value)))
				// ==> stloc v(compound.op.new(callvirt get_Property(ldloc S_1), value))
				setterValue = storeInSetter.Value;
				if (storeInSetter.Variable.Type.IsSmallIntegerType())
				{
					// 'stloc v' implicitly truncates the value.
					// Ensure that type of 'v' matches the type of the property:
					if (storeInSetter.Variable.Type.GetSize() != targetType.GetSize())
						return false;
					if (storeInSetter.Variable.Type.GetSign() != targetType.GetSign())
						return false;
				}
			}
			ILInstruction newInst;
			if (UnwrapSmallIntegerConv(setterValue, out var smallIntConv) is BinaryNumericInstruction binary)
			{
				if (compoundStore is StLoc)
				{
					// transform local variables only for user-defined operators
					return false;
				}
				if (!IsMatchingCompoundLoad(binary.Left, compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				if (!ValidateCompoundAssign(binary, smallIntConv, targetType, context.Settings))
					return false;
				context.Step($"Compound assignment (binary.numeric)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new NumericCompoundAssign(
					binary, target, targetKind, binary.Right,
					targetType, CompoundEvalMode.EvaluatesToNewValue);
			}
			else if (setterValue is Call operatorCall && operatorCall.Method.IsOperator)
			{
				if (operatorCall.Arguments.Count == 0)
					return false;
				if (!IsMatchingCompoundLoad(operatorCall.Arguments[0], compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				ILInstruction rhs;
				if (operatorCall.Arguments.Count == 2)
				{
					if (CSharp.ExpressionBuilder.GetAssignmentOperatorTypeFromMetadataName(operatorCall.Method.Name) == null)
						return false;
					rhs = operatorCall.Arguments[1];
				}
				else if (operatorCall.Arguments.Count == 1)
				{
					if (!(operatorCall.Method.Name == "op_Increment" || operatorCall.Method.Name == "op_Decrement"))
						return false;
					// use a dummy node so that we don't need a dedicated instruction for user-defined unary operator calls
					rhs = new LdcI4(1);
				}
				else
				{
					return false;
				}
				if (operatorCall.IsLifted)
					return false; // TODO: add tests and think about whether nullables need special considerations
				context.Step($"Compound assignment (user-defined binary)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new UserDefinedCompoundAssign(operatorCall.Method, CompoundEvalMode.EvaluatesToNewValue,
					target, targetKind, rhs);
			}
			else if (setterValue is DynamicBinaryOperatorInstruction dynamicBinaryOp)
			{
				if (!IsMatchingCompoundLoad(dynamicBinaryOp.Left, compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				context.Step($"Compound assignment (dynamic binary)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new DynamicCompoundAssign(dynamicBinaryOp.Operation, dynamicBinaryOp.BinderFlags, target, dynamicBinaryOp.LeftArgumentInfo, dynamicBinaryOp.Right, dynamicBinaryOp.RightArgumentInfo, targetKind);
			}
			else if (setterValue is Call concatCall && UserDefinedCompoundAssign.IsStringConcat(concatCall.Method))
			{
				// setterValue is a string.Concat() invocation
				if (compoundStore is StLoc)
				{
					// transform local variables only for user-defined operators
					return false;
				}
				if (concatCall.Arguments.Count != 2)
					return false; // for now we only support binary compound assignments
				if (!targetType.IsKnownType(KnownTypeCode.String))
					return false;
				if (!IsMatchingCompoundLoad(concatCall.Arguments[0], compoundStore, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: storeInSetter?.Variable))
					return false;
				context.Step($"Compound assignment (string concatenation)", compoundStore);
				finalizeMatch?.Invoke(context);
				newInst = new UserDefinedCompoundAssign(concatCall.Method, CompoundEvalMode.EvaluatesToNewValue,
					target, targetKind, concatCall.Arguments[1]);
			}
			else
			{
				return false;
			}
			newInst.AddILRange(setterValue);

			if (setterValue is StLoc storeInSetter)
			{
				storeInSetter.Value = newInst;
				newInst = storeInSetter;
				context.RequestRerun(); // moving stloc to top-level might trigger inlining
			}
			compoundStore.ReplaceWith(newInst);
			if (newInst.Parent is Block inlineAssignBlock && inlineAssignBlock.Kind == BlockKind.CallInlineAssign)
			{
				// It's possible that we first replaced the instruction in an inline-assign helper block.
				// In such a situation, we know from the block invariant that we're have a storeInSetter.
				Debug.Assert(setterValue is StLoc storeInSetter);
				Debug.Assert(storeInSetter.Variable.IsSingleDefinition && storeInSetter.Variable.LoadCount == 1);
				Debug.Assert(inlineAssignBlock.Instructions.Single() == storeInSetter);
				Debug.Assert(inlineAssignBlock.FinalInstruction.MatchLdLoc(storeInSetter.Variable));
				// Block CallInlineAssign { stloc I_0(compound.op(...)); final: ldloc I_0 }
				// --> compound.op(...)
				inlineAssignBlock.ReplaceWith(storeInSetter.Value);
			}
			return true;
		}

		/// <code>
		/// stloc s(value)
		/// stloc l(ldloc s)
		///   where neither 'stloc s' nor 'stloc l' truncates the value
		/// -->
		/// stloc s(stloc l(value))
		/// </code>
		bool TransformInlineAssignmentLocal(Block block, int pos)
		{
			var inst = block.Instructions[pos] as StLoc;
			var nextInst = block.Instructions.ElementAtOrDefault(pos + 1) as StLoc;
			if (inst == null || nextInst == null)
				return false;
			if (inst.Variable.Kind != VariableKind.StackSlot)
				return false;
			if (!(nextInst.Variable.Kind == VariableKind.Local || nextInst.Variable.Kind == VariableKind.Parameter))
				return false;
			if (!nextInst.Value.MatchLdLoc(inst.Variable))
				return false;
			if (IsImplicitTruncation(inst.Value, inst.Variable.Type, context.TypeSystem))
			{
				// 'stloc s' is implicitly truncating the stack value
				return false;
			}
			if (IsImplicitTruncation(inst.Value, nextInst.Variable.Type, context.TypeSystem))
			{
				// 'stloc l' is implicitly truncating the stack value
				return false;
			}
			if (nextInst.Variable.StackType == StackType.Ref)
			{
				// ref locals need to be initialized when they are declared, so
				// we can only use inline assignments when we know that the
				// ref local is definitely assigned.
				// We don't have an easy way to check for that in this transform,
				// so avoid inline assignments to ref locals for now.
				return false;
			}
			context.Step("Inline assignment to local variable", inst);
			var value = inst.Value;
			var var = nextInst.Variable;
			var stackVar = inst.Variable;
			block.Instructions.RemoveAt(pos);
			nextInst.ReplaceWith(new StLoc(stackVar, new StLoc(var, value)));
			return true;
		}

		/// <summary>
		/// Gets whether 'stobj type(..., value)' would evaluate to a different value than 'value'
		/// due to implicit truncation.
		/// </summary>
		static internal bool IsImplicitTruncation(ILInstruction value, IType type, ICompilation compilation, bool allowNullableValue = false)
		{
			if (!type.IsSmallIntegerType())
			{
				// Implicit truncation in ILAst only happens for small integer types;
				// other types of implicit truncation in IL cause the ILReader to insert
				// conv instructions.
				return false;
			}
			// With small integer types, test whether the value might be changed by
			// truncation (based on type.GetSize()) followed by sign/zero extension (based on type.GetSign()).
			// (it's OK to have false-positives here if we're unsure)
			if (value.MatchLdcI4(out int val))
			{
				switch (type.GetEnumUnderlyingType().GetDefinition()?.KnownTypeCode)
				{
					case KnownTypeCode.Boolean:
						return !(val == 0 || val == 1);
					case KnownTypeCode.Byte:
						return !(val >= byte.MinValue && val <= byte.MaxValue);
					case KnownTypeCode.SByte:
						return !(val >= sbyte.MinValue && val <= sbyte.MaxValue);
					case KnownTypeCode.Int16:
						return !(val >= short.MinValue && val <= short.MaxValue);
					case KnownTypeCode.UInt16:
					case KnownTypeCode.Char:
						return !(val >= ushort.MinValue && val <= ushort.MaxValue);
				}
			}
			else if (value is Conv conv)
			{
				return conv.TargetType != type.ToPrimitiveType();
			}
			else if (value is Comp)
			{
				return false; // comp returns 0 or 1, which always fits
			}
			else if (value is BinaryNumericInstruction bni)
			{
				switch (bni.Operator)
				{
					case BinaryNumericOperator.BitAnd:
					case BinaryNumericOperator.BitOr:
					case BinaryNumericOperator.BitXor:
						// If both input values fit into the type without truncation,
						// the result of a binary operator will also fit.
						return IsImplicitTruncation(bni.Left, type, compilation, allowNullableValue)
							|| IsImplicitTruncation(bni.Right, type, compilation, allowNullableValue);
				}
			}
			else if (value is IfInstruction ifInst)
			{
				return IsImplicitTruncation(ifInst.TrueInst, type, compilation, allowNullableValue)
					|| IsImplicitTruncation(ifInst.FalseInst, type, compilation, allowNullableValue);
			}
			else
			{
				IType inferredType = value.InferType(compilation);
				if (allowNullableValue)
				{
					inferredType = NullableType.GetUnderlyingType(inferredType);
				}
				if (inferredType.Kind != TypeKind.Unknown)
				{
					return !(inferredType.GetSize() <= type.GetSize() && inferredType.GetSign() == type.GetSign());
				}
			}
			return true;
		}

		/// <summary>
		/// Gets whether 'inst' is a possible store for use as a compound store.
		/// </summary>
		/// <remarks>
		/// Output parameters:
		/// storeType: The type of the value being stored.
		/// value: The value being stored (will be analyzed further to detect compound assignments)
		/// 
		/// Every IsCompoundStore() call should be followed by an IsMatchingCompoundLoad() call.
		/// </remarks>
		static bool IsCompoundStore(ILInstruction inst, out IType storeType,
			out ILInstruction value, ICompilation compilation)
		{
			value = null;
			storeType = null;
			if (inst is StObj stobj)
			{
				// stobj.Type may just be 'int' (due to stind.i4) when we're actually operating on a 'ref MyEnum'.
				// Try to determine the real type of the object we're modifying:
				storeType = stobj.Target.InferType(compilation);
				if (storeType is ByReferenceType refType)
				{
					if (TypeUtils.IsCompatibleTypeForMemoryAccess(refType.ElementType, stobj.Type))
					{
						storeType = refType.ElementType;
					}
					else
					{
						storeType = stobj.Type;
					}
				}
				else if (storeType is PointerType pointerType)
				{
					if (TypeUtils.IsCompatibleTypeForMemoryAccess(pointerType.ElementType, stobj.Type))
					{
						storeType = pointerType.ElementType;
					}
					else
					{
						storeType = stobj.Type;
					}
				}
				else
				{
					storeType = stobj.Type;
				}
				value = stobj.Value;
				return SemanticHelper.IsPure(stobj.Target.Flags);
			}
			else if (inst is CallInstruction call && (call.OpCode == OpCode.Call || call.OpCode == OpCode.CallVirt))
			{
				if (call.Method.Parameters.Count == 0)
				{
					return false;
				}
				foreach (var arg in call.Arguments.SkipLast(1))
				{
					if (arg.MatchStLoc(out var v) && v.IsSingleDefinition && v.LoadCount == 1)
					{
						continue; // OK, IsMatchingCompoundLoad can perform an adjustment in this special case
					}
					if (!SemanticHelper.IsPure(arg.Flags))
					{
						return false;
					}
				}
				storeType = call.Method.Parameters.Last().Type;
				value = call.Arguments.Last();
				return IsSameMember(call.Method, (call.Method.AccessorOwner as IProperty)?.Setter);
			}
			else if (inst is StLoc stloc && (stloc.Variable.Kind == VariableKind.Local || stloc.Variable.Kind == VariableKind.Parameter))
			{
				storeType = stloc.Variable.Type;
				value = stloc.Value;
				return true;
			}
			else
			{
				return false;
			}
		}

		/// <summary>
		/// Checks whether 'load' and 'store' both access the same store, and can be combined to a compound assignment.
		/// </summary>
		/// <param name="load">The load instruction to test.</param>
		/// <param name="store">The compound store to test against. Must have previously been tested via IsCompoundStore()</param>
		/// <param name="target">The target to use for the compound assignment instruction.</param>
		/// <param name="targetKind">The target kind to use for the compound assignment instruction.</param>
		/// <param name="finalizeMatch">If set to a non-null value, call this delegate to fix up minor mismatches between getter and setter.</param>
		/// <param name="forbiddenVariable">
		/// If given a non-null value, this function returns false if the forbiddenVariable is used in the load/store instructions.
		/// Some transforms effectively move a store around,
		/// which is only valid if the variable stored to does not occur in the compound load/store.
		/// </param>
		/// <param name="previousInstruction">
		/// Instruction preceding the load.
		/// </param>
		static bool IsMatchingCompoundLoad(ILInstruction load, ILInstruction store,
			out ILInstruction target, out CompoundTargetKind targetKind,
			out Action<ILTransformContext> finalizeMatch,
			ILVariable forbiddenVariable = null,
			ILInstruction previousInstruction = null)
		{
			target = null;
			targetKind = 0;
			finalizeMatch = null;
			if (load is LdObj ldobj && store is StObj stobj)
			{
				Debug.Assert(SemanticHelper.IsPure(stobj.Target.Flags));
				if (!SemanticHelper.IsPure(ldobj.Target.Flags))
					return false;
				if (forbiddenVariable != null && forbiddenVariable.IsUsedWithin(ldobj.Target))
					return false;
				target = ldobj.Target;
				targetKind = CompoundTargetKind.Address;
				if (ldobj.Target.Match(stobj.Target).Success)
				{
					return true;
				}
				else if (IsDuplicatedAddressComputation(stobj.Target, ldobj.Target))
				{
					// Use S_0 as target, so that S_0 can later be eliminated by inlining.
					// (we can't eliminate previousInstruction right now, because it's before the transform's starting instruction)
					target = stobj.Target;
					return true;
				}
				else
				{
					return false;
				}
			}
			else if (MatchingGetterAndSetterCalls(load as CallInstruction, store as CallInstruction, out finalizeMatch))
			{
				if (forbiddenVariable != null && forbiddenVariable.IsUsedWithin(load))
					return false;
				target = load;
				targetKind = CompoundTargetKind.Property;
				return true;
			}
			else if (load is LdLoc ldloc && store is StLoc stloc && ILVariableEqualityComparer.Instance.Equals(ldloc.Variable, stloc.Variable))
			{
				if (ILVariableEqualityComparer.Instance.Equals(ldloc.Variable, forbiddenVariable))
					return false;
				target = new LdLoca(ldloc.Variable).WithILRange(ldloc);
				targetKind = CompoundTargetKind.Address;
				finalizeMatch = context => context.Function.RecombineVariables(ldloc.Variable, stloc.Variable);
				return true;
			}
			else
			{
				return false;
			}

			bool IsDuplicatedAddressComputation(ILInstruction storeTarget, ILInstruction loadTarget)
			{
				// Sometimes roslyn duplicates the address calculation:
				// stloc S_0(ldloc refParam)
				// stloc V_0(ldobj System.Int32(ldloc refParam))
				// stobj System.Int32(ldloc S_0, binary.add.i4(ldloc V_0, ldc.i4 1))
				while (storeTarget is LdFlda storeLdFlda && loadTarget is LdFlda loadLdFlda)
				{
					if (!storeLdFlda.Field.Equals(loadLdFlda.Field))
						return false;
					storeTarget = storeLdFlda.Target;
					loadTarget = loadLdFlda.Target;
				}
				if (!storeTarget.MatchLdLoc(out var s))
					return false;
				if (!(s.Kind == VariableKind.StackSlot && s.IsSingleDefinition && s != forbiddenVariable))
					return false;
				if (s.StoreInstructions.SingleOrDefault() != previousInstruction)
					return false;
				return previousInstruction is StLoc addressStore && addressStore.Value.Match(loadTarget).Success;
			}
		}

		/// <code>
		/// stobj(target, binary.add(stloc l(ldobj(target)), ldc.i4 1))
		///   where target is pure and does not use 'l', and the 'stloc l' does not truncate
		/// -->
		/// stloc l(compound.op.old(ldobj(target), ldc.i4 1))
		/// 
		///  -or-
		/// 
		/// call set_Prop(args..., binary.add(stloc l(call get_Prop(args...)), ldc.i4 1))
		///   where args.. are pure and do not use 'l', and the 'stloc l' does not truncate
		/// -->
		/// stloc l(compound.op.old(call get_Prop(target), ldc.i4 1))
		/// </code>
		/// <remarks>
		/// This pattern is used for post-increment by legacy csc.
		/// 
		/// Even though this transform operates only on a single expression, it's not an expression transform
		/// as the result value of the expression changes (this is OK only for statements in a block).
		/// </remarks>
		bool TransformPostIncDecOperatorWithInlineStore(Block block, int pos)
		{
			var store = block.Instructions[pos];
			if (!IsCompoundStore(store, out var targetType, out var value, context.TypeSystem))
			{
				return false;
			}
			StLoc stloc;

			if (UnwrapSmallIntegerConv(value, out var conv) is BinaryNumericInstruction binary && (binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1)))
			{
				if (!(binary.Operator == BinaryNumericOperator.Add || binary.Operator == BinaryNumericOperator.Sub))
					return false;
				if (!ValidateCompoundAssign(binary, conv, targetType, context.Settings))
					return false;
				stloc = binary.Left as StLoc;
			}
			else if (value is Call operatorCall && operatorCall.Method.IsOperator && operatorCall.Arguments.Count == 1)
			{
				if (!(operatorCall.Method.Name == "op_Increment" || operatorCall.Method.Name == "op_Decrement"))
					return false;
				if (operatorCall.IsLifted)
					return false; // TODO: add tests and think about whether nullables need special considerations
				stloc = operatorCall.Arguments[0] as StLoc;
			}
			else
			{
				return false;
			}
			if (stloc == null)
				return false;
			if (!(stloc.Variable.Kind == VariableKind.Local || stloc.Variable.Kind == VariableKind.StackSlot))
				return false;
			if (!IsMatchingCompoundLoad(stloc.Value, store, out var target, out var targetKind, out var finalizeMatch, forbiddenVariable: stloc.Variable))
				return false;
			if (IsImplicitTruncation(stloc.Value, stloc.Variable.Type, context.TypeSystem))
				return false;
			context.Step("TransformPostIncDecOperatorWithInlineStore", store);
			finalizeMatch?.Invoke(context);

			if (UnwrapSmallIntegerConv(value, out var conv) is BinaryNumericInstruction binary)
			{
				block.Instructions[pos] = new StLoc(stloc.Variable, new NumericCompoundAssign(
					binary, target, targetKind, binary.Right, targetType, CompoundEvalMode.EvaluatesToOldValue));
			}
			else
			{
				Call operatorCall = (Call)value;
				block.Instructions[pos] = new StLoc(stloc.Variable, new UserDefinedCompoundAssign(
					operatorCall.Method, CompoundEvalMode.EvaluatesToOldValue, target, targetKind, new LdcI4(1)));
			}
			return true;
		}

		/// <code>
		/// stloc tmp(ldobj(target))
		/// stobj(target, binary.op(ldloc tmp, ldc.i4 1))
		///   target is pure and does not use 'tmp', 'stloc does not truncate'
		/// -->
		/// stloc tmp(compound.op.old(ldobj(target), ldc.i4 1))
		/// </code>
		/// This is usually followed by inlining or eliminating 'tmp'.
		/// 
		/// Local variables use a similar pattern, also detected by this function:
		/// <code>
		/// stloc tmp(ldloc target)
		/// stloc target(binary.op(ldloc tmp, ldc.i4 1))
		/// -->
		/// stloc tmp(compound.op.old(ldloca target, ldc.i4 1))
		/// </code>
		/// <remarks>
		/// This pattern occurs with legacy csc for static fields, and with Roslyn for most post-increments.
		/// </remarks>
		bool TransformPostIncDecOperator(Block block, int i)
		{
			var inst = block.Instructions[i] as StLoc;
			var store = block.Instructions.ElementAtOrDefault(i + 1);
			if (inst == null || store == null)
				return false;
			var tmpVar = inst.Variable;
			if (!IsCompoundStore(store, out var targetType, out var value, context.TypeSystem))
				return false;
			if (IsImplicitTruncation(inst.Value, targetType, context.TypeSystem))
			{
				// 'stloc tmp' is implicitly truncating the value
				return false;
			}
			if (!IsMatchingCompoundLoad(inst.Value, store, out var target, out var targetKind, out var finalizeMatch,
				forbiddenVariable: inst.Variable,
				previousInstruction: block.Instructions.ElementAtOrDefault(i - 1)))
			{
				return false;
			}
			if (UnwrapSmallIntegerConv(value, out var conv) is BinaryNumericInstruction binary)
			{
				if (!binary.Left.MatchLdLoc(tmpVar) || !(binary.Right.MatchLdcI(1) || binary.Right.MatchLdcF4(1) || binary.Right.MatchLdcF8(1)))
					return false;
				if (!(binary.Operator == BinaryNumericOperator.Add || binary.Operator == BinaryNumericOperator.Sub))
					return false;
				if (!ValidateCompoundAssign(binary, conv, targetType, context.Settings))
					return false;
				context.Step("TransformPostIncDecOperator (builtin)", inst);
				finalizeMatch?.Invoke(context);
				inst.Value = new NumericCompoundAssign(binary, target, targetKind, binary.Right,
					targetType, CompoundEvalMode.EvaluatesToOldValue);
			}
			else if (value is Call operatorCall && operatorCall.Method.IsOperator && operatorCall.Arguments.Count == 1)
			{
				if (!operatorCall.Arguments[0].MatchLdLoc(tmpVar))
					return false;
				if (!(operatorCall.Method.Name == "op_Increment" || operatorCall.Method.Name == "op_Decrement"))
					return false;
				if (operatorCall.IsLifted)
					return false; // TODO: add tests and think about whether nullables need special considerations
				context.Step("TransformPostIncDecOperator (user-defined)", inst);
				finalizeMatch?.Invoke(context);
				inst.Value = new UserDefinedCompoundAssign(operatorCall.Method,
					CompoundEvalMode.EvaluatesToOldValue, target, targetKind, new LdcI4(1));
			}
			else
			{
				return false;
			}
			block.Instructions.RemoveAt(i + 1);
			if (inst.Variable.IsSingleDefinition && inst.Variable.LoadCount == 0)
			{
				// dead store -> it was a statement-level post-increment
				inst.ReplaceWith(inst.Value);
			}
			return true;
		}

		static bool IsSameMember(IMember a, IMember b)
		{
			if (a == null || b == null)
				return false;
			a = a.MemberDefinition;
			b = b.MemberDefinition;
			return a.Equals(b);
		}
	}
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(24,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(413,29): error CS0128: A local variable or function named 'storeInSetter' is already defined in this scope,D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(424,39): error CS0136: A local or parameter named 'storeInSetter' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(339,139): error CS0165: Use of unassigned local variable 'storeInSetter',D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(425,18): error CS0165: Use of unassigned local variable 'storeInSetter',D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(792,46): error CS0128: A local variable or function named 'conv' is already defined in this scope,D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(792,80): error CS0128: A local variable or function named 'binary' is already defined in this scope,D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(795,6): error CS0165: Use of unassigned local variable 'binary',D:\a\1\s\ICSharpCode.Decompiler\IL\Transforms\TransformAssignment.cs(24,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;

using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.TypeSystem.Implementation
{
	/// <summary>
	/// Provides helper methods for implementing GetMembers() on IType-implementations.
	/// Note: GetMembersHelper will recursively call back into IType.GetMembers(), but only with
	/// both GetMemberOptions.IgnoreInheritedMembers and GetMemberOptions.ReturnMemberDefinitions set,
	/// and only the 'simple' overloads (not taking type arguments).
	/// 
	/// Ensure that your IType implementation does not use the GetMembersHelper if both flags are set,
	/// otherwise you'll get a StackOverflowException!
	/// </summary>
	static class GetMembersHelper
	{
		#region GetNestedTypes
		public static IEnumerable<IType> GetNestedTypes(IType type, Predicate<ITypeDefinition> filter, GetMemberOptions options)
		{
			return GetNestedTypes(type, null, filter, options);
		}

		public static IEnumerable<IType> GetNestedTypes(IType type, IReadOnlyList<IType> nestedTypeArguments, Predicate<ITypeDefinition> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetNestedTypesImpl(type, nestedTypeArguments, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetNestedTypesImpl(t, nestedTypeArguments, filter, options));
			}
		}

		static IEnumerable<IType> GetNestedTypesImpl(IType outerType, IReadOnlyList<IType> nestedTypeArguments, Predicate<ITypeDefinition> filter, GetMemberOptions options)
		{
			ITypeDefinition outerTypeDef = outerType.GetDefinition();
			if (outerTypeDef == null)
				yield break;

			int outerTypeParameterCount = outerTypeDef.TypeParameterCount;
			ParameterizedType pt = outerType as ParameterizedType;
			foreach (ITypeDefinition nestedType in outerTypeDef.NestedTypes)
			{
				int totalTypeParameterCount = nestedType.TypeParameterCount;
				if (nestedTypeArguments != null)
				{
					if (totalTypeParameterCount - outerTypeParameterCount != nestedTypeArguments.Count)
						continue;
				}
				if (!(filter == null || filter(nestedType)))
					continue;

				if (totalTypeParameterCount == 0 || (options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
				{
					yield return nestedType;
				}
				else
				{
					// We need to parameterize the nested type
					IType[] newTypeArguments = new IType[totalTypeParameterCount];
					for (int i = 0; i < outerTypeParameterCount; i++)
					{
						newTypeArguments[i] = pt != null ? pt.GetTypeArgument(i) : outerTypeDef.TypeParameters[i];
					}
					for (int i = outerTypeParameterCount; i < totalTypeParameterCount; i++)
					{
						if (nestedTypeArguments != null)
							newTypeArguments[i] = nestedTypeArguments[i - outerTypeParameterCount];
						else
							newTypeArguments[i] = SpecialType.UnboundTypeArgument;
					}
					yield return new ParameterizedType(nestedType, newTypeArguments);
				}
			}
		}
		#endregion

		#region GetMethods
		public static IEnumerable<IMethod> GetMethods(IType type, Predicate<IMethod> filter, GetMemberOptions options)
		{
			return GetMethods(type, null, filter, options);
		}

		public static IEnumerable<IMethod> GetMethods(IType type, IReadOnlyList<IType> typeArguments, Predicate<IMethod> filter, GetMemberOptions options)
		{
			if (typeArguments != null && typeArguments.Count > 0)
			{
				filter = FilterTypeParameterCount(typeArguments.Count).And(filter);
			}

			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetMethodsImpl(type, typeArguments, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetMethodsImpl(t, typeArguments, filter, options));
			}
		}

		static Predicate<IMethod> FilterTypeParameterCount(int expectedTypeParameterCount)
		{
			return m => m.TypeParameters.Count == expectedTypeParameterCount;
		}

		const GetMemberOptions declaredMembers = GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions;

		static IEnumerable<IMethod> GetMethodsImpl(IType baseType, IReadOnlyList<IType> methodTypeArguments, Predicate<IMethod> filter, GetMemberOptions options)
		{
			IEnumerable<IMethod> declaredMethods = baseType.GetMethods(filter, options | declaredMembers);

			ParameterizedType pt = baseType as ParameterizedType;
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == 0
				&& (pt != null || (methodTypeArguments != null && methodTypeArguments.Count > 0)))
			{
				TypeParameterSubstitution substitution = null;
				foreach (IMethod m in declaredMethods)
				{
					if (methodTypeArguments != null && methodTypeArguments.Count > 0)
					{
						if (m.TypeParameters.Count != methodTypeArguments.Count)
							continue;
					}
					if (substitution == null)
					{
						if (pt != null)
							substitution = pt.GetSubstitution(methodTypeArguments);
						else
							substitution = new TypeParameterSubstitution(null, methodTypeArguments);
					}
					yield return new SpecializedMethod(m, substitution);
				}
			}
			else
			{
				foreach (IMethod m in declaredMethods)
				{
					yield return m;
				}
			}
		}
		#endregion

		#region GetAccessors
		public static IEnumerable<IMethod> GetAccessors(IType type, Predicate<IMethod> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetAccessorsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetAccessorsImpl(t, filter, options));
			}
		}

		static IEnumerable<IMethod> GetAccessorsImpl(IType baseType, Predicate<IMethod> filter, GetMemberOptions options)
		{
			return GetConstructorsOrAccessorsImpl(baseType, baseType.GetAccessors(filter, options | declaredMembers), options);
		}
		#endregion

		#region GetConstructors
		public static IEnumerable<IMethod> GetConstructors(IType type, Predicate<IMethod> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetConstructorsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetConstructorsImpl(t, filter, options));
			}
		}

		static IEnumerable<IMethod> GetConstructorsImpl(IType baseType, Predicate<IMethod> filter, GetMemberOptions options)
		{
			return GetConstructorsOrAccessorsImpl(baseType, baseType.GetConstructors(filter, options | declaredMembers), options);
		}

		static IEnumerable<IMethod> GetConstructorsOrAccessorsImpl(IType baseType, IEnumerable<IMethod> declaredMembers, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredMembers;
			}

			ParameterizedType pt = baseType as ParameterizedType;
			if (pt != null)
			{
				var substitution = pt.GetSubstitution();
				return declaredMembers.Select(m => new SpecializedMethod(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredMembers;
			}
		}
		#endregion

		#region GetProperties
		public static IEnumerable<IProperty> GetProperties(IType type, Predicate<IProperty> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetPropertiesImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetPropertiesImpl(t, filter, options));
			}
		}

		static IEnumerable<IProperty> GetPropertiesImpl(IType baseType, Predicate<IProperty> filter, GetMemberOptions options)
		{
			IEnumerable<IProperty> declaredProperties = baseType.GetProperties(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredProperties;
			}

			ParameterizedType pt = baseType as ParameterizedType;
			if (pt != null)
			{
				var substitution = pt.GetSubstitution();
				return declaredProperties.Select(m => new SpecializedProperty(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredProperties;
			}
		}
		#endregion

		#region GetFields
		public static IEnumerable<IField> GetFields(IType type, Predicate<IField> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetFieldsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetFieldsImpl(t, filter, options));
			}
		}

		static IEnumerable<IField> GetFieldsImpl(IType baseType, Predicate<IField> filter, GetMemberOptions options)
		{
			IEnumerable<IField> declaredFields = baseType.GetFields(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredFields;
			}

			ParameterizedType pt = baseType as ParameterizedType;
			if (pt != null)
			{
				var substitution = pt.GetSubstitution();
				return declaredFields.Select(m => new SpecializedField(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredFields;
			}
		}
		#endregion

		#region GetEvents
		public static IEnumerable<IEvent> GetEvents(IType type, Predicate<IEvent> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetEventsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetEventsImpl(t, filter, options));
			}
		}

		static IEnumerable<IEvent> GetEventsImpl(IType baseType, Predicate<IEvent> filter, GetMemberOptions options)
		{
			IEnumerable<IEvent> declaredEvents = baseType.GetEvents(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredEvents;
			}

			ParameterizedType pt = baseType as ParameterizedType;
			if (pt != null)
			{
				var substitution = pt.GetSubstitution();
				return declaredEvents.Select(m => new SpecializedEvent(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredEvents;
			}
		}
		#endregion

		#region GetMembers
		public static IEnumerable<IMember> GetMembers(IType type, Predicate<IMember> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetMembersImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetMembersImpl(t, filter, options));
			}
		}

		static IEnumerable<IMember> GetMembersImpl(IType baseType, Predicate<IMember> filter, GetMemberOptions options)
		{
			foreach (var m in GetMethodsImpl(baseType, null, filter, options))
				yield return m;
			foreach (var m in GetPropertiesImpl(baseType, filter, options))
				yield return m;
			foreach (var m in GetFieldsImpl(baseType, filter, options))
				yield return m;
			foreach (var m in GetEventsImpl(baseType, filter, options))
				yield return m;
		}
		#endregion
	}
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;

using ICSharpCode.Decompiler.Util;

namespace ICSharpCode.Decompiler.TypeSystem.Implementation
{
	/// <summary>
	/// Provides helper methods for implementing GetMembers() on IType-implementations.
	/// Note: GetMembersHelper will recursively call back into IType.GetMembers(), but only with
	/// both GetMemberOptions.IgnoreInheritedMembers and GetMemberOptions.ReturnMemberDefinitions set,
	/// and only the 'simple' overloads (not taking type arguments).
	/// 
	/// Ensure that your IType implementation does not use the GetMembersHelper if both flags are set,
	/// otherwise you'll get a StackOverflowException!
	/// </summary>
	static class GetMembersHelper
	{
		#region GetNestedTypes
		public static IEnumerable<IType> GetNestedTypes(IType type, Predicate<ITypeDefinition> filter, GetMemberOptions options)
		{
			return GetNestedTypes(type, null, filter, options);
		}

		public static IEnumerable<IType> GetNestedTypes(IType type, IReadOnlyList<IType> nestedTypeArguments, Predicate<ITypeDefinition> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetNestedTypesImpl(type, nestedTypeArguments, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetNestedTypesImpl(t, nestedTypeArguments, filter, options));
			}
		}

		static IEnumerable<IType> GetNestedTypesImpl(IType outerType, IReadOnlyList<IType> nestedTypeArguments, Predicate<ITypeDefinition> filter, GetMemberOptions options)
		{
			ITypeDefinition outerTypeDef = outerType.GetDefinition();
			if (outerTypeDef == null)
				yield break;

			int outerTypeParameterCount = outerTypeDef.TypeParameterCount;
			foreach (ITypeDefinition nestedType in outerTypeDef.NestedTypes)
			{
				int totalTypeParameterCount = nestedType.TypeParameterCount;
				if (nestedTypeArguments != null)
				{
					if (totalTypeParameterCount - outerTypeParameterCount != nestedTypeArguments.Count)
						continue;
				}
				if (!(filter == null || filter(nestedType)))
					continue;

				if (totalTypeParameterCount == 0 || (options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
				{
					yield return nestedType;
				}
				else
				{
					// We need to parameterize the nested type
					IType[] newTypeArguments = new IType[totalTypeParameterCount];
					for (int i = 0; i < outerTypeParameterCount; i++)
					{
						newTypeArguments[i] = outerType is ParameterizedType pt ? pt.GetTypeArgument(i) : outerTypeDef.TypeParameters[i];
					}
					for (int i = outerTypeParameterCount; i < totalTypeParameterCount; i++)
					{
						if (nestedTypeArguments != null)
							newTypeArguments[i] = nestedTypeArguments[i - outerTypeParameterCount];
						else
							newTypeArguments[i] = SpecialType.UnboundTypeArgument;
					}
					yield return new ParameterizedType(nestedType, newTypeArguments);
				}
			}
		}
		#endregion

		#region GetMethods
		public static IEnumerable<IMethod> GetMethods(IType type, Predicate<IMethod> filter, GetMemberOptions options)
		{
			return GetMethods(type, null, filter, options);
		}

		public static IEnumerable<IMethod> GetMethods(IType type, IReadOnlyList<IType> typeArguments, Predicate<IMethod> filter, GetMemberOptions options)
		{
			if (typeArguments != null && typeArguments.Count > 0)
			{
				filter = FilterTypeParameterCount(typeArguments.Count).And(filter);
			}

			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetMethodsImpl(type, typeArguments, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetMethodsImpl(t, typeArguments, filter, options));
			}
		}

		static Predicate<IMethod> FilterTypeParameterCount(int expectedTypeParameterCount)
		{
			return m => m.TypeParameters.Count == expectedTypeParameterCount;
		}

		const GetMemberOptions declaredMembers = GetMemberOptions.IgnoreInheritedMembers | GetMemberOptions.ReturnMemberDefinitions;

		static IEnumerable<IMethod> GetMethodsImpl(IType baseType, IReadOnlyList<IType> methodTypeArguments, Predicate<IMethod> filter, GetMemberOptions options)
		{
			IEnumerable<IMethod> declaredMethods = baseType.GetMethods(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == 0
				&& (baseType is ParameterizedType pt || (methodTypeArguments != null && methodTypeArguments.Count > 0)))
			{
				TypeParameterSubstitution substitution = null;
				foreach (IMethod m in declaredMethods)
				{
					if (methodTypeArguments != null && methodTypeArguments.Count > 0)
					{
						if (m.TypeParameters.Count != methodTypeArguments.Count)
							continue;
					}
					if (substitution == null)
					{
						if (baseType is ParameterizedType pt)
							substitution = pt.GetSubstitution(methodTypeArguments);
						else
							substitution = new TypeParameterSubstitution(null, methodTypeArguments);
					}
					yield return new SpecializedMethod(m, substitution);
				}
			}
			else
			{
				foreach (IMethod m in declaredMethods)
				{
					yield return m;
				}
			}
		}
		#endregion

		#region GetAccessors
		public static IEnumerable<IMethod> GetAccessors(IType type, Predicate<IMethod> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetAccessorsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetAccessorsImpl(t, filter, options));
			}
		}

		static IEnumerable<IMethod> GetAccessorsImpl(IType baseType, Predicate<IMethod> filter, GetMemberOptions options)
		{
			return GetConstructorsOrAccessorsImpl(baseType, baseType.GetAccessors(filter, options | declaredMembers), options);
		}
		#endregion

		#region GetConstructors
		public static IEnumerable<IMethod> GetConstructors(IType type, Predicate<IMethod> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetConstructorsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetConstructorsImpl(t, filter, options));
			}
		}

		static IEnumerable<IMethod> GetConstructorsImpl(IType baseType, Predicate<IMethod> filter, GetMemberOptions options)
		{
			return GetConstructorsOrAccessorsImpl(baseType, baseType.GetConstructors(filter, options | declaredMembers), options);
		}

		static IEnumerable<IMethod> GetConstructorsOrAccessorsImpl(IType baseType, IEnumerable<IMethod> declaredMembers, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredMembers;
			}

			if (baseType is ParameterizedType pt)
			{
				var substitution = pt.GetSubstitution();
				return declaredMembers.Select(m => new SpecializedMethod(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredMembers;
			}
		}
		#endregion

		#region GetProperties
		public static IEnumerable<IProperty> GetProperties(IType type, Predicate<IProperty> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetPropertiesImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetPropertiesImpl(t, filter, options));
			}
		}

		static IEnumerable<IProperty> GetPropertiesImpl(IType baseType, Predicate<IProperty> filter, GetMemberOptions options)
		{
			IEnumerable<IProperty> declaredProperties = baseType.GetProperties(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredProperties;
			}

			if (baseType is ParameterizedType pt)
			{
				var substitution = pt.GetSubstitution();
				return declaredProperties.Select(m => new SpecializedProperty(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredProperties;
			}
		}
		#endregion

		#region GetFields
		public static IEnumerable<IField> GetFields(IType type, Predicate<IField> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetFieldsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetFieldsImpl(t, filter, options));
			}
		}

		static IEnumerable<IField> GetFieldsImpl(IType baseType, Predicate<IField> filter, GetMemberOptions options)
		{
			IEnumerable<IField> declaredFields = baseType.GetFields(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredFields;
			}

			if (baseType is ParameterizedType pt)
			{
				var substitution = pt.GetSubstitution();
				return declaredFields.Select(m => new SpecializedField(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredFields;
			}
		}
		#endregion

		#region GetEvents
		public static IEnumerable<IEvent> GetEvents(IType type, Predicate<IEvent> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetEventsImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetEventsImpl(t, filter, options));
			}
		}

		static IEnumerable<IEvent> GetEventsImpl(IType baseType, Predicate<IEvent> filter, GetMemberOptions options)
		{
			IEnumerable<IEvent> declaredEvents = baseType.GetEvents(filter, options | declaredMembers);
			if ((options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions)
			{
				return declaredEvents;
			}

			if (baseType is ParameterizedType pt)
			{
				var substitution = pt.GetSubstitution();
				return declaredEvents.Select(m => new SpecializedEvent(m, substitution) { DeclaringType = pt });
			}
			else
			{
				return declaredEvents;
			}
		}
		#endregion

		#region GetMembers
		public static IEnumerable<IMember> GetMembers(IType type, Predicate<IMember> filter, GetMemberOptions options)
		{
			if ((options & GetMemberOptions.IgnoreInheritedMembers) == GetMemberOptions.IgnoreInheritedMembers)
			{
				return GetMembersImpl(type, filter, options);
			}
			else
			{
				return type.GetNonInterfaceBaseTypes().SelectMany(t => GetMembersImpl(t, filter, options));
			}
		}

		static IEnumerable<IMember> GetMembersImpl(IType baseType, Predicate<IMember> filter, GetMemberOptions options)
		{
			foreach (var m in GetMethodsImpl(baseType, null, filter, options))
				yield return m;
			foreach (var m in GetPropertiesImpl(baseType, filter, options))
				yield return m;
			foreach (var m in GetFieldsImpl(baseType, filter, options))
				yield return m;
			foreach (var m in GetEventsImpl(baseType, filter, options))
				yield return m;
		}
		#endregion
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\Implementation\GetMembersHelper.cs(145,41): error CS0136: A local or parameter named 'pt' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\ICSharpCode.Decompiler\TypeSystem\ParameterListComparer.cs
Description: Error: Unable to create valid SyntaxTree for document: ParameterListComparer.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (x is IParameterizedMember px && y is IParameterizedMember py)
			{
				if (x is IMethod mx && y is IMethod my && mx.TypeParameters.Count != my.TypeParameters.Count)
					return false;
				return ParameterListComparer.Instance.Equals(px.Parameters, py.Parameters);
			}
			else
			{
				return true;
			}
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (x is IParameterizedMember px && y is IParameterizedMember py)
			{
				if (x is IMethod mx && y is IMethod my && mx.TypeParameters.Count != my.TypeParameters.Count)
					return false;
				return ParameterListComparer.Instance.Equals(px.Parameters, py.Parameters);
			}
			else
			{
				return true;
			}
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;

using ICSharpCode.Decompiler.TypeSystem.Implementation;

namespace ICSharpCode.Decompiler.TypeSystem
{
	/// <summary>
	/// Compares parameter lists by comparing the types of all parameters.
	/// </summary>
	/// <remarks>
	/// 'ref int' and 'out int' are considered to be equal - unless <see cref="includeModifiers" /> is set to true.
	/// 'object' and 'dynamic' are also equal.
	/// For generic methods, "Method{T}(T a)" and "Method{S}(S b)" are considered equal.
	/// However, "Method(T a)" and "Method(S b)" are not considered equal when the type parameters T and S belong to classes.
	/// </remarks>
	public sealed class ParameterListComparer : IEqualityComparer<IReadOnlyList<IParameter>>
	{
		public static readonly ParameterListComparer Instance = new ParameterListComparer();

		static readonly NormalizeTypeVisitor normalizationVisitor = new NormalizeTypeVisitor {
			ReplaceClassTypeParametersWithDummy = false,
			ReplaceMethodTypeParametersWithDummy = true,
			DynamicAndObject = true,
			TupleToUnderlyingType = true,
		};

		bool includeModifiers;

		public static ParameterListComparer WithOptions(bool includeModifiers = false)
		{
			return new ParameterListComparer() {
				includeModifiers = includeModifiers
			};
		}

		public bool Equals(IReadOnlyList<IParameter> x, IReadOnlyList<IParameter> y)
		{
			if (x == y)
				return true;
			if (x == null || y == null || x.Count != y.Count)
				return false;
			for (int i = 0; i < x.Count; i++)
			{
				var a = x[i];
				var b = y[i];
				if (a == null && b == null)
					continue;
				if (a == null || b == null)
					return false;

				if (includeModifiers)
				{
					if (a.ReferenceKind != b.ReferenceKind)
						return false;
					if (a.IsParams != b.IsParams)
						return false;
				}

				// We want to consider the parameter lists "Method<T>(T a)" and "Method<S>(S b)" as equal.
				// However, the parameter types are not considered equal, as T is a different type parameter than S.
				// In order to compare the method signatures, we will normalize all method type parameters.
				IType aType = a.Type.AcceptVisitor(normalizationVisitor);
				IType bType = b.Type.AcceptVisitor(normalizationVisitor);

				if (!aType.Equals(bType))
					return false;
			}
			return true;
		}

		public int GetHashCode(IReadOnlyList<IParameter> obj)
		{
			int hashCode = obj.Count;
			unchecked
			{
				foreach (IParameter p in obj)
				{
					hashCode *= 27;
					IType type = p.Type.AcceptVisitor(normalizationVisitor);
					hashCode += type.GetHashCode();
				}
			}
			return hashCode;
		}
	}

	/// <summary>
	/// Compares member signatures.
	/// </summary>
	/// <remarks>
	/// This comparer checks for equal short name, equal type parameter count, and equal parameter types (using ParameterListComparer).
	/// </remarks>
	public sealed class SignatureComparer : IEqualityComparer<IMember>
	{
		StringComparer nameComparer;

		public SignatureComparer(StringComparer nameComparer)
		{
			if (nameComparer == null)
				throw new ArgumentNullException(nameof(nameComparer));
			this.nameComparer = nameComparer;
		}

		/// <summary>
		/// Gets a signature comparer that uses an ordinal comparison for the member name.
		/// </summary>
		public static readonly SignatureComparer Ordinal = new SignatureComparer(StringComparer.Ordinal);

		public bool Equals(IMember x, IMember y)
		{
			if (x == y)
				return true;
			if (x == null || y == null || x.SymbolKind != y.SymbolKind || !nameComparer.Equals(x.Name, y.Name))
				return false;
			IParameterizedMember px = x as IParameterizedMember;
			IParameterizedMember py = y as IParameterizedMember;
			if (px != null && py != null)
			{
				IMethod mx = x as IMethod;
				IMethod my = y as IMethod;
				if (mx != null && my != null && mx.TypeParameters.Count != my.TypeParameters.Count)
					return false;
				return ParameterListComparer.Instance.Equals(px.Parameters, py.Parameters);
			}
			else
			{
				return true;
			}
		}

		public int GetHashCode(IMember obj)
		{
			unchecked
			{
				int hash = (int)obj.SymbolKind * 33 + nameComparer.GetHashCode(obj.Name);
				IParameterizedMember pm = obj as IParameterizedMember;
				if (pm != null)
				{
					hash *= 27;
					hash += ParameterListComparer.Instance.GetHashCode(pm.Parameters);
					IMethod m = pm as IMethod;
					if (m != null)
						hash += m.TypeParameters.Count;
				}
				return hash;
			}
		}
	}
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


