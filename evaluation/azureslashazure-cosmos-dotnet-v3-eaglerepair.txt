Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Microsoft.Azure.Cosmos
    #1 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\ChangeFeedProcessor\Bootstrapping\PartitionSynchronizerCore.cs, Line: 219, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #2 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\DocumentClient.cs, Line: 1324, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #3 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\DocumentClient.cs, Line: 5443, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #4 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\DocumentClient.cs, Line: 6599, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #5 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\DocumentClient.cs, Line: 6603, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #6 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\GatewayStoreModel.cs, Line: 107, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #7 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\GatewayStoreModel.cs, Line: 116, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #8 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\GatewayStoreModel.cs, Line: 125, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #9 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\GatewayStoreModel.cs, Line: 134, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #10 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\GatewayStoreModel.cs, Line: 98, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #11 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Handler\RequestInvokerHandler.cs, Line: 56, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #12 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Handler\ResponseMessage.cs, Line: 80, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #13 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\ConstantEvaluator.cs, Line: 40, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\ConstantEvaluator.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\ExpressionToSQL.cs, Line: 1653, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\ExpressionToSQL.cs, Line: 523, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #17 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\ExpressionToSQL.cs, Line: 524, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #18 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\QueryUnderConstruction.cs, Line: 365, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\QueryUnderConstruction.cs, Line: 374, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\QueryUnderConstruction.cs, Line: 401, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Linq\QueryUnderConstruction.cs, Line: 427, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs, Line: 757, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #23 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs, Line: 767, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #24 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs, Line: 847, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #25 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs, Line: 857, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #26 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\LexerActionExecutor.cs, Line: 226, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #27 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\LexerChannelAction.cs, Line: 129, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\LexerModeAction.cs, Line: 127, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\LexerPushModeAction.cs, Line: 126, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\LexerTypeAction.cs, Line: 122, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\LL1Analyzer.cs, Line: 317, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #32 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ParserATNSimulator.cs, Line: 2127, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #33 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ParserATNSimulator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #34 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\BufferedTokenStream.cs, Line: 244, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #35 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\CommonToken.cs, Line: 174, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #36 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\DefaultErrorStrategy.cs, Line: 148, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #37 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\DefaultErrorStrategy.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #38 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\DefaultErrorStrategy.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #39 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #40 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\DiagnosticErrorListener.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #41 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\FailedPredicateException.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #42 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Lexer.cs, Line: 118, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #43 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\IntervalSet.cs, Line: 209, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #44 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\IntervalSet.cs, Line: 247, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #45 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\IntervalSet.cs, Line: 265, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #46 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\IntervalSet.cs, Line: 606, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #47 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\Pair.cs, Line: 49, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\RuleDependencyChecker.cs, Line: 664, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\RuleDependencyChecker.cs, Line: 732, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\RuleDependencyChecker.cs, Line: 751, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #51 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\RuleDependencyChecker.cs, Line: 767, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #52 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Misc\RuleDependencyChecker.cs, Line: 773, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #53 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Parser.cs, Line: 1186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #54 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Parser.cs, Line: 202, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #55 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Parser.cs, Line: 607, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #56 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Parser.cs, Line: 771, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #57 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\ParserInterpreter.cs, Line: 273, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #58 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\ParserRuleContext.cs, Line: 150, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\ParserRuleContext.cs, Line: 203, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #60 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\ParserRuleContext.cs, Line: 268, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #61 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\ParserRuleContext.cs, Line: 298, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #62 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\ParserRuleContext.cs, Line: 344, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #63 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\ParseTreeWalker.cs, Line: 27, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #64 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\ParseTreeWalker.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #65 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Pattern\ParseTreeMatch.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #66 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Pattern\ParseTreePatternMatcher.cs, Line: 506, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #67 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Pattern\ParseTreePatternMatcher.cs, Line: 530, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #68 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Pattern\ParseTreePatternMatcher.cs, Line: 693, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #69 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Trees.cs, Line: 122, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #70 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Trees.cs, Line: 19, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #71 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Trees.cs, Line: 90, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #72 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Xpath\XPathRuleElement.cs, Line: 32, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #73 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Tree\Xpath\XPathTokenElement.cs, Line: 31, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #74 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\UnbufferedTokenStream.cs, Line: 268, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #75 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Pagination\CrossPartitionRangePageAsyncEnumerator.cs, Line: 167, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #76 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Metrics\SchedulingTimeSpan.cs, Line: 187, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #77 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Parser\LASets.cs, Line: 451, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #78 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Pipeline\CrossPartition\OrderBy\OrderByCrossPartitionQueryPipelineStage.cs, Line: 314, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #79 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Pipeline\CrossPartition\OrderBy\OrderByCrossPartitionQueryPipelineStage.cs, Line: 426, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #80 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Pipeline\CrossPartition\OrderBy\OrderByCrossPartitionQueryPipelineStage.cs, Line: 632, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #81 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Pipeline\CrossPartition\OrderBy\OrderByCrossPartitionQueryPipelineStage.cs, Line: 632, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #82 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\Pipeline\Skip\SkipQueryPipelineStage.Compute.cs, Line: 105, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #83 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\Core\QueryPlan\QueryPlanHandler.cs, Line: 146, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #84 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Query\v2Query\DocumentQueryExecutionContextFactory.cs, Line: 48, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #85 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Resource\Settings\IndexingDirective.cs, Line: 48, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #86 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\ResourceThrottleRetryPolicy.cs, Line: 52, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #87 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\ClientCollectionCache.cs, Line: 81, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #88 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\CollectionCache.cs, Line: 201, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #89 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\GlobalEndpointManager.cs, Line: 146, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #90 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\GlobalEndpointManager.cs, Line: 324, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\PartitionKeyHashRanges.cs, Line: 98, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #92 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\PartitionKeyRangeCache.cs, Line: 120, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #93 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\PartitionKeyRangeCache.cs, Line: 63, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #94 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\PartitionKeyRangeCache.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #95 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\PartitionRoutingHelper.cs, Line: 429, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #96 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\SerializableNameValueCollection.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\Microsoft.Azure.Cosmos\src\SessionContainer.cs, Line: 483, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Microsoft.Azure.Cosmos.Tests
    #98 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\BaselineTest\BaselineTests.cs, Line: 49, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #99 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Batch\BatchUnitTests.cs, Line: 560, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #100 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\BinaryEncodingOverTheWireTests.cs, Line: 274, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #101 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\ChangeFeed\EqualPartitionsBalancingStrategyTests.cs, Line: 30, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #102 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\ChangeFeed\EqualPartitionsBalancingStrategyTests.cs, Line: 38, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #103 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\CosmosElements\LazyCosmosElementTests.cs, Line: 466, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Json\JsonNavigatorTests.cs, Line: 484, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Json\JsonReaderTests.cs, Line: 3268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #106 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Json\JsonRoundtripTests.cs, Line: 463, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #107 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Json\JsonWriterTests.cs, Line: 2622, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Json\JsonWriterTests.cs, Line: 2643, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #109 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Pagination\InMemoryContainer.cs, Line: 605, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #110 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Query\OfflineEngine\AggregateProjectionTransformer.cs, Line: 165, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #111 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\Query\Pipeline\DCountQueryPipelineStageTests.cs, Line: 110, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #112 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\SessionContainerTest.cs, Line: 806, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #113 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Tests\SessionContainerTest.cs, Line: 807, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Microsoft.Azure.Cosmos.EmulatorTests
    #114 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\BaselineTest\BaselineTests.cs, Line: 51, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #115 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Batch\BatchSinglePartitionKeyTests.cs, Line: 1021, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #116 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Batch\BatchTestBase.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #117 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\ChangeFeed\DynamicTests.cs, Line: 101, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #118 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\ChangeFeed\DynamicTests.cs, Line: 161, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #119 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\ChangeFeed\DynamicTests.cs, Line: 51, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #120 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\ChangeFeed\SmokeTests.cs, Line: 328, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #121 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\ClientTestsUtils.cs, Line: 271, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #122 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosDatabaseAccountSettingsTests.cs, Line: 46, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #123 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosDatabaseAccountSettingsTests.cs, Line: 48, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #124 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosItemLinqTests.cs, Line: 225, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #125 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosItemLinqTests.cs, Line: 277, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #126 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosItemTests.cs, Line: 1054, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #127 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosItemTests.cs, Line: 1101, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #128 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosItemTests.cs, Line: 1316, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #129 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosReadFeedTests.cs, Line: 115, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #130 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CosmosReadFeedTests.cs, Line: 162, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #131 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\CustomSerializationTests.cs, Line: 771, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #132 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\FeedToken\ReadFeedTokenTests.cs, Line: 465, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #133 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\FeedToken\ReadFeedTokenTests.cs, Line: 509, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #134 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\GatewayTests.cs, Line: 2853, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #135 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\GatewayTests.cs, Line: 3416, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #136 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\HeadersValidationTests.cs, Line: 641, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #137 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqAggregateFunctionsBaselineTests.cs, Line: 402, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #138 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs, Line: 2148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #139 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs, Line: 2210, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs, Line: 569, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #141 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqTestsCommon.cs, Line: 151, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #142 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\OfferTests.cs, Line: 1054, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #143 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\AggregateQueryTests.cs, Line: 103, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #144 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\AggregateQueryTests.cs, Line: 629, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #145 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\AggregateQueryTests.cs, Line: 698, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #146 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\AggregateQueryTests.cs, Line: 842, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #147 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\AggregateQueryTests.cs, Line: 90, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #148 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\DistinctQueryTests.cs, Line: 112, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #149 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\OrderByQueryTests.cs, Line: 1018, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #150 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\OrderByQueryTests.cs, Line: 1288, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #151 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\OrderByQueryTests.cs, Line: 234, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #152 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\OrderByQueryTests.cs, Line: 237, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #153 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\OrderByQueryTests.cs, Line: 237, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #154 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\OrderByQueryTests.cs, Line: 955, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #155 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\QueryTestsBase.cs, Line: 116, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #156 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\QueryTestsBase.cs, Line: 137, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #157 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\SanityQueryTests.cs, Line: 115, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #158 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\SanityQueryTests.cs, Line: 395, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #159 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\SanityQueryTests.cs, Line: 437, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #160 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\SanityQueryTests.cs, Line: 47, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #161 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Query\SanityQueryTests.cs, Line: 494, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #162 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\QueryTests.cs, Line: 1005, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #163 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\QueryTests.cs, Line: 1382, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #164 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\QueryTests.cs, Line: 1383, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #165 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\QueryTests.cs, Line: 941, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #166 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\ScriptSampleTests.cs, Line: 135, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #167 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\NonPartitionedContainerHelper.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #168 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\NonPartitionedContainerHelper.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #169 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\NonPartitionedContainerHelper.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\NonPartitionedContainerHelper.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #171 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\QueryOracle.cs, Line: 165, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #172 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\QueryOracleUtil.cs, Line: 467, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #173 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\QueryOracleUtil.cs, Line: 551, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #174 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\QueryOracleUtil.cs, Line: 574, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #175 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\QueryOracleUtil.cs, Line: 669, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #176 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\QueryOracleUtil.cs, Line: 712, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #177 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\Util.cs, Line: 123, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #178 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\Utils\Util.cs, Line: 165, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Microsoft.Azure.Cosmos.Performance.Tests
    #179 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Performance.Tests\Benchmarks\MockedItemOfTBenchmark.cs, Line: 123, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #180 Path: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.Performance.Tests\Json\Utils.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Microsoft.Azure.Cosmos.Encryption
    #181 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\AeadAes256CbcHmac256Algorithm.cs, Line: 201, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #182 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\AeadAes256CbcHmac256Algorithm.cs, Line: 355, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #183 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\DataEncryptionKeyContainerCore.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #184 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\EncryptionProcessor.cs, Line: 481, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #185 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\EncryptionProcessor.cs, Line: 553, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #186 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\KeyVault\AzureKeyVaultKeyWrapProvider.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #187 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Custom\KeyVault\AzureKeyVaultKeyWrapProvider.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Microsoft.Azure.Cosmos.Encryption.EmulatorTests
    #188 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\LegacyEncryptionTests.cs, Line: 596, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #189 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\LegacyEncryptionTests.cs, Line: 605, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #190 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\MdeCustomEncryptionTests.cs, Line: 519, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #191 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\MdeCustomEncryptionTests.cs, Line: 529, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #192 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\MdeCustomEncryptionTests.cs, Line: 656, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #193 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\MdeCustomEncryptionTests.cs, Line: 665, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #194 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\MdeEncryptionTests.cs, Line: 447, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #195 Path: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\tests\EmulatorTests\MdeEncryptionTests.cs, Line: 456, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R9: 55
R4: 51
R5: 30
R6: 19
R7: 17
R8: 11
R2: 9
R3: 3

--- Summary ---
Fixed ReSharper issues: 186
Fixed SonarQube issues: 103
Total fixed issues: 195

Finished in: 35 s

######################################################################
Nr: 1 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Dfa;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Sharpen;

namespace Antlr4.Runtime.Atn
{
    /// <author>Sam Harwell</author>
    internal class ATNDeserializer
    {
        public static readonly int SerializedVersion = 3;

        /// <summary>This is the earliest supported serialized UUID.</summary>
        /// <remarks>This is the earliest supported serialized UUID.</remarks>
        private static readonly Guid BaseSerializedUuid;

        /// <summary>
        /// This UUID indicates the serialized ATN contains two sets of
        /// IntervalSets, where the second set's values are encoded as
        /// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
        /// </summary>
        /// <remarks>
        /// This UUID indicates the serialized ATN contains two sets of
        /// IntervalSets, where the second set's values are encoded as
        /// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
        /// </remarks>
        private static readonly Guid AddedUnicodeSmp;

        /// <summary>
        /// This list contains all of the currently supported UUIDs, ordered by when
        /// the feature first appeared in this branch.
        /// </summary>
        /// <remarks>
        /// This list contains all of the currently supported UUIDs, ordered by when
        /// the feature first appeared in this branch.
        /// </remarks>
        private static readonly IList<Guid> SupportedUuids;

        /// <summary>This is the current serialized UUID.</summary>
        /// <remarks>This is the current serialized UUID.</remarks>
        public static readonly Guid SerializedUuid;

        static ATNDeserializer()
        {
			BaseSerializedUuid = new Guid("AADB8D7E-AEEF-4415-AD2B-8204D6CF042E");
			AddedUnicodeSmp = new Guid("59627784-3BE5-417A-B9EB-8131A7286089");
            SupportedUuids = new List<Guid>();
            SupportedUuids.Add(BaseSerializedUuid);
            SupportedUuids.Add(AddedUnicodeSmp);
			SerializedUuid = AddedUnicodeSmp;
        }

        [NotNull]
        private readonly ATNDeserializationOptions deserializationOptions;

        private Guid uuid;

        public ATNDeserializer()
            : this(ATNDeserializationOptions.Default)
        {
        }

        public ATNDeserializer(ATNDeserializationOptions deserializationOptions)
        {
            if (deserializationOptions == null)
            {
                deserializationOptions = ATNDeserializationOptions.Default;
            }
            this.deserializationOptions = deserializationOptions;
        }

        /// <summary>
        /// Determines if a particular serialized representation of an ATN supports
        /// a particular feature, identified by the
        /// <see cref="Guid"/>
        /// used for serializing
        /// the ATN at the time the feature was first introduced.
        /// </summary>
        /// <param name="feature">
        /// The
        /// <see cref="Guid"/>
        /// marking the first time the feature was
        /// supported in the serialized ATN.
        /// </param>
        /// <param name="actualUuid">
        /// The
        /// <see cref="Guid"/>
        /// of the actual serialized ATN which is
        /// currently being deserialized.
        /// </param>
        /// <returns>
        ///
        /// <see langword="true"/>
        /// if the
        /// <paramref name="actualUuid"/>
        /// value represents a
        /// serialized ATN at or after the feature identified by
        /// <paramref name="feature"/>
        /// was
        /// introduced; otherwise,
        /// <see langword="false"/>
        /// .
        /// </returns>
        protected internal virtual bool IsFeatureSupported(Guid feature, Guid actualUuid)
        {
            int featureIndex = SupportedUuids.IndexOf(feature);
            if (featureIndex < 0)
            {
                return false;
            }
            return SupportedUuids.IndexOf(actualUuid) >= featureIndex;
        }

		char[] data;
		int p;

        public virtual ATN Deserialize(char[] data)
        {
			Reset (data);
			CheckVersion ();
			CheckUUID ();
			ATN atn = ReadATN ();
			ReadStates (atn);
			ReadRules (atn);
			ReadModes (atn);
			IList<IntervalSet> sets = new List<IntervalSet>();
			ReadSets (atn, sets, this.ReadInt);
			if (IsFeatureSupported(AddedUnicodeSmp, uuid)) {
				ReadSets (atn, sets, this.ReadInt32);
			}
			ReadEdges (atn, sets);
			ReadDecisions (atn);
			ReadLexerActions (atn);
            MarkPrecedenceDecisions(atn);
			if (deserializationOptions.VerifyAtn) {
				VerifyATN (atn);
			}
			if (deserializationOptions.GenerateRuleBypassTransitions && atn.grammarType == ATNType.Parser) {
				GenerateRuleBypassTransitions (atn);
			}
            if (deserializationOptions.Optimize)
            {
				OptimizeATN (atn);
            }
            IdentifyTailCalls(atn);
            return atn;
        }

		protected internal virtual void OptimizeATN(ATN atn)
		{
			while (true)
			{
				int optimizationCount = 0;
				optimizationCount += InlineSetRules(atn);
				optimizationCount += CombineChainedEpsilons(atn);
				bool preserveOrder = atn.grammarType == ATNType.Lexer;
				optimizationCount += OptimizeSets(atn, preserveOrder);
				if (optimizationCount == 0)
				{
					break;
				}
			}
			if (deserializationOptions.VerifyAtn)
			{
				// reverify after modification
				VerifyATN(atn);
			}
		}

		protected internal virtual void GenerateRuleBypassTransitions(ATN atn)
		{
			atn.ruleToTokenType = new int[atn.ruleToStartState.Length];
			for (int i_10 = 0; i_10 < atn.ruleToStartState.Length; i_10++)
			{
				atn.ruleToTokenType[i_10] = atn.maxTokenType + i_10 + 1;
			}
			for (int i_13 = 0; i_13 < atn.ruleToStartState.Length; i_13++)
			{
				BasicBlockStartState bypassStart = new BasicBlockStartState();
				bypassStart.ruleIndex = i_13;
				atn.AddState(bypassStart);
				BlockEndState bypassStop = new BlockEndState();
				bypassStop.ruleIndex = i_13;
				atn.AddState(bypassStop);
				bypassStart.endState = bypassStop;
				atn.DefineDecisionState(bypassStart);
				bypassStop.startState = bypassStart;
				ATNState endState;
				Transition excludeTransition = null;
				if (atn.ruleToStartState[i_13].isPrecedenceRule)
				{
					// wrap from the beginning of the rule to the StarLoopEntryState
					endState = null;
					foreach (ATNState state_3 in atn.states)
					{
						if (state_3.ruleIndex != i_13)
						{
							continue;
						}
						if (!(state_3 is StarLoopEntryState))
						{
							continue;
						}
						ATNState maybeLoopEndState = state_3.Transition(state_3.NumberOfTransitions - 1).target;
						if (!(maybeLoopEndState is LoopEndState))
						{
							continue;
						}
						if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.Transition(0).target is RuleStopState)
						{
							endState = state_3;
							break;
						}
					}
					if (endState == null)
					{
						throw new NotSupportedException("Couldn't identify final state of the precedence rule prefix section.");
					}
					excludeTransition = ((StarLoopEntryState)endState).loopBackState.Transition(0);
				}
				else
				{
					endState = atn.ruleToStopState[i_13];
				}
				// all non-excluded transitions that currently target end state need to target blockEnd instead
				foreach (ATNState state_4 in atn.states)
				{
					foreach (Transition transition in state_4.transitions)
					{
						if (transition == excludeTransition)
						{
							continue;
						}
						if (transition.target == endState)
						{
							transition.target = bypassStop;
						}
					}
				}
				// all transitions leaving the rule start state need to leave blockStart instead
				while (atn.ruleToStartState[i_13].NumberOfTransitions > 0)
				{
					Transition transition = atn.ruleToStartState[i_13].Transition(atn.ruleToStartState[i_13].NumberOfTransitions - 1);
					atn.ruleToStartState[i_13].RemoveTransition(atn.ruleToStartState[i_13].NumberOfTransitions - 1);
					bypassStart.AddTransition(transition);
				}
				// link the new states
				atn.ruleToStartState[i_13].AddTransition(new EpsilonTransition(bypassStart));
				bypassStop.AddTransition(new EpsilonTransition(endState));
				ATNState matchState = new BasicState();
				atn.AddState(matchState);
				matchState.AddTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[i_13]));
				bypassStart.AddTransition(new EpsilonTransition(matchState));
			}
			if (deserializationOptions.VerifyAtn)
			{
				// reverify after modification
				VerifyATN(atn);
			}
		}

		protected internal virtual void ReadLexerActions(ATN atn)
		{
			//
			// LEXER ACTIONS
			//
			if (atn.grammarType == ATNType.Lexer)
			{
				atn.lexerActions = new ILexerAction[ReadInt()];
				for (int i_10 = 0; i_10 < atn.lexerActions.Length; i_10++)
				{
					LexerActionType actionType = (LexerActionType)ReadInt();
					int data1 = ReadInt();
					if (data1 == unchecked((int)(0xFFFF)))
					{
						data1 = -1;
					}
					int data2 = ReadInt();
					if (data2 == unchecked((int)(0xFFFF)))
					{
						data2 = -1;
					}
					ILexerAction lexerAction = LexerActionFactory(actionType, data1, data2);
					atn.lexerActions[i_10] = lexerAction;
				}
			}
		}

		protected internal virtual void ReadDecisions(ATN atn)
		{
			//
			// DECISIONS
			//
			int ndecisions = ReadInt();
			for (int i_11 = 0; i_11 < ndecisions; i_11++)
			{
				int s = ReadInt();
				DecisionState decState = (DecisionState)atn.states[s];
				atn.decisionToState.Add(decState);
				decState.decision = i_11;
			}
			atn.decisionToDFA = new DFA[ndecisions];
			for (int i_12 = 0; i_12 < ndecisions; i_12++)
			{
				atn.decisionToDFA[i_12] = new DFA(atn.decisionToState[i_12], i_12);
			}
		}

		protected internal virtual void ReadEdges(ATN atn, IList<IntervalSet> sets)
		{
			//
			// EDGES
			//
			int nedges = ReadInt();
			for (int i_9 = 0; i_9 < nedges; i_9++)
			{
				int src = ReadInt();
				int trg = ReadInt();
				TransitionType ttype = (TransitionType)ReadInt();
				int arg1 = ReadInt();
				int arg2 = ReadInt();
				int arg3 = ReadInt();
				Transition trans = EdgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
				ATNState srcState = atn.states[src];
				srcState.AddTransition(trans);
			}
			// edges for rule stop states can be derived, so they aren't serialized
			foreach (ATNState state_1 in atn.states)
			{
				for (int i_10 = 0; i_10 < state_1.NumberOfTransitions; i_10++)
				{
					Transition t = state_1.Transition(i_10);
					if (!(t is RuleTransition))
					{
						continue;
					}
					RuleTransition ruleTransition = (RuleTransition)t;
					int outermostPrecedenceReturn = -1;
					if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule)
					{
						if (ruleTransition.precedence == 0)
						{
							outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
						}
					}
					EpsilonTransition returnTransition = new EpsilonTransition(ruleTransition.followState, outermostPrecedenceReturn);
					atn.ruleToStopState[ruleTransition.target.ruleIndex].AddTransition(returnTransition);
				}
			}
			foreach (ATNState state_2 in atn.states)
			{
				if (state_2 is BlockStartState)
				{
					// we need to know the end state to set its start state
					if (((BlockStartState)state_2).endState == null)
					{
						throw new InvalidOperationException();
					}
					// block end states can only be associated to a single block start state
					if (((BlockStartState)state_2).endState.startState != null)
					{
						throw new InvalidOperationException();
					}
					((BlockStartState)state_2).endState.startState = (BlockStartState)state_2;
				}
				else if (state_2 is PlusLoopbackState)
				{
					PlusLoopbackState loopbackState = (PlusLoopbackState)state_2;
					for (int i_10 = 0; i_10 < loopbackState.NumberOfTransitions; i_10++)
					{
						ATNState target = loopbackState.Transition(i_10).target;
						if (target is PlusBlockStartState)
						{
							((PlusBlockStartState)target).loopBackState = loopbackState;
						}
					}
				}
				else if (state_2 is StarLoopbackState)
				{
					StarLoopbackState loopbackState = (StarLoopbackState)state_2;
					for (int i_10 = 0; i_10 < loopbackState.NumberOfTransitions; i_10++)
					{
						ATNState target = loopbackState.Transition(i_10).target;
						if (target is StarLoopEntryState)
						{
							((StarLoopEntryState)target).loopBackState = loopbackState;
						}
					}
				}
			}
		}

		protected internal virtual void ReadSets(ATN atn, IList<IntervalSet> sets, Func<int> readUnicode)
		{
			//
			// SETS
			//
			int nsets = ReadInt();
			for (int i_8 = 0; i_8 < nsets; i_8++)
			{
				IntervalSet set = new IntervalSet();
				sets.Add(set);
				int nintervals = ReadInt();
				bool containsEof = ReadInt() != 0;
				if (containsEof)
				{
					set.Add(-1);
				}
				for (int j = 0; j < nintervals; j++)
				{
					set.Add(readUnicode(), readUnicode());
				}
			}
		}

		protected internal virtual void ReadModes(ATN atn)
		{
			//
			// MODES
			//
			int nmodes = ReadInt();
			for (int i_6 = 0; i_6 < nmodes; i_6++)
			{
				int _i = ReadInt();
				atn.modeToStartState.Add((TokensStartState)atn.states[_i]);
			}
			// not in Java code
			atn.modeToDFA = new DFA[nmodes];
			for (int i_7 = 0; i_7 < nmodes; i_7++)
			{
				atn.modeToDFA[i_7] = new DFA(atn.modeToStartState[i_7]);
			}
		}

		protected internal virtual void ReadRules(ATN atn)
		{
			//
			// RULES
			//
			int nrules = ReadInt();
			if (atn.grammarType == ATNType.Lexer)
			{
				atn.ruleToTokenType = new int[nrules];
			}
			atn.ruleToStartState = new RuleStartState[nrules];
			for (int i_5 = 0; i_5 < nrules; i_5++)
			{
				int s = ReadInt();
				RuleStartState startState = (RuleStartState)atn.states[s];
				atn.ruleToStartState[i_5] = startState;
				if (atn.grammarType == ATNType.Lexer) {
					int tokenType = ReadInt ();
					if (tokenType == unchecked((int)(0xFFFF))) {
						tokenType = TokenConstants.EOF;
					}
					atn.ruleToTokenType [i_5] = tokenType;
				}
			}
			atn.ruleToStopState = new RuleStopState[nrules];
			foreach (ATNState state in atn.states)
			{
				if (!(state is RuleStopState))
				{
					continue;
				}
				RuleStopState stopState = (RuleStopState)state;
				atn.ruleToStopState[state.ruleIndex] = stopState;
				atn.ruleToStartState[state.ruleIndex].stopState = stopState;
			}
		}

		protected internal virtual void ReadStates(ATN atn)
		{
			//
			// STATES
			//
			IList<Tuple<LoopEndState, int>> loopBackStateNumbers = new List<Tuple<LoopEndState, int>>();
			IList<Tuple<BlockStartState, int>> endStateNumbers = new List<Tuple<BlockStartState, int>>();
			int nstates = ReadInt();
			for (int i_1 = 0; i_1 < nstates; i_1++)
			{
				StateType stype = (StateType)ReadInt();
				// ignore bad type of states
				if (stype == StateType.InvalidType)
				{
					atn.AddState(null);
					continue;
				}
				int ruleIndex = ReadInt();
				if (ruleIndex == char.MaxValue)
				{
					ruleIndex = -1;
				}
				ATNState s = StateFactory(stype, ruleIndex);
				if (stype == StateType.LoopEnd)
				{
					// special case
					int loopBackStateNumber = ReadInt();
					loopBackStateNumbers.Add(Tuple.Create((LoopEndState)s, loopBackStateNumber));
				}
				else
				{
					if (s is BlockStartState)
					{
						int endStateNumber = ReadInt();
						endStateNumbers.Add(Tuple.Create((BlockStartState)s, endStateNumber));
					}
				}
				atn.AddState(s);
			}
			// delay the assignment of loop back and end states until we know all the state instances have been initialized
			foreach (Tuple<LoopEndState, int> pair in loopBackStateNumbers)
			{
				pair.Item1.loopBackState = atn.states[pair.Item2];
			}
			foreach (Tuple<BlockStartState, int> pair_1 in endStateNumbers)
			{
				pair_1.Item1.endState = (BlockEndState)atn.states[pair_1.Item2];
			}
			int numNonGreedyStates = ReadInt();
			for (int i_2 = 0; i_2 < numNonGreedyStates; i_2++)
			{
				int stateNumber = ReadInt();
				((DecisionState)atn.states[stateNumber]).nonGreedy = true;
			}
			int numPrecedenceStates = ReadInt();
			for (int i_4 = 0; i_4 < numPrecedenceStates; i_4++)
			{
				int stateNumber = ReadInt();
				((RuleStartState)atn.states[stateNumber]).isPrecedenceRule = true;
			}
		}

		protected internal virtual ATN ReadATN()
		{
			ATNType grammarType = (ATNType)ReadInt();
			int maxTokenType = ReadInt();
			return new ATN(grammarType, maxTokenType);
		}

		protected internal virtual void CheckUUID()
		{
			uuid = ReadUUID();
			if (!SupportedUuids.Contains(uuid))
			{
				string reason = string.Format(CultureInfo.CurrentCulture, "Could not deserialize ATN with UUID {0} (expected {1} or a legacy UUID).", uuid, SerializedUuid);
				throw new NotSupportedException(reason);
			}
		}

		protected internal virtual void CheckVersion()
		{
			int version = ReadInt();
			if (version != SerializedVersion)
			{
				string reason = string.Format(CultureInfo.CurrentCulture, "Could not deserialize ATN with version {0} (expected {1}).", version, SerializedVersion);
				throw new NotSupportedException(reason);
			}
		}

		protected internal virtual void Reset(char[] data)
		{
			this.data = new char[data.Length];
			// don't adjust the first value since that's the version number
			this.data[0] = data[0];
			for (int i = 1; i < data.Length; i++)
			{
				this.data[i] = (char)(data[i] - 2);
			}
			this.p = 0;
		}

        /// <summary>
        /// Analyze the
        /// <see cref="StarLoopEntryState"/>
        /// states in the specified ATN to set
        /// the
        /// <see cref="StarLoopEntryState.isPrecedenceDecision"/>
        /// field to the
        /// correct value.
        /// </summary>
        /// <param name="atn">The ATN.</param>
        protected internal virtual void MarkPrecedenceDecisions(ATN atn)
        {
            foreach (ATNState state in atn.states)
            {
                if (!(state is StarLoopEntryState))
                {
                    continue;
                }
                if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule)
                {
                    ATNState maybeLoopEndState = state.Transition(state.NumberOfTransitions - 1).target;
                    if (maybeLoopEndState is LoopEndState)
                    {
                        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.Transition(0).target is RuleStopState)
                        {
							((StarLoopEntryState)state).isPrecedenceDecision = true;
                        }
                    }
                }
            }
        }

        protected internal virtual void VerifyATN(ATN atn)
        {
            // verify assumptions
            foreach (ATNState state in atn.states)
            {
                if (state == null)
                {
                    continue;
                }
                CheckCondition(state.OnlyHasEpsilonTransitions || state.NumberOfTransitions <= 1);
                if (state is PlusBlockStartState)
                {
                    CheckCondition(((PlusBlockStartState)state).loopBackState != null);
                }
                if (state is StarLoopEntryState)
                {
                    StarLoopEntryState starLoopEntryState = (StarLoopEntryState)state;
                    CheckCondition(starLoopEntryState.loopBackState != null);
                    CheckCondition(starLoopEntryState.NumberOfTransitions == 2);
                    if (starLoopEntryState.Transition(0).target is StarBlockStartState)
                    {
                        CheckCondition(starLoopEntryState.Transition(1).target is LoopEndState);
                        CheckCondition(!starLoopEntryState.nonGreedy);
                    }
                    else
                    {
                        if (starLoopEntryState.Transition(0).target is LoopEndState)
                        {
                            CheckCondition(starLoopEntryState.Transition(1).target is StarBlockStartState);
                            CheckCondition(starLoopEntryState.nonGreedy);
                        }
                        else
                        {
                            throw new InvalidOperationException();
                        }
                    }
                }
                if (state is StarLoopbackState)
                {
                    CheckCondition(state.NumberOfTransitions == 1);
                    CheckCondition(state.Transition(0).target is StarLoopEntryState);
                }
                if (state is LoopEndState)
                {
                    CheckCondition(((LoopEndState)state).loopBackState != null);
                }
                if (state is RuleStartState)
                {
                    CheckCondition(((RuleStartState)state).stopState != null);
                }
                if (state is BlockStartState)
                {
                    CheckCondition(((BlockStartState)state).endState != null);
                }
                if (state is BlockEndState)
                {
                    CheckCondition(((BlockEndState)state).startState != null);
                }
                if (state is DecisionState)
                {
                    DecisionState decisionState = (DecisionState)state;
                    CheckCondition(decisionState.NumberOfTransitions <= 1 || decisionState.decision >= 0);
                }
                else
                {
                    CheckCondition(state.NumberOfTransitions <= 1 || state is RuleStopState);
                }
            }
        }

        protected internal virtual void CheckCondition(bool condition)
        {
            CheckCondition(condition, null);
        }

        protected internal virtual void CheckCondition(bool condition, string message)
        {
            if (!condition)
            {
                throw new InvalidOperationException(message);
            }
        }

        private static int InlineSetRules(ATN atn)
        {
            int inlinedCalls = 0;
            Transition[] ruleToInlineTransition = new Transition[atn.ruleToStartState.Length];
            for (int i = 0; i < atn.ruleToStartState.Length; i++)
            {
                RuleStartState startState = atn.ruleToStartState[i];
                ATNState middleState = startState;
                while (middleState.OnlyHasEpsilonTransitions && middleState.NumberOfOptimizedTransitions == 1 && middleState.GetOptimizedTransition(0).TransitionType == TransitionType.EPSILON)
                {
                    middleState = middleState.GetOptimizedTransition(0).target;
                }
                if (middleState.NumberOfOptimizedTransitions != 1)
                {
                    continue;
                }
                Transition matchTransition = middleState.GetOptimizedTransition(0);
                ATNState matchTarget = matchTransition.target;
                if (matchTransition.IsEpsilon || !matchTarget.OnlyHasEpsilonTransitions || matchTarget.NumberOfOptimizedTransitions != 1 || !(matchTarget.GetOptimizedTransition(0).target is RuleStopState))
                {
                    continue;
                }
                switch (matchTransition.TransitionType)
                {
                    case TransitionType.ATOM:
                    case TransitionType.RANGE:
                    case TransitionType.SET:
                    {
                        ruleToInlineTransition[i] = matchTransition;
                        break;
                    }

                    case TransitionType.NOT_SET:
                    case TransitionType.WILDCARD:
                    {
                        // not implemented yet
                        continue;
                    }

                    default:
                    {
                        continue;
                    }
                }
            }
            for (int stateNumber = 0; stateNumber < atn.states.Count; stateNumber++)
            {
                ATNState state = atn.states[stateNumber];
                if (state.ruleIndex < 0)
                {
                    continue;
                }
                IList<Transition> optimizedTransitions = null;
                for (int i_1 = 0; i_1 < state.NumberOfOptimizedTransitions; i_1++)
                {
                    Transition transition = state.GetOptimizedTransition(i_1);
                    if (!(transition is RuleTransition))
                    {
                        if (optimizedTransitions != null)
                        {
                            optimizedTransitions.Add(transition);
                        }
                        continue;
                    }
                    RuleTransition ruleTransition = (RuleTransition)transition;
                    Transition effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
                    if (effective == null)
                    {
                        if (optimizedTransitions != null)
                        {
                            optimizedTransitions.Add(transition);
                        }
                        continue;
                    }
                    if (optimizedTransitions == null)
                    {
                        optimizedTransitions = new List<Transition>();
                        for (int j = 0; j < i_1; j++)
                        {
                            optimizedTransitions.Add(state.GetOptimizedTransition(i_1));
                        }
                    }
                    inlinedCalls++;
                    ATNState target = ruleTransition.followState;
                    ATNState intermediateState = new BasicState();
                    intermediateState.SetRuleIndex(target.ruleIndex);
                    atn.AddState(intermediateState);
                    optimizedTransitions.Add(new EpsilonTransition(intermediateState));
                    switch (effective.TransitionType)
                    {
                        case TransitionType.ATOM:
                        {
							intermediateState.AddTransition(new AtomTransition(target, ((AtomTransition)effective).token));
                            break;
                        }

                        case TransitionType.RANGE:
                        {
                            intermediateState.AddTransition(new RangeTransition(target, ((RangeTransition)effective).from, ((RangeTransition)effective).to));
                            break;
                        }

                        case TransitionType.SET:
                        {
                            intermediateState.AddTransition(new SetTransition(target, effective.Label));
                            break;
                        }

                        default:
                        {
                            throw new NotSupportedException();
                        }
                    }
                }
                if (optimizedTransitions != null)
                {
                    if (state.IsOptimized)
                    {
                        while (state.NumberOfOptimizedTransitions > 0)
                        {
                            state.RemoveOptimizedTransition(state.NumberOfOptimizedTransitions - 1);
                        }
                    }
                    foreach (Transition transition in optimizedTransitions)
                    {
                        state.AddOptimizedTransition(transition);
                    }
                }
            }
            return inlinedCalls;
        }

        private static int CombineChainedEpsilons(ATN atn)
        {
            int removedEdges = 0;
            foreach (ATNState state in atn.states)
            {
                if (!state.OnlyHasEpsilonTransitions || state is RuleStopState)
                {
                    continue;
                }
                IList<Transition> optimizedTransitions = null;
                for (int i = 0; i < state.NumberOfOptimizedTransitions; i++)
                {
                    Transition transition = state.GetOptimizedTransition(i);
                    ATNState intermediate = transition.target;
                    if (transition.TransitionType != TransitionType.EPSILON || ((EpsilonTransition)transition).OutermostPrecedenceReturn != -1 || intermediate.StateType != StateType.Basic || !intermediate.OnlyHasEpsilonTransitions)
                    {
                        if (optimizedTransitions != null)
                        {
                            optimizedTransitions.Add(transition);
                        }
                        goto nextTransition_continue;
                    }
                    for (int j = 0; j < intermediate.NumberOfOptimizedTransitions; j++)
                    {
                        if (intermediate.GetOptimizedTransition(j).TransitionType != TransitionType.EPSILON || ((EpsilonTransition)intermediate.GetOptimizedTransition(j)).OutermostPrecedenceReturn != -1)
                        {
                            if (optimizedTransitions != null)
                            {
                                optimizedTransitions.Add(transition);
                            }
                            goto nextTransition_continue;
                        }
                    }
                    removedEdges++;
                    if (optimizedTransitions == null)
                    {
                        optimizedTransitions = new List<Transition>();
                        for (int j_1 = 0; j_1 < i; j_1++)
                        {
                            optimizedTransitions.Add(state.GetOptimizedTransition(j_1));
                        }
                    }
                    for (int j_2 = 0; j_2 < intermediate.NumberOfOptimizedTransitions; j_2++)
                    {
                        ATNState target = intermediate.GetOptimizedTransition(j_2).target;
                        optimizedTransitions.Add(new EpsilonTransition(target));
                    }
nextTransition_continue: ;
                }

                if (optimizedTransitions != null)
                {
                    if (state.IsOptimized)
                    {
                        while (state.NumberOfOptimizedTransitions > 0)
                        {
                            state.RemoveOptimizedTransition(state.NumberOfOptimizedTransitions - 1);
                        }
                    }
                    foreach (Transition transition in optimizedTransitions)
                    {
                        state.AddOptimizedTransition(transition);
                    }
                }
            }

            return removedEdges;
        }

        private static int OptimizeSets(ATN atn, bool preserveOrder)
        {
            if (preserveOrder)
            {
                // this optimization currently doesn't preserve edge order.
                return 0;
            }
            int removedPaths = 0;
            IList<DecisionState> decisions = atn.decisionToState;
            foreach (DecisionState decision in decisions)
            {
                IntervalSet setTransitions = new IntervalSet();
                for (int i = 0; i < decision.NumberOfOptimizedTransitions; i++)
                {
                    Transition epsTransition = decision.GetOptimizedTransition(i);
                    if (!(epsTransition is EpsilonTransition))
                    {
                        continue;
                    }
                    if (epsTransition.target.NumberOfOptimizedTransitions != 1)
                    {
                        continue;
                    }
                    Transition transition = epsTransition.target.GetOptimizedTransition(0);
                    if (!(transition.target is BlockEndState))
                    {
                        continue;
                    }
                    if (transition is NotSetTransition)
                    {
                        // TODO: not yet implemented
                        continue;
                    }
                    if (transition is AtomTransition || transition is RangeTransition || transition is SetTransition)
                    {
                        setTransitions.Add(i);
                    }
                }
                if (setTransitions.Count <= 1)
                {
                    continue;
                }
                IList<Transition> optimizedTransitions = new List<Transition>();
                for (int i_1 = 0; i_1 < decision.NumberOfOptimizedTransitions; i_1++)
                {
                    if (!setTransitions.Contains(i_1))
                    {
                        optimizedTransitions.Add(decision.GetOptimizedTransition(i_1));
                    }
                }
                ATNState blockEndState = decision.GetOptimizedTransition(setTransitions.MinElement).target.GetOptimizedTransition(0).target;
                IntervalSet matchSet = new IntervalSet();
                for (int i_2 = 0; i_2 < setTransitions.GetIntervals().Count; i_2++)
                {
                    Interval interval = setTransitions.GetIntervals()[i_2];
                    for (int j = interval.a; j <= interval.b; j++)
                    {
                        Transition matchTransition = decision.GetOptimizedTransition(j).target.GetOptimizedTransition(0);
                        if (matchTransition is NotSetTransition)
                        {
                            throw new NotSupportedException("Not yet implemented.");
                        }
                        else
                        {
                            matchSet.AddAll(matchTransition.Label);
                        }
                    }
                }
                Transition newTransition;
                if (matchSet.GetIntervals().Count == 1)
                {
                    if (matchSet.Count == 1)
                    {
                        newTransition = new AtomTransition(blockEndState, matchSet.MinElement);
                    }
                    else
                    {
                        Interval matchInterval = matchSet.GetIntervals()[0];
                        newTransition = new RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
                    }
                }
                else
                {
                    newTransition = new SetTransition(blockEndState, matchSet);
                }
                ATNState setOptimizedState = new BasicState();
                setOptimizedState.SetRuleIndex(decision.ruleIndex);
                atn.AddState(setOptimizedState);
                setOptimizedState.AddTransition(newTransition);
                optimizedTransitions.Add(new EpsilonTransition(setOptimizedState));
                removedPaths += decision.NumberOfOptimizedTransitions - optimizedTransitions.Count;
                if (decision.IsOptimized)
                {
                    while (decision.NumberOfOptimizedTransitions > 0)
                    {
                        decision.RemoveOptimizedTransition(decision.NumberOfOptimizedTransitions - 1);
                    }
                }
                foreach (Transition transition_1 in optimizedTransitions)
                {
                    decision.AddOptimizedTransition(transition_1);
                }
            }
            return removedPaths;
        }

        private static void IdentifyTailCalls(ATN atn)
        {
            foreach (ATNState state in atn.states)
            {
                foreach (Transition transition in state.transitions)
                {
                    if (!(transition is RuleTransition))
                    {
                        continue;
                    }
                    RuleTransition ruleTransition = (RuleTransition)transition;
                    ruleTransition.tailCall = TestTailCall(atn, ruleTransition, false);
                    ruleTransition.optimizedTailCall = TestTailCall(atn, ruleTransition, true);
                }
                if (!state.IsOptimized)
                {
                    continue;
                }
                foreach (Transition transition_1 in state.optimizedTransitions)
                {
                    if (!(transition_1 is RuleTransition))
                    {
                        continue;
                    }
                    RuleTransition ruleTransition = (RuleTransition)transition_1;
                    ruleTransition.tailCall = TestTailCall(atn, ruleTransition, false);
                    ruleTransition.optimizedTailCall = TestTailCall(atn, ruleTransition, true);
                }
            }
        }

        private static bool TestTailCall(ATN atn, RuleTransition transition, bool optimizedPath)
        {
            if (!optimizedPath && transition.tailCall)
            {
                return true;
            }
            if (optimizedPath && transition.optimizedTailCall)
            {
                return true;
            }
            BitSet reachable = new BitSet(atn.states.Count);
            Stack<ATNState> worklist = new Stack<ATNState>();
            worklist.Push(transition.followState);
            while (worklist.Count > 0)
            {
                ATNState state = worklist.Pop();
                if (reachable.Get(state.stateNumber))
                {
                    continue;
                }
                if (state is RuleStopState)
                {
                    continue;
                }
                if (!state.OnlyHasEpsilonTransitions)
                {
                    return false;
                }
                IList<Transition> transitions = optimizedPath ? state.optimizedTransitions : state.transitions;
                foreach (Transition t in transitions)
                {
                    if (t.TransitionType != TransitionType.EPSILON)
                    {
                        return false;
                    }
                    worklist.Push(t.target);
                }
            }
            return true;
        }


        protected internal int ReadInt()
        {
			return data[p++];
        }

        protected internal int ReadInt32()
        {
			return (int)data[p++] | ((int)data[p++] << 16);
        }

        protected internal long ReadLong()
        {
            long lowOrder = ReadInt32() & unchecked((long)(0x00000000FFFFFFFFL));
            return lowOrder | ((long)ReadInt32() << 32);
        }

        protected internal Guid ReadUUID()
        {
			byte[] d = BitConverter.GetBytes (ReadLong ());
			if(BitConverter.IsLittleEndian)
			{
				Array.Reverse(d);
			}
			short c = (short)ReadInt();
			short b = (short)ReadInt();
			int a = ReadInt32();
            return new Guid(a, b, c, d);
        }

        [return: NotNull]
        protected internal virtual Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList<IntervalSet> sets)
        {
            ATNState target = atn.states[trg];
            switch (type)
            {
                case TransitionType.EPSILON:
                {
                    return new EpsilonTransition(target);
                }

                case TransitionType.RANGE:
                {
                    if (arg3 != 0)
                    {
                        return new RangeTransition(target, TokenConstants.EOF, arg2);
                    }
                    else
                    {
                        return new RangeTransition(target, arg1, arg2);
                    }
                }

                case TransitionType.RULE:
                {
                    RuleTransition rt = new RuleTransition((RuleStartState)atn.states[arg1], arg2, arg3, target);
                    return rt;
                }

                case TransitionType.PREDICATE:
                {
                    PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);
                    return pt;
                }

                case TransitionType.PRECEDENCE:
                {
                    return new PrecedencePredicateTransition(target, arg1);
                }

                case TransitionType.ATOM:
                {
                    if (arg3 != 0)
                    {
                        return new AtomTransition(target, TokenConstants.EOF);
                    }
                    else
                    {
                        return new AtomTransition(target, arg1);
                    }
                }

                case TransitionType.ACTION:
                {
                    ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);
                    return a;
                }

                case TransitionType.SET:
                {
                    return new SetTransition(target, sets[arg1]);
                }

                case TransitionType.NOT_SET:
                {
                    return new NotSetTransition(target, sets[arg1]);
                }

                case TransitionType.WILDCARD:
                {
                    return new WildcardTransition(target);
                }
            }
            throw new ArgumentException("The specified transition type is not valid.");
        }

        protected internal virtual ATNState StateFactory(StateType type, int ruleIndex)
        {
            ATNState s;
            switch (type)
            {
                case StateType.InvalidType:
                {
                    return null;
                }

                case StateType.Basic:
                {
                    s = new BasicState();
                    break;
                }

                case StateType.RuleStart:
                {
                    s = new RuleStartState();
                    break;
                }

                case StateType.BlockStart:
                {
                    s = new BasicBlockStartState();
                    break;
                }

                case StateType.PlusBlockStart:
                {
                    s = new PlusBlockStartState();
                    break;
                }

                case StateType.StarBlockStart:
                {
                    s = new StarBlockStartState();
                    break;
                }

                case StateType.TokenStart:
                {
                    s = new TokensStartState();
                    break;
                }

                case StateType.RuleStop:
                {
                    s = new RuleStopState();
                    break;
                }

                case StateType.BlockEnd:
                {
                    s = new BlockEndState();
                    break;
                }

                case StateType.StarLoopBack:
                {
                    s = new StarLoopbackState();
                    break;
                }

                case StateType.StarLoopEntry:
                {
                    s = new StarLoopEntryState();
                    break;
                }

                case StateType.PlusLoopBack:
                {
                    s = new PlusLoopbackState();
                    break;
                }

                case StateType.LoopEnd:
                {
                    s = new LoopEndState();
                    break;
                }

                default:
                {
                    string message = string.Format(CultureInfo.CurrentCulture, "The specified state type {0} is not valid.", type);
                    throw new ArgumentException(message);
                }
            }
            s.ruleIndex = ruleIndex;
            return s;
        }

        protected internal virtual ILexerAction LexerActionFactory(LexerActionType type, int data1, int data2)
        {
            switch (type)
            {
                case LexerActionType.Channel:
                {
                    return new LexerChannelAction(data1);
                }

                case LexerActionType.Custom:
                {
                    return new LexerCustomAction(data1, data2);
                }

                case LexerActionType.Mode:
                {
                    return new LexerModeAction(data1);
                }

                case LexerActionType.More:
                {
                    return LexerMoreAction.Instance;
                }

                case LexerActionType.PopMode:
                {
                    return LexerPopModeAction.Instance;
                }

                case LexerActionType.PushMode:
                {
                    return new LexerPushModeAction(data1);
                }

                case LexerActionType.Skip:
                {
                    return LexerSkipAction.Instance;
                }

                case LexerActionType.Type:
                {
                    return new LexerTypeAction(data1);
                }

                default:
                {
                    string message = string.Format(CultureInfo.CurrentCulture, "The specified lexer action type {0} is not valid.", type);
                    throw new ArgumentException(message);
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Dfa;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Sharpen;

namespace Antlr4.Runtime.Atn
{
    /// <author>Sam Harwell</author>
    internal class ATNDeserializer
    {
        public static readonly int SerializedVersion = 3;

        /// <summary>This is the earliest supported serialized UUID.</summary>
        /// <remarks>This is the earliest supported serialized UUID.</remarks>
        private static readonly Guid BaseSerializedUuid;

        /// <summary>
        /// This UUID indicates the serialized ATN contains two sets of
        /// IntervalSets, where the second set's values are encoded as
        /// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
        /// </summary>
        /// <remarks>
        /// This UUID indicates the serialized ATN contains two sets of
        /// IntervalSets, where the second set's values are encoded as
        /// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
        /// </remarks>
        private static readonly Guid AddedUnicodeSmp;

        /// <summary>
        /// This list contains all of the currently supported UUIDs, ordered by when
        /// the feature first appeared in this branch.
        /// </summary>
        /// <remarks>
        /// This list contains all of the currently supported UUIDs, ordered by when
        /// the feature first appeared in this branch.
        /// </remarks>
        private static readonly IList<Guid> SupportedUuids;

        /// <summary>This is the current serialized UUID.</summary>
        /// <remarks>This is the current serialized UUID.</remarks>
        public static readonly Guid SerializedUuid;

        static ATNDeserializer()
        {
			BaseSerializedUuid = new Guid("AADB8D7E-AEEF-4415-AD2B-8204D6CF042E");
			AddedUnicodeSmp = new Guid("59627784-3BE5-417A-B9EB-8131A7286089");
            SupportedUuids = new List<Guid>();
            SupportedUuids.Add(BaseSerializedUuid);
            SupportedUuids.Add(AddedUnicodeSmp);
			SerializedUuid = AddedUnicodeSmp;
        }

        [NotNull]
        private readonly ATNDeserializationOptions deserializationOptions;

        private Guid uuid;

        public ATNDeserializer()
            : this(ATNDeserializationOptions.Default)
        {
        }

        public ATNDeserializer(ATNDeserializationOptions deserializationOptions)
        {
            if (deserializationOptions == null)
            {
                deserializationOptions = ATNDeserializationOptions.Default;
            }
            this.deserializationOptions = deserializationOptions;
        }

        /// <summary>
        /// Determines if a particular serialized representation of an ATN supports
        /// a particular feature, identified by the
        /// <see cref="Guid"/>
        /// used for serializing
        /// the ATN at the time the feature was first introduced.
        /// </summary>
        /// <param name="feature">
        /// The
        /// <see cref="Guid"/>
        /// marking the first time the feature was
        /// supported in the serialized ATN.
        /// </param>
        /// <param name="actualUuid">
        /// The
        /// <see cref="Guid"/>
        /// of the actual serialized ATN which is
        /// currently being deserialized.
        /// </param>
        /// <returns>
        ///
        /// <see langword="true"/>
        /// if the
        /// <paramref name="actualUuid"/>
        /// value represents a
        /// serialized ATN at or after the feature identified by
        /// <paramref name="feature"/>
        /// was
        /// introduced; otherwise,
        /// <see langword="false"/>
        /// .
        /// </returns>
        protected internal virtual bool IsFeatureSupported(Guid feature, Guid actualUuid)
        {
            int featureIndex = SupportedUuids.IndexOf(feature);
            if (featureIndex < 0)
            {
                return false;
            }
            return SupportedUuids.IndexOf(actualUuid) >= featureIndex;
        }

		char[] data;
		int p;

        public virtual ATN Deserialize(char[] data)
        {
			Reset (data);
			CheckVersion ();
			CheckUUID ();
			ATN atn = ReadATN ();
			ReadStates (atn);
			ReadRules (atn);
			ReadModes (atn);
			IList<IntervalSet> sets = new List<IntervalSet>();
			ReadSets (atn, sets, this.ReadInt);
			if (IsFeatureSupported(AddedUnicodeSmp, uuid)) {
				ReadSets (atn, sets, this.ReadInt32);
			}
			ReadEdges (atn, sets);
			ReadDecisions (atn);
			ReadLexerActions (atn);
            MarkPrecedenceDecisions(atn);
			if (deserializationOptions.VerifyAtn) {
				VerifyATN (atn);
			}
			if (deserializationOptions.GenerateRuleBypassTransitions && atn.grammarType == ATNType.Parser) {
				GenerateRuleBypassTransitions (atn);
			}
            if (deserializationOptions.Optimize)
            {
				OptimizeATN (atn);
            }
            IdentifyTailCalls(atn);
            return atn;
        }

		protected internal virtual void OptimizeATN(ATN atn)
		{
			while (true)
			{
				int optimizationCount = 0;
				optimizationCount += InlineSetRules(atn);
				optimizationCount += CombineChainedEpsilons(atn);
				bool preserveOrder = atn.grammarType == ATNType.Lexer;
				optimizationCount += OptimizeSets(atn, preserveOrder);
				if (optimizationCount == 0)
				{
					break;
				}
			}
			if (deserializationOptions.VerifyAtn)
			{
				// reverify after modification
				VerifyATN(atn);
			}
		}

		protected internal virtual void GenerateRuleBypassTransitions(ATN atn)
		{
			atn.ruleToTokenType = new int[atn.ruleToStartState.Length];
			for (int i_10 = 0; i_10 < atn.ruleToStartState.Length; i_10++)
			{
				atn.ruleToTokenType[i_10] = atn.maxTokenType + i_10 + 1;
			}
			for (int i_13 = 0; i_13 < atn.ruleToStartState.Length; i_13++)
			{
				BasicBlockStartState bypassStart = new BasicBlockStartState();
				bypassStart.ruleIndex = i_13;
				atn.AddState(bypassStart);
				BlockEndState bypassStop = new BlockEndState();
				bypassStop.ruleIndex = i_13;
				atn.AddState(bypassStop);
				bypassStart.endState = bypassStop;
				atn.DefineDecisionState(bypassStart);
				bypassStop.startState = bypassStart;
				ATNState endState;
				Transition excludeTransition = null;
				if (atn.ruleToStartState[i_13].isPrecedenceRule)
				{
					// wrap from the beginning of the rule to the StarLoopEntryState
					endState = null;
					foreach (ATNState state_3 in atn.states)
					{
						if (state_3.ruleIndex != i_13)
						{
							continue;
						}
						if (!(state_3 is StarLoopEntryState))
						{
							continue;
						}
						ATNState maybeLoopEndState = state_3.Transition(state_3.NumberOfTransitions - 1).target;
						if (!(maybeLoopEndState is LoopEndState))
						{
							continue;
						}
						if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.Transition(0).target is RuleStopState)
						{
							endState = state_3;
							break;
						}
					}
					if (endState == null)
					{
						throw new NotSupportedException("Couldn't identify final state of the precedence rule prefix section.");
					}
					excludeTransition = ((StarLoopEntryState)endState).loopBackState.Transition(0);
				}
				else
				{
					endState = atn.ruleToStopState[i_13];
				}
				// all non-excluded transitions that currently target end state need to target blockEnd instead
				foreach (ATNState state_4 in atn.states)
				{
					foreach (Transition transition in state_4.transitions)
					{
						if (transition == excludeTransition)
						{
							continue;
						}
						if (transition.target == endState)
						{
							transition.target = bypassStop;
						}
					}
				}
				// all transitions leaving the rule start state need to leave blockStart instead
				while (atn.ruleToStartState[i_13].NumberOfTransitions > 0)
				{
					Transition transition = atn.ruleToStartState[i_13].Transition(atn.ruleToStartState[i_13].NumberOfTransitions - 1);
					atn.ruleToStartState[i_13].RemoveTransition(atn.ruleToStartState[i_13].NumberOfTransitions - 1);
					bypassStart.AddTransition(transition);
				}
				// link the new states
				atn.ruleToStartState[i_13].AddTransition(new EpsilonTransition(bypassStart));
				bypassStop.AddTransition(new EpsilonTransition(endState));
				ATNState matchState = new BasicState();
				atn.AddState(matchState);
				matchState.AddTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[i_13]));
				bypassStart.AddTransition(new EpsilonTransition(matchState));
			}
			if (deserializationOptions.VerifyAtn)
			{
				// reverify after modification
				VerifyATN(atn);
			}
		}

		protected internal virtual void ReadLexerActions(ATN atn)
		{
			//
			// LEXER ACTIONS
			//
			if (atn.grammarType == ATNType.Lexer)
			{
				atn.lexerActions = new ILexerAction[ReadInt()];
				for (int i_10 = 0; i_10 < atn.lexerActions.Length; i_10++)
				{
					LexerActionType actionType = (LexerActionType)ReadInt();
					int data1 = ReadInt();
					if (data1 == unchecked((int)(0xFFFF)))
					{
						data1 = -1;
					}
					int data2 = ReadInt();
					if (data2 == unchecked((int)(0xFFFF)))
					{
						data2 = -1;
					}
					ILexerAction lexerAction = LexerActionFactory(actionType, data1, data2);
					atn.lexerActions[i_10] = lexerAction;
				}
			}
		}

		protected internal virtual void ReadDecisions(ATN atn)
		{
			//
			// DECISIONS
			//
			int ndecisions = ReadInt();
			for (int i_11 = 0; i_11 < ndecisions; i_11++)
			{
				int s = ReadInt();
				DecisionState decState = (DecisionState)atn.states[s];
				atn.decisionToState.Add(decState);
				decState.decision = i_11;
			}
			atn.decisionToDFA = new DFA[ndecisions];
			for (int i_12 = 0; i_12 < ndecisions; i_12++)
			{
				atn.decisionToDFA[i_12] = new DFA(atn.decisionToState[i_12], i_12);
			}
		}

		protected internal virtual void ReadEdges(ATN atn, IList<IntervalSet> sets)
		{
			//
			// EDGES
			//
			int nedges = ReadInt();
			for (int i_9 = 0; i_9 < nedges; i_9++)
			{
				int src = ReadInt();
				int trg = ReadInt();
				TransitionType ttype = (TransitionType)ReadInt();
				int arg1 = ReadInt();
				int arg2 = ReadInt();
				int arg3 = ReadInt();
				Transition trans = EdgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
				ATNState srcState = atn.states[src];
				srcState.AddTransition(trans);
			}
			// edges for rule stop states can be derived, so they aren't serialized
			foreach (ATNState state_1 in atn.states)
			{
				for (int i_10 = 0; i_10 < state_1.NumberOfTransitions; i_10++)
				{
					Transition t = state_1.Transition(i_10);
					if (!(t is RuleTransition))
					{
						continue;
					}
					RuleTransition ruleTransition = (RuleTransition)t;
					int outermostPrecedenceReturn = -1;
					if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule)
					{
						if (ruleTransition.precedence == 0)
						{
							outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
						}
					}
					EpsilonTransition returnTransition = new EpsilonTransition(ruleTransition.followState, outermostPrecedenceReturn);
					atn.ruleToStopState[ruleTransition.target.ruleIndex].AddTransition(returnTransition);
				}
			}
			foreach (ATNState state_2 in atn.states)
			{
				if (state_2 is BlockStartState blockStartState)
				{
					// we need to know the end state to set its start state
					if (blockStartState.endState == null)
					{
						throw new InvalidOperationException();
					}
					// block end states can only be associated to a single block start state
					if (((BlockStartState)state_2).endState.startState != null)
					{
						throw new InvalidOperationException();
					}
					((BlockStartState)state_2).endState.startState = (BlockStartState)state_2;
				}
				else if (state_2 is PlusLoopbackState loopbackState)
				{
					for (int i_10 = 0; i_10 < loopbackState.NumberOfTransitions; i_10++)
					{
						ATNState target = loopbackState.Transition(i_10).target;
						if (target is PlusBlockStartState plusBlockStartState)
						{
							plusBlockStartState.loopBackState = loopbackState;
						}
					}
				}
				else if (state_2 is StarLoopbackState loopbackState)
				{
					for (int i_10 = 0; i_10 < loopbackState.NumberOfTransitions; i_10++)
					{
						ATNState target = loopbackState.Transition(i_10).target;
						if (target is StarLoopEntryState starLoopEntryState)
						{
							starLoopEntryState.loopBackState = loopbackState;
						}
					}
				}
			}
		}

		protected internal virtual void ReadSets(ATN atn, IList<IntervalSet> sets, Func<int> readUnicode)
		{
			//
			// SETS
			//
			int nsets = ReadInt();
			for (int i_8 = 0; i_8 < nsets; i_8++)
			{
				IntervalSet set = new IntervalSet();
				sets.Add(set);
				int nintervals = ReadInt();
				bool containsEof = ReadInt() != 0;
				if (containsEof)
				{
					set.Add(-1);
				}
				for (int j = 0; j < nintervals; j++)
				{
					set.Add(readUnicode(), readUnicode());
				}
			}
		}

		protected internal virtual void ReadModes(ATN atn)
		{
			//
			// MODES
			//
			int nmodes = ReadInt();
			for (int i_6 = 0; i_6 < nmodes; i_6++)
			{
				int _i = ReadInt();
				atn.modeToStartState.Add((TokensStartState)atn.states[_i]);
			}
			// not in Java code
			atn.modeToDFA = new DFA[nmodes];
			for (int i_7 = 0; i_7 < nmodes; i_7++)
			{
				atn.modeToDFA[i_7] = new DFA(atn.modeToStartState[i_7]);
			}
		}

		protected internal virtual void ReadRules(ATN atn)
		{
			//
			// RULES
			//
			int nrules = ReadInt();
			if (atn.grammarType == ATNType.Lexer)
			{
				atn.ruleToTokenType = new int[nrules];
			}
			atn.ruleToStartState = new RuleStartState[nrules];
			for (int i_5 = 0; i_5 < nrules; i_5++)
			{
				int s = ReadInt();
				RuleStartState startState = (RuleStartState)atn.states[s];
				atn.ruleToStartState[i_5] = startState;
				if (atn.grammarType == ATNType.Lexer) {
					int tokenType = ReadInt ();
					if (tokenType == unchecked((int)(0xFFFF))) {
						tokenType = TokenConstants.EOF;
					}
					atn.ruleToTokenType [i_5] = tokenType;
				}
			}
			atn.ruleToStopState = new RuleStopState[nrules];
			foreach (ATNState state in atn.states)
			{
				if (!(state is RuleStopState))
				{
					continue;
				}
				RuleStopState stopState = (RuleStopState)state;
				atn.ruleToStopState[state.ruleIndex] = stopState;
				atn.ruleToStartState[state.ruleIndex].stopState = stopState;
			}
		}

		protected internal virtual void ReadStates(ATN atn)
		{
			//
			// STATES
			//
			IList<Tuple<LoopEndState, int>> loopBackStateNumbers = new List<Tuple<LoopEndState, int>>();
			IList<Tuple<BlockStartState, int>> endStateNumbers = new List<Tuple<BlockStartState, int>>();
			int nstates = ReadInt();
			for (int i_1 = 0; i_1 < nstates; i_1++)
			{
				StateType stype = (StateType)ReadInt();
				// ignore bad type of states
				if (stype == StateType.InvalidType)
				{
					atn.AddState(null);
					continue;
				}
				int ruleIndex = ReadInt();
				if (ruleIndex == char.MaxValue)
				{
					ruleIndex = -1;
				}
				ATNState s = StateFactory(stype, ruleIndex);
				if (stype == StateType.LoopEnd)
				{
					// special case
					int loopBackStateNumber = ReadInt();
					loopBackStateNumbers.Add(Tuple.Create((LoopEndState)s, loopBackStateNumber));
				}
				else
				{
					if (s is BlockStartState blockStartState)
					{
						int endStateNumber = ReadInt();
						endStateNumbers.Add(Tuple.Create(blockStartState, endStateNumber));
					}
				}
				atn.AddState(s);
			}
			// delay the assignment of loop back and end states until we know all the state instances have been initialized
			foreach (Tuple<LoopEndState, int> pair in loopBackStateNumbers)
			{
				pair.Item1.loopBackState = atn.states[pair.Item2];
			}
			foreach (Tuple<BlockStartState, int> pair_1 in endStateNumbers)
			{
				pair_1.Item1.endState = (BlockEndState)atn.states[pair_1.Item2];
			}
			int numNonGreedyStates = ReadInt();
			for (int i_2 = 0; i_2 < numNonGreedyStates; i_2++)
			{
				int stateNumber = ReadInt();
				((DecisionState)atn.states[stateNumber]).nonGreedy = true;
			}
			int numPrecedenceStates = ReadInt();
			for (int i_4 = 0; i_4 < numPrecedenceStates; i_4++)
			{
				int stateNumber = ReadInt();
				((RuleStartState)atn.states[stateNumber]).isPrecedenceRule = true;
			}
		}

		protected internal virtual ATN ReadATN()
		{
			ATNType grammarType = (ATNType)ReadInt();
			int maxTokenType = ReadInt();
			return new ATN(grammarType, maxTokenType);
		}

		protected internal virtual void CheckUUID()
		{
			uuid = ReadUUID();
			if (!SupportedUuids.Contains(uuid))
			{
				string reason = string.Format(CultureInfo.CurrentCulture, "Could not deserialize ATN with UUID {0} (expected {1} or a legacy UUID).", uuid, SerializedUuid);
				throw new NotSupportedException(reason);
			}
		}

		protected internal virtual void CheckVersion()
		{
			int version = ReadInt();
			if (version != SerializedVersion)
			{
				string reason = string.Format(CultureInfo.CurrentCulture, "Could not deserialize ATN with version {0} (expected {1}).", version, SerializedVersion);
				throw new NotSupportedException(reason);
			}
		}

		protected internal virtual void Reset(char[] data)
		{
			this.data = new char[data.Length];
			// don't adjust the first value since that's the version number
			this.data[0] = data[0];
			for (int i = 1; i < data.Length; i++)
			{
				this.data[i] = (char)(data[i] - 2);
			}
			this.p = 0;
		}

        /// <summary>
        /// Analyze the
        /// <see cref="StarLoopEntryState"/>
        /// states in the specified ATN to set
        /// the
        /// <see cref="StarLoopEntryState.isPrecedenceDecision"/>
        /// field to the
        /// correct value.
        /// </summary>
        /// <param name="atn">The ATN.</param>
        protected internal virtual void MarkPrecedenceDecisions(ATN atn)
        {
            foreach (ATNState state in atn.states)
            {
                if (!(state is StarLoopEntryState))
                {
                    continue;
                }
                if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule)
                {
                    ATNState maybeLoopEndState = state.Transition(state.NumberOfTransitions - 1).target;
                    if (maybeLoopEndState is LoopEndState)
                    {
                        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.Transition(0).target is RuleStopState)
                        {
							((StarLoopEntryState)state).isPrecedenceDecision = true;
                        }
                    }
                }
            }
        }

        protected internal virtual void VerifyATN(ATN atn)
        {
            // verify assumptions
            foreach (ATNState state in atn.states)
            {
                if (state == null)
                {
                    continue;
                }
                CheckCondition(state.OnlyHasEpsilonTransitions || state.NumberOfTransitions <= 1);
                if (state is PlusBlockStartState plusBlockStartState)
                {
                    CheckCondition(plusBlockStartState.loopBackState != null);
                }
                if (state is StarLoopEntryState starLoopEntryState)
                {
                    CheckCondition(starLoopEntryState.loopBackState != null);
                    CheckCondition(starLoopEntryState.NumberOfTransitions == 2);
                    if (starLoopEntryState.Transition(0).target is StarBlockStartState)
                    {
                        CheckCondition(starLoopEntryState.Transition(1).target is LoopEndState);
                        CheckCondition(!starLoopEntryState.nonGreedy);
                    }
                    else
                    {
                        if (starLoopEntryState.Transition(0).target is LoopEndState)
                        {
                            CheckCondition(starLoopEntryState.Transition(1).target is StarBlockStartState);
                            CheckCondition(starLoopEntryState.nonGreedy);
                        }
                        else
                        {
                            throw new InvalidOperationException();
                        }
                    }
                }
                if (state is StarLoopbackState)
                {
                    CheckCondition(state.NumberOfTransitions == 1);
                    CheckCondition(state.Transition(0).target is StarLoopEntryState);
                }
                if (state is LoopEndState loopEndState)
                {
                    CheckCondition(loopEndState.loopBackState != null);
                }
                if (state is RuleStartState ruleStartState)
                {
                    CheckCondition(ruleStartState.stopState != null);
                }
                if (state is BlockStartState blockStartState)
                {
                    CheckCondition(blockStartState.endState != null);
                }
                if (state is BlockEndState blockEndState)
                {
                    CheckCondition(blockEndState.startState != null);
                }
                if (state is DecisionState decisionState)
                {
                    CheckCondition(decisionState.NumberOfTransitions <= 1 || decisionState.decision >= 0);
                }
                else
                {
                    CheckCondition(state.NumberOfTransitions <= 1 || state is RuleStopState);
                }
            }
        }

        protected internal virtual void CheckCondition(bool condition)
        {
            CheckCondition(condition, null);
        }

        protected internal virtual void CheckCondition(bool condition, string message)
        {
            if (!condition)
            {
                throw new InvalidOperationException(message);
            }
        }

        private static int InlineSetRules(ATN atn)
        {
            int inlinedCalls = 0;
            Transition[] ruleToInlineTransition = new Transition[atn.ruleToStartState.Length];
            for (int i = 0; i < atn.ruleToStartState.Length; i++)
            {
                RuleStartState startState = atn.ruleToStartState[i];
                ATNState middleState = startState;
                while (middleState.OnlyHasEpsilonTransitions && middleState.NumberOfOptimizedTransitions == 1 && middleState.GetOptimizedTransition(0).TransitionType == TransitionType.EPSILON)
                {
                    middleState = middleState.GetOptimizedTransition(0).target;
                }
                if (middleState.NumberOfOptimizedTransitions != 1)
                {
                    continue;
                }
                Transition matchTransition = middleState.GetOptimizedTransition(0);
                ATNState matchTarget = matchTransition.target;
                if (matchTransition.IsEpsilon || !matchTarget.OnlyHasEpsilonTransitions || matchTarget.NumberOfOptimizedTransitions != 1 || !(matchTarget.GetOptimizedTransition(0).target is RuleStopState))
                {
                    continue;
                }
                switch (matchTransition.TransitionType)
                {
                    case TransitionType.ATOM:
                    case TransitionType.RANGE:
                    case TransitionType.SET:
                    {
                        ruleToInlineTransition[i] = matchTransition;
                        break;
                    }

                    case TransitionType.NOT_SET:
                    case TransitionType.WILDCARD:
                    {
                        // not implemented yet
                        continue;
                    }

                    default:
                    {
                        continue;
                    }
                }
            }
            for (int stateNumber = 0; stateNumber < atn.states.Count; stateNumber++)
            {
                ATNState state = atn.states[stateNumber];
                if (state.ruleIndex < 0)
                {
                    continue;
                }
                IList<Transition> optimizedTransitions = null;
                for (int i_1 = 0; i_1 < state.NumberOfOptimizedTransitions; i_1++)
                {
                    Transition transition = state.GetOptimizedTransition(i_1);
                    if (!(transition is RuleTransition))
                    {
                        if (optimizedTransitions != null)
                        {
                            optimizedTransitions.Add(transition);
                        }
                        continue;
                    }
                    RuleTransition ruleTransition = (RuleTransition)transition;
                    Transition effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
                    if (effective == null)
                    {
                        if (optimizedTransitions != null)
                        {
                            optimizedTransitions.Add(transition);
                        }
                        continue;
                    }
                    if (optimizedTransitions == null)
                    {
                        optimizedTransitions = new List<Transition>();
                        for (int j = 0; j < i_1; j++)
                        {
                            optimizedTransitions.Add(state.GetOptimizedTransition(i_1));
                        }
                    }
                    inlinedCalls++;
                    ATNState target = ruleTransition.followState;
                    ATNState intermediateState = new BasicState();
                    intermediateState.SetRuleIndex(target.ruleIndex);
                    atn.AddState(intermediateState);
                    optimizedTransitions.Add(new EpsilonTransition(intermediateState));
                    switch (effective.TransitionType)
                    {
                        case TransitionType.ATOM:
                        {
							intermediateState.AddTransition(new AtomTransition(target, ((AtomTransition)effective).token));
                            break;
                        }

                        case TransitionType.RANGE:
                        {
                            intermediateState.AddTransition(new RangeTransition(target, ((RangeTransition)effective).from, ((RangeTransition)effective).to));
                            break;
                        }

                        case TransitionType.SET:
                        {
                            intermediateState.AddTransition(new SetTransition(target, effective.Label));
                            break;
                        }

                        default:
                        {
                            throw new NotSupportedException();
                        }
                    }
                }
                if (optimizedTransitions != null)
                {
                    if (state.IsOptimized)
                    {
                        while (state.NumberOfOptimizedTransitions > 0)
                        {
                            state.RemoveOptimizedTransition(state.NumberOfOptimizedTransitions - 1);
                        }
                    }
                    foreach (Transition transition in optimizedTransitions)
                    {
                        state.AddOptimizedTransition(transition);
                    }
                }
            }
            return inlinedCalls;
        }

        private static int CombineChainedEpsilons(ATN atn)
        {
            int removedEdges = 0;
            foreach (ATNState state in atn.states)
            {
                if (!state.OnlyHasEpsilonTransitions || state is RuleStopState)
                {
                    continue;
                }
                IList<Transition> optimizedTransitions = null;
                for (int i = 0; i < state.NumberOfOptimizedTransitions; i++)
                {
                    Transition transition = state.GetOptimizedTransition(i);
                    ATNState intermediate = transition.target;
                    if (transition.TransitionType != TransitionType.EPSILON || ((EpsilonTransition)transition).OutermostPrecedenceReturn != -1 || intermediate.StateType != StateType.Basic || !intermediate.OnlyHasEpsilonTransitions)
                    {
                        if (optimizedTransitions != null)
                        {
                            optimizedTransitions.Add(transition);
                        }
                        goto nextTransition_continue;
                    }
                    for (int j = 0; j < intermediate.NumberOfOptimizedTransitions; j++)
                    {
                        if (intermediate.GetOptimizedTransition(j).TransitionType != TransitionType.EPSILON || ((EpsilonTransition)intermediate.GetOptimizedTransition(j)).OutermostPrecedenceReturn != -1)
                        {
                            if (optimizedTransitions != null)
                            {
                                optimizedTransitions.Add(transition);
                            }
                            goto nextTransition_continue;
                        }
                    }
                    removedEdges++;
                    if (optimizedTransitions == null)
                    {
                        optimizedTransitions = new List<Transition>();
                        for (int j_1 = 0; j_1 < i; j_1++)
                        {
                            optimizedTransitions.Add(state.GetOptimizedTransition(j_1));
                        }
                    }
                    for (int j_2 = 0; j_2 < intermediate.NumberOfOptimizedTransitions; j_2++)
                    {
                        ATNState target = intermediate.GetOptimizedTransition(j_2).target;
                        optimizedTransitions.Add(new EpsilonTransition(target));
                    }
nextTransition_continue: ;
                }

                if (optimizedTransitions != null)
                {
                    if (state.IsOptimized)
                    {
                        while (state.NumberOfOptimizedTransitions > 0)
                        {
                            state.RemoveOptimizedTransition(state.NumberOfOptimizedTransitions - 1);
                        }
                    }
                    foreach (Transition transition in optimizedTransitions)
                    {
                        state.AddOptimizedTransition(transition);
                    }
                }
            }

            return removedEdges;
        }

        private static int OptimizeSets(ATN atn, bool preserveOrder)
        {
            if (preserveOrder)
            {
                // this optimization currently doesn't preserve edge order.
                return 0;
            }
            int removedPaths = 0;
            IList<DecisionState> decisions = atn.decisionToState;
            foreach (DecisionState decision in decisions)
            {
                IntervalSet setTransitions = new IntervalSet();
                for (int i = 0; i < decision.NumberOfOptimizedTransitions; i++)
                {
                    Transition epsTransition = decision.GetOptimizedTransition(i);
                    if (!(epsTransition is EpsilonTransition))
                    {
                        continue;
                    }
                    if (epsTransition.target.NumberOfOptimizedTransitions != 1)
                    {
                        continue;
                    }
                    Transition transition = epsTransition.target.GetOptimizedTransition(0);
                    if (!(transition.target is BlockEndState))
                    {
                        continue;
                    }
                    if (transition is NotSetTransition)
                    {
                        // TODO: not yet implemented
                        continue;
                    }
                    if (transition is AtomTransition || transition is RangeTransition || transition is SetTransition)
                    {
                        setTransitions.Add(i);
                    }
                }
                if (setTransitions.Count <= 1)
                {
                    continue;
                }
                IList<Transition> optimizedTransitions = new List<Transition>();
                for (int i_1 = 0; i_1 < decision.NumberOfOptimizedTransitions; i_1++)
                {
                    if (!setTransitions.Contains(i_1))
                    {
                        optimizedTransitions.Add(decision.GetOptimizedTransition(i_1));
                    }
                }
                ATNState blockEndState = decision.GetOptimizedTransition(setTransitions.MinElement).target.GetOptimizedTransition(0).target;
                IntervalSet matchSet = new IntervalSet();
                for (int i_2 = 0; i_2 < setTransitions.GetIntervals().Count; i_2++)
                {
                    Interval interval = setTransitions.GetIntervals()[i_2];
                    for (int j = interval.a; j <= interval.b; j++)
                    {
                        Transition matchTransition = decision.GetOptimizedTransition(j).target.GetOptimizedTransition(0);
                        if (matchTransition is NotSetTransition)
                        {
                            throw new NotSupportedException("Not yet implemented.");
                        }
                        else
                        {
                            matchSet.AddAll(matchTransition.Label);
                        }
                    }
                }
                Transition newTransition;
                if (matchSet.GetIntervals().Count == 1)
                {
                    if (matchSet.Count == 1)
                    {
                        newTransition = new AtomTransition(blockEndState, matchSet.MinElement);
                    }
                    else
                    {
                        Interval matchInterval = matchSet.GetIntervals()[0];
                        newTransition = new RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
                    }
                }
                else
                {
                    newTransition = new SetTransition(blockEndState, matchSet);
                }
                ATNState setOptimizedState = new BasicState();
                setOptimizedState.SetRuleIndex(decision.ruleIndex);
                atn.AddState(setOptimizedState);
                setOptimizedState.AddTransition(newTransition);
                optimizedTransitions.Add(new EpsilonTransition(setOptimizedState));
                removedPaths += decision.NumberOfOptimizedTransitions - optimizedTransitions.Count;
                if (decision.IsOptimized)
                {
                    while (decision.NumberOfOptimizedTransitions > 0)
                    {
                        decision.RemoveOptimizedTransition(decision.NumberOfOptimizedTransitions - 1);
                    }
                }
                foreach (Transition transition_1 in optimizedTransitions)
                {
                    decision.AddOptimizedTransition(transition_1);
                }
            }
            return removedPaths;
        }

        private static void IdentifyTailCalls(ATN atn)
        {
            foreach (ATNState state in atn.states)
            {
                foreach (Transition transition in state.transitions)
                {
                    if (!(transition is RuleTransition))
                    {
                        continue;
                    }
                    RuleTransition ruleTransition = (RuleTransition)transition;
                    ruleTransition.tailCall = TestTailCall(atn, ruleTransition, false);
                    ruleTransition.optimizedTailCall = TestTailCall(atn, ruleTransition, true);
                }
                if (!state.IsOptimized)
                {
                    continue;
                }
                foreach (Transition transition_1 in state.optimizedTransitions)
                {
                    if (!(transition_1 is RuleTransition))
                    {
                        continue;
                    }
                    RuleTransition ruleTransition = (RuleTransition)transition_1;
                    ruleTransition.tailCall = TestTailCall(atn, ruleTransition, false);
                    ruleTransition.optimizedTailCall = TestTailCall(atn, ruleTransition, true);
                }
            }
        }

        private static bool TestTailCall(ATN atn, RuleTransition transition, bool optimizedPath)
        {
            if (!optimizedPath && transition.tailCall)
            {
                return true;
            }
            if (optimizedPath && transition.optimizedTailCall)
            {
                return true;
            }
            BitSet reachable = new BitSet(atn.states.Count);
            Stack<ATNState> worklist = new Stack<ATNState>();
            worklist.Push(transition.followState);
            while (worklist.Count > 0)
            {
                ATNState state = worklist.Pop();
                if (reachable.Get(state.stateNumber))
                {
                    continue;
                }
                if (state is RuleStopState)
                {
                    continue;
                }
                if (!state.OnlyHasEpsilonTransitions)
                {
                    return false;
                }
                IList<Transition> transitions = optimizedPath ? state.optimizedTransitions : state.transitions;
                foreach (Transition t in transitions)
                {
                    if (t.TransitionType != TransitionType.EPSILON)
                    {
                        return false;
                    }
                    worklist.Push(t.target);
                }
            }
            return true;
        }


        protected internal int ReadInt()
        {
			return data[p++];
        }

        protected internal int ReadInt32()
        {
			return (int)data[p++] | ((int)data[p++] << 16);
        }

        protected internal long ReadLong()
        {
            long lowOrder = ReadInt32() & unchecked((long)(0x00000000FFFFFFFFL));
            return lowOrder | ((long)ReadInt32() << 32);
        }

        protected internal Guid ReadUUID()
        {
			byte[] d = BitConverter.GetBytes (ReadLong ());
			if(BitConverter.IsLittleEndian)
			{
				Array.Reverse(d);
			}
			short c = (short)ReadInt();
			short b = (short)ReadInt();
			int a = ReadInt32();
            return new Guid(a, b, c, d);
        }

        [return: NotNull]
        protected internal virtual Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList<IntervalSet> sets)
        {
            ATNState target = atn.states[trg];
            switch (type)
            {
                case TransitionType.EPSILON:
                {
                    return new EpsilonTransition(target);
                }

                case TransitionType.RANGE:
                {
                    if (arg3 != 0)
                    {
                        return new RangeTransition(target, TokenConstants.EOF, arg2);
                    }
                    else
                    {
                        return new RangeTransition(target, arg1, arg2);
                    }
                }

                case TransitionType.RULE:
                {
                    RuleTransition rt = new RuleTransition((RuleStartState)atn.states[arg1], arg2, arg3, target);
                    return rt;
                }

                case TransitionType.PREDICATE:
                {
                    PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);
                    return pt;
                }

                case TransitionType.PRECEDENCE:
                {
                    return new PrecedencePredicateTransition(target, arg1);
                }

                case TransitionType.ATOM:
                {
                    if (arg3 != 0)
                    {
                        return new AtomTransition(target, TokenConstants.EOF);
                    }
                    else
                    {
                        return new AtomTransition(target, arg1);
                    }
                }

                case TransitionType.ACTION:
                {
                    ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);
                    return a;
                }

                case TransitionType.SET:
                {
                    return new SetTransition(target, sets[arg1]);
                }

                case TransitionType.NOT_SET:
                {
                    return new NotSetTransition(target, sets[arg1]);
                }

                case TransitionType.WILDCARD:
                {
                    return new WildcardTransition(target);
                }
            }
            throw new ArgumentException("The specified transition type is not valid.");
        }

        protected internal virtual ATNState StateFactory(StateType type, int ruleIndex)
        {
            ATNState s;
            switch (type)
            {
                case StateType.InvalidType:
                {
                    return null;
                }

                case StateType.Basic:
                {
                    s = new BasicState();
                    break;
                }

                case StateType.RuleStart:
                {
                    s = new RuleStartState();
                    break;
                }

                case StateType.BlockStart:
                {
                    s = new BasicBlockStartState();
                    break;
                }

                case StateType.PlusBlockStart:
                {
                    s = new PlusBlockStartState();
                    break;
                }

                case StateType.StarBlockStart:
                {
                    s = new StarBlockStartState();
                    break;
                }

                case StateType.TokenStart:
                {
                    s = new TokensStartState();
                    break;
                }

                case StateType.RuleStop:
                {
                    s = new RuleStopState();
                    break;
                }

                case StateType.BlockEnd:
                {
                    s = new BlockEndState();
                    break;
                }

                case StateType.StarLoopBack:
                {
                    s = new StarLoopbackState();
                    break;
                }

                case StateType.StarLoopEntry:
                {
                    s = new StarLoopEntryState();
                    break;
                }

                case StateType.PlusLoopBack:
                {
                    s = new PlusLoopbackState();
                    break;
                }

                case StateType.LoopEnd:
                {
                    s = new LoopEndState();
                    break;
                }

                default:
                {
                    string message = string.Format(CultureInfo.CurrentCulture, "The specified state type {0} is not valid.", type);
                    throw new ArgumentException(message);
                }
            }
            s.ruleIndex = ruleIndex;
            return s;
        }

        protected internal virtual ILexerAction LexerActionFactory(LexerActionType type, int data1, int data2)
        {
            switch (type)
            {
                case LexerActionType.Channel:
                {
                    return new LexerChannelAction(data1);
                }

                case LexerActionType.Custom:
                {
                    return new LexerCustomAction(data1, data2);
                }

                case LexerActionType.Mode:
                {
                    return new LexerModeAction(data1);
                }

                case LexerActionType.More:
                {
                    return LexerMoreAction.Instance;
                }

                case LexerActionType.PopMode:
                {
                    return LexerPopModeAction.Instance;
                }

                case LexerActionType.PushMode:
                {
                    return new LexerPushModeAction(data1);
                }

                case LexerActionType.Skip:
                {
                    return LexerSkipAction.Instance;
                }

                case LexerActionType.Type:
                {
                    return new LexerTypeAction(data1);
                }

                default:
                {
                    string message = string.Format(CultureInfo.CurrentCulture, "The specified lexer action type {0} is not valid.", type);
                    throw new ArgumentException(message);
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs(11,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs(388,43): error CS0136: A local or parameter named 'loopbackState' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\ATNDeserializer.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 2 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\PredictionContext.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Text;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Sharpen;

namespace Antlr4.Runtime.Atn
{
	internal abstract class PredictionContext
	{
		public static readonly int EMPTY_RETURN_STATE = int.MaxValue;

		public static readonly EmptyPredictionContext EMPTY = new EmptyPredictionContext();

		private static readonly int INITIAL_HASH = 1;

		protected internal static int CalculateEmptyHashCode()
		{
			int hash = MurmurHash.Initialize(INITIAL_HASH);
			hash = MurmurHash.Finish(hash, 0);
			return hash;
		}

		protected internal static int CalculateHashCode(PredictionContext parent, int returnState)
		{
			int hash = MurmurHash.Initialize(INITIAL_HASH);
			hash = MurmurHash.Update(hash, parent);
			hash = MurmurHash.Update(hash, returnState);
			hash = MurmurHash.Finish(hash, 2);
			return hash;
		}

		protected internal static int CalculateHashCode(PredictionContext[] parents, int[] returnStates)
		{
			int hash = MurmurHash.Initialize(INITIAL_HASH);
			foreach (PredictionContext parent in parents)
			{
				hash = MurmurHash.Update(hash, parent);
			}
			foreach (int returnState in returnStates)
			{
				hash = MurmurHash.Update(hash, returnState);
			}
			hash = MurmurHash.Finish(hash, 2 * parents.Length);
			return hash;
		}

		private readonly int cachedHashCode;

		protected internal PredictionContext(int cachedHashCode)
		{
			this.cachedHashCode = cachedHashCode;
		}

		public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext)
		{
			if (outerContext == null)
				outerContext = ParserRuleContext.EMPTY;
			if (outerContext.Parent == null || outerContext == ParserRuleContext.EMPTY)
				return PredictionContext.EMPTY;
			PredictionContext parent = PredictionContext.FromRuleContext(atn, outerContext.Parent);
			ATNState state = atn.states[outerContext.invokingState];
			RuleTransition transition = (RuleTransition)state.Transition(0);
			return parent.GetChild(transition.followState.stateNumber);
		}

		public abstract int Size
		{
			get;
		}

		public abstract PredictionContext GetParent(int index);

		public abstract int GetReturnState(int index);

		public virtual bool IsEmpty
		{
			get
			{
				return this == EMPTY;
			}
		}

		public virtual bool HasEmptyPath
		{
			get
			{
				return GetReturnState(Size - 1) == EMPTY_RETURN_STATE;
			}
		}

		public sealed override int GetHashCode()
		{
			return cachedHashCode;
		}



		internal static PredictionContext Merge(PredictionContext a, PredictionContext b, bool rootIsWildcard, MergeCache mergeCache)
		{
			if (a == b || a.Equals(b))
			{
				return a;
			}
			if (a is SingletonPredictionContext && b is SingletonPredictionContext)
			{
				return MergeSingletons((SingletonPredictionContext)a,
									   (SingletonPredictionContext)b,
									   rootIsWildcard, mergeCache);
			}

			// At least one of a or b is array
			// If one is $ and rootIsWildcard, return $ as * wildcard
			if (rootIsWildcard)
			{
				if (a is EmptyPredictionContext)
					return a;
				if (b is EmptyPredictionContext)
					return b;
			}

			// convert singleton so both are arrays to normalize
			if (a is SingletonPredictionContext)
			{
				a = new ArrayPredictionContext((SingletonPredictionContext)a);
			}
			if (b is SingletonPredictionContext)
			{
				b = new ArrayPredictionContext((SingletonPredictionContext)b);
			}
			return MergeArrays((ArrayPredictionContext)a, (ArrayPredictionContext)b,
							   rootIsWildcard, mergeCache);
		}

		public static PredictionContext MergeSingletons(
	SingletonPredictionContext a,
	SingletonPredictionContext b,
	bool rootIsWildcard,
	MergeCache mergeCache)
		{
			if (mergeCache != null)
			{
				PredictionContext previous = mergeCache.Get(a, b);
				if (previous != null) return previous;
				previous = mergeCache.Get(b, a);
				if (previous != null) return previous;
			}

			PredictionContext rootMerge = MergeRoot(a, b, rootIsWildcard);
			if (rootMerge != null)
			{
				if (mergeCache != null) mergeCache.Put(a, b, rootMerge);
				return rootMerge;
			}

			if (a.returnState == b.returnState)
			{ // a == b
				PredictionContext parent = Merge(a.parent, b.parent, rootIsWildcard, mergeCache);
				// if parent is same as existing a or b parent or reduced to a parent, return it
				if (parent == a.parent) return a; // ax + bx = ax, if a=b
				if (parent == b.parent) return b; // ax + bx = bx, if a=b
												  // else: ax + ay = a'[x,y]
												  // merge parents x and y, giving array node with x,y then remainders
												  // of those graphs.  dup a, a' points at merged array
												  // new joined parent so create new singleton pointing to it, a'
				PredictionContext a_ = SingletonPredictionContext.Create(parent, a.returnState);
				if (mergeCache != null) mergeCache.Put(a, b, a_);
				return a_;
			}
			else { // a != b payloads differ
				   // see if we can collapse parents due to $+x parents if local ctx
				int[] payloads = new int[2];
				PredictionContext[] parents = new PredictionContext[2];
				PredictionContext pc;
				PredictionContext singleParent = null;
				if (a == b || (a.parent != null && a.parent.Equals(b.parent)))
				{ // ax + bx = [a,b]x
					singleParent = a.parent;
				}
				if (singleParent != null)
				{   // parents are same
					// sort payloads and use same parent
					if (a.returnState > b.returnState)
					{
						payloads[0] = b.returnState;
						payloads[1] = a.returnState;
					}
					else {
						payloads[0] = a.returnState;
						payloads[1] = b.returnState;
					}
					parents[0] = singleParent;
					parents[1] = singleParent;
					pc = new ArrayPredictionContext(parents, payloads);
					if (mergeCache != null)
						mergeCache.Put(a, b, pc);
					return pc;
				}
				// parents differ and can't merge them. Just pack together
				// into array; can't merge.
				// ax + by = [ax,by]
				// sort by payload
				if (a.returnState > b.returnState)
				{
					payloads[0] = b.returnState;
					payloads[1] = a.returnState;
					parents[0] = b.parent;
					parents[1] = a.parent;
				}
				else {
					payloads[0] = a.returnState;
					payloads[1] = b.returnState;
					parents[0] = a.parent;
					parents[1] = b.parent;
				}
				pc = new ArrayPredictionContext(parents, payloads);
				if (mergeCache != null)
					mergeCache.Put(a, b, pc);
				return pc;
			}
		}

		public static PredictionContext MergeArrays(
	ArrayPredictionContext a,
	ArrayPredictionContext b,
	bool rootIsWildcard,
	MergeCache mergeCache)
		{
			if (mergeCache != null)
			{
				PredictionContext previous = mergeCache.Get(a, b);
				if (previous != null)
					return previous;
				previous = mergeCache.Get(b, a);
				if (previous != null)
					return previous;
			}

			// merge sorted payloads a + b => M
			int i = 0; // walks a
			int j = 0; // walks b
			int k = 0; // walks target M array

			int[] mergedReturnStates =
				new int[a.returnStates.Length + b.returnStates.Length];
			PredictionContext[] mergedParents =
				new PredictionContext[a.returnStates.Length + b.returnStates.Length];
			// walk and merge to yield mergedParents, mergedReturnStates
			while (i < a.returnStates.Length && j < b.returnStates.Length)
			{
				PredictionContext a_parent = a.parents[i];
				PredictionContext b_parent = b.parents[j];
				if (a.returnStates[i] == b.returnStates[j])
				{
					// same payload (stack tops are equal), must yield merged singleton
					int payload = a.returnStates[i];
					// $+$ = $
					bool both_dollar = payload == EMPTY_RETURN_STATE &&
									a_parent == null && b_parent == null;
					bool ax_ax = (a_parent != null && b_parent != null) &&
									a_parent.Equals(b_parent); // ax+ax -> ax
					if (both_dollar || ax_ax ) {
						mergedParents[k] = a_parent; // choose left
						mergedReturnStates[k] = payload;
					}
				else { // ax+ay -> a'[x,y]
						PredictionContext mergedParent =
							Merge(a_parent, b_parent, rootIsWildcard, mergeCache);
						mergedParents[k] = mergedParent;
						mergedReturnStates[k] = payload;
					}
					i++; // hop over left one as usual
					j++; // but also skip one in right side since we merge
				}
				else if (a.returnStates[i] < b.returnStates[j])
				{ // copy a[i] to M
					mergedParents[k] = a_parent;
					mergedReturnStates[k] = a.returnStates[i];
					i++;
				}
				else { // b > a, copy b[j] to M
					mergedParents[k] = b_parent;
					mergedReturnStates[k] = b.returnStates[j];
					j++;
				}
				k++;
			}

			// copy over any payloads remaining in either array
			if (i < a.returnStates.Length)
			{
				for (int p = i; p < a.returnStates.Length; p++)
				{
					mergedParents[k] = a.parents[p];
					mergedReturnStates[k] = a.returnStates[p];
					k++;
				}
			}
			else {
				for (int p = j; p < b.returnStates.Length; p++)
				{
					mergedParents[k] = b.parents[p];
					mergedReturnStates[k] = b.returnStates[p];
					k++;
				}
			}

			// trim merged if we combined a few that had same stack tops
			if (k < mergedParents.Length)
			{ // write index < last position; trim
				if (k == 1)
				{ // for just one merged element, return singleton top
					PredictionContext a_ = SingletonPredictionContext.Create(mergedParents[0], mergedReturnStates[0]);
					if (mergeCache != null) mergeCache.Put(a, b, a_);
					return a_;
				}
				mergedParents = Arrays.CopyOf(mergedParents, k);
				mergedReturnStates = Arrays.CopyOf(mergedReturnStates, k);
			}

			PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

			// if we created same array as a or b, return that instead
			// TODO: track whether this is possible above during merge sort for speed
			if (M.Equals(a))
			{
				if (mergeCache != null)
					mergeCache.Put(a, b, a);
				return a;
			}
			if (M.Equals(b))
			{
				if (mergeCache != null)
					mergeCache.Put(a, b, b);
				return b;
			}

			CombineCommonParents(mergedParents);

			if (mergeCache != null)
				mergeCache.Put(a, b, M);
			return M;
		}

		protected static void CombineCommonParents(PredictionContext[] parents)
		{
			Dictionary<PredictionContext, PredictionContext> uniqueParents = new Dictionary<PredictionContext, PredictionContext>();

			for (int p = 0; p < parents.Length; p++)
			{
				PredictionContext parent = parents[p];
				if (parent!=null && !uniqueParents.ContainsKey(parent))
				{ // don't replace
					uniqueParents.Put(parent, parent);
				}
			}

			for (int p = 0; p < parents.Length; p++)
			{
				PredictionContext parent = parents[p];
				if (parent!=null)
					parents[p] = uniqueParents.Get(parent);
			}
		}

		public static PredictionContext MergeRoot(SingletonPredictionContext a,
											  SingletonPredictionContext b,
											  bool rootIsWildcard)
		{
			if (rootIsWildcard)
			{
				if (a == PredictionContext.EMPTY)
					return PredictionContext.EMPTY;  // * + b = *
				if (b == PredictionContext.EMPTY)
					return PredictionContext.EMPTY;  // a + * = *
			}
			else {
				if (a == EMPTY && b == EMPTY) return EMPTY; // $ + $ = $
				if (a == EMPTY)
				{ // $ + x = [$,x]
					int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
					PredictionContext[] parents = { b.parent, null };
					PredictionContext joined =
						new ArrayPredictionContext(parents, payloads);
					return joined;
				}
				if (b == EMPTY)
				{ // x + $ = [$,x] ($ is always first if present)
					int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
					PredictionContext[] parents = { a.parent, null };
					PredictionContext joined =
						new ArrayPredictionContext(parents, payloads);
					return joined;
				}
			}
			return null;
		}


		public static PredictionContext GetCachedContext(PredictionContext context, PredictionContextCache contextCache, PredictionContext.IdentityHashMap visited)
		{
			if (context.IsEmpty)
			{
				return context;
			}

			PredictionContext existing = visited.Get(context);
			if (existing != null)
			{
				return existing;
			}

			existing = contextCache.Get(context);
			if (existing != null)
			{
				visited.Put(context, existing);
				return existing;
			}

			bool changed = false;
			PredictionContext[] parents = new PredictionContext[context.Size];
			for (int i = 0; i < parents.Length; i++)
			{
				PredictionContext parent = GetCachedContext(context.GetParent(i), contextCache, visited);
				if (changed || parent != context.GetParent(i))
				{
					if (!changed)
					{
						parents = new PredictionContext[context.Size];
						for (int j = 0; j < context.Size; j++)
						{
							parents[j] = context.GetParent(j);
						}

						changed = true;
					}

					parents[i] = parent;
				}
			}

			if (!changed)
			{
				contextCache.Add(context);
				visited.Put(context, context);
				return context;
			}

			PredictionContext updated;
			if (parents.Length == 0)
			{
				updated = EMPTY;
			}
			else if (parents.Length == 1)
			{
				updated = SingletonPredictionContext.Create(parents[0], context.GetReturnState(0));
			}
			else {
				ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext)context;
				updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
			}

			contextCache.Add(updated);
			visited.Put(updated, updated);
			visited.Put(context, updated);

			return updated;
		}

		public virtual PredictionContext GetChild(int returnState)
		{
			return new SingletonPredictionContext(this, returnState);
		}


		public virtual string[] ToStrings(IRecognizer recognizer, int currentState)
		{
			return ToStrings(recognizer, PredictionContext.EMPTY, currentState);
		}

		public virtual string[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState)
		{
			List<string> result = new List<string>();
			for (int perm = 0; ; perm++)
			{
				int offset = 0;
				bool last = true;
				PredictionContext p = this;
				int stateNumber = currentState;
				StringBuilder localBuffer = new StringBuilder();
				localBuffer.Append("[");
				while (!p.IsEmpty && p != stop)
				{
					int index = 0;
					if (p.Size > 0)
					{
						int bits = 1;
						while ((1 << bits) < p.Size)
						{
							bits++;
						}
						int mask = (1 << bits) - 1;
						index = (perm >> offset) & mask;
						last &= index >= p.Size - 1;
						if (index >= p.Size)
						{
							goto outer_continue;
						}
						offset += bits;
					}
					if (recognizer != null)
					{
						if (localBuffer.Length > 1)
						{
							// first char is '[', if more than that this isn't the first rule
							localBuffer.Append(' ');
						}
						ATN atn = recognizer.Atn;
						ATNState s = atn.states[stateNumber];
						string ruleName = recognizer.RuleNames[s.ruleIndex];
						localBuffer.Append(ruleName);
					}
					else
					{
						if (p.GetReturnState(index) != EMPTY_RETURN_STATE)
						{
							if (!p.IsEmpty)
							{
								if (localBuffer.Length > 1)
								{
									// first char is '[', if more than that this isn't the first rule
									localBuffer.Append(' ');
								}
								localBuffer.Append(p.GetReturnState(index));
							}
						}
					}
					stateNumber = p.GetReturnState(index);
					p = p.GetParent(index);
				}
				localBuffer.Append("]");
				result.Add(localBuffer.ToString());
				if (last)
				{
					break;
				}
			outer_continue:;
			}

			return result.ToArray();
		}

		internal sealed class IdentityHashMap : Dictionary<PredictionContext, PredictionContext>
		{
			public IdentityHashMap()
				: base(PredictionContext.IdentityEqualityComparator.Instance)
			{
			}
		}

		internal sealed class IdentityEqualityComparator : EqualityComparer<PredictionContext>
		{
			public static readonly PredictionContext.IdentityEqualityComparator Instance = new PredictionContext.IdentityEqualityComparator();

			private IdentityEqualityComparator()
			{
			}

			public override int GetHashCode(PredictionContext obj)
			{
				return obj.GetHashCode();
			}

			public override bool Equals(PredictionContext a, PredictionContext b)
			{
				return a == b;
			}
		}
	}
}

---- Transformed Tree ----
using System.Collections.Generic;
using System.Text;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Sharpen;

namespace Antlr4.Runtime.Atn
{
	internal abstract class PredictionContext
	{
		public static readonly int EMPTY_RETURN_STATE = int.MaxValue;

		public static readonly EmptyPredictionContext EMPTY = new EmptyPredictionContext();

		private static readonly int INITIAL_HASH = 1;

		protected internal static int CalculateEmptyHashCode()
		{
			int hash = MurmurHash.Initialize(INITIAL_HASH);
			hash = MurmurHash.Finish(hash, 0);
			return hash;
		}

		protected internal static int CalculateHashCode(PredictionContext parent, int returnState)
		{
			int hash = MurmurHash.Initialize(INITIAL_HASH);
			hash = MurmurHash.Update(hash, parent);
			hash = MurmurHash.Update(hash, returnState);
			hash = MurmurHash.Finish(hash, 2);
			return hash;
		}

		protected internal static int CalculateHashCode(PredictionContext[] parents, int[] returnStates)
		{
			int hash = MurmurHash.Initialize(INITIAL_HASH);
			foreach (PredictionContext parent in parents)
			{
				hash = MurmurHash.Update(hash, parent);
			}
			foreach (int returnState in returnStates)
			{
				hash = MurmurHash.Update(hash, returnState);
			}
			hash = MurmurHash.Finish(hash, 2 * parents.Length);
			return hash;
		}

		private readonly int cachedHashCode;

		protected internal PredictionContext(int cachedHashCode)
		{
			this.cachedHashCode = cachedHashCode;
		}

		public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext)
		{
			if (outerContext == null)
				outerContext = ParserRuleContext.EMPTY;
			if (outerContext.Parent == null || outerContext == ParserRuleContext.EMPTY)
				return PredictionContext.EMPTY;
			PredictionContext parent = PredictionContext.FromRuleContext(atn, outerContext.Parent);
			ATNState state = atn.states[outerContext.invokingState];
			RuleTransition transition = (RuleTransition)state.Transition(0);
			return parent.GetChild(transition.followState.stateNumber);
		}

		public abstract int Size
		{
			get;
		}

		public abstract PredictionContext GetParent(int index);

		public abstract int GetReturnState(int index);

		public virtual bool IsEmpty
		{
			get
			{
				return this == EMPTY;
			}
		}

		public virtual bool HasEmptyPath
		{
			get
			{
				return GetReturnState(Size - 1) == EMPTY_RETURN_STATE;
			}
		}

		public sealed override int GetHashCode()
		{
			return cachedHashCode;
		}



		internal static PredictionContext Merge(PredictionContext a, PredictionContext b, bool rootIsWildcard, MergeCache mergeCache)
		{
			if (a == b || a.Equals(b))
			{
				return a;
			}
			if (a is SingletonPredictionContext && b is SingletonPredictionContext)
			{
				return MergeSingletons((SingletonPredictionContext)a,
									   (SingletonPredictionContext)b,
									   rootIsWildcard, mergeCache);
			}

			// At least one of a or b is array
			// If one is $ and rootIsWildcard, return $ as * wildcard
			if (rootIsWildcard)
			{
				if (a is EmptyPredictionContext)
					return a;
				if (b is EmptyPredictionContext)
					return b;
			}

			// convert singleton so both are arrays to normalize
			if (a is SingletonPredictionContext singletonPredictionContext)
			{
				a = new ArrayPredictionContext(singletonPredictionContext);
			}
			if (b is SingletonPredictionContext singletonPredictionContext)
			{
				b = new ArrayPredictionContext(singletonPredictionContext);
			}
			return MergeArrays((ArrayPredictionContext)a, (ArrayPredictionContext)b,
							   rootIsWildcard, mergeCache);
		}

		public static PredictionContext MergeSingletons(
	SingletonPredictionContext a,
	SingletonPredictionContext b,
	bool rootIsWildcard,
	MergeCache mergeCache)
		{
			if (mergeCache != null)
			{
				PredictionContext previous = mergeCache.Get(a, b);
				if (previous != null) return previous;
				previous = mergeCache.Get(b, a);
				if (previous != null) return previous;
			}

			PredictionContext rootMerge = MergeRoot(a, b, rootIsWildcard);
			if (rootMerge != null)
			{
				if (mergeCache != null) mergeCache.Put(a, b, rootMerge);
				return rootMerge;
			}

			if (a.returnState == b.returnState)
			{ // a == b
				PredictionContext parent = Merge(a.parent, b.parent, rootIsWildcard, mergeCache);
				// if parent is same as existing a or b parent or reduced to a parent, return it
				if (parent == a.parent) return a; // ax + bx = ax, if a=b
				if (parent == b.parent) return b; // ax + bx = bx, if a=b
												  // else: ax + ay = a'[x,y]
												  // merge parents x and y, giving array node with x,y then remainders
												  // of those graphs.  dup a, a' points at merged array
												  // new joined parent so create new singleton pointing to it, a'
				PredictionContext a_ = SingletonPredictionContext.Create(parent, a.returnState);
				if (mergeCache != null) mergeCache.Put(a, b, a_);
				return a_;
			}
			else { // a != b payloads differ
				   // see if we can collapse parents due to $+x parents if local ctx
				int[] payloads = new int[2];
				PredictionContext[] parents = new PredictionContext[2];
				PredictionContext pc;
				PredictionContext singleParent = null;
				if (a == b || (a.parent != null && a.parent.Equals(b.parent)))
				{ // ax + bx = [a,b]x
					singleParent = a.parent;
				}
				if (singleParent != null)
				{   // parents are same
					// sort payloads and use same parent
					if (a.returnState > b.returnState)
					{
						payloads[0] = b.returnState;
						payloads[1] = a.returnState;
					}
					else {
						payloads[0] = a.returnState;
						payloads[1] = b.returnState;
					}
					parents[0] = singleParent;
					parents[1] = singleParent;
					pc = new ArrayPredictionContext(parents, payloads);
					if (mergeCache != null)
						mergeCache.Put(a, b, pc);
					return pc;
				}
				// parents differ and can't merge them. Just pack together
				// into array; can't merge.
				// ax + by = [ax,by]
				// sort by payload
				if (a.returnState > b.returnState)
				{
					payloads[0] = b.returnState;
					payloads[1] = a.returnState;
					parents[0] = b.parent;
					parents[1] = a.parent;
				}
				else {
					payloads[0] = a.returnState;
					payloads[1] = b.returnState;
					parents[0] = a.parent;
					parents[1] = b.parent;
				}
				pc = new ArrayPredictionContext(parents, payloads);
				if (mergeCache != null)
					mergeCache.Put(a, b, pc);
				return pc;
			}
		}

		public static PredictionContext MergeArrays(
	ArrayPredictionContext a,
	ArrayPredictionContext b,
	bool rootIsWildcard,
	MergeCache mergeCache)
		{
			if (mergeCache != null)
			{
				PredictionContext previous = mergeCache.Get(a, b);
				if (previous != null)
					return previous;
				previous = mergeCache.Get(b, a);
				if (previous != null)
					return previous;
			}

			// merge sorted payloads a + b => M
			int i = 0; // walks a
			int j = 0; // walks b
			int k = 0; // walks target M array

			int[] mergedReturnStates =
				new int[a.returnStates.Length + b.returnStates.Length];
			PredictionContext[] mergedParents =
				new PredictionContext[a.returnStates.Length + b.returnStates.Length];
			// walk and merge to yield mergedParents, mergedReturnStates
			while (i < a.returnStates.Length && j < b.returnStates.Length)
			{
				PredictionContext a_parent = a.parents[i];
				PredictionContext b_parent = b.parents[j];
				if (a.returnStates[i] == b.returnStates[j])
				{
					// same payload (stack tops are equal), must yield merged singleton
					int payload = a.returnStates[i];
					// $+$ = $
					bool both_dollar = payload == EMPTY_RETURN_STATE &&
									a_parent == null && b_parent == null;
					bool ax_ax = (a_parent != null && b_parent != null) &&
									a_parent.Equals(b_parent); // ax+ax -> ax
					if (both_dollar || ax_ax ) {
						mergedParents[k] = a_parent; // choose left
						mergedReturnStates[k] = payload;
					}
				else { // ax+ay -> a'[x,y]
						PredictionContext mergedParent =
							Merge(a_parent, b_parent, rootIsWildcard, mergeCache);
						mergedParents[k] = mergedParent;
						mergedReturnStates[k] = payload;
					}
					i++; // hop over left one as usual
					j++; // but also skip one in right side since we merge
				}
				else if (a.returnStates[i] < b.returnStates[j])
				{ // copy a[i] to M
					mergedParents[k] = a_parent;
					mergedReturnStates[k] = a.returnStates[i];
					i++;
				}
				else { // b > a, copy b[j] to M
					mergedParents[k] = b_parent;
					mergedReturnStates[k] = b.returnStates[j];
					j++;
				}
				k++;
			}

			// copy over any payloads remaining in either array
			if (i < a.returnStates.Length)
			{
				for (int p = i; p < a.returnStates.Length; p++)
				{
					mergedParents[k] = a.parents[p];
					mergedReturnStates[k] = a.returnStates[p];
					k++;
				}
			}
			else {
				for (int p = j; p < b.returnStates.Length; p++)
				{
					mergedParents[k] = b.parents[p];
					mergedReturnStates[k] = b.returnStates[p];
					k++;
				}
			}

			// trim merged if we combined a few that had same stack tops
			if (k < mergedParents.Length)
			{ // write index < last position; trim
				if (k == 1)
				{ // for just one merged element, return singleton top
					PredictionContext a_ = SingletonPredictionContext.Create(mergedParents[0], mergedReturnStates[0]);
					if (mergeCache != null) mergeCache.Put(a, b, a_);
					return a_;
				}
				mergedParents = Arrays.CopyOf(mergedParents, k);
				mergedReturnStates = Arrays.CopyOf(mergedReturnStates, k);
			}

			PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

			// if we created same array as a or b, return that instead
			// TODO: track whether this is possible above during merge sort for speed
			if (M.Equals(a))
			{
				if (mergeCache != null)
					mergeCache.Put(a, b, a);
				return a;
			}
			if (M.Equals(b))
			{
				if (mergeCache != null)
					mergeCache.Put(a, b, b);
				return b;
			}

			CombineCommonParents(mergedParents);

			if (mergeCache != null)
				mergeCache.Put(a, b, M);
			return M;
		}

		protected static void CombineCommonParents(PredictionContext[] parents)
		{
			Dictionary<PredictionContext, PredictionContext> uniqueParents = new Dictionary<PredictionContext, PredictionContext>();

			for (int p = 0; p < parents.Length; p++)
			{
				PredictionContext parent = parents[p];
				if (parent!=null && !uniqueParents.ContainsKey(parent))
				{ // don't replace
					uniqueParents.Put(parent, parent);
				}
			}

			for (int p = 0; p < parents.Length; p++)
			{
				PredictionContext parent = parents[p];
				if (parent!=null)
					parents[p] = uniqueParents.Get(parent);
			}
		}

		public static PredictionContext MergeRoot(SingletonPredictionContext a,
											  SingletonPredictionContext b,
											  bool rootIsWildcard)
		{
			if (rootIsWildcard)
			{
				if (a == PredictionContext.EMPTY)
					return PredictionContext.EMPTY;  // * + b = *
				if (b == PredictionContext.EMPTY)
					return PredictionContext.EMPTY;  // a + * = *
			}
			else {
				if (a == EMPTY && b == EMPTY) return EMPTY; // $ + $ = $
				if (a == EMPTY)
				{ // $ + x = [$,x]
					int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
					PredictionContext[] parents = { b.parent, null };
					PredictionContext joined =
						new ArrayPredictionContext(parents, payloads);
					return joined;
				}
				if (b == EMPTY)
				{ // x + $ = [$,x] ($ is always first if present)
					int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
					PredictionContext[] parents = { a.parent, null };
					PredictionContext joined =
						new ArrayPredictionContext(parents, payloads);
					return joined;
				}
			}
			return null;
		}


		public static PredictionContext GetCachedContext(PredictionContext context, PredictionContextCache contextCache, PredictionContext.IdentityHashMap visited)
		{
			if (context.IsEmpty)
			{
				return context;
			}

			PredictionContext existing = visited.Get(context);
			if (existing != null)
			{
				return existing;
			}

			existing = contextCache.Get(context);
			if (existing != null)
			{
				visited.Put(context, existing);
				return existing;
			}

			bool changed = false;
			PredictionContext[] parents = new PredictionContext[context.Size];
			for (int i = 0; i < parents.Length; i++)
			{
				PredictionContext parent = GetCachedContext(context.GetParent(i), contextCache, visited);
				if (changed || parent != context.GetParent(i))
				{
					if (!changed)
					{
						parents = new PredictionContext[context.Size];
						for (int j = 0; j < context.Size; j++)
						{
							parents[j] = context.GetParent(j);
						}

						changed = true;
					}

					parents[i] = parent;
				}
			}

			if (!changed)
			{
				contextCache.Add(context);
				visited.Put(context, context);
				return context;
			}

			PredictionContext updated;
			if (parents.Length == 0)
			{
				updated = EMPTY;
			}
			else if (parents.Length == 1)
			{
				updated = SingletonPredictionContext.Create(parents[0], context.GetReturnState(0));
			}
			else {
				ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext)context;
				updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
			}

			contextCache.Add(updated);
			visited.Put(updated, updated);
			visited.Put(context, updated);

			return updated;
		}

		public virtual PredictionContext GetChild(int returnState)
		{
			return new SingletonPredictionContext(this, returnState);
		}


		public virtual string[] ToStrings(IRecognizer recognizer, int currentState)
		{
			return ToStrings(recognizer, PredictionContext.EMPTY, currentState);
		}

		public virtual string[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState)
		{
			List<string> result = new List<string>();
			for (int perm = 0; ; perm++)
			{
				int offset = 0;
				bool last = true;
				PredictionContext p = this;
				int stateNumber = currentState;
				StringBuilder localBuffer = new StringBuilder();
				localBuffer.Append("[");
				while (!p.IsEmpty && p != stop)
				{
					int index = 0;
					if (p.Size > 0)
					{
						int bits = 1;
						while ((1 << bits) < p.Size)
						{
							bits++;
						}
						int mask = (1 << bits) - 1;
						index = (perm >> offset) & mask;
						last &= index >= p.Size - 1;
						if (index >= p.Size)
						{
							goto outer_continue;
						}
						offset += bits;
					}
					if (recognizer != null)
					{
						if (localBuffer.Length > 1)
						{
							// first char is '[', if more than that this isn't the first rule
							localBuffer.Append(' ');
						}
						ATN atn = recognizer.Atn;
						ATNState s = atn.states[stateNumber];
						string ruleName = recognizer.RuleNames[s.ruleIndex];
						localBuffer.Append(ruleName);
					}
					else
					{
						if (p.GetReturnState(index) != EMPTY_RETURN_STATE)
						{
							if (!p.IsEmpty)
							{
								if (localBuffer.Length > 1)
								{
									// first char is '[', if more than that this isn't the first rule
									localBuffer.Append(' ');
								}
								localBuffer.Append(p.GetReturnState(index));
							}
						}
					}
					stateNumber = p.GetReturnState(index);
					p = p.GetParent(index);
				}
				localBuffer.Append("]");
				result.Add(localBuffer.ToString());
				if (last)
				{
					break;
				}
			outer_continue:;
			}

			return result.ToArray();
		}

		internal sealed class IdentityHashMap : Dictionary<PredictionContext, PredictionContext>
		{
			public IdentityHashMap()
				: base(PredictionContext.IdentityEqualityComparator.Instance)
			{
			}
		}

		internal sealed class IdentityEqualityComparator : EqualityComparer<PredictionContext>
		{
			public static readonly PredictionContext.IdentityEqualityComparator Instance = new PredictionContext.IdentityEqualityComparator();

			private IdentityEqualityComparator()
			{
			}

			public override int GetHashCode(PredictionContext obj)
			{
				return obj.GetHashCode();
			}

			public override bool Equals(PredictionContext a, PredictionContext b)
			{
				return a == b;
			}
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\PredictionContext.cs(133,40): error CS0128: A local variable or function named 'singletonPredictionContext' is already defined in this scope,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Atn\PredictionContext.cs(135,36): error CS0165: Use of unassigned local variable 'singletonPredictionContext'
######################################################################


######################################################################
Nr: 3 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Antlr4.Runtime.Dfa;
using Antlr4.Runtime.Sharpen;
using Interlocked = System.Threading.Interlocked;

#if NET45PLUS
using Volatile = System.Threading.Volatile;
#elif !PORTABLE && !COMPACT
using Thread = System.Threading.Thread;
#endif

namespace Antlr4.Runtime.Dfa
{
    /// <author>Sam Harwell</author>
    internal sealed class ArrayEdgeMap<T> : AbstractEdgeMap<T>
        where T : class
    {
        private readonly T[] arrayData;

        private int size;

        public ArrayEdgeMap(int minIndex, int maxIndex)
            : base(minIndex, maxIndex)
        {
            arrayData = new T[maxIndex - minIndex + 1];
        }

        public override int Count
        {
            get
            {
#if NET45PLUS
                return Volatile.Read(ref size);
#elif !PORTABLE && !COMPACT
                return Thread.VolatileRead(ref size);
#else
                return Interlocked.CompareExchange(ref size, 0, 0);
#endif
            }
        }

        public override bool IsEmpty
        {
            get
            {
                return Count == 0;
            }
        }

        public override bool ContainsKey(int key)
        {
            return this[key] != null;
        }

        public override T this[int key]
        {
            get
            {
                if (key < minIndex || key > maxIndex)
                {
                    return null;
                }

#if NET45PLUS
                return Volatile.Read(ref arrayData[key - minIndex]);
#else
                return Interlocked.CompareExchange(ref arrayData[key - minIndex], null, null);
#endif
            }
        }

        public override AbstractEdgeMap<T> Put(int key, T value)
        {
            if (key >= minIndex && key <= maxIndex)
            {
                T existing = Interlocked.Exchange(ref arrayData[key - minIndex], value);
                if (existing == null && value != null)
                {
                    Interlocked.Increment(ref size);
                }
                else
                {
                    if (existing != null && value == null)
                    {
                        Interlocked.Decrement(ref size);
                    }
                }
            }
            return this;
        }

        public override AbstractEdgeMap<T> Remove(int key)
        {
            return Put(key, null);
        }

        public override AbstractEdgeMap<T> PutAll(IEdgeMap<T> m)
        {
            if (m.IsEmpty)
            {
                return this;
            }
            if (m is Antlr4.Runtime.Dfa.ArrayEdgeMap<T>)
            {
                Antlr4.Runtime.Dfa.ArrayEdgeMap<T> other = (Antlr4.Runtime.Dfa.ArrayEdgeMap<T>)m;
                int minOverlap = Math.Max(minIndex, other.minIndex);
                int maxOverlap = Math.Min(maxIndex, other.maxIndex);
                Antlr4.Runtime.Dfa.ArrayEdgeMap<T> result = this;
                for (int i = minOverlap; i <= maxOverlap; i++)
                {
                    result = ((Antlr4.Runtime.Dfa.ArrayEdgeMap<T>)result.Put(i, m[i]));
                }
                return result;
            }
            else
            {
                if (m is SingletonEdgeMap<T>)
                {
                    SingletonEdgeMap<T> other = (SingletonEdgeMap<T>)m;
                    System.Diagnostics.Debug.Assert(!other.IsEmpty);
                    return Put(other.Key, other.Value);
                }
                else
                {
                    if (m is SparseEdgeMap<T>)
                    {
                        SparseEdgeMap<T> other = (SparseEdgeMap<T>)m;
                        lock (other)
                        {
                            int[] keys = other.Keys;
                            IList<T> values = other.Values;
                            Antlr4.Runtime.Dfa.ArrayEdgeMap<T> result = this;
                            for (int i = 0; i < values.Count; i++)
                            {
                                result = ((Antlr4.Runtime.Dfa.ArrayEdgeMap<T>)result.Put(keys[i], values[i]));
                            }
                            return result;
                        }
                    }
                    else
                    {
                        throw new NotSupportedException(string.Format("EdgeMap of type {0} is supported yet.", m.GetType().FullName));
                    }
                }
            }
        }

        public override AbstractEdgeMap<T> Clear()
        {
            return new EmptyEdgeMap<T>(minIndex, maxIndex);
        }

#if NET45PLUS
        public override IReadOnlyDictionary<int, T> ToMap()
#else
        public override IDictionary<int, T> ToMap()
#endif
        {
            if (IsEmpty)
            {
                return Sharpen.Collections.EmptyMap<int, T>();
            }

#if COMPACT
            IDictionary<int, T> result = new SortedList<int, T>();
#elif PORTABLE && !NET45PLUS
            IDictionary<int, T> result = new Dictionary<int, T>();
#else
            IDictionary<int, T> result = new SortedDictionary<int, T>();
#endif
            for (int i = 0; i < arrayData.Length; i++)
            {
                T element = arrayData[i];
                if (element == null)
                {
                    continue;
                }
                result[i + minIndex] = element;
            }
#if NET45PLUS
            return new ReadOnlyDictionary<int, T>(result);
#else
            return result;
#endif
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Antlr4.Runtime.Dfa;
using Antlr4.Runtime.Sharpen;
using Interlocked = System.Threading.Interlocked;

#if NET45PLUS
using Volatile = System.Threading.Volatile;
#elif !PORTABLE && !COMPACT
using Thread = System.Threading.Thread;
#endif

namespace Antlr4.Runtime.Dfa
{
    /// <author>Sam Harwell</author>
    internal sealed class ArrayEdgeMap<T> : AbstractEdgeMap<T>
        where T : class
    {
        private readonly T[] arrayData;

        private int size;

        public ArrayEdgeMap(int minIndex, int maxIndex)
            : base(minIndex, maxIndex)
        {
            arrayData = new T[maxIndex - minIndex + 1];
        }

        public override int Count
        {
            get
            {
#if NET45PLUS
                return Volatile.Read(ref size);
#elif !PORTABLE && !COMPACT
                return Thread.VolatileRead(ref size);
#else
                return Interlocked.CompareExchange(ref size, 0, 0);
#endif
            }
        }

        public override bool IsEmpty
        {
            get
            {
                return Count == 0;
            }
        }

        public override bool ContainsKey(int key)
        {
            return this[key] != null;
        }

        public override T this[int key]
        {
            get
            {
                if (key < minIndex || key > maxIndex)
                {
                    return null;
                }

#if NET45PLUS
                return Volatile.Read(ref arrayData[key - minIndex]);
#else
                return Interlocked.CompareExchange(ref arrayData[key - minIndex], null, null);
#endif
            }
        }

        public override AbstractEdgeMap<T> Put(int key, T value)
        {
            if (key >= minIndex && key <= maxIndex)
            {
                T existing = Interlocked.Exchange(ref arrayData[key - minIndex], value);
                if (existing == null && value != null)
                {
                    Interlocked.Increment(ref size);
                }
                else
                {
                    if (existing != null && value == null)
                    {
                        Interlocked.Decrement(ref size);
                    }
                }
            }
            return this;
        }

        public override AbstractEdgeMap<T> Remove(int key)
        {
            return Put(key, null);
        }

        public override AbstractEdgeMap<T> PutAll(IEdgeMap<T> m)
        {
            if (m.IsEmpty)
            {
                return this;
            }
            if (m is Antlr4.Runtime.Dfa.ArrayEdgeMap<T> other)
            {
                int minOverlap = Math.Max(minIndex, other.minIndex);
                int maxOverlap = Math.Min(maxIndex, other.maxIndex);
                Antlr4.Runtime.Dfa.ArrayEdgeMap<T> result = this;
                for (int i = minOverlap; i <= maxOverlap; i++)
                {
                    result = ((Antlr4.Runtime.Dfa.ArrayEdgeMap<T>)result.Put(i, m[i]));
                }
                return result;
            }
            else
            {
                if (m is SingletonEdgeMap<T> other)
                {
                    System.Diagnostics.Debug.Assert(!other.IsEmpty);
                    return Put(other.Key, other.Value);
                }
                else
                {
                    if (m is SparseEdgeMap<T> other)
                    {
                        lock (other)
                        {
                            int[] keys = other.Keys;
                            IList<T> values = other.Values;
                            Antlr4.Runtime.Dfa.ArrayEdgeMap<T> result = this;
                            for (int i = 0; i < values.Count; i++)
                            {
                                result = ((Antlr4.Runtime.Dfa.ArrayEdgeMap<T>)result.Put(keys[i], values[i]));
                            }
                            return result;
                        }
                    }
                    else
                    {
                        throw new NotSupportedException(string.Format("EdgeMap of type {0} is supported yet.", m.GetType().FullName));
                    }
                }
            }
        }

        public override AbstractEdgeMap<T> Clear()
        {
            return new EmptyEdgeMap<T>(minIndex, maxIndex);
        }

#if NET45PLUS
        public override IReadOnlyDictionary<int, T> ToMap()
#else
        public override IDictionary<int, T> ToMap()
#endif
        {
            if (IsEmpty)
            {
                return Sharpen.Collections.EmptyMap<int, T>();
            }

#if COMPACT
            IDictionary<int, T> result = new SortedList<int, T>();
#elif PORTABLE && !NET45PLUS
            IDictionary<int, T> result = new Dictionary<int, T>();
#else
            IDictionary<int, T> result = new SortedDictionary<int, T>();
#endif
            for (int i = 0; i < arrayData.Length; i++)
            {
                T element = arrayData[i];
                if (element == null)
                {
                    continue;
                }
                result[i + minIndex] = element;
            }
#if NET45PLUS
            return new ReadOnlyDictionary<int, T>(result);
#else
            return result;
#endif
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(10,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(12,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(125,46): error CS0136: A local or parameter named 'other' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(132,47): error CS0136: A local or parameter named 'other' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(10,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Microsoft.Azure.Cosmos\src\OSS\Antlr\Dfa\ArrayEdgeMap.cs(12,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\AsyncCache.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.Azure.Cosmos.Common
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Azure.Documents;

    /// <summary>
    /// Cache which supports asynchronous value initialization.
    /// It ensures that for given key only single inintialization funtion is running at any point in time.
    /// </summary>
    /// <typeparam name="TKey">Type of keys.</typeparam>
    /// <typeparam name="TValue">Type of values.</typeparam>
    internal sealed class AsyncCache<TKey, TValue>
    {
        private readonly IEqualityComparer<TValue> valueEqualityComparer;
        private readonly IEqualityComparer<TKey> keyEqualityComparer;

        private ConcurrentDictionary<TKey, AsyncLazy<TValue>> values;

        public AsyncCache(IEqualityComparer<TValue> valueEqualityComparer, IEqualityComparer<TKey> keyEqualityComparer = null)
        {
            this.keyEqualityComparer = keyEqualityComparer ?? EqualityComparer<TKey>.Default;
            this.values = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            this.valueEqualityComparer = valueEqualityComparer;
        }

        public AsyncCache()
            : this(EqualityComparer<TValue>.Default)
        {
        }

        public ICollection<TKey> Keys
        {
            get
            {
                return this.values.Keys;
            }
        }

        public void Set(TKey key, TValue value)
        {
            AsyncLazy<TValue> lazyValue = new AsyncLazy<TValue>(value);

            // Access it to mark as created+completed, so that further calls to getasync do not overwrite.
#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
            TValue x = lazyValue.Value.Result;
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits

            this.values.AddOrUpdate(key, lazyValue, (k, existingValue) =>
            {
                // Observe all exceptions thrown for existingValue.
                if (existingValue.IsValueCreated)
                {
                    Task unused = existingValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }

                return lazyValue;
            });
        }

        /// <summary>
        /// <para>
        /// Gets value corresponding to <paramref name="key"/>.
        /// </para>
        /// <para>
        /// If another initialization function is already running, new initialization function will not be started.
        /// The result will be result of currently running initialization function.
        /// </para>
        /// <para>
        /// If previous initialization function is successfully completed - value returned by it will be returned unless
        /// it is equal to <paramref name="obsoleteValue"/>, in which case new initialization function will be started.
        /// </para>
        /// <para>
        /// If previous initialization function failed - new one will be launched.
        /// </para>
        /// </summary>
        /// <param name="key">Key for which to get a value.</param>
        /// <param name="obsoleteValue">Value which is obsolete and needs to be refreshed.</param>
        /// <param name="singleValueInitFunc">Initialization function.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <param name="forceRefresh">Skip cached value and generate new value.</param>
        /// <returns>Cached value or value returned by initialization function.</returns>
        public async Task<TValue> GetAsync(
           TKey key,
           TValue obsoleteValue,
           Func<Task<TValue>> singleValueInitFunc,
           CancellationToken cancellationToken,
           bool forceRefresh = false)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AsyncLazy<TValue> initialLazyValue;

            if (this.values.TryGetValue(key, out initialLazyValue))
            {
                // If we haven't computed the value or we're currently computing it, then return it...
                if (!initialLazyValue.IsValueCreated || !initialLazyValue.Value.IsCompleted)
                {
                    try
                    {
                        return await initialLazyValue.Value;
                    }

                    // It does not matter to us if this instance of the task throws - the lambda that failed was provided by a different caller.
                    // The exception that we see here will be handled/logged by whatever caller provided the failing lambda, if any. Our part is catching and observing it.
                    // As such, we discard this exception and will retry with our own lambda below, for which we will let exception bubble up.
                    catch
                    {
                    }
                }

                // Don't check Task if there's an exception or it's been canceled. Accessing Task.Exception marks it as observed, which we want.
                else if (initialLazyValue.Value.Exception == null && !initialLazyValue.Value.IsCanceled)
                {
                    TValue cachedValue = await initialLazyValue.Value;

                    // If not forcing refresh or obsolete value, use cached value.
                    if (!forceRefresh && !this.valueEqualityComparer.Equals(cachedValue, obsoleteValue))
                    {
                        return cachedValue;
                    }
                }
            }

            AsyncLazy<TValue> newLazyValue = new AsyncLazy<TValue>(singleValueInitFunc, cancellationToken);

            // Update the new task in the cache - compare-and-swap style.
            AsyncLazy<TValue> actualValue = this.values.AddOrUpdate(
                key,
                newLazyValue,
                (existingKey, existingValue) => object.ReferenceEquals(existingValue, initialLazyValue) ? newLazyValue : existingValue);

            // Task starts running here.
            Task<TValue> generator = actualValue.Value;

            // Even if the current thread goes away, all exceptions will be observed.
            Task unused = generator.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);

            return await generator;
        }

        public void Remove(TKey key)
        {
            AsyncLazy<TValue> initialLazyValue;

            if (this.values.TryRemove(key, out initialLazyValue) && initialLazyValue.IsValueCreated)
            {
                // Observe all exceptions thrown.
                Task unused = initialLazyValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
            }
        }

        public bool TryRemoveIfCompleted(TKey key)
        {
            AsyncLazy<TValue> initialLazyValue;

            if (this.values.TryGetValue(key, out initialLazyValue) && initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted)
            {
                // Accessing Exception marks as observed.
                Exception e = initialLazyValue.Value.Exception;

                // This is a nice trick to do "atomic remove if value not changed".
                // ConcurrentDictionary inherits from ICollection<KVP<..>>, which allows removal of specific key value pair, instead of removal just by key.
                ICollection<KeyValuePair<TKey, AsyncLazy<TValue>>> valuesAsCollection = this.values as ICollection<KeyValuePair<TKey, AsyncLazy<TValue>>>;
                Debug.Assert(valuesAsCollection != null, "Values collection expected to implement ICollection<KVP<TKey, AsyncLazy<TValue>>.");
                return valuesAsCollection?.Remove(new KeyValuePair<TKey, AsyncLazy<TValue>>(key, initialLazyValue)) ?? false;
            }

            return false;
        }

        /// <summary>
        /// Remove value from cache and return it if present.
        /// </summary>
        /// <param name="key"></param>
        /// <returns>Value if present, default value if not present.</returns>
        public async Task<TValue> RemoveAsync(TKey key)
        {
            AsyncLazy<TValue> initialLazyValue;
            if (this.values.TryRemove(key, out initialLazyValue))
            {
                try
                {
                    return await initialLazyValue.Value;
                }
                catch
                {
                }
            }

            return default(TValue);
        }

        public void Clear()
        {
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> newValues = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> oldValues = Interlocked.Exchange(ref this.values, newValues);

            // Ensure all tasks are observed.
            foreach (AsyncLazy<TValue> value in oldValues.Values)
            {
                if (value.IsValueCreated)
                {
                    Task unused = value.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }
            }

            oldValues.Clear();
        }

        /// <summary>
        /// Runs a background task that will started refreshing the cached value for a given key.
        /// This observes the same logic as GetAsync - a running value will still take precedence over a call to this.
        /// </summary>
        /// <param name="key">Key.</param>
        /// <param name="singleValueInitFunc">Generator function.</param>
        public void BackgroundRefreshNonBlocking(TKey key, Func<Task<TValue>> singleValueInitFunc)
        {
            // Trigger background refresh of cached value.
            // Fire and forget.
            Task unused = Task.Factory.StartNewOnCurrentTaskSchedulerAsync(async () =>
            {
                try
                {
                    AsyncLazy<TValue> initialLazyValue;

                    // If we don't have a value, or we have one that has completed running (i.e. if a value is currently being generated, we do nothing).
                    if (!this.values.TryGetValue(key, out initialLazyValue) || (initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted))
                    {
                        // Use GetAsync to trigger the generation of a value.
                        await this.GetAsync(
                            key,
                            default(TValue), // obsolete value unused since forceRefresh: true
                            singleValueInitFunc,
                            CancellationToken.None,
                            forceRefresh: true);
                    }
                }
                catch
                {
                    // Observe all exceptions.
                }
            }).Unwrap();
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.Azure.Cosmos.Common
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Azure.Documents;

    /// <summary>
    /// Cache which supports asynchronous value initialization.
    /// It ensures that for given key only single inintialization funtion is running at any point in time.
    /// </summary>
    /// <typeparam name="TKey">Type of keys.</typeparam>
    /// <typeparam name="TValue">Type of values.</typeparam>
    internal sealed class AsyncCache<TKey, TValue>
    {
        private readonly IEqualityComparer<TValue> valueEqualityComparer;
        private readonly IEqualityComparer<TKey> keyEqualityComparer;

        private ConcurrentDictionary<TKey, AsyncLazy<TValue>> values;

        public AsyncCache(IEqualityComparer<TValue> valueEqualityComparer, IEqualityComparer<TKey> keyEqualityComparer = null)
        {
            this.keyEqualityComparer = keyEqualityComparer ?? EqualityComparer<TKey>.Default;
            this.values = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            this.valueEqualityComparer = valueEqualityComparer;
        }

        public AsyncCache()
            : this(EqualityComparer<TValue>.Default)
        {
        }

        public ICollection<TKey> Keys
        {
            get
            {
                return this.values.Keys;
            }
        }

        public void Set(TKey key, TValue value)
        {
            AsyncLazy<TValue> lazyValue = new AsyncLazy<TValue>(value);

            // Access it to mark as created+completed, so that further calls to getasync do not overwrite.
#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
            TValue x = lazyValue.Value.Result;
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits

            this.values.AddOrUpdate(key, lazyValue, (k, existingValue) =>
            {
                // Observe all exceptions thrown for existingValue.
                if (existingValue.IsValueCreated)
                {
                    Task unused = existingValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }

                return lazyValue;
            });
        }

        /// <summary>
        /// <para>
        /// Gets value corresponding to <paramref name="key"/>.
        /// </para>
        /// <para>
        /// If another initialization function is already running, new initialization function will not be started.
        /// The result will be result of currently running initialization function.
        /// </para>
        /// <para>
        /// If previous initialization function is successfully completed - value returned by it will be returned unless
        /// it is equal to <paramref name="obsoleteValue"/>, in which case new initialization function will be started.
        /// </para>
        /// <para>
        /// If previous initialization function failed - new one will be launched.
        /// </para>
        /// </summary>
        /// <param name="key">Key for which to get a value.</param>
        /// <param name="obsoleteValue">Value which is obsolete and needs to be refreshed.</param>
        /// <param name="singleValueInitFunc">Initialization function.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <param name="forceRefresh">Skip cached value and generate new value.</param>
        /// <returns>Cached value or value returned by initialization function.</returns>
        public async Task<TValue> GetAsync(
           TKey key,
           TValue obsoleteValue,
           Func<Task<TValue>> singleValueInitFunc,
           CancellationToken cancellationToken,
           bool forceRefresh = false)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AsyncLazy<TValue> initialLazyValue;

            if (this.values.TryGetValue(key, out initialLazyValue))
            {
                // If we haven't computed the value or we're currently computing it, then return it...
                if (!initialLazyValue.IsValueCreated || !initialLazyValue.Value.IsCompleted)
                {
                    try
                    {
                        return await initialLazyValue.Value;
                    }

                    // It does not matter to us if this instance of the task throws - the lambda that failed was provided by a different caller.
                    // The exception that we see here will be handled/logged by whatever caller provided the failing lambda, if any. Our part is catching and observing it.
                    // As such, we discard this exception and will retry with our own lambda below, for which we will let exception bubble up.
                    catch
                    {
                    }
                }

                // Don't check Task if there's an exception or it's been canceled. Accessing Task.Exception marks it as observed, which we want.
                else if (initialLazyValue.Value.Exception == null && !initialLazyValue.Value.IsCanceled)
                {
                    TValue cachedValue = await initialLazyValue.Value;

                    // If not forcing refresh or obsolete value, use cached value.
                    if (!forceRefresh && !this.valueEqualityComparer.Equals(cachedValue, obsoleteValue))
                    {
                        return cachedValue;
                    }
                }
            }

            AsyncLazy<TValue> newLazyValue = new AsyncLazy<TValue>(singleValueInitFunc, cancellationToken);

            // Update the new task in the cache - compare-and-swap style.
            AsyncLazy<TValue> actualValue = this.values.AddOrUpdate(
                key,
                newLazyValue,
                (existingKey, existingValue) => object.ReferenceEquals(existingValue, initialLazyValue) ? newLazyValue : existingValue);

            // Task starts running here.
            Task<TValue> generator = actualValue.Value;

            // Even if the current thread goes away, all exceptions will be observed.
            Task unused = generator.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);

            return await generator;
        }

        public void Remove(TKey key)
        {
            AsyncLazy<TValue> initialLazyValue;

            if (this.values.TryRemove(key, out initialLazyValue) && initialLazyValue.IsValueCreated)
            {
                // Observe all exceptions thrown.
                Task unused = initialLazyValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
            }
        }

        public bool TryRemoveIfCompleted(TKey key)
        {
            AsyncLazy<TValue> initialLazyValue;

            if (this.values.TryGetValue(key, out initialLazyValue) && initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted)
            {
                // Accessing Exception marks as observed.
                Exception e = initialLazyValue.Value.Exception;
                // This is a nice trick to do "atomic remove if value not changed".                // ConcurrentDictionary inherits from ICollection<KVP<..>>, which allows removal of specific key value pair, instead of removal just by key.
                Debug.Assert(this.values is ICollection<KeyValuePair<TKey, AsyncLazy<TValue>>> valuesAsCollection, "Values collection expected to implement ICollection<KVP<TKey, AsyncLazy<TValue>>.");
                return valuesAsCollection?.Remove(new KeyValuePair<TKey, AsyncLazy<TValue>>(key, initialLazyValue)) ?? false;
            }

            return false;
        }

        /// <summary>
        /// Remove value from cache and return it if present.
        /// </summary>
        /// <param name="key"></param>
        /// <returns>Value if present, default value if not present.</returns>
        public async Task<TValue> RemoveAsync(TKey key)
        {
            AsyncLazy<TValue> initialLazyValue;
            if (this.values.TryRemove(key, out initialLazyValue))
            {
                try
                {
                    return await initialLazyValue.Value;
                }
                catch
                {
                }
            }

            return default(TValue);
        }

        public void Clear()
        {
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> newValues = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> oldValues = Interlocked.Exchange(ref this.values, newValues);

            // Ensure all tasks are observed.
            foreach (AsyncLazy<TValue> value in oldValues.Values)
            {
                if (value.IsValueCreated)
                {
                    Task unused = value.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }
            }

            oldValues.Clear();
        }

        /// <summary>
        /// Runs a background task that will started refreshing the cached value for a given key.
        /// This observes the same logic as GetAsync - a running value will still take precedence over a call to this.
        /// </summary>
        /// <param name="key">Key.</param>
        /// <param name="singleValueInitFunc">Generator function.</param>
        public void BackgroundRefreshNonBlocking(TKey key, Func<Task<TValue>> singleValueInitFunc)
        {
            // Trigger background refresh of cached value.
            // Fire and forget.
            Task unused = Task.Factory.StartNewOnCurrentTaskSchedulerAsync(async () =>
            {
                try
                {
                    AsyncLazy<TValue> initialLazyValue;

                    // If we don't have a value, or we have one that has completed running (i.e. if a value is currently being generated, we do nothing).
                    if (!this.values.TryGetValue(key, out initialLazyValue) || (initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted))
                    {
                        // Use GetAsync to trigger the generation of a value.
                        await this.GetAsync(
                            key,
                            default(TValue), // obsolete value unused since forceRefresh: true
                            singleValueInitFunc,
                            CancellationToken.None,
                            forceRefresh: true);
                    }
                }
                catch
                {
                    // Observe all exceptions.
                }
            }).Unwrap();
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\src\Routing\AsyncCache.cs(171,24): error CS0165: Use of unassigned local variable 'valuesAsCollection'
######################################################################


######################################################################
Nr: 5 - UseMethodAnyRewriterR6
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.Azure.Cosmos.Services.Management.Tests.LinqProviderTests
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic;
    using System.Runtime.Serialization;
    using System.Threading.Tasks;
    using Microsoft.Azure.Cosmos.Linq;
    using Microsoft.Azure.Cosmos.SDK.EmulatorTests;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Newtonsoft.Json;
    using BaselineTest;
    using Microsoft.Azure.Documents;
    using Microsoft.Azure.Cosmos.Scripts;

    [Microsoft.Azure.Cosmos.SDK.EmulatorTests.TestClass]
    public class LinqGeneralBaselineTests : BaselineTests<LinqTestInput, LinqTestOutput>
    {
        private static CosmosClient cosmosClient;
        private static Cosmos.Database testDb;
        private static Container testContainer;
        private static Func<bool, IQueryable<Family>> getQuery;

        [ClassInitialize]
        public async static Task Initialize(TestContext textContext)
        {
            cosmosClient = TestCommon.CreateCosmosClient(true);
            DocumentClientSwitchLinkExtension.Reset("LinqTests");

            string dbName = $"{nameof(LinqGeneralBaselineTests)}-{Guid.NewGuid().ToString("N")}";
            testDb = await cosmosClient.CreateDatabaseAsync(dbName);

            getQuery = LinqTestsCommon.GenerateFamilyCosmosData(testDb, out testContainer);
        }

        [ClassCleanup]
        public async static Task CleanUp()
        {
            if (testDb != null)
            {
                await testDb.DeleteStreamAsync();
            }
        }

        public class Address
        {
            public string State;
            public string County;
            public string City;
        }

        public class GuidClass : LinqTestObject
        {
            [JsonProperty(PropertyName = "id")]
            public Guid Id;
        }

        public class ListArrayClass : LinqTestObject
        {
            [JsonProperty(PropertyName = "id")]
            public string Id;

            public int[] ArrayField;
            public List<int> ListField;
        }

        [DataContract]
        public class Sport : LinqTestObject
        {
            [DataMember(Name = "id")]
            public string SportName;

            [JsonProperty(PropertyName = "json")]
            [DataMember(Name = "data")]
            public string SportType;
        }

        public class Sport2 : LinqTestObject
        {
            [DataMember(Name = "data")]
            public string id;
        }

        [TestMethod]
        public void TestSelectMany()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            inputs.Add(new LinqTestInput("SelectMany(SelectMany(Where -> Select))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))));

            inputs.Add(new LinqTestInput("SelectMany(Where -> SelectMany(Where -> Select))",
                b => getQuery(b)
                .SelectMany(family => family.Children.Where(c => c.Grade > 10)
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))));

            inputs.Add(new LinqTestInput("SelectMany(SelectMany(Where -> Select new {}))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Select)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Select(n => n.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Where)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Where(n => n.Count() > 10))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select) -> Select",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName)).Select(n => n.Count())));

            inputs.Add(new LinqTestInput("SelectMany()", b => getQuery(b).SelectMany(root => root.Children)));

            inputs.Add(new LinqTestInput("SelectMany -> SelectMany", b => getQuery(b).SelectMany(f => f.Children).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput("SelectMany -> Where -> SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Children).Where(c => c.Pets.Count() > 0).SelectMany(c => c.Pets.Select(p => p.GivenName))));

            inputs.Add(new LinqTestInput("SelectMany -> Where -> SelectMany(Select new)", b => getQuery(b)
                .SelectMany(f => f.Children)
                .Where(c => c.Pets.Count() > 0)
                .SelectMany(c => c.Pets.Select(p => new { PetName = p.GivenName, OwnerName = c.GivenName }))));

            inputs.Add(new LinqTestInput("Where -> SelectMany", b => getQuery(b).Where(f => f.Children.Count() > 0).SelectMany(f => f.Children)));

            inputs.Add(new LinqTestInput("SelectMany -> Select", b => getQuery(b).SelectMany(f => f.Children).Select(c => c.FamilyName)));

            inputs.Add(new LinqTestInput("SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput("SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName))));

            inputs.Add(new LinqTestInput("SelectMany(Select -> Select)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Select(n => n.Count()))));

            inputs.Add(new LinqTestInput("SelectMany(Select -> Where)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Where(n => n.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(Take -> Where)", b => getQuery(b).SelectMany(f => f.Children.Take(2).Where(c => c.FamilyName.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(OrderBy -> Take -> Where)", b => getQuery(b).SelectMany(f => f.Children.OrderBy(c => c.Grade).Take(2).Where(c => c.FamilyName.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(Distinct -> Where)", b => getQuery(b).SelectMany(f => f.Children.Distinct().Where(c => c.FamilyName.Count() > 10))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestSimpleSubquery()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            inputs.Add(new LinqTestInput("Select -> Select", b => getQuery(b).Select(f => f.FamilyId).Select(n => n.Count())));

            inputs.Add(new LinqTestInput("Select -> Where", b => getQuery(b).Select(f => f.FamilyId).Where(id => id.Count() > 10)));

            inputs.Add(new LinqTestInput("Select -> OrderBy -> Take -> Select -> Orderby -> Take", b => getQuery(b).Select(x => x).OrderBy(x => x).Take(10).Select(f => f.FamilyId).OrderBy(n => n.Count()).Take(5)));

            inputs.Add(new LinqTestInput("Select -> Orderby -> Take -> Select -> Orderby -> Take", b => getQuery(b).Select(f => f).OrderBy(f => f.Children.Count()).Take(3).Select(x => x).OrderBy(f => f.Parents.Count()).Take(2)));

            inputs.Add(new LinqTestInput("Orderby -> Take -> Orderby -> Take", b => getQuery(b).OrderBy(f => f.Children.Count()).Take(3).OrderBy(f => f.Parents.Count()).Take(2)));

            inputs.Add(new LinqTestInput("Take -> Orderby -> Take", b => getQuery(b).Take(10).OrderBy(f => f.FamilyId).Take(1)));

            inputs.Add(new LinqTestInput("Take -> Where -> Take -> Where -> Take -> Where", b => getQuery(b).Take(10).Where(f => f.Children.Count() > 0).Take(9).Where(f => f.Parents.Count() > 0).Take(8).Where(f => f.FamilyId.Count() > 10)));

            inputs.Add(new LinqTestInput("Take -> Where -> Distinct -> Select -> Take -> Where", b => getQuery(b).Take(10).Where(f => f.Children.Count() > 0).Distinct().Select(f => new { f }).Take(8).Where(f => f.f.FamilyId.Count() > 10)));

            inputs.Add(new LinqTestInput("Distinct -> Select -> Take -> Where -> Take -> Where", b => getQuery(b).Distinct().Select(f => new { f }).Take(10).Where(f => f.f.Children.Count() > 0).Take(9).Where(f => f.f.Parents.Count() > 0)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestQueryFlattening()
        {
            // these queries should make more sense when combined with where and orderby
            // these tests verify the flattening part
            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("array create", b => getQuery(b).Select(f => f.Int).Select(i => new int[] { i })));
            inputs.Add(new LinqTestInput("unary operation", b => getQuery(b).Select(f => f.Int).Select(i => -i)));
            inputs.Add(new LinqTestInput("binary operation", b => getQuery(b).Select(f => f).Select(i => i.Int % 10 * i.Children.Count())));
            inputs.Add(new LinqTestInput("literal", b => getQuery(b).Select(f => f.Int).Select(i => 0)));
            inputs.Add(new LinqTestInput("function call", b => getQuery(b).Select(f => f.Parents).Select(p => p.Count())));
            inputs.Add(new LinqTestInput("object create", b => getQuery(b).Select(f => f.Parents).Select(p => new { parentCount = p.Count() })));
            inputs.Add(new LinqTestInput("conditional", b => getQuery(b).Select(f => f.Children).Select(c => c.Count() > 0 ? "have kids" : "no kids")));
            inputs.Add(new LinqTestInput("property ref + indexer", b => getQuery(b).Select(f => f)
                .Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 0)
                .Select(f => f.Children[0].Pets[0].GivenName)));

            inputs.Add(new LinqTestInput("array creation -> indexer", b => getQuery(b).Select(f => new int[] { f.Int }).Select(array => array[0])));
            inputs.Add(new LinqTestInput("unary, indexer, property, function call -> function call", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .Select(f => -f.Children[0].Pets.Count()).Select(i => Math.Abs(i))));
            inputs.Add(new LinqTestInput("binary operation, function call -> conditional", b => getQuery(b).Select(i => i.Int % 10 * i.Children.Count()).Select(i => i > 0 ? new int[] { i } : new int[] { })));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b)
                .Select(f => new { parentCount = f.Parents.Count(), childrenCount = f.Children.Count() })
                .Select(r => r.parentCount > 0 ? Math.Floor((double)r.childrenCount / r.parentCount) : 0)));
            inputs.Add(new LinqTestInput("indexer -> function call", b => getQuery(b).Select(f => f.Parents[0]).Select(p => string.Concat(p.FamilyName, p.GivenName))));
            inputs.Add(new LinqTestInput("conditional -> object creation", b => getQuery(b).Select(f => f.Parents.Count() > 0 ? f.Parents : new Parent[0]).Select(p => new { parentCount = p.Count() })));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b).Select(f => new { children = f.Children }).Select(c => c.children.Count() > 0 ? c.children[0].GivenName : "no kids")));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b).Select(f => new { family = f, children = f.Children.Count() }).Select(f => f.children > 0 && f.family.Children[0].Pets.Count() > 0 ? f.family.Children[0].Pets[0].GivenName : "no kids")));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestSubquery()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------------------------
            // Subquery lambdas
            // --------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Pets.Count()))));
                
            inputs.Add(new LinqTestInput(
                "Select(Take)", b => getQuery(b)
                .Select(f => f.Children.Take(2))));
                
            inputs.Add(new LinqTestInput(
                "Select(Where)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Pets.Count() > 0))));
                
            inputs.Add(new LinqTestInput(
                "Select(Distinct)", b => getQuery(b)
                .Select(f => f.Children.Distinct())));
                
            inputs.Add(new LinqTestInput(
                "Select(Count)", b => getQuery(b)
                .Select(f => f.Children.Count(c => c.Grade > 80))));

            inputs.Add(new LinqTestInput(
                "Select(Sum)", b => getQuery(b)
                .Select(f => f.Children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "Where(Count)", b => getQuery(b)
                .Where(f => f.Children.Count(c => c.Pets.Count() > 0) > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Sum)", b => getQuery(b)
                .Where(f => f.Children.Sum(c => c.Grade) > 100)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Count)", b => getQuery(b)
                .OrderBy(f => f.Children.Count(c => c.Grade > 90))));

            // -------------------------------------------------------------
            // Mutilpe-transformations subquery lambdas
            // -------------------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select -> Distinct -> Count)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Gender).Distinct().Count())));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Sum)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Sum())));

            inputs.Add(new LinqTestInput(
                "Select(Select -> OrderBy -> Take)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.GivenName).OrderBy(n => n.Length).Take(1))));

            inputs.Add(new LinqTestInput(
                "Select(SelectMany -> Select)", b => getQuery(b)
                .Select(f => f.Children.SelectMany(c => c.Pets).Select(c => c.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Count)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Count())));

            inputs.Add(new LinqTestInput(
                "Select(Where -> OrderBy -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).OrderBy(c => c.Pets.Count()).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Select -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Select(c => c.Pets.Count()).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Select(array) -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Select(c => c.Pets).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(where -> Select -> Distinct)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50 && c.Pets.Count() > 0).Select(c => c.Gender).Distinct())));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy -> Take -> Select)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Grade).Take(1).Select(c => c.Gender))));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy -> Take -> Select -> Average)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Pets.Count()).Take(2).Select(c => c.Grade).Average())));

            inputs.Add(new LinqTestInput(
                "Where(Select -> Count)", b => getQuery(b)
                .Where(f => f.Children.Select(c => c.Pets.Count()).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> Count)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> Sum)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).Sum(c => c.Grade) < 200)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> OrderBy -> Take -> Select)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).OrderBy(c => c.Grade).Take(1).Where(c => c.Grade > 80).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select -> Where)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Pets.Count()).Where(x => x > 1))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Where -> Count)", b => getQuery(b)
                .OrderBy(f => f.Children.Where(c => c.Pets.Count() > 3).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select -> Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Grade).Sum())));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> Take -> Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.OrderBy(c => c.Pets.Count()).Take(2).Sum(c => c.Grade))));

            // ---------------------------------------------------------
            // Scalar and Built-in expressions with subquery lambdas
            // ---------------------------------------------------------

            // Unary

            inputs.Add(new LinqTestInput(
                "Where(unary (Where -> Count))", b => getQuery(b)
                .Where(f => -f.Children.Where(c => c.Grade < 20).Count() == 0)));

            // Binary

            inputs.Add(new LinqTestInput(
                "Select(binary with Count)", b => getQuery(b)
                .Select(f => 5 + f.Children.Count(c => c.Pets.Count() > 0))));
                
            inputs.Add(new LinqTestInput(
                "Select(constant + Where -> Count)", b => getQuery(b)
                .Select(f => 5 + f.Children.Where(c => c.Pets.Count() > 0).Count())));

            inputs.Add(new LinqTestInput(
                "Where((Where -> Count) % constant)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).Count() % 2 == 1)));

            // Conditional

            inputs.Add(new LinqTestInput(
                "Select(conditional Any ? Select : Select)", b => getQuery(b)
                .Select(f => f.Children.Any() ? f.Children.Select(c => c.GivenName) : f.Parents.Select(p => p.GivenName))));

            inputs.Add(new LinqTestInput(
                "Select(conditional Any(filter) ? Max : Sum)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Grade > 97) ? f.Children.Max(c => c.Grade) : f.Children.Sum(c => c.Grade))));

            // New array

            inputs.Add(new LinqTestInput(
                "Select(new array)", b => getQuery(b)
                .Select(f => new int[] { f.Children.Count(), f.Children.Sum(c => c.Grade) })));

            // New + member init

            inputs.Add(new LinqTestInput(
                "Select(new)", b => getQuery(b)
                .Select(f => new int[] { f.Children.Count(), f.Children.Sum(c => c.Grade) })));

            inputs.Add(new LinqTestInput(
               "Select(Select new)", b => getQuery(b)
               .Select(f => new { f.FamilyId, ChildrenPetCount = f.Children.Select(c => c.Pets.Count()) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where)", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 3) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where)", b => getQuery(b)
                .Select(f => new { f.FamilyId, GoodChildren = f.Children.Where(c => c.Grade > 90) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where -> Select)", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 3).Select(c => c.GivenName) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where -> Count) -> Where", b => getQuery(b)
                .Select(f => new { Family = f, ChildrenCount = f.Children.Where(c => c.Grade > 0).Count() }).Where(f => f.ChildrenCount > 0)));

            // Array builtin functions

            inputs.Add(new LinqTestInput(
                "Select(Where -> Concat(Where))", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 90).Concat(f.Children.Where(c => c.Grade < 10)))));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Contains(Sum))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Contains(f.Children.Sum(c => c.Pets.Count())))));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Contains(Where -> Count))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Contains(f.Children.Where(c => c.Grade > 50).Count()))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(array indexer)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Grade > 20).Count() >= 2)
                .Select(f => f.Children.Where(c => c.Grade > 20).ToArray()[1])));

            inputs.Add(new LinqTestInput(
                "Where -> Select(array indexer)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Grade > 20).Count() >= 2)
                .Select(f => f.Children.Where(c => c.Grade > 20).ToArray()[f.Children.Count() % 2])));

            // Math builtin functions

            inputs.Add(new LinqTestInput(
                "Select(Floor(sum(map), sum(map)))", b => getQuery(b)
                .Select(f => Math.Floor(1.0 * f.Children.Sum(c => c.Grade) / (f.Children.Sum(c => c.Pets.Count()) + 1)))));

            inputs.Add(new LinqTestInput(
                "Select(Pow(Sum(map), Count(Any)))", b => getQuery(b)
                .Select(f => Math.Pow(f.Children.Sum(c => c.Pets.Count()), f.Children.Count(c => c.Pets.Any(p => p.GivenName.Count() == 0 || p.GivenName.Substring(0, 1) == "A"))))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Log(Where -> Count))", b => getQuery(b)
                .OrderBy(f => Math.Log(f.Children.Where(c => c.Pets.Count() > 0).Count()))));

            // ------------------------------------------------------------------
            // Expression with subquery lambdas -> more transformations
            // ------------------------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Where", b => getQuery(b).Select(f => f.Children.Select(c => c.Pets.Count())).Where(x => x.Count() > 0)));
            
            // Customer requested scenario
            inputs.Add(new LinqTestInput(
                "Select(new w/ Where) -> Where -> OrderBy -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), SmartChildren = f.Children.Where(c => c.Grade > 90) })
                .Where(f => f.FamilyId.CompareTo("ABC") > 0 && f.SmartChildren.Count() > 0)
                .OrderBy(f => f.ChildrenCount)
                .Take(10)));
            // TODO https://github.com/Azure/azure-cosmos-dotnet-v3/issues/375
            //inputs.Add(new LinqTestInput(
            //    "Select(new w/ Where) -> Where -> OrderBy -> Take", b => getQuery(b)
            //    .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), SmartChildren = f.Children.Where(c => c.Grade > 90) })
            //    .Where(f => f.ChildrenCount > 2 && f.SmartChildren.Count() > 1)
            //    .OrderBy(f => f.FamilyId)
            //    .Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new { Select(Select), conditional Count Take }) -> Where -> Select(Select(Any))", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    ChildrenPetFirstChars = f.Children.Select(c => c.Pets.Select(p => p.GivenName.Substring(0, 1))),
                    FirstChild = f.Children.Count() > 0 ? f.Children.Take(1) : null
                })
                .Where(f => f.FirstChild != null)
                .Select(f => f.ChildrenPetFirstChars.Select(chArray => chArray.Any(a => f.FamilyId.StartsWith(a))))));

            inputs.Add(new LinqTestInput(
                "Select(new (Select(new (Select, Select))))", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    ChildrenProfile = f.Children.Select(c => new
                    {
                        Fullname = c.GivenName + " " + c.FamilyName,
                        PetNames = c.Pets.Select(p => p.GivenName),
                        ParentNames = f.Parents.Select(p => p.GivenName)
                    })
                })));

            // ------------------------------------------------
            // Subquery lambda -> subquery lamda
            // ------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(array) -> Where(Sum(map))", b => getQuery(b)
                .Select(f => f.Children).Where(children => children.Sum(c => c.Grade) > 100)));

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Select(Sum())", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade)).Select(children => children.Sum())));

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Select(Sum(map))", b => getQuery(b)
                .Select(f => f.Children).Select(children => children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "Where(Any binary) -> Select(Sum(map))", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Grade > 90) && f.IsRegistered)
                .Select(f => f.Children.Sum(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Where(Any binary) -> OrderBy(Count(filter)) -> Select(Sum(map))", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Grade > 90) && f.IsRegistered)
                .OrderBy(f => f.Children.Count(c => c.Things.Count() > 3))
                .Select(f => f.Children.Sum(c => c.Pets.Count()))));

            // ------------------------------
            // Nested subquery lambdas
            // ------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select(Select))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName.Count())))));

            inputs.Add(new LinqTestInput(
                "Select(Select(Select))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Select(p => p)))));

            inputs.Add(new LinqTestInput(
                "Select(Select(new Count))", b => getQuery(b)
                .Select(f => f.Children
                    .Select(c => new
                    {
                        HasSiblingWithSameStartingChar = f.Children.Count(child => (child.GivenName + " ").Substring(0, 1) == (c.GivenName + " ").Substring(0, 1)) > 1
                    }))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(conditional ? Take : OrderBy -> Array indexer)", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .Select(f => f.Children.Count() == 1 ? f.Children.Take(1).ToArray()[0] : f.Children.OrderBy(c => c.Grade).ToArray()[1])));

            inputs.Add(new LinqTestInput(
                "Select(Where(Where -> Count) -> Select(new Count))", b => getQuery(b)
                .Select(f => f.Children
                    .Where(c => c.Pets
                        .Where(p => p.GivenName.Count() > 10 && p.GivenName.Substring(0, 1) == "A")
                        .Count() > 0)
                    .Select(c => new
                    {
                        HasSiblingWithSameStartingChar = f.Children.Count(child => (child.GivenName + " ").Substring(0, 1) == (c.GivenName + " ").Substring(0, 1)) > 1
                    }))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select(Select))", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName.Count())))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where(Any))", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Pets.Any(p => p.GivenName.Count() > 10)))));

            inputs.Add(new LinqTestInput(
                "Where(Where(Count) -> Count)", b => getQuery(b)
                .Where(f => f.Parents.Where(p => p.FamilyName.Count() > 10).Count() > 1)));

            inputs.Add(new LinqTestInput(
                "Where(Where(Where -> Count) -> Count)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Where(p => p.GivenName.Count() > 15).Count() > 0).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Select(Select -> Any))", b => getQuery(b)
                .Where(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName)).Any(t => t.Count() > 3))));

            // -------------------------------------
            // Expression -> Subquery lambdas
            // -------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(new) -> Select(Select)", b => getQuery(b)
                .Select(f => new { f.FamilyId, Family = f }).Select(f => f.Family.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select(Select)", b => getQuery(b)
                .SelectMany(f => f.Children).Select(c => c.Pets.Select(p => p.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where) -> Where(Any) -> Select(Select)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Grade > 80))
                .Where(c => c.Pets.Any(p => p.GivenName.Count() > 20))
                .Select(c => c.Pets.Select(p => p.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "Distinct -> Select(new) -> Where(Select(Select -> Any))", b => getQuery(b)
                .Distinct()
                .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), Family = f })
                .Where(f => f.Family.Children.Select(c => c.Pets.Select(p => p.GivenName)).Any(t => t.Count() > 3))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(Select)", b => getQuery(b)
                .Where(f => f.Children.Count() > 0).Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Distinct -> Select(Select)", b => getQuery(b)
                .Distinct().Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Take -> Select(Select)", b => getQuery(b)
                .Take(10).Select(f => f.Children.Select(c => c.Pets.Count()))));
            
            // ------------------
            // Any in lambda
            // ------------------

            inputs.Add(new LinqTestInput(
                "Select(Any w const array)", b => getQuery(b)
                .Select(f => new int[] { 1, 2, 3 }.Any())));
                
            inputs.Add(new LinqTestInput(
                "Select(Any)", b => getQuery(b)
                .Select(f => f.Children.Any())));
                
            inputs.Add(new LinqTestInput(
                "Select(Any w lambda)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Grade > 80))));
                
            inputs.Add(new LinqTestInput(
                "Select(new Any)", b => getQuery(b)
                .Select(f => new { f.FamilyId, HasGoodChildren = f.Children.Any(c => c.Grade > 80) })));
                
            inputs.Add(new LinqTestInput(
                "Select(new 2 Any)", b => getQuery(b)
                .Select(f => new { HasChildrenWithPets = f.Children.Any(c => c.Pets.Count() > 0), HasGoodChildren = f.Children.Any(c => c.Grade > 80) })));
                
            inputs.Add(new LinqTestInput(
                "Select(Nested Any)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Pets.Any(p => p.GivenName.Count() > 10)))));

            inputs.Add(new LinqTestInput(
                "Where(Any)", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Pets.Count() > 0))));

            // Customer requested scenario
            inputs.Add(new LinqTestInput(
                "Where(simple expr && Any)", b => getQuery(b)
                .Where(f => f.FamilyId.Contains("a") && f.Children.Any(c => c.Pets.Count() > 0))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Any)", b => getQuery(b)
                .OrderBy(f => f.Children.Any(c => c.Pets.Count() > 3))));
            
            // ------------------------------------------------
            // SelectMany with Take and OrderBy in lambda
            // ------------------------------------------------

            inputs.Add(new LinqTestInput(
                "SelectMany(Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Take(2))));

            inputs.Add(new LinqTestInput(
                "SelectMany(OrderBy)", b => getQuery(b)
                .SelectMany(f => f.Children.OrderBy(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.FamilyName.Count() > 10).Take(2))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> Take -> Select)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.FamilyName.Count() > 10).Take(2).Select(c => c.Grade))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void DebuggingTest()
        {
            
        }

        [TestMethod]
        [Owner("khdang")]
        [Ignore]
        public void TestSkipTake()
        {
            //TODO
            //V2 using V3 pipeline causing issue on accessing Continuation in CosmosQueryResponseMessageHeaders
            //This will be fine once we convert these test cases to use V3 pipeline

            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------------------
            // Skip - Take combinations
            // --------------------------------

            inputs.Add(new LinqTestInput(
                "Skip", b => getQuery(b)
                .Skip(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take", b => getQuery(b)
                .Skip(1).Take(2)));

            inputs.Add(new LinqTestInput(
                "Skip(negative number) -> Take", b => getQuery(b)
                .Skip(-1).Take(1)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take(negative number)", b => getQuery(b)
                .Skip(1).Take(-2)));

            inputs.Add(new LinqTestInput(
                "Skip -> Skip -> Take", b => getQuery(b)
                .Skip(1).Skip(2).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Take", b => getQuery(b)
                .Skip(3).Take(5).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Skip -> Take", b => getQuery(b)
                .Skip(1).Take(2).Skip(3).Take(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Take -> Skip", b => getQuery(b)
                .Skip(1).Take(2).Take(3).Skip(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Skip -> Take -> Take", b => getQuery(b)
                .Skip(5).Skip(2).Take(10).Take(3)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip", b => getQuery(b)
                .Take(7).Skip(3)));

            inputs.Add(new LinqTestInput(
                "Take -> Take -> Skip", b => getQuery(b)
                .Take(2).Take(3).Skip(5)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Skip", b => getQuery(b)
                .Take(3).Skip(1).Skip(2)));

            inputs.Add(new LinqTestInput(
                "Take -> Take -> Skip -> Skip", b => getQuery(b)
                .Take(5).Take(3).Skip(1).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Take -> Skip", b => getQuery(b)
                .Take(10).Skip(2).Take(5).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Skip -> Take", b => getQuery(b)
                .Take(10).Skip(4).Skip(2).Take(2)));

            // --------------------------
            // Select + Skip & Take
            // --------------------------

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(1).Take(2)));

            inputs.Add(new LinqTestInput(
                "Select -> Take -> Skip", b => getQuery(b)
                .Select(f => f.FamilyId).Take(2).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> Select", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(7).Take(13).Select(f => f.Count())));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Take -> Skip", b => getQuery(b)
                .Skip(5).Take(11).Select(f => f.Children.Count()).Take(7).Skip(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).Select(f => f.FamilyId).Take(7)));

            inputs.Add(new LinqTestInput(
                "Take -> Select -> Skip", b => getQuery(b)
                .Take(7).Select(f => f.FamilyId).Skip(3)));

            // ------------------------------
            // SelectMany + Skip & Take
            // ------------------------------

            inputs.Add(new LinqTestInput(
                "SelectMany -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Skip(7).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Skip -> Take -> SelectMany", b => getQuery(b)
                .SelectMany(f => f.Children).Skip(11).Take(3).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "Skip -> SelectMany -> Take -> Skip -> SelectMany", b => getQuery(b)
                .Skip(1).SelectMany(f => f.Children).Take(13).Skip(3).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> SelectMany -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).SelectMany(c => c.Pets).Skip(3).Take(4)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> SelectMany -> Skip -> SelectMany", b => getQuery(b)
                .Take(50).Skip(25).SelectMany(f => f.Children).Skip(10).SelectMany(c => c.Pets)));

            // ---------------------------
            // Where + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(3).Take(5)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 0).Skip(7).Take(11).Where(f => f.Tags.Count() > 2).Skip(1).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Where -> Skip", b => getQuery(b)
                .Skip(1).Take(25).Where(f => f.Int > 10).Skip(5)));

            inputs.Add(new LinqTestInput(
                "Take -> Where -> Skip", b => getQuery(b)
                .Take(25).Where(f => f.FamilyId.Contains("A")).Skip(10)));

            inputs.Add(new LinqTestInput(
                "Where -> Take -> Skip -> Where", b => getQuery(b)
                .Where(f => f.Children.Count() > 1).Take(10).Skip(3).Where(f => f.Int > 0)));

            // ---------------------------
            // OrderBy + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take -> OrderBy -> Take -> Skip", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(3).Take(11).OrderBy(f => f.FamilyId).Take(7).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> OrderBy", b => getQuery(b)
                .Skip(3).Take(43).OrderBy(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderByDescending -> Skip", b => getQuery(b)
                .Take(50).OrderByDescending(f => f.Int).Skip(13)));

            inputs.Add(new LinqTestInput(
                "Skip -> OrderByDescending -> Take", b => getQuery(b)
                .Skip(7).OrderByDescending(f => f.Int).Take(17)));

            // ---------------------------
            // Distinct + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "Distinct -> Skip -> Take", b => getQuery(b)
                .Distinct().Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Distinct", b => getQuery(b)
                .Skip(3).Take(11).Distinct()));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Distinct -> Skip -> Take -> Distinct -> Skip", b => getQuery(b)
                .Skip(10).Take(60).Select(f => f.Int).Distinct().Skip(15).Take(20).Distinct().Skip(7)));

            inputs.Add(new LinqTestInput(
                "Skip -> Distinct -> Skip -> Take", b => getQuery(b)
                .Skip(7).Distinct().Skip(20).Take(10)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Distinct -> Skip", b => getQuery(b)
                .Take(30).Skip(10).Distinct().Skip(7)));

            // ---------------------------------------------------------------------------------
            // Select, SelectMany, Where, OrderBy, Distinct with Skip & Take in between
            // ---------------------------------------------------------------------------------

            // Select, SelectMany

            inputs.Add(new LinqTestInput(
                "Select(new) -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, f.Children }).SelectMany(c => c.Children).Skip(3).Take(10)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Select(c => c.GivenName).Skip(7).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> SelectMany -> Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).Take(20).SelectMany(f => f.Children).Skip(3).Select(c => c.GivenName).Take(5)));

            inputs.Add(new LinqTestInput(
                "Skip -> SelectMany -> Take -> Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).SelectMany(f => f.Children).Take(10).Skip(1).Select(c => c.FamilyName).Take(7)));

            inputs.Add(new LinqTestInput(
                "Take -> SelectMany -> Skip -> Select -> Take", b => getQuery(b)
                .Take(30).SelectMany(f => f.Children).Skip(10).Select(c => c.Grade).Take(3)));

            // Select, Where

            inputs.Add(new LinqTestInput(
                "Select -> Where -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Children).Where(c => c.Count() > 0).Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Select -> Skip", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(7).Take(3).Select(f => f.FamilyId).Skip(2)));

            // Select, OrderBy

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> OrderBy", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(1).Take(2).OrderBy(s => s)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> Take -> Skip -> Select", b => getQuery(b)
                .OrderByDescending(f => f.Int).Take(10).Skip(3).Select(f => f.Int + 1)));

            // Select, Distinct

            inputs.Add(new LinqTestInput(
                "Take -> Select -> Distinct -> Skip -> Take", b => getQuery(b)
                .Take(7).Select(f => f.Int).Distinct().Skip(1).Take(5)));

            // SelectMany, Where

            inputs.Add(new LinqTestInput(
                "SelectMany -> Where -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Where(c => c.Grade > 100).Skip(10).Take(20)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> SelectMany -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(10).SelectMany(f => f.Children).Take(7)));

            // SelectMany, OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> SelectMany -> SelectMany", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(10).SelectMany(f => f.Children).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(10).Take(20)));

            // SelectMany, Distinct

            inputs.Add(new LinqTestInput(
                "SelectMany -> Distinct -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Distinct().Skip(7).Take(11)));

            inputs.Add(new LinqTestInput(
                "Distinct -> Skip -> SelectMany", b => getQuery(b)
                .Distinct().Skip(3).SelectMany(f => f.Children)));

            // Where, OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Where -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Where(f => f.IsRegistered).Skip(11).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Where -> Take -> OrderBy", b => getQuery(b)
                .Skip(20).Where(f => f.Children.Count() > 0).Take(10).OrderBy(f => f.Int)));

            // Where, Distinct

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Distinct", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(3).Take(17).Distinct()));

            inputs.Add(new LinqTestInput(
                "Skip -> Distinct -> Where -> Take", b => getQuery(b)
                .Skip(22).Distinct().Where(f => f.Parents.Count() > 0).Take(7)));

            // -----------------------------------------
            // All basic operations with Skip & Take
            // -----------------------------------------

            // Start with Select

            inputs.Add(new LinqTestInput(
                "Select -> Where -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Where(id => id.Count() > 10).OrderBy(id => id).Skip(1).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select -> Where -> OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Where(id => id.Count() > 10).OrderBy(id => id).Skip(1).Take(10)
                .Select(id => id + "_suffix").Where(id => id.Count() > 12).Skip(2).Take(4)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> OrderBy -> Skip -> Distinct -> Skip", b => getQuery(b)
                .Select(f => f.Records).Skip(5).OrderBy(r => r.Transactions.Count()).Skip(1).Distinct().Skip(3)));

            inputs.Add(new LinqTestInput(
                "Select(new(new(new(new(new))))) -> (Skip -> Select) x 6 -> Skip -> Where -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, L1 = new { L2 = new { L3 = new { L4 = new { f.Records } } } } })
                .Skip(1).Select(f => f.L1)
                .Skip(2).Select(f => f.L2)
                .Skip(3).Select(f => f.L3)
                .Skip(4).Select(f => f.L4)
                .Skip(5).Select(f => f.Records)
                .Skip(6).Select(f => f.Transactions)
                .Skip(7).Where(t => t.Count() > 100)
                .Take(20)));

            inputs.Add(new LinqTestInput(
                "Select -> (Skip -> Select -> Where -> OrderBy -> Distinct -> Take) x 3 -> Skip -> Take", b => getQuery(b)
                .Select(f => new { L1 = f })
                .Skip(1).Select(f => f.L1).Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Distinct().Take(100)
                .Skip(2).Select(f => new { L2 = f }).Where(f => f.L2.FamilyId.CompareTo("A") > 0).OrderBy(f => f.L2.Int).Distinct().Take(50)
                .Skip(3).Select(f => f.L2).Where(f => f.Children.Count() > 1).OrderBy(f => f.IsRegistered).Distinct().Take(40)
                .Skip(4).Take(25)));

            // Start with Distinct

            inputs.Add(new LinqTestInput(
                "Distinct -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Distinct().Select(f => f.Records).Where(r => r.Transactions.Count() > 2).Skip(1).Take(10)));

            // Start with Where

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Skip(1).Take(5)));

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Skip(1).Take(5)
                .Select(f => f.Records).Where(r => r.Transactions != null).Skip(1).Take(3)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 20).Skip(5).Take(20)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(5).Take(10)));

            // Start with OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(1).Take(10)
                .Select(f => f.Records).Where(r => r.Transactions.Count() > 10).Skip(2).Take(3)));

            // Start with Skip

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Skip(1).Take(10).Select(f => f.Children.Count()).Where(c => c > 1).Skip(1).Take(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Where -> Skip -> Take -> OrderBy -> Skip -> Take -> Select -> Skip -> Distinct -> Skip -> Take", b => getQuery(b)
                .Skip(2).Take(10).Where(f => f.Int > 10)
                .Skip(1).Take(9).OrderBy(f => f.FamilyId)
                .Skip(3).Take(5).Select(f => f.Children.Count())
                .Skip(1).Distinct()
                .Skip(1).Take(1)));

            // Start with Take

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Take(10).Skip(2).Where(f => f.IsRegistered).OrderBy(f => f.Int).Skip(1).Take(9)));

            inputs.Add(new LinqTestInput(
                "Take -> Distinct -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Take(10).Distinct().Select(f => f.Children).Where(c => c.Count() > 0).Skip(2).Take(5)));

            // -----------------------------------------------------------------------------
            // All basic operations with Skip & Take with SelectMany in the middle
            // -----------------------------------------------------------------------------

            // SelectMany after Take

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Records).Skip(1).Take(10)
                .SelectMany(r => r.Transactions).Skip(1).Take(9)));

            // SelectMany after Where

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(10).Take(20)));

            // Start with SelectMany

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children)
                    .Select(c => c.FamilyName).Skip(1).Take(20)
                    .Select(n => n.Count()).Where(l => l > 10).Skip(2).Take(50)));

            // -------------------------------------------------------------
            // Nested Skip & Take in Select, SelectMany, Where, OrderBy
            // -------------------------------------------------------------

            // Nested with Select

            inputs.Add(new LinqTestInput(
                "Select(new(Where -> Skip)) -> Where", b => getQuery(b)
                .Select(f => new {
                    id = f.FamilyId,
                    GoodChildren = f.Children.Where(c => c.Grade > 75).Skip(1)
                })
                .Where(f => f.GoodChildren.Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Select(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Children.Skip(1).Take(1)).Skip(3).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new(Skip -> Take, Skip, Take) -> Skip -> Take -> Where", b => getQuery(b)
                .Select(f => new {
                    v0 = f.Children.Skip(1).Take(2),
                    v1 = f.Parents.Skip(1),
                    v2 = f.Records.Transactions.Take(10)
                })
                .Skip(1).Take(20).Where(f => f.v0.Count() > 0).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new(SelectMany -> SelectMany -> Distinct, OrderByDescending -> Take -> SelectMany -> Skip, Select -> OrderBy -> Skip -> Take -> Sum) -> Where -> Skip -> Take -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => new {
                    v0 = f.Children.SelectMany(c => c.Pets.Skip(1).SelectMany(p => p.GivenName).Distinct()),
                    v1 = f.Children.OrderByDescending(c => c.Grade).Take(2).SelectMany(c => c.Pets.Select(p => p.GivenName).Skip(2)),
                    v2 = f.Records.Transactions.Select(t => t.Amount).OrderBy(a => a).Skip(10).Take(20).Sum()
                })
                .Where(f => f.v2 > 100).Skip(5).Take(20)
                .SelectMany(f => f.v1).Distinct().Skip(3).Take(22)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> SelectMany(Skip -> OrderBy)", b => getQuery(b)
                .Select(f => f.Records).Skip(1).SelectMany(r => r.Transactions.Skip(10).OrderBy(t => t.Date))));

            // Nested with Where

            inputs.Add(new LinqTestInput(
                "Where -> Where(Skip -> Take -> Count) - > Skip -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 2).Where(f => f.Children.Skip(1).Take(10).Count() > 1).Skip(1).Take(10)));

            // Nested with OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy(Skip -> Take -> Count) -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Children.Skip(1).Take(5).Count())));

            // Nested with SelectMany

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).Take(2)).Skip(3).Take(20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> Take) -> Skip -> Take -> SelectMany(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).Take(2)).Skip(3).Take(20)
                .SelectMany(c => c.Pets.Skip(1).Take(2)).Skip(1).Take(10)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> OrderBy -> Skip -> Distinct)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Grade > 10).OrderBy(c => c.Grade).Skip(1).Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> SelectMany(Skip -> Select) -> Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).SelectMany(c => c.Pets.Skip(1).Select(p => p.GivenName)).Take(10))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void TestUnsupportedScenarios()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------
            // Dictionary type
            // --------------------

            // Iterating through Dictionary type
            inputs.Add(new LinqTestInput("Iterating through Dictionary type", b => getQuery(b).Select(f => f.Children.Select(c => c.Things.Select(t => t.Key.Count() + t.Value.Count())))));

            // Get a count of a Dictionary type
            inputs.Add(new LinqTestInput("Getting Dictionary count", b => getQuery(b).Select(f => f.Children.Select(c => c.Things.Count()))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestOrderByTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Ascending
            inputs.Add(new LinqTestInput("Select -> order by", b => getQuery(b).Select(family => family.FamilyId).OrderBy(id => id)));
            inputs.Add(new LinqTestInput("Select -> order by -> Select", b => getQuery(b).Select(family => family.FamilyId).OrderBy(id => id).Select(x => x.Count())));
            inputs.Add(new LinqTestInput("Where -> OrderBy -> Select query",
                b => from f in getQuery(b)
                     where f.Int == 5 && f.NullableInt != null
                     orderby f.IsRegistered
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("Where -> OrderBy -> Select", b => getQuery(b).Where(f => f.Int == 5 && f.NullableInt != null).OrderBy(f => f.IsRegistered).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy query",
                b => from f in getQuery(b)
                     orderby f.FamilyId
                     select f));
            inputs.Add(new LinqTestInput("OrderBy", b => getQuery(b).OrderBy(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select query",
                b => from f in getQuery(b)
                     orderby f.FamilyId
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("OrderBy -> Select", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Take", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId).Take(10)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Select", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId).Select(x => x)));

            // Descending
            inputs.Add(new LinqTestInput("Select -> order by", b => getQuery(b).Select(family => family.FamilyId).OrderByDescending(id => id)));
            inputs.Add(new LinqTestInput("Select -> order by -> Select", b => getQuery(b).Select(family => family.FamilyId).OrderByDescending(id => id).Select(x => x.Count())));
            inputs.Add(new LinqTestInput("Where -> OrderBy Desc -> Select query",
                b => from f in getQuery(b)
                     where f.Int == 5 && f.NullableInt != null
                     orderby f.IsRegistered descending
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("Where -> OrderBy Desc -> Select", b => getQuery(b).Where(f => f.Int == 5 && f.NullableInt != null).OrderByDescending(f => f.IsRegistered).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy Desc query",
                b => from f in getQuery(b)
                     orderby f.FamilyId descending
                     select f));
            inputs.Add(new LinqTestInput("OrderBy Desc", b => getQuery(b).OrderByDescending(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy Desc -> Select query",
                b => from f in getQuery(b)
                     orderby f.FamilyId descending
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("OrderBy Desc -> Select", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Take", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId).Take(10)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Select", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId).Select(x => x)));
            inputs.Add(new LinqTestInput("OrderBy multiple expressions",
                b => from f in getQuery(b)
                     orderby f.FamilyId, f.Int
                     select f.FamilyId));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestThenByTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Ascending and descending

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenByDescending", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .ThenBy(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> ThenByDescending", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .ThenByDescending(f => f.Int)));

            // Subquery in OrderBy or in ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy subquery -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy subquery -> ThenBy subquery", b => getQuery(b)
                .OrderByDescending(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            // OrderBy and ThenBy by the same property (not a realistic scenario)

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.FamilyId)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenByDescending", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.FamilyId)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending subquery -> ThenBy subquery", b => getQuery(b)
                .OrderByDescending(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Children.Where(c => c.Grade > 100).Count())));

            // OrderBy and ThenBy with epxressions

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.Int * 2)
                .ThenBy(f => f.FamilyId.Substring(2, 3))));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => !f.NullableInt.IsDefined())
                .ThenByDescending(f => f.Tags.Count() % 2)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.IsRegistered ? f.FamilyId : f.Int.ToString())
                .ThenBy(f => f.Records.Transactions.Max(t => t.Amount) % 1000)));

            // Multiple OrderBy and ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> OrderBy -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .OrderBy(f => f.Int)
                .ThenByDescending(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.Int)
                .ThenByDescending(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Orderby subquery -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .OrderBy(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy subquery -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())
                .ThenBy(f => f.Children.Where(c => c.Grade > 100).Count())));

            // Nested ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy(OrderBy -> ThenBy -> Select)", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> ThenBy) -> ThenBy(OrderBy -> ThenBy)", b => getQuery(b)
                .OrderBy(f => f.Children
                    .OrderBy(c => c.Grade)
                    .ThenBy(c => c.Pets.Count))
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            // Nested expressions with ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy(OrderBy -> ThenBy -> Take -> Select)", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Take(1)
                    .Select(p => p.FamilyName + p.GivenName))));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> ThenBy -> Take -> OrderBy -> ThenBy) -> ThenBy(OrderBy -> ThenBy)", b => getQuery(b)
                .OrderBy(f => f.Children
                    .OrderBy(c => c.Grade)
                    .ThenByDescending(c => c.Pets.Count)
                    .Take(10)
                    .OrderByDescending(c => c.GivenName)
                    .ThenBy(c => c.Gender))
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            // On a new object

            inputs.Add(new LinqTestInput(
                "Select -> OrderBy -> ThenBy", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    ChildrenPetCount = f.Children.Select(c => c.Pets.Count()).Sum()
                })
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> ThenBy", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    Name = c.GivenName,
                    SpecialPetCount = c.Pets.Where(p => p.GivenName.Length > 5).Count()
                })
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber))));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> ThenBy", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    Name = c.GivenName,
                    SpecialPetCount = c.Pets.Where(p => p.GivenName.Length > 5).Count()
                }))
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber)
                .Select(r => r.FamilyId)));

            inputs.Add(new LinqTestInput(
                "Select(new(Where, Sum) -> OrderBy(Count) -> ThenBy)", b => getQuery(b)
                .Select(f => new {
                    ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 0),
                    TotalExpenses = f.Records.Transactions.Sum(t => t.Amount)
                })
                .OrderByDescending(r => r.ChildrenWithPets.Count())
                .ThenByDescending(r => r.TotalExpenses)));

            inputs.Add(new LinqTestInput(
                "Select(new(Min, Count, SelectMany->Select->Distinct->Count)) -> OrderByDescending -> ThenBy", b => getQuery(b)
                .Select(f => new {
                    ParentGivenName = f.Parents.Min(p => p.GivenName),
                    ParentCount = f.Parents.Count(),
                    GoodChildrenCount = f.Children.Where(c => c.Grade > 95).Count(),
                    UniquePetsNameCount = f.Children.SelectMany(c => c.Pets).Select(p => p.GivenName).Distinct().Count()
                })
                .OrderByDescending(r => r.GoodChildrenCount)
                .ThenBy(r => r.UniquePetsNameCount)));

            // With other LINQ operators: Where, SelectMany, Distinct, Skip, Take, and aggregates

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> ThenBy", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children)
                .OrderBy(c => c.Grade)
                .ThenByDescending(c => c.Pets.Count())
                .Take(3)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Skip -> Take -> Where -> Select -> Distinct", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children)
                .OrderByDescending(c => c.Grade)
                .ThenBy(c => c.GivenName)
                .Skip(2)
                .Take(20)
                .Where(c => c.Pets.Where(p => p.GivenName.Length > 10).Count() > 0)
                .Select(c => c.GivenName)
                .Distinct()));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Select => Distinct => Take => OrderBy", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children)
                .OrderBy(c => c.Grade)
                .ThenByDescending(c => c.Pets.Count())
                .Select(c => c.GivenName)
                .Distinct()
                .Take(10)
                .Skip(5)
                .OrderBy(n => n.Length)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Records.Transactions)
                .OrderBy(t => t.Type)
                .ThenBy(t => t.Amount)
                .Take(100)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderBy -> ThenBy", b => getQuery(b)
                .Take(100)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderBy -> ThenBy -> Skip", b => getQuery(b)
                .Take(100)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)
                .Skip(5)));

            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy -> ThenBy", b => getQuery(b)
                .Distinct()
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany(Select(new Where->Count)) -> Distinct -> OrderBy -> ThenBy", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children.Select(c => new {
                    Name = c.GivenName,
                    PetWithLongNames = c.Pets.Where(p => p.GivenName.Length > 8).Count()
                }))
                .Distinct()
                .OrderByDescending(r => r.Name)
                .ThenBy(r => r.PetWithLongNames)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Any) -> ThenBy(Any)", b => getQuery(b)
                .OrderBy(f => f.Children.Any(c => c.Grade > 90))
                .ThenByDescending(f => f.Parents.Any(p => p.GivenName.Length > 10))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Min) -> ThenBy(Max) -> ThenBy(Sum) -> ThenBy(Avg)", b => getQuery(b)
                .OrderBy(f => f.Children.Min(c => c.GivenName))
                .ThenByDescending(f => f.Parents.Max(p => p.GivenName))
                .ThenBy(f => f.Records.Transactions.Sum(t => t.Amount))
                .ThenByDescending(f => f.Records.Transactions.Average(t => t.Amount))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void TestDistinctSelectManyIssues()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // these tests need a fix in the ServiceInterop
            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy -> Take",
                b => getQuery(b).Select(f => f.Int).Distinct().OrderBy(x => x).Take(10)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Distinct -> Take",
                b => getQuery(b).Select(f => f.Int).OrderBy(x => x).Distinct().Take(10)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestDistinctTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Simple distinct
            // Select -> Distinct for all data types
            inputs.Add(new LinqTestInput(
                "Distinct string",
                b => getQuery(b).Select(f => f.FamilyId).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct int",
                b => getQuery(b).Select(f => f.Int).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct bool",
                b => getQuery(b).Select(f => f.IsRegistered).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct nullable int",
                b => getQuery(b).Where(f => f.NullableInt != null).Select(f => f.NullableInt).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct null",
                b => getQuery(b).Where(f => f.NullObject != null).Select(f => f.NullObject).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct children",
                b => getQuery(b).SelectMany(f => f.Children).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct parent",
                b => getQuery(b).SelectMany(f => f.Parents).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct family",
                b => getQuery(b).Distinct()));

            inputs.Add(new LinqTestInput(
                "Multiple distincts",
                b => getQuery(b).Distinct().Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct new obj",
                b => getQuery(b).Select(f => new { Parents = f.Parents.Count(), Children = f.Children.Count() }).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct new obj",
                b => getQuery(b).Select(f => new { Parents = f.Parents.Count(), Children = f.Children.Count() }).Select(f => f.Parents).Distinct()));

            // Distinct + Take
            inputs.Add(new LinqTestInput(
                "Distinct -> Take",
                b => getQuery(b).Select(f => f.Int).Distinct().Take(10)));

            inputs.Add(new LinqTestInput(
                "Take -> Distinct",
                b => getQuery(b).Select(f => f.Int).Take(10).Distinct()));

            // Distinct + Order By
            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy",
                b => getQuery(b).Select(f => f.Int).Distinct().OrderBy(x => x)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Distinct",
                b => getQuery(b).OrderBy(f => f.Int).Distinct()));

            // Distinct + Order By + Take
            inputs.Add(new LinqTestInput(
                "Distinct -> Take -> OrderBy",
                b => getQuery(b).Select(f => f.Int).Distinct().Take(10).OrderBy(x => x)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Take -> Distinct",
                b => getQuery(b).Select(f => f.Int).OrderBy(x => x).Take(10).Distinct()));

            // Distinct + Where
            inputs.Add(new LinqTestInput(
                "Where -> Distinct",
                b => getQuery(b).Select(f => f.Int).Where(x => x > 10).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct -> Where",
                b => getQuery(b).Select(f => f.Int).Distinct().Where(x => x > 10)));

            // SelectMany w Distinct
            inputs.Add(new LinqTestInput(
                "SelectMany(Select obj) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select)) -> Distinct",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select -> Distinct))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)
                    .Distinct()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select -> Select) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet.GivenName)
                        .Select(name => name.Count())))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {} -> Select) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        }).Select(p => p.child))
                    .Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {}) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {} -> Distinct))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })
                        .Distinct()))));

            // SelectMany(Distinct)
            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20).Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct().Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct().OrderBy(f => f.GivenName.Length)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct().OrderBy(f => f.GivenName.Length).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .Where(f => f.FamilyName.Count() < 20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).OrderBy(f => f.FamilyName)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).OrderBy(f => f.FamilyName).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Select",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Select(f => f.FamilyName.Count())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Select -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Select(f => f.FamilyName.Count()).Take(5)));

            // SelectMany(Select -> Distinct)
            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).OrderBy(n => n).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Where -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Where(n => n.Count() > 10).OrderBy(n => n).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName)).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Where(n => n.Count() > 10)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void ValidateDynamicLinq()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Select", b => getQuery(b).Select("FamilyId")));
            inputs.Add(new LinqTestInput("Where", b => getQuery(b).Where("FamilyId = \"some id\"")));
            inputs.Add(new LinqTestInput("Where longer", b => getQuery(b).Where("FamilyId = \"some id\" AND IsRegistered = True OR Int > 101")));
            // with parameters
            inputs.Add(new LinqTestInput("Where w/ parameters", b => getQuery(b).Where("FamilyId = @0 AND IsRegistered = @1 OR Int > @2", "some id", true, 101)));
            inputs.Add(new LinqTestInput("Where -> Select", b => getQuery(b).Where("FamilyId = \"some id\"").Select("Int")));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public async Task ValidateLinqQueries()
        {
            Container container = await testDb.CreateContainerAsync(new ContainerProperties (id : Guid.NewGuid().ToString("N"), partitionKeyPath : "/id" ));

            Parent mother = new Parent { FamilyName = "Wakefield", GivenName = "Robin" };
            Parent father = new Parent { FamilyName = "Miller", GivenName = "Ben" };
            Pet pet = new Pet { GivenName = "Fluffy" };
            Child child = new Child
            {
                FamilyName = "Merriam",
                GivenName = "Jesse",
                Gender = "female",
                Grade = 1,
                Pets = new List<Pet>() { pet, new Pet() { GivenName = "koko" } },
                Things = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } },
            };

            Address address = new Address { State = "NY", County = "Manhattan", City = "NY" };
            Family family = new Family { FamilyId = "WakefieldFamily", Parents = new Parent[] { mother, father }, Children = new Child[] { child }, IsRegistered = false, Int = 3, NullableInt = 5 , Id = "WakefieldFamily"};

            List<Family> fList = new List<Family>();
            fList.Add(family);

            container.CreateItemAsync<Family>(family).Wait();
            IOrderedQueryable<Family> query = container.GetItemLinqQueryable<Family>(allowSynchronousQueryExecution : true);

            IEnumerable<string> q1 = query.Select(f => f.Parents[0].FamilyName);
            Assert.AreEqual(q1.FirstOrDefault(), family.Parents[0].FamilyName);

            IEnumerable<int> q2 = query.Select(f => f.Children[0].Grade + 13);
            Assert.AreEqual(q2.FirstOrDefault(), family.Children[0].Grade + 13);

            IEnumerable<Family> q3 = query.Where(f => f.Children[0].Pets[0].GivenName == "Fluffy");
            Assert.AreEqual(q3.FirstOrDefault().FamilyId, family.FamilyId);

            IEnumerable<Family> q4 = query.Where(f => f.Children[0].Things["A"] == "B");
            Assert.AreEqual(q4.FirstOrDefault().FamilyId, family.FamilyId);

            for (int index = 0; index < 2; index++)
            {
                IEnumerable<Pet> q5 = query.Where(f => f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[index]);
                Assert.AreEqual(q5.FirstOrDefault().GivenName, family.Children[0].Pets[index].GivenName);
            }

            IEnumerable<dynamic> q6 = query.SelectMany(f => f.Children.Select(c => new { Id = f.FamilyId }));
            Assert.AreEqual(q6.FirstOrDefault().Id, family.FamilyId);

            string nullString = null;
            IEnumerable<Family> q7 = query.Where(f => nullString == f.FamilyId);
            Assert.IsNull(q7.FirstOrDefault());

            object nullObject = null;
            q7 = query.Where(f => f.NullObject == nullObject);
            Assert.AreEqual(q7.FirstOrDefault().FamilyId, family.FamilyId);

            q7 = query.Where(f => f.FamilyId == nullString);
            Assert.IsNull(q7.FirstOrDefault());

            IEnumerable<Family> q8 = query.Where(f => null == f.FamilyId);
            Assert.IsNull(q8.FirstOrDefault());

            IEnumerable<Family> q9 = query.Where(f => f.IsRegistered == false);
            Assert.AreEqual(q9.FirstOrDefault().FamilyId, family.FamilyId);

            dynamic q10 = query.Where(f => f.FamilyId.Equals("WakefieldFamily")).AsEnumerable().FirstOrDefault();
            Assert.AreEqual(q10.FamilyId, family.FamilyId);

            GuidClass guidObject = new GuidClass() { Id = new Guid("098aa945-7ed8-4c50-b7b8-bd99eddb54bc") };
            container.CreateItemAsync(guidObject).Wait();
            List<GuidClass> guidData = new List<GuidClass>() { guidObject };

            IOrderedQueryable<GuidClass> guid = container.GetItemLinqQueryable<GuidClass>(allowSynchronousQueryExecution: true);

            IQueryable<GuidClass> q11 = guid.Where(g => g.Id == guidObject.Id);
            Assert.AreEqual(((IEnumerable<GuidClass>)q11).FirstOrDefault().Id, guidObject.Id);

            IQueryable<GuidClass> q12 = guid.Where(g => g.Id.ToString() == guidObject.Id.ToString());
            Assert.AreEqual(((IEnumerable<GuidClass>)q12).FirstOrDefault().Id, guidObject.Id);

            ListArrayClass arrayObject = new ListArrayClass() { Id = "arrayObject", ArrayField = new int[] { 1, 2, 3 } };
            container.CreateItemAsync(arrayObject).Wait();

            IOrderedQueryable<ListArrayClass> listArrayQuery = container.GetItemLinqQueryable<ListArrayClass>(allowSynchronousQueryExecution : true);

            IEnumerable<dynamic> q13 = listArrayQuery.Where(a => a.ArrayField == arrayObject.ArrayField);
            Assert.AreEqual(q13.FirstOrDefault().Id, arrayObject.Id);

            int[] nullArray = null;
            q13 = listArrayQuery.Where(a => a.ArrayField == nullArray);
            Assert.IsNull(q13.FirstOrDefault());

            ListArrayClass listObject = new ListArrayClass() { Id = "listObject", ListField = new List<int> { 1, 2, 3 } };
            container.CreateItemAsync(listObject).Wait();
            List<ListArrayClass> listArrayObjectData = new List<ListArrayClass>() { arrayObject, listObject };

            IEnumerable<dynamic> q14 = listArrayQuery.Where(a => a.ListField == listObject.ListField);
            Assert.AreEqual(q14.FirstOrDefault().Id, listObject.Id);

            IEnumerable<dynamic> q15 = query.Where(f => f.NullableInt == null);
            Assert.AreEqual(q15.ToList().Count, 0);

            int? nullInt = null;
            q15 = query.Where(f => f.NullableInt == nullInt);
            Assert.AreEqual(q15.ToList().Count, 0);

            q15 = query.Where(f => f.NullableInt == 5);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = 5;
            q15 = query.Where(f => f.NullableInt == nullInt);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            q15 = query.Where(f => f.NullableInt == nullInt.Value);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = 3;
            q15 = query.Where(f => f.Int == nullInt);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            q15 = query.Where(f => f.Int == nullInt.Value);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = null;
            q15 = query.Where(f => f.Int == nullInt);
            Assert.AreEqual(q15.ToList().Count, 0);

            List<Family> v = fList.Where(f => f.Int > nullInt).ToList();

            q15 = query.Where(f => f.Int < nullInt);

            string doc1Id = "document1:x:'!@TT){}\"";
            Document doubleQoutesDocument = new Document() { Id = doc1Id };
            container.CreateItemAsync(doubleQoutesDocument).Wait();

            IQueryable<Document> docQuery = from book in container.GetItemLinqQueryable<Document>(allowSynchronousQueryExecution : true)
                           where book.Id == doc1Id
                           select book;

            Assert.AreEqual(docQuery.AsEnumerable().Single().Id, doc1Id);

            GreatFamily greatFamily = new GreatFamily() { Family = family };
            GreatGreatFamily greatGreatFamily = new GreatGreatFamily() { GreatFamilyId = Guid.NewGuid().ToString(), GreatFamily = greatFamily };
            container.CreateItemAsync(greatGreatFamily).Wait();
            List<GreatGreatFamily> greatGreatFamilyData = new List<GreatGreatFamily>() { greatGreatFamily };

            IOrderedQueryable<GreatGreatFamily> queryable = container.GetItemLinqQueryable<GreatGreatFamily>(allowSynchronousQueryExecution : true);

            IEnumerable<GreatGreatFamily> q16 = queryable.SelectMany(gf => gf.GreatFamily.Family.Children.Where(c => c.GivenName == "Jesse").Select(c => gf));

            Assert.AreEqual(q16.FirstOrDefault().GreatFamilyId, greatGreatFamily.GreatFamilyId);

            Sport sport = new Sport() { SportName = "Tennis", SportType = "Racquet" };
            container.CreateItemAsync(sport).Wait();
            List<Sport> sportData = new List<Sport>() { sport };

            IOrderedQueryable<Sport> sportQuery = container.GetItemLinqQueryable<Sport>(allowSynchronousQueryExecution : true);

            IEnumerable<Sport> q17 = sportQuery.Where(s => s.SportName == "Tennis");

            Assert.AreEqual(sport.SportName, q17.FirstOrDefault().SportName);

            Sport2 sport2 = new Sport2() { id = "json" };
            container.CreateItemAsync(sport2).Wait();
            List<Sport2> sport2Data = new List<Sport2>() { sport2 };

            IOrderedQueryable<Sport2> sport2Query = container.GetItemLinqQueryable<Sport2>(allowSynchronousQueryExecution: true);

            Func<bool, IQueryable<GuidClass>> getGuidQuery = useQuery => useQuery ? guid : guidData.AsQueryable();
            Func<bool, IQueryable<ListArrayClass>> getListArrayQuery = useQuery => useQuery ? listArrayQuery : listArrayObjectData.AsQueryable();
            Func<bool, IQueryable<GreatGreatFamily>> getGreatFamilyQuery = useQuery => useQuery ? queryable : greatGreatFamilyData.AsQueryable();
            Func<bool, IQueryable<Sport>> getSportQuery = useQuery => useQuery ? sportQuery : sportData.AsQueryable();
            Func<bool, IQueryable<Sport2>> getSport2Query = useQuery => useQuery ? sport2Query : sport2Data.AsQueryable();

            int? nullIntVal = null;
            int? nullableIntVal = 5;

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Select 1st parent family name", b => getQuery(b).Where(f => f.Parents.Count() > 0).Select(f => f.Parents[0].FamilyName)));
            inputs.Add(new LinqTestInput("Select 1st children grade expr", b => getQuery(b).Where(f => f.Children.Count() > 0).Select(f => f.Children[0].Grade + 13)));
            inputs.Add(new LinqTestInput("Filter 1st children's 1st pet name", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 0 && f.Children[0].Pets[0].GivenName == "Fluffy")));
            inputs.Add(new LinqTestInput("Filter 1st children's thing A value", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Things["A"] == "B")));
            inputs.Add(new LinqTestInput("Filter 1st children's gender -> Select his 1st pet", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 0 && f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[0])));
            inputs.Add(new LinqTestInput("Filter 1st children's gender -> Select his 2nd pet", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 1 && f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[1])));
            inputs.Add(new LinqTestInput("Select FamilyId of all children", b => getQuery(b).SelectMany(f => f.Children.Select(c => new { Id = f.FamilyId }))));
            inputs.Add(new LinqTestInput("Filter family with null Id", b => getQuery(b).Where(f => (string)null == f.FamilyId)));
            inputs.Add(new LinqTestInput("Filter family with null Id #2", b => getQuery(b).Where(f => f.FamilyId == (string)null)));
            inputs.Add(new LinqTestInput("Filter family with null object", b => getQuery(b).Where(f => f.NullObject == (object)null)));
            inputs.Add(new LinqTestInput("Filter family with null Id #3", b => getQuery(b).Where(f => null == f.FamilyId)));
            inputs.Add(new LinqTestInput("Filter registered family", b => getQuery(b).Where(f => f.IsRegistered == false)));
            inputs.Add(new LinqTestInput("Filter family by FamilyId", b => getQuery(b).Where(f => f.FamilyId.Equals("WakefieldFamily"))));
            inputs.Add(new LinqTestInput("Filter family nullable int", b => getQuery(b).Where(f => f.NullableInt == null)));
            inputs.Add(new LinqTestInput("Filter family nullable int #2", b => getQuery(b).Where(f => f.NullableInt == nullIntVal)));
            inputs.Add(new LinqTestInput("Filter family nullable int =", b => getQuery(b).Where(f => f.NullableInt == 5)));
            inputs.Add(new LinqTestInput("Filter nullableInt = nullInt", b => getQuery(b).Where(f => f.NullableInt == nullableIntVal)));
            inputs.Add(new LinqTestInput("Filter nullableInt = nullInt value", b => getQuery(b).Where(f => f.NullableInt == nullableIntVal.Value)));
            inputs.Add(new LinqTestInput("Filter int = nullInt", b => getQuery(b).Where(f => f.Int == nullableIntVal)));
            inputs.Add(new LinqTestInput("Filter int = nullInt value", b => getQuery(b).Where(f => f.Int == nullableIntVal.Value)));
            inputs.Add(new LinqTestInput("Filter int = nullInt", b => getQuery(b).Where(f => f.Int == nullIntVal)));
            inputs.Add(new LinqTestInput("Filter int < nullInt", b => getQuery(b).Where(f => f.Int < nullIntVal)));

            inputs.Add(new LinqTestInput("Guid filter by Id", b => getGuidQuery(b).Where(g => g.Id == guidObject.Id)));
            inputs.Add(new LinqTestInput("Guid filter by Id #2", b => getGuidQuery(b).Where(g => g.Id.ToString() == guidObject.Id.ToString())));
            inputs.Add(new LinqTestInput("Array compare", b => getListArrayQuery(b).Where(a => a.ArrayField == arrayObject.ArrayField)));
            inputs.Add(new LinqTestInput("Array compare null", b => getListArrayQuery(b).Where(a => a.ArrayField == nullArray)));
            inputs.Add(new LinqTestInput("List compare", b => getListArrayQuery(b).Where(a => a.ListField == listObject.ListField)));

            inputs.Add(new LinqTestInput("Nested great family query filter children name", b => getGreatFamilyQuery(b).SelectMany(gf => gf.GreatFamily.Family.Children.Where(c => c.GivenName == "Jesse").Select(c => gf))));
            inputs.Add(new LinqTestInput("Sport filter sport name", b => getSportQuery(b).Where(s => s.SportName == "Tennis")));
            inputs.Add(new LinqTestInput("Sport filter sport type", b => getSportQuery(b).Where(s => s.SportType == "Racquet")));
            inputs.Add(new LinqTestInput("Sport2 filter by id", b => getSport2Query(b).Where(s => s.id == "json")));
            this.ExecuteTestSuite(inputs);
        }

        internal static TValue CreateExecuteAndDeleteProcedure<TValue>(DocumentClient client,
            DocumentCollection collection,
            string transientProcedure,
            out StoredProcedureResponse<TValue> response)
        {
            // create
            StoredProcedure storedProcedure = new StoredProcedure
            {
                Id = "storedProcedure" + Guid.NewGuid().ToString(),
                Body = transientProcedure
            };
            StoredProcedure retrievedStoredProcedure = client.CreateStoredProcedureAsync(collection, storedProcedure).Result;

            // execute
            response = client.ExecuteStoredProcedureAsync<TValue>(retrievedStoredProcedure).Result;

            // delete
            client.Delete<StoredProcedure>(retrievedStoredProcedure.GetIdOrFullName());

            return response.Response;
        }

        [TestMethod]
        public void ValidateBasicQuery()
        {
            this.ValidateBasicQueryAsync().Wait();
        }

        private async Task ValidateBasicQueryAsync()
        {
            DocumentClient client = TestCommon.CreateClient(true);
            Documents.Database database = await client.ReadDatabaseAsync(string.Format("dbs/{0}", testDb.Id));

            string databaseName = database.Id;

            List<Database> queryResults = new List<Database>();
            //Simple Equality
            IQueryable<Documents.Database> dbQuery = from db in client.CreateDatabaseQuery()
                                           where db.Id == databaseName
                                           select db;
            IDocumentQuery<Documents.Database> documentQuery = dbQuery.AsDocumentQuery();

            while (documentQuery.HasMoreResults)
            {
                DocumentFeedResponse<Database> pagedResponse = await documentQuery.ExecuteNextAsync<Database>();
                Assert.IsNotNull(pagedResponse.ResponseHeaders, "ResponseHeaders is null");
                Assert.IsNotNull(pagedResponse.ActivityId, "Query ActivityId is null");
                queryResults.AddRange(pagedResponse);
            }

            Assert.AreEqual(1, queryResults.Count);
            Assert.AreEqual(databaseName, queryResults[0].Id);

            //Logical Or 
            dbQuery = from db in client.CreateDatabaseQuery()
                      where db.Id == databaseName || db.ResourceId == database.ResourceId
                      select db;
            documentQuery = dbQuery.AsDocumentQuery();

            while (documentQuery.HasMoreResults)
            {
                queryResults.AddRange(await documentQuery.ExecuteNextAsync<Database>());
            }

            Assert.AreEqual(2, queryResults.Count);
            Assert.AreEqual(databaseName, queryResults[0].Id);

            //Select Property
            IQueryable<string> idQuery = from db in client.CreateDatabaseQuery()
                                         where db.Id == databaseName
                                         select db.ResourceId;
            IDocumentQuery<string> documentIdQuery = idQuery.AsDocumentQuery();

            List<string> idResults = new List<string>();
            while (documentIdQuery.HasMoreResults)
            {
                idResults.AddRange(await documentIdQuery.ExecuteNextAsync<string>());
            }

            Assert.AreEqual(1, idResults.Count);
            Assert.AreEqual(database.ResourceId, idResults[0]);
        }

        [TestMethod]
        public async Task ValidateTransformQuery()
        {
            PartitionKeyDefinition partitionKeyDefinition = new PartitionKeyDefinition { Paths = new System.Collections.ObjectModel.Collection<string>(new[] { "/id" }), Kind = PartitionKind.Hash };
            DocumentCollection collection = new DocumentCollection
            {
                Id = Guid.NewGuid().ToString("N"),
                PartitionKey = partitionKeyDefinition
            };
            collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
            Database database = await cosmosClient.DocumentClient.ReadDatabaseAsync(string.Format("dbs/{0}", testDb.Id));
            collection = cosmosClient.DocumentClient.Create<DocumentCollection>(database.ResourceId, collection);
            int documentsToCreate = 100;
            for (int i = 0; i < documentsToCreate; i++)
            {
                dynamic myDocument = new Document();
                myDocument.Id = "doc" + i;
                myDocument.Title = "MyBook"; //Simple Property.
                myDocument.Languages = new Language[] { new Language { Name = "English", Copyright = "London Publication" }, new Language { Name = "French", Copyright = "Paris Publication" } }; //Array Property
                myDocument.Author = new Author { Name = "Don", Location = "France" }; //Complex Property
                myDocument.Price = 9.99;
                myDocument = await cosmosClient.DocumentClient.CreateDocumentAsync(collection.DocumentsLink, myDocument);
            }

            //Read response as dynamic.
            IQueryable<dynamic> docQuery = cosmosClient.DocumentClient.CreateDocumentQuery(collection.DocumentsLink, @"select * from root r where r.Title=""MyBook""", new FeedOptions { EnableCrossPartitionQuery = true });

            IDocumentQuery<dynamic> DocumentQuery = docQuery.AsDocumentQuery();
            DocumentFeedResponse<dynamic> queryResponse = await DocumentQuery.ExecuteNextAsync();

            Assert.IsNotNull(queryResponse.ResponseHeaders, "ResponseHeaders is null");
            Assert.IsNotNull(queryResponse.ActivityId, "ActivityId is null");
            Assert.AreEqual(documentsToCreate, queryResponse.Count);

            foreach (dynamic myBook in queryResponse)
            {
                Assert.AreEqual(myBook.Title.ToString(), "MyBook");
            }

            cosmosClient.DocumentClient.DeleteDocumentCollectionAsync(collection.SelfLink).Wait();
        }

        [TestMethod]
        public void ValidateDynamicDocumentQuery() //Ensure query on custom property of document.
        {
            Book myDocument = new Book();
            myDocument.Id = Guid.NewGuid().ToString();
            myDocument.Title = "My Book"; //Simple Property.
            myDocument.Languages = new Language[] { new Language { Name = "English", Copyright = "London Publication" }, new Language { Name = "French", Copyright = "Paris Publication" } }; //Array Property
            myDocument.Author = new Author { Name = "Don", Location = "France" }; //Complex Property
            myDocument.Price = 9.99;
            myDocument.Editions = new List<Edition>() { new Edition() { Name = "First", Year = 2001 }, new Edition() { Name = "Second", Year = 2005 } };

            //Create second document to make sure we have atleast one document which are filtered out of query.
            Book secondDocument = new Book
            {
                Id = Guid.NewGuid().ToString(),
                Title = "My Second Book",
                Languages = new Language[] { new Language { Name = "Spanish", Copyright = "Mexico Publication" } },
                Author = new Author { Name = "Carlos", Location = "Cancun" },
                Price = 25,
                Editions = new List<Edition>() { new Edition() { Name = "First", Year = 1970 } }
            };

            //Unfiltered execution.
            IOrderedQueryable<Book> bookDocQuery = testContainer.GetItemLinqQueryable<Book>(allowSynchronousQueryExecution : true);
            Func<bool, IQueryable<Book>> getBookQuery = useQuery => useQuery ? bookDocQuery : new List<Book>().AsQueryable();

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Simple Equality on custom property",
                b => from book in getBookQuery(b)
                      where book.Title == "My Book"
                      select book));
            inputs.Add(new LinqTestInput("Nested Property access",
                b => from book in getBookQuery(b)
                      where book.Author.Name == "Don"
                      select book));
            inputs.Add(new LinqTestInput("Array references & Project Author out..",
                b => from book in getBookQuery(b)
                      where book.Languages[0].Name == "English"
                      select book.Author));
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book => book.Languages).Where(lang => lang.Name == "French").Select(lang => lang.Copyright)));
            inputs.Add(new LinqTestInput("NumericRange query",
                b => from book in getBookQuery(b)
                      where book.Price < 10
                      select book.Author));
            inputs.Add(new LinqTestInput("Or query",
                b => from book in getBookQuery(b)
                      where book.Title == "My Book" || book.Author.Name == "Don"
                      select book));
            inputs.Add(new LinqTestInput("SelectMany query on a List type.",
                b => getBookQuery(b).SelectMany(book => book.Editions).Select(ed => ed.Name)));
            // Below samples are strictly speaking not Any equivalent. But they join and filter "all"
            // subchildren which match predicate. When SQL BE supports ANY, we can replace these with Any Flavor.
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book =>
                           book.Languages
                           .Where(lng => lng.Name == "English")
                           .Select(lng => book.Author))));
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book =>
                               book.Editions
                               .Where(edition => edition.Year == 2001)
                               .Select(lng => book.Author))));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void ValidateDynamicAttachmentQuery() //Ensure query on custom property of attachment.
        {
            IOrderedQueryable<SpecialAttachment2> attachmentQuery = testContainer.GetItemLinqQueryable<SpecialAttachment2>(allowSynchronousQueryExecution : true);
            Document myDocument = new Document();
            Func<bool, IQueryable<SpecialAttachment2>> getAttachmentQuery = useQuery => useQuery ? attachmentQuery : new List<SpecialAttachment2>().AsQueryable();

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Filter equality on custom property",
                b => from attachment in getAttachmentQuery(b)
                     where attachment.Title == "My Book Title2"
                     select attachment));
            inputs.Add(new LinqTestInput("Filter equality on custom property #2",
                b => from attachment in getAttachmentQuery(b)
                     where attachment.Title == "My Book Title"
                     select attachment));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestLinqTypeSystem()
        {
            Assert.AreEqual(null, TypeSystem.GetElementType(typeof(Book)));
            Assert.AreEqual(null, TypeSystem.GetElementType(typeof(Author)));

            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(Language[])));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(List<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(IList<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(IEnumerable<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(ICollection<Language>)));

            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(DerivedFooItem[])));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(List<FooItem>)));
            Assert.AreEqual(typeof(string), TypeSystem.GetElementType(typeof(MyList<string>)));
            Assert.AreEqual(typeof(Tuple<string, string>), TypeSystem.GetElementType(typeof(MyTupleList<string>)));

            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(DerivedFooCollection)));
            Assert.AreEqual(typeof(string), TypeSystem.GetElementType(typeof(FooStringCollection)));

            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<object>)));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<IFooItem>)));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<FooItem>)));
            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(FooTCollection<DerivedFooItem>)));
        }

        #region DataDocument type tests

        public class BaseDocument
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Id { get; set; }
            public string TypeName { get; set; }
        }

        public class DataDocument : BaseDocument
        {
            public int Number { get; set; }
        }

        private class QueryHelper
        {
            private readonly Container container;

            public QueryHelper(Container container)
            {
                this.container = container;
            }

            public IQueryable<T> Query<T>() where T : BaseDocument
            {
                IQueryable<T> query = this.container.GetItemLinqQueryable<T>(allowSynchronousQueryExecution : true)
                                       .Where(d => d.TypeName == "Hello");
                string queryString = query.ToString();
                return query;
            }
        }

        [TestMethod]
        public async Task ValidateLinqOnDataDocumentType()
        {
            Container container = await testDb.CreateContainerAsync(new ContainerProperties(id : nameof(ValidateLinqOnDataDocumentType), partitionKeyPath : "/id"));

            DataDocument doc = new DataDocument() { Id = Guid.NewGuid().ToString("N"), Number = 0, TypeName = "Hello" };
            container.CreateItemAsync(doc).Wait();

            QueryHelper queryHelper = new QueryHelper(container);
            IEnumerable<BaseDocument> result = queryHelper.Query<BaseDocument>();
            Assert.AreEqual(1, result.Count());

            BaseDocument baseDocument = result.FirstOrDefault<BaseDocument>();
            Assert.AreEqual(doc.Id, baseDocument.Id);

            BaseDocument iDocument = doc;
            IOrderedQueryable<DataDocument> q = container.GetItemLinqQueryable<DataDocument>(allowSynchronousQueryExecution : true);

            IEnumerable<DataDocument> iresult = from f in q
                                                where f.Id == iDocument.Id
                                                select f;
            DataDocument id = iresult.FirstOrDefault<DataDocument>();
            Assert.AreEqual(doc.Id, id.Id);
        }

        #endregion

        #region Book type tests
        public class Author
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Name { get; set; }
            public string Location { get; set; }
        }

        public class Language
        {
            public string Name { get; set; }
            public string Copyright { get; set; }
        }

        public class Edition
        {
            public string Name { get; set; }
            public int Year { get; set; }
        }

        public class Book
        {
            //Verify that we can override the propertyName but still can query them using .NET Property names.
            [JsonProperty(PropertyName = "title")]
            public string Title { get; set; }
            [JsonProperty(PropertyName = "name")]
            public string Name { get; set; }
            public Language[] Languages { get; set; }
            public Author Author { get; set; }
            public double Price { get; set; }
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Id { get; set; }
            public List<Edition> Editions { get; set; }
        }

        [TestMethod]
        public async Task ValidateServerSideQueryEvalWithPagination()
        {
            await this.ValidateServerSideQueryEvalWithPaginationScenario();
        }

        private async Task ValidateServerSideQueryEvalWithPaginationScenario()
        {
            PartitionKeyDefinition partitionKeyDefinition = new PartitionKeyDefinition { Paths = new System.Collections.ObjectModel.Collection<string>(new[] { "/title" }), Kind = PartitionKind.Hash };
            ContainerProperties cosmosContainerSettings = new ContainerProperties
            {
                Id = Guid.NewGuid().ToString(),
                PartitionKey = partitionKeyDefinition,
            };
            cosmosContainerSettings.IndexingPolicy.IndexingMode = Microsoft.Azure.Cosmos.IndexingMode.Consistent;

            Container collection = await testDb.CreateContainerAsync(cosmosContainerSettings);

            //Do script post to insert as many document as we could in a tight loop.
            string script = @"function() {
                var output = 0;
                var client = getContext().getCollection();
                function callback(err, docCreated) {
                    if(err) throw 'Error while creating document';
                    output++;
                    getContext().getResponse().setBody(output);
                    if(output < 50) 
                        client.createDocument(client.getSelfLink(), { id: 'testDoc' + output, title : 'My Book'}, {}, callback);                       
                };
                client.createDocument(client.getSelfLink(), { id: 'testDoc' + output, title : 'My Book'}, {}, callback); }";

            StoredProcedureExecuteResponse<int> scriptResponse = null;
            int totalNumberOfDocuments = GatewayTests.CreateExecuteAndDeleteCosmosProcedure(collection, script, out scriptResponse, "My Book");

            IOrderedQueryable<Book> linqQueryable = collection.GetItemLinqQueryable<Book>(allowSynchronousQueryExecution : true);
            int totalHit = linqQueryable.Where(book => book.Title == "My Book").Count();
            Assert.AreEqual(totalHit, totalNumberOfDocuments, "Didnt get all the documents");

        }

        #endregion

        public class SpecialAttachment2 //Non attachemnt derived.
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Name { get; set; }

            [JsonProperty(PropertyName = "contentType")]
            public string ContentType { get; set; }

            [JsonProperty(PropertyName = Constants.Properties.MediaLink)]
            public string Media { get; set; }

            public string Author { get; set; }
            public string Title { get; set; }
        }

        #region TypeSystem test reference classes
        public interface IFooItem { }

        public class FooItem : IFooItem { }

        public class DerivedFooItem : FooItem { }

        public class MyList<T> : List<T> { }

        public class MyTupleList<T> : List<Tuple<T, T>> { }

        public class DerivedFooCollection : IList<IFooItem>, IEnumerable<DerivedFooItem>
        {
            public int IndexOf(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void Insert(int index, IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void RemoveAt(int index)
            {
                throw new NotImplementedException();
            }

            public IFooItem this[int index]
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public void Add(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(IFooItem[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { throw new NotImplementedException(); }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<IFooItem> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator<DerivedFooItem> IEnumerable<DerivedFooItem>.GetEnumerator()
            {
                throw new NotImplementedException();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        public class FooStringCollection : IList<string>, IEnumerable<FooItem>
        {
            public int IndexOf(string item)
            {
                throw new NotImplementedException();
            }

            public void Insert(int index, string item)
            {
                throw new NotImplementedException();
            }

            public void RemoveAt(int index)
            {
                throw new NotImplementedException();
            }

            public string this[int index]
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public void Add(string item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(string item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(string[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { throw new NotImplementedException(); }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(string item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<string> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator<FooItem> IEnumerable<FooItem>.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        public class FooTCollection<T> : List<FooItem>, IEnumerable<T>
        {
            public new IEnumerator<T> GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }
        #endregion

        public override LinqTestOutput ExecuteTest(LinqTestInput input)
        {
            return LinqTestsCommon.ExecuteTest(input);
        }
    }
}

---- Transformed Tree ----
using System.Linq;
//-----------------------------------------------------------------------
// <copyright file="LinqAttributeContractTests.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace Microsoft.Azure.Cosmos.Services.Management.Tests.LinqProviderTests
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic;
    using System.Runtime.Serialization;
    using System.Threading.Tasks;
    using Microsoft.Azure.Cosmos.Linq;
    using Microsoft.Azure.Cosmos.SDK.EmulatorTests;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Newtonsoft.Json;
    using BaselineTest;
    using Microsoft.Azure.Documents;
    using Microsoft.Azure.Cosmos.Scripts;

    [Microsoft.Azure.Cosmos.SDK.EmulatorTests.TestClass]
    public class LinqGeneralBaselineTests : BaselineTests<LinqTestInput, LinqTestOutput>
    {
        private static CosmosClient cosmosClient;
        private static Cosmos.Database testDb;
        private static Container testContainer;
        private static Func<bool, IQueryable<Family>> getQuery;

        [ClassInitialize]
        public async static Task Initialize(TestContext textContext)
        {
            cosmosClient = TestCommon.CreateCosmosClient(true);
            DocumentClientSwitchLinkExtension.Reset("LinqTests");

            string dbName = $"{nameof(LinqGeneralBaselineTests)}-{Guid.NewGuid().ToString("N")}";
            testDb = await cosmosClient.CreateDatabaseAsync(dbName);

            getQuery = LinqTestsCommon.GenerateFamilyCosmosData(testDb, out testContainer);
        }

        [ClassCleanup]
        public async static Task CleanUp()
        {
            if (testDb != null)
            {
                await testDb.DeleteStreamAsync();
            }
        }

        public class Address
        {
            public string State;
            public string County;
            public string City;
        }

        public class GuidClass : LinqTestObject
        {
            [JsonProperty(PropertyName = "id")]
            public Guid Id;
        }

        public class ListArrayClass : LinqTestObject
        {
            [JsonProperty(PropertyName = "id")]
            public string Id;

            public int[] ArrayField;
            public List<int> ListField;
        }

        [DataContract]
        public class Sport : LinqTestObject
        {
            [DataMember(Name = "id")]
            public string SportName;

            [JsonProperty(PropertyName = "json")]
            [DataMember(Name = "data")]
            public string SportType;
        }

        public class Sport2 : LinqTestObject
        {
            [DataMember(Name = "data")]
            public string id;
        }

        [TestMethod]
        public void TestSelectMany()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            inputs.Add(new LinqTestInput("SelectMany(SelectMany(Where -> Select))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))));

            inputs.Add(new LinqTestInput("SelectMany(Where -> SelectMany(Where -> Select))",
                b => getQuery(b)
                .SelectMany(family => family.Children.Where(c => c.Grade > 10)
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))));

            inputs.Add(new LinqTestInput("SelectMany(SelectMany(Where -> Select new {}))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Select)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Select(n => n.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Where)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Where(n => n.Count() > 10))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select) -> Select",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName)).Select(n => n.Count())));

            inputs.Add(new LinqTestInput("SelectMany()", b => getQuery(b).SelectMany(root => root.Children)));

            inputs.Add(new LinqTestInput("SelectMany -> SelectMany", b => getQuery(b).SelectMany(f => f.Children).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput("SelectMany -> Where -> SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Children).Where(c => c.Pets.Any()).SelectMany(c => c.Pets.Select(p => p.GivenName))));

            inputs.Add(new LinqTestInput("SelectMany -> Where -> SelectMany(Select new)", b => getQuery(b)
                .SelectMany(f => f.Children)
                .Where(c => c.Pets.Any())
                .SelectMany(c => c.Pets.Select(p => new { PetName = p.GivenName, OwnerName = c.GivenName }))));

            inputs.Add(new LinqTestInput("Where -> SelectMany", b => getQuery(b).Where(f => f.Children.Any()).SelectMany(f => f.Children)));

            inputs.Add(new LinqTestInput("SelectMany -> Select", b => getQuery(b).SelectMany(f => f.Children).Select(c => c.FamilyName)));

            inputs.Add(new LinqTestInput("SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput("SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName))));

            inputs.Add(new LinqTestInput("SelectMany(Select -> Select)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Select(n => n.Count()))));

            inputs.Add(new LinqTestInput("SelectMany(Select -> Where)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Where(n => n.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(Take -> Where)", b => getQuery(b).SelectMany(f => f.Children.Take(2).Where(c => c.FamilyName.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(OrderBy -> Take -> Where)", b => getQuery(b).SelectMany(f => f.Children.OrderBy(c => c.Grade).Take(2).Where(c => c.FamilyName.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(Distinct -> Where)", b => getQuery(b).SelectMany(f => f.Children.Distinct().Where(c => c.FamilyName.Count() > 10))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestSimpleSubquery()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            inputs.Add(new LinqTestInput("Select -> Select", b => getQuery(b).Select(f => f.FamilyId).Select(n => n.Count())));

            inputs.Add(new LinqTestInput("Select -> Where", b => getQuery(b).Select(f => f.FamilyId).Where(id => id.Count() > 10)));

            inputs.Add(new LinqTestInput("Select -> OrderBy -> Take -> Select -> Orderby -> Take", b => getQuery(b).Select(x => x).OrderBy(x => x).Take(10).Select(f => f.FamilyId).OrderBy(n => n.Count()).Take(5)));

            inputs.Add(new LinqTestInput("Select -> Orderby -> Take -> Select -> Orderby -> Take", b => getQuery(b).Select(f => f).OrderBy(f => f.Children.Count()).Take(3).Select(x => x).OrderBy(f => f.Parents.Count()).Take(2)));

            inputs.Add(new LinqTestInput("Orderby -> Take -> Orderby -> Take", b => getQuery(b).OrderBy(f => f.Children.Count()).Take(3).OrderBy(f => f.Parents.Count()).Take(2)));

            inputs.Add(new LinqTestInput("Take -> Orderby -> Take", b => getQuery(b).Take(10).OrderBy(f => f.FamilyId).Take(1)));

            inputs.Add(new LinqTestInput("Take -> Where -> Take -> Where -> Take -> Where", b => getQuery(b).Take(10).Where(f => f.Children.Any()).Take(9).Where(f => f.Parents.Any()).Take(8).Where(f => f.FamilyId.Count() > 10)));

            inputs.Add(new LinqTestInput("Take -> Where -> Distinct -> Select -> Take -> Where", b => getQuery(b).Take(10).Where(f => f.Children.Any()).Distinct().Select(f => new { f }).Take(8).Where(f => f.f.FamilyId.Count() > 10)));

            inputs.Add(new LinqTestInput("Distinct -> Select -> Take -> Where -> Take -> Where", b => getQuery(b).Distinct().Select(f => new { f }).Take(10).Where(f => f.f.Children.Any()).Take(9).Where(f => f.f.Parents.Any())));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestQueryFlattening()
        {
            // these queries should make more sense when combined with where and orderby
            // these tests verify the flattening part
            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("array create", b => getQuery(b).Select(f => f.Int).Select(i => new int[] { i })));
            inputs.Add(new LinqTestInput("unary operation", b => getQuery(b).Select(f => f.Int).Select(i => -i)));
            inputs.Add(new LinqTestInput("binary operation", b => getQuery(b).Select(f => f).Select(i => i.Int % 10 * i.Children.Count())));
            inputs.Add(new LinqTestInput("literal", b => getQuery(b).Select(f => f.Int).Select(i => 0)));
            inputs.Add(new LinqTestInput("function call", b => getQuery(b).Select(f => f.Parents).Select(p => p.Count())));
            inputs.Add(new LinqTestInput("object create", b => getQuery(b).Select(f => f.Parents).Select(p => new { parentCount = p.Count() })));
            inputs.Add(new LinqTestInput("conditional", b => getQuery(b).Select(f => f.Children).Select(c => c.Any()? "have kids" : "no kids")));
            inputs.Add(new LinqTestInput("property ref + indexer", b => getQuery(b).Select(f => f)
                .Where(f => f.Children.Any() && f.Children[0].Pets.Any())
                .Select(f => f.Children[0].Pets[0].GivenName)));

            inputs.Add(new LinqTestInput("array creation -> indexer", b => getQuery(b).Select(f => new int[] { f.Int }).Select(array => array[0])));
            inputs.Add(new LinqTestInput("unary, indexer, property, function call -> function call", b => getQuery(b)
                .Where(f => f.Children.Any())
                .Select(f => -f.Children[0].Pets.Count()).Select(i => Math.Abs(i))));
            inputs.Add(new LinqTestInput("binary operation, function call -> conditional", b => getQuery(b).Select(i => i.Int % 10 * i.Children.Count()).Select(i => i > 0 ? new int[] { i } : new int[] { })));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b)
                .Select(f => new { parentCount = f.Parents.Count(), childrenCount = f.Children.Count() })
                .Select(r => r.parentCount > 0 ? Math.Floor((double)r.childrenCount / r.parentCount) : 0)));
            inputs.Add(new LinqTestInput("indexer -> function call", b => getQuery(b).Select(f => f.Parents[0]).Select(p => string.Concat(p.FamilyName, p.GivenName))));
            inputs.Add(new LinqTestInput("conditional -> object creation", b => getQuery(b).Select(f => f.Parents.Any()? f.Parents : new Parent[0]).Select(p => new { parentCount = p.Count() })));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b).Select(f => new { children = f.Children }).Select(c => c.children.Any()? c.children[0].GivenName : "no kids")));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b).Select(f => new { family = f, children = f.Children.Count() }).Select(f => f.children > 0 && f.family.Children[0].Pets.Any()? f.family.Children[0].Pets[0].GivenName : "no kids")));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestSubquery()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------------------------
            // Subquery lambdas
            // --------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Pets.Count()))));
                
            inputs.Add(new LinqTestInput(
                "Select(Take)", b => getQuery(b)
                .Select(f => f.Children.Take(2))));
                
            inputs.Add(new LinqTestInput(
                "Select(Where)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Pets.Any()))));
                
            inputs.Add(new LinqTestInput(
                "Select(Distinct)", b => getQuery(b)
                .Select(f => f.Children.Distinct())));
                
            inputs.Add(new LinqTestInput(
                "Select(Count)", b => getQuery(b)
                .Select(f => f.Children.Count(c => c.Grade > 80))));

            inputs.Add(new LinqTestInput(
                "Select(Sum)", b => getQuery(b)
                .Select(f => f.Children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "Where(Count)", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Pets.Count() > 0))));

            inputs.Add(new LinqTestInput(
                "Where(Sum)", b => getQuery(b)
                .Where(f => f.Children.Sum(c => c.Grade) > 100)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Count)", b => getQuery(b)
                .OrderBy(f => f.Children.Count(c => c.Grade > 90))));

            // -------------------------------------------------------------
            // Mutilpe-transformations subquery lambdas
            // -------------------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select -> Distinct -> Count)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Gender).Distinct().Count())));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Sum)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Sum())));

            inputs.Add(new LinqTestInput(
                "Select(Select -> OrderBy -> Take)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.GivenName).OrderBy(n => n.Length).Take(1))));

            inputs.Add(new LinqTestInput(
                "Select(SelectMany -> Select)", b => getQuery(b)
                .Select(f => f.Children.SelectMany(c => c.Pets).Select(c => c.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Count)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Count())));

            inputs.Add(new LinqTestInput(
                "Select(Where -> OrderBy -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).OrderBy(c => c.Pets.Count()).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Select -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Select(c => c.Pets.Count()).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Select(array) -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Select(c => c.Pets).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(where -> Select -> Distinct)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50 && c.Pets.Any()).Select(c => c.Gender).Distinct())));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy -> Take -> Select)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Grade).Take(1).Select(c => c.Gender))));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy -> Take -> Select -> Average)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Pets.Count()).Take(2).Select(c => c.Grade).Average())));

            inputs.Add(new LinqTestInput(
                "Where(Select -> Count)", b => getQuery(b)
                .Where(f => f.Children.Select(c => c.Pets.Any()).Count())));

            inputs.Add(new LinqTestInput(
                "Where(Where -> Count)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Any() > 0).Count())));

            inputs.Add(new LinqTestInput(
                "Where(Where -> Sum)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Any()).Sum(c => c.Grade) < 200)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> OrderBy -> Take -> Select)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Any() > 0).OrderBy(c => c.Grade).Take(1).Where(c => c.Grade > 80).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select -> Where)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Pets.Count()).Where(x => x > 1))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Where -> Count)", b => getQuery(b)
                .OrderBy(f => f.Children.Where(c => c.Pets.Count() > 3).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select -> Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Grade).Sum())));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> Take -> Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.OrderBy(c => c.Pets.Count()).Take(2).Sum(c => c.Grade))));

            // ---------------------------------------------------------
            // Scalar and Built-in expressions with subquery lambdas
            // ---------------------------------------------------------

            // Unary

            inputs.Add(new LinqTestInput(
                "Where(unary (Where -> Count))", b => getQuery(b)
                .Where(f => !-f.Children.Where(c => c.Grade < 20).Any())));

            // Binary

            inputs.Add(new LinqTestInput(
                "Select(binary with Count)", b => getQuery(b)
                .Select(f => 5 + f.Children.Count(c => c.Pets.Any()))));
                
            inputs.Add(new LinqTestInput(
                "Select(constant + Where -> Count)", b => getQuery(b)
                .Select(f => 5 + f.Children.Where(c => c.Pets.Any()).Count())));

            inputs.Add(new LinqTestInput(
                "Where((Where -> Count) % constant)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Any()).Count() % 2 == 1)));

            // Conditional

            inputs.Add(new LinqTestInput(
                "Select(conditional Any ? Select : Select)", b => getQuery(b)
                .Select(f => f.Children.Any() ? f.Children.Select(c => c.GivenName) : f.Parents.Select(p => p.GivenName))));

            inputs.Add(new LinqTestInput(
                "Select(conditional Any(filter) ? Max : Sum)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Grade > 97) ? f.Children.Max(c => c.Grade) : f.Children.Sum(c => c.Grade))));

            // New array

            inputs.Add(new LinqTestInput(
                "Select(new array)", b => getQuery(b)
                .Select(f => new int[] { f.Children.Count(), f.Children.Sum(c => c.Grade) })));

            // New + member init

            inputs.Add(new LinqTestInput(
                "Select(new)", b => getQuery(b)
                .Select(f => new int[] { f.Children.Count(), f.Children.Sum(c => c.Grade) })));

            inputs.Add(new LinqTestInput(
               "Select(Select new)", b => getQuery(b)
               .Select(f => new { f.FamilyId, ChildrenPetCount = f.Children.Select(c => c.Pets.Count()) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where)", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 3) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where)", b => getQuery(b)
                .Select(f => new { f.FamilyId, GoodChildren = f.Children.Where(c => c.Grade > 90) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where -> Select)", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 3).Select(c => c.GivenName) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where -> Count) -> Where", b => getQuery(b)
                .Select(f => new { Family = f, ChildrenCount = f.Children.Where(c => c.Grade > 0).Count() }).Where(f => f.ChildrenCount > 0)));

            // Array builtin functions

            inputs.Add(new LinqTestInput(
                "Select(Where -> Concat(Where))", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 90).Concat(f.Children.Where(c => c.Grade < 10)))));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Contains(Sum))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Contains(f.Children.Sum(c => c.Pets.Count())))));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Contains(Where -> Count))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Contains(f.Children.Where(c => c.Grade > 50).Count()))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(array indexer)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Grade > 20).Count() >= 2)
                .Select(f => f.Children.Where(c => c.Grade > 20).ToArray()[1])));

            inputs.Add(new LinqTestInput(
                "Where -> Select(array indexer)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Grade > 20).Count() >= 2)
                .Select(f => f.Children.Where(c => c.Grade > 20).ToArray()[f.Children.Count() % 2])));

            // Math builtin functions

            inputs.Add(new LinqTestInput(
                "Select(Floor(sum(map), sum(map)))", b => getQuery(b)
                .Select(f => Math.Floor(1.0 * f.Children.Sum(c => c.Grade) / (f.Children.Sum(c => c.Pets.Count()) + 1)))));

            inputs.Add(new LinqTestInput(
                "Select(Pow(Sum(map), Count(Any)))", b => getQuery(b)
                .Select(f => Math.Pow(f.Children.Sum(c => c.Pets.Count()), f.Children.Count(c => c.Pets.Any(p => !p.GivenName.Any() || p.GivenName.Substring(0, 1) == "A"))))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Log(Where -> Count))", b => getQuery(b)
                .OrderBy(f => Math.Log(f.Children.Where(c => c.Pets.Any()).Count()))));

            // ------------------------------------------------------------------
            // Expression with subquery lambdas -> more transformations
            // ------------------------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Where", b => getQuery(b).Select(f => f.Children.Select(c => c.Pets.Count())).Where(x => x.Any())));
            
            // Customer requested scenario
            inputs.Add(new LinqTestInput(
                "Select(new w/ Where) -> Where -> OrderBy -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), SmartChildren = f.Children.Where(c => c.Grade > 90) })
                .Where(f => f.FamilyId.CompareTo("ABC") > 0 && f.SmartChildren.Any())
                .OrderBy(f => f.ChildrenCount)
                .Take(10)));
            // TODO https://github.com/Azure/azure-cosmos-dotnet-v3/issues/375
            //inputs.Add(new LinqTestInput(
            //    "Select(new w/ Where) -> Where -> OrderBy -> Take", b => getQuery(b)
            //    .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), SmartChildren = f.Children.Where(c => c.Grade > 90) })
            //    .Where(f => f.ChildrenCount > 2 && f.SmartChildren.Count() > 1)
            //    .OrderBy(f => f.FamilyId)
            //    .Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new { Select(Select), conditional Count Take }) -> Where -> Select(Select(Any))", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    ChildrenPetFirstChars = f.Children.Select(c => c.Pets.Select(p => p.GivenName.Substring(0, 1))),
                    FirstChild = f.Children.Any()? f.Children.Take(1) : null
                })
                .Where(f => f.FirstChild != null)
                .Select(f => f.ChildrenPetFirstChars.Select(chArray => chArray.Any(a => f.FamilyId.StartsWith(a))))));

            inputs.Add(new LinqTestInput(
                "Select(new (Select(new (Select, Select))))", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    ChildrenProfile = f.Children.Select(c => new
                    {
                        Fullname = c.GivenName + " " + c.FamilyName,
                        PetNames = c.Pets.Select(p => p.GivenName),
                        ParentNames = f.Parents.Select(p => p.GivenName)
                    })
                })));

            // ------------------------------------------------
            // Subquery lambda -> subquery lamda
            // ------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(array) -> Where(Sum(map))", b => getQuery(b)
                .Select(f => f.Children).Where(children => children.Sum(c => c.Grade) > 100)));

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Select(Sum())", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade)).Select(children => children.Sum())));

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Select(Sum(map))", b => getQuery(b)
                .Select(f => f.Children).Select(children => children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "Where(Any binary) -> Select(Sum(map))", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Grade > 90) && f.IsRegistered)
                .Select(f => f.Children.Sum(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Where(Any binary) -> OrderBy(Count(filter)) -> Select(Sum(map))", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Grade > 90) && f.IsRegistered)
                .OrderBy(f => f.Children.Count(c => c.Things.Count() > 3))
                .Select(f => f.Children.Sum(c => c.Pets.Count()))));

            // ------------------------------
            // Nested subquery lambdas
            // ------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select(Select))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName.Count())))));

            inputs.Add(new LinqTestInput(
                "Select(Select(Select))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Select(p => p)))));

            inputs.Add(new LinqTestInput(
                "Select(Select(new Count))", b => getQuery(b)
                .Select(f => f.Children
                    .Select(c => new
                    {
                        HasSiblingWithSameStartingChar = f.Children.Count(child => (child.GivenName + " ").Substring(0, 1) == (c.GivenName + " ").Substring(0, 1)) > 1
                    }))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(conditional ? Take : OrderBy -> Array indexer)", b => getQuery(b)
                .Where(f => f.Children.Any())
                .Select(f => f.Children.Count() == 1 ? f.Children.Take(1).ToArray()[0] : f.Children.OrderBy(c => c.Grade).ToArray()[1])));

            inputs.Add(new LinqTestInput(
                "Select(Where(Where -> Count) -> Select(new Count))", b => getQuery(b)
                .Select(f => f.Children
                    .Where(c => c.Pets.Where(p => p.GivenName.Any() > 10 && p.GivenName.Substring(0, 1) == "A").Count())
                    .Select(c => new
                    {
                        HasSiblingWithSameStartingChar = f.Children.Count(child => (child.GivenName + " ").Substring(0, 1) == (c.GivenName + " ").Substring(0, 1)) > 1
                    }))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select(Select))", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName.Count())))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where(Any))", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Pets.Any(p => p.GivenName.Count() > 10)))));

            inputs.Add(new LinqTestInput(
                "Where(Where(Count) -> Count)", b => getQuery(b)
                .Where(f => f.Parents.Where(p => p.FamilyName.Count() > 10).Count() > 1)));

            inputs.Add(new LinqTestInput(
                "Where(Where(Where -> Count) -> Count)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Where(p => p.GivenName.Any() > 15).Count() > 0).Count())));

            inputs.Add(new LinqTestInput(
                "Where(Select(Select -> Any))", b => getQuery(b)
                .Where(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName)).Any(t => t.Count() > 3))));

            // -------------------------------------
            // Expression -> Subquery lambdas
            // -------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(new) -> Select(Select)", b => getQuery(b)
                .Select(f => new { f.FamilyId, Family = f }).Select(f => f.Family.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select(Select)", b => getQuery(b)
                .SelectMany(f => f.Children).Select(c => c.Pets.Select(p => p.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where) -> Where(Any) -> Select(Select)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Grade > 80))
                .Where(c => c.Pets.Any(p => p.GivenName.Count() > 20))
                .Select(c => c.Pets.Select(p => p.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "Distinct -> Select(new) -> Where(Select(Select -> Any))", b => getQuery(b)
                .Distinct()
                .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), Family = f })
                .Where(f => f.Family.Children.Select(c => c.Pets.Select(p => p.GivenName)).Any(t => t.Count() > 3))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(Select)", b => getQuery(b)
                .Where(f => f.Children.Any()).Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Distinct -> Select(Select)", b => getQuery(b)
                .Distinct().Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Take -> Select(Select)", b => getQuery(b)
                .Take(10).Select(f => f.Children.Select(c => c.Pets.Count()))));
            
            // ------------------
            // Any in lambda
            // ------------------

            inputs.Add(new LinqTestInput(
                "Select(Any w const array)", b => getQuery(b)
                .Select(f => new int[] { 1, 2, 3 }.Any())));
                
            inputs.Add(new LinqTestInput(
                "Select(Any)", b => getQuery(b)
                .Select(f => f.Children.Any())));
                
            inputs.Add(new LinqTestInput(
                "Select(Any w lambda)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Grade > 80))));
                
            inputs.Add(new LinqTestInput(
                "Select(new Any)", b => getQuery(b)
                .Select(f => new { f.FamilyId, HasGoodChildren = f.Children.Any(c => c.Grade > 80) })));
                
            inputs.Add(new LinqTestInput(
                "Select(new 2 Any)", b => getQuery(b)
                .Select(f => new { HasChildrenWithPets = f.Children.Any(c => c.Pets.Any()), HasGoodChildren = f.Children.Any(c => c.Grade > 80) })));
                
            inputs.Add(new LinqTestInput(
                "Select(Nested Any)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Pets.Any(p => p.GivenName.Count() > 10)))));

            inputs.Add(new LinqTestInput(
                "Where(Any)", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Pets.Any()))));

            // Customer requested scenario
            inputs.Add(new LinqTestInput(
                "Where(simple expr && Any)", b => getQuery(b)
                .Where(f => f.FamilyId.Contains("a") && f.Children.Any(c => c.Pets.Any()))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Any)", b => getQuery(b)
                .OrderBy(f => f.Children.Any(c => c.Pets.Count() > 3))));
            
            // ------------------------------------------------
            // SelectMany with Take and OrderBy in lambda
            // ------------------------------------------------

            inputs.Add(new LinqTestInput(
                "SelectMany(Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Take(2))));

            inputs.Add(new LinqTestInput(
                "SelectMany(OrderBy)", b => getQuery(b)
                .SelectMany(f => f.Children.OrderBy(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.FamilyName.Count() > 10).Take(2))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> Take -> Select)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.FamilyName.Count() > 10).Take(2).Select(c => c.Grade))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void DebuggingTest()
        {
            
        }

        [TestMethod]
        [Owner("khdang")]
        [Ignore]
        public void TestSkipTake()
        {
            //TODO
            //V2 using V3 pipeline causing issue on accessing Continuation in CosmosQueryResponseMessageHeaders
            //This will be fine once we convert these test cases to use V3 pipeline

            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------------------
            // Skip - Take combinations
            // --------------------------------

            inputs.Add(new LinqTestInput(
                "Skip", b => getQuery(b)
                .Skip(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take", b => getQuery(b)
                .Skip(1).Take(2)));

            inputs.Add(new LinqTestInput(
                "Skip(negative number) -> Take", b => getQuery(b)
                .Skip(-1).Take(1)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take(negative number)", b => getQuery(b)
                .Skip(1).Take(-2)));

            inputs.Add(new LinqTestInput(
                "Skip -> Skip -> Take", b => getQuery(b)
                .Skip(1).Skip(2).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Take", b => getQuery(b)
                .Skip(3).Take(5).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Skip -> Take", b => getQuery(b)
                .Skip(1).Take(2).Skip(3).Take(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Take -> Skip", b => getQuery(b)
                .Skip(1).Take(2).Take(3).Skip(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Skip -> Take -> Take", b => getQuery(b)
                .Skip(5).Skip(2).Take(10).Take(3)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip", b => getQuery(b)
                .Take(7).Skip(3)));

            inputs.Add(new LinqTestInput(
                "Take -> Take -> Skip", b => getQuery(b)
                .Take(2).Take(3).Skip(5)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Skip", b => getQuery(b)
                .Take(3).Skip(1).Skip(2)));

            inputs.Add(new LinqTestInput(
                "Take -> Take -> Skip -> Skip", b => getQuery(b)
                .Take(5).Take(3).Skip(1).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Take -> Skip", b => getQuery(b)
                .Take(10).Skip(2).Take(5).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Skip -> Take", b => getQuery(b)
                .Take(10).Skip(4).Skip(2).Take(2)));

            // --------------------------
            // Select + Skip & Take
            // --------------------------

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(1).Take(2)));

            inputs.Add(new LinqTestInput(
                "Select -> Take -> Skip", b => getQuery(b)
                .Select(f => f.FamilyId).Take(2).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> Select", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(7).Take(13).Select(f => f.Count())));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Take -> Skip", b => getQuery(b)
                .Skip(5).Take(11).Select(f => f.Children.Count()).Take(7).Skip(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).Select(f => f.FamilyId).Take(7)));

            inputs.Add(new LinqTestInput(
                "Take -> Select -> Skip", b => getQuery(b)
                .Take(7).Select(f => f.FamilyId).Skip(3)));

            // ------------------------------
            // SelectMany + Skip & Take
            // ------------------------------

            inputs.Add(new LinqTestInput(
                "SelectMany -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Skip(7).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Skip -> Take -> SelectMany", b => getQuery(b)
                .SelectMany(f => f.Children).Skip(11).Take(3).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "Skip -> SelectMany -> Take -> Skip -> SelectMany", b => getQuery(b)
                .Skip(1).SelectMany(f => f.Children).Take(13).Skip(3).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> SelectMany -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).SelectMany(c => c.Pets).Skip(3).Take(4)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> SelectMany -> Skip -> SelectMany", b => getQuery(b)
                .Take(50).Skip(25).SelectMany(f => f.Children).Skip(10).SelectMany(c => c.Pets)));

            // ---------------------------
            // Where + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(3).Take(5)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Children.Any()).Skip(7).Take(11).Where(f => f.Tags.Count() > 2).Skip(1).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Where -> Skip", b => getQuery(b)
                .Skip(1).Take(25).Where(f => f.Int > 10).Skip(5)));

            inputs.Add(new LinqTestInput(
                "Take -> Where -> Skip", b => getQuery(b)
                .Take(25).Where(f => f.FamilyId.Contains("A")).Skip(10)));

            inputs.Add(new LinqTestInput(
                "Where -> Take -> Skip -> Where", b => getQuery(b)
                .Where(f => f.Children.Count() > 1).Take(10).Skip(3).Where(f => f.Int > 0)));

            // ---------------------------
            // OrderBy + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take -> OrderBy -> Take -> Skip", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(3).Take(11).OrderBy(f => f.FamilyId).Take(7).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> OrderBy", b => getQuery(b)
                .Skip(3).Take(43).OrderBy(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderByDescending -> Skip", b => getQuery(b)
                .Take(50).OrderByDescending(f => f.Int).Skip(13)));

            inputs.Add(new LinqTestInput(
                "Skip -> OrderByDescending -> Take", b => getQuery(b)
                .Skip(7).OrderByDescending(f => f.Int).Take(17)));

            // ---------------------------
            // Distinct + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "Distinct -> Skip -> Take", b => getQuery(b)
                .Distinct().Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Distinct", b => getQuery(b)
                .Skip(3).Take(11).Distinct()));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Distinct -> Skip -> Take -> Distinct -> Skip", b => getQuery(b)
                .Skip(10).Take(60).Select(f => f.Int).Distinct().Skip(15).Take(20).Distinct().Skip(7)));

            inputs.Add(new LinqTestInput(
                "Skip -> Distinct -> Skip -> Take", b => getQuery(b)
                .Skip(7).Distinct().Skip(20).Take(10)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Distinct -> Skip", b => getQuery(b)
                .Take(30).Skip(10).Distinct().Skip(7)));

            // ---------------------------------------------------------------------------------
            // Select, SelectMany, Where, OrderBy, Distinct with Skip & Take in between
            // ---------------------------------------------------------------------------------

            // Select, SelectMany

            inputs.Add(new LinqTestInput(
                "Select(new) -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, f.Children }).SelectMany(c => c.Children).Skip(3).Take(10)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Select(c => c.GivenName).Skip(7).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> SelectMany -> Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).Take(20).SelectMany(f => f.Children).Skip(3).Select(c => c.GivenName).Take(5)));

            inputs.Add(new LinqTestInput(
                "Skip -> SelectMany -> Take -> Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).SelectMany(f => f.Children).Take(10).Skip(1).Select(c => c.FamilyName).Take(7)));

            inputs.Add(new LinqTestInput(
                "Take -> SelectMany -> Skip -> Select -> Take", b => getQuery(b)
                .Take(30).SelectMany(f => f.Children).Skip(10).Select(c => c.Grade).Take(3)));

            // Select, Where

            inputs.Add(new LinqTestInput(
                "Select -> Where -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Children).Where(c => c.Any()).Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Select -> Skip", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(7).Take(3).Select(f => f.FamilyId).Skip(2)));

            // Select, OrderBy

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> OrderBy", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(1).Take(2).OrderBy(s => s)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> Take -> Skip -> Select", b => getQuery(b)
                .OrderByDescending(f => f.Int).Take(10).Skip(3).Select(f => f.Int + 1)));

            // Select, Distinct

            inputs.Add(new LinqTestInput(
                "Take -> Select -> Distinct -> Skip -> Take", b => getQuery(b)
                .Take(7).Select(f => f.Int).Distinct().Skip(1).Take(5)));

            // SelectMany, Where

            inputs.Add(new LinqTestInput(
                "SelectMany -> Where -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Where(c => c.Grade > 100).Skip(10).Take(20)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> SelectMany -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(10).SelectMany(f => f.Children).Take(7)));

            // SelectMany, OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> SelectMany -> SelectMany", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(10).SelectMany(f => f.Children).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(10).Take(20)));

            // SelectMany, Distinct

            inputs.Add(new LinqTestInput(
                "SelectMany -> Distinct -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Distinct().Skip(7).Take(11)));

            inputs.Add(new LinqTestInput(
                "Distinct -> Skip -> SelectMany", b => getQuery(b)
                .Distinct().Skip(3).SelectMany(f => f.Children)));

            // Where, OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Where -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Where(f => f.IsRegistered).Skip(11).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Where -> Take -> OrderBy", b => getQuery(b)
                .Skip(20).Where(f => f.Children.Any()).Take(10).OrderBy(f => f.Int)));

            // Where, Distinct

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Distinct", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(3).Take(17).Distinct()));

            inputs.Add(new LinqTestInput(
                "Skip -> Distinct -> Where -> Take", b => getQuery(b)
                .Skip(22).Distinct().Where(f => f.Parents.Any()).Take(7)));

            // -----------------------------------------
            // All basic operations with Skip & Take
            // -----------------------------------------

            // Start with Select

            inputs.Add(new LinqTestInput(
                "Select -> Where -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Where(id => id.Count() > 10).OrderBy(id => id).Skip(1).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select -> Where -> OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Where(id => id.Count() > 10).OrderBy(id => id).Skip(1).Take(10)
                .Select(id => id + "_suffix").Where(id => id.Count() > 12).Skip(2).Take(4)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> OrderBy -> Skip -> Distinct -> Skip", b => getQuery(b)
                .Select(f => f.Records).Skip(5).OrderBy(r => r.Transactions.Count()).Skip(1).Distinct().Skip(3)));

            inputs.Add(new LinqTestInput(
                "Select(new(new(new(new(new))))) -> (Skip -> Select) x 6 -> Skip -> Where -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, L1 = new { L2 = new { L3 = new { L4 = new { f.Records } } } } })
                .Skip(1).Select(f => f.L1)
                .Skip(2).Select(f => f.L2)
                .Skip(3).Select(f => f.L3)
                .Skip(4).Select(f => f.L4)
                .Skip(5).Select(f => f.Records)
                .Skip(6).Select(f => f.Transactions)
                .Skip(7).Where(t => t.Count() > 100)
                .Take(20)));

            inputs.Add(new LinqTestInput(
                "Select -> (Skip -> Select -> Where -> OrderBy -> Distinct -> Take) x 3 -> Skip -> Take", b => getQuery(b)
                .Select(f => new { L1 = f })
                .Skip(1).Select(f => f.L1).Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Distinct().Take(100)
                .Skip(2).Select(f => new { L2 = f }).Where(f => f.L2.FamilyId.CompareTo("A") > 0).OrderBy(f => f.L2.Int).Distinct().Take(50)
                .Skip(3).Select(f => f.L2).Where(f => f.Children.Count() > 1).OrderBy(f => f.IsRegistered).Distinct().Take(40)
                .Skip(4).Take(25)));

            // Start with Distinct

            inputs.Add(new LinqTestInput(
                "Distinct -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Distinct().Select(f => f.Records).Where(r => r.Transactions.Count() > 2).Skip(1).Take(10)));

            // Start with Where

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Skip(1).Take(5)));

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Skip(1).Take(5)
                .Select(f => f.Records).Where(r => r.Transactions != null).Skip(1).Take(3)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 20).Skip(5).Take(20)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(5).Take(10)));

            // Start with OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(1).Take(10)
                .Select(f => f.Records).Where(r => r.Transactions.Count() > 10).Skip(2).Take(3)));

            // Start with Skip

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Skip(1).Take(10).Select(f => f.Children.Count()).Where(c => c > 1).Skip(1).Take(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Where -> Skip -> Take -> OrderBy -> Skip -> Take -> Select -> Skip -> Distinct -> Skip -> Take", b => getQuery(b)
                .Skip(2).Take(10).Where(f => f.Int > 10)
                .Skip(1).Take(9).OrderBy(f => f.FamilyId)
                .Skip(3).Take(5).Select(f => f.Children.Count())
                .Skip(1).Distinct()
                .Skip(1).Take(1)));

            // Start with Take

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Take(10).Skip(2).Where(f => f.IsRegistered).OrderBy(f => f.Int).Skip(1).Take(9)));

            inputs.Add(new LinqTestInput(
                "Take -> Distinct -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Take(10).Distinct().Select(f => f.Children).Where(c => c.Any()).Skip(2).Take(5)));

            // -----------------------------------------------------------------------------
            // All basic operations with Skip & Take with SelectMany in the middle
            // -----------------------------------------------------------------------------

            // SelectMany after Take

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Records).Skip(1).Take(10)
                .SelectMany(r => r.Transactions).Skip(1).Take(9)));

            // SelectMany after Where

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(10).Take(20)));

            // Start with SelectMany

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children)
                    .Select(c => c.FamilyName).Skip(1).Take(20)
                    .Select(n => n.Count()).Where(l => l > 10).Skip(2).Take(50)));

            // -------------------------------------------------------------
            // Nested Skip & Take in Select, SelectMany, Where, OrderBy
            // -------------------------------------------------------------

            // Nested with Select

            inputs.Add(new LinqTestInput(
                "Select(new(Where -> Skip)) -> Where", b => getQuery(b)
                .Select(f => new {
                    id = f.FamilyId,
                    GoodChildren = f.Children.Where(c => c.Grade > 75).Skip(1)
                })
                .Where(f => f.GoodChildren.Any())));

            inputs.Add(new LinqTestInput(
                "Select(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Children.Skip(1).Take(1)).Skip(3).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new(Skip -> Take, Skip, Take) -> Skip -> Take -> Where", b => getQuery(b)
                .Select(f => new {
                    v0 = f.Children.Skip(1).Take(2),
                    v1 = f.Parents.Skip(1),
                    v2 = f.Records.Transactions.Take(10)
                })
                .Skip(1).Take(20).Where(f => f.v0.Any()).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new(SelectMany -> SelectMany -> Distinct, OrderByDescending -> Take -> SelectMany -> Skip, Select -> OrderBy -> Skip -> Take -> Sum) -> Where -> Skip -> Take -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => new {
                    v0 = f.Children.SelectMany(c => c.Pets.Skip(1).SelectMany(p => p.GivenName).Distinct()),
                    v1 = f.Children.OrderByDescending(c => c.Grade).Take(2).SelectMany(c => c.Pets.Select(p => p.GivenName).Skip(2)),
                    v2 = f.Records.Transactions.Select(t => t.Amount).OrderBy(a => a).Skip(10).Take(20).Sum()
                })
                .Where(f => f.v2 > 100).Skip(5).Take(20)
                .SelectMany(f => f.v1).Distinct().Skip(3).Take(22)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> SelectMany(Skip -> OrderBy)", b => getQuery(b)
                .Select(f => f.Records).Skip(1).SelectMany(r => r.Transactions.Skip(10).OrderBy(t => t.Date))));

            // Nested with Where

            inputs.Add(new LinqTestInput(
                "Where -> Where(Skip -> Take -> Count) - > Skip -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 2).Where(f => f.Children.Skip(1).Take(10).Count() > 1).Skip(1).Take(10)));

            // Nested with OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy(Skip -> Take -> Count) -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Children.Skip(1).Take(5).Count())));

            // Nested with SelectMany

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).Take(2)).Skip(3).Take(20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> Take) -> Skip -> Take -> SelectMany(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).Take(2)).Skip(3).Take(20)
                .SelectMany(c => c.Pets.Skip(1).Take(2)).Skip(1).Take(10)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> OrderBy -> Skip -> Distinct)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Grade > 10).OrderBy(c => c.Grade).Skip(1).Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> SelectMany(Skip -> Select) -> Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).SelectMany(c => c.Pets.Skip(1).Select(p => p.GivenName)).Take(10))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void TestUnsupportedScenarios()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------
            // Dictionary type
            // --------------------

            // Iterating through Dictionary type
            inputs.Add(new LinqTestInput("Iterating through Dictionary type", b => getQuery(b).Select(f => f.Children.Select(c => c.Things.Select(t => t.Key.Count() + t.Value.Count())))));

            // Get a count of a Dictionary type
            inputs.Add(new LinqTestInput("Getting Dictionary count", b => getQuery(b).Select(f => f.Children.Select(c => c.Things.Count()))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestOrderByTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Ascending
            inputs.Add(new LinqTestInput("Select -> order by", b => getQuery(b).Select(family => family.FamilyId).OrderBy(id => id)));
            inputs.Add(new LinqTestInput("Select -> order by -> Select", b => getQuery(b).Select(family => family.FamilyId).OrderBy(id => id).Select(x => x.Count())));
            inputs.Add(new LinqTestInput("Where -> OrderBy -> Select query",
                b => from f in getQuery(b)
                     where f.Int == 5 && f.NullableInt != null
                     orderby f.IsRegistered
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("Where -> OrderBy -> Select", b => getQuery(b).Where(f => f.Int == 5 && f.NullableInt != null).OrderBy(f => f.IsRegistered).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy query",
                b => from f in getQuery(b)
                     orderby f.FamilyId
                     select f));
            inputs.Add(new LinqTestInput("OrderBy", b => getQuery(b).OrderBy(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select query",
                b => from f in getQuery(b)
                     orderby f.FamilyId
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("OrderBy -> Select", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Take", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId).Take(10)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Select", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId).Select(x => x)));

            // Descending
            inputs.Add(new LinqTestInput("Select -> order by", b => getQuery(b).Select(family => family.FamilyId).OrderByDescending(id => id)));
            inputs.Add(new LinqTestInput("Select -> order by -> Select", b => getQuery(b).Select(family => family.FamilyId).OrderByDescending(id => id).Select(x => x.Count())));
            inputs.Add(new LinqTestInput("Where -> OrderBy Desc -> Select query",
                b => from f in getQuery(b)
                     where f.Int == 5 && f.NullableInt != null
                     orderby f.IsRegistered descending
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("Where -> OrderBy Desc -> Select", b => getQuery(b).Where(f => f.Int == 5 && f.NullableInt != null).OrderByDescending(f => f.IsRegistered).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy Desc query",
                b => from f in getQuery(b)
                     orderby f.FamilyId descending
                     select f));
            inputs.Add(new LinqTestInput("OrderBy Desc", b => getQuery(b).OrderByDescending(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy Desc -> Select query",
                b => from f in getQuery(b)
                     orderby f.FamilyId descending
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("OrderBy Desc -> Select", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Take", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId).Take(10)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Select", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId).Select(x => x)));
            inputs.Add(new LinqTestInput("OrderBy multiple expressions",
                b => from f in getQuery(b)
                     orderby f.FamilyId, f.Int
                     select f.FamilyId));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestThenByTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Ascending and descending

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenByDescending", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .ThenBy(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> ThenByDescending", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .ThenByDescending(f => f.Int)));

            // Subquery in OrderBy or in ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy subquery -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy subquery -> ThenBy subquery", b => getQuery(b)
                .OrderByDescending(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            // OrderBy and ThenBy by the same property (not a realistic scenario)

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.FamilyId)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenByDescending", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.FamilyId)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending subquery -> ThenBy subquery", b => getQuery(b)
                .OrderByDescending(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Children.Where(c => c.Grade > 100).Count())));

            // OrderBy and ThenBy with epxressions

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.Int * 2)
                .ThenBy(f => f.FamilyId.Substring(2, 3))));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => !f.NullableInt.IsDefined())
                .ThenByDescending(f => f.Tags.Count() % 2)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.IsRegistered ? f.FamilyId : f.Int.ToString())
                .ThenBy(f => f.Records.Transactions.Max(t => t.Amount) % 1000)));

            // Multiple OrderBy and ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> OrderBy -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .OrderBy(f => f.Int)
                .ThenByDescending(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.Int)
                .ThenByDescending(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Orderby subquery -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .OrderBy(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy subquery -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())
                .ThenBy(f => f.Children.Where(c => c.Grade > 100).Count())));

            // Nested ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy(OrderBy -> ThenBy -> Select)", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> ThenBy) -> ThenBy(OrderBy -> ThenBy)", b => getQuery(b)
                .OrderBy(f => f.Children
                    .OrderBy(c => c.Grade)
                    .ThenBy(c => c.Pets.Count))
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            // Nested expressions with ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy(OrderBy -> ThenBy -> Take -> Select)", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Take(1)
                    .Select(p => p.FamilyName + p.GivenName))));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> ThenBy -> Take -> OrderBy -> ThenBy) -> ThenBy(OrderBy -> ThenBy)", b => getQuery(b)
                .OrderBy(f => f.Children
                    .OrderBy(c => c.Grade)
                    .ThenByDescending(c => c.Pets.Count)
                    .Take(10)
                    .OrderByDescending(c => c.GivenName)
                    .ThenBy(c => c.Gender))
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            // On a new object

            inputs.Add(new LinqTestInput(
                "Select -> OrderBy -> ThenBy", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    ChildrenPetCount = f.Children.Select(c => c.Pets.Count()).Sum()
                })
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> ThenBy", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    Name = c.GivenName,
                    SpecialPetCount = c.Pets.Where(p => p.GivenName.Length > 5).Count()
                })
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber))));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> ThenBy", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    Name = c.GivenName,
                    SpecialPetCount = c.Pets.Where(p => p.GivenName.Length > 5).Count()
                }))
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber)
                .Select(r => r.FamilyId)));

            inputs.Add(new LinqTestInput(
                "Select(new(Where, Sum) -> OrderBy(Count) -> ThenBy)", b => getQuery(b)
                .Select(f => new {
                    ChildrenWithPets = f.Children.Where(c => c.Pets.Any()),
                    TotalExpenses = f.Records.Transactions.Sum(t => t.Amount)
                })
                .OrderByDescending(r => r.ChildrenWithPets.Count())
                .ThenByDescending(r => r.TotalExpenses)));

            inputs.Add(new LinqTestInput(
                "Select(new(Min, Count, SelectMany->Select->Distinct->Count)) -> OrderByDescending -> ThenBy", b => getQuery(b)
                .Select(f => new {
                    ParentGivenName = f.Parents.Min(p => p.GivenName),
                    ParentCount = f.Parents.Count(),
                    GoodChildrenCount = f.Children.Where(c => c.Grade > 95).Count(),
                    UniquePetsNameCount = f.Children.SelectMany(c => c.Pets).Select(p => p.GivenName).Distinct().Count()
                })
                .OrderByDescending(r => r.GoodChildrenCount)
                .ThenBy(r => r.UniquePetsNameCount)));

            // With other LINQ operators: Where, SelectMany, Distinct, Skip, Take, and aggregates

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> ThenBy", b => getQuery(b)
                .Where(f => f.Children.Any())
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Take", b => getQuery(b)
                .Where(f => f.Children.Any())
                .SelectMany(f => f.Children)
                .OrderBy(c => c.Grade)
                .ThenByDescending(c => c.Pets.Count())
                .Take(3)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Skip -> Take -> Where -> Select -> Distinct", b => getQuery(b)
                .Where(f => f.Children.Any())
                .SelectMany(f => f.Children)
                .OrderByDescending(c => c.Grade)
                .ThenBy(c => c.GivenName)
                .Skip(2)
                .Take(20)
                .Where(c => c.Pets.Where(p => p.GivenName.Length > 10).Any())
                .Select(c => c.GivenName)
                .Distinct()));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Select => Distinct => Take => OrderBy", b => getQuery(b)
                .Where(f => f.Children.Any())
                .SelectMany(f => f.Children)
                .OrderBy(c => c.Grade)
                .ThenByDescending(c => c.Pets.Count())
                .Select(c => c.GivenName)
                .Distinct()
                .Take(10)
                .Skip(5)
                .OrderBy(n => n.Length)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Take", b => getQuery(b)
                .Where(f => f.Children.Any())
                .SelectMany(f => f.Records.Transactions)
                .OrderBy(t => t.Type)
                .ThenBy(t => t.Amount)
                .Take(100)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderBy -> ThenBy", b => getQuery(b)
                .Take(100)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderBy -> ThenBy -> Skip", b => getQuery(b)
                .Take(100)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)
                .Skip(5)));

            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy -> ThenBy", b => getQuery(b)
                .Distinct()
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany(Select(new Where->Count)) -> Distinct -> OrderBy -> ThenBy", b => getQuery(b)
                .Where(f => f.Children.Any())
                .SelectMany(f => f.Children.Select(c => new {
                    Name = c.GivenName,
                    PetWithLongNames = c.Pets.Where(p => p.GivenName.Length > 8).Count()
                }))
                .Distinct()
                .OrderByDescending(r => r.Name)
                .ThenBy(r => r.PetWithLongNames)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Any) -> ThenBy(Any)", b => getQuery(b)
                .OrderBy(f => f.Children.Any(c => c.Grade > 90))
                .ThenByDescending(f => f.Parents.Any(p => p.GivenName.Length > 10))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Min) -> ThenBy(Max) -> ThenBy(Sum) -> ThenBy(Avg)", b => getQuery(b)
                .OrderBy(f => f.Children.Min(c => c.GivenName))
                .ThenByDescending(f => f.Parents.Max(p => p.GivenName))
                .ThenBy(f => f.Records.Transactions.Sum(t => t.Amount))
                .ThenByDescending(f => f.Records.Transactions.Average(t => t.Amount))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void TestDistinctSelectManyIssues()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // these tests need a fix in the ServiceInterop
            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy -> Take",
                b => getQuery(b).Select(f => f.Int).Distinct().OrderBy(x => x).Take(10)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Distinct -> Take",
                b => getQuery(b).Select(f => f.Int).OrderBy(x => x).Distinct().Take(10)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestDistinctTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Simple distinct
            // Select -> Distinct for all data types
            inputs.Add(new LinqTestInput(
                "Distinct string",
                b => getQuery(b).Select(f => f.FamilyId).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct int",
                b => getQuery(b).Select(f => f.Int).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct bool",
                b => getQuery(b).Select(f => f.IsRegistered).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct nullable int",
                b => getQuery(b).Where(f => f.NullableInt != null).Select(f => f.NullableInt).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct null",
                b => getQuery(b).Where(f => f.NullObject != null).Select(f => f.NullObject).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct children",
                b => getQuery(b).SelectMany(f => f.Children).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct parent",
                b => getQuery(b).SelectMany(f => f.Parents).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct family",
                b => getQuery(b).Distinct()));

            inputs.Add(new LinqTestInput(
                "Multiple distincts",
                b => getQuery(b).Distinct().Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct new obj",
                b => getQuery(b).Select(f => new { Parents = f.Parents.Count(), Children = f.Children.Count() }).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct new obj",
                b => getQuery(b).Select(f => new { Parents = f.Parents.Count(), Children = f.Children.Count() }).Select(f => f.Parents).Distinct()));

            // Distinct + Take
            inputs.Add(new LinqTestInput(
                "Distinct -> Take",
                b => getQuery(b).Select(f => f.Int).Distinct().Take(10)));

            inputs.Add(new LinqTestInput(
                "Take -> Distinct",
                b => getQuery(b).Select(f => f.Int).Take(10).Distinct()));

            // Distinct + Order By
            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy",
                b => getQuery(b).Select(f => f.Int).Distinct().OrderBy(x => x)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Distinct",
                b => getQuery(b).OrderBy(f => f.Int).Distinct()));

            // Distinct + Order By + Take
            inputs.Add(new LinqTestInput(
                "Distinct -> Take -> OrderBy",
                b => getQuery(b).Select(f => f.Int).Distinct().Take(10).OrderBy(x => x)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Take -> Distinct",
                b => getQuery(b).Select(f => f.Int).OrderBy(x => x).Take(10).Distinct()));

            // Distinct + Where
            inputs.Add(new LinqTestInput(
                "Where -> Distinct",
                b => getQuery(b).Select(f => f.Int).Where(x => x > 10).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct -> Where",
                b => getQuery(b).Select(f => f.Int).Distinct().Where(x => x > 10)));

            // SelectMany w Distinct
            inputs.Add(new LinqTestInput(
                "SelectMany(Select obj) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select)) -> Distinct",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select -> Distinct))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)
                    .Distinct()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select -> Select) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet.GivenName)
                        .Select(name => name.Count())))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {} -> Select) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        }).Select(p => p.child))
                    .Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {}) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {} -> Distinct))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })
                        .Distinct()))));

            // SelectMany(Distinct)
            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20).Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct().Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct().OrderBy(f => f.GivenName.Length)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct().OrderBy(f => f.GivenName.Length).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .Where(f => f.FamilyName.Count() < 20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).OrderBy(f => f.FamilyName)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).OrderBy(f => f.FamilyName).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Select",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Select(f => f.FamilyName.Count())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Select -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Select(f => f.FamilyName.Count()).Take(5)));

            // SelectMany(Select -> Distinct)
            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).OrderBy(n => n).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Where -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Where(n => n.Count() > 10).OrderBy(n => n).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName)).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Where(n => n.Count() > 10)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void ValidateDynamicLinq()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Select", b => getQuery(b).Select("FamilyId")));
            inputs.Add(new LinqTestInput("Where", b => getQuery(b).Where("FamilyId = \"some id\"")));
            inputs.Add(new LinqTestInput("Where longer", b => getQuery(b).Where("FamilyId = \"some id\" AND IsRegistered = True OR Int > 101")));
            // with parameters
            inputs.Add(new LinqTestInput("Where w/ parameters", b => getQuery(b).Where("FamilyId = @0 AND IsRegistered = @1 OR Int > @2", "some id", true, 101)));
            inputs.Add(new LinqTestInput("Where -> Select", b => getQuery(b).Where("FamilyId = \"some id\"").Select("Int")));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public async Task ValidateLinqQueries()
        {
            Container container = await testDb.CreateContainerAsync(new ContainerProperties (id : Guid.NewGuid().ToString("N"), partitionKeyPath : "/id" ));

            Parent mother = new Parent { FamilyName = "Wakefield", GivenName = "Robin" };
            Parent father = new Parent { FamilyName = "Miller", GivenName = "Ben" };
            Pet pet = new Pet { GivenName = "Fluffy" };
            Child child = new Child
            {
                FamilyName = "Merriam",
                GivenName = "Jesse",
                Gender = "female",
                Grade = 1,
                Pets = new List<Pet>() { pet, new Pet() { GivenName = "koko" } },
                Things = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } },
            };

            Address address = new Address { State = "NY", County = "Manhattan", City = "NY" };
            Family family = new Family { FamilyId = "WakefieldFamily", Parents = new Parent[] { mother, father }, Children = new Child[] { child }, IsRegistered = false, Int = 3, NullableInt = 5 , Id = "WakefieldFamily"};

            List<Family> fList = new List<Family>();
            fList.Add(family);

            container.CreateItemAsync<Family>(family).Wait();
            IOrderedQueryable<Family> query = container.GetItemLinqQueryable<Family>(allowSynchronousQueryExecution : true);

            IEnumerable<string> q1 = query.Select(f => f.Parents[0].FamilyName);
            Assert.AreEqual(q1.FirstOrDefault(), family.Parents[0].FamilyName);

            IEnumerable<int> q2 = query.Select(f => f.Children[0].Grade + 13);
            Assert.AreEqual(q2.FirstOrDefault(), family.Children[0].Grade + 13);

            IEnumerable<Family> q3 = query.Where(f => f.Children[0].Pets[0].GivenName == "Fluffy");
            Assert.AreEqual(q3.FirstOrDefault().FamilyId, family.FamilyId);

            IEnumerable<Family> q4 = query.Where(f => f.Children[0].Things["A"] == "B");
            Assert.AreEqual(q4.FirstOrDefault().FamilyId, family.FamilyId);

            for (int index = 0; index < 2; index++)
            {
                IEnumerable<Pet> q5 = query.Where(f => f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[index]);
                Assert.AreEqual(q5.FirstOrDefault().GivenName, family.Children[0].Pets[index].GivenName);
            }

            IEnumerable<dynamic> q6 = query.SelectMany(f => f.Children.Select(c => new { Id = f.FamilyId }));
            Assert.AreEqual(q6.FirstOrDefault().Id, family.FamilyId);

            string nullString = null;
            IEnumerable<Family> q7 = query.Where(f => nullString == f.FamilyId);
            Assert.IsNull(q7.FirstOrDefault());

            object nullObject = null;
            q7 = query.Where(f => f.NullObject == nullObject);
            Assert.AreEqual(q7.FirstOrDefault().FamilyId, family.FamilyId);

            q7 = query.Where(f => f.FamilyId == nullString);
            Assert.IsNull(q7.FirstOrDefault());

            IEnumerable<Family> q8 = query.Where(f => null == f.FamilyId);
            Assert.IsNull(q8.FirstOrDefault());

            IEnumerable<Family> q9 = query.Where(f => f.IsRegistered == false);
            Assert.AreEqual(q9.FirstOrDefault().FamilyId, family.FamilyId);

            dynamic q10 = query.Where(f => f.FamilyId.Equals("WakefieldFamily")).AsEnumerable().FirstOrDefault();
            Assert.AreEqual(q10.FamilyId, family.FamilyId);

            GuidClass guidObject = new GuidClass() { Id = new Guid("098aa945-7ed8-4c50-b7b8-bd99eddb54bc") };
            container.CreateItemAsync(guidObject).Wait();
            List<GuidClass> guidData = new List<GuidClass>() { guidObject };

            IOrderedQueryable<GuidClass> guid = container.GetItemLinqQueryable<GuidClass>(allowSynchronousQueryExecution: true);

            IQueryable<GuidClass> q11 = guid.Where(g => g.Id == guidObject.Id);
            Assert.AreEqual(((IEnumerable<GuidClass>)q11).FirstOrDefault().Id, guidObject.Id);

            IQueryable<GuidClass> q12 = guid.Where(g => g.Id.ToString() == guidObject.Id.ToString());
            Assert.AreEqual(((IEnumerable<GuidClass>)q12).FirstOrDefault().Id, guidObject.Id);

            ListArrayClass arrayObject = new ListArrayClass() { Id = "arrayObject", ArrayField = new int[] { 1, 2, 3 } };
            container.CreateItemAsync(arrayObject).Wait();

            IOrderedQueryable<ListArrayClass> listArrayQuery = container.GetItemLinqQueryable<ListArrayClass>(allowSynchronousQueryExecution : true);

            IEnumerable<dynamic> q13 = listArrayQuery.Where(a => a.ArrayField == arrayObject.ArrayField);
            Assert.AreEqual(q13.FirstOrDefault().Id, arrayObject.Id);

            int[] nullArray = null;
            q13 = listArrayQuery.Where(a => a.ArrayField == nullArray);
            Assert.IsNull(q13.FirstOrDefault());

            ListArrayClass listObject = new ListArrayClass() { Id = "listObject", ListField = new List<int> { 1, 2, 3 } };
            container.CreateItemAsync(listObject).Wait();
            List<ListArrayClass> listArrayObjectData = new List<ListArrayClass>() { arrayObject, listObject };

            IEnumerable<dynamic> q14 = listArrayQuery.Where(a => a.ListField == listObject.ListField);
            Assert.AreEqual(q14.FirstOrDefault().Id, listObject.Id);

            IEnumerable<dynamic> q15 = query.Where(f => f.NullableInt == null);
            Assert.AreEqual(q15.ToList().Count, 0);

            int? nullInt = null;
            q15 = query.Where(f => f.NullableInt == nullInt);
            Assert.AreEqual(q15.ToList().Count, 0);

            q15 = query.Where(f => f.NullableInt == 5);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = 5;
            q15 = query.Where(f => f.NullableInt == nullInt);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            q15 = query.Where(f => f.NullableInt == nullInt.Value);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = 3;
            q15 = query.Where(f => f.Int == nullInt);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            q15 = query.Where(f => f.Int == nullInt.Value);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = null;
            q15 = query.Where(f => f.Int == nullInt);
            Assert.AreEqual(q15.ToList().Count, 0);

            List<Family> v = fList.Where(f => f.Int > nullInt).ToList();

            q15 = query.Where(f => f.Int < nullInt);

            string doc1Id = "document1:x:'!@TT){}\"";
            Document doubleQoutesDocument = new Document() { Id = doc1Id };
            container.CreateItemAsync(doubleQoutesDocument).Wait();

            IQueryable<Document> docQuery = from book in container.GetItemLinqQueryable<Document>(allowSynchronousQueryExecution : true)
                           where book.Id == doc1Id
                           select book;

            Assert.AreEqual(docQuery.AsEnumerable().Single().Id, doc1Id);

            GreatFamily greatFamily = new GreatFamily() { Family = family };
            GreatGreatFamily greatGreatFamily = new GreatGreatFamily() { GreatFamilyId = Guid.NewGuid().ToString(), GreatFamily = greatFamily };
            container.CreateItemAsync(greatGreatFamily).Wait();
            List<GreatGreatFamily> greatGreatFamilyData = new List<GreatGreatFamily>() { greatGreatFamily };

            IOrderedQueryable<GreatGreatFamily> queryable = container.GetItemLinqQueryable<GreatGreatFamily>(allowSynchronousQueryExecution : true);

            IEnumerable<GreatGreatFamily> q16 = queryable.SelectMany(gf => gf.GreatFamily.Family.Children.Where(c => c.GivenName == "Jesse").Select(c => gf));

            Assert.AreEqual(q16.FirstOrDefault().GreatFamilyId, greatGreatFamily.GreatFamilyId);

            Sport sport = new Sport() { SportName = "Tennis", SportType = "Racquet" };
            container.CreateItemAsync(sport).Wait();
            List<Sport> sportData = new List<Sport>() { sport };

            IOrderedQueryable<Sport> sportQuery = container.GetItemLinqQueryable<Sport>(allowSynchronousQueryExecution : true);

            IEnumerable<Sport> q17 = sportQuery.Where(s => s.SportName == "Tennis");

            Assert.AreEqual(sport.SportName, q17.FirstOrDefault().SportName);

            Sport2 sport2 = new Sport2() { id = "json" };
            container.CreateItemAsync(sport2).Wait();
            List<Sport2> sport2Data = new List<Sport2>() { sport2 };

            IOrderedQueryable<Sport2> sport2Query = container.GetItemLinqQueryable<Sport2>(allowSynchronousQueryExecution: true);

            Func<bool, IQueryable<GuidClass>> getGuidQuery = useQuery => useQuery ? guid : guidData.AsQueryable();
            Func<bool, IQueryable<ListArrayClass>> getListArrayQuery = useQuery => useQuery ? listArrayQuery : listArrayObjectData.AsQueryable();
            Func<bool, IQueryable<GreatGreatFamily>> getGreatFamilyQuery = useQuery => useQuery ? queryable : greatGreatFamilyData.AsQueryable();
            Func<bool, IQueryable<Sport>> getSportQuery = useQuery => useQuery ? sportQuery : sportData.AsQueryable();
            Func<bool, IQueryable<Sport2>> getSport2Query = useQuery => useQuery ? sport2Query : sport2Data.AsQueryable();

            int? nullIntVal = null;
            int? nullableIntVal = 5;

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Select 1st parent family name", b => getQuery(b).Where(f => f.Parents.Any()).Select(f => f.Parents[0].FamilyName)));
            inputs.Add(new LinqTestInput("Select 1st children grade expr", b => getQuery(b).Where(f => f.Children.Any()).Select(f => f.Children[0].Grade + 13)));
            inputs.Add(new LinqTestInput("Filter 1st children's 1st pet name", b => getQuery(b).Where(f => f.Children.Any() && f.Children[0].Pets.Any() && f.Children[0].Pets[0].GivenName == "Fluffy")));
            inputs.Add(new LinqTestInput("Filter 1st children's thing A value", b => getQuery(b).Where(f => f.Children.Any() && f.Children[0].Things["A"] == "B")));
            inputs.Add(new LinqTestInput("Filter 1st children's gender -> Select his 1st pet", b => getQuery(b).Where(f => f.Children.Any() && f.Children[0].Pets.Any() && f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[0])));
            inputs.Add(new LinqTestInput("Filter 1st children's gender -> Select his 2nd pet", b => getQuery(b).Where(f => f.Children.Any() && f.Children[0].Pets.Count() > 1 && f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[1])));
            inputs.Add(new LinqTestInput("Select FamilyId of all children", b => getQuery(b).SelectMany(f => f.Children.Select(c => new { Id = f.FamilyId }))));
            inputs.Add(new LinqTestInput("Filter family with null Id", b => getQuery(b).Where(f => (string)null == f.FamilyId)));
            inputs.Add(new LinqTestInput("Filter family with null Id #2", b => getQuery(b).Where(f => f.FamilyId == (string)null)));
            inputs.Add(new LinqTestInput("Filter family with null object", b => getQuery(b).Where(f => f.NullObject == (object)null)));
            inputs.Add(new LinqTestInput("Filter family with null Id #3", b => getQuery(b).Where(f => null == f.FamilyId)));
            inputs.Add(new LinqTestInput("Filter registered family", b => getQuery(b).Where(f => f.IsRegistered == false)));
            inputs.Add(new LinqTestInput("Filter family by FamilyId", b => getQuery(b).Where(f => f.FamilyId.Equals("WakefieldFamily"))));
            inputs.Add(new LinqTestInput("Filter family nullable int", b => getQuery(b).Where(f => f.NullableInt == null)));
            inputs.Add(new LinqTestInput("Filter family nullable int #2", b => getQuery(b).Where(f => f.NullableInt == nullIntVal)));
            inputs.Add(new LinqTestInput("Filter family nullable int =", b => getQuery(b).Where(f => f.NullableInt == 5)));
            inputs.Add(new LinqTestInput("Filter nullableInt = nullInt", b => getQuery(b).Where(f => f.NullableInt == nullableIntVal)));
            inputs.Add(new LinqTestInput("Filter nullableInt = nullInt value", b => getQuery(b).Where(f => f.NullableInt == nullableIntVal.Value)));
            inputs.Add(new LinqTestInput("Filter int = nullInt", b => getQuery(b).Where(f => f.Int == nullableIntVal)));
            inputs.Add(new LinqTestInput("Filter int = nullInt value", b => getQuery(b).Where(f => f.Int == nullableIntVal.Value)));
            inputs.Add(new LinqTestInput("Filter int = nullInt", b => getQuery(b).Where(f => f.Int == nullIntVal)));
            inputs.Add(new LinqTestInput("Filter int < nullInt", b => getQuery(b).Where(f => f.Int < nullIntVal)));

            inputs.Add(new LinqTestInput("Guid filter by Id", b => getGuidQuery(b).Where(g => g.Id == guidObject.Id)));
            inputs.Add(new LinqTestInput("Guid filter by Id #2", b => getGuidQuery(b).Where(g => g.Id.ToString() == guidObject.Id.ToString())));
            inputs.Add(new LinqTestInput("Array compare", b => getListArrayQuery(b).Where(a => a.ArrayField == arrayObject.ArrayField)));
            inputs.Add(new LinqTestInput("Array compare null", b => getListArrayQuery(b).Where(a => a.ArrayField == nullArray)));
            inputs.Add(new LinqTestInput("List compare", b => getListArrayQuery(b).Where(a => a.ListField == listObject.ListField)));

            inputs.Add(new LinqTestInput("Nested great family query filter children name", b => getGreatFamilyQuery(b).SelectMany(gf => gf.GreatFamily.Family.Children.Where(c => c.GivenName == "Jesse").Select(c => gf))));
            inputs.Add(new LinqTestInput("Sport filter sport name", b => getSportQuery(b).Where(s => s.SportName == "Tennis")));
            inputs.Add(new LinqTestInput("Sport filter sport type", b => getSportQuery(b).Where(s => s.SportType == "Racquet")));
            inputs.Add(new LinqTestInput("Sport2 filter by id", b => getSport2Query(b).Where(s => s.id == "json")));
            this.ExecuteTestSuite(inputs);
        }

        internal static TValue CreateExecuteAndDeleteProcedure<TValue>(DocumentClient client,
            DocumentCollection collection,
            string transientProcedure,
            out StoredProcedureResponse<TValue> response)
        {
            // create
            StoredProcedure storedProcedure = new StoredProcedure
            {
                Id = "storedProcedure" + Guid.NewGuid().ToString(),
                Body = transientProcedure
            };
            StoredProcedure retrievedStoredProcedure = client.CreateStoredProcedureAsync(collection, storedProcedure).Result;

            // execute
            response = client.ExecuteStoredProcedureAsync<TValue>(retrievedStoredProcedure).Result;

            // delete
            client.Delete<StoredProcedure>(retrievedStoredProcedure.GetIdOrFullName());

            return response.Response;
        }

        [TestMethod]
        public void ValidateBasicQuery()
        {
            this.ValidateBasicQueryAsync().Wait();
        }

        private async Task ValidateBasicQueryAsync()
        {
            DocumentClient client = TestCommon.CreateClient(true);
            Documents.Database database = await client.ReadDatabaseAsync(string.Format("dbs/{0}", testDb.Id));

            string databaseName = database.Id;

            List<Database> queryResults = new List<Database>();
            //Simple Equality
            IQueryable<Documents.Database> dbQuery = from db in client.CreateDatabaseQuery()
                                           where db.Id == databaseName
                                           select db;
            IDocumentQuery<Documents.Database> documentQuery = dbQuery.AsDocumentQuery();

            while (documentQuery.HasMoreResults)
            {
                DocumentFeedResponse<Database> pagedResponse = await documentQuery.ExecuteNextAsync<Database>();
                Assert.IsNotNull(pagedResponse.ResponseHeaders, "ResponseHeaders is null");
                Assert.IsNotNull(pagedResponse.ActivityId, "Query ActivityId is null");
                queryResults.AddRange(pagedResponse);
            }

            Assert.AreEqual(1, queryResults.Count);
            Assert.AreEqual(databaseName, queryResults[0].Id);

            //Logical Or 
            dbQuery = from db in client.CreateDatabaseQuery()
                      where db.Id == databaseName || db.ResourceId == database.ResourceId
                      select db;
            documentQuery = dbQuery.AsDocumentQuery();

            while (documentQuery.HasMoreResults)
            {
                queryResults.AddRange(await documentQuery.ExecuteNextAsync<Database>());
            }

            Assert.AreEqual(2, queryResults.Count);
            Assert.AreEqual(databaseName, queryResults[0].Id);

            //Select Property
            IQueryable<string> idQuery = from db in client.CreateDatabaseQuery()
                                         where db.Id == databaseName
                                         select db.ResourceId;
            IDocumentQuery<string> documentIdQuery = idQuery.AsDocumentQuery();

            List<string> idResults = new List<string>();
            while (documentIdQuery.HasMoreResults)
            {
                idResults.AddRange(await documentIdQuery.ExecuteNextAsync<string>());
            }

            Assert.AreEqual(1, idResults.Count);
            Assert.AreEqual(database.ResourceId, idResults[0]);
        }

        [TestMethod]
        public async Task ValidateTransformQuery()
        {
            PartitionKeyDefinition partitionKeyDefinition = new PartitionKeyDefinition { Paths = new System.Collections.ObjectModel.Collection<string>(new[] { "/id" }), Kind = PartitionKind.Hash };
            DocumentCollection collection = new DocumentCollection
            {
                Id = Guid.NewGuid().ToString("N"),
                PartitionKey = partitionKeyDefinition
            };
            collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
            Database database = await cosmosClient.DocumentClient.ReadDatabaseAsync(string.Format("dbs/{0}", testDb.Id));
            collection = cosmosClient.DocumentClient.Create<DocumentCollection>(database.ResourceId, collection);
            int documentsToCreate = 100;
            for (int i = 0; i < documentsToCreate; i++)
            {
                dynamic myDocument = new Document();
                myDocument.Id = "doc" + i;
                myDocument.Title = "MyBook"; //Simple Property.
                myDocument.Languages = new Language[] { new Language { Name = "English", Copyright = "London Publication" }, new Language { Name = "French", Copyright = "Paris Publication" } }; //Array Property
                myDocument.Author = new Author { Name = "Don", Location = "France" }; //Complex Property
                myDocument.Price = 9.99;
                myDocument = await cosmosClient.DocumentClient.CreateDocumentAsync(collection.DocumentsLink, myDocument);
            }

            //Read response as dynamic.
            IQueryable<dynamic> docQuery = cosmosClient.DocumentClient.CreateDocumentQuery(collection.DocumentsLink, @"select * from root r where r.Title=""MyBook""", new FeedOptions { EnableCrossPartitionQuery = true });

            IDocumentQuery<dynamic> DocumentQuery = docQuery.AsDocumentQuery();
            DocumentFeedResponse<dynamic> queryResponse = await DocumentQuery.ExecuteNextAsync();

            Assert.IsNotNull(queryResponse.ResponseHeaders, "ResponseHeaders is null");
            Assert.IsNotNull(queryResponse.ActivityId, "ActivityId is null");
            Assert.AreEqual(documentsToCreate, queryResponse.Count);

            foreach (dynamic myBook in queryResponse)
            {
                Assert.AreEqual(myBook.Title.ToString(), "MyBook");
            }

            cosmosClient.DocumentClient.DeleteDocumentCollectionAsync(collection.SelfLink).Wait();
        }

        [TestMethod]
        public void ValidateDynamicDocumentQuery() //Ensure query on custom property of document.
        {
            Book myDocument = new Book();
            myDocument.Id = Guid.NewGuid().ToString();
            myDocument.Title = "My Book"; //Simple Property.
            myDocument.Languages = new Language[] { new Language { Name = "English", Copyright = "London Publication" }, new Language { Name = "French", Copyright = "Paris Publication" } }; //Array Property
            myDocument.Author = new Author { Name = "Don", Location = "France" }; //Complex Property
            myDocument.Price = 9.99;
            myDocument.Editions = new List<Edition>() { new Edition() { Name = "First", Year = 2001 }, new Edition() { Name = "Second", Year = 2005 } };

            //Create second document to make sure we have atleast one document which are filtered out of query.
            Book secondDocument = new Book
            {
                Id = Guid.NewGuid().ToString(),
                Title = "My Second Book",
                Languages = new Language[] { new Language { Name = "Spanish", Copyright = "Mexico Publication" } },
                Author = new Author { Name = "Carlos", Location = "Cancun" },
                Price = 25,
                Editions = new List<Edition>() { new Edition() { Name = "First", Year = 1970 } }
            };

            //Unfiltered execution.
            IOrderedQueryable<Book> bookDocQuery = testContainer.GetItemLinqQueryable<Book>(allowSynchronousQueryExecution : true);
            Func<bool, IQueryable<Book>> getBookQuery = useQuery => useQuery ? bookDocQuery : new List<Book>().AsQueryable();

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Simple Equality on custom property",
                b => from book in getBookQuery(b)
                      where book.Title == "My Book"
                      select book));
            inputs.Add(new LinqTestInput("Nested Property access",
                b => from book in getBookQuery(b)
                      where book.Author.Name == "Don"
                      select book));
            inputs.Add(new LinqTestInput("Array references & Project Author out..",
                b => from book in getBookQuery(b)
                      where book.Languages[0].Name == "English"
                      select book.Author));
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book => book.Languages).Where(lang => lang.Name == "French").Select(lang => lang.Copyright)));
            inputs.Add(new LinqTestInput("NumericRange query",
                b => from book in getBookQuery(b)
                      where book.Price < 10
                      select book.Author));
            inputs.Add(new LinqTestInput("Or query",
                b => from book in getBookQuery(b)
                      where book.Title == "My Book" || book.Author.Name == "Don"
                      select book));
            inputs.Add(new LinqTestInput("SelectMany query on a List type.",
                b => getBookQuery(b).SelectMany(book => book.Editions).Select(ed => ed.Name)));
            // Below samples are strictly speaking not Any equivalent. But they join and filter "all"
            // subchildren which match predicate. When SQL BE supports ANY, we can replace these with Any Flavor.
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book =>
                           book.Languages
                           .Where(lng => lng.Name == "English")
                           .Select(lng => book.Author))));
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book =>
                               book.Editions
                               .Where(edition => edition.Year == 2001)
                               .Select(lng => book.Author))));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void ValidateDynamicAttachmentQuery() //Ensure query on custom property of attachment.
        {
            IOrderedQueryable<SpecialAttachment2> attachmentQuery = testContainer.GetItemLinqQueryable<SpecialAttachment2>(allowSynchronousQueryExecution : true);
            Document myDocument = new Document();
            Func<bool, IQueryable<SpecialAttachment2>> getAttachmentQuery = useQuery => useQuery ? attachmentQuery : new List<SpecialAttachment2>().AsQueryable();

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Filter equality on custom property",
                b => from attachment in getAttachmentQuery(b)
                     where attachment.Title == "My Book Title2"
                     select attachment));
            inputs.Add(new LinqTestInput("Filter equality on custom property #2",
                b => from attachment in getAttachmentQuery(b)
                     where attachment.Title == "My Book Title"
                     select attachment));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestLinqTypeSystem()
        {
            Assert.AreEqual(null, TypeSystem.GetElementType(typeof(Book)));
            Assert.AreEqual(null, TypeSystem.GetElementType(typeof(Author)));

            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(Language[])));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(List<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(IList<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(IEnumerable<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(ICollection<Language>)));

            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(DerivedFooItem[])));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(List<FooItem>)));
            Assert.AreEqual(typeof(string), TypeSystem.GetElementType(typeof(MyList<string>)));
            Assert.AreEqual(typeof(Tuple<string, string>), TypeSystem.GetElementType(typeof(MyTupleList<string>)));

            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(DerivedFooCollection)));
            Assert.AreEqual(typeof(string), TypeSystem.GetElementType(typeof(FooStringCollection)));

            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<object>)));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<IFooItem>)));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<FooItem>)));
            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(FooTCollection<DerivedFooItem>)));
        }

        #region DataDocument type tests

        public class BaseDocument
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Id { get; set; }
            public string TypeName { get; set; }
        }

        public class DataDocument : BaseDocument
        {
            public int Number { get; set; }
        }

        private class QueryHelper
        {
            private readonly Container container;

            public QueryHelper(Container container)
            {
                this.container = container;
            }

            public IQueryable<T> Query<T>() where T : BaseDocument
            {
                IQueryable<T> query = this.container.GetItemLinqQueryable<T>(allowSynchronousQueryExecution : true)
                                       .Where(d => d.TypeName == "Hello");
                string queryString = query.ToString();
                return query;
            }
        }

        [TestMethod]
        public async Task ValidateLinqOnDataDocumentType()
        {
            Container container = await testDb.CreateContainerAsync(new ContainerProperties(id : nameof(ValidateLinqOnDataDocumentType), partitionKeyPath : "/id"));

            DataDocument doc = new DataDocument() { Id = Guid.NewGuid().ToString("N"), Number = 0, TypeName = "Hello" };
            container.CreateItemAsync(doc).Wait();

            QueryHelper queryHelper = new QueryHelper(container);
            IEnumerable<BaseDocument> result = queryHelper.Query<BaseDocument>();
            Assert.AreEqual(1, result.Count());

            BaseDocument baseDocument = result.FirstOrDefault<BaseDocument>();
            Assert.AreEqual(doc.Id, baseDocument.Id);

            BaseDocument iDocument = doc;
            IOrderedQueryable<DataDocument> q = container.GetItemLinqQueryable<DataDocument>(allowSynchronousQueryExecution : true);

            IEnumerable<DataDocument> iresult = from f in q
                                                where f.Id == iDocument.Id
                                                select f;
            DataDocument id = iresult.FirstOrDefault<DataDocument>();
            Assert.AreEqual(doc.Id, id.Id);
        }

        #endregion

        #region Book type tests
        public class Author
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Name { get; set; }
            public string Location { get; set; }
        }

        public class Language
        {
            public string Name { get; set; }
            public string Copyright { get; set; }
        }

        public class Edition
        {
            public string Name { get; set; }
            public int Year { get; set; }
        }

        public class Book
        {
            //Verify that we can override the propertyName but still can query them using .NET Property names.
            [JsonProperty(PropertyName = "title")]
            public string Title { get; set; }
            [JsonProperty(PropertyName = "name")]
            public string Name { get; set; }
            public Language[] Languages { get; set; }
            public Author Author { get; set; }
            public double Price { get; set; }
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Id { get; set; }
            public List<Edition> Editions { get; set; }
        }

        [TestMethod]
        public async Task ValidateServerSideQueryEvalWithPagination()
        {
            await this.ValidateServerSideQueryEvalWithPaginationScenario();
        }

        private async Task ValidateServerSideQueryEvalWithPaginationScenario()
        {
            PartitionKeyDefinition partitionKeyDefinition = new PartitionKeyDefinition { Paths = new System.Collections.ObjectModel.Collection<string>(new[] { "/title" }), Kind = PartitionKind.Hash };
            ContainerProperties cosmosContainerSettings = new ContainerProperties
            {
                Id = Guid.NewGuid().ToString(),
                PartitionKey = partitionKeyDefinition,
            };
            cosmosContainerSettings.IndexingPolicy.IndexingMode = Microsoft.Azure.Cosmos.IndexingMode.Consistent;

            Container collection = await testDb.CreateContainerAsync(cosmosContainerSettings);

            //Do script post to insert as many document as we could in a tight loop.
            string script = @"function() {
                var output = 0;
                var client = getContext().getCollection();
                function callback(err, docCreated) {
                    if(err) throw 'Error while creating document';
                    output++;
                    getContext().getResponse().setBody(output);
                    if(output < 50) 
                        client.createDocument(client.getSelfLink(), { id: 'testDoc' + output, title : 'My Book'}, {}, callback);                       
                };
                client.createDocument(client.getSelfLink(), { id: 'testDoc' + output, title : 'My Book'}, {}, callback); }";

            StoredProcedureExecuteResponse<int> scriptResponse = null;
            int totalNumberOfDocuments = GatewayTests.CreateExecuteAndDeleteCosmosProcedure(collection, script, out scriptResponse, "My Book");

            IOrderedQueryable<Book> linqQueryable = collection.GetItemLinqQueryable<Book>(allowSynchronousQueryExecution : true);
            int totalHit = linqQueryable.Where(book => book.Title == "My Book").Count();
            Assert.AreEqual(totalHit, totalNumberOfDocuments, "Didnt get all the documents");

        }

        #endregion

        public class SpecialAttachment2 //Non attachemnt derived.
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Name { get; set; }

            [JsonProperty(PropertyName = "contentType")]
            public string ContentType { get; set; }

            [JsonProperty(PropertyName = Constants.Properties.MediaLink)]
            public string Media { get; set; }

            public string Author { get; set; }
            public string Title { get; set; }
        }

        #region TypeSystem test reference classes
        public interface IFooItem { }

        public class FooItem : IFooItem { }

        public class DerivedFooItem : FooItem { }

        public class MyList<T> : List<T> { }

        public class MyTupleList<T> : List<Tuple<T, T>> { }

        public class DerivedFooCollection : IList<IFooItem>, IEnumerable<DerivedFooItem>
        {
            public int IndexOf(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void Insert(int index, IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void RemoveAt(int index)
            {
                throw new NotImplementedException();
            }

            public IFooItem this[int index]
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public void Add(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(IFooItem[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { throw new NotImplementedException(); }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<IFooItem> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator<DerivedFooItem> IEnumerable<DerivedFooItem>.GetEnumerator()
            {
                throw new NotImplementedException();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        public class FooStringCollection : IList<string>, IEnumerable<FooItem>
        {
            public int IndexOf(string item)
            {
                throw new NotImplementedException();
            }

            public void Insert(int index, string item)
            {
                throw new NotImplementedException();
            }

            public void RemoveAt(int index)
            {
                throw new NotImplementedException();
            }

            public string this[int index]
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public void Add(string item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(string item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(string[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { throw new NotImplementedException(); }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(string item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<string> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator<FooItem> IEnumerable<FooItem>.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        public class FooTCollection<T> : List<FooItem>, IEnumerable<T>
        {
            public new IEnumerator<T> GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }
        #endregion

        public override LinqTestOutput ExecuteTest(LinqTestInput input)
        {
            return LinqTestsCommon.ExecuteTest(input);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(335,29): error CS0029: Cannot implicitly convert type 'int' to 'bool',D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(335,29): error CS1662: Cannot convert lambda expression to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type,D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(339,51): error CS0019: Operator '>' cannot be applied to operands of type 'bool' and 'int',D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(347,51): error CS0019: Operator '>' cannot be applied to operands of type 'bool' and 'int',D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(373,30): error CS0023: Operator '-' cannot be applied to operand of type 'bool',D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(570,51): error CS0019: Operator '>' cannot be applied to operands of type 'bool' and 'int',D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs(590,69): error CS0019: Operator '>' cannot be applied to operands of type 'bool' and 'int'
######################################################################


######################################################################
Nr: 6 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos\tests\Microsoft.Azure.Cosmos.EmulatorTests\LinqGeneralBaselineTests.cs
Description: Error: Unable to create valid SyntaxTree for document: LinqGeneralBaselineTests.cs. Caught exception: System.ArgumentException: Syntax node is not within syntax tree
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CheckSyntaxNode(CSharpSyntaxNode syntax)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 58
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBinaryExpression(BinaryExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBinaryExpression(BinaryExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 197
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBinaryExpression(BinaryExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 42
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 146
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 126
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 42
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitExpressionStatement(ExpressionStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 121, Message: Syntax node is not within syntax tree
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.Azure.Cosmos.Services.Management.Tests.LinqProviderTests
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic;
    using System.Runtime.Serialization;
    using System.Threading.Tasks;
    using Microsoft.Azure.Cosmos.Linq;
    using Microsoft.Azure.Cosmos.SDK.EmulatorTests;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Newtonsoft.Json;
    using BaselineTest;
    using Microsoft.Azure.Documents;
    using Microsoft.Azure.Cosmos.Scripts;

    [Microsoft.Azure.Cosmos.SDK.EmulatorTests.TestClass]
    public class LinqGeneralBaselineTests : BaselineTests<LinqTestInput, LinqTestOutput>
    {
        private static CosmosClient cosmosClient;
        private static Cosmos.Database testDb;
        private static Container testContainer;
        private static Func<bool, IQueryable<Family>> getQuery;

        [ClassInitialize]
        public async static Task Initialize(TestContext textContext)
        {
            cosmosClient = TestCommon.CreateCosmosClient(true);
            DocumentClientSwitchLinkExtension.Reset("LinqTests");

            string dbName = $"{nameof(LinqGeneralBaselineTests)}-{Guid.NewGuid().ToString("N")}";
            testDb = await cosmosClient.CreateDatabaseAsync(dbName);

            getQuery = LinqTestsCommon.GenerateFamilyCosmosData(testDb, out testContainer);
        }

        [ClassCleanup]
        public async static Task CleanUp()
        {
            if (testDb != null)
            {
                await testDb.DeleteStreamAsync();
            }
        }

        public class Address
        {
            public string State;
            public string County;
            public string City;
        }

        public class GuidClass : LinqTestObject
        {
            [JsonProperty(PropertyName = "id")]
            public Guid Id;
        }

        public class ListArrayClass : LinqTestObject
        {
            [JsonProperty(PropertyName = "id")]
            public string Id;

            public int[] ArrayField;
            public List<int> ListField;
        }

        [DataContract]
        public class Sport : LinqTestObject
        {
            [DataMember(Name = "id")]
            public string SportName;

            [JsonProperty(PropertyName = "json")]
            [DataMember(Name = "data")]
            public string SportType;
        }

        public class Sport2 : LinqTestObject
        {
            [DataMember(Name = "data")]
            public string id;
        }

        [TestMethod]
        public void TestSelectMany()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            inputs.Add(new LinqTestInput("SelectMany(SelectMany(Where -> Select))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))));

            inputs.Add(new LinqTestInput("SelectMany(Where -> SelectMany(Where -> Select))",
                b => getQuery(b)
                .SelectMany(family => family.Children.Where(c => c.Grade > 10)
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))));

            inputs.Add(new LinqTestInput("SelectMany(SelectMany(Where -> Select new {}))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Select)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Select(n => n.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Where)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Where(n => n.Count() > 10))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select) -> Select",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName)).Select(n => n.Count())));

            inputs.Add(new LinqTestInput("SelectMany()", b => getQuery(b).SelectMany(root => root.Children)));

            inputs.Add(new LinqTestInput("SelectMany -> SelectMany", b => getQuery(b).SelectMany(f => f.Children).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput("SelectMany -> Where -> SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Children).Where(c => c.Pets.Count() > 0).SelectMany(c => c.Pets.Select(p => p.GivenName))));

            inputs.Add(new LinqTestInput("SelectMany -> Where -> SelectMany(Select new)", b => getQuery(b)
                .SelectMany(f => f.Children)
                .Where(c => c.Pets.Count() > 0)
                .SelectMany(c => c.Pets.Select(p => new { PetName = p.GivenName, OwnerName = c.GivenName }))));

            inputs.Add(new LinqTestInput("Where -> SelectMany", b => getQuery(b).Where(f => f.Children.Count() > 0).SelectMany(f => f.Children)));

            inputs.Add(new LinqTestInput("SelectMany -> Select", b => getQuery(b).SelectMany(f => f.Children).Select(c => c.FamilyName)));

            inputs.Add(new LinqTestInput("SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput("SelectMany(Select)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName))));

            inputs.Add(new LinqTestInput("SelectMany(Select -> Select)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Select(n => n.Count()))));

            inputs.Add(new LinqTestInput("SelectMany(Select -> Where)", b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Where(n => n.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(Take -> Where)", b => getQuery(b).SelectMany(f => f.Children.Take(2).Where(c => c.FamilyName.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(OrderBy -> Take -> Where)", b => getQuery(b).SelectMany(f => f.Children.OrderBy(c => c.Grade).Take(2).Where(c => c.FamilyName.Count() > 10))));

            inputs.Add(new LinqTestInput("SelectMany(Distinct -> Where)", b => getQuery(b).SelectMany(f => f.Children.Distinct().Where(c => c.FamilyName.Count() > 10))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestSimpleSubquery()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            inputs.Add(new LinqTestInput("Select -> Select", b => getQuery(b).Select(f => f.FamilyId).Select(n => n.Count())));

            inputs.Add(new LinqTestInput("Select -> Where", b => getQuery(b).Select(f => f.FamilyId).Where(id => id.Count() > 10)));

            inputs.Add(new LinqTestInput("Select -> OrderBy -> Take -> Select -> Orderby -> Take", b => getQuery(b).Select(x => x).OrderBy(x => x).Take(10).Select(f => f.FamilyId).OrderBy(n => n.Count()).Take(5)));

            inputs.Add(new LinqTestInput("Select -> Orderby -> Take -> Select -> Orderby -> Take", b => getQuery(b).Select(f => f).OrderBy(f => f.Children.Count()).Take(3).Select(x => x).OrderBy(f => f.Parents.Count()).Take(2)));

            inputs.Add(new LinqTestInput("Orderby -> Take -> Orderby -> Take", b => getQuery(b).OrderBy(f => f.Children.Count()).Take(3).OrderBy(f => f.Parents.Count()).Take(2)));

            inputs.Add(new LinqTestInput("Take -> Orderby -> Take", b => getQuery(b).Take(10).OrderBy(f => f.FamilyId).Take(1)));

            inputs.Add(new LinqTestInput("Take -> Where -> Take -> Where -> Take -> Where", b => getQuery(b).Take(10).Where(f => f.Children.Count() > 0).Take(9).Where(f => f.Parents.Count() > 0).Take(8).Where(f => f.FamilyId.Count() > 10)));

            inputs.Add(new LinqTestInput("Take -> Where -> Distinct -> Select -> Take -> Where", b => getQuery(b).Take(10).Where(f => f.Children.Count() > 0).Distinct().Select(f => new { f }).Take(8).Where(f => f.f.FamilyId.Count() > 10)));

            inputs.Add(new LinqTestInput("Distinct -> Select -> Take -> Where -> Take -> Where", b => getQuery(b).Distinct().Select(f => new { f }).Take(10).Where(f => f.f.Children.Count() > 0).Take(9).Where(f => f.f.Parents.Count() > 0)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestQueryFlattening()
        {
            // these queries should make more sense when combined with where and orderby
            // these tests verify the flattening part
            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("array create", b => getQuery(b).Select(f => f.Int).Select(i => new int[] { i })));
            inputs.Add(new LinqTestInput("unary operation", b => getQuery(b).Select(f => f.Int).Select(i => -i)));
            inputs.Add(new LinqTestInput("binary operation", b => getQuery(b).Select(f => f).Select(i => i.Int % 10 * i.Children.Count())));
            inputs.Add(new LinqTestInput("literal", b => getQuery(b).Select(f => f.Int).Select(i => 0)));
            inputs.Add(new LinqTestInput("function call", b => getQuery(b).Select(f => f.Parents).Select(p => p.Count())));
            inputs.Add(new LinqTestInput("object create", b => getQuery(b).Select(f => f.Parents).Select(p => new { parentCount = p.Count() })));
            inputs.Add(new LinqTestInput("conditional", b => getQuery(b).Select(f => f.Children).Select(c => c.Count() > 0 ? "have kids" : "no kids")));
            inputs.Add(new LinqTestInput("property ref + indexer", b => getQuery(b).Select(f => f)
                .Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 0)
                .Select(f => f.Children[0].Pets[0].GivenName)));

            inputs.Add(new LinqTestInput("array creation -> indexer", b => getQuery(b).Select(f => new int[] { f.Int }).Select(array => array[0])));
            inputs.Add(new LinqTestInput("unary, indexer, property, function call -> function call", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .Select(f => -f.Children[0].Pets.Count()).Select(i => Math.Abs(i))));
            inputs.Add(new LinqTestInput("binary operation, function call -> conditional", b => getQuery(b).Select(i => i.Int % 10 * i.Children.Count()).Select(i => i > 0 ? new int[] { i } : new int[] { })));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b)
                .Select(f => new { parentCount = f.Parents.Count(), childrenCount = f.Children.Count() })
                .Select(r => r.parentCount > 0 ? Math.Floor((double)r.childrenCount / r.parentCount) : 0)));
            inputs.Add(new LinqTestInput("indexer -> function call", b => getQuery(b).Select(f => f.Parents[0]).Select(p => string.Concat(p.FamilyName, p.GivenName))));
            inputs.Add(new LinqTestInput("conditional -> object creation", b => getQuery(b).Select(f => f.Parents.Count() > 0 ? f.Parents : new Parent[0]).Select(p => new { parentCount = p.Count() })));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b).Select(f => new { children = f.Children }).Select(c => c.children.Count() > 0 ? c.children[0].GivenName : "no kids")));
            inputs.Add(new LinqTestInput("object creation -> conditional", b => getQuery(b).Select(f => new { family = f, children = f.Children.Count() }).Select(f => f.children > 0 && f.family.Children[0].Pets.Count() > 0 ? f.family.Children[0].Pets[0].GivenName : "no kids")));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestSubquery()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------------------------
            // Subquery lambdas
            // --------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Pets.Count()))));
                
            inputs.Add(new LinqTestInput(
                "Select(Take)", b => getQuery(b)
                .Select(f => f.Children.Take(2))));
                
            inputs.Add(new LinqTestInput(
                "Select(Where)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Pets.Count() > 0))));
                
            inputs.Add(new LinqTestInput(
                "Select(Distinct)", b => getQuery(b)
                .Select(f => f.Children.Distinct())));
                
            inputs.Add(new LinqTestInput(
                "Select(Count)", b => getQuery(b)
                .Select(f => f.Children.Count(c => c.Grade > 80))));

            inputs.Add(new LinqTestInput(
                "Select(Sum)", b => getQuery(b)
                .Select(f => f.Children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "Where(Count)", b => getQuery(b)
                .Where(f => f.Children.Count(c => c.Pets.Count() > 0) > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Sum)", b => getQuery(b)
                .Where(f => f.Children.Sum(c => c.Grade) > 100)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Count)", b => getQuery(b)
                .OrderBy(f => f.Children.Count(c => c.Grade > 90))));

            // -------------------------------------------------------------
            // Mutilpe-transformations subquery lambdas
            // -------------------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select -> Distinct -> Count)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Gender).Distinct().Count())));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Sum)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Sum())));

            inputs.Add(new LinqTestInput(
                "Select(Select -> OrderBy -> Take)", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.GivenName).OrderBy(n => n.Length).Take(1))));

            inputs.Add(new LinqTestInput(
                "Select(SelectMany -> Select)", b => getQuery(b)
                .Select(f => f.Children.SelectMany(c => c.Pets).Select(c => c.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Count)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Count())));

            inputs.Add(new LinqTestInput(
                "Select(Where -> OrderBy -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).OrderBy(c => c.Pets.Count()).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Select -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Select(c => c.Pets.Count()).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(Where -> Select(array) -> Take)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50).Select(c => c.Pets).Take(3))));

            inputs.Add(new LinqTestInput(
                "Select(where -> Select -> Distinct)", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 50 && c.Pets.Count() > 0).Select(c => c.Gender).Distinct())));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy -> Take -> Select)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Grade).Take(1).Select(c => c.Gender))));

            inputs.Add(new LinqTestInput(
                "Select(OrderBy -> Take -> Select -> Average)", b => getQuery(b)
                .Select(f => f.Children.OrderBy(c => c.Pets.Count()).Take(2).Select(c => c.Grade).Average())));

            inputs.Add(new LinqTestInput(
                "Where(Select -> Count)", b => getQuery(b)
                .Where(f => f.Children.Select(c => c.Pets.Count()).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> Count)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> Sum)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).Sum(c => c.Grade) < 200)));

            inputs.Add(new LinqTestInput(
                "Where(Where -> OrderBy -> Take -> Select)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).OrderBy(c => c.Grade).Take(1).Where(c => c.Grade > 80).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select -> Where)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Pets.Count()).Where(x => x > 1))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Where -> Count)", b => getQuery(b)
                .OrderBy(f => f.Children.Where(c => c.Pets.Count() > 3).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy(Select -> Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.Select(c => c.Grade).Sum())));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> Take -> Sum)", b => getQuery(b)
                .OrderBy(f => f.Children.OrderBy(c => c.Pets.Count()).Take(2).Sum(c => c.Grade))));

            // ---------------------------------------------------------
            // Scalar and Built-in expressions with subquery lambdas
            // ---------------------------------------------------------

            // Unary

            inputs.Add(new LinqTestInput(
                "Where(unary (Where -> Count))", b => getQuery(b)
                .Where(f => -f.Children.Where(c => c.Grade < 20).Count() == 0)));

            // Binary

            inputs.Add(new LinqTestInput(
                "Select(binary with Count)", b => getQuery(b)
                .Select(f => 5 + f.Children.Count(c => c.Pets.Count() > 0))));
                
            inputs.Add(new LinqTestInput(
                "Select(constant + Where -> Count)", b => getQuery(b)
                .Select(f => 5 + f.Children.Where(c => c.Pets.Count() > 0).Count())));

            inputs.Add(new LinqTestInput(
                "Where((Where -> Count) % constant)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Count() > 0).Count() % 2 == 1)));

            // Conditional

            inputs.Add(new LinqTestInput(
                "Select(conditional Any ? Select : Select)", b => getQuery(b)
                .Select(f => f.Children.Any() ? f.Children.Select(c => c.GivenName) : f.Parents.Select(p => p.GivenName))));

            inputs.Add(new LinqTestInput(
                "Select(conditional Any(filter) ? Max : Sum)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Grade > 97) ? f.Children.Max(c => c.Grade) : f.Children.Sum(c => c.Grade))));

            // New array

            inputs.Add(new LinqTestInput(
                "Select(new array)", b => getQuery(b)
                .Select(f => new int[] { f.Children.Count(), f.Children.Sum(c => c.Grade) })));

            // New + member init

            inputs.Add(new LinqTestInput(
                "Select(new)", b => getQuery(b)
                .Select(f => new int[] { f.Children.Count(), f.Children.Sum(c => c.Grade) })));

            inputs.Add(new LinqTestInput(
               "Select(Select new)", b => getQuery(b)
               .Select(f => new { f.FamilyId, ChildrenPetCount = f.Children.Select(c => c.Pets.Count()) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where)", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 3) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where)", b => getQuery(b)
                .Select(f => new { f.FamilyId, GoodChildren = f.Children.Where(c => c.Grade > 90) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where -> Select)", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 3).Select(c => c.GivenName) })));

            inputs.Add(new LinqTestInput(
                "Select(new Where -> Count) -> Where", b => getQuery(b)
                .Select(f => new { Family = f, ChildrenCount = f.Children.Where(c => c.Grade > 0).Count() }).Where(f => f.ChildrenCount > 0)));

            // Array builtin functions

            inputs.Add(new LinqTestInput(
                "Select(Where -> Concat(Where))", b => getQuery(b)
                .Select(f => f.Children.Where(c => c.Grade > 90).Concat(f.Children.Where(c => c.Grade < 10)))));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Contains(Sum))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Contains(f.Children.Sum(c => c.Pets.Count())))));

            inputs.Add(new LinqTestInput(
                "Select(Select -> Contains(Where -> Count))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade).Contains(f.Children.Where(c => c.Grade > 50).Count()))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(array indexer)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Grade > 20).Count() >= 2)
                .Select(f => f.Children.Where(c => c.Grade > 20).ToArray()[1])));

            inputs.Add(new LinqTestInput(
                "Where -> Select(array indexer)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Grade > 20).Count() >= 2)
                .Select(f => f.Children.Where(c => c.Grade > 20).ToArray()[f.Children.Count() % 2])));

            // Math builtin functions

            inputs.Add(new LinqTestInput(
                "Select(Floor(sum(map), sum(map)))", b => getQuery(b)
                .Select(f => Math.Floor(1.0 * f.Children.Sum(c => c.Grade) / (f.Children.Sum(c => c.Pets.Count()) + 1)))));

            inputs.Add(new LinqTestInput(
                "Select(Pow(Sum(map), Count(Any)))", b => getQuery(b)
                .Select(f => Math.Pow(f.Children.Sum(c => c.Pets.Count()), f.Children.Count(c => c.Pets.Any(p => p.GivenName.Count() == 0 || p.GivenName.Substring(0, 1) == "A"))))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Log(Where -> Count))", b => getQuery(b)
                .OrderBy(f => Math.Log(f.Children.Where(c => c.Pets.Count() > 0).Count()))));

            // ------------------------------------------------------------------
            // Expression with subquery lambdas -> more transformations
            // ------------------------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Where", b => getQuery(b).Select(f => f.Children.Select(c => c.Pets.Count())).Where(x => x.Count() > 0)));
            
            // Customer requested scenario
            inputs.Add(new LinqTestInput(
                "Select(new w/ Where) -> Where -> OrderBy -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), SmartChildren = f.Children.Where(c => c.Grade > 90) })
                .Where(f => f.FamilyId.CompareTo("ABC") > 0 && f.SmartChildren.Count() > 0)
                .OrderBy(f => f.ChildrenCount)
                .Take(10)));
            // TODO https://github.com/Azure/azure-cosmos-dotnet-v3/issues/375
            //inputs.Add(new LinqTestInput(
            //    "Select(new w/ Where) -> Where -> OrderBy -> Take", b => getQuery(b)
            //    .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), SmartChildren = f.Children.Where(c => c.Grade > 90) })
            //    .Where(f => f.ChildrenCount > 2 && f.SmartChildren.Count() > 1)
            //    .OrderBy(f => f.FamilyId)
            //    .Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new { Select(Select), conditional Count Take }) -> Where -> Select(Select(Any))", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    ChildrenPetFirstChars = f.Children.Select(c => c.Pets.Select(p => p.GivenName.Substring(0, 1))),
                    FirstChild = f.Children.Count() > 0 ? f.Children.Take(1) : null
                })
                .Where(f => f.FirstChild != null)
                .Select(f => f.ChildrenPetFirstChars.Select(chArray => chArray.Any(a => f.FamilyId.StartsWith(a))))));

            inputs.Add(new LinqTestInput(
                "Select(new (Select(new (Select, Select))))", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    ChildrenProfile = f.Children.Select(c => new
                    {
                        Fullname = c.GivenName + " " + c.FamilyName,
                        PetNames = c.Pets.Select(p => p.GivenName),
                        ParentNames = f.Parents.Select(p => p.GivenName)
                    })
                })));

            // ------------------------------------------------
            // Subquery lambda -> subquery lamda
            // ------------------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(array) -> Where(Sum(map))", b => getQuery(b)
                .Select(f => f.Children).Where(children => children.Sum(c => c.Grade) > 100)));

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Select(Sum())", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Grade)).Select(children => children.Sum())));

            inputs.Add(new LinqTestInput(
                "Select(Select) -> Select(Sum(map))", b => getQuery(b)
                .Select(f => f.Children).Select(children => children.Sum(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "Where(Any binary) -> Select(Sum(map))", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Grade > 90) && f.IsRegistered)
                .Select(f => f.Children.Sum(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Where(Any binary) -> OrderBy(Count(filter)) -> Select(Sum(map))", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Grade > 90) && f.IsRegistered)
                .OrderBy(f => f.Children.Count(c => c.Things.Count() > 3))
                .Select(f => f.Children.Sum(c => c.Pets.Count()))));

            // ------------------------------
            // Nested subquery lambdas
            // ------------------------------

            inputs.Add(new LinqTestInput(
                "Select(Select(Select))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName.Count())))));

            inputs.Add(new LinqTestInput(
                "Select(Select(Select))", b => getQuery(b)
                .Select(f => f.Children.Select(c => c.Pets.Select(p => p)))));

            inputs.Add(new LinqTestInput(
                "Select(Select(new Count))", b => getQuery(b)
                .Select(f => f.Children
                    .Select(c => new
                    {
                        HasSiblingWithSameStartingChar = f.Children.Count(child => (child.GivenName + " ").Substring(0, 1) == (c.GivenName + " ").Substring(0, 1)) > 1
                    }))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(conditional ? Take : OrderBy -> Array indexer)", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .Select(f => f.Children.Count() == 1 ? f.Children.Take(1).ToArray()[0] : f.Children.OrderBy(c => c.Grade).ToArray()[1])));

            inputs.Add(new LinqTestInput(
                "Select(Where(Where -> Count) -> Select(new Count))", b => getQuery(b)
                .Select(f => f.Children
                    .Where(c => c.Pets
                        .Where(p => p.GivenName.Count() > 10 && p.GivenName.Substring(0, 1) == "A")
                        .Count() > 0)
                    .Select(c => new
                    {
                        HasSiblingWithSameStartingChar = f.Children.Count(child => (child.GivenName + " ").Substring(0, 1) == (c.GivenName + " ").Substring(0, 1)) > 1
                    }))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select(Select))", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName.Count())))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where(Any))", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Pets.Any(p => p.GivenName.Count() > 10)))));

            inputs.Add(new LinqTestInput(
                "Where(Where(Count) -> Count)", b => getQuery(b)
                .Where(f => f.Parents.Where(p => p.FamilyName.Count() > 10).Count() > 1)));

            inputs.Add(new LinqTestInput(
                "Where(Where(Where -> Count) -> Count)", b => getQuery(b)
                .Where(f => f.Children.Where(c => c.Pets.Where(p => p.GivenName.Count() > 15).Count() > 0).Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Where(Select(Select -> Any))", b => getQuery(b)
                .Where(f => f.Children.Select(c => c.Pets.Select(p => p.GivenName)).Any(t => t.Count() > 3))));

            // -------------------------------------
            // Expression -> Subquery lambdas
            // -------------------------------------

            inputs.Add(new LinqTestInput(
                "Select(new) -> Select(Select)", b => getQuery(b)
                .Select(f => new { f.FamilyId, Family = f }).Select(f => f.Family.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select(Select)", b => getQuery(b)
                .SelectMany(f => f.Children).Select(c => c.Pets.Select(p => p.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where) -> Where(Any) -> Select(Select)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Grade > 80))
                .Where(c => c.Pets.Any(p => p.GivenName.Count() > 20))
                .Select(c => c.Pets.Select(p => p.GivenName.Count()))));

            inputs.Add(new LinqTestInput(
                "Distinct -> Select(new) -> Where(Select(Select -> Any))", b => getQuery(b)
                .Distinct()
                .Select(f => new { f.FamilyId, ChildrenCount = f.Children.Count(), Family = f })
                .Where(f => f.Family.Children.Select(c => c.Pets.Select(p => p.GivenName)).Any(t => t.Count() > 3))));

            inputs.Add(new LinqTestInput(
                "Where -> Select(Select)", b => getQuery(b)
                .Where(f => f.Children.Count() > 0).Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Distinct -> Select(Select)", b => getQuery(b)
                .Distinct().Select(f => f.Children.Select(c => c.Pets.Count()))));

            inputs.Add(new LinqTestInput(
                "Take -> Select(Select)", b => getQuery(b)
                .Take(10).Select(f => f.Children.Select(c => c.Pets.Count()))));
            
            // ------------------
            // Any in lambda
            // ------------------

            inputs.Add(new LinqTestInput(
                "Select(Any w const array)", b => getQuery(b)
                .Select(f => new int[] { 1, 2, 3 }.Any())));
                
            inputs.Add(new LinqTestInput(
                "Select(Any)", b => getQuery(b)
                .Select(f => f.Children.Any())));
                
            inputs.Add(new LinqTestInput(
                "Select(Any w lambda)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Grade > 80))));
                
            inputs.Add(new LinqTestInput(
                "Select(new Any)", b => getQuery(b)
                .Select(f => new { f.FamilyId, HasGoodChildren = f.Children.Any(c => c.Grade > 80) })));
                
            inputs.Add(new LinqTestInput(
                "Select(new 2 Any)", b => getQuery(b)
                .Select(f => new { HasChildrenWithPets = f.Children.Any(c => c.Pets.Count() > 0), HasGoodChildren = f.Children.Any(c => c.Grade > 80) })));
                
            inputs.Add(new LinqTestInput(
                "Select(Nested Any)", b => getQuery(b)
                .Select(f => f.Children.Any(c => c.Pets.Any(p => p.GivenName.Count() > 10)))));

            inputs.Add(new LinqTestInput(
                "Where(Any)", b => getQuery(b)
                .Where(f => f.Children.Any(c => c.Pets.Count() > 0))));

            // Customer requested scenario
            inputs.Add(new LinqTestInput(
                "Where(simple expr && Any)", b => getQuery(b)
                .Where(f => f.FamilyId.Contains("a") && f.Children.Any(c => c.Pets.Count() > 0))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Any)", b => getQuery(b)
                .OrderBy(f => f.Children.Any(c => c.Pets.Count() > 3))));
            
            // ------------------------------------------------
            // SelectMany with Take and OrderBy in lambda
            // ------------------------------------------------

            inputs.Add(new LinqTestInput(
                "SelectMany(Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Take(2))));

            inputs.Add(new LinqTestInput(
                "SelectMany(OrderBy)", b => getQuery(b)
                .SelectMany(f => f.Children.OrderBy(c => c.Grade))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.FamilyName.Count() > 10).Take(2))));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> Take -> Select)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.FamilyName.Count() > 10).Take(2).Select(c => c.Grade))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void DebuggingTest()
        {
            
        }

        [TestMethod]
        [Owner("khdang")]
        [Ignore]
        public void TestSkipTake()
        {
            //TODO
            //V2 using V3 pipeline causing issue on accessing Continuation in CosmosQueryResponseMessageHeaders
            //This will be fine once we convert these test cases to use V3 pipeline

            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------------------
            // Skip - Take combinations
            // --------------------------------

            inputs.Add(new LinqTestInput(
                "Skip", b => getQuery(b)
                .Skip(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take", b => getQuery(b)
                .Skip(1).Take(2)));

            inputs.Add(new LinqTestInput(
                "Skip(negative number) -> Take", b => getQuery(b)
                .Skip(-1).Take(1)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take(negative number)", b => getQuery(b)
                .Skip(1).Take(-2)));

            inputs.Add(new LinqTestInput(
                "Skip -> Skip -> Take", b => getQuery(b)
                .Skip(1).Skip(2).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Take", b => getQuery(b)
                .Skip(3).Take(5).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Skip -> Take", b => getQuery(b)
                .Skip(1).Take(2).Skip(3).Take(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Take -> Skip", b => getQuery(b)
                .Skip(1).Take(2).Take(3).Skip(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Skip -> Take -> Take", b => getQuery(b)
                .Skip(5).Skip(2).Take(10).Take(3)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip", b => getQuery(b)
                .Take(7).Skip(3)));

            inputs.Add(new LinqTestInput(
                "Take -> Take -> Skip", b => getQuery(b)
                .Take(2).Take(3).Skip(5)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Skip", b => getQuery(b)
                .Take(3).Skip(1).Skip(2)));

            inputs.Add(new LinqTestInput(
                "Take -> Take -> Skip -> Skip", b => getQuery(b)
                .Take(5).Take(3).Skip(1).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Take -> Skip", b => getQuery(b)
                .Take(10).Skip(2).Take(5).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Skip -> Take", b => getQuery(b)
                .Take(10).Skip(4).Skip(2).Take(2)));

            // --------------------------
            // Select + Skip & Take
            // --------------------------

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(1).Take(2)));

            inputs.Add(new LinqTestInput(
                "Select -> Take -> Skip", b => getQuery(b)
                .Select(f => f.FamilyId).Take(2).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> Select", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(7).Take(13).Select(f => f.Count())));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Take -> Skip", b => getQuery(b)
                .Skip(5).Take(11).Select(f => f.Children.Count()).Take(7).Skip(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).Select(f => f.FamilyId).Take(7)));

            inputs.Add(new LinqTestInput(
                "Take -> Select -> Skip", b => getQuery(b)
                .Take(7).Select(f => f.FamilyId).Skip(3)));

            // ------------------------------
            // SelectMany + Skip & Take
            // ------------------------------

            inputs.Add(new LinqTestInput(
                "SelectMany -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Skip(7).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Skip -> Take -> SelectMany", b => getQuery(b)
                .SelectMany(f => f.Children).Skip(11).Take(3).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "Skip -> SelectMany -> Take -> Skip -> SelectMany", b => getQuery(b)
                .Skip(1).SelectMany(f => f.Children).Take(13).Skip(3).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> SelectMany -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).SelectMany(c => c.Pets).Skip(3).Take(4)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> SelectMany -> Skip -> SelectMany", b => getQuery(b)
                .Take(50).Skip(25).SelectMany(f => f.Children).Skip(10).SelectMany(c => c.Pets)));

            // ---------------------------
            // Where + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(3).Take(5)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 0).Skip(7).Take(11).Where(f => f.Tags.Count() > 2).Skip(1).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Where -> Skip", b => getQuery(b)
                .Skip(1).Take(25).Where(f => f.Int > 10).Skip(5)));

            inputs.Add(new LinqTestInput(
                "Take -> Where -> Skip", b => getQuery(b)
                .Take(25).Where(f => f.FamilyId.Contains("A")).Skip(10)));

            inputs.Add(new LinqTestInput(
                "Where -> Take -> Skip -> Where", b => getQuery(b)
                .Where(f => f.Children.Count() > 1).Take(10).Skip(3).Where(f => f.Int > 0)));

            // ---------------------------
            // OrderBy + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take -> OrderBy -> Take -> Skip", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(3).Take(11).OrderBy(f => f.FamilyId).Take(7).Skip(1)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> OrderBy", b => getQuery(b)
                .Skip(3).Take(43).OrderBy(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderByDescending -> Skip", b => getQuery(b)
                .Take(50).OrderByDescending(f => f.Int).Skip(13)));

            inputs.Add(new LinqTestInput(
                "Skip -> OrderByDescending -> Take", b => getQuery(b)
                .Skip(7).OrderByDescending(f => f.Int).Take(17)));

            // ---------------------------
            // Distinct + Skip & Take
            // ---------------------------

            inputs.Add(new LinqTestInput(
                "Distinct -> Skip -> Take", b => getQuery(b)
                .Distinct().Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Distinct", b => getQuery(b)
                .Skip(3).Take(11).Distinct()));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Distinct -> Skip -> Take -> Distinct -> Skip", b => getQuery(b)
                .Skip(10).Take(60).Select(f => f.Int).Distinct().Skip(15).Take(20).Distinct().Skip(7)));

            inputs.Add(new LinqTestInput(
                "Skip -> Distinct -> Skip -> Take", b => getQuery(b)
                .Skip(7).Distinct().Skip(20).Take(10)));

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> Distinct -> Skip", b => getQuery(b)
                .Take(30).Skip(10).Distinct().Skip(7)));

            // ---------------------------------------------------------------------------------
            // Select, SelectMany, Where, OrderBy, Distinct with Skip & Take in between
            // ---------------------------------------------------------------------------------

            // Select, SelectMany

            inputs.Add(new LinqTestInput(
                "Select(new) -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, f.Children }).SelectMany(c => c.Children).Skip(3).Take(10)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Select(c => c.GivenName).Skip(7).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> SelectMany -> Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).Take(20).SelectMany(f => f.Children).Skip(3).Select(c => c.GivenName).Take(5)));

            inputs.Add(new LinqTestInput(
                "Skip -> SelectMany -> Take -> Skip -> Select -> Take", b => getQuery(b)
                .Skip(10).SelectMany(f => f.Children).Take(10).Skip(1).Select(c => c.FamilyName).Take(7)));

            inputs.Add(new LinqTestInput(
                "Take -> SelectMany -> Skip -> Select -> Take", b => getQuery(b)
                .Take(30).SelectMany(f => f.Children).Skip(10).Select(c => c.Grade).Take(3)));

            // Select, Where

            inputs.Add(new LinqTestInput(
                "Select -> Where -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Children).Where(c => c.Count() > 0).Skip(3).Take(7)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Select -> Skip", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(7).Take(3).Select(f => f.FamilyId).Skip(2)));

            // Select, OrderBy

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> OrderBy", b => getQuery(b)
                .Select(f => f.FamilyId).Skip(1).Take(2).OrderBy(s => s)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> Take -> Skip -> Select", b => getQuery(b)
                .OrderByDescending(f => f.Int).Take(10).Skip(3).Select(f => f.Int + 1)));

            // Select, Distinct

            inputs.Add(new LinqTestInput(
                "Take -> Select -> Distinct -> Skip -> Take", b => getQuery(b)
                .Take(7).Select(f => f.Int).Distinct().Skip(1).Take(5)));

            // SelectMany, Where

            inputs.Add(new LinqTestInput(
                "SelectMany -> Where -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Where(c => c.Grade > 100).Skip(10).Take(20)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> SelectMany -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(10).SelectMany(f => f.Children).Take(7)));

            // SelectMany, OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> SelectMany -> SelectMany", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(10).SelectMany(f => f.Children).SelectMany(c => c.Pets)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(10).Take(20)));

            // SelectMany, Distinct

            inputs.Add(new LinqTestInput(
                "SelectMany -> Distinct -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children).Distinct().Skip(7).Take(11)));

            inputs.Add(new LinqTestInput(
                "Distinct -> Skip -> SelectMany", b => getQuery(b)
                .Distinct().Skip(3).SelectMany(f => f.Children)));

            // Where, OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Where -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Where(f => f.IsRegistered).Skip(11).Take(3)));

            inputs.Add(new LinqTestInput(
                "Skip -> Where -> Take -> OrderBy", b => getQuery(b)
                .Skip(20).Where(f => f.Children.Count() > 0).Take(10).OrderBy(f => f.Int)));

            // Where, Distinct

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> Distinct", b => getQuery(b)
                .Where(f => f.IsRegistered).Skip(3).Take(17).Distinct()));

            inputs.Add(new LinqTestInput(
                "Skip -> Distinct -> Where -> Take", b => getQuery(b)
                .Skip(22).Distinct().Where(f => f.Parents.Count() > 0).Take(7)));

            // -----------------------------------------
            // All basic operations with Skip & Take
            // -----------------------------------------

            // Start with Select

            inputs.Add(new LinqTestInput(
                "Select -> Where -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Where(id => id.Count() > 10).OrderBy(id => id).Skip(1).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select -> Where -> OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Select(f => f.FamilyId).Where(id => id.Count() > 10).OrderBy(id => id).Skip(1).Take(10)
                .Select(id => id + "_suffix").Where(id => id.Count() > 12).Skip(2).Take(4)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> OrderBy -> Skip -> Distinct -> Skip", b => getQuery(b)
                .Select(f => f.Records).Skip(5).OrderBy(r => r.Transactions.Count()).Skip(1).Distinct().Skip(3)));

            inputs.Add(new LinqTestInput(
                "Select(new(new(new(new(new))))) -> (Skip -> Select) x 6 -> Skip -> Where -> Take", b => getQuery(b)
                .Select(f => new { f.FamilyId, L1 = new { L2 = new { L3 = new { L4 = new { f.Records } } } } })
                .Skip(1).Select(f => f.L1)
                .Skip(2).Select(f => f.L2)
                .Skip(3).Select(f => f.L3)
                .Skip(4).Select(f => f.L4)
                .Skip(5).Select(f => f.Records)
                .Skip(6).Select(f => f.Transactions)
                .Skip(7).Where(t => t.Count() > 100)
                .Take(20)));

            inputs.Add(new LinqTestInput(
                "Select -> (Skip -> Select -> Where -> OrderBy -> Distinct -> Take) x 3 -> Skip -> Take", b => getQuery(b)
                .Select(f => new { L1 = f })
                .Skip(1).Select(f => f.L1).Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Distinct().Take(100)
                .Skip(2).Select(f => new { L2 = f }).Where(f => f.L2.FamilyId.CompareTo("A") > 0).OrderBy(f => f.L2.Int).Distinct().Take(50)
                .Skip(3).Select(f => f.L2).Where(f => f.Children.Count() > 1).OrderBy(f => f.IsRegistered).Distinct().Take(40)
                .Skip(4).Take(25)));

            // Start with Distinct

            inputs.Add(new LinqTestInput(
                "Distinct -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Distinct().Select(f => f.Records).Where(r => r.Transactions.Count() > 2).Skip(1).Take(10)));

            // Start with Where

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Skip(1).Take(5)));

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 10).OrderBy(f => f.FamilyId).Skip(1).Take(5)
                .Select(f => f.Records).Where(r => r.Transactions != null).Skip(1).Take(3)));

            inputs.Add(new LinqTestInput(
                "Where -> Skip -> Take -> SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.Int > 20).Skip(5).Take(20)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(5).Take(10)));

            // Start with OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Int).Skip(1).Take(10)
                .Select(f => f.Records).Where(r => r.Transactions.Count() > 10).Skip(2).Take(3)));

            // Start with Skip

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Skip(1).Take(10).Select(f => f.Children.Count()).Where(c => c > 1).Skip(1).Take(4)));

            inputs.Add(new LinqTestInput(
                "Skip -> Take -> Where -> Skip -> Take -> OrderBy -> Skip -> Take -> Select -> Skip -> Distinct -> Skip -> Take", b => getQuery(b)
                .Skip(2).Take(10).Where(f => f.Int > 10)
                .Skip(1).Take(9).OrderBy(f => f.FamilyId)
                .Skip(3).Take(5).Select(f => f.Children.Count())
                .Skip(1).Distinct()
                .Skip(1).Take(1)));

            // Start with Take

            inputs.Add(new LinqTestInput(
                "Take -> Skip -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Take(10).Skip(2).Where(f => f.IsRegistered).OrderBy(f => f.Int).Skip(1).Take(9)));

            inputs.Add(new LinqTestInput(
                "Take -> Distinct -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .Take(10).Distinct().Select(f => f.Children).Where(c => c.Count() > 0).Skip(2).Take(5)));

            // -----------------------------------------------------------------------------
            // All basic operations with Skip & Take with SelectMany in the middle
            // -----------------------------------------------------------------------------

            // SelectMany after Take

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> Take -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Records).Skip(1).Take(10)
                .SelectMany(r => r.Transactions).Skip(1).Take(9)));

            // SelectMany after Where

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> Skip -> Take", b => getQuery(b)
                .Where(f => f.IsRegistered)
                .SelectMany(f => f.Children).OrderBy(c => c.Grade).Skip(10).Take(20)));

            // Start with SelectMany

            inputs.Add(new LinqTestInput(
                "SelectMany -> Select -> Skip -> Take -> Select -> Where -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children)
                    .Select(c => c.FamilyName).Skip(1).Take(20)
                    .Select(n => n.Count()).Where(l => l > 10).Skip(2).Take(50)));

            // -------------------------------------------------------------
            // Nested Skip & Take in Select, SelectMany, Where, OrderBy
            // -------------------------------------------------------------

            // Nested with Select

            inputs.Add(new LinqTestInput(
                "Select(new(Where -> Skip)) -> Where", b => getQuery(b)
                .Select(f => new {
                    id = f.FamilyId,
                    GoodChildren = f.Children.Where(c => c.Grade > 75).Skip(1)
                })
                .Where(f => f.GoodChildren.Count() > 0)));

            inputs.Add(new LinqTestInput(
                "Select(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .Select(f => f.Children.Skip(1).Take(1)).Skip(3).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new(Skip -> Take, Skip, Take) -> Skip -> Take -> Where", b => getQuery(b)
                .Select(f => new {
                    v0 = f.Children.Skip(1).Take(2),
                    v1 = f.Parents.Skip(1),
                    v2 = f.Records.Transactions.Take(10)
                })
                .Skip(1).Take(20).Where(f => f.v0.Count() > 0).Take(10)));

            inputs.Add(new LinqTestInput(
                "Select(new(SelectMany -> SelectMany -> Distinct, OrderByDescending -> Take -> SelectMany -> Skip, Select -> OrderBy -> Skip -> Take -> Sum) -> Where -> Skip -> Take -> SelectMany -> Skip -> Take", b => getQuery(b)
                .Select(f => new {
                    v0 = f.Children.SelectMany(c => c.Pets.Skip(1).SelectMany(p => p.GivenName).Distinct()),
                    v1 = f.Children.OrderByDescending(c => c.Grade).Take(2).SelectMany(c => c.Pets.Select(p => p.GivenName).Skip(2)),
                    v2 = f.Records.Transactions.Select(t => t.Amount).OrderBy(a => a).Skip(10).Take(20).Sum()
                })
                .Where(f => f.v2 > 100).Skip(5).Take(20)
                .SelectMany(f => f.v1).Distinct().Skip(3).Take(22)));

            inputs.Add(new LinqTestInput(
                "Select -> Skip -> SelectMany(Skip -> OrderBy)", b => getQuery(b)
                .Select(f => f.Records).Skip(1).SelectMany(r => r.Transactions.Skip(10).OrderBy(t => t.Date))));

            // Nested with Where

            inputs.Add(new LinqTestInput(
                "Where -> Where(Skip -> Take -> Count) - > Skip -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 2).Where(f => f.Children.Skip(1).Take(10).Count() > 1).Skip(1).Take(10)));

            // Nested with OrderBy

            inputs.Add(new LinqTestInput(
                "OrderBy(Skip -> Take -> Count) -> Skip -> Take", b => getQuery(b)
                .OrderBy(f => f.Children.Skip(1).Take(5).Count())));

            // Nested with SelectMany

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).Take(2)).Skip(3).Take(20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> Take) -> Skip -> Take -> SelectMany(Skip -> Take) -> Skip -> Take", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).Take(2)).Skip(3).Take(20)
                .SelectMany(c => c.Pets.Skip(1).Take(2)).Skip(1).Take(10)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Where -> OrderBy -> Skip -> Distinct)", b => getQuery(b)
                .SelectMany(f => f.Children.Where(c => c.Grade > 10).OrderBy(c => c.Grade).Skip(1).Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Skip -> SelectMany(Skip -> Select) -> Take)", b => getQuery(b)
                .SelectMany(f => f.Children.Skip(1).SelectMany(c => c.Pets.Skip(1).Select(p => p.GivenName)).Take(10))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void TestUnsupportedScenarios()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // --------------------
            // Dictionary type
            // --------------------

            // Iterating through Dictionary type
            inputs.Add(new LinqTestInput("Iterating through Dictionary type", b => getQuery(b).Select(f => f.Children.Select(c => c.Things.Select(t => t.Key.Count() + t.Value.Count())))));

            // Get a count of a Dictionary type
            inputs.Add(new LinqTestInput("Getting Dictionary count", b => getQuery(b).Select(f => f.Children.Select(c => c.Things.Count()))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestOrderByTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Ascending
            inputs.Add(new LinqTestInput("Select -> order by", b => getQuery(b).Select(family => family.FamilyId).OrderBy(id => id)));
            inputs.Add(new LinqTestInput("Select -> order by -> Select", b => getQuery(b).Select(family => family.FamilyId).OrderBy(id => id).Select(x => x.Count())));
            inputs.Add(new LinqTestInput("Where -> OrderBy -> Select query",
                b => from f in getQuery(b)
                     where f.Int == 5 && f.NullableInt != null
                     orderby f.IsRegistered
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("Where -> OrderBy -> Select", b => getQuery(b).Where(f => f.Int == 5 && f.NullableInt != null).OrderBy(f => f.IsRegistered).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy query",
                b => from f in getQuery(b)
                     orderby f.FamilyId
                     select f));
            inputs.Add(new LinqTestInput("OrderBy", b => getQuery(b).OrderBy(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select query",
                b => from f in getQuery(b)
                     orderby f.FamilyId
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("OrderBy -> Select", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Take", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId).Take(10)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Select", b => getQuery(b).OrderBy(f => f.FamilyId).Select(f => f.FamilyId).Select(x => x)));

            // Descending
            inputs.Add(new LinqTestInput("Select -> order by", b => getQuery(b).Select(family => family.FamilyId).OrderByDescending(id => id)));
            inputs.Add(new LinqTestInput("Select -> order by -> Select", b => getQuery(b).Select(family => family.FamilyId).OrderByDescending(id => id).Select(x => x.Count())));
            inputs.Add(new LinqTestInput("Where -> OrderBy Desc -> Select query",
                b => from f in getQuery(b)
                     where f.Int == 5 && f.NullableInt != null
                     orderby f.IsRegistered descending
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("Where -> OrderBy Desc -> Select", b => getQuery(b).Where(f => f.Int == 5 && f.NullableInt != null).OrderByDescending(f => f.IsRegistered).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy Desc query",
                b => from f in getQuery(b)
                     orderby f.FamilyId descending
                     select f));
            inputs.Add(new LinqTestInput("OrderBy Desc", b => getQuery(b).OrderByDescending(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy Desc -> Select query",
                b => from f in getQuery(b)
                     orderby f.FamilyId descending
                     select f.FamilyId));
            inputs.Add(new LinqTestInput("OrderBy Desc -> Select", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Take", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId).Take(10)));
            inputs.Add(new LinqTestInput("OrderBy -> Select -> Select", b => getQuery(b).OrderByDescending(f => f.FamilyId).Select(f => f.FamilyId).Select(x => x)));
            inputs.Add(new LinqTestInput("OrderBy multiple expressions",
                b => from f in getQuery(b)
                     orderby f.FamilyId, f.Int
                     select f.FamilyId));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestThenByTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Ascending and descending

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenByDescending", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .ThenBy(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending -> ThenByDescending", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .ThenByDescending(f => f.Int)));

            // Subquery in OrderBy or in ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy subquery -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy subquery -> ThenBy subquery", b => getQuery(b)
                .OrderByDescending(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            // OrderBy and ThenBy by the same property (not a realistic scenario)

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.FamilyId)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenByDescending", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.FamilyId)));

            inputs.Add(new LinqTestInput(
                "OrderByDescending subquery -> ThenBy subquery", b => getQuery(b)
                .OrderByDescending(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Children.Where(c => c.Grade > 100).Count())));

            // OrderBy and ThenBy with epxressions

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.Int * 2)
                .ThenBy(f => f.FamilyId.Substring(2, 3))));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => !f.NullableInt.IsDefined())
                .ThenByDescending(f => f.Tags.Count() % 2)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.IsRegistered ? f.FamilyId : f.Int.ToString())
                .ThenBy(f => f.Records.Transactions.Max(t => t.Amount) % 1000)));

            // Multiple OrderBy and ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> OrderBy -> ThenBy", b => getQuery(b)
                .OrderByDescending(f => f.FamilyId)
                .OrderBy(f => f.Int)
                .ThenByDescending(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy -> ThenBy", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenBy(f => f.Int)
                .ThenByDescending(f => f.IsRegistered)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Orderby subquery -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .OrderBy(f => f.Children.Where(c => c.Grade > 100).Count())
                .ThenBy(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())));

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy subquery -> ThenBy subquery", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents.Where(p => p.GivenName.Length > 10).Count())
                .ThenBy(f => f.Children.Where(c => c.Grade > 100).Count())));

            // Nested ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy(OrderBy -> ThenBy -> Select)", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> ThenBy) -> ThenBy(OrderBy -> ThenBy)", b => getQuery(b)
                .OrderBy(f => f.Children
                    .OrderBy(c => c.Grade)
                    .ThenBy(c => c.Pets.Count))
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            // Nested expressions with ThenBy

            inputs.Add(new LinqTestInput(
                "OrderBy -> ThenBy(OrderBy -> ThenBy -> Take -> Select)", b => getQuery(b)
                .OrderBy(f => f.FamilyId)
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Take(1)
                    .Select(p => p.FamilyName + p.GivenName))));

            inputs.Add(new LinqTestInput(
                "OrderBy(OrderBy -> ThenBy -> Take -> OrderBy -> ThenBy) -> ThenBy(OrderBy -> ThenBy)", b => getQuery(b)
                .OrderBy(f => f.Children
                    .OrderBy(c => c.Grade)
                    .ThenByDescending(c => c.Pets.Count)
                    .Take(10)
                    .OrderByDescending(c => c.GivenName)
                    .ThenBy(c => c.Gender))
                .ThenByDescending(f => f.Parents
                    .OrderBy(p => p.FamilyName)
                    .ThenByDescending(p => p.GivenName)
                    .Select(p => p.FamilyName + p.GivenName))));

            // On a new object

            inputs.Add(new LinqTestInput(
                "Select -> OrderBy -> ThenBy", b => getQuery(b)
                .Select(f => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    ChildrenPetCount = f.Children.Select(c => c.Pets.Count()).Sum()
                })
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber)));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> ThenBy", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    Name = c.GivenName,
                    SpecialPetCount = c.Pets.Where(p => p.GivenName.Length > 5).Count()
                })
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber))));

            inputs.Add(new LinqTestInput(
                "SelectMany -> OrderBy -> ThenBy", b => getQuery(b)
                .SelectMany(f => f.Children.Select(c => new
                {
                    f.FamilyId,
                    FamilyNumber = f.Int,
                    ChildrenCount = f.Children.Count(),
                    Name = c.GivenName,
                    SpecialPetCount = c.Pets.Where(p => p.GivenName.Length > 5).Count()
                }))
                .OrderBy(r => r.FamilyId)
                .ThenBy(r => r.FamilyNumber)
                .Select(r => r.FamilyId)));

            inputs.Add(new LinqTestInput(
                "Select(new(Where, Sum) -> OrderBy(Count) -> ThenBy)", b => getQuery(b)
                .Select(f => new {
                    ChildrenWithPets = f.Children.Where(c => c.Pets.Count() > 0),
                    TotalExpenses = f.Records.Transactions.Sum(t => t.Amount)
                })
                .OrderByDescending(r => r.ChildrenWithPets.Count())
                .ThenByDescending(r => r.TotalExpenses)));

            inputs.Add(new LinqTestInput(
                "Select(new(Min, Count, SelectMany->Select->Distinct->Count)) -> OrderByDescending -> ThenBy", b => getQuery(b)
                .Select(f => new {
                    ParentGivenName = f.Parents.Min(p => p.GivenName),
                    ParentCount = f.Parents.Count(),
                    GoodChildrenCount = f.Children.Where(c => c.Grade > 95).Count(),
                    UniquePetsNameCount = f.Children.SelectMany(c => c.Pets).Select(p => p.GivenName).Distinct().Count()
                })
                .OrderByDescending(r => r.GoodChildrenCount)
                .ThenBy(r => r.UniquePetsNameCount)));

            // With other LINQ operators: Where, SelectMany, Distinct, Skip, Take, and aggregates

            inputs.Add(new LinqTestInput(
                "Where -> OrderBy -> ThenBy", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children)
                .OrderBy(c => c.Grade)
                .ThenByDescending(c => c.Pets.Count())
                .Take(3)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Skip -> Take -> Where -> Select -> Distinct", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children)
                .OrderByDescending(c => c.Grade)
                .ThenBy(c => c.GivenName)
                .Skip(2)
                .Take(20)
                .Where(c => c.Pets.Where(p => p.GivenName.Length > 10).Count() > 0)
                .Select(c => c.GivenName)
                .Distinct()));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Select => Distinct => Take => OrderBy", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children)
                .OrderBy(c => c.Grade)
                .ThenByDescending(c => c.Pets.Count())
                .Select(c => c.GivenName)
                .Distinct()
                .Take(10)
                .Skip(5)
                .OrderBy(n => n.Length)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany -> OrderBy -> ThenBy -> Take", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Records.Transactions)
                .OrderBy(t => t.Type)
                .ThenBy(t => t.Amount)
                .Take(100)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderBy -> ThenBy", b => getQuery(b)
                .Take(100)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Take -> OrderBy -> ThenBy -> Skip", b => getQuery(b)
                .Take(100)
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)
                .Skip(5)));

            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy -> ThenBy", b => getQuery(b)
                .Distinct()
                .OrderBy(f => f.IsRegistered)
                .ThenByDescending(f => f.Int)));

            inputs.Add(new LinqTestInput(
                "Where -> SelectMany(Select(new Where->Count)) -> Distinct -> OrderBy -> ThenBy", b => getQuery(b)
                .Where(f => f.Children.Count() > 0)
                .SelectMany(f => f.Children.Select(c => new {
                    Name = c.GivenName,
                    PetWithLongNames = c.Pets.Where(p => p.GivenName.Length > 8).Count()
                }))
                .Distinct()
                .OrderByDescending(r => r.Name)
                .ThenBy(r => r.PetWithLongNames)));

            inputs.Add(new LinqTestInput(
                "OrderBy(Any) -> ThenBy(Any)", b => getQuery(b)
                .OrderBy(f => f.Children.Any(c => c.Grade > 90))
                .ThenByDescending(f => f.Parents.Any(p => p.GivenName.Length > 10))));

            inputs.Add(new LinqTestInput(
                "OrderBy(Min) -> ThenBy(Max) -> ThenBy(Sum) -> ThenBy(Avg)", b => getQuery(b)
                .OrderBy(f => f.Children.Min(c => c.GivenName))
                .ThenByDescending(f => f.Parents.Max(p => p.GivenName))
                .ThenBy(f => f.Records.Transactions.Sum(t => t.Amount))
                .ThenByDescending(f => f.Records.Transactions.Average(t => t.Amount))));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        [Ignore]
        public void TestDistinctSelectManyIssues()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // these tests need a fix in the ServiceInterop
            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy -> Take",
                b => getQuery(b).Select(f => f.Int).Distinct().OrderBy(x => x).Take(10)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Distinct -> Take",
                b => getQuery(b).Select(f => f.Int).OrderBy(x => x).Distinct().Take(10)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestDistinctTranslation()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();

            // Simple distinct
            // Select -> Distinct for all data types
            inputs.Add(new LinqTestInput(
                "Distinct string",
                b => getQuery(b).Select(f => f.FamilyId).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct int",
                b => getQuery(b).Select(f => f.Int).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct bool",
                b => getQuery(b).Select(f => f.IsRegistered).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct nullable int",
                b => getQuery(b).Where(f => f.NullableInt != null).Select(f => f.NullableInt).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct null",
                b => getQuery(b).Where(f => f.NullObject != null).Select(f => f.NullObject).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct children",
                b => getQuery(b).SelectMany(f => f.Children).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct parent",
                b => getQuery(b).SelectMany(f => f.Parents).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct family",
                b => getQuery(b).Distinct()));

            inputs.Add(new LinqTestInput(
                "Multiple distincts",
                b => getQuery(b).Distinct().Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct new obj",
                b => getQuery(b).Select(f => new { Parents = f.Parents.Count(), Children = f.Children.Count() }).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct new obj",
                b => getQuery(b).Select(f => new { Parents = f.Parents.Count(), Children = f.Children.Count() }).Select(f => f.Parents).Distinct()));

            // Distinct + Take
            inputs.Add(new LinqTestInput(
                "Distinct -> Take",
                b => getQuery(b).Select(f => f.Int).Distinct().Take(10)));

            inputs.Add(new LinqTestInput(
                "Take -> Distinct",
                b => getQuery(b).Select(f => f.Int).Take(10).Distinct()));

            // Distinct + Order By
            inputs.Add(new LinqTestInput(
                "Distinct -> OrderBy",
                b => getQuery(b).Select(f => f.Int).Distinct().OrderBy(x => x)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Distinct",
                b => getQuery(b).OrderBy(f => f.Int).Distinct()));

            // Distinct + Order By + Take
            inputs.Add(new LinqTestInput(
                "Distinct -> Take -> OrderBy",
                b => getQuery(b).Select(f => f.Int).Distinct().Take(10).OrderBy(x => x)));

            inputs.Add(new LinqTestInput(
                "OrderBy -> Take -> Distinct",
                b => getQuery(b).Select(f => f.Int).OrderBy(x => x).Take(10).Distinct()));

            // Distinct + Where
            inputs.Add(new LinqTestInput(
                "Where -> Distinct",
                b => getQuery(b).Select(f => f.Int).Where(x => x > 10).Distinct()));

            inputs.Add(new LinqTestInput(
                "Distinct -> Where",
                b => getQuery(b).Select(f => f.Int).Distinct().Where(x => x > 10)));

            // SelectMany w Distinct
            inputs.Add(new LinqTestInput(
                "SelectMany(Select obj) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select)) -> Distinct",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select -> Distinct))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet)
                    .Distinct()))));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select -> Select) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => pet.GivenName)
                        .Select(name => name.Count())))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {} -> Select) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        }).Select(p => p.child))
                    .Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {}) -> Distinct)",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })))
                    .Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(SelectMany(Where -> Select new {} -> Distinct))",
                b => getQuery(b)
                .SelectMany(family => family.Children
                    .SelectMany(child => child.Pets
                        .Where(pet => pet.GivenName == "Fluffy")
                        .Select(pet => new
                        {
                            family = family.FamilyId,
                            child = child.GivenName,
                            pet = pet.GivenName
                        })
                        .Distinct()))));

            // SelectMany(Distinct)
            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Where -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Where(f => f.FamilyName.Count() < 20).Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> OrderBy -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .OrderBy(f => f).Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct().Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Distinct -> Take -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10).Distinct()
                    .Take(5).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct().OrderBy(f => f.GivenName.Length)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Distinct().OrderBy(f => f.GivenName.Length).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Distinct -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .OrderBy(f => f).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Where -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Where(f => f.FamilyName.Count() > 10)
                    .Where(f => f.FamilyName.Count() < 20)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> OrderBy",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).OrderBy(f => f.FamilyName)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).OrderBy(f => f.FamilyName).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Select",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Select(f => f.FamilyName.Count())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Distinct) -> Select -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Distinct()).Select(f => f.FamilyName.Count()).Take(5)));

            // SelectMany(Select -> Distinct)
            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).OrderBy(n => n).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Where -> OrderBy -> Take",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Where(n => n.Count() > 10).OrderBy(n => n).Take(5)));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName)).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct)",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.FamilyName).Distinct())));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Distinct",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Distinct()));

            inputs.Add(new LinqTestInput(
                "SelectMany(Select -> Distinct) -> Where",
                b => getQuery(b).SelectMany(f => f.Parents.Select(p => p.GivenName).Distinct()).Where(n => n.Count() > 10)));

            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void ValidateDynamicLinq()
        {
            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Select", b => getQuery(b).Select("FamilyId")));
            inputs.Add(new LinqTestInput("Where", b => getQuery(b).Where("FamilyId = \"some id\"")));
            inputs.Add(new LinqTestInput("Where longer", b => getQuery(b).Where("FamilyId = \"some id\" AND IsRegistered = True OR Int > 101")));
            // with parameters
            inputs.Add(new LinqTestInput("Where w/ parameters", b => getQuery(b).Where("FamilyId = @0 AND IsRegistered = @1 OR Int > @2", "some id", true, 101)));
            inputs.Add(new LinqTestInput("Where -> Select", b => getQuery(b).Where("FamilyId = \"some id\"").Select("Int")));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public async Task ValidateLinqQueries()
        {
            Container container = await testDb.CreateContainerAsync(new ContainerProperties (id : Guid.NewGuid().ToString("N"), partitionKeyPath : "/id" ));

            Parent mother = new Parent { FamilyName = "Wakefield", GivenName = "Robin" };
            Parent father = new Parent { FamilyName = "Miller", GivenName = "Ben" };
            Pet pet = new Pet { GivenName = "Fluffy" };
            Child child = new Child
            {
                FamilyName = "Merriam",
                GivenName = "Jesse",
                Gender = "female",
                Grade = 1,
                Pets = new List<Pet>() { pet, new Pet() { GivenName = "koko" } },
                Things = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } },
            };

            Address address = new Address { State = "NY", County = "Manhattan", City = "NY" };
            Family family = new Family { FamilyId = "WakefieldFamily", Parents = new Parent[] { mother, father }, Children = new Child[] { child }, IsRegistered = false, Int = 3, NullableInt = 5 , Id = "WakefieldFamily"};

            List<Family> fList = new List<Family>();
            fList.Add(family);

            container.CreateItemAsync<Family>(family).Wait();
            IOrderedQueryable<Family> query = container.GetItemLinqQueryable<Family>(allowSynchronousQueryExecution : true);

            IEnumerable<string> q1 = query.Select(f => f.Parents[0].FamilyName);
            Assert.AreEqual(q1.FirstOrDefault(), family.Parents[0].FamilyName);

            IEnumerable<int> q2 = query.Select(f => f.Children[0].Grade + 13);
            Assert.AreEqual(q2.FirstOrDefault(), family.Children[0].Grade + 13);

            IEnumerable<Family> q3 = query.Where(f => f.Children[0].Pets[0].GivenName == "Fluffy");
            Assert.AreEqual(q3.FirstOrDefault().FamilyId, family.FamilyId);

            IEnumerable<Family> q4 = query.Where(f => f.Children[0].Things["A"] == "B");
            Assert.AreEqual(q4.FirstOrDefault().FamilyId, family.FamilyId);

            for (int index = 0; index < 2; index++)
            {
                IEnumerable<Pet> q5 = query.Where(f => f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[index]);
                Assert.AreEqual(q5.FirstOrDefault().GivenName, family.Children[0].Pets[index].GivenName);
            }

            IEnumerable<dynamic> q6 = query.SelectMany(f => f.Children.Select(c => new { Id = f.FamilyId }));
            Assert.AreEqual(q6.FirstOrDefault().Id, family.FamilyId);

            string nullString = null;
            IEnumerable<Family> q7 = query.Where(f => nullString == f.FamilyId);
            Assert.IsNull(q7.FirstOrDefault());

            object nullObject = null;
            q7 = query.Where(f => f.NullObject == nullObject);
            Assert.AreEqual(q7.FirstOrDefault().FamilyId, family.FamilyId);

            q7 = query.Where(f => f.FamilyId == nullString);
            Assert.IsNull(q7.FirstOrDefault());

            IEnumerable<Family> q8 = query.Where(f => null == f.FamilyId);
            Assert.IsNull(q8.FirstOrDefault());

            IEnumerable<Family> q9 = query.Where(f => f.IsRegistered == false);
            Assert.AreEqual(q9.FirstOrDefault().FamilyId, family.FamilyId);

            dynamic q10 = query.Where(f => f.FamilyId.Equals("WakefieldFamily")).AsEnumerable().FirstOrDefault();
            Assert.AreEqual(q10.FamilyId, family.FamilyId);

            GuidClass guidObject = new GuidClass() { Id = new Guid("098aa945-7ed8-4c50-b7b8-bd99eddb54bc") };
            container.CreateItemAsync(guidObject).Wait();
            List<GuidClass> guidData = new List<GuidClass>() { guidObject };

            IOrderedQueryable<GuidClass> guid = container.GetItemLinqQueryable<GuidClass>(allowSynchronousQueryExecution: true);

            IQueryable<GuidClass> q11 = guid.Where(g => g.Id == guidObject.Id);
            Assert.AreEqual(((IEnumerable<GuidClass>)q11).FirstOrDefault().Id, guidObject.Id);

            IQueryable<GuidClass> q12 = guid.Where(g => g.Id.ToString() == guidObject.Id.ToString());
            Assert.AreEqual(((IEnumerable<GuidClass>)q12).FirstOrDefault().Id, guidObject.Id);

            ListArrayClass arrayObject = new ListArrayClass() { Id = "arrayObject", ArrayField = new int[] { 1, 2, 3 } };
            container.CreateItemAsync(arrayObject).Wait();

            IOrderedQueryable<ListArrayClass> listArrayQuery = container.GetItemLinqQueryable<ListArrayClass>(allowSynchronousQueryExecution : true);

            IEnumerable<dynamic> q13 = listArrayQuery.Where(a => a.ArrayField == arrayObject.ArrayField);
            Assert.AreEqual(q13.FirstOrDefault().Id, arrayObject.Id);

            int[] nullArray = null;
            q13 = listArrayQuery.Where(a => a.ArrayField == nullArray);
            Assert.IsNull(q13.FirstOrDefault());

            ListArrayClass listObject = new ListArrayClass() { Id = "listObject", ListField = new List<int> { 1, 2, 3 } };
            container.CreateItemAsync(listObject).Wait();
            List<ListArrayClass> listArrayObjectData = new List<ListArrayClass>() { arrayObject, listObject };

            IEnumerable<dynamic> q14 = listArrayQuery.Where(a => a.ListField == listObject.ListField);
            Assert.AreEqual(q14.FirstOrDefault().Id, listObject.Id);

            IEnumerable<dynamic> q15 = query.Where(f => f.NullableInt == null);
            Assert.AreEqual(q15.ToList().Count, 0);

            int? nullInt = null;
            q15 = query.Where(f => f.NullableInt == nullInt);
            Assert.AreEqual(q15.ToList().Count, 0);

            q15 = query.Where(f => f.NullableInt == 5);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = 5;
            q15 = query.Where(f => f.NullableInt == nullInt);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            q15 = query.Where(f => f.NullableInt == nullInt.Value);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = 3;
            q15 = query.Where(f => f.Int == nullInt);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            q15 = query.Where(f => f.Int == nullInt.Value);
            Assert.AreEqual(q15.FirstOrDefault().FamilyId, family.FamilyId);

            nullInt = null;
            q15 = query.Where(f => f.Int == nullInt);
            Assert.AreEqual(q15.ToList().Count, 0);

            List<Family> v = fList.Where(f => f.Int > nullInt).ToList();

            q15 = query.Where(f => f.Int < nullInt);

            string doc1Id = "document1:x:'!@TT){}\"";
            Document doubleQoutesDocument = new Document() { Id = doc1Id };
            container.CreateItemAsync(doubleQoutesDocument).Wait();

            IQueryable<Document> docQuery = from book in container.GetItemLinqQueryable<Document>(allowSynchronousQueryExecution : true)
                           where book.Id == doc1Id
                           select book;

            Assert.AreEqual(docQuery.AsEnumerable().Single().Id, doc1Id);

            GreatFamily greatFamily = new GreatFamily() { Family = family };
            GreatGreatFamily greatGreatFamily = new GreatGreatFamily() { GreatFamilyId = Guid.NewGuid().ToString(), GreatFamily = greatFamily };
            container.CreateItemAsync(greatGreatFamily).Wait();
            List<GreatGreatFamily> greatGreatFamilyData = new List<GreatGreatFamily>() { greatGreatFamily };

            IOrderedQueryable<GreatGreatFamily> queryable = container.GetItemLinqQueryable<GreatGreatFamily>(allowSynchronousQueryExecution : true);

            IEnumerable<GreatGreatFamily> q16 = queryable.SelectMany(gf => gf.GreatFamily.Family.Children.Where(c => c.GivenName == "Jesse").Select(c => gf));

            Assert.AreEqual(q16.FirstOrDefault().GreatFamilyId, greatGreatFamily.GreatFamilyId);

            Sport sport = new Sport() { SportName = "Tennis", SportType = "Racquet" };
            container.CreateItemAsync(sport).Wait();
            List<Sport> sportData = new List<Sport>() { sport };

            IOrderedQueryable<Sport> sportQuery = container.GetItemLinqQueryable<Sport>(allowSynchronousQueryExecution : true);

            IEnumerable<Sport> q17 = sportQuery.Where(s => s.SportName == "Tennis");

            Assert.AreEqual(sport.SportName, q17.FirstOrDefault().SportName);

            Sport2 sport2 = new Sport2() { id = "json" };
            container.CreateItemAsync(sport2).Wait();
            List<Sport2> sport2Data = new List<Sport2>() { sport2 };

            IOrderedQueryable<Sport2> sport2Query = container.GetItemLinqQueryable<Sport2>(allowSynchronousQueryExecution: true);

            Func<bool, IQueryable<GuidClass>> getGuidQuery = useQuery => useQuery ? guid : guidData.AsQueryable();
            Func<bool, IQueryable<ListArrayClass>> getListArrayQuery = useQuery => useQuery ? listArrayQuery : listArrayObjectData.AsQueryable();
            Func<bool, IQueryable<GreatGreatFamily>> getGreatFamilyQuery = useQuery => useQuery ? queryable : greatGreatFamilyData.AsQueryable();
            Func<bool, IQueryable<Sport>> getSportQuery = useQuery => useQuery ? sportQuery : sportData.AsQueryable();
            Func<bool, IQueryable<Sport2>> getSport2Query = useQuery => useQuery ? sport2Query : sport2Data.AsQueryable();

            int? nullIntVal = null;
            int? nullableIntVal = 5;

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Select 1st parent family name", b => getQuery(b).Where(f => f.Parents.Count() > 0).Select(f => f.Parents[0].FamilyName)));
            inputs.Add(new LinqTestInput("Select 1st children grade expr", b => getQuery(b).Where(f => f.Children.Count() > 0).Select(f => f.Children[0].Grade + 13)));
            inputs.Add(new LinqTestInput("Filter 1st children's 1st pet name", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 0 && f.Children[0].Pets[0].GivenName == "Fluffy")));
            inputs.Add(new LinqTestInput("Filter 1st children's thing A value", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Things["A"] == "B")));
            inputs.Add(new LinqTestInput("Filter 1st children's gender -> Select his 1st pet", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 0 && f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[0])));
            inputs.Add(new LinqTestInput("Filter 1st children's gender -> Select his 2nd pet", b => getQuery(b).Where(f => f.Children.Count() > 0 && f.Children[0].Pets.Count() > 1 && f.Children[0].Gender == "female").Select(f => f.Children[0].Pets[1])));
            inputs.Add(new LinqTestInput("Select FamilyId of all children", b => getQuery(b).SelectMany(f => f.Children.Select(c => new { Id = f.FamilyId }))));
            inputs.Add(new LinqTestInput("Filter family with null Id", b => getQuery(b).Where(f => (string)null == f.FamilyId)));
            inputs.Add(new LinqTestInput("Filter family with null Id #2", b => getQuery(b).Where(f => f.FamilyId == (string)null)));
            inputs.Add(new LinqTestInput("Filter family with null object", b => getQuery(b).Where(f => f.NullObject == (object)null)));
            inputs.Add(new LinqTestInput("Filter family with null Id #3", b => getQuery(b).Where(f => null == f.FamilyId)));
            inputs.Add(new LinqTestInput("Filter registered family", b => getQuery(b).Where(f => f.IsRegistered == false)));
            inputs.Add(new LinqTestInput("Filter family by FamilyId", b => getQuery(b).Where(f => f.FamilyId.Equals("WakefieldFamily"))));
            inputs.Add(new LinqTestInput("Filter family nullable int", b => getQuery(b).Where(f => f.NullableInt == null)));
            inputs.Add(new LinqTestInput("Filter family nullable int #2", b => getQuery(b).Where(f => f.NullableInt == nullIntVal)));
            inputs.Add(new LinqTestInput("Filter family nullable int =", b => getQuery(b).Where(f => f.NullableInt == 5)));
            inputs.Add(new LinqTestInput("Filter nullableInt = nullInt", b => getQuery(b).Where(f => f.NullableInt == nullableIntVal)));
            inputs.Add(new LinqTestInput("Filter nullableInt = nullInt value", b => getQuery(b).Where(f => f.NullableInt == nullableIntVal.Value)));
            inputs.Add(new LinqTestInput("Filter int = nullInt", b => getQuery(b).Where(f => f.Int == nullableIntVal)));
            inputs.Add(new LinqTestInput("Filter int = nullInt value", b => getQuery(b).Where(f => f.Int == nullableIntVal.Value)));
            inputs.Add(new LinqTestInput("Filter int = nullInt", b => getQuery(b).Where(f => f.Int == nullIntVal)));
            inputs.Add(new LinqTestInput("Filter int < nullInt", b => getQuery(b).Where(f => f.Int < nullIntVal)));

            inputs.Add(new LinqTestInput("Guid filter by Id", b => getGuidQuery(b).Where(g => g.Id == guidObject.Id)));
            inputs.Add(new LinqTestInput("Guid filter by Id #2", b => getGuidQuery(b).Where(g => g.Id.ToString() == guidObject.Id.ToString())));
            inputs.Add(new LinqTestInput("Array compare", b => getListArrayQuery(b).Where(a => a.ArrayField == arrayObject.ArrayField)));
            inputs.Add(new LinqTestInput("Array compare null", b => getListArrayQuery(b).Where(a => a.ArrayField == nullArray)));
            inputs.Add(new LinqTestInput("List compare", b => getListArrayQuery(b).Where(a => a.ListField == listObject.ListField)));

            inputs.Add(new LinqTestInput("Nested great family query filter children name", b => getGreatFamilyQuery(b).SelectMany(gf => gf.GreatFamily.Family.Children.Where(c => c.GivenName == "Jesse").Select(c => gf))));
            inputs.Add(new LinqTestInput("Sport filter sport name", b => getSportQuery(b).Where(s => s.SportName == "Tennis")));
            inputs.Add(new LinqTestInput("Sport filter sport type", b => getSportQuery(b).Where(s => s.SportType == "Racquet")));
            inputs.Add(new LinqTestInput("Sport2 filter by id", b => getSport2Query(b).Where(s => s.id == "json")));
            this.ExecuteTestSuite(inputs);
        }

        internal static TValue CreateExecuteAndDeleteProcedure<TValue>(DocumentClient client,
            DocumentCollection collection,
            string transientProcedure,
            out StoredProcedureResponse<TValue> response)
        {
            // create
            StoredProcedure storedProcedure = new StoredProcedure
            {
                Id = "storedProcedure" + Guid.NewGuid().ToString(),
                Body = transientProcedure
            };
            StoredProcedure retrievedStoredProcedure = client.CreateStoredProcedureAsync(collection, storedProcedure).Result;

            // execute
            response = client.ExecuteStoredProcedureAsync<TValue>(retrievedStoredProcedure).Result;

            // delete
            client.Delete<StoredProcedure>(retrievedStoredProcedure.GetIdOrFullName());

            return response.Response;
        }

        [TestMethod]
        public void ValidateBasicQuery()
        {
            this.ValidateBasicQueryAsync().Wait();
        }

        private async Task ValidateBasicQueryAsync()
        {
            DocumentClient client = TestCommon.CreateClient(true);
            Documents.Database database = await client.ReadDatabaseAsync(string.Format("dbs/{0}", testDb.Id));

            string databaseName = database.Id;

            List<Database> queryResults = new List<Database>();
            //Simple Equality
            IQueryable<Documents.Database> dbQuery = from db in client.CreateDatabaseQuery()
                                           where db.Id == databaseName
                                           select db;
            IDocumentQuery<Documents.Database> documentQuery = dbQuery.AsDocumentQuery();

            while (documentQuery.HasMoreResults)
            {
                DocumentFeedResponse<Database> pagedResponse = await documentQuery.ExecuteNextAsync<Database>();
                Assert.IsNotNull(pagedResponse.ResponseHeaders, "ResponseHeaders is null");
                Assert.IsNotNull(pagedResponse.ActivityId, "Query ActivityId is null");
                queryResults.AddRange(pagedResponse);
            }

            Assert.AreEqual(1, queryResults.Count);
            Assert.AreEqual(databaseName, queryResults[0].Id);

            //Logical Or 
            dbQuery = from db in client.CreateDatabaseQuery()
                      where db.Id == databaseName || db.ResourceId == database.ResourceId
                      select db;
            documentQuery = dbQuery.AsDocumentQuery();

            while (documentQuery.HasMoreResults)
            {
                queryResults.AddRange(await documentQuery.ExecuteNextAsync<Database>());
            }

            Assert.AreEqual(2, queryResults.Count);
            Assert.AreEqual(databaseName, queryResults[0].Id);

            //Select Property
            IQueryable<string> idQuery = from db in client.CreateDatabaseQuery()
                                         where db.Id == databaseName
                                         select db.ResourceId;
            IDocumentQuery<string> documentIdQuery = idQuery.AsDocumentQuery();

            List<string> idResults = new List<string>();
            while (documentIdQuery.HasMoreResults)
            {
                idResults.AddRange(await documentIdQuery.ExecuteNextAsync<string>());
            }

            Assert.AreEqual(1, idResults.Count);
            Assert.AreEqual(database.ResourceId, idResults[0]);
        }

        [TestMethod]
        public async Task ValidateTransformQuery()
        {
            PartitionKeyDefinition partitionKeyDefinition = new PartitionKeyDefinition { Paths = new System.Collections.ObjectModel.Collection<string>(new[] { "/id" }), Kind = PartitionKind.Hash };
            DocumentCollection collection = new DocumentCollection
            {
                Id = Guid.NewGuid().ToString("N"),
                PartitionKey = partitionKeyDefinition
            };
            collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
            Database database = await cosmosClient.DocumentClient.ReadDatabaseAsync(string.Format("dbs/{0}", testDb.Id));
            collection = cosmosClient.DocumentClient.Create<DocumentCollection>(database.ResourceId, collection);
            int documentsToCreate = 100;
            for (int i = 0; i < documentsToCreate; i++)
            {
                dynamic myDocument = new Document();
                myDocument.Id = "doc" + i;
                myDocument.Title = "MyBook"; //Simple Property.
                myDocument.Languages = new Language[] { new Language { Name = "English", Copyright = "London Publication" }, new Language { Name = "French", Copyright = "Paris Publication" } }; //Array Property
                myDocument.Author = new Author { Name = "Don", Location = "France" }; //Complex Property
                myDocument.Price = 9.99;
                myDocument = await cosmosClient.DocumentClient.CreateDocumentAsync(collection.DocumentsLink, myDocument);
            }

            //Read response as dynamic.
            IQueryable<dynamic> docQuery = cosmosClient.DocumentClient.CreateDocumentQuery(collection.DocumentsLink, @"select * from root r where r.Title=""MyBook""", new FeedOptions { EnableCrossPartitionQuery = true });

            IDocumentQuery<dynamic> DocumentQuery = docQuery.AsDocumentQuery();
            DocumentFeedResponse<dynamic> queryResponse = await DocumentQuery.ExecuteNextAsync();

            Assert.IsNotNull(queryResponse.ResponseHeaders, "ResponseHeaders is null");
            Assert.IsNotNull(queryResponse.ActivityId, "ActivityId is null");
            Assert.AreEqual(documentsToCreate, queryResponse.Count);

            foreach (dynamic myBook in queryResponse)
            {
                Assert.AreEqual(myBook.Title.ToString(), "MyBook");
            }

            cosmosClient.DocumentClient.DeleteDocumentCollectionAsync(collection.SelfLink).Wait();
        }

        [TestMethod]
        public void ValidateDynamicDocumentQuery() //Ensure query on custom property of document.
        {
            Book myDocument = new Book();
            myDocument.Id = Guid.NewGuid().ToString();
            myDocument.Title = "My Book"; //Simple Property.
            myDocument.Languages = new Language[] { new Language { Name = "English", Copyright = "London Publication" }, new Language { Name = "French", Copyright = "Paris Publication" } }; //Array Property
            myDocument.Author = new Author { Name = "Don", Location = "France" }; //Complex Property
            myDocument.Price = 9.99;
            myDocument.Editions = new List<Edition>() { new Edition() { Name = "First", Year = 2001 }, new Edition() { Name = "Second", Year = 2005 } };

            //Create second document to make sure we have atleast one document which are filtered out of query.
            Book secondDocument = new Book
            {
                Id = Guid.NewGuid().ToString(),
                Title = "My Second Book",
                Languages = new Language[] { new Language { Name = "Spanish", Copyright = "Mexico Publication" } },
                Author = new Author { Name = "Carlos", Location = "Cancun" },
                Price = 25,
                Editions = new List<Edition>() { new Edition() { Name = "First", Year = 1970 } }
            };

            //Unfiltered execution.
            IOrderedQueryable<Book> bookDocQuery = testContainer.GetItemLinqQueryable<Book>(allowSynchronousQueryExecution : true);
            Func<bool, IQueryable<Book>> getBookQuery = useQuery => useQuery ? bookDocQuery : new List<Book>().AsQueryable();

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Simple Equality on custom property",
                b => from book in getBookQuery(b)
                      where book.Title == "My Book"
                      select book));
            inputs.Add(new LinqTestInput("Nested Property access",
                b => from book in getBookQuery(b)
                      where book.Author.Name == "Don"
                      select book));
            inputs.Add(new LinqTestInput("Array references & Project Author out..",
                b => from book in getBookQuery(b)
                      where book.Languages[0].Name == "English"
                      select book.Author));
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book => book.Languages).Where(lang => lang.Name == "French").Select(lang => lang.Copyright)));
            inputs.Add(new LinqTestInput("NumericRange query",
                b => from book in getBookQuery(b)
                      where book.Price < 10
                      select book.Author));
            inputs.Add(new LinqTestInput("Or query",
                b => from book in getBookQuery(b)
                      where book.Title == "My Book" || book.Author.Name == "Don"
                      select book));
            inputs.Add(new LinqTestInput("SelectMany query on a List type.",
                b => getBookQuery(b).SelectMany(book => book.Editions).Select(ed => ed.Name)));
            // Below samples are strictly speaking not Any equivalent. But they join and filter "all"
            // subchildren which match predicate. When SQL BE supports ANY, we can replace these with Any Flavor.
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book =>
                           book.Languages
                           .Where(lng => lng.Name == "English")
                           .Select(lng => book.Author))));
            inputs.Add(new LinqTestInput("SelectMany",
                b => getBookQuery(b).SelectMany(book =>
                               book.Editions
                               .Where(edition => edition.Year == 2001)
                               .Select(lng => book.Author))));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void ValidateDynamicAttachmentQuery() //Ensure query on custom property of attachment.
        {
            IOrderedQueryable<SpecialAttachment2> attachmentQuery = testContainer.GetItemLinqQueryable<SpecialAttachment2>(allowSynchronousQueryExecution : true);
            Document myDocument = new Document();
            Func<bool, IQueryable<SpecialAttachment2>> getAttachmentQuery = useQuery => useQuery ? attachmentQuery : new List<SpecialAttachment2>().AsQueryable();

            List<LinqTestInput> inputs = new List<LinqTestInput>();
            inputs.Add(new LinqTestInput("Filter equality on custom property",
                b => from attachment in getAttachmentQuery(b)
                     where attachment.Title == "My Book Title2"
                     select attachment));
            inputs.Add(new LinqTestInput("Filter equality on custom property #2",
                b => from attachment in getAttachmentQuery(b)
                     where attachment.Title == "My Book Title"
                     select attachment));
            this.ExecuteTestSuite(inputs);
        }

        [TestMethod]
        public void TestLinqTypeSystem()
        {
            Assert.AreEqual(null, TypeSystem.GetElementType(typeof(Book)));
            Assert.AreEqual(null, TypeSystem.GetElementType(typeof(Author)));

            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(Language[])));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(List<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(IList<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(IEnumerable<Language>)));
            Assert.AreEqual(typeof(Language), TypeSystem.GetElementType(typeof(ICollection<Language>)));

            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(DerivedFooItem[])));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(List<FooItem>)));
            Assert.AreEqual(typeof(string), TypeSystem.GetElementType(typeof(MyList<string>)));
            Assert.AreEqual(typeof(Tuple<string, string>), TypeSystem.GetElementType(typeof(MyTupleList<string>)));

            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(DerivedFooCollection)));
            Assert.AreEqual(typeof(string), TypeSystem.GetElementType(typeof(FooStringCollection)));

            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<object>)));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<IFooItem>)));
            Assert.AreEqual(typeof(FooItem), TypeSystem.GetElementType(typeof(FooTCollection<FooItem>)));
            Assert.AreEqual(typeof(DerivedFooItem), TypeSystem.GetElementType(typeof(FooTCollection<DerivedFooItem>)));
        }

        #region DataDocument type tests

        public class BaseDocument
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Id { get; set; }
            public string TypeName { get; set; }
        }

        public class DataDocument : BaseDocument
        {
            public int Number { get; set; }
        }

        private class QueryHelper
        {
            private readonly Container container;

            public QueryHelper(Container container)
            {
                this.container = container;
            }

            public IQueryable<T> Query<T>() where T : BaseDocument
            {
                IQueryable<T> query = this.container.GetItemLinqQueryable<T>(allowSynchronousQueryExecution : true)
                                       .Where(d => d.TypeName == "Hello");
                string queryString = query.ToString();
                return query;
            }
        }

        [TestMethod]
        public async Task ValidateLinqOnDataDocumentType()
        {
            Container container = await testDb.CreateContainerAsync(new ContainerProperties(id : nameof(ValidateLinqOnDataDocumentType), partitionKeyPath : "/id"));

            DataDocument doc = new DataDocument() { Id = Guid.NewGuid().ToString("N"), Number = 0, TypeName = "Hello" };
            container.CreateItemAsync(doc).Wait();

            QueryHelper queryHelper = new QueryHelper(container);
            IEnumerable<BaseDocument> result = queryHelper.Query<BaseDocument>();
            Assert.AreEqual(1, result.Count());

            BaseDocument baseDocument = result.FirstOrDefault<BaseDocument>();
            Assert.AreEqual(doc.Id, baseDocument.Id);

            BaseDocument iDocument = doc;
            IOrderedQueryable<DataDocument> q = container.GetItemLinqQueryable<DataDocument>(allowSynchronousQueryExecution : true);

            IEnumerable<DataDocument> iresult = from f in q
                                                where f.Id == iDocument.Id
                                                select f;
            DataDocument id = iresult.FirstOrDefault<DataDocument>();
            Assert.AreEqual(doc.Id, id.Id);
        }

        #endregion

        #region Book type tests
        public class Author
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Name { get; set; }
            public string Location { get; set; }
        }

        public class Language
        {
            public string Name { get; set; }
            public string Copyright { get; set; }
        }

        public class Edition
        {
            public string Name { get; set; }
            public int Year { get; set; }
        }

        public class Book
        {
            //Verify that we can override the propertyName but still can query them using .NET Property names.
            [JsonProperty(PropertyName = "title")]
            public string Title { get; set; }
            [JsonProperty(PropertyName = "name")]
            public string Name { get; set; }
            public Language[] Languages { get; set; }
            public Author Author { get; set; }
            public double Price { get; set; }
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Id { get; set; }
            public List<Edition> Editions { get; set; }
        }

        [TestMethod]
        public async Task ValidateServerSideQueryEvalWithPagination()
        {
            await this.ValidateServerSideQueryEvalWithPaginationScenario();
        }

        private async Task ValidateServerSideQueryEvalWithPaginationScenario()
        {
            PartitionKeyDefinition partitionKeyDefinition = new PartitionKeyDefinition { Paths = new System.Collections.ObjectModel.Collection<string>(new[] { "/title" }), Kind = PartitionKind.Hash };
            ContainerProperties cosmosContainerSettings = new ContainerProperties
            {
                Id = Guid.NewGuid().ToString(),
                PartitionKey = partitionKeyDefinition,
            };
            cosmosContainerSettings.IndexingPolicy.IndexingMode = Microsoft.Azure.Cosmos.IndexingMode.Consistent;

            Container collection = await testDb.CreateContainerAsync(cosmosContainerSettings);

            //Do script post to insert as many document as we could in a tight loop.
            string script = @"function() {
                var output = 0;
                var client = getContext().getCollection();
                function callback(err, docCreated) {
                    if(err) throw 'Error while creating document';
                    output++;
                    getContext().getResponse().setBody(output);
                    if(output < 50) 
                        client.createDocument(client.getSelfLink(), { id: 'testDoc' + output, title : 'My Book'}, {}, callback);                       
                };
                client.createDocument(client.getSelfLink(), { id: 'testDoc' + output, title : 'My Book'}, {}, callback); }";

            StoredProcedureExecuteResponse<int> scriptResponse = null;
            int totalNumberOfDocuments = GatewayTests.CreateExecuteAndDeleteCosmosProcedure(collection, script, out scriptResponse, "My Book");

            IOrderedQueryable<Book> linqQueryable = collection.GetItemLinqQueryable<Book>(allowSynchronousQueryExecution : true);
            int totalHit = linqQueryable.Where(book => book.Title == "My Book").Count();
            Assert.AreEqual(totalHit, totalNumberOfDocuments, "Didnt get all the documents");

        }

        #endregion

        public class SpecialAttachment2 //Non attachemnt derived.
        {
            [JsonProperty(PropertyName = Constants.Properties.Id)]
            public string Name { get; set; }

            [JsonProperty(PropertyName = "contentType")]
            public string ContentType { get; set; }

            [JsonProperty(PropertyName = Constants.Properties.MediaLink)]
            public string Media { get; set; }

            public string Author { get; set; }
            public string Title { get; set; }
        }

        #region TypeSystem test reference classes
        public interface IFooItem { }

        public class FooItem : IFooItem { }

        public class DerivedFooItem : FooItem { }

        public class MyList<T> : List<T> { }

        public class MyTupleList<T> : List<Tuple<T, T>> { }

        public class DerivedFooCollection : IList<IFooItem>, IEnumerable<DerivedFooItem>
        {
            public int IndexOf(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void Insert(int index, IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void RemoveAt(int index)
            {
                throw new NotImplementedException();
            }

            public IFooItem this[int index]
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public void Add(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(IFooItem[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { throw new NotImplementedException(); }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(IFooItem item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<IFooItem> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator<DerivedFooItem> IEnumerable<DerivedFooItem>.GetEnumerator()
            {
                throw new NotImplementedException();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        public class FooStringCollection : IList<string>, IEnumerable<FooItem>
        {
            public int IndexOf(string item)
            {
                throw new NotImplementedException();
            }

            public void Insert(int index, string item)
            {
                throw new NotImplementedException();
            }

            public void RemoveAt(int index)
            {
                throw new NotImplementedException();
            }

            public string this[int index]
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public void Add(string item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                throw new NotImplementedException();
            }

            public bool Contains(string item)
            {
                throw new NotImplementedException();
            }

            public void CopyTo(string[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public int Count
            {
                get { throw new NotImplementedException(); }
            }

            public bool IsReadOnly
            {
                get { throw new NotImplementedException(); }
            }

            public bool Remove(string item)
            {
                throw new NotImplementedException();
            }

            public IEnumerator<string> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator<FooItem> IEnumerable<FooItem>.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        public class FooTCollection<T> : List<FooItem>, IEnumerable<T>
        {
            public new IEnumerator<T> GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }
        #endregion

        public override LinqTestOutput ExecuteTest(LinqTestInput input)
        {
            return LinqTestsCommon.ExecuteTest(input);
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Mirrored\AsyncCache.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.Azure.Cosmos.Encryption
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Cache which supports asynchronous value initialization.
    /// It ensures that for given key only single inintialization funtion is running at any point in time.
    /// </summary>
    /// <typeparam name="TKey">Type of keys.</typeparam>
    /// <typeparam name="TValue">Type of values.</typeparam>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "VSTHRD105:Avoid method overloads that assume TaskScheduler.Current", Justification = "Mirrored file.")]
    internal sealed class AsyncCache<TKey, TValue>
    {
        private readonly IEqualityComparer<TValue> valueEqualityComparer;
        private readonly IEqualityComparer<TKey> keyEqualityComparer;

        private ConcurrentDictionary<TKey, AsyncLazy<TValue>> values;

        public AsyncCache(IEqualityComparer<TValue> valueEqualityComparer, IEqualityComparer<TKey> keyEqualityComparer = null)
        {
            this.keyEqualityComparer = keyEqualityComparer ?? EqualityComparer<TKey>.Default;
            this.values = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            this.valueEqualityComparer = valueEqualityComparer;
        }

        public AsyncCache()
            : this(EqualityComparer<TValue>.Default)
        {
        }

        public ICollection<TKey> Keys => this.values.Keys;

        public void Set(TKey key, TValue value)
        {
            AsyncLazy<TValue> lazyValue = new AsyncLazy<TValue>(value);

            // Access it to mark as created+completed, so that further calls to getasync do not overwrite.
#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
            TValue x = lazyValue.Value.Result;
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits

            this.values.AddOrUpdate(key, lazyValue, (k, existingValue) =>
            {
                // Observe all exceptions thrown for existingValue.
                if (existingValue.IsValueCreated)
                {
                    Task unused = existingValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }

                return lazyValue;
            });
        }

        /// <summary>
        /// <para>
        /// Gets value corresponding to <paramref name="key"/>.
        /// </para>
        /// <para>
        /// If another initialization function is already running, new initialization function will not be started.
        /// The result will be result of currently running initialization function.
        /// </para>
        /// <para>
        /// If previous initialization function is successfully completed - value returned by it will be returned unless
        /// it is equal to <paramref name="obsoleteValue"/>, in which case new initialization function will be started.
        /// </para>
        /// <para>
        /// If previous initialization function failed - new one will be launched.
        /// </para>
        /// </summary>
        /// <param name="key">Key for which to get a value.</param>
        /// <param name="obsoleteValue">Value which is obsolete and needs to be refreshed.</param>
        /// <param name="singleValueInitFunc">Initialization function.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <param name="forceRefresh">Skip cached value and generate new value.</param>
        /// <returns>Cached value or value returned by initialization function.</returns>
        public async Task<TValue> GetAsync(
           TKey key,
           TValue obsoleteValue,
           Func<Task<TValue>> singleValueInitFunc,
           CancellationToken cancellationToken,
           bool forceRefresh = false)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (this.values.TryGetValue(key, out AsyncLazy<TValue> initialLazyValue))
            {
                // If we haven't computed the value or we're currently computing it, then return it...
                if (!initialLazyValue.IsValueCreated || !initialLazyValue.Value.IsCompleted)
                {
                    try
                    {
                        return await initialLazyValue.Value;
                    }

                    // It does not matter to us if this instance of the task throws - the lambda that failed was provided by a different caller.
                    // The exception that we see here will be handled/logged by whatever caller provided the failing lambda, if any. Our part is catching and observing it.
                    // As such, we discard this exception and will retry with our own lambda below, for which we will let exception bubble up.
                    catch
                    {
                    }
                }

                // Don't check Task if there's an exception or it's been canceled. Accessing Task.Exception marks it as observed, which we want.
                else if (initialLazyValue.Value.Exception == null && !initialLazyValue.Value.IsCanceled)
                {
                    TValue cachedValue = await initialLazyValue.Value;

                    // If not forcing refresh or obsolete value, use cached value.
                    if (!forceRefresh && !this.valueEqualityComparer.Equals(cachedValue, obsoleteValue))
                    {
                        return cachedValue;
                    }
                }
            }

            AsyncLazy<TValue> newLazyValue = new AsyncLazy<TValue>(singleValueInitFunc, cancellationToken);

            // Update the new task in the cache - compare-and-swap style.
            AsyncLazy<TValue> actualValue = this.values.AddOrUpdate(
                key,
                newLazyValue,
                (existingKey, existingValue) => object.ReferenceEquals(existingValue, initialLazyValue) ? newLazyValue : existingValue);

            // Task starts running here.
            Task<TValue> generator = actualValue.Value;

            // Even if the current thread goes away, all exceptions will be observed.
            Task unused = generator.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);

            return await generator;
        }

        public void Remove(TKey key)
        {
            if (this.values.TryRemove(key, out AsyncLazy<TValue> initialLazyValue) && initialLazyValue.IsValueCreated)
            {
                // Observe all exceptions thrown.
                Task unused = initialLazyValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
            }
        }

        public bool TryRemoveIfCompleted(TKey key)
        {
            if (this.values.TryGetValue(key, out AsyncLazy<TValue> initialLazyValue) && initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted)
            {
                // Accessing Exception marks as observed.
                _ = initialLazyValue.Value.Exception;

                // This is a nice trick to do "atomic remove if value not changed".
                // ConcurrentDictionary inherits from ICollection<KVP<..>>, which allows removal of specific key value pair, instead of removal just by key.
                ICollection<KeyValuePair<TKey, AsyncLazy<TValue>>> valuesAsCollection = this.values as ICollection<KeyValuePair<TKey, AsyncLazy<TValue>>>;
                Debug.Assert(valuesAsCollection != null, "Values collection expected to implement ICollection<KVP<TKey, AsyncLazy<TValue>>.");
                return valuesAsCollection?.Remove(new KeyValuePair<TKey, AsyncLazy<TValue>>(key, initialLazyValue)) ?? false;
            }

            return false;
        }

        /// <summary>
        /// Remove value from cache and return it if present.
        /// </summary>
        /// <param name="key"> Key </param>
        /// <returns>Value if present, default value if not present.</returns>
        public async Task<TValue> RemoveAsync(TKey key)
        {
            if (this.values.TryRemove(key, out AsyncLazy<TValue> initialLazyValue))
            {
                try
                {
                    return await initialLazyValue.Value;
                }
                catch
                {
                }
            }

            return default;
        }

        public void Clear()
        {
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> newValues = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> oldValues = Interlocked.Exchange(ref this.values, newValues);

            // Ensure all tasks are observed.
            foreach (AsyncLazy<TValue> value in oldValues.Values)
            {
                if (value.IsValueCreated)
                {
                    Task unused = value.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }
            }

            oldValues.Clear();
        }

        /// <summary>
        /// Runs a background task that will started refreshing the cached value for a given key.
        /// This observes the same logic as GetAsync - a running value will still take precedence over a call to this.
        /// </summary>
        /// <param name="key">Key.</param>
        /// <param name="singleValueInitFunc">Generator function.</param>
        public void BackgroundRefreshNonBlocking(TKey key, Func<Task<TValue>> singleValueInitFunc)
        {
            // Trigger background refresh of cached value.
            // Fire and forget.
            Task unused = Task.Factory.StartNewOnCurrentTaskSchedulerAsync(async () =>
            {
                try
                {
                    // If we don't have a value, or we have one that has completed running (i.e. if a value is currently being generated, we do nothing).
                    if (!this.values.TryGetValue(key, out AsyncLazy<TValue> initialLazyValue) || (initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted))
                    {
                        // Use GetAsync to trigger the generation of a value.
                        await this.GetAsync(
                            key,
                            default, // obsolete value unused since forceRefresh: true
                            singleValueInitFunc,
                            CancellationToken.None,
                            forceRefresh: true);
                    }
                }
                catch
                {
                    // Observe all exceptions.
                }
            }).Unwrap();
        }
    }
}
---- Transformed Tree ----
namespace Microsoft.Azure.Cosmos.Encryption
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Cache which supports asynchronous value initialization.
    /// It ensures that for given key only single inintialization funtion is running at any point in time.
    /// </summary>
    /// <typeparam name="TKey">Type of keys.</typeparam>
    /// <typeparam name="TValue">Type of values.</typeparam>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "VSTHRD105:Avoid method overloads that assume TaskScheduler.Current", Justification = "Mirrored file.")]
    internal sealed class AsyncCache<TKey, TValue>
    {
        private readonly IEqualityComparer<TValue> valueEqualityComparer;
        private readonly IEqualityComparer<TKey> keyEqualityComparer;

        private ConcurrentDictionary<TKey, AsyncLazy<TValue>> values;

        public AsyncCache(IEqualityComparer<TValue> valueEqualityComparer, IEqualityComparer<TKey> keyEqualityComparer = null)
        {
            this.keyEqualityComparer = keyEqualityComparer ?? EqualityComparer<TKey>.Default;
            this.values = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            this.valueEqualityComparer = valueEqualityComparer;
        }

        public AsyncCache()
            : this(EqualityComparer<TValue>.Default)
        {
        }

        public ICollection<TKey> Keys => this.values.Keys;

        public void Set(TKey key, TValue value)
        {
            AsyncLazy<TValue> lazyValue = new AsyncLazy<TValue>(value);

            // Access it to mark as created+completed, so that further calls to getasync do not overwrite.
#pragma warning disable VSTHRD002 // Avoid problematic synchronous waits
            TValue x = lazyValue.Value.Result;
#pragma warning restore VSTHRD002 // Avoid problematic synchronous waits

            this.values.AddOrUpdate(key, lazyValue, (k, existingValue) =>
            {
                // Observe all exceptions thrown for existingValue.
                if (existingValue.IsValueCreated)
                {
                    Task unused = existingValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }

                return lazyValue;
            });
        }

        /// <summary>
        /// <para>
        /// Gets value corresponding to <paramref name="key"/>.
        /// </para>
        /// <para>
        /// If another initialization function is already running, new initialization function will not be started.
        /// The result will be result of currently running initialization function.
        /// </para>
        /// <para>
        /// If previous initialization function is successfully completed - value returned by it will be returned unless
        /// it is equal to <paramref name="obsoleteValue"/>, in which case new initialization function will be started.
        /// </para>
        /// <para>
        /// If previous initialization function failed - new one will be launched.
        /// </para>
        /// </summary>
        /// <param name="key">Key for which to get a value.</param>
        /// <param name="obsoleteValue">Value which is obsolete and needs to be refreshed.</param>
        /// <param name="singleValueInitFunc">Initialization function.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <param name="forceRefresh">Skip cached value and generate new value.</param>
        /// <returns>Cached value or value returned by initialization function.</returns>
        public async Task<TValue> GetAsync(
           TKey key,
           TValue obsoleteValue,
           Func<Task<TValue>> singleValueInitFunc,
           CancellationToken cancellationToken,
           bool forceRefresh = false)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (this.values.TryGetValue(key, out AsyncLazy<TValue> initialLazyValue))
            {
                // If we haven't computed the value or we're currently computing it, then return it...
                if (!initialLazyValue.IsValueCreated || !initialLazyValue.Value.IsCompleted)
                {
                    try
                    {
                        return await initialLazyValue.Value;
                    }

                    // It does not matter to us if this instance of the task throws - the lambda that failed was provided by a different caller.
                    // The exception that we see here will be handled/logged by whatever caller provided the failing lambda, if any. Our part is catching and observing it.
                    // As such, we discard this exception and will retry with our own lambda below, for which we will let exception bubble up.
                    catch
                    {
                    }
                }

                // Don't check Task if there's an exception or it's been canceled. Accessing Task.Exception marks it as observed, which we want.
                else if (initialLazyValue.Value.Exception == null && !initialLazyValue.Value.IsCanceled)
                {
                    TValue cachedValue = await initialLazyValue.Value;

                    // If not forcing refresh or obsolete value, use cached value.
                    if (!forceRefresh && !this.valueEqualityComparer.Equals(cachedValue, obsoleteValue))
                    {
                        return cachedValue;
                    }
                }
            }

            AsyncLazy<TValue> newLazyValue = new AsyncLazy<TValue>(singleValueInitFunc, cancellationToken);

            // Update the new task in the cache - compare-and-swap style.
            AsyncLazy<TValue> actualValue = this.values.AddOrUpdate(
                key,
                newLazyValue,
                (existingKey, existingValue) => object.ReferenceEquals(existingValue, initialLazyValue) ? newLazyValue : existingValue);

            // Task starts running here.
            Task<TValue> generator = actualValue.Value;

            // Even if the current thread goes away, all exceptions will be observed.
            Task unused = generator.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);

            return await generator;
        }

        public void Remove(TKey key)
        {
            if (this.values.TryRemove(key, out AsyncLazy<TValue> initialLazyValue) && initialLazyValue.IsValueCreated)
            {
                // Observe all exceptions thrown.
                Task unused = initialLazyValue.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
            }
        }

        public bool TryRemoveIfCompleted(TKey key)
        {
            if (this.values.TryGetValue(key, out AsyncLazy<TValue> initialLazyValue) && initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted)
            {
                // Accessing Exception marks as observed.
                _ = initialLazyValue.Value.Exception;
                // This is a nice trick to do "atomic remove if value not changed".                // ConcurrentDictionary inherits from ICollection<KVP<..>>, which allows removal of specific key value pair, instead of removal just by key.
                Debug.Assert(this.values is ICollection<KeyValuePair<TKey, AsyncLazy<TValue>>> valuesAsCollection, "Values collection expected to implement ICollection<KVP<TKey, AsyncLazy<TValue>>.");
                return valuesAsCollection?.Remove(new KeyValuePair<TKey, AsyncLazy<TValue>>(key, initialLazyValue)) ?? false;
            }

            return false;
        }

        /// <summary>
        /// Remove value from cache and return it if present.
        /// </summary>
        /// <param name="key"> Key </param>
        /// <returns>Value if present, default value if not present.</returns>
        public async Task<TValue> RemoveAsync(TKey key)
        {
            if (this.values.TryRemove(key, out AsyncLazy<TValue> initialLazyValue))
            {
                try
                {
                    return await initialLazyValue.Value;
                }
                catch
                {
                }
            }

            return default;
        }

        public void Clear()
        {
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> newValues = new ConcurrentDictionary<TKey, AsyncLazy<TValue>>(this.keyEqualityComparer);
            ConcurrentDictionary<TKey, AsyncLazy<TValue>> oldValues = Interlocked.Exchange(ref this.values, newValues);

            // Ensure all tasks are observed.
            foreach (AsyncLazy<TValue> value in oldValues.Values)
            {
                if (value.IsValueCreated)
                {
                    Task unused = value.Value.ContinueWith(c => c.Exception, TaskContinuationOptions.OnlyOnFaulted);
                }
            }

            oldValues.Clear();
        }

        /// <summary>
        /// Runs a background task that will started refreshing the cached value for a given key.
        /// This observes the same logic as GetAsync - a running value will still take precedence over a call to this.
        /// </summary>
        /// <param name="key">Key.</param>
        /// <param name="singleValueInitFunc">Generator function.</param>
        public void BackgroundRefreshNonBlocking(TKey key, Func<Task<TValue>> singleValueInitFunc)
        {
            // Trigger background refresh of cached value.
            // Fire and forget.
            Task unused = Task.Factory.StartNewOnCurrentTaskSchedulerAsync(async () =>
            {
                try
                {
                    // If we don't have a value, or we have one that has completed running (i.e. if a value is currently being generated, we do nothing).
                    if (!this.values.TryGetValue(key, out AsyncLazy<TValue> initialLazyValue) || (initialLazyValue.IsValueCreated && initialLazyValue.Value.IsCompleted))
                    {
                        // Use GetAsync to trigger the generation of a value.
                        await this.GetAsync(
                            key,
                            default, // obsolete value unused since forceRefresh: true
                            singleValueInitFunc,
                            CancellationToken.None,
                            forceRefresh: true);
                    }
                }
                catch
                {
                    // Observe all exceptions.
                }
            }).Unwrap();
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Microsoft.Azure.Cosmos.Encryption\src\Mirrored\AsyncCache.cs(159,24): error CS0165: Use of unassigned local variable 'valuesAsCollection'
######################################################################


