Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: csla.test
    #1 Path: D:\a\1\s\Source\Csla.test\Basic\Child.cs, Line: 43, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #2 Path: D:\a\1\s\Source\Csla.test\DataAnnotations\DataAnnotationsTests.cs, Line: 102, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #3 Path: D:\a\1\s\Source\Csla.test\DataAnnotations\DataAnnotationsTests.cs, Line: 103, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #4 Path: D:\a\1\s\Source\Csla.test\MethodCaller\MethodCallerTests.cs, Line: 146, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #5 Path: D:\a\1\s\Source\Csla.test\Reflection\GetConstructor.cs, Line: 53, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #6 Path: D:\a\1\s\Source\Csla.test\ValidationRules\AsyncRuleRoot.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #7 Path: D:\a\1\s\Source\Csla.test\ValidationRules\RuleBaseClassesRoot.cs, Line: 238, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #8 Path: D:\a\1\s\Source\Csla.test\ValidationRules\RuleBaseClassesRoot.cs, Line: 239, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #9 Path: D:\a\1\s\Source\Csla.test\ValidationRules\RuleBaseClassesRoot.cs, Line: 274, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\Source\Csla.test\ValidationRules\ValidationTests.cs, Line: 684, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Csla.Validation.Test
    #11 Path: D:\a\1\s\Source\Csla.Validation.Test\ResourceInfo.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Csla.Xaml.Net4.6
    #12 Path: D:\a\1\s\Source\Csla.Xaml.Shared\BrokenRulesSeverityConverter.cs, Line: 36, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\Source\Csla.Xaml.Shared\BusyAnimation.cs, Line: 181, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CancellableViewModel.cs, Line: 72, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #15 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProvider.cs, Line: 355, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #16 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 106, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #17 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 114, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #18 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 133, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #20 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 141, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #21 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 165, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #23 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 59, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #24 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 77, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #27 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 85, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #28 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #29 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 143, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #37 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 153, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\Source\Csla.Xaml.Shared\InvokeMethod.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\Source\Csla.Xaml.Shared\InvokeMethod.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ObjectStatus.cs, Line: 288, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ObjectStatus.cs, Line: 304, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 334, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #43 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 382, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #44 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 382, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #45 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 460, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 512, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 522, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 525, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 532, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 535, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 554, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 226, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 271, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 290, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 299, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 302, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 319, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 564, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 571, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 644, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 655, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #63 Path: D:\a\1\s\Source\Csla.Xaml.Shared\TriggerAction.cs, Line: 258, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #64 Path: D:\a\1\s\Source\Csla.Xaml.Shared\TriggerAction.cs, Line: 44, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #65 Path: D:\a\1\s\Source\Csla.Xaml.Shared\TriggerAction.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Csla.Windows.Net4.6
    #66 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #67 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #70 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs, Line: 756, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #71 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs, Line: 856, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #72 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs, Line: 756, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #73 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs, Line: 856, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #74 Path: D:\a\1\s\Source\Csla.Windows.Shared\ReadWriteAuthorization.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #75 Path: D:\a\1\s\Source\Csla.Windows.Shared\ReadWriteAuthorization.cs, Line: 175, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Csla.Validation.Net4.6
    #76 Path: D:\a\1\s\Source\Csla.Validation.Shared\CommonRules.cs, Line: 1334, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #77 Path: D:\a\1\s\Source\Csla.Validation.Shared\CommonRules.cs, Line: 1339, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: D:\a\1\s\Source\Csla.Validation.Shared\CommonRules.cs, Line: 1366, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\Source\Csla.Validation.Shared\CommonRules.cs, Line: 1370, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #80 Path: D:\a\1\s\Source\Csla.Validation.Shared\CommonRules.cs, Line: 1412, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: D:\a\1\s\Source\Csla.Validation.Shared\PropertyHelper.cs, Line: 25, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Csla.Analyzers
    #82 Path: D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers\CheckConstructorsAnalyzerPublicConstructorCodeFix.cs, Line: 95, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #83 Path: D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers\Extensions\SyntaxNodeExtensions.cs, Line: 27, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Csla.Web.Mvc5.Net4.6
    #84 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\CslaModelBinder.cs, Line: 261, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\CslaModelBinder.cs, Line: 286, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\CslaModelBinder.cs, Line: 321, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\CslaModelBinder.cs, Line: 336, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\CslaModelBinder.cs, Line: 341, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #89 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #90 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #91 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 93, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Csla.Web.Net4.6
    #92 Path: D:\a\1\s\Source\Csla.Web.Shared\CslaDataSource.cs, Line: 141, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #93 Path: D:\a\1\s\Source\Csla.Web.Shared\CslaDataSourceView.cs, Line: 108, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #94 Path: D:\a\1\s\Source\Csla.Web.Shared\CslaDataSourceView.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #95 Path: D:\a\1\s\Source\Csla.Web.Shared\CslaDataSourceView.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #96 Path: D:\a\1\s\Source\Csla.Web.Shared\Design\CslaDataSourceDesigner.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Csla.AspNetCore.Mvc2.NetStandard2.0
    #97 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #98 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #99 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 93, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Csla.Xaml.Xamarin
    #100 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 227, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #101 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 260, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #102 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 512, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 522, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #104 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 525, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #105 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 532, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #106 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 535, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #107 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 554, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: csla.netcore.test
    #108 Path: D:\a\1\s\Source\csla.netcore.test\Serialization\ClaimsPrincipalTests.cs, Line: 36, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Csla.Analyzers.Tests(net461)
    #109 Path: D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers.Tests\Extensions\SyntaxNodeExtensionsTests.cs, Line: 45, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #110 Path: D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers.Tests\Extensions\SyntaxNodeExtensionsTests.cs, Line: 62, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #111 Path: D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers.Tests\TestHelpers.cs, Line: 21, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Csla.Channels.Grpc
    #112 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcPortal.cs, Line: 137, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #113 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcPortal.cs, Line: 184, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #114 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcPortal.cs, Line: 273, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #115 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcProxy.cs, Line: 160, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #116 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcProxy.cs, Line: 215, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #117 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcProxy.cs, Line: 264, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #118 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcProxy.cs, Line: 319, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #119 Path: D:\a\1\s\Source\Csla.Channels.Grpc\GrpcProxy.cs, Line: 371, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #120 Path: D:\a\1\s\Source\Csla.Channels.Grpc\obj\Debug\netstandard2.1\Protos\GrpcChannel.cs, Line: 169, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #121 Path: D:\a\1\s\Source\Csla.Channels.Grpc\obj\Debug\netstandard2.1\Protos\GrpcChannel.cs, Line: 355, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Csla.Channels.RabbitMq
    #122 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqPortal.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #123 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqPortal.cs, Line: 243, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #124 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqPortal.cs, Line: 332, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #125 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqProxy.cs, Line: 157, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #126 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqProxy.cs, Line: 216, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #127 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqProxy.cs, Line: 269, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #128 Path: D:\a\1\s\Source\Csla.Channels.Rabbitmq\RabbitMqProxy.cs, Line: 328, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Csla.Windows.NetCoreApp3.0(net5.0-windows10.0.19041.0)
    #129 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #130 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #131 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\Source\Csla.Windows.Shared\BindingSourceNode.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #133 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs, Line: 756, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #134 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs, Line: 856, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #135 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs, Line: 756, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #136 Path: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs, Line: 856, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #137 Path: D:\a\1\s\Source\Csla.Windows.Shared\ReadWriteAuthorization.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\Source\Csla.Windows.Shared\ReadWriteAuthorization.cs, Line: 175, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Csla.Xaml.NetCoreApp3.0(net5.0-windows10.0.19041.0)
    #139 Path: D:\a\1\s\Source\Csla.Xaml.Shared\BrokenRulesSeverityConverter.cs, Line: 36, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\Source\Csla.Xaml.Shared\BusyAnimation.cs, Line: 181, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #141 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CancellableViewModel.cs, Line: 72, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #142 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProvider.cs, Line: 355, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #143 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 106, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #144 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 114, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #145 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #146 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 133, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #147 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 141, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #148 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #149 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 165, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #150 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 59, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #151 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #152 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #153 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 77, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #154 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 85, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #155 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #156 Path: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProviderCommandManager.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #157 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #158 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\Source\Csla.Xaml.Shared\DataDecoratorBase.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 143, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #164 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ErrorDialog.cs, Line: 153, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #165 Path: D:\a\1\s\Source\Csla.Xaml.Shared\InvokeMethod.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\Source\Csla.Xaml.Shared\InvokeMethod.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ObjectStatus.cs, Line: 288, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #168 Path: D:\a\1\s\Source\Csla.Xaml.Shared\ObjectStatus.cs, Line: 304, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #169 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 334, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 382, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #171 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 382, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #172 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 460, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 512, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 522, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 525, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 532, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 535, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyInfo.cs, Line: 554, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #179 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 226, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #180 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 271, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #181 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 290, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #183 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 299, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 302, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 319, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 564, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 571, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 644, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\Source\Csla.Xaml.Shared\PropertyStatus.cs, Line: 655, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #190 Path: D:\a\1\s\Source\Csla.Xaml.Shared\TriggerAction.cs, Line: 258, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #191 Path: D:\a\1\s\Source\Csla.Xaml.Shared\TriggerAction.cs, Line: 44, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #192 Path: D:\a\1\s\Source\Csla.Xaml.Shared\TriggerAction.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Csla.AspNetCore.NetCore3.0
    #193 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #194 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #195 Path: D:\a\1\s\Source\Csla.Web.Mvc.Shared\Server\Hosts\HttpPortal.cs, Line: 93, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Csla(net461)
    #196 Path: D:\a\1\s\Source\Csla\Core\BusinessBase.cs, Line: 529, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #197 Path: D:\a\1\s\Source\Csla\Core\BusinessBase.cs, Line: 604, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #198 Path: D:\a\1\s\Source\Csla\Core\BusinessBase.cs, Line: 698, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #199 Path: D:\a\1\s\Source\Csla\Core\BusinessBase.cs, Line: 724, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #200 Path: D:\a\1\s\Source\Csla\Core\ContextDictionary.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 229, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #202 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 237, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #204 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 241, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #205 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 254, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #206 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 258, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #207 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 262, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #208 Path: D:\a\1\s\Source\Csla\Core\ExtendedBindingList.cs, Line: 266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #209 Path: D:\a\1\s\Source\Csla\Core\FieldManager\FieldDataManager.cs, Line: 225, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #210 Path: D:\a\1\s\Source\Csla\Core\FieldManager\FieldDataManager.cs, Line: 315, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #211 Path: D:\a\1\s\Source\Csla\Core\FieldManager\FieldDataManager.cs, Line: 512, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #212 Path: D:\a\1\s\Source\Csla\Core\FieldManager\FieldDataManager.cs, Line: 543, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #213 Path: D:\a\1\s\Source\Csla\Core\FieldManager\FieldDataManager.cs, Line: 88, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #214 Path: D:\a\1\s\Source\Csla\Core\GraphMerger.cs, Line: 90, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #215 Path: D:\a\1\s\Source\Csla\Core\ManagedObjectBase.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #216 Path: D:\a\1\s\Source\Csla\Core\ManagedObjectBase.cs, Line: 246, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #217 Path: D:\a\1\s\Source\Csla\Core\ManagedObjectBase.cs, Line: 291, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #218 Path: D:\a\1\s\Source\Csla\Core\ManagedObjectBase.cs, Line: 318, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #219 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 313, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #220 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 317, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #221 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 321, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #222 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 329, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #223 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 342, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #224 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 346, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #225 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 350, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #226 Path: D:\a\1\s\Source\Csla\Core\ObservableBindingList.cs, Line: 358, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #227 Path: D:\a\1\s\Source\Csla\Data\DataMapper.cs, Line: 149, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #228 Path: D:\a\1\s\Source\Csla\Data\DataMapper.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #229 Path: D:\a\1\s\Source\Csla\Data\DataMapper.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #230 Path: D:\a\1\s\Source\Csla\Data\DataMapper.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #231 Path: D:\a\1\s\Source\Csla\Data\ObjectAdapter.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\Source\Csla\Data\ObjectAdapter.cs, Line: 149, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #233 Path: D:\a\1\s\Source\Csla\Data\ObjectAdapter.cs, Line: 155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #234 Path: D:\a\1\s\Source\Csla\Data\ObjectAdapter.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #235 Path: D:\a\1\s\Source\Csla\Data\ObjectAdapter.cs, Line: 221, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #236 Path: D:\a\1\s\Source\Csla\Data\ObjectAdapter.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #237 Path: D:\a\1\s\Source\Csla\DataPortal.cs, Line: 861, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #238 Path: D:\a\1\s\Source\Csla\DataPortalClient\DataPortalProxyFactory.cs, Line: 167, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #239 Path: D:\a\1\s\Source\Csla\DataPortalClient\HttpProxy.cs, Line: 233, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #240 Path: D:\a\1\s\Source\Csla\DataPortalClient\HttpProxy.cs, Line: 290, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #241 Path: D:\a\1\s\Source\Csla\DataPortalClient\HttpProxy.cs, Line: 341, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #242 Path: D:\a\1\s\Source\Csla\DataPortalClient\HttpProxy.cs, Line: 398, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #243 Path: D:\a\1\s\Source\Csla\DataPortalClient\HttpProxy.cs, Line: 497, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #244 Path: D:\a\1\s\Source\Csla\DataPortalException.cs, Line: 205, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #245 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 1080, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #246 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #247 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 306, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #248 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 309, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #249 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 620, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #250 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 657, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #251 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 807, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #252 Path: D:\a\1\s\Source\Csla\DataPortalT.cs, Line: 809, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #253 Path: D:\a\1\s\Source\Csla\DynamicBindingListBase.cs, Line: 155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #254 Path: D:\a\1\s\Source\Csla\DynamicBindingListBase.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #255 Path: D:\a\1\s\Source\Csla\DynamicBindingListBase.cs, Line: 425, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #256 Path: D:\a\1\s\Source\Csla\DynamicListBase.cs, Line: 165, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #257 Path: D:\a\1\s\Source\Csla\FilteredBindingList.cs, Line: 1012, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #258 Path: D:\a\1\s\Source\Csla\FilteredBindingList.cs, Line: 1021, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #259 Path: D:\a\1\s\Source\Csla\FilteredBindingList.cs, Line: 751, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #260 Path: D:\a\1\s\Source\Csla\MethodInfo.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #261 Path: D:\a\1\s\Source\Csla\ReadOnlyBase.cs, Line: 1162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #262 Path: D:\a\1\s\Source\Csla\ReadOnlyBase.cs, Line: 228, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: D:\a\1\s\Source\Csla\ReadOnlyBase.cs, Line: 329, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #264 Path: D:\a\1\s\Source\Csla\ReadOnlyBase.cs, Line: 355, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #265 Path: D:\a\1\s\Source\Csla\Reflection\CallMethodException.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #266 Path: D:\a\1\s\Source\Csla\Reflection\MethodCacheKey.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\Source\Csla\Reflection\MethodCaller.cs, Line: 417, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #268 Path: D:\a\1\s\Source\Csla\Rules\AuthorizationRule.cs, Line: 141, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: D:\a\1\s\Source\Csla\Rules\AuthorizationRule.cs, Line: 98, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #270 Path: D:\a\1\s\Source\Csla\Rules\AuthorizationRuleManager.cs, Line: 81, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #271 Path: D:\a\1\s\Source\Csla\Rules\BusinessRuleBase.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #272 Path: D:\a\1\s\Source\Csla\Rules\BusinessRules.cs, Line: 1072, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #273 Path: D:\a\1\s\Source\Csla\Rules\BusinessRules.cs, Line: 850, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #274 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaBinaryWriter.cs, Line: 116, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #275 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaBinaryWriter.cs, Line: 17, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #276 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaBinaryWriter.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #277 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaBinaryWriter.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #278 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaBinaryWriter.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #279 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaBinaryWriter.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #280 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaLegacyBinaryWriter.cs, Line: 105, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #281 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaLegacyBinaryWriter.cs, Line: 17, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #282 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaLegacyBinaryWriter.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #283 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaLegacyBinaryWriter.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #284 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaLegacyBinaryWriter.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #285 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\CslaLegacyBinaryWriter.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #286 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\MobileFormatter.cs, Line: 293, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #287 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\MobileFormatter.cs, Line: 299, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #288 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\SerializationInfo.cs, Line: 302, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #289 Path: D:\a\1\s\Source\Csla\Serialization\Mobile\SerializationInfo.cs, Line: 416, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #290 Path: D:\a\1\s\Source\Csla\Server\DataPortal.cs, Line: 348, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\Source\Csla\Server\DataPortal.cs, Line: 365, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #292 Path: D:\a\1\s\Source\Csla\Server\DataPortalException.cs, Line: 39, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #293 Path: D:\a\1\s\Source\Csla\Server\DataPortalTarget.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #294 Path: D:\a\1\s\Source\Csla\Server\FactoryDataPortal.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #295 Path: D:\a\1\s\Source\Csla\Server\FactoryDataPortal.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #296 Path: D:\a\1\s\Source\Csla\Server\FactoryDataPortal.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\Source\Csla\Server\FactoryDataPortal.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #298 Path: D:\a\1\s\Source\Csla\Server\FactoryDataPortal.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\Source\Csla\Server\FactoryDataPortal.cs, Line: 74, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #300 Path: D:\a\1\s\Source\Csla\Server\Hosts\Mobile\WcfPortal.cs, Line: 180, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #301 Path: D:\a\1\s\Source\Csla\Server\Hosts\Mobile\WcfPortal.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #302 Path: D:\a\1\s\Source\Csla\Server\Hosts\Mobile\WcfPortal.cs, Line: 92, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #303 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #304 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #305 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 165, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #306 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 183, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #307 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 218, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #308 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #309 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #310 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #311 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #312 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #313 Path: D:\a\1\s\Source\Csla\Server\ObjectFactory.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #314 Path: D:\a\1\s\Source\Csla\Server\ObjectFactoryAttribute.cs, Line: 307, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #315 Path: D:\a\1\s\Source\Csla\SmartDate.cs, Line: 482, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #316 Path: D:\a\1\s\Source\Csla\SmartDate.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #317 Path: D:\a\1\s\Source\Csla\SmartDate.cs, Line: 863, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #318 Path: D:\a\1\s\Source\Csla\SortedBindingList.cs, Line: 58, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #319 Path: D:\a\1\s\Source\Csla\SortedBindingList.cs, Line: 740, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #320 Path: D:\a\1\s\Source\Csla\SortedBindingList.cs, Line: 889, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #321 Path: D:\a\1\s\Source\Csla\SortedBindingList.cs, Line: 898, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #322 Path: D:\a\1\s\Source\Csla\Threading\BackgroundWorker.cs, Line: 254, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #323 Path: D:\a\1\s\Source\Csla\Threading\BackgroundWorker.cs, Line: 303, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #324 Path: D:\a\1\s\Source\Csla\Threading\BackgroundWorker.cs, Line: 319, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



--- Rules Summary ---
R8: 152
R9: 59
R5: 44
R2: 38
R7: 13
R4: 9
R6: 6
R3: 3

--- Summary ---
Fixed ReSharper issues: 286
Fixed SonarQube issues: 62
Total fixed issues: 324

Finished in: 32 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProvider.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;
using System.Reflection;
using Csla.Reflection;
using Csla.Properties;

namespace Csla.Xaml
{
  /// <summary>
  /// Wraps and creates a CSLA .NET-style object 
  /// that you can use as a binding source.
  /// </summary>
  public class CslaDataProvider : DataSourceProvider
  {

    /// <summary>
    /// Creates an instance of the object.
    /// </summary>
    public CslaDataProvider()
    {
      _commandManager = new CslaDataProviderCommandManager(this);
      _factoryParameters = new ObservableCollection<object>();
      _factoryParameters.CollectionChanged += 
        new System.Collections.Specialized.NotifyCollectionChangedEventHandler(_factoryParameters_CollectionChanged);
    }

    /// <summary>
    /// Event raised when the object has been saved.
    /// </summary>
    public event EventHandler<Csla.Core.SavedEventArgs> Saved;
    /// <summary>
    /// Raise the Saved event when the object has been saved.
    /// </summary>
    /// <param name="newObject">New object reference as a result
    /// of the save operation.</param>
    /// <param name="error">Reference to an exception object if
    /// an error occurred.</param>
    /// <param name="userState">Reference to a userstate object.</param>
    protected virtual void OnSaved(object newObject, Exception error, object userState)
    {
      if (Saved != null)
        Saved(this, new Csla.Core.SavedEventArgs(newObject, error, userState));
    }

    void _factoryParameters_CollectionChanged(
      object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
      BeginQuery();
    }

#region Properties

    private Type _objectType = null;
    private bool _manageLifetime;
    private string _factoryMethod = string.Empty;
    private ObservableCollection<object> _factoryParameters;
    private bool _isAsynchronous;
    private CslaDataProviderCommandManager _commandManager;
    private bool _isBusy;

    /// <summary>
    /// Gets an object that can be used to execute
    /// Save and Undo commands on this CslaDataProvider 
    /// through XAML command bindings.
    /// </summary>
    public CslaDataProviderCommandManager CommandManager
    {
      get
      {
        return _commandManager;
      }
    }

    /// <summary>
    /// Gets or sets the type of object 
    /// to create an instance of.
    /// </summary>
    public Type ObjectType
    {
      get 
      { 
        return _objectType; 
      }
      set 
      { 
        _objectType = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectType"));
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the
    /// data control should manage the lifetime of
    /// the business object, including using n-level
    /// undo.
    /// </summary>
    public bool ManageObjectLifetime
    {
      get
      {
        return _manageLifetime;
      }
      set
      {
        _manageLifetime = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ManageObjectLifetime"));
      }
    }

    private object _dataChangedHandler;

    /// <summary>
    /// Gets or sets a reference to an object that
    /// will handle the DataChanged event raised
    /// by this data provider.
    /// </summary>
    /// <remarks>
    /// This property is designed to 
    /// reference an IErrorDialog control.
    /// </remarks>
    public object DataChangedHandler
    {
      get
      {
        return _dataChangedHandler;
      }
      set
      {
        _dataChangedHandler = value;
        var dialog = value as IErrorDialog;
        if (dialog != null)
          dialog.Register(this);
        OnPropertyChanged(new PropertyChangedEventArgs("DataChangedHandler"));
      }
    }

    /// <summary>
    /// Gets or sets the name of the static
    /// (Shared in Visual Basic) factory method
    /// that should be called to create the
    /// object instance.
    /// </summary>
    public string FactoryMethod
    {
      get
      {
        return _factoryMethod;
      }
      set
      {
        _factoryMethod = value;
        OnPropertyChanged(new PropertyChangedEventArgs("FactoryMethod"));
      }
    }

    /// <summary>
    /// Get the list of parameters to pass
    /// to the factory method.
    /// </summary>
    public IList FactoryParameters
    {
      get
      {
        return _factoryParameters;
      }
    }

    /// <summary>
    /// Gets or sets a value that indicates 
    /// whether to perform object creation in 
    /// a worker thread or in the active context.
    /// </summary>
    public bool IsAsynchronous
    {
      get { return _isAsynchronous; }
      set { _isAsynchronous = value; }
    }

    /// <summary>
    /// Gets or sets a reference to the data
    /// object.
    /// </summary>
    public object ObjectInstance
    {
      get { return Data; }
      set 
      {
        OnQueryFinished(value, null, null, null);
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectInstance"));
      }
    }

    /// <summary>
    /// Gets a value indicating if this object is busy.
    /// </summary>
    public bool IsBusy
    {
      get { return _isBusy; }
      protected set
      {
        _isBusy = value;
        OnPropertyChanged(new PropertyChangedEventArgs("IsBusy"));
      }
    }

    /// <summary>
    /// Triggers WPF data binding to rebind to the
    /// data object.
    /// </summary>
    public void Rebind()
    {
      object tmp = ObjectInstance;
      ObjectInstance = null;
      ObjectInstance = tmp;
    }

#endregion

#region Query

    private bool _firstRun = true;
    private bool _init = false;
    private bool _endInitCompete = false;
    private bool _endInitError = false;

    /// <summary>
    /// Indicates that the control is about to initialize.
    /// </summary>
    protected override void BeginInit()
    {
      _init = true;
      base.BeginInit();
    }

    /// <summary>
    /// Indicates that the control has initialized.
    /// </summary>
    protected override void EndInit()
    {
      _init = false;
      base.EndInit();
      _endInitCompete = true;
    }

    /// <summary>
    /// Overridden. Starts to create the requested object, 
    /// either immediately or on a background thread, 
    /// based on the value of the IsAsynchronous property.
    /// </summary>
    protected override void BeginQuery()
    {
      if (_init)
        return;

      if (_firstRun)
      {
        _firstRun = false;
        if (!IsInitialLoadEnabled)
          return;
      }

      if (_endInitError)
      {
        // this handles a case where the WPF form initilizer
        // invokes the data provider twice when an exception
        // occurs - we really don't want to try the query twice
        // or report the error twice
        _endInitError = false;
        OnQueryFinished(null);
        return;
      }

      if (this.IsRefreshDeferred)
        return;

      QueryRequest request = new QueryRequest();
      request.ObjectType = _objectType;
      request.FactoryMethod = _factoryMethod;
      request.FactoryParameters = _factoryParameters;
      request.ManageObjectLifetime = _manageLifetime;

      IsBusy = true;

      if (IsAsynchronous)
        System.Threading.ThreadPool.QueueUserWorkItem(DoQuery, request);
      else
        DoQuery(request);
    }

    private void DoQuery(object state)
    {
      QueryRequest request = (QueryRequest)state;
      object result = null;
      Exception exceptionResult = null;
      object[] parameters = new List<object>(request.FactoryParameters).ToArray();

      try
      {
        // get factory method info
        BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy;
        System.Reflection.MethodInfo factory = request.ObjectType.GetMethod(
          request.FactoryMethod, flags, null, 
          MethodCaller.GetParameterTypes(parameters), null);

        if (factory == null)
        {
          // strongly typed factory couldn't be found
          // so find one with the correct number of
          // parameters 
          int parameterCount = parameters.Length;
          System.Reflection.MethodInfo[] methods = request.ObjectType.GetMethods(flags);
          foreach (System.Reflection.MethodInfo method in methods)
            if (method.Name == request.FactoryMethod && method.GetParameters().Length == parameterCount)
            {
              factory = method;
              break;
            }
        }

        if (factory == null)
        {
          // no matching factory could be found
          // so throw exception
          throw new InvalidOperationException(
            string.Format(Resources.NoSuchFactoryMethod, request.FactoryMethod));
        }

        // invoke factory method
        try
        {
          result = factory.Invoke(null, parameters);
        }
        catch (Csla.DataPortalException ex)
        {
          exceptionResult = ex.BusinessException;
        }
        catch (System.Reflection.TargetInvocationException ex)
        {
          if (ex.InnerException != null)
          {
            exceptionResult = ex.InnerException;
            var dpe = exceptionResult as Csla.DataPortalException;
            if (dpe?.BusinessException != null)
              exceptionResult = dpe.BusinessException;
          }
          else
            exceptionResult = ex;
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
      }
      catch (Exception ex)
      {
        exceptionResult = ex;
      }

      if (request.ManageObjectLifetime && result != null)
      {
        Csla.Core.ISupportUndo undo = result as Csla.Core.ISupportUndo;
        if (undo != null)
          undo.BeginEdit();
      }

      //if (!System.Windows.Application.Current.Dispatcher.CheckAccess())
      //  System.Windows.Application.Current.Dispatcher.Invoke(
      //    new Action(() => { IsBusy = false; }), 
      //    new object[] { });

      if (!_endInitCompete && exceptionResult != null)
        _endInitError = true;

      // return result to base class
      OnQueryFinished(result, exceptionResult, (o) => { IsBusy = false; return null; }, null);
    }

#region QueryRequest Class

    private class QueryRequest
    {
      private Type _objectType;

      public Type ObjectType
      {
        get { return _objectType; }
        set { _objectType = value; }
      }

      private string _factoryMethod;

      public string FactoryMethod
      {
        get { return _factoryMethod; }
        set { _factoryMethod = value; }
      }

      private ObservableCollection<object> _factoryParameters;

      public ObservableCollection<object> FactoryParameters
      {
        get { return _factoryParameters; }
        set { _factoryParameters = 
          new ObservableCollection<object>(new List<object>(value)); }
      }
      private bool _manageLifetime;

      public bool ManageObjectLifetime
      {
        get { return _manageLifetime; }
        set { _manageLifetime = value; }
      }
	
    }

#endregion

#endregion

#region Cancel/Update/New/Remove  

    /// <summary>
    /// Cancels changes to the business object, returning
    /// it to its previous state.
    /// </summary>
    /// <remarks>
    /// This metod does nothing unless ManageLifetime is
    /// set to true and the object supports n-level undo.
    /// </remarks>
    public void Cancel()
    {
      Csla.Core.ISupportUndo undo = this.Data as Csla.Core.ISupportUndo;
      if (undo != null && _manageLifetime)
      {
        IsBusy = true;
        undo.CancelEdit();
        undo.BeginEdit();
        IsBusy = false;
      }
    }

    /// <summary>
    /// Accepts changes to the business object, and
    /// commits them by calling the object's Save()
    /// method.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method does nothing unless the object
    /// implements Csla.Core.ISavable.
    /// </para><para>
    /// If the object implements IClonable, it
    /// will be cloned, and the clone will be
    /// saved.
    /// </para><para>
    /// If the object supports n-level undo and
    /// ManageLifetime is true, then this method
    /// will automatically call ApplyEdit() and
    /// BeginEdit() appropriately.
    /// </para>
    /// </remarks>
    public void Save()
    {
      // only do something if the object implements
      // ISavable
      Csla.Core.ISavable savable = this.Data as Csla.Core.ISavable;
      if (savable != null)
      {
        object result = savable;
        Exception exceptionResult = null;
        try
        {
          IsBusy = true;

          // clone the object if possible
          ICloneable clonable = savable as ICloneable;
          if (clonable != null)
            savable = (Csla.Core.ISavable)clonable.Clone();

          // apply edits in memory
          Csla.Core.ISupportUndo undo = savable as Csla.Core.ISupportUndo;
          if (undo != null && _manageLifetime)
            undo.ApplyEdit();


          // save the clone
          result = savable.Save();

          if (!ReferenceEquals(savable, this.Data) && !Csla.ApplicationContext.AutoCloneOnUpdate)
          {
            // raise Saved event from original object
            Core.ISavable original = this.Data as Core.ISavable;
            if (original != null)
              original.SaveComplete(result);
          }

          // start editing the resulting object
          undo = result as Csla.Core.ISupportUndo;
          if (undo != null && _manageLifetime)
            undo.BeginEdit();
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
        // clear previous object
        OnQueryFinished(null, exceptionResult, null, null);
        // return result to base class
        OnQueryFinished(result, null, null, null);
        IsBusy = false;
        OnSaved(result, exceptionResult, null);
      }
    }


    /// <summary>
    /// Adds a new item to the object if the object
    /// implements IBindingList and AllowNew is true.
    /// </summary>
    public object AddNew()
    {
      // only do something if the object implements
      // IBindingList
      IBindingList list = this.Data as IBindingList;
      if (list != null && list.AllowNew)
        return list.AddNew();
      else
        return null;

    }

    /// <summary>
    /// Removes an item from the list if the object
    /// implements IBindingList and AllowRemove is true.
    /// </summary>
    /// <param name="sender">Object invoking this method.</param>
    /// <param name="e">
    /// ExecuteEventArgs, where MethodParameter contains 
    /// the item to be removed from the list.
    /// </param>
    public void RemoveItem(object sender, ExecuteEventArgs e)
    {
      var item = e.MethodParameter;
      // only do something if the object implements
      // IBindingList
      IBindingList list;
      Csla.Core.BusinessBase bb = item as Csla.Core.BusinessBase;
      if (bb != null)
        list = bb.Parent as IBindingList;
      else
        list = this.Data as IBindingList;
      if (list != null && list.AllowRemove)
        list.Remove(item);
    }

#endregion

  }
}
#endif
---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;
using System.Reflection;
using Csla.Reflection;
using Csla.Properties;

namespace Csla.Xaml
{
  /// <summary>
  /// Wraps and creates a CSLA .NET-style object 
  /// that you can use as a binding source.
  /// </summary>
  public class CslaDataProvider : DataSourceProvider
  {

    /// <summary>
    /// Creates an instance of the object.
    /// </summary>
    public CslaDataProvider()
    {
      _commandManager = new CslaDataProviderCommandManager(this);
      _factoryParameters = new ObservableCollection<object>();
      _factoryParameters.CollectionChanged += 
        new System.Collections.Specialized.NotifyCollectionChangedEventHandler(_factoryParameters_CollectionChanged);
    }

    /// <summary>
    /// Event raised when the object has been saved.
    /// </summary>
    public event EventHandler<Csla.Core.SavedEventArgs> Saved;
    /// <summary>
    /// Raise the Saved event when the object has been saved.
    /// </summary>
    /// <param name="newObject">New object reference as a result
    /// of the save operation.</param>
    /// <param name="error">Reference to an exception object if
    /// an error occurred.</param>
    /// <param name="userState">Reference to a userstate object.</param>
    protected virtual void OnSaved(object newObject, Exception error, object userState)
    {
      if (Saved != null)
        Saved(this, new Csla.Core.SavedEventArgs(newObject, error, userState));
    }

    void _factoryParameters_CollectionChanged(
      object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
      BeginQuery();
    }

#region Properties

    private Type _objectType = null;
    private bool _manageLifetime;
    private string _factoryMethod = string.Empty;
    private ObservableCollection<object> _factoryParameters;
    private bool _isAsynchronous;
    private CslaDataProviderCommandManager _commandManager;
    private bool _isBusy;

    /// <summary>
    /// Gets an object that can be used to execute
    /// Save and Undo commands on this CslaDataProvider 
    /// through XAML command bindings.
    /// </summary>
    public CslaDataProviderCommandManager CommandManager
    {
      get
      {
        return _commandManager;
      }
    }

    /// <summary>
    /// Gets or sets the type of object 
    /// to create an instance of.
    /// </summary>
    public Type ObjectType
    {
      get 
      { 
        return _objectType; 
      }
      set 
      { 
        _objectType = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectType"));
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the
    /// data control should manage the lifetime of
    /// the business object, including using n-level
    /// undo.
    /// </summary>
    public bool ManageObjectLifetime
    {
      get
      {
        return _manageLifetime;
      }
      set
      {
        _manageLifetime = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ManageObjectLifetime"));
      }
    }

    private object _dataChangedHandler;

    /// <summary>
    /// Gets or sets a reference to an object that
    /// will handle the DataChanged event raised
    /// by this data provider.
    /// </summary>
    /// <remarks>
    /// This property is designed to 
    /// reference an IErrorDialog control.
    /// </remarks>
    public object DataChangedHandler
    {
      get
      {
        return _dataChangedHandler;
      }
      set
      {
        _dataChangedHandler = value;
        var dialog = value as IErrorDialog;
        if (dialog != null)
          dialog.Register(this);
        OnPropertyChanged(new PropertyChangedEventArgs("DataChangedHandler"));
      }
    }

    /// <summary>
    /// Gets or sets the name of the static
    /// (Shared in Visual Basic) factory method
    /// that should be called to create the
    /// object instance.
    /// </summary>
    public string FactoryMethod
    {
      get
      {
        return _factoryMethod;
      }
      set
      {
        _factoryMethod = value;
        OnPropertyChanged(new PropertyChangedEventArgs("FactoryMethod"));
      }
    }

    /// <summary>
    /// Get the list of parameters to pass
    /// to the factory method.
    /// </summary>
    public IList FactoryParameters
    {
      get
      {
        return _factoryParameters;
      }
    }

    /// <summary>
    /// Gets or sets a value that indicates 
    /// whether to perform object creation in 
    /// a worker thread or in the active context.
    /// </summary>
    public bool IsAsynchronous
    {
      get { return _isAsynchronous; }
      set { _isAsynchronous = value; }
    }

    /// <summary>
    /// Gets or sets a reference to the data
    /// object.
    /// </summary>
    public object ObjectInstance
    {
      get { return Data; }
      set 
      {
        OnQueryFinished(value, null, null, null);
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectInstance"));
      }
    }

    /// <summary>
    /// Gets a value indicating if this object is busy.
    /// </summary>
    public bool IsBusy
    {
      get { return _isBusy; }
      protected set
      {
        _isBusy = value;
        OnPropertyChanged(new PropertyChangedEventArgs("IsBusy"));
      }
    }

    /// <summary>
    /// Triggers WPF data binding to rebind to the
    /// data object.
    /// </summary>
    public void Rebind()
    {
      object tmp = ObjectInstance;
      ObjectInstance = null;
      ObjectInstance = tmp;
    }

#endregion

#region Query

    private bool _firstRun = true;
    private bool _init = false;
    private bool _endInitCompete = false;
    private bool _endInitError = false;

    /// <summary>
    /// Indicates that the control is about to initialize.
    /// </summary>
    protected override void BeginInit()
    {
      _init = true;
      base.BeginInit();
    }

    /// <summary>
    /// Indicates that the control has initialized.
    /// </summary>
    protected override void EndInit()
    {
      _init = false;
      base.EndInit();
      _endInitCompete = true;
    }

    /// <summary>
    /// Overridden. Starts to create the requested object, 
    /// either immediately or on a background thread, 
    /// based on the value of the IsAsynchronous property.
    /// </summary>
    protected override void BeginQuery()
    {
      if (_init)
        return;

      if (_firstRun)
      {
        _firstRun = false;
        if (!IsInitialLoadEnabled)
          return;
      }

      if (_endInitError)
      {
        // this handles a case where the WPF form initilizer
        // invokes the data provider twice when an exception
        // occurs - we really don't want to try the query twice
        // or report the error twice
        _endInitError = false;
        OnQueryFinished(null);
        return;
      }

      if (this.IsRefreshDeferred)
        return;

      QueryRequest request = new QueryRequest();
      request.ObjectType = _objectType;
      request.FactoryMethod = _factoryMethod;
      request.FactoryParameters = _factoryParameters;
      request.ManageObjectLifetime = _manageLifetime;

      IsBusy = true;

      if (IsAsynchronous)
        System.Threading.ThreadPool.QueueUserWorkItem(DoQuery, request);
      else
        DoQuery(request);
    }

    private void DoQuery(object state)
    {
      QueryRequest request = (QueryRequest)state;
      object result = null;
      Exception exceptionResult = null;
      object[] parameters = new List<object>(request.FactoryParameters).ToArray();

      try
      {
        // get factory method info
        BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy;
        System.Reflection.MethodInfo factory = request.ObjectType.GetMethod(
          request.FactoryMethod, flags, null, 
          MethodCaller.GetParameterTypes(parameters), null);

        if (factory == null)
        {
          // strongly typed factory couldn't be found
          // so find one with the correct number of
          // parameters 
          int parameterCount = parameters.Length;
          System.Reflection.MethodInfo[] methods = request.ObjectType.GetMethods(flags);
          foreach (System.Reflection.MethodInfo method in methods)
            if (method.Name == request.FactoryMethod && method.GetParameters().Length == parameterCount)
            {
              factory = method;
              break;
            }
        }

        if (factory == null)
        {
          // no matching factory could be found
          // so throw exception
          throw new InvalidOperationException(
            string.Format(Resources.NoSuchFactoryMethod, request.FactoryMethod));
        }

        // invoke factory method
        try
        {
          result = factory.Invoke(null, parameters);
        }
        catch (Csla.DataPortalException ex)
        {
          exceptionResult = ex.BusinessException;
        }
        catch (System.Reflection.TargetInvocationException ex)
        {
          if (ex.InnerException != null)
          {
            exceptionResult = ex.InnerException;
            var dpe = exceptionResult as Csla.DataPortalException;
            if (dpe?.BusinessException != null)
              exceptionResult = dpe.BusinessException;
          }
          else
            exceptionResult = ex;
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
      }
      catch (Exception ex)
      {
        exceptionResult = ex;
      }

      if (request.ManageObjectLifetime && result != null)
      {
        if (result is Csla.Core.ISupportUndo undo)
          undo.BeginEdit();
      }

      //if (!System.Windows.Application.Current.Dispatcher.CheckAccess())
      //  System.Windows.Application.Current.Dispatcher.Invoke(
      //    new Action(() => { IsBusy = false; }), 
      //    new object[] { });

      if (!_endInitCompete && exceptionResult != null)
        _endInitError = true;

      // return result to base class
      OnQueryFinished(result, exceptionResult, (o) => { IsBusy = false; return null; }, null);
    }

#region QueryRequest Class

    private class QueryRequest
    {
      private Type _objectType;

      public Type ObjectType
      {
        get { return _objectType; }
        set { _objectType = value; }
      }

      private string _factoryMethod;

      public string FactoryMethod
      {
        get { return _factoryMethod; }
        set { _factoryMethod = value; }
      }

      private ObservableCollection<object> _factoryParameters;

      public ObservableCollection<object> FactoryParameters
      {
        get { return _factoryParameters; }
        set { _factoryParameters = 
          new ObservableCollection<object>(new List<object>(value)); }
      }
      private bool _manageLifetime;

      public bool ManageObjectLifetime
      {
        get { return _manageLifetime; }
        set { _manageLifetime = value; }
      }
	
    }

#endregion

#endregion

#region Cancel/Update/New/Remove  

    /// <summary>
    /// Cancels changes to the business object, returning
    /// it to its previous state.
    /// </summary>
    /// <remarks>
    /// This metod does nothing unless ManageLifetime is
    /// set to true and the object supports n-level undo.
    /// </remarks>
    public void Cancel()
    {
      if (this.Data is Csla.Core.ISupportUndo undo && _manageLifetime)
      {
        IsBusy = true;
        undo.CancelEdit();
        undo.BeginEdit();
        IsBusy = false;
      }
    }

    /// <summary>
    /// Accepts changes to the business object, and
    /// commits them by calling the object's Save()
    /// method.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method does nothing unless the object
    /// implements Csla.Core.ISavable.
    /// </para><para>
    /// If the object implements IClonable, it
    /// will be cloned, and the clone will be
    /// saved.
    /// </para><para>
    /// If the object supports n-level undo and
    /// ManageLifetime is true, then this method
    /// will automatically call ApplyEdit() and
    /// BeginEdit() appropriately.
    /// </para>
    /// </remarks>
    public void Save()
    {
      // only do something if the object implements      // ISavable
      if (this.Data is Csla.Core.ISavable savable)
      {
        object result = savable;
        Exception exceptionResult = null;
        try
        {
          IsBusy = true;

          // clone the object if possible
          if (savable is ICloneable clonable)
            savable = (Csla.Core.ISavable)clonable.Clone();

          // apply edits in memory
          if (savable is Csla.Core.ISupportUndo undo && _manageLifetime)
            undo.ApplyEdit();


          // save the clone
          result = savable.Save();

          if (!ReferenceEquals(savable, this.Data) && !Csla.ApplicationContext.AutoCloneOnUpdate)
          {
            // raise Saved event from original object
            if (this.Data is Core.ISavable original)
              original.SaveComplete(result);
          }

          // start editing the resulting object
          undo = result as Csla.Core.ISupportUndo;

          if (savable is Csla.Core.ISupportUndo undo && _manageLifetime)
            undo.BeginEdit();
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
        // clear previous object
        OnQueryFinished(null, exceptionResult, null, null);
        // return result to base class
        OnQueryFinished(result, null, null, null);
        IsBusy = false;
        OnSaved(result, exceptionResult, null);
      }
    }


    /// <summary>
    /// Adds a new item to the object if the object
    /// implements IBindingList and AllowNew is true.
    /// </summary>
    public object AddNew()
    {
      // only do something if the object implements      // IBindingList
      if (this.Data is IBindingList list && list.AllowNew)
        return list.AddNew();
      else
        return null;

    }

    /// <summary>
    /// Removes an item from the list if the object
    /// implements IBindingList and AllowRemove is true.
    /// </summary>
    /// <param name="sender">Object invoking this method.</param>
    /// <param name="e">
    /// ExecuteEventArgs, where MethodParameter contains 
    /// the item to be removed from the list.
    /// </param>
    public void RemoveItem(object sender, ExecuteEventArgs e)
    {
      var item = e.MethodParameter;
      // only do something if the object implements
      // IBindingList
      IBindingList list;

      if (item is Csla.Core.BusinessBase bb)
        list = bb.Parent as IBindingList;
      else
        list = this.Data as IBindingList;
      if (list != null && list.AllowRemove)
        list.Remove(item);
    }

#endregion

  }
}
#endif
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProvider.cs(505,49): error CS0128: A local variable or function named 'undo' is already defined in this scope
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (Control))]
  [ProvideProperty("PostSaveAction", typeof (Control))]
  [ProvideProperty("RebindAfterSave", typeof (Control))]
  [ProvideProperty("DisableWhenClean", typeof (Control))]
  [ProvideProperty("DisableWhenUseless", typeof (Control))]
  [ProvideProperty("CommandName", typeof (Control))]
  public class CslaActionExtender : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtender(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<Control, CslaActionExtenderProperties> _sources =
      new Dictionary<Control, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is IButtonControl;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(Control ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(Control ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(Control ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      BindingSource rootSource = _dataSource as BindingSource;

      if (rootSource != null)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      Control ctl = (Control) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<Control> extendedControls = new List<Control>();
      foreach (KeyValuePair<Control, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          Control ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(Control ctl, KeyValuePair<Control, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          ITrackStatus trackableObject = businessObject as ITrackStatus;
          if (trackableObject != null)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(Control ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<Control, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          Control ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;
      BindingSource source = _dataSource as BindingSource;
      if (source != null)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (Control))]
  [ProvideProperty("PostSaveAction", typeof (Control))]
  [ProvideProperty("RebindAfterSave", typeof (Control))]
  [ProvideProperty("DisableWhenClean", typeof (Control))]
  [ProvideProperty("DisableWhenUseless", typeof (Control))]
  [ProvideProperty("CommandName", typeof (Control))]
  public class CslaActionExtender : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtender(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<Control, CslaActionExtenderProperties> _sources =
      new Dictionary<Control, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is IButtonControl;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(Control ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(Control ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(Control ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      if (_dataSource is BindingSource rootSource)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      Control ctl = (Control) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<Control> extendedControls = new List<Control>();
      foreach (KeyValuePair<Control, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          Control ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(Control ctl, KeyValuePair<Control, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          if (businessObject is ITrackStatus trackableObject)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(Control ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<Control, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          Control ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;

      if (_dataSource is BindingSource source)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs(599,88): error CS0165: Use of unassigned local variable 'rootSource'
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control (for ToolStripButton only) providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (ToolStripButton))]
  [ProvideProperty("PostSaveAction", typeof (ToolStripButton))]
  [ProvideProperty("RebindAfterSave", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenClean", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenUseless", typeof (ToolStripButton))]
  [ProvideProperty("CommandName", typeof (ToolStripButton))]
  public class CslaActionExtenderToolStrip : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtenderToolStrip(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<ToolStripButton, CslaActionExtenderProperties> _sources =
      new Dictionary<ToolStripButton, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is ToolStripButton;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(ToolStripButton ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(ToolStripButton ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(ToolStripButton ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      BindingSource rootSource = _dataSource as BindingSource;

      if (rootSource != null)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      ToolStripButton ctl = (ToolStripButton) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<ToolStripButton> extendedControls = new List<ToolStripButton>();
      foreach (KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          ToolStripButton ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(ToolStripButton ctl, KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          ITrackStatus trackableObject = businessObject as ITrackStatus;
          if (trackableObject != null)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(ToolStripButton ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<ToolStripButton, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          ToolStripButton ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(ToolStripButton thisToolStripButton)
    {
      return GetParentForm(thisToolStripButton.GetCurrentParent());
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;
      BindingSource source = _dataSource as BindingSource;
      if (source != null)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control (for ToolStripButton only) providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (ToolStripButton))]
  [ProvideProperty("PostSaveAction", typeof (ToolStripButton))]
  [ProvideProperty("RebindAfterSave", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenClean", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenUseless", typeof (ToolStripButton))]
  [ProvideProperty("CommandName", typeof (ToolStripButton))]
  public class CslaActionExtenderToolStrip : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtenderToolStrip(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<ToolStripButton, CslaActionExtenderProperties> _sources =
      new Dictionary<ToolStripButton, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is ToolStripButton;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(ToolStripButton ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(ToolStripButton ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(ToolStripButton ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      if (_dataSource is BindingSource rootSource)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      ToolStripButton ctl = (ToolStripButton) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<ToolStripButton> extendedControls = new List<ToolStripButton>();
      foreach (KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          ToolStripButton ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(ToolStripButton ctl, KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          if (businessObject is ITrackStatus trackableObject)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(ToolStripButton ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<ToolStripButton, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          ToolStripButton ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(ToolStripButton thisToolStripButton)
    {
      return GetParentForm(thisToolStripButton.GetCurrentParent());
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;

      if (_dataSource is BindingSource source)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs(599,88): error CS0165: Use of unassigned local variable 'rootSource'
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers\EvaluateManagedBackingFieldsAnalayzer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Immutable;
using System.Linq;
using static Csla.Analyzers.Extensions.ITypeSymbolExtensions;

namespace Csla.Analyzers
{
  [DiagnosticAnalyzer(LanguageNames.CSharp)]
  public sealed class EvaluateManagedBackingFieldsAnalayzer
    : DiagnosticAnalyzer
  {
    private static readonly DiagnosticDescriptor mustBePublicStaticAndReadonlyRule =
      new DiagnosticDescriptor(
        Constants.AnalyzerIdentifiers.EvaluateManagedBackingFields,
        EvaluateManagedBackingFieldsAnalayzerConstants.Title,
        EvaluateManagedBackingFieldsAnalayzerConstants.Message,
        Constants.Categories.Usage, DiagnosticSeverity.Error, true,
        helpLinkUri: HelpUrlBuilder.Build(
          Constants.AnalyzerIdentifiers.EvaluateManagedBackingFields, nameof(EvaluateManagedBackingFieldsAnalayzer)));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => 
      ImmutableArray.Create(mustBePublicStaticAndReadonlyRule);

    public override void Initialize(AnalysisContext context)
    {
      context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
      context.EnableConcurrentExecution();
      context.RegisterSyntaxNodeAction(AnalyzeFieldDeclaration, SyntaxKind.FieldDeclaration);
    }

    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context)
    {
      var fieldNode = (FieldDeclarationSyntax)context.Node;

      if (!fieldNode.ContainsDiagnostics)
      {
        foreach (var variable in fieldNode.Declaration.Variables)
        {
          var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
          var classSymbol = fieldSymbol?.ContainingType;

          context.CancellationToken.ThrowIfCancellationRequested();

          if (fieldSymbol != null && classSymbol != null && classSymbol.IsStereotype())
          {
            if (fieldSymbol.Type.IsIPropertyInfo())
            {
              foreach (var classMember in classSymbol.GetMembers())
              {
                if (classMember.Kind == SymbolKind.Property)
                {
                  var classProperty = classMember as IPropertySymbol;

                  if (!classProperty.IsIndexer)
                  {
                    if (DetermineIfPropertyUsesField(context, fieldSymbol, classProperty))
                    {
                      context.CancellationToken.ThrowIfCancellationRequested();

                      CheckForDiagnostics(context, fieldNode, fieldSymbol);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    private static void CheckForDiagnostics(SyntaxNodeAnalysisContext context, FieldDeclarationSyntax fieldNode, IFieldSymbol fieldSymbol)
    {
      var isStatic = fieldSymbol.IsStatic;
      var isPublic = fieldSymbol.DeclaredAccessibility.HasFlag(Accessibility.Public);
      var isReadOnly = fieldSymbol.IsReadOnly;

      if (!isStatic || !isPublic || !isReadOnly)
      {
        context.ReportDiagnostic(Diagnostic.Create(
          mustBePublicStaticAndReadonlyRule, fieldNode.GetLocation()));
      }
    }

    private static bool DetermineIfPropertyUsesField(SyntaxNodeAnalysisContext context, 
      IFieldSymbol fieldSymbol, IPropertySymbol classProperty, 
      Func<PropertyDeclarationSyntax, SyntaxNode> propertyBody)
    {
      var root = context.Node.SyntaxTree.GetRoot();
      var rootSpan = root.FullSpan;
      var classPropertyLocationSpan = classProperty.Locations[0].SourceSpan;

      if (rootSpan.Contains(classPropertyLocationSpan))
      {
        if (root.FindNode(classPropertyLocationSpan) is PropertyDeclarationSyntax propertyNode)
        {
          var getter = propertyBody(propertyNode);

          if (new EvaluateManagedBackingFieldsWalker(getter, context.SemanticModel, fieldSymbol).UsesField)
          {
            return true;
          }
        }
      }

      return false;
    }

    private static bool DetermineIfPropertyUsesField(SyntaxNodeAnalysisContext context,
      IFieldSymbol fieldSymbol, IPropertySymbol classProperty)
    {
      if (classProperty.GetMethod != null)
      {
        return DetermineIfPropertyUsesField(
          context, fieldSymbol, classProperty,
          propertyNode => propertyNode.ExpressionBody as SyntaxNode ??
            propertyNode.AccessorList.Accessors.Single(
              _ => _.IsKind(SyntaxKind.GetAccessorDeclaration)));
      }

      if (classProperty.SetMethod != null)
      {
        return DetermineIfPropertyUsesField(
          context, fieldSymbol, classProperty,
          propertyNode => propertyNode.AccessorList.Accessors.Single(
            _ => _.IsKind(SyntaxKind.SetAccessorDeclaration)));
      }

      return false;
    }
  }
}
---- Transformed Tree ----
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Immutable;
using System.Linq;
using static Csla.Analyzers.Extensions.ITypeSymbolExtensions;

namespace Csla.Analyzers
{
  [DiagnosticAnalyzer(LanguageNames.CSharp)]
  public sealed class EvaluateManagedBackingFieldsAnalayzer
    : DiagnosticAnalyzer
  {
    private static readonly DiagnosticDescriptor mustBePublicStaticAndReadonlyRule =
      new DiagnosticDescriptor(
        Constants.AnalyzerIdentifiers.EvaluateManagedBackingFields,
        EvaluateManagedBackingFieldsAnalayzerConstants.Title,
        EvaluateManagedBackingFieldsAnalayzerConstants.Message,
        Constants.Categories.Usage, DiagnosticSeverity.Error, true,
        helpLinkUri: HelpUrlBuilder.Build(
          Constants.AnalyzerIdentifiers.EvaluateManagedBackingFields, nameof(EvaluateManagedBackingFieldsAnalayzer)));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => 
      ImmutableArray.Create(mustBePublicStaticAndReadonlyRule);

    public override void Initialize(AnalysisContext context)
    {
      context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
      context.EnableConcurrentExecution();
      context.RegisterSyntaxNodeAction(AnalyzeFieldDeclaration, SyntaxKind.FieldDeclaration);
    }

    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context)
    {
      var fieldNode = (FieldDeclarationSyntax)context.Node;

      if (!fieldNode.ContainsDiagnostics)
      {
        foreach (var variable in fieldNode.Declaration.Variables)
        {
          var classSymbol = fieldSymbol?.ContainingType;

          context.CancellationToken.ThrowIfCancellationRequested();

          if (context.SemanticModel.GetDeclaredSymbol(variable) is IFieldSymbol fieldSymbol && classSymbol != null && classSymbol.IsStereotype())
          {
            if (fieldSymbol.Type.IsIPropertyInfo())
            {
              foreach (var classMember in classSymbol.GetMembers())
              {
                if (classMember.Kind == SymbolKind.Property)
                {
                  var classProperty = classMember as IPropertySymbol;

                  if (!classProperty.IsIndexer)
                  {
                    if (DetermineIfPropertyUsesField(context, fieldSymbol, classProperty))
                    {
                      context.CancellationToken.ThrowIfCancellationRequested();

                      CheckForDiagnostics(context, fieldNode, fieldSymbol);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    private static void CheckForDiagnostics(SyntaxNodeAnalysisContext context, FieldDeclarationSyntax fieldNode, IFieldSymbol fieldSymbol)
    {
      var isStatic = fieldSymbol.IsStatic;
      var isPublic = fieldSymbol.DeclaredAccessibility.HasFlag(Accessibility.Public);
      var isReadOnly = fieldSymbol.IsReadOnly;

      if (!isStatic || !isPublic || !isReadOnly)
      {
        context.ReportDiagnostic(Diagnostic.Create(
          mustBePublicStaticAndReadonlyRule, fieldNode.GetLocation()));
      }
    }

    private static bool DetermineIfPropertyUsesField(SyntaxNodeAnalysisContext context, 
      IFieldSymbol fieldSymbol, IPropertySymbol classProperty, 
      Func<PropertyDeclarationSyntax, SyntaxNode> propertyBody)
    {
      var root = context.Node.SyntaxTree.GetRoot();
      var rootSpan = root.FullSpan;
      var classPropertyLocationSpan = classProperty.Locations[0].SourceSpan;

      if (rootSpan.Contains(classPropertyLocationSpan))
      {
        if (root.FindNode(classPropertyLocationSpan) is PropertyDeclarationSyntax propertyNode)
        {
          var getter = propertyBody(propertyNode);

          if (new EvaluateManagedBackingFieldsWalker(getter, context.SemanticModel, fieldSymbol).UsesField)
          {
            return true;
          }
        }
      }

      return false;
    }

    private static bool DetermineIfPropertyUsesField(SyntaxNodeAnalysisContext context,
      IFieldSymbol fieldSymbol, IPropertySymbol classProperty)
    {
      if (classProperty.GetMethod != null)
      {
        return DetermineIfPropertyUsesField(
          context, fieldSymbol, classProperty,
          propertyNode => propertyNode.ExpressionBody as SyntaxNode ??
            propertyNode.AccessorList.Accessors.Single(
              _ => _.IsKind(SyntaxKind.GetAccessorDeclaration)));
      }

      if (classProperty.SetMethod != null)
      {
        return DetermineIfPropertyUsesField(
          context, fieldSymbol, classProperty,
          propertyNode => propertyNode.AccessorList.Accessors.Single(
            _ => _.IsKind(SyntaxKind.SetAccessorDeclaration)));
      }

      return false;
    }
  }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers\EvaluateManagedBackingFieldsAnalayzer.cs(43,29): error CS0841: Cannot use local variable 'fieldSymbol' before it is declared,D:\a\1\s\Source\Csla.Analyzers\Csla.Analyzers\EvaluateManagedBackingFieldsAnalayzer.cs(53,21): error CS0019: Operator '==' cannot be applied to operands of type 'method group' and 'SymbolKind'
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (Control))]
  [ProvideProperty("PostSaveAction", typeof (Control))]
  [ProvideProperty("RebindAfterSave", typeof (Control))]
  [ProvideProperty("DisableWhenClean", typeof (Control))]
  [ProvideProperty("DisableWhenUseless", typeof (Control))]
  [ProvideProperty("CommandName", typeof (Control))]
  public class CslaActionExtender : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtender(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<Control, CslaActionExtenderProperties> _sources =
      new Dictionary<Control, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is IButtonControl;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(Control ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(Control ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(Control ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      BindingSource rootSource = _dataSource as BindingSource;

      if (rootSource != null)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      Control ctl = (Control) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<Control> extendedControls = new List<Control>();
      foreach (KeyValuePair<Control, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          Control ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(Control ctl, KeyValuePair<Control, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          ITrackStatus trackableObject = businessObject as ITrackStatus;
          if (trackableObject != null)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(Control ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<Control, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          Control ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;
      BindingSource source = _dataSource as BindingSource;
      if (source != null)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (Control))]
  [ProvideProperty("PostSaveAction", typeof (Control))]
  [ProvideProperty("RebindAfterSave", typeof (Control))]
  [ProvideProperty("DisableWhenClean", typeof (Control))]
  [ProvideProperty("DisableWhenUseless", typeof (Control))]
  [ProvideProperty("CommandName", typeof (Control))]
  public class CslaActionExtender : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtender(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<Control, CslaActionExtenderProperties> _sources =
      new Dictionary<Control, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is IButtonControl;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(Control ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(Control ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(Control ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(Control ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to Control.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(Control ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the Control.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      if (_dataSource is BindingSource rootSource)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      Control ctl = (Control) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<Control> extendedControls = new List<Control>();
      foreach (KeyValuePair<Control, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          Control ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(Control ctl, KeyValuePair<Control, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          if (businessObject is ITrackStatus trackableObject)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(Control ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<Control, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          Control ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;

      if (_dataSource is BindingSource source)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtender.cs(599,88): error CS0165: Use of unassigned local variable 'rootSource'
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control (for ToolStripButton only) providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (ToolStripButton))]
  [ProvideProperty("PostSaveAction", typeof (ToolStripButton))]
  [ProvideProperty("RebindAfterSave", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenClean", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenUseless", typeof (ToolStripButton))]
  [ProvideProperty("CommandName", typeof (ToolStripButton))]
  public class CslaActionExtenderToolStrip : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtenderToolStrip(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<ToolStripButton, CslaActionExtenderProperties> _sources =
      new Dictionary<ToolStripButton, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is ToolStripButton;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(ToolStripButton ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(ToolStripButton ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(ToolStripButton ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      BindingSource rootSource = _dataSource as BindingSource;

      if (rootSource != null)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      INotifyPropertyChanged propChangedObjParent = objectToBind as INotifyPropertyChanged;
      if (propChangedObjParent != null)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      INotifyChildChanged propChangedObjChild = objectToBind as INotifyChildChanged;
      if (propChangedObjChild != null)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      ToolStripButton ctl = (ToolStripButton) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<ToolStripButton> extendedControls = new List<ToolStripButton>();
      foreach (KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          ToolStripButton ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(ToolStripButton ctl, KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          ITrackStatus trackableObject = businessObject as ITrackStatus;
          if (trackableObject != null)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(ToolStripButton ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<ToolStripButton, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          ToolStripButton ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(ToolStripButton thisToolStripButton)
    {
      return GetParentForm(thisToolStripButton.GetCurrentParent());
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;
      BindingSource source = _dataSource as BindingSource;
      if (source != null)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using Csla.Core;
using Csla.Core.FieldManager;
using Csla.Properties;

namespace Csla.Windows
{
  /// <summary>
  /// Extender control (for ToolStripButton only) providing automation around
  /// data binding to CSLA .NET business objects.
  /// </summary>
  [ToolboxItem(true)]
  [ProvideProperty("ActionType", typeof (ToolStripButton))]
  [ProvideProperty("PostSaveAction", typeof (ToolStripButton))]
  [ProvideProperty("RebindAfterSave", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenClean", typeof (ToolStripButton))]
  [ProvideProperty("DisableWhenUseless", typeof (ToolStripButton))]
  [ProvideProperty("CommandName", typeof (ToolStripButton))]
  public class CslaActionExtenderToolStrip : Component, IExtenderProvider
  {
    #region Constructors

    /// <summary>
    /// Creates an instance of the type.
    /// </summary>
    /// <param name="container">Container for the component.</param>
    public CslaActionExtenderToolStrip(IContainer container)
    {
      _container = container;
      container.Add(this);
    }

    #endregion

    #region Member variables

    private Dictionary<ToolStripButton, CslaActionExtenderProperties> _sources =
      new Dictionary<ToolStripButton, CslaActionExtenderProperties>();

    private object _dataSource = null;
    private bool _autoShowBrokenRules = true;
    private bool _warnIfCloseOnDirty = true;
    private string _dirtyWarningMessage = Resources.ActionExtenderDirtyWarningMessagePropertyDefault;
    private bool _warnOnCancel = false;
    private string _warnOnCancelMessage = Resources.ActionExtenderWarnOnCancelMessagePropertyDefault;
    private string _objectIsValidMessage = Resources.ActionExtenderObjectIsValidMessagePropertyDefault;
    private IContainer _container = null;
    private BindingSourceNode _bindingSourceTree = null;
    private bool _closeForm = false;

    #endregion

    #region IExtenderProvider implementation

    bool IExtenderProvider.CanExtend(object extendee)
    {
      return extendee is ToolStripButton;
    }

    #endregion

    #region Public properties

    /// <summary>
    /// Gets or sets a reference to the data source object.
    /// </summary>
    [Category("Data")]
    [Description("Gets or sets the data source to which this button is bound for action purposes.")]
    [AttributeProvider(typeof (IListSource))]
    public object DataSource
    {
      get { return _dataSource; }
      set
      {
        if (value != null)
        {
          if (value is BindingSource)
            _dataSource = value;
          else
            throw new ArgumentException(Resources.ActionExtenderSourceMustBeBindingSource);
        }
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to automatically
    /// show broken rules.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the broken rules will be displayed in a message box, should the object be invalid.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool AutoShowBrokenRules
    {
      get { return _autoShowBrokenRules; }
      set { _autoShowBrokenRules = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn the
    /// user on close when the object is dirty.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the control (when set to Close mode) will warn the user if the object is currently dirty.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool WarnIfCloseOnDirty
    {
      get { return _warnIfCloseOnDirty; }
      set { _warnIfCloseOnDirty = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a close on dirty warning.
    /// </summary>
    [Category("Behavior")]
    [Description("Gets or sets the confirmation message that will display if a Close button is pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue("Object is currently in a dirty changed.")]
    [Localizable(true)]
    public string DirtyWarningMessage
    {
      get { return _dirtyWarningMessage; }
      set { _dirtyWarningMessage = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether to warn
    /// the user on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If True, then the Cancel button will warn when pressed and the object is dirty.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool WarnOnCancel
    {
      get { return _warnOnCancel; }
      set { _warnOnCancel = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user
    /// in a warn on cancel.
    /// </summary>
    [Category("Behavior")]
    [Description("If the WarnOnCancel property is set to True, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Are you sure you want to revert to the previous values?")]
    [Localizable(true)]
    public string WarnOnCancelMessage
    {
      get { return _warnOnCancelMessage; }
      set { _warnOnCancelMessage = value; }
    }

    /// <summary>
    /// Gets or sets the message shown to the user when a button with a 
    /// Validate ActionType is pressed when the object is valid.
    /// </summary>
    [Category("Behavior")]
    [Description("When a button with a Validate ActionType is pressed when the object is valid, this is the message to be displayed.")]
    [Bindable(true)]
    [DefaultValue("Object is valid.")]
    [Localizable(true)]
    public string ObjectIsValidMessage
    {
      get { return _objectIsValidMessage; }
      set { _objectIsValidMessage = value; }
    }

    #endregion

    #region Property accessor methods

    #region ActionType

    /// <summary>
    /// Gets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public CslaFormAction GetActionType(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].ActionType;

      return CslaActionExtenderProperties.ActionTypeDefault;
    }

    /// <summary>
    /// Sets the action type.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action type for this button.")]
    [Bindable(true)]
    [DefaultValue(CslaFormAction.None)]
    public void SetActionType(ToolStripButton ctl, CslaFormAction value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].ActionType = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.ActionType = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region PostSaveAction

    /// <summary>
    /// Gets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <returns></returns>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public PostSaveActionType GetPostSaveAction(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].PostSaveAction;

      return CslaActionExtenderProperties.PostSaveActionDefault;
    }

    /// <summary>
    /// Sets the post save action.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the action performed after a save (if ActionType is set to Save).")]
    [Bindable(true)]
    [DefaultValue(PostSaveActionType.None)]
    public void SetPostSaveAction(ToolStripButton ctl, PostSaveActionType value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].PostSaveAction = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.PostSaveAction = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region RebindAfterSave

    /// <summary>
    /// Gets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public bool GetRebindAfterSave(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].RebindAfterSave;

      return CslaActionExtenderProperties.RebindAfterSaveDefault;
    }

    /// <summary>
    /// Sets the rebind after save value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Determines if the binding source will rebind after business object saves.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetRebindAfterSave(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].RebindAfterSave = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.RebindAfterSave = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenClean

    /// <summary>
    /// Gets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public bool GetDisableWhenClean(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenClean;

      return CslaActionExtenderProperties.DisableWhenCleanDefault;
    }

    /// <summary>
    /// Sets the disable when clean value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the dirtiness of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    [Obsolete("Use instead DisableWhenUseless")]
    [Browsable(false)]
    public void SetDisableWhenClean(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenClean = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenClean = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region DisableWhenUseless

    /// <summary>
    /// Gets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(false)]
    public bool GetDisableWhenUseless(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].DisableWhenUseless;

      return CslaActionExtenderProperties.DisableWhenUselessDefault;
    }

    /// <summary>
    /// Sets the disable when useless value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("If True, then the status of the underlying business object will cause this button to be enabled or disabled.")]
    [Bindable(true)]
    [DefaultValue(true)]
    public void SetDisableWhenUseless(ToolStripButton ctl, bool value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].DisableWhenUseless = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.DisableWhenUseless = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #region CommandName

    /// <summary>
    /// Gets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public string GetCommandName(ToolStripButton ctl)
    {
      if (_sources.ContainsKey(ctl))
        return _sources[ctl].CommandName;

      return CslaActionExtenderProperties.CommandNameDefault;
    }

    /// <summary>
    /// Sets the command name value.
    /// </summary>
    /// <param name="ctl">Reference to ToolStripButton.</param>
    /// <param name="value">Value for property.</param>
    [Category("Csla")]
    [Description("Gets or sets the name of this command control for unique identification purposes.")]
    [Bindable(true)]
    [DefaultValue("")]
    public void SetCommandName(ToolStripButton ctl, string value)
    {
      if (_sources.ContainsKey(ctl))
        _sources[ctl].CommandName = value;
      else
      {
        CslaActionExtenderProperties props = new CslaActionExtenderProperties();
        props.CommandName = value;
        _sources.Add(ctl, props);
      }
    }

    #endregion

    #endregion

    #region Event declarations

    /// <summary>
    /// Event indicating the user is clicking on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires just before the attempted action.")]
    public event EventHandler<CslaActionCancelEventArgs> Clicking;

    /// <summary>
    /// Event indicating the user clicked on the ToolStripButton.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires after a successful action.  When button is set to Save, this event will only fire upon a successful save.  If button is set to Close, this event will never fire.")]
    public event EventHandler<CslaActionEventArgs> Clicked;

    /// <summary>
    /// Event indicating an error was encountered.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon encountering any exception during an action.")]
    public event EventHandler<ErrorEncounteredEventArgs> ErrorEncountered;

    /// <summary>
    /// Event indicating the object is set for new.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires upon a successful save when the PostSaveAction property is set to AndNew.")]
    public event EventHandler<CslaActionEventArgs> SetForNew;

    /// <summary>
    /// Event indicating the business object is in an invalid state.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires when the object is in an invalid state.  Note that this event will work in conjunction with the InvalidateOnWarnings and InvalidateOnInformation properties.")]
    public event EventHandler<CslaActionEventArgs> BusinessObjectInvalid;

    /// <summary>
    /// Event indicating the business object has broken rules.
    /// </summary>
    [Category("Csla")]
    [Description("Event fires if there are any broken rules at all, despite severity.")]
    public event EventHandler<HasBrokenRulesEventArgs> HasBrokenRules;

    /// <summary>
    /// Event indicating that the object is saving.
    /// </summary>
    [Category("Csla")]
    [Description("Fires just before a save action is performed.")]
    public event EventHandler<CslaActionCancelEventArgs> ObjectSaving;

    /// <summary>
    /// Event indicating that the object has been saved.
    /// </summary>
    [Category("Csla")]
    [Description("Fires immediately after the underlying object successfully saves.")]
    public event EventHandler<CslaActionEventArgs> ObjectSaved;

    #endregion

    #region OnEvent methods

    /// <summary>
    /// Raises the Clicking event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicking(CslaActionCancelEventArgs e)
    {
      if (Clicking != null)
        Clicking(this, e);
    }

    /// <summary>
    /// Raises the Clicked event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnClicked(CslaActionEventArgs e)
    {
      if (Clicked != null)
        Clicked(this, e);
    }

    /// <summary>
    /// Raises the ErrorEncountered event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnErrorEncountered(ErrorEncounteredEventArgs e)
    {
      if (ErrorEncountered != null)
        ErrorEncountered(this, e);
    }

    /// <summary>
    /// Raises the SetForNew event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnSetForNew(CslaActionEventArgs e)
    {
      if (SetForNew != null)
        SetForNew(this, e);
    }

    /// <summary>
    /// Raises the BusinessObjectInvalid event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnBusinessObjectInvalid(CslaActionEventArgs e)
    {
      if (BusinessObjectInvalid != null)
        BusinessObjectInvalid(this, e);
    }

    /// <summary>
    /// Raises the HasBrokenRules event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnHasBrokenRules(HasBrokenRulesEventArgs e)
    {
      if (HasBrokenRules != null)
        HasBrokenRules(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaving event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaving(CslaActionCancelEventArgs e)
    {
      if (ObjectSaving != null)
        ObjectSaving(this, e);
    }

    /// <summary>
    /// Raises the ObjectSaved event.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected virtual void OnObjectSaved(CslaActionEventArgs e)
    {
      if (ObjectSaved != null)
        ObjectSaved(this, e);
    }

    #endregion

    #region Public methods

    /// <summary>
    /// Resets all action behaviors.
    /// </summary>
    /// <param name="objectToBind">Target object.</param>
    public void ResetActionBehaviors(ISavable objectToBind)
    {
      InitializeControls(true);

      if (_dataSource is BindingSource rootSource)
      {
        AddEventHooks(objectToBind);
      }

      _bindingSourceTree = BindingSourceHelper.InitializeBindingSourceTree(_container, rootSource);
      _bindingSourceTree.Bind(objectToBind);
    }

    private void AddEventHooks(ISavable objectToBind)
    {
      // make sure to not attach many times
      RemoveEventHooks(objectToBind);

      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged += propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged += propChangedObj_ChildChanged;
      }
    }

    private void RemoveEventHooks(ISavable objectToBind)
    {
      if (objectToBind is INotifyPropertyChanged propChangedObjParent)
      {
        propChangedObjParent.PropertyChanged -= propChangedObj_PropertyChanged;
      }

      if (objectToBind is INotifyChildChanged propChangedObjChild)
      {
        propChangedObjChild.ChildChanged -= propChangedObj_ChildChanged;
      }
    }

    private void propChangedObj_ChildChanged(object sender, ChildChangedEventArgs e)
    {
      ResetControls();
    }

    private void propChangedObj_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      ResetControls();
    }

    #endregion

    #region Protected methods

    /// <summary>
    /// Method invoked when the target control is clicked.
    /// </summary>
    /// <param name="sender">Object originating action.</param>
    /// <param name="e">Arguments.</param>
    protected void OnClick(object sender, EventArgs e)
    {
      ToolStripButton ctl = (ToolStripButton) sender;
      CslaActionExtenderProperties props = _sources[ctl];
      if (props.ActionType != CslaFormAction.None)
      {
        try
        {
          bool raiseClicked = true;
          CslaActionCancelEventArgs args = new CslaActionCancelEventArgs(false, props.CommandName);
          OnClicking(args);
          if (!args.Cancel)
          {
            ISavable savableObject = null;
            ITrackStatus trackableObject = null;
            BindingSource source = null;

            var sourceObjectError = false;
            if (_dataSource != null)
            {
              source = _dataSource as BindingSource;

              if (source != null)
              {
                savableObject = source.DataSource as ISavable;
                trackableObject = source.DataSource as ITrackStatus;
              }
              else
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBindingSourceCast)));
                sourceObjectError = true;
              }

              if (savableObject == null || trackableObject == null)
              {
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new InvalidCastException(Resources.ActionExtenderInvalidBusinessObjectBaseCast)));
                sourceObjectError = true;
              }
            }

            if (!sourceObjectError)
            {
              DialogResult diagResult;

              switch (props.ActionType)
              {
                case CslaFormAction.Save:
                  raiseClicked = ExecuteSaveAction(savableObject, trackableObject, props);
                  break;
                // case CslaFormAction.Save

                case CslaFormAction.Cancel:

                  diagResult = DialogResult.Yes;
                  if (_warnOnCancel && trackableObject.IsDirty)
                    diagResult = MessageBox.Show(
                      _warnOnCancelMessage, Resources.Warning,
                      MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                  if (diagResult == DialogResult.Yes)
                    _bindingSourceTree.Cancel(savableObject);

                  break;
                // case CslaFormAction.Cancel

                case CslaFormAction.Close:

                  diagResult = DialogResult.Yes;
                  if (trackableObject.IsDirty || trackableObject.IsNew)
                  {
                    if (_warnIfCloseOnDirty)
                      diagResult = MessageBox.Show(
                        _dirtyWarningMessage + Environment.NewLine + Resources.ActionExtenderCloseConfirmation,
                        Resources.Warning, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                  }

                  if (diagResult == DialogResult.Yes)
                  {
                    _bindingSourceTree.Close();
                    _closeForm = true;
                  }

                  break;
                // case CslaFormAction.Close

                case CslaFormAction.Validate:

                  if (savableObject is BusinessBase)
                  {
                    BusinessBase businessObject = savableObject as BusinessBase;
                    if (!businessObject.IsValid)
                    {
                      string brokenRules = string.Empty;
                      foreach (var brokenRule in businessObject.GetBrokenRules())
                      {
                        var lambdaBrokenRule = brokenRule;
                        var friendlyName =
                          PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                            c => c.Name == lambdaBrokenRule.Property).FriendlyName;
                        brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
                      }
                      MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    else
                    {
                      MessageBox.Show(_objectIsValidMessage, Resources.ActionExtenderInformationCaption,
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                  }

                  break;
                //case CslaFormAction.Validate

              } // switch (props.ActionType)

              // raiseClicked is true if
              // ActionType == CslaFormAction.Save and everything is ok
              if (raiseClicked)
              {
                if (props.ActionType == CslaFormAction.Save && source != null)
                {
                  if (props.RebindAfterSave)
                  {
                    // For some strange reason, this has to be done down here.
                    // Putting it in the Select Case AfterSave... does not work.
                    _bindingSourceTree.ResetBindings(false);
                    InitializeControls(true);
                  }
                }
                else
                {
                  if (props.ActionType == CslaFormAction.Cancel)
                    InitializeControls(true);
                }

                OnClicked(new CslaActionEventArgs(props.CommandName));
              }

            } // if (!sourceObjectError)

          } // if (!args.Cancel)

          if (_closeForm)
            CloseForm();
        }
        catch (Exception ex)
        {
          OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, ex));
        }
      } // if (props.ActionType != CslaFormAction.None)
    }

    #endregion

    #region Private methods

    private bool ExecuteSaveAction(ISavable savableObject, ITrackStatus trackableObject, CslaActionExtenderProperties props)
    {
      var result = true;
      bool okToContinue = true;

      BusinessBase businessObject = null;
      bool savableObjectIsBusinessBase = savableObject is BusinessBase;
      if (savableObjectIsBusinessBase)
        businessObject = savableObject as BusinessBase;

      if (savableObjectIsBusinessBase)
      {
        if (!businessObject.IsValid)
        {
          HasBrokenRulesEventArgs argsHasBrokenRules = new HasBrokenRulesEventArgs(
            props.CommandName,
            businessObject.GetBrokenRules().ErrorCount > 0,
            businessObject.GetBrokenRules().WarningCount > 0,
            businessObject.GetBrokenRules().InformationCount > 0,
            _autoShowBrokenRules);

          OnHasBrokenRules(argsHasBrokenRules);

          okToContinue = !argsHasBrokenRules.Cancel;
          //in case the client changed it
          _autoShowBrokenRules = argsHasBrokenRules.AutoShowBrokenRules;
        }
      }

      if (okToContinue)
      {
        if (savableObjectIsBusinessBase)
        {
          if (_autoShowBrokenRules && !businessObject.IsValid)
          {
            string brokenRules = string.Empty;
            foreach (var brokenRule in businessObject.GetBrokenRules())
            {
              var lambdaBrokenRule = brokenRule;
              var friendlyName =
                PropertyInfoManager.GetRegisteredProperties(businessObject.GetType()).Find(
                  c => c.Name == lambdaBrokenRule.Property).FriendlyName;
              brokenRules += string.Format("{0}: {1}{2}", friendlyName, brokenRule, Environment.NewLine);
            }
            MessageBox.Show(brokenRules, Resources.ActionExtenderErrorCaption,
              MessageBoxButtons.OK, MessageBoxIcon.Error);
          }
        }

        if (trackableObject.IsValid)
        {
          CslaActionCancelEventArgs savingArgs = new CslaActionCancelEventArgs(false, props.CommandName);
          OnObjectSaving(savingArgs);

          if (!savingArgs.Cancel)
          {
            _bindingSourceTree.Apply();
            ISavable objectToSave;

            if (Csla.ApplicationContext.AutoCloneOnUpdate == false)
              objectToSave = ((ICloneable)savableObject).Clone() as ISavable;// if not AutoClone, clone manually
            else
              objectToSave = savableObject;

            if (objectToSave != null)
            {
              try
              {
                RemoveEventHooks(savableObject);
                savableObject = savableObject.Save() as ISavable;

                OnObjectSaved(new CslaActionEventArgs(props.CommandName));

                switch (props.PostSaveAction)
                {
                  case PostSaveActionType.None:

                    if (props.RebindAfterSave)
                    {
                      _bindingSourceTree.Bind(savableObject);
                      AddEventHooks(savableObject);
                    }
                    break;

                  case PostSaveActionType.AndClose:

                    CloseForm();
                    break;

                  case PostSaveActionType.AndNew:

                    OnSetForNew(new CslaActionEventArgs(props.CommandName));
                    AddEventHooks(savableObject);
                    break;
                }
              }
              catch (Exception ex)
              {
                _bindingSourceTree.Bind(objectToSave);
                AddEventHooks(objectToSave);
                OnErrorEncountered(new ErrorEncounteredEventArgs(props.CommandName, new ObjectSaveException(ex)));
                // there was some problem
                result = false;
              }
            }
            else
            {
              // did not find bound object so don't bother raising the Clicked event
              result = false;
            }

            _bindingSourceTree.SetEvents(true);
          }
        }
        else
        {
          OnBusinessObjectInvalid(new CslaActionEventArgs(props.CommandName));
          // object not valid or has broken rules set to invalidate it due to this control's properties
          result = false;
        }
      }
      else
      {
        // process was canceled from the HasBrokenRules event (okToContinue = false)
        result = false;
      }

      return result;
    }

    private void ResetControls()
    {
      InitializeControls(false);
    }

    private void InitializeControls(bool initialEnabling)
    {
      // controls will not be enabled until the BusinessObjectPropertyChanged event fires or if it's in an appropriate state now
      List<ToolStripButton> extendedControls = new List<ToolStripButton>();
      foreach (KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair in _sources)
      {
        if (pair.Value.ActionType != CslaFormAction.None)
        {
          ToolStripButton ctl = pair.Key;
          if (initialEnabling)
          {
            if (pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, !(pair.Value.DisableWhenUseless || pair.Value.DisableWhenClean));
            pair.Key.Click -= OnClick;
            pair.Key.Click += OnClick;
          }
          InitializeControl(ctl, pair);
          extendedControls.Add(ctl);
        }
      }
    }

    private void InitializeControl(ToolStripButton ctl, KeyValuePair<ToolStripButton, CslaActionExtenderProperties> pair)
    {
      if (pair.Value.DisableWhenUseless || (pair.Value.DisableWhenClean && !ctl.Enabled))
      {
        ISavable businessObject = GetBusinessObject();
        if (businessObject != null)
        {
          if (businessObject is ITrackStatus trackableObject)
          {
            if (pair.Value.ActionType == CslaFormAction.Cancel || pair.Value.DisableWhenClean)
              ChangeEnabled(ctl, trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted);
            if (pair.Value.ActionType == CslaFormAction.Save)
              ChangeEnabled(ctl, (trackableObject.IsNew || trackableObject.IsDirty || trackableObject.IsDeleted)
                && trackableObject.IsValid);
          }
        }
      }
    }

    private void ChangeEnabled(ToolStripButton ctl, bool newEnabled)
    {
      // only do this if it's changed to avoid flicker
      if (ctl.Enabled != newEnabled)
        ctl.Enabled = newEnabled;
    }

    private void CloseForm()
    {
      if (_sources.Count > 0)
      {
        Dictionary<ToolStripButton, CslaActionExtenderProperties>.Enumerator enumerator = _sources.GetEnumerator();
        if (enumerator.MoveNext())
        {
          ToolStripButton ctl = enumerator.Current.Key;
          Form frm = GetParentForm(ctl);
          if (frm != null)
            frm.Close();
        }
      }
    }

    private Form GetParentForm(ToolStripButton thisToolStripButton)
    {
      return GetParentForm(thisToolStripButton.GetCurrentParent());
    }

    private Form GetParentForm(Control thisControl)
    {
      Form frm;

      if (thisControl.Parent is Form)
        frm = (Form) thisControl.Parent;
      else
        frm = GetParentForm(thisControl.Parent);

      return frm;
    }

    private ISavable GetBusinessObject()
    {
      ISavable businessObject = null;

      if (_dataSource is BindingSource source)
        businessObject = source.DataSource as ISavable;

      return businessObject;
    }

    #endregion
  }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Windows.Shared\CslaActionExtenderToolStrip.cs(599,88): error CS0165: Use of unassigned local variable 'rootSource'
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProvider.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;
using System.Reflection;
using Csla.Reflection;
using Csla.Properties;

namespace Csla.Xaml
{
  /// <summary>
  /// Wraps and creates a CSLA .NET-style object 
  /// that you can use as a binding source.
  /// </summary>
  public class CslaDataProvider : DataSourceProvider
  {

    /// <summary>
    /// Creates an instance of the object.
    /// </summary>
    public CslaDataProvider()
    {
      _commandManager = new CslaDataProviderCommandManager(this);
      _factoryParameters = new ObservableCollection<object>();
      _factoryParameters.CollectionChanged += 
        new System.Collections.Specialized.NotifyCollectionChangedEventHandler(_factoryParameters_CollectionChanged);
    }

    /// <summary>
    /// Event raised when the object has been saved.
    /// </summary>
    public event EventHandler<Csla.Core.SavedEventArgs> Saved;
    /// <summary>
    /// Raise the Saved event when the object has been saved.
    /// </summary>
    /// <param name="newObject">New object reference as a result
    /// of the save operation.</param>
    /// <param name="error">Reference to an exception object if
    /// an error occurred.</param>
    /// <param name="userState">Reference to a userstate object.</param>
    protected virtual void OnSaved(object newObject, Exception error, object userState)
    {
      if (Saved != null)
        Saved(this, new Csla.Core.SavedEventArgs(newObject, error, userState));
    }

    void _factoryParameters_CollectionChanged(
      object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
      BeginQuery();
    }

#region Properties

    private Type _objectType = null;
    private bool _manageLifetime;
    private string _factoryMethod = string.Empty;
    private ObservableCollection<object> _factoryParameters;
    private bool _isAsynchronous;
    private CslaDataProviderCommandManager _commandManager;
    private bool _isBusy;

    /// <summary>
    /// Gets an object that can be used to execute
    /// Save and Undo commands on this CslaDataProvider 
    /// through XAML command bindings.
    /// </summary>
    public CslaDataProviderCommandManager CommandManager
    {
      get
      {
        return _commandManager;
      }
    }

    /// <summary>
    /// Gets or sets the type of object 
    /// to create an instance of.
    /// </summary>
    public Type ObjectType
    {
      get 
      { 
        return _objectType; 
      }
      set 
      { 
        _objectType = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectType"));
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the
    /// data control should manage the lifetime of
    /// the business object, including using n-level
    /// undo.
    /// </summary>
    public bool ManageObjectLifetime
    {
      get
      {
        return _manageLifetime;
      }
      set
      {
        _manageLifetime = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ManageObjectLifetime"));
      }
    }

    private object _dataChangedHandler;

    /// <summary>
    /// Gets or sets a reference to an object that
    /// will handle the DataChanged event raised
    /// by this data provider.
    /// </summary>
    /// <remarks>
    /// This property is designed to 
    /// reference an IErrorDialog control.
    /// </remarks>
    public object DataChangedHandler
    {
      get
      {
        return _dataChangedHandler;
      }
      set
      {
        _dataChangedHandler = value;
        var dialog = value as IErrorDialog;
        if (dialog != null)
          dialog.Register(this);
        OnPropertyChanged(new PropertyChangedEventArgs("DataChangedHandler"));
      }
    }

    /// <summary>
    /// Gets or sets the name of the static
    /// (Shared in Visual Basic) factory method
    /// that should be called to create the
    /// object instance.
    /// </summary>
    public string FactoryMethod
    {
      get
      {
        return _factoryMethod;
      }
      set
      {
        _factoryMethod = value;
        OnPropertyChanged(new PropertyChangedEventArgs("FactoryMethod"));
      }
    }

    /// <summary>
    /// Get the list of parameters to pass
    /// to the factory method.
    /// </summary>
    public IList FactoryParameters
    {
      get
      {
        return _factoryParameters;
      }
    }

    /// <summary>
    /// Gets or sets a value that indicates 
    /// whether to perform object creation in 
    /// a worker thread or in the active context.
    /// </summary>
    public bool IsAsynchronous
    {
      get { return _isAsynchronous; }
      set { _isAsynchronous = value; }
    }

    /// <summary>
    /// Gets or sets a reference to the data
    /// object.
    /// </summary>
    public object ObjectInstance
    {
      get { return Data; }
      set 
      {
        OnQueryFinished(value, null, null, null);
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectInstance"));
      }
    }

    /// <summary>
    /// Gets a value indicating if this object is busy.
    /// </summary>
    public bool IsBusy
    {
      get { return _isBusy; }
      protected set
      {
        _isBusy = value;
        OnPropertyChanged(new PropertyChangedEventArgs("IsBusy"));
      }
    }

    /// <summary>
    /// Triggers WPF data binding to rebind to the
    /// data object.
    /// </summary>
    public void Rebind()
    {
      object tmp = ObjectInstance;
      ObjectInstance = null;
      ObjectInstance = tmp;
    }

#endregion

#region Query

    private bool _firstRun = true;
    private bool _init = false;
    private bool _endInitCompete = false;
    private bool _endInitError = false;

    /// <summary>
    /// Indicates that the control is about to initialize.
    /// </summary>
    protected override void BeginInit()
    {
      _init = true;
      base.BeginInit();
    }

    /// <summary>
    /// Indicates that the control has initialized.
    /// </summary>
    protected override void EndInit()
    {
      _init = false;
      base.EndInit();
      _endInitCompete = true;
    }

    /// <summary>
    /// Overridden. Starts to create the requested object, 
    /// either immediately or on a background thread, 
    /// based on the value of the IsAsynchronous property.
    /// </summary>
    protected override void BeginQuery()
    {
      if (_init)
        return;

      if (_firstRun)
      {
        _firstRun = false;
        if (!IsInitialLoadEnabled)
          return;
      }

      if (_endInitError)
      {
        // this handles a case where the WPF form initilizer
        // invokes the data provider twice when an exception
        // occurs - we really don't want to try the query twice
        // or report the error twice
        _endInitError = false;
        OnQueryFinished(null);
        return;
      }

      if (this.IsRefreshDeferred)
        return;

      QueryRequest request = new QueryRequest();
      request.ObjectType = _objectType;
      request.FactoryMethod = _factoryMethod;
      request.FactoryParameters = _factoryParameters;
      request.ManageObjectLifetime = _manageLifetime;

      IsBusy = true;

      if (IsAsynchronous)
        System.Threading.ThreadPool.QueueUserWorkItem(DoQuery, request);
      else
        DoQuery(request);
    }

    private void DoQuery(object state)
    {
      QueryRequest request = (QueryRequest)state;
      object result = null;
      Exception exceptionResult = null;
      object[] parameters = new List<object>(request.FactoryParameters).ToArray();

      try
      {
        // get factory method info
        BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy;
        System.Reflection.MethodInfo factory = request.ObjectType.GetMethod(
          request.FactoryMethod, flags, null, 
          MethodCaller.GetParameterTypes(parameters), null);

        if (factory == null)
        {
          // strongly typed factory couldn't be found
          // so find one with the correct number of
          // parameters 
          int parameterCount = parameters.Length;
          System.Reflection.MethodInfo[] methods = request.ObjectType.GetMethods(flags);
          foreach (System.Reflection.MethodInfo method in methods)
            if (method.Name == request.FactoryMethod && method.GetParameters().Length == parameterCount)
            {
              factory = method;
              break;
            }
        }

        if (factory == null)
        {
          // no matching factory could be found
          // so throw exception
          throw new InvalidOperationException(
            string.Format(Resources.NoSuchFactoryMethod, request.FactoryMethod));
        }

        // invoke factory method
        try
        {
          result = factory.Invoke(null, parameters);
        }
        catch (Csla.DataPortalException ex)
        {
          exceptionResult = ex.BusinessException;
        }
        catch (System.Reflection.TargetInvocationException ex)
        {
          if (ex.InnerException != null)
          {
            exceptionResult = ex.InnerException;
            var dpe = exceptionResult as Csla.DataPortalException;
            if (dpe?.BusinessException != null)
              exceptionResult = dpe.BusinessException;
          }
          else
            exceptionResult = ex;
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
      }
      catch (Exception ex)
      {
        exceptionResult = ex;
      }

      if (request.ManageObjectLifetime && result != null)
      {
        Csla.Core.ISupportUndo undo = result as Csla.Core.ISupportUndo;
        if (undo != null)
          undo.BeginEdit();
      }

      //if (!System.Windows.Application.Current.Dispatcher.CheckAccess())
      //  System.Windows.Application.Current.Dispatcher.Invoke(
      //    new Action(() => { IsBusy = false; }), 
      //    new object[] { });

      if (!_endInitCompete && exceptionResult != null)
        _endInitError = true;

      // return result to base class
      OnQueryFinished(result, exceptionResult, (o) => { IsBusy = false; return null; }, null);
    }

#region QueryRequest Class

    private class QueryRequest
    {
      private Type _objectType;

      public Type ObjectType
      {
        get { return _objectType; }
        set { _objectType = value; }
      }

      private string _factoryMethod;

      public string FactoryMethod
      {
        get { return _factoryMethod; }
        set { _factoryMethod = value; }
      }

      private ObservableCollection<object> _factoryParameters;

      public ObservableCollection<object> FactoryParameters
      {
        get { return _factoryParameters; }
        set { _factoryParameters = 
          new ObservableCollection<object>(new List<object>(value)); }
      }
      private bool _manageLifetime;

      public bool ManageObjectLifetime
      {
        get { return _manageLifetime; }
        set { _manageLifetime = value; }
      }
	
    }

#endregion

#endregion

#region Cancel/Update/New/Remove  

    /// <summary>
    /// Cancels changes to the business object, returning
    /// it to its previous state.
    /// </summary>
    /// <remarks>
    /// This metod does nothing unless ManageLifetime is
    /// set to true and the object supports n-level undo.
    /// </remarks>
    public void Cancel()
    {
      Csla.Core.ISupportUndo undo = this.Data as Csla.Core.ISupportUndo;
      if (undo != null && _manageLifetime)
      {
        IsBusy = true;
        undo.CancelEdit();
        undo.BeginEdit();
        IsBusy = false;
      }
    }

    /// <summary>
    /// Accepts changes to the business object, and
    /// commits them by calling the object's Save()
    /// method.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method does nothing unless the object
    /// implements Csla.Core.ISavable.
    /// </para><para>
    /// If the object implements IClonable, it
    /// will be cloned, and the clone will be
    /// saved.
    /// </para><para>
    /// If the object supports n-level undo and
    /// ManageLifetime is true, then this method
    /// will automatically call ApplyEdit() and
    /// BeginEdit() appropriately.
    /// </para>
    /// </remarks>
    public void Save()
    {
      // only do something if the object implements
      // ISavable
      Csla.Core.ISavable savable = this.Data as Csla.Core.ISavable;
      if (savable != null)
      {
        object result = savable;
        Exception exceptionResult = null;
        try
        {
          IsBusy = true;

          // clone the object if possible
          ICloneable clonable = savable as ICloneable;
          if (clonable != null)
            savable = (Csla.Core.ISavable)clonable.Clone();

          // apply edits in memory
          Csla.Core.ISupportUndo undo = savable as Csla.Core.ISupportUndo;
          if (undo != null && _manageLifetime)
            undo.ApplyEdit();


          // save the clone
          result = savable.Save();

          if (!ReferenceEquals(savable, this.Data) && !Csla.ApplicationContext.AutoCloneOnUpdate)
          {
            // raise Saved event from original object
            Core.ISavable original = this.Data as Core.ISavable;
            if (original != null)
              original.SaveComplete(result);
          }

          // start editing the resulting object
          undo = result as Csla.Core.ISupportUndo;
          if (undo != null && _manageLifetime)
            undo.BeginEdit();
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
        // clear previous object
        OnQueryFinished(null, exceptionResult, null, null);
        // return result to base class
        OnQueryFinished(result, null, null, null);
        IsBusy = false;
        OnSaved(result, exceptionResult, null);
      }
    }


    /// <summary>
    /// Adds a new item to the object if the object
    /// implements IBindingList and AllowNew is true.
    /// </summary>
    public object AddNew()
    {
      // only do something if the object implements
      // IBindingList
      IBindingList list = this.Data as IBindingList;
      if (list != null && list.AllowNew)
        return list.AddNew();
      else
        return null;

    }

    /// <summary>
    /// Removes an item from the list if the object
    /// implements IBindingList and AllowRemove is true.
    /// </summary>
    /// <param name="sender">Object invoking this method.</param>
    /// <param name="e">
    /// ExecuteEventArgs, where MethodParameter contains 
    /// the item to be removed from the list.
    /// </param>
    public void RemoveItem(object sender, ExecuteEventArgs e)
    {
      var item = e.MethodParameter;
      // only do something if the object implements
      // IBindingList
      IBindingList list;
      Csla.Core.BusinessBase bb = item as Csla.Core.BusinessBase;
      if (bb != null)
        list = bb.Parent as IBindingList;
      else
        list = this.Data as IBindingList;
      if (list != null && list.AllowRemove)
        list.Remove(item);
    }

#endregion

  }
}
#endif
---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;
using System.Reflection;
using Csla.Reflection;
using Csla.Properties;

namespace Csla.Xaml
{
  /// <summary>
  /// Wraps and creates a CSLA .NET-style object 
  /// that you can use as a binding source.
  /// </summary>
  public class CslaDataProvider : DataSourceProvider
  {

    /// <summary>
    /// Creates an instance of the object.
    /// </summary>
    public CslaDataProvider()
    {
      _commandManager = new CslaDataProviderCommandManager(this);
      _factoryParameters = new ObservableCollection<object>();
      _factoryParameters.CollectionChanged += 
        new System.Collections.Specialized.NotifyCollectionChangedEventHandler(_factoryParameters_CollectionChanged);
    }

    /// <summary>
    /// Event raised when the object has been saved.
    /// </summary>
    public event EventHandler<Csla.Core.SavedEventArgs> Saved;
    /// <summary>
    /// Raise the Saved event when the object has been saved.
    /// </summary>
    /// <param name="newObject">New object reference as a result
    /// of the save operation.</param>
    /// <param name="error">Reference to an exception object if
    /// an error occurred.</param>
    /// <param name="userState">Reference to a userstate object.</param>
    protected virtual void OnSaved(object newObject, Exception error, object userState)
    {
      if (Saved != null)
        Saved(this, new Csla.Core.SavedEventArgs(newObject, error, userState));
    }

    void _factoryParameters_CollectionChanged(
      object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
      BeginQuery();
    }

#region Properties

    private Type _objectType = null;
    private bool _manageLifetime;
    private string _factoryMethod = string.Empty;
    private ObservableCollection<object> _factoryParameters;
    private bool _isAsynchronous;
    private CslaDataProviderCommandManager _commandManager;
    private bool _isBusy;

    /// <summary>
    /// Gets an object that can be used to execute
    /// Save and Undo commands on this CslaDataProvider 
    /// through XAML command bindings.
    /// </summary>
    public CslaDataProviderCommandManager CommandManager
    {
      get
      {
        return _commandManager;
      }
    }

    /// <summary>
    /// Gets or sets the type of object 
    /// to create an instance of.
    /// </summary>
    public Type ObjectType
    {
      get 
      { 
        return _objectType; 
      }
      set 
      { 
        _objectType = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectType"));
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the
    /// data control should manage the lifetime of
    /// the business object, including using n-level
    /// undo.
    /// </summary>
    public bool ManageObjectLifetime
    {
      get
      {
        return _manageLifetime;
      }
      set
      {
        _manageLifetime = value;
        OnPropertyChanged(new PropertyChangedEventArgs("ManageObjectLifetime"));
      }
    }

    private object _dataChangedHandler;

    /// <summary>
    /// Gets or sets a reference to an object that
    /// will handle the DataChanged event raised
    /// by this data provider.
    /// </summary>
    /// <remarks>
    /// This property is designed to 
    /// reference an IErrorDialog control.
    /// </remarks>
    public object DataChangedHandler
    {
      get
      {
        return _dataChangedHandler;
      }
      set
      {
        _dataChangedHandler = value;
        var dialog = value as IErrorDialog;
        if (dialog != null)
          dialog.Register(this);
        OnPropertyChanged(new PropertyChangedEventArgs("DataChangedHandler"));
      }
    }

    /// <summary>
    /// Gets or sets the name of the static
    /// (Shared in Visual Basic) factory method
    /// that should be called to create the
    /// object instance.
    /// </summary>
    public string FactoryMethod
    {
      get
      {
        return _factoryMethod;
      }
      set
      {
        _factoryMethod = value;
        OnPropertyChanged(new PropertyChangedEventArgs("FactoryMethod"));
      }
    }

    /// <summary>
    /// Get the list of parameters to pass
    /// to the factory method.
    /// </summary>
    public IList FactoryParameters
    {
      get
      {
        return _factoryParameters;
      }
    }

    /// <summary>
    /// Gets or sets a value that indicates 
    /// whether to perform object creation in 
    /// a worker thread or in the active context.
    /// </summary>
    public bool IsAsynchronous
    {
      get { return _isAsynchronous; }
      set { _isAsynchronous = value; }
    }

    /// <summary>
    /// Gets or sets a reference to the data
    /// object.
    /// </summary>
    public object ObjectInstance
    {
      get { return Data; }
      set 
      {
        OnQueryFinished(value, null, null, null);
        OnPropertyChanged(new PropertyChangedEventArgs("ObjectInstance"));
      }
    }

    /// <summary>
    /// Gets a value indicating if this object is busy.
    /// </summary>
    public bool IsBusy
    {
      get { return _isBusy; }
      protected set
      {
        _isBusy = value;
        OnPropertyChanged(new PropertyChangedEventArgs("IsBusy"));
      }
    }

    /// <summary>
    /// Triggers WPF data binding to rebind to the
    /// data object.
    /// </summary>
    public void Rebind()
    {
      object tmp = ObjectInstance;
      ObjectInstance = null;
      ObjectInstance = tmp;
    }

#endregion

#region Query

    private bool _firstRun = true;
    private bool _init = false;
    private bool _endInitCompete = false;
    private bool _endInitError = false;

    /// <summary>
    /// Indicates that the control is about to initialize.
    /// </summary>
    protected override void BeginInit()
    {
      _init = true;
      base.BeginInit();
    }

    /// <summary>
    /// Indicates that the control has initialized.
    /// </summary>
    protected override void EndInit()
    {
      _init = false;
      base.EndInit();
      _endInitCompete = true;
    }

    /// <summary>
    /// Overridden. Starts to create the requested object, 
    /// either immediately or on a background thread, 
    /// based on the value of the IsAsynchronous property.
    /// </summary>
    protected override void BeginQuery()
    {
      if (_init)
        return;

      if (_firstRun)
      {
        _firstRun = false;
        if (!IsInitialLoadEnabled)
          return;
      }

      if (_endInitError)
      {
        // this handles a case where the WPF form initilizer
        // invokes the data provider twice when an exception
        // occurs - we really don't want to try the query twice
        // or report the error twice
        _endInitError = false;
        OnQueryFinished(null);
        return;
      }

      if (this.IsRefreshDeferred)
        return;

      QueryRequest request = new QueryRequest();
      request.ObjectType = _objectType;
      request.FactoryMethod = _factoryMethod;
      request.FactoryParameters = _factoryParameters;
      request.ManageObjectLifetime = _manageLifetime;

      IsBusy = true;

      if (IsAsynchronous)
        System.Threading.ThreadPool.QueueUserWorkItem(DoQuery, request);
      else
        DoQuery(request);
    }

    private void DoQuery(object state)
    {
      QueryRequest request = (QueryRequest)state;
      object result = null;
      Exception exceptionResult = null;
      object[] parameters = new List<object>(request.FactoryParameters).ToArray();

      try
      {
        // get factory method info
        BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy;
        System.Reflection.MethodInfo factory = request.ObjectType.GetMethod(
          request.FactoryMethod, flags, null, 
          MethodCaller.GetParameterTypes(parameters), null);

        if (factory == null)
        {
          // strongly typed factory couldn't be found
          // so find one with the correct number of
          // parameters 
          int parameterCount = parameters.Length;
          System.Reflection.MethodInfo[] methods = request.ObjectType.GetMethods(flags);
          foreach (System.Reflection.MethodInfo method in methods)
            if (method.Name == request.FactoryMethod && method.GetParameters().Length == parameterCount)
            {
              factory = method;
              break;
            }
        }

        if (factory == null)
        {
          // no matching factory could be found
          // so throw exception
          throw new InvalidOperationException(
            string.Format(Resources.NoSuchFactoryMethod, request.FactoryMethod));
        }

        // invoke factory method
        try
        {
          result = factory.Invoke(null, parameters);
        }
        catch (Csla.DataPortalException ex)
        {
          exceptionResult = ex.BusinessException;
        }
        catch (System.Reflection.TargetInvocationException ex)
        {
          if (ex.InnerException != null)
          {
            exceptionResult = ex.InnerException;
            var dpe = exceptionResult as Csla.DataPortalException;
            if (dpe?.BusinessException != null)
              exceptionResult = dpe.BusinessException;
          }
          else
            exceptionResult = ex;
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
      }
      catch (Exception ex)
      {
        exceptionResult = ex;
      }

      if (request.ManageObjectLifetime && result != null)
      {
        if (result is Csla.Core.ISupportUndo undo)
          undo.BeginEdit();
      }

      //if (!System.Windows.Application.Current.Dispatcher.CheckAccess())
      //  System.Windows.Application.Current.Dispatcher.Invoke(
      //    new Action(() => { IsBusy = false; }), 
      //    new object[] { });

      if (!_endInitCompete && exceptionResult != null)
        _endInitError = true;

      // return result to base class
      OnQueryFinished(result, exceptionResult, (o) => { IsBusy = false; return null; }, null);
    }

#region QueryRequest Class

    private class QueryRequest
    {
      private Type _objectType;

      public Type ObjectType
      {
        get { return _objectType; }
        set { _objectType = value; }
      }

      private string _factoryMethod;

      public string FactoryMethod
      {
        get { return _factoryMethod; }
        set { _factoryMethod = value; }
      }

      private ObservableCollection<object> _factoryParameters;

      public ObservableCollection<object> FactoryParameters
      {
        get { return _factoryParameters; }
        set { _factoryParameters = 
          new ObservableCollection<object>(new List<object>(value)); }
      }
      private bool _manageLifetime;

      public bool ManageObjectLifetime
      {
        get { return _manageLifetime; }
        set { _manageLifetime = value; }
      }
	
    }

#endregion

#endregion

#region Cancel/Update/New/Remove  

    /// <summary>
    /// Cancels changes to the business object, returning
    /// it to its previous state.
    /// </summary>
    /// <remarks>
    /// This metod does nothing unless ManageLifetime is
    /// set to true and the object supports n-level undo.
    /// </remarks>
    public void Cancel()
    {
      if (this.Data is Csla.Core.ISupportUndo undo && _manageLifetime)
      {
        IsBusy = true;
        undo.CancelEdit();
        undo.BeginEdit();
        IsBusy = false;
      }
    }

    /// <summary>
    /// Accepts changes to the business object, and
    /// commits them by calling the object's Save()
    /// method.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method does nothing unless the object
    /// implements Csla.Core.ISavable.
    /// </para><para>
    /// If the object implements IClonable, it
    /// will be cloned, and the clone will be
    /// saved.
    /// </para><para>
    /// If the object supports n-level undo and
    /// ManageLifetime is true, then this method
    /// will automatically call ApplyEdit() and
    /// BeginEdit() appropriately.
    /// </para>
    /// </remarks>
    public void Save()
    {
      // only do something if the object implements      // ISavable
      if (this.Data is Csla.Core.ISavable savable)
      {
        object result = savable;
        Exception exceptionResult = null;
        try
        {
          IsBusy = true;

          // clone the object if possible
          if (savable is ICloneable clonable)
            savable = (Csla.Core.ISavable)clonable.Clone();

          // apply edits in memory
          if (savable is Csla.Core.ISupportUndo undo && _manageLifetime)
            undo.ApplyEdit();


          // save the clone
          result = savable.Save();

          if (!ReferenceEquals(savable, this.Data) && !Csla.ApplicationContext.AutoCloneOnUpdate)
          {
            // raise Saved event from original object
            if (this.Data is Core.ISavable original)
              original.SaveComplete(result);
          }

          // start editing the resulting object
          undo = result as Csla.Core.ISupportUndo;

          if (savable is Csla.Core.ISupportUndo undo && _manageLifetime)
            undo.BeginEdit();
        }
        catch (Exception ex)
        {
          exceptionResult = ex;
        }
        // clear previous object
        OnQueryFinished(null, exceptionResult, null, null);
        // return result to base class
        OnQueryFinished(result, null, null, null);
        IsBusy = false;
        OnSaved(result, exceptionResult, null);
      }
    }


    /// <summary>
    /// Adds a new item to the object if the object
    /// implements IBindingList and AllowNew is true.
    /// </summary>
    public object AddNew()
    {
      // only do something if the object implements      // IBindingList
      if (this.Data is IBindingList list && list.AllowNew)
        return list.AddNew();
      else
        return null;

    }

    /// <summary>
    /// Removes an item from the list if the object
    /// implements IBindingList and AllowRemove is true.
    /// </summary>
    /// <param name="sender">Object invoking this method.</param>
    /// <param name="e">
    /// ExecuteEventArgs, where MethodParameter contains 
    /// the item to be removed from the list.
    /// </param>
    public void RemoveItem(object sender, ExecuteEventArgs e)
    {
      var item = e.MethodParameter;
      // only do something if the object implements
      // IBindingList
      IBindingList list;

      if (item is Csla.Core.BusinessBase bb)
        list = bb.Parent as IBindingList;
      else
        list = this.Data as IBindingList;
      if (list != null && list.AllowRemove)
        list.Remove(item);
    }

#endregion

  }
}
#endif
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla.Xaml.Shared\CslaDataProvider.cs(505,49): error CS0128: A local variable or function named 'undo' is already defined in this scope
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\Csla\Core\BusinessBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading.Tasks;
using Csla.Properties;
using System.Collections.Specialized;
using System.ComponentModel.DataAnnotations;
using System.Collections.ObjectModel;
using Csla.Core.LoadManager;
using Csla.Reflection;
using Csla.Server;
using Csla.Security;
using Csla.Serialization.Mobile;
using Csla.Rules;
using System.Security;
using Csla.Core.FieldManager;
using System.Reflection;

namespace Csla.Core
{

  /// <summary>
  /// This is the non-generic base class from which most
  /// business objects will be derived.
  /// </summary>
#if TESTING
  [System.Diagnostics.DebuggerStepThrough]
#endif
  [Serializable]
  public abstract class BusinessBase : UndoableBase,
    IEditableBusinessObject,
    IEditableObject,
    ICloneable,
    IAuthorizeReadWrite,
    IParent,
    IDataPortalTarget,
    IManageProperties,
    Rules.IHostRules,
    ICheckRules,
    INotifyBusy,
    INotifyChildChanged,
    ISerializationNotification
, IDataErrorInfo
  {

    /// <summary>
    /// Creates an instance of the object.
    /// </summary>
    protected BusinessBase()
    {
      InitializeIdentity();
      Initialize();
      InitializeBusinessRules();
    }

    #region Initialize

    /// <summary>
    /// Override this method to set up event handlers so user
    /// code in a partial class can respond to events raised by
    /// generated code.
    /// </summary>
    protected virtual void Initialize()
    { /* allows subclass to initialize events before any other activity occurs */ }

    #endregion

    #region Identity

    private int _identity = -1;

    int IBusinessObject.Identity
    {
      get { return _identity; }
    }

    private void InitializeIdentity()
    {
      _identity = ((IParent)this).GetNextIdentity(_identity);
    }

    [NonSerialized]
    [NotUndoable]
    private IdentityManager _identityManager;

    int IParent.GetNextIdentity(int current)
    {
      if (this.Parent != null)
      {
        return this.Parent.GetNextIdentity(current);
      }
      else
      {
        if (_identityManager == null)
          _identityManager = new IdentityManager();
        return _identityManager.GetNextIdentity(current);
      }
    }
    
    #endregion

    #region Parent/Child link

    [NotUndoable]
    [NonSerialized]
    private IParent _parent;

    /// <summary>
    /// Provide access to the parent reference for use
    /// in child object code.
    /// </summary>
    /// <remarks>
    /// This value will be Nothing for root objects.
    /// </remarks>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public Core.IParent Parent
    {
      get { return _parent; }
    }

    /// <summary>
    /// Used by BusinessListBase as a child object is 
    /// created to tell the child object about its
    /// parent.
    /// </summary>
    /// <param name="parent">A reference to the parent collection object.</param>
    protected virtual void SetParent(Core.IParent parent)
    {
      _parent = parent;
      _identityManager = null;
      InitializeIdentity();
    }

    #endregion

    #region IsNew, IsDeleted, IsDirty, IsSavable

    // keep track of whether we are new, deleted or dirty
    private bool _isNew = true;
    private bool _isDeleted;
    private bool _isDirty = true;

    /// <summary>
    /// Returns true if this is a new object, 
    /// false if it is a pre-existing object.
    /// </summary>
    /// <remarks>
    /// An object is considered to be new if its primary identifying (key) value 
    /// doesn't correspond to data in the database. In other words, 
    /// if the data values in this particular
    /// object have not yet been saved to the database the object is considered to
    /// be new. Likewise, if the object's data has been deleted from the database
    /// then the object is considered to be new.
    /// </remarks>
    /// <returns>A value indicating if this object is new.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public bool IsNew
    {
      get { return _isNew; }
    }

    /// <summary>
    /// Returns true if this object is marked for deletion.
    /// </summary>
    /// <remarks>
    /// CSLA .NET supports both immediate and deferred deletion of objects. This
    /// property is part of the support for deferred deletion, where an object
    /// can be marked for deletion, but isn't actually deleted until the object
    /// is saved to the database. This property indicates whether or not the
    /// current object has been marked for deletion. If it is true
    /// , the object will
    /// be deleted when it is saved to the database, otherwise it will be inserted
    /// or updated by the save operation.
    /// </remarks>
    /// <returns>A value indicating if this object is marked for deletion.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public bool IsDeleted
    {
      get { return _isDeleted; }
    }

    /// <summary>
    /// Returns true if this object's 
    /// data, or any of its fields or child objects data, 
    /// has been changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When an object's data is changed, CSLA .NET makes note of that change
    /// and considers the object to be 'dirty' or changed. This value is used to
    /// optimize data updates, since an unchanged object does not need to be
    /// updated into the database. All new objects are considered dirty. All objects
    /// marked for deletion are considered dirty.
    /// </para><para>
    /// Once an object's data has been saved to the database (inserted or updated)
    /// the dirty flag is cleared and the object is considered unchanged. Objects
    /// newly loaded from the database are also considered unchanged.
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if this object's data has been changed.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsDirty
    {
      get { return IsSelfDirty || (_fieldManager != null && FieldManager.IsDirty()); }
    }

    /// <summary>
    /// Returns true if this object's data has been changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When an object's data is changed, CSLA .NET makes note of that change
    /// and considers the object to be 'dirty' or changed. This value is used to
    /// optimize data updates, since an unchanged object does not need to be
    /// updated into the database. All new objects are considered dirty. All objects
    /// marked for deletion are considered dirty.
    /// </para><para>
    /// Once an object's data has been saved to the database (inserted or updated)
    /// the dirty flag is cleared and the object is considered unchanged. Objects
    /// newly loaded from the database are also considered unchanged.
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if this object's data has been changed.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSelfDirty
    {
      get { return _isDirty; }
    }

    /// <summary>
    /// Marks the object as being a new object. This also marks the object
    /// as being dirty and ensures that it is not marked for deletion.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Newly created objects are marked new by default. You should call
    /// this method in the implementation of DataPortal_Update when the
    /// object is deleted (due to being marked for deletion) to indicate
    /// that the object no longer reflects data in the database.
    /// </para><para>
    /// If you override this method, make sure to call the base
    /// implementation after executing your new code.
    /// </para>
    /// </remarks>
    protected virtual void MarkNew()
    {
      _isNew = true;
      _isDeleted = false;
      MetaPropertyHasChanged("IsNew");
      MetaPropertyHasChanged("IsDeleted");
      MarkDirty();
    }

    /// <summary>
    /// Marks the object as being an old (not new) object. This also
    /// marks the object as being unchanged (not dirty).
    /// </summary>
    /// <remarks>
    /// <para>
    /// You should call this method in the implementation of
    /// DataPortal_Fetch to indicate that an existing object has been
    /// successfully retrieved from the database.
    /// </para><para>
    /// You should call this method in the implementation of 
    /// DataPortal_Update to indicate that a new object has been successfully
    /// inserted into the database.
    /// </para><para>
    /// If you override this method, make sure to call the base
    /// implementation after executing your new code.
    /// </para>
    /// </remarks>
    protected virtual void MarkOld()
    {
      _isNew = false;
      MetaPropertyHasChanged("IsNew");
      MarkClean();
    }

    /// <summary>
    /// Marks an object for deletion. This also marks the object
    /// as being dirty.
    /// </summary>
    /// <remarks>
    /// You should call this method in your business logic in the
    /// case that you want to have the object deleted when it is
    /// saved to the database.
    /// </remarks>
    protected void MarkDeleted()
    {
      _isDeleted = true;
      MetaPropertyHasChanged("IsDeleted");
      MarkDirty();
    }

    /// <summary>
    /// Marks an object as being dirty, or changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// You should call this method in your business logic any time
    /// the object's internal data changes. Any time any instance
    /// variable changes within the object, this method should be called
    /// to tell CSLA .NET that the object's data has been changed.
    /// </para><para>
    /// Marking an object as dirty does two things. First it ensures
    /// that CSLA .NET will properly save the object as appropriate. Second,
    /// it causes CSLA .NET to tell Windows Forms data binding that the
    /// object's data has changed so any bound controls will update to
    /// reflect the new values.
    /// </para>
    /// </remarks>
    protected void MarkDirty()
    {
      MarkDirty(false);
    }

    /// <summary>
    /// Marks an object as being dirty, or changed.
    /// </summary>
    /// <param name="suppressEvent">
    /// true to supress the PropertyChanged event that is otherwise
    /// raised to indicate that the object's state has changed.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkDirty(bool suppressEvent)
    {
      bool old = _isDirty;
      _isDirty = true;
      if (!suppressEvent)
        OnUnknownPropertyChanged();
      if (_isDirty != old)
      {
        MetaPropertyHasChanged("IsSelfDirty");
        MetaPropertyHasChanged("IsDirty");
        MetaPropertyHasChanged("IsSavable");
      }
    }

    /// <summary>
    /// Performs processing required when a property
    /// has changed.
    /// </summary>
    /// <param name="property">Property that
    /// has changed.</param>
    /// <remarks>
    /// This method calls CheckRules(propertyName), MarkDirty and
    /// OnPropertyChanged(propertyName). MarkDirty is called such
    /// that no event is raised for IsDirty, so only the specific
    /// property changed event for the current property is raised.
    /// </remarks>
    protected virtual void PropertyHasChanged(Csla.Core.IPropertyInfo property)
    {
      MarkDirty(true);
      CheckPropertyRules(property);
    }

    private void PropertyHasChanged(string propertyName)
    {
      PropertyHasChanged(FieldManager.GetRegisteredProperty(propertyName));
    }

    /// <summary>
    /// Raises OnPropertyChanged for meta properties (IsXYZ) when PropertyChangedMode is not Windows
    /// </summary>
    /// <param name="name">meta property name that has cchanged.</param>
    protected virtual void MetaPropertyHasChanged(string name)
    {
      if (ApplicationContext.PropertyChangedMode != ApplicationContext.PropertyChangedModes.Windows)
        OnMetaPropertyChanged(name);
    }

    /// <summary>
    /// Check rules for the property and notifies UI of properties that may have changed.
    /// </summary>
    /// <param name="property">The property.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void CheckPropertyRules(IPropertyInfo property)
    {
      var propertyNames = BusinessRules.CheckRules(property);
      if (ApplicationContext.PropertyChangedMode == ApplicationContext.PropertyChangedModes.Windows)
        OnPropertyChanged(property);
      else
        foreach (var name in propertyNames)
          OnPropertyChanged(name);
    }

    /// <summary>
    /// Check object rules and notifies UI of properties that may have changed. 
    /// </summary>
    protected virtual void CheckObjectRules()
    {
      var propertyNames = BusinessRules.CheckObjectRules();
      if (ApplicationContext.PropertyChangedMode == ApplicationContext.PropertyChangedModes.Windows)
      {
        OnUnknownPropertyChanged();
      }
      else
        foreach (var name in propertyNames)
          OnPropertyChanged(name);
    }



    /// <summary>
    /// Forces the object's IsDirty flag to false.
    /// </summary>
    /// <remarks>
    /// This method is normally called automatically and is
    /// not intended to be called manually.
    /// </remarks>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkClean()
    {
      _isDirty = false;
      if (_fieldManager != null)
        FieldManager.MarkClean();
      OnUnknownPropertyChanged();
      MetaPropertyHasChanged("IsSelfDirty");
      MetaPropertyHasChanged("IsDirty");
      MetaPropertyHasChanged("IsSavable");
    }

    /// <summary>
    /// Returns true if this object is both dirty and valid.
    /// </summary>
    /// <remarks>
    /// An object is considered dirty (changed) if 
    /// <see cref="P:Csla.BusinessBase.IsDirty" /> returns true. It is
    /// considered valid if IsValid
    /// returns true. The IsSavable property is
    /// a combination of these two properties. 
    /// </remarks>
    /// <returns>A value indicating if this object is both dirty and valid.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSavable
    {
      get
      {
        bool auth;
        if (IsDeleted)
          auth = Csla.Rules.BusinessRules.HasPermission(Rules.AuthorizationActions.DeleteObject, this);
        else if (IsNew)
          auth = Csla.Rules.BusinessRules.HasPermission(Rules.AuthorizationActions.CreateObject, this);
        else
          auth = Csla.Rules.BusinessRules.HasPermission(Rules.AuthorizationActions.EditObject, this);
        return (auth && IsDirty && IsValid && !IsBusy);
      }
    }

    #endregion

    #region Authorization

    [NotUndoable]
    [NonSerialized]
    private ConcurrentDictionary<string, bool> _readResultCache;
    [NotUndoable]
    [NonSerialized]
    private ConcurrentDictionary<string, bool> _writeResultCache;
    [NotUndoable]
    [NonSerialized]
    private ConcurrentDictionary<string, bool> _executeResultCache;
    [NotUndoable]
    [NonSerialized]
    private System.Security.Principal.IPrincipal _lastPrincipal;

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// calling property.
    /// </summary>
    /// <param name="property">Property to check.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanReadProperty(Csla.Core.IPropertyInfo property)
    {
      var result = true;

      VerifyAuthorizationCache();

      if (!_readResultCache.TryGetValue(property.Name, out result))
      {
        result = BusinessRules.HasPermission(AuthorizationActions.ReadProperty, property);
        if (BusinessRules.CachePermissionResult(AuthorizationActions.ReadProperty, property))
        {
          // store value in cache
          _readResultCache.AddOrUpdate(property.Name, result, (a,b) => { return result; });
        }
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// calling property.
    /// </summary>
    /// <returns>true if read is allowed.</returns>
    /// <param name="property">Property to read.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanReadProperty(Csla.Core.IPropertyInfo property, bool throwOnFalse)
    {
      bool result = CanReadProperty(property);
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex = new Csla.Security.SecurityException(
          String.Format("{0} ({1})",
          Resources.PropertyGetNotAllowed, property.Name));
        throw ex;
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to read.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanReadProperty(string propertyName)
    {
      return CanReadProperty(propertyName, false);
    }

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to read.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    private bool CanReadProperty(string propertyName, bool throwOnFalse)
    {
      var propertyInfo = FieldManager.GetRegisteredProperties().FirstOrDefault(p => p.Name == propertyName);
      if (propertyInfo == null)
      {
        Trace.TraceError("CanReadProperty: {0} is not a registered property of {1}.{2}", propertyName, this.GetType().Namespace, this.GetType().Name);
        return true;
      }
      return CanReadProperty(propertyInfo, throwOnFalse);
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// specified property.
    /// </summary>
    /// <param name="property">Property to write.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanWriteProperty(Csla.Core.IPropertyInfo property)
    {
      bool result = true;

      VerifyAuthorizationCache();

      if (!_writeResultCache.TryGetValue(property.Name, out result))
      {
        result = BusinessRules.HasPermission(AuthorizationActions.WriteProperty, property);
        if (BusinessRules.CachePermissionResult(AuthorizationActions.WriteProperty, property))
        {
          // store value in cache
          _writeResultCache.AddOrUpdate(property.Name, result, (a, b) => { return result; });
        }
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// calling property.
    /// </summary>
    /// <returns>true if write is allowed.</returns>
    /// <param name="property">Property to write.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanWriteProperty(Csla.Core.IPropertyInfo property, bool throwOnFalse)
    {
      bool result = CanWriteProperty(property);
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex = new Csla.Security.SecurityException(
          String.Format("{0} ({1})", Resources.PropertySetNotAllowed, property.Name));
        throw ex;
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to write.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanWriteProperty(string propertyName)
    {
      return CanWriteProperty(propertyName, false);
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to write.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    private bool CanWriteProperty(string propertyName, bool throwOnFalse)
    {
      var propertyInfo = FieldManager.GetRegisteredProperties().FirstOrDefault(p => p.Name == propertyName);
      if (propertyInfo == null)
      {
        Trace.TraceError("CanReadProperty: {0} is not a registered property of {1}.{2}", propertyName, this.GetType().Namespace, this.GetType().Name);
        return true;
      }
      return CanWriteProperty(propertyInfo, throwOnFalse);
    }

    private void VerifyAuthorizationCache()
    {
      if (_readResultCache == null)
        _readResultCache = new ConcurrentDictionary<string, bool>();
      if (_writeResultCache == null)
        _writeResultCache = new ConcurrentDictionary<string, bool>();
      if (_executeResultCache == null)
        _executeResultCache = new ConcurrentDictionary<string, bool>();
      if (!ReferenceEquals(Csla.ApplicationContext.User, _lastPrincipal))
      {
        // the principal has changed - reset the cache
        _readResultCache.Clear();
        _writeResultCache.Clear();
        _executeResultCache.Clear();
        _lastPrincipal = Csla.ApplicationContext.User;
      }
    }

    /// <summary>
    /// Returns true if the user is allowed to execute
    /// the specified method.
    /// </summary>
    /// <param name="method">Method to execute.</param>
    /// <returns>true if execute is allowed.</returns>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanExecuteMethod(Csla.Core.IMemberInfo method)
    {
      bool result = true;

      VerifyAuthorizationCache();

      if (!_executeResultCache.TryGetValue(method.Name, out result))
      {
        result = BusinessRules.HasPermission(AuthorizationActions.ExecuteMethod, method);
        if (BusinessRules.CachePermissionResult(AuthorizationActions.ExecuteMethod, method))
        {
          // store value in cache
          _executeResultCache.AddOrUpdate(method.Name, result, (a, b) => { return result; });
        }
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to execute
    /// the specified method.
    /// </summary>
    /// <returns>true if execute is allowed.</returns>
    /// <param name="method">Method to execute.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanExecuteMethod(Csla.Core.IMemberInfo method, bool throwOnFalse)
    {

      bool result = CanExecuteMethod(method);
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex =
          new Csla.Security.SecurityException(string.Format("{0} ({1})", Properties.Resources.MethodExecuteNotAllowed, method.Name));
        throw ex;
      }
      return result;

    }


    /// <summary>
    /// Returns true if the user is allowed to execute
    /// the specified method.
    /// </summary>
    /// <param name="methodName">Name of the method to execute.</param>
    /// <returns>true if execute is allowed.</returns>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanExecuteMethod(string methodName)
    {
      return CanExecuteMethod(methodName, false);
    }

    private bool CanExecuteMethod(string methodName, bool throwOnFalse)
    {

      bool result = CanExecuteMethod(new MethodInfo(methodName));
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex = new Csla.Security.SecurityException(string.Format("{0} ({1})", Properties.Resources.MethodExecuteNotAllowed, methodName));
        throw ex;
      }
      return result;
    }

#endregion

#region System.ComponentModel.IEditableObject

    private bool _neverCommitted = true;
    [NotUndoable]
    private bool _disableIEditableObject;

    /// <summary>
    /// Gets or sets a value indicating whether the
    /// IEditableObject interface methods should
    /// be disabled for this object.
    /// </summary>
    /// <value>Defaults to False, indicating that
    /// the IEditableObject methods will behave
    /// normally.</value>
    /// <remarks>
    /// If you disable the IEditableObject methods
    /// then Windows Forms data binding will no longer
    /// automatically call BeginEdit, CancelEdit or
    /// ApplyEdit on your object, and you will have
    /// to call these methods manually to get proper
    /// n-level undo behavior.
    /// </remarks>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected bool DisableIEditableObject
    {
      get
      {
        return _disableIEditableObject;
      }
      set
      {
        _disableIEditableObject = value;
      }
    }

    /// <summary>
    /// Allow data binding to start a nested edit on the object.
    /// </summary>
    /// <remarks>
    /// Data binding may call this method many times. Only the first
    /// call should be honored, so we have extra code to detect this
    /// and do nothing for subsquent calls.
    /// </remarks>
    void System.ComponentModel.IEditableObject.BeginEdit()
    {
      if (!_disableIEditableObject && !BindingEdit)
      {
        BindingEdit = true;
        BeginEdit();
      }
    }

    /// <summary>
    /// Allow data binding to cancel the current edit.
    /// </summary>
    /// <remarks>
    /// Data binding may call this method many times. Only the first
    /// call to either IEditableObject.CancelEdit or 
    /// IEditableObject.EndEdit
    /// should be honored. We include extra code to detect this and do
    /// nothing for subsequent calls.
    /// </remarks>
    void System.ComponentModel.IEditableObject.CancelEdit()
    {
      if (!_disableIEditableObject && BindingEdit)
      {
        CancelEdit();
        BindingEdit = false;
        if (IsNew && _neverCommitted && EditLevel <= EditLevelAdded)
        {
          // we're new and no EndEdit or ApplyEdit has ever been
          // called on us, and now we've been cancelled back to
          // where we were added so we should have ourselves
          // removed from the parent collection
          if (Parent != null)
            Parent.RemoveChild(this);
        }
      }
    }

    /// <summary>
    /// Allow data binding to apply the current edit.
    /// </summary>
    /// <remarks>
    /// Data binding may call this method many times. Only the first
    /// call to either IEditableObject.EndEdit or 
    /// IEditableObject.CancelEdit
    /// should be honored. We include extra code to detect this and do
    /// nothing for subsequent calls.
    /// </remarks>
    void System.ComponentModel.IEditableObject.EndEdit()
    {
      if (!_disableIEditableObject && BindingEdit)
      {
        ApplyEdit();
        BindingEdit = false;
      }
    }

#endregion

#region Begin/Cancel/ApplyEdit

    /// <summary>
    /// Starts a nested edit on the object.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When this method is called the object takes a snapshot of
    /// its current state (the values of its variables). This snapshot
    /// can be restored by calling CancelEdit
    /// or committed by calling ApplyEdit.
    /// </para><para>
    /// This is a nested operation. Each call to BeginEdit adds a new
    /// snapshot of the object's state to a stack. You should ensure that 
    /// for each call to BeginEdit there is a corresponding call to either 
    /// CancelEdit or ApplyEdit to remove that snapshot from the stack.
    /// </para><para>
    /// See Chapters 2 and 3 for details on n-level undo and state stacking.
    /// </para>
    /// </remarks>
    public void BeginEdit()
    {
      CopyState(this.EditLevel + 1);
    }

    /// <summary>
    /// Cancels the current edit process, restoring the object's state to
    /// its previous values.
    /// </summary>
    /// <remarks>
    /// Calling this method causes the most recently taken snapshot of the 
    /// object's state to be restored. This resets the object's values
    /// to the point of the last BeginEdit call.
    /// </remarks>
    public void CancelEdit()
    {
      UndoChanges(this.EditLevel - 1);
    }

    /// <summary>
    /// Called when an undo operation has completed.
    /// </summary>
    /// <remarks> 
    /// This method resets the object as a result of
    /// deserialization and raises PropertyChanged events
    /// to notify data binding that the object has changed.
    /// </remarks>
    protected override void UndoChangesComplete()
    {
      BusinessRules.SetTarget(this);
      InitializeBusinessRules();
      OnUnknownPropertyChanged();
      base.UndoChangesComplete();
    }

    /// <summary>
    /// Commits the current edit process.
    /// </summary>
    /// <remarks>
    /// Calling this method causes the most recently taken snapshot of the 
    /// object's state to be discarded, thus committing any changes made
    /// to the object's state since the last BeginEdit call.
    /// </remarks>
    public void ApplyEdit()
    {
      _neverCommitted = false;
      AcceptChanges(this.EditLevel - 1);
      //Next line moved to IEditableObject.ApplyEdit 
      //BindingEdit = false;
    }

    /// <summary>
    /// Notifies the parent object (if any) that this
    /// child object's edits have been accepted.
    /// </summary>
    protected override void AcceptChangesComplete()
    {
      BindingEdit = false;
      base.AcceptChangesComplete();

      // !!!! Will trigger Save here when using DynamicListBase template
      if (Parent != null)
        Parent.ApplyEditChild(this);
    }

#endregion

#region IsChild

    [NotUndoable]
    private bool _isChild;

    /// <summary>
    /// Returns true if this is a child (non-root) object.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public bool IsChild
    {
      get { return _isChild; }
    }

    /// <summary>
    /// Marks the object as being a child object.
    /// </summary>
    protected void MarkAsChild()
    {
      _identity = -1;
      _isChild = true;
    }

#endregion

#region Delete

    /// <summary>
    /// Marks the object for deletion. The object will be deleted as part of the
    /// next save operation.
    /// </summary>
    /// <remarks>
    /// <para>
    /// CSLA .NET supports both immediate and deferred deletion of objects. This
    /// method is part of the support for deferred deletion, where an object
    /// can be marked for deletion, but isn't actually deleted until the object
    /// is saved to the database. This method is called by the UI developer to
    /// mark the object for deletion.
    /// </para><para>
    /// To 'undelete' an object, use n-level undo as discussed in Chapters 2 and 3.
    /// </para>
    /// </remarks>
    public virtual void Delete()
    {
      if (this.IsChild)
        throw new NotSupportedException(Resources.ChildDeleteException);

      MarkDeleted();
    }

    /// <summary>
    /// Called by a parent object to mark the child
    /// for deferred deletion.
    /// </summary>
    internal void DeleteChild()
    {
      if (!this.IsChild)
        throw new NotSupportedException(Resources.NoDeleteRootException);

      BindingEdit = false;
      MarkDeleted();
    }

#endregion

#region Edit Level Tracking (child only)

    // we need to keep track of the edit
    // level when we weere added so if the user
    // cancels below that level we can be destroyed
    [NotUndoable]
    private int _editLevelAdded;

    /// <summary>
    /// Gets or sets the current edit level of the
    /// object.
    /// </summary>
    /// <remarks>
    /// Allow the collection object to use the
    /// edit level as needed.
    /// </remarks>
    internal int EditLevelAdded
    {
      get { return _editLevelAdded; }
      set { _editLevelAdded = value; }
    }

    int IUndoableObject.EditLevel
    {
      get
      {
        return this.EditLevel;
      }
    }

#endregion

#region ICloneable

    object ICloneable.Clone()
    {
      return GetClone();
    }

    /// <summary>
    /// Creates a clone of the object.
    /// </summary>
    /// <returns>
    /// A new object containing the exact data of the original object.
    /// </returns>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual object GetClone()
    {
      return ObjectCloner.Clone(this);
    }

#endregion

#region BusinessRules, IsValid

    [NonSerialized]
    [NotUndoable]
    private EventHandler _validationCompleteHandlers;

    /// <summary>
    /// Event raised when validation is complete.
    /// </summary>
    public event EventHandler ValidationComplete
    {
      add
      {
        _validationCompleteHandlers = (EventHandler)
          System.Delegate.Combine(_validationCompleteHandlers, value);
      }
      remove
      {
        _validationCompleteHandlers = (EventHandler)
          System.Delegate.Remove(_validationCompleteHandlers, value);
      }
    }

    /// <summary>
    /// Raises the ValidationComplete event
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void OnValidationComplete()
    {
      if (_validationCompleteHandlers != null)
        _validationCompleteHandlers(this, EventArgs.Empty);
    }

    private void InitializeBusinessRules()
    {
      var rules = BusinessRuleManager.GetRulesForType(this.GetType());
      if (!rules.Initialized)
        lock (rules)
          if (!rules.Initialized)
          {
            try
            {
              AddBusinessRules();
              rules.Initialized = true;
            }
            catch (Exception)
            {
              BusinessRuleManager.CleanupRulesForType(this.GetType());
              throw;  // and rethrow exception
            }
          }
    }

    private Csla.Rules.BusinessRules _businessRules;

    /// <summary>
    /// Provides access to the broken rules functionality.
    /// </summary>
    /// <remarks>
    /// This property is used within your business logic so you can
    /// easily call the AddRule() method to associate business
    /// rules with your object's properties.
    /// </remarks>
    protected BusinessRules BusinessRules
    {
      get
      {
        if (_businessRules == null)
          _businessRules = new BusinessRules(this);
        else if (_businessRules.Target == null)
          _businessRules.SetTarget(this);
        return _businessRules;
      }
    }

    /// <summary>
    /// Gets the registered rules. Only for unit testing and not visible to code. 
    /// </summary>
    /// <returns></returns>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected BusinessRuleManager GetRegisteredRules()
    {
      return BusinessRules.TypeRules;
    }

    void IHostRules.RuleStart(IPropertyInfo property)
    {
      OnBusyChanged(new BusyChangedEventArgs(property.Name, true));
    }

    void IHostRules.RuleComplete(IPropertyInfo property)
    {
      OnPropertyChanged(property);
      OnBusyChanged(new BusyChangedEventArgs(property.Name, false));
      MetaPropertyHasChanged("IsSelfValid");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    void IHostRules.RuleComplete(string property)
    {
      OnPropertyChanged(property);
      MetaPropertyHasChanged("IsSelfValid");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    void Rules.IHostRules.AllRulesComplete()
    {
      OnValidationComplete();
      MetaPropertyHasChanged("IsSelfValid");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    /// <summary>
    /// Override this method in your business class to
    /// be notified when you need to set up shared 
    /// business rules.
    /// </summary>
    /// <remarks>
    /// This method is automatically called by CSLA .NET
    /// when your object should associate per-type 
    /// validation rules with its properties.
    /// </remarks>
    protected virtual void AddBusinessRules()
    {
      BusinessRules.AddDataAnnotations();
    }

    /// <summary>
    /// Returns true if the object 
    /// and its child objects are currently valid, 
    /// false if the
    /// object or any of its child objects have broken 
    /// rules or are otherwise invalid.
    /// </summary>
    /// <remarks>
    /// <para>
    /// By default this property relies on the underling BusinessRules
    /// object to track whether any business rules are currently broken for this object.
    /// </para><para>
    /// You can override this property to provide more sophisticated
    /// implementations of the behavior. For instance, you should always override
    /// this method if your object has child objects, since the validity of this object
    /// is affected by the validity of all child objects.
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if the object is currently valid.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsValid
    {
      get { return IsSelfValid && (_fieldManager == null || FieldManager.IsValid()); }
    }

    /// <summary>
    /// Returns true if the object is currently 
    /// valid, false if the
    /// object has broken rules or is otherwise invalid.
    /// </summary>
    /// <remarks>
    /// <para>
    /// By default this property relies on the underling BusinessRules
    /// object to track whether any business rules are currently broken for this object.
    /// </para><para>
    /// You can override this property to provide more sophisticated
    /// implementations of the behavior. 
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if the object is currently valid.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSelfValid
    {
      get { return BusinessRules.IsValid; }
    }

    /// <summary>
    /// Provides access to the readonly collection of broken business rules
    /// for this object.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    [System.ComponentModel.DataAnnotations.Schema.NotMapped]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual Rules.BrokenRulesCollection BrokenRulesCollection
    {
      get { return BusinessRules.GetBrokenRules(); }
    }

#endregion

#region Data Access

    /// <summary>
    /// Override this method to load a new business object with default
    /// values from the database.
    /// </summary>
    /// <remarks>
    /// Normally you will overload this method to accept a strongly-typed
    /// criteria parameter, rather than overriding the method with a
    /// loosely-typed criteria parameter.
    /// </remarks>
    [RunLocal]
    protected virtual void DataPortal_Create()
    {
      BusinessRules.CheckRules();
    }

    /// <summary>
    /// Override this method to allow insertion of a business
    /// object.
    /// </summary>
    protected virtual void DataPortal_Insert()
    { }

    /// <summary>
    /// Override this method to allow update of a business
    /// object.
    /// </summary>
    protected virtual void DataPortal_Update()
    { }

    /// <summary>
    /// Override this method to allow deferred deletion of a business object.
    /// </summary>
    protected virtual void DataPortal_DeleteSelf()
    { }

    /// <summary>
    /// Called by the server-side DataPortal prior to calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void DataPortal_OnDataPortalInvoke(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal after calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void DataPortal_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal if an exception
    /// occurs during data access.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    /// <param name="ex">The Exception thrown during data access.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void DataPortal_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    { }

    /// <summary>
    /// Override this method to load a new business object with default
    /// values from the database.
    /// </summary>
    /// <remarks>
    /// Normally you will overload this method to accept a strongly-typed
    /// criteria parameter, rather than overriding the method with a
    /// loosely-typed criteria parameter.
    /// </remarks>
    protected virtual void Child_Create()
    {
      BusinessRules.CheckRules();
    }

    /// <summary>
    /// Called by the server-side DataPortal prior to calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void Child_OnDataPortalInvoke(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal after calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void Child_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal if an exception
    /// occurs during data access.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    /// <param name="ex">The Exception thrown during data access.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void Child_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    { }

#endregion

#region IDataErrorInfo

    string IDataErrorInfo.Error
    {
      get
      {
        if (!IsSelfValid)
          return BusinessRules.GetBrokenRules().ToString(
            Csla.Rules.RuleSeverity.Error);
        else
          return String.Empty;
      }
    }

    string IDataErrorInfo.this[string columnName]
    {
      get
      {
        string result = string.Empty;
        if (!IsSelfValid)
        {
          Rules.BrokenRule rule =
            BusinessRules.GetBrokenRules().GetFirstBrokenRule(columnName);
          if (rule != null)
            result = rule.Description;
        }
        return result;
      }
    }

#endregion

#region Serialization Notification

    void ISerializationNotification.Deserialized()
    {
      OnDeserializedHandler(new System.Runtime.Serialization.StreamingContext());
    }

    [System.Runtime.Serialization.OnDeserialized]
    private void OnDeserializedHandler(System.Runtime.Serialization.StreamingContext context)
    {
      BusinessRules.SetTarget(this);
      if (_fieldManager != null)
        FieldManager.SetPropertyList(this.GetType());
      InitializeBusinessRules();
      FieldDataDeserialized();

      OnDeserialized(context);
    }

    /// <summary>
    /// This method is called on a newly deserialized object
    /// after deserialization is complete.
    /// </summary>
    /// <param name="context">Serialization context object.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void OnDeserialized(System.Runtime.Serialization.StreamingContext context)
    { }

#endregion

#region Bubbling event Hooks

    /// <summary>
    /// For internal use.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void AddEventHooks(IBusinessObject child)
    {
      OnAddEventHooks(child);
    }

    /// <summary>
    /// Hook child object events.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void OnAddEventHooks(IBusinessObject child)
    {
      INotifyBusy busy = child as INotifyBusy;
      if (busy != null)
        busy.BusyChanged += Child_BusyChanged;

      INotifyUnhandledAsyncException unhandled = child as INotifyUnhandledAsyncException;
      if (unhandled != null)
        unhandled.UnhandledAsyncException += Child_UnhandledAsyncException;

      INotifyPropertyChanged pc = child as INotifyPropertyChanged;
      if (pc != null)
        pc.PropertyChanged += Child_PropertyChanged;

      IBindingList bl = child as IBindingList;
      if (bl != null)
        bl.ListChanged += Child_ListChanged;

      INotifyCollectionChanged ncc = child as INotifyCollectionChanged;
      if (ncc != null)
        ncc.CollectionChanged += Child_CollectionChanged;

      INotifyChildChanged cc = child as INotifyChildChanged;
      if (cc != null)
        cc.ChildChanged += Child_Changed;
    }

    /// <summary>
    /// For internal use only.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void RemoveEventHooks(IBusinessObject child)
    {
      OnRemoveEventHooks(child);
    }

    /// <summary>
    /// Unhook child object events.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void OnRemoveEventHooks(IBusinessObject child)
    {
      INotifyBusy busy = child as INotifyBusy;
      if (busy != null)
        busy.BusyChanged -= Child_BusyChanged;

      INotifyUnhandledAsyncException unhandled = child as INotifyUnhandledAsyncException;
      if (unhandled != null)
        unhandled.UnhandledAsyncException -= Child_UnhandledAsyncException;

      INotifyPropertyChanged pc = child as INotifyPropertyChanged;
      if (pc != null)
        pc.PropertyChanged -= Child_PropertyChanged;

      IBindingList bl = child as IBindingList;
      if (bl != null)
        bl.ListChanged -= Child_ListChanged;

      INotifyCollectionChanged ncc = child as INotifyCollectionChanged;
      if (ncc != null)
        ncc.CollectionChanged -= Child_CollectionChanged;

      INotifyChildChanged cc = child as INotifyChildChanged;
      if (cc != null)
        cc.ChildChanged -= Child_Changed;
    }

#endregion

#region Busy / Unhandled exception bubbling

    private void Child_UnhandledAsyncException(object sender, ErrorEventArgs e)
    {
      OnUnhandledAsyncException(e);
    }

    private void Child_BusyChanged(object sender, BusyChangedEventArgs e)
    {
      OnBusyChanged(e);
    }

#endregion

#region IEditableBusinessObject Members

    int IEditableBusinessObject.EditLevelAdded
    {
      get
      {
        return this.EditLevelAdded;
      }
      set
      {
        this.EditLevelAdded = value;
      }
    }

    void IEditableBusinessObject.DeleteChild()
    {
      this.DeleteChild();
    }

    void IEditableBusinessObject.SetParent(IParent parent)
    {
      this.SetParent(parent);
    }

#endregion

#region Register Methods

    /// <summary>
    /// Indicates that the specified method belongs
    /// to the type.
    /// </summary>
    /// <param name="objectType">
    /// Type of object to which the method belongs.
    /// </param>
    /// <param name="info">
    /// IMemberInfo object for the property.
    /// </param>
    /// <returns>
    /// The provided IMemberInfo object.
    /// </returns>
    protected static Csla.Core.IMemberInfo RegisterMethod(Type objectType, IMemberInfo info)
    {
      var reflected = objectType.GetMethod(info.Name);
      if (reflected == null)
        throw new ArgumentException(string.Format(Resources.NoSuchMethod, info.Name), "info");
      return info;
    }

    /// <summary>
    /// Indicates that the specified method belongs
    /// to the type.
    /// </summary>
    /// <param name="objectType">
    /// Type of object to which the method belongs.
    /// </param>
    /// <param name="methodName">
    /// Name of the method.
    /// </param>
    /// <returns>
    /// The provided IMemberInfo object.
    /// </returns>
    protected static MethodInfo RegisterMethod(Type objectType, string methodName)
    {
      var info = new MethodInfo(methodName);
      RegisterMethod(objectType, info);
      return info;
    }

#endregion

#region  Register Properties

    /// <summary>
    /// Indicates that the specified property belongs
    /// to the type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of property.
    /// </typeparam>
    /// <param name="objectType">
    /// Type of object to which the property belongs.
    /// </param>
    /// <param name="info">
    /// PropertyInfo object for the property.
    /// </param>
    /// <returns>
    /// The provided IPropertyInfo object.
    /// </returns>
    protected static PropertyInfo<P> RegisterProperty<P>(Type objectType, PropertyInfo<P> info)
    {
      return Core.FieldManager.PropertyInfoManager.RegisterProperty<P>(objectType, info);
    }

#endregion

#region  Get Properties

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="defaultValue">
    /// Value to be returned if the user is not
    /// authorized to read the property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(string propertyName, P field, P defaultValue)
    {
      return GetProperty<P>(propertyName, field, defaultValue, Security.NoAccessBehavior.SuppressException);
    }

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="defaultValue">
    /// Value to be returned if the user is not
    /// authorized to read the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    protected P GetProperty<P>(string propertyName, P field, P defaultValue, Security.NoAccessBehavior noAccess)
    {
#region Check to see if the property is marked with RelationshipTypes.PrivateField

      var propertyInfo = FieldManager.GetRegisteredProperty(propertyName);

      if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) != RelationshipTypes.PrivateField)
        throw new InvalidOperationException(Resources.PrivateFieldException);

#endregion

      if (_bypassPropertyChecks || CanReadProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        return field;

      return defaultValue;
    }

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo, P field)
    {
      return GetProperty<P>(propertyInfo.Name, field, propertyInfo.DefaultValue, Security.NoAccessBehavior.SuppressException);
    }

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="defaultValue">
    /// Value to be returned if the user is not
    /// authorized to read the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo, P field, P defaultValue, Security.NoAccessBehavior noAccess)
    {
      return GetProperty<P>(propertyInfo.Name, field, defaultValue, noAccess);
    }

    /// <summary>
    /// Gets a property's value as 
    /// a specified type, first checking authorization.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo, F field)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo.Name, field, propertyInfo.DefaultValue, Security.NoAccessBehavior.SuppressException));
    }

    /// <summary>
    /// Gets a property's value as a specified type, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo, F field, Security.NoAccessBehavior noAccess)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo.Name, field, propertyInfo.DefaultValue, noAccess));
    }

    /// <summary>
    /// Gets a property's managed field value, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo)
    {
      return GetProperty<P>(propertyInfo, Security.NoAccessBehavior.SuppressException);
    }

    /// <summary>
    /// Gets a property's value from the list of 
    /// managed field values, first checking authorization,
    /// and converting the value to an appropriate type.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo, Security.NoAccessBehavior.SuppressException));
    }

    /// <summary>
    /// Gets a property's value from the list of 
    /// managed field values, first checking authorization,
    /// and converting the value to an appropriate type.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo, Security.NoAccessBehavior noAccess)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo, noAccess));
    }

    /// <summary>
    /// Gets a property's value as a specified type, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo, Security.NoAccessBehavior noAccess)
    {
      P result = default(P);
      if (_bypassPropertyChecks || CanReadProperty(propertyInfo, noAccess == Csla.Security.NoAccessBehavior.ThrowException))
        result = ReadProperty<P>(propertyInfo);
      else
        result = propertyInfo.DefaultValue;
      return result;
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected object GetProperty(IPropertyInfo propertyInfo)
    {
      object result = null;
      if (_bypassPropertyChecks || CanReadProperty(propertyInfo, false))
      {
        // call ReadProperty (may be overloaded in actual class)
        result = ReadProperty(propertyInfo);
      }
      else
      {
        result = propertyInfo.DefaultValue;
      }
      return result;
    }

    /// <summary>
    /// Gets a property's managed field value, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(IPropertyInfo propertyInfo)
    {
      return (P)GetProperty(propertyInfo);
    }

    /// <summary>
    /// Lazily initializes a property and returns
    /// the resulting value.
    /// </summary>
    /// <typeparam name="P">Type of the property.</typeparam>
    /// <param name="property">PropertyInfo object containing property metadata.</param>
    /// <param name="valueGenerator">Method returning the new value.</param>
    /// <returns></returns>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P LazyGetProperty<P>(PropertyInfo<P> property, Func<P> valueGenerator)
    {
      if (!(FieldManager.FieldExists(property)))
      {
        var result = valueGenerator();
        LoadProperty(property, result);
      }
      return GetProperty<P>(property);
    }

    [NotUndoable]
    [NonSerialized]
    private List<Csla.Core.IPropertyInfo> _lazyLoadingProperties = new List<Csla.Core.IPropertyInfo>();

    /// <summary>
    /// Lazily initializes a property and returns
    /// the resulting value.
    /// </summary>
    /// <typeparam name="P">Type of the property.</typeparam>
    /// <param name="property">PropertyInfo object containing property metadata.</param>
    /// <param name="factory">Async method returning the new value.</param>
    /// <returns></returns>
    /// <remarks>
    /// <para>
    /// Note that the first value returned is almost certainly
    /// the defaultValue because the value is initialized asynchronously.
    /// The real value is provided later along with a PropertyChanged
    /// event to indicate the value has changed.
    /// </para><para>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </para>
    /// </remarks>
    protected P LazyGetPropertyAsync<P>(PropertyInfo<P> property, Task<P> factory)
    {
      if (!(FieldManager.FieldExists(property)) && !_lazyLoadingProperties.Contains(property))
      {
        _lazyLoadingProperties.Add(property);
        LoadPropertyAsync(property, factory);
      }
      return GetProperty<P>(property);
    }

    object IManageProperties.LazyGetProperty<P>(PropertyInfo<P> propertyInfo, Func<P> valueGenerator)
    {
      return LazyGetProperty(propertyInfo, valueGenerator);
    }

    object IManageProperties.LazyGetPropertyAsync<P>(PropertyInfo<P> propertyInfo, Task<P> factory)
    {
      return LazyGetPropertyAsync(propertyInfo, factory);
    }

#endregion

#region  Read Properties

    /// <summary>
    /// Gets a property's value from the list of 
    /// managed field values, converting the 
    /// value to an appropriate type.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    protected P ReadPropertyConvert<F, P>(PropertyInfo<F> propertyInfo)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, ReadProperty<F>(propertyInfo));
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    protected P ReadProperty<P>(PropertyInfo<P> propertyInfo)
    {
      if (((propertyInfo.RelationshipType & RelationshipTypes.LazyLoad) == RelationshipTypes.LazyLoad) && !FieldManager.FieldExists(propertyInfo))
        throw new InvalidOperationException(Resources.PropertyGetNotAllowed);

      P result = default(P);
      FieldManager.IFieldData data = FieldManager.GetFieldData(propertyInfo);
      if (data != null)
      {
        FieldManager.IFieldData<P> fd = data as FieldManager.IFieldData<P>;
        if (fd != null)
          result = fd.Value;
        else
          result = (P)data.Value;
      }
      else
      {
        result = propertyInfo.DefaultValue;
        FieldManager.LoadFieldData<P>(propertyInfo, result);
      }
      return result;
    }

    /// <summary>
    /// Gets a property's value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    protected virtual object ReadProperty(IPropertyInfo propertyInfo)
    {
      if (((propertyInfo.RelationshipType & RelationshipTypes.LazyLoad) == RelationshipTypes.LazyLoad) && !FieldManager.FieldExists(propertyInfo))
        throw new InvalidOperationException(Resources.PropertyGetNotAllowed);

      if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) == RelationshipTypes.PrivateField)
      {
        using (BypassPropertyChecks)
        {
          return MethodCaller.CallPropertyGetter(this, propertyInfo.Name);
        }
      }

      object result = null;
      var info = FieldManager.GetFieldData(propertyInfo);
      if (info != null)
      {
        result = info.Value;
      }
      else
      {
        result = propertyInfo.DefaultValue;
        FieldManager.LoadFieldData(propertyInfo, result);
      }

      return result;
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="property">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="valueGenerator">Method returning the new value.</param>
    protected P LazyReadProperty<P>(PropertyInfo<P> property, Func<P> valueGenerator)
    {
      if (!(FieldManager.FieldExists(property)))
      {
        var result = valueGenerator();
        LoadProperty(property, result);
      }
      return ReadProperty<P>(property);
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="property">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="factory">Async method returning the new value.</param>
    protected P LazyReadPropertyAsync<P>(PropertyInfo<P> property, Task<P> factory)
    {
      if (!(FieldManager.FieldExists(property)) && !_lazyLoadingProperties.Contains(property))
      {
        _lazyLoadingProperties.Add(property);
        LoadPropertyAsync(property, factory);
      }
      return ReadProperty<P>(property);
    }

    P IManageProperties.LazyReadProperty<P>(PropertyInfo<P> propertyInfo, Func<P> valueGenerator)
    {
      return LazyReadProperty(propertyInfo, valueGenerator);
    }

    P IManageProperties.LazyReadPropertyAsync<P>(PropertyInfo<P> propertyInfo, Task<P> factory)
    {
      return LazyReadPropertyAsync(propertyInfo, factory);
    }

#endregion

#region  Set Properties

    /// <summary>
    /// Sets a property's backing field with the supplied
    /// value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetProperty<P>(PropertyInfo<P> propertyInfo, ref P field, P newValue)
    {
      SetProperty<P>(propertyInfo.Name, ref field, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's backing field with the supplied
    /// value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetProperty<P>(string propertyName, ref P field, P newValue)
    {
      SetProperty<P>(propertyName, ref field, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's backing field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the field being set.
    /// </typeparam>
    /// <typeparam name="V">
    /// Type of the value provided to the field.
    /// </typeparam>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetPropertyConvert<P, V>(PropertyInfo<P> propertyInfo, ref P field, V newValue)
    {
      SetPropertyConvert<P, V>(propertyInfo, ref field, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's backing field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the field being set.
    /// </typeparam>
    /// <typeparam name="V">
    /// Type of the value provided to the field.
    /// </typeparam>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    /// <remarks>
    /// If the field value is of type string, any incoming
    /// null values are converted to string.Empty.
    /// </remarks>
    protected void SetPropertyConvert<P, V>(PropertyInfo<P> propertyInfo, ref P field, V newValue, Security.NoAccessBehavior noAccess)
    {
      SetPropertyConvert<P, V>(propertyInfo.Name, ref field, newValue, noAccess);
    }

    /// <summary>
    /// Sets a property's backing field with the supplied
    /// value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    protected void SetProperty<P>(string propertyName, ref P field, P newValue, Security.NoAccessBehavior noAccess)
    {
      try
      {
#region Check to see if the property is marked with RelationshipTypes.PrivateField

        var propertyInfo = FieldManager.GetRegisteredProperty(propertyName);

        if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) != RelationshipTypes.PrivateField)
          throw new InvalidOperationException(Resources.PrivateFieldException);

#endregion

        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        {
          bool doChange = false;
          if (field == null)
          {
            if (newValue != null)
              doChange = true;
          }
          else
          {
            if (typeof(P) == typeof(string) && newValue == null)
              newValue = Utilities.CoerceValue<P>(typeof(string), field, string.Empty);
            if (!field.Equals(newValue))
              doChange = true;
          }
          if (doChange)
          {
            if (!_bypassPropertyChecks) OnPropertyChanging(propertyName);
            field = newValue;
            if (!_bypassPropertyChecks) PropertyHasChanged(propertyName);
          }
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Resources.PropertyLoadException, propertyName, ex.Message, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's backing field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the field being set.
    /// </typeparam>
    /// <typeparam name="V">
    /// Type of the value provided to the field.
    /// </typeparam>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    /// <remarks>
    /// If the field value is of type string, any incoming
    /// null values are converted to string.Empty.
    /// </remarks>
    protected void SetPropertyConvert<P, V>(string propertyName, ref P field, V newValue, Security.NoAccessBehavior noAccess)
    {
      try
      {
#region Check to see if the property is marked with RelationshipTypes.PrivateField

        var propertyInfo = FieldManager.GetRegisteredProperty(propertyName);

        if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) != RelationshipTypes.PrivateField)
          throw new InvalidOperationException(Resources.PrivateFieldException);

#endregion

        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        {
          bool doChange = false;
          if (field == null)
          {
            if (newValue != null)
              doChange = true;
          }
          else
          {
            if (typeof(V) == typeof(string) && newValue == null)
              newValue = Utilities.CoerceValue<V>(typeof(string), null, string.Empty);
            if (!field.Equals(newValue))
              doChange = true;
          }
          if (doChange)
          {
            if (!_bypassPropertyChecks) OnPropertyChanging(propertyName);
            field = Utilities.CoerceValue<P>(typeof(V), field, newValue);
            if (!_bypassPropertyChecks) PropertyHasChanged(propertyName);
          }
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyName, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">Property type.</typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetProperty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      SetProperty<P>(propertyInfo, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetPropertyConvert<P, F>(PropertyInfo<P> propertyInfo, F newValue)
    {
      SetPropertyConvert<P, F>(propertyInfo, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    protected void SetPropertyConvert<P, F>(PropertyInfo<P> propertyInfo, F newValue, Security.NoAccessBehavior noAccess)
    {
      try
      {
        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        {
          P oldValue = default(P);
          var fieldData = FieldManager.GetFieldData(propertyInfo);
          if (fieldData == null)
          {
            oldValue = propertyInfo.DefaultValue;
            fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
          }
          else
          {
            var fd = fieldData as FieldManager.IFieldData<P>;
            if (fd != null)
              oldValue = fd.Value;
            else
              oldValue = (P)fieldData.Value;
          }
          if (typeof(F) == typeof(string) && newValue == null)
            newValue = Utilities.CoerceValue<F>(typeof(string), null, string.Empty);
          LoadPropertyValue<P>(propertyInfo, oldValue, Utilities.CoerceValue<P>(typeof(F), oldValue, newValue), !_bypassPropertyChecks);
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    protected void SetProperty<P>(PropertyInfo<P> propertyInfo, P newValue, Security.NoAccessBehavior noAccess)
    {
      if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
      {
        try
        {
          P oldValue = default(P);
          var fieldData = FieldManager.GetFieldData(propertyInfo);
          if (fieldData == null)
          {
            oldValue = propertyInfo.DefaultValue;
            fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
          }
          else
          {
            var fd = fieldData as FieldManager.IFieldData<P>;
            if (fd != null)
              oldValue = fd.Value;
            else
              oldValue = (P)fieldData.Value;
          }
          if (typeof(P) == typeof(string) && newValue == null)
            newValue = Utilities.CoerceValue<P>(typeof(string), null, string.Empty);
          LoadPropertyValue<P>(propertyInfo, oldValue, newValue, !_bypassPropertyChecks);
        }
        catch (Exception ex)
        {
          throw new PropertyLoadException(
            string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
        }
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, and then
    /// calls PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the 
    /// property a SecurityException is thrown.
    /// </remarks>
    protected void SetProperty(IPropertyInfo propertyInfo, object newValue)
    {
      try
      {
        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, true))
        {
          if (!_bypassPropertyChecks) OnPropertyChanging(propertyInfo);
          FieldManager.SetFieldData(propertyInfo, newValue);
          if (!_bypassPropertyChecks) PropertyHasChanged(propertyInfo);
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, and then
    /// calls PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the 
    /// property a SecurityException is thrown.
    /// </remarks>
    protected void SetProperty<P>(IPropertyInfo propertyInfo, P newValue)
    {
      SetProperty(propertyInfo, (object)newValue);
    }

#endregion

#region  Load Properties

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected void LoadPropertyConvert<P, F>(PropertyInfo<P> propertyInfo, F newValue)
    {
      try
      {
        P oldValue = default(P);
        var fieldData = FieldManager.GetFieldData(propertyInfo);
        if (fieldData == null)
        {
          oldValue = propertyInfo.DefaultValue;
          fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
        }
        else
        {
          var fd = fieldData as FieldManager.IFieldData<P>;
          if (fd != null)
            oldValue = fd.Value;
          else
            oldValue = (P)fieldData.Value;
        }
        LoadPropertyValue<P>(propertyInfo, oldValue, Utilities.CoerceValue<P>(typeof(F), oldValue, newValue), false);
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    void Core.IManageProperties.LoadProperty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      LoadProperty<P>(propertyInfo, newValue);
    }

    bool Core.IManageProperties.FieldExists(Core.IPropertyInfo property)
    {
      return FieldManager.FieldExists(property);
    }

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected void LoadProperty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      try
      {
        P oldValue = default(P);
        var fieldData = FieldManager.GetFieldData(propertyInfo);
        if (fieldData == null)
        {
          oldValue = propertyInfo.DefaultValue;
          fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
        }
        else
        {
          var fd = fieldData as FieldManager.IFieldData<P>;
          if (fd != null)
            oldValue = fd.Value;
          else
            oldValue = (P)fieldData.Value;
        }
        LoadPropertyValue<P>(propertyInfo, oldValue, newValue, false);
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value and mark field as dirty if value is modified.
    /// </summary> 
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected bool LoadPropertyMarkDirty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      try
      {
        P oldValue = default(P);
        var fieldData = FieldManager.GetFieldData(propertyInfo);
        if (fieldData == null)
        {
          oldValue = propertyInfo.DefaultValue;
          fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
        }
        else
        {
          var fd = fieldData as FieldManager.IFieldData<P>;
          if (fd != null)
            oldValue = fd.Value;
          else
            oldValue = (P)fieldData.Value;
        }

        var valuesDiffer = ValuesDiffer(propertyInfo, newValue, oldValue);
        if (valuesDiffer)
        {

          IBusinessObject old = oldValue as IBusinessObject;
          if (old != null)
            RemoveEventHooks(old);
          IBusinessObject @new = newValue as IBusinessObject;
          if (@new != null)
            AddEventHooks(@new);

          if (typeof(IEditableBusinessObject).IsAssignableFrom(propertyInfo.Type))
          {
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            ResetChildEditLevel(newValue);
          }
          else if (typeof(IEditableCollection).IsAssignableFrom(propertyInfo.Type))
          {
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            ResetChildEditLevel(newValue);
          }
          else
          {
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
          }
        }
        return valuesDiffer;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Check if old and new values are different.
    /// </summary>
    /// <typeparam name="P"></typeparam>
    /// <param name="propertyInfo">The property info.</param>
    /// <param name="newValue">The new value.</param>
    /// <param name="oldValue">The old value.</param>
    /// <returns></returns>
    private static bool ValuesDiffer<P>(PropertyInfo<P> propertyInfo, P newValue, P oldValue)
    {
      var valuesDiffer = false;
      if (oldValue == null)
        valuesDiffer = newValue != null;
      else
      {
        // use reference equals for objects that inherit from CSLA base class
        if (typeof (IBusinessObject).IsAssignableFrom(propertyInfo.Type))
        {
          valuesDiffer = !(ReferenceEquals(oldValue, newValue));
        }
        else
        {
          valuesDiffer = !(oldValue.Equals(newValue));
        }
      }
      return valuesDiffer;
    }

    private void LoadPropertyValue<P>(PropertyInfo<P> propertyInfo, P oldValue, P newValue, bool markDirty)
    {
      var valuesDiffer = ValuesDiffer(propertyInfo, newValue, oldValue);

      if (valuesDiffer)
      {

        IBusinessObject old = oldValue as IBusinessObject;
        if (old != null)
          RemoveEventHooks(old);
        IBusinessObject @new = newValue as IBusinessObject;
        if (@new != null)
          AddEventHooks(@new);


        if (typeof(IEditableBusinessObject).IsAssignableFrom(propertyInfo.Type))
        {
          if (markDirty)
          {
            OnPropertyChanging(propertyInfo);
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            PropertyHasChanged(propertyInfo);
          }
          else
          {
            FieldManager.LoadFieldData<P>(propertyInfo, newValue);
          }
          ResetChildEditLevel(newValue);
        }
        else if (typeof(IEditableCollection).IsAssignableFrom(propertyInfo.Type))
        {
          if (markDirty)
          {
            OnPropertyChanging(propertyInfo);
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            PropertyHasChanged(propertyInfo);
          }
          else
          {
            FieldManager.LoadFieldData<P>(propertyInfo, newValue);
          }
          ResetChildEditLevel(newValue);
        }
        else
        {
          if (markDirty)
          {
            OnPropertyChanging(propertyInfo);
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            PropertyHasChanged(propertyInfo);
          }
          else
          {
            FieldManager.LoadFieldData<P>(propertyInfo, newValue);
          }
        }
      }
    }

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected virtual bool LoadPropertyMarkDirty(IPropertyInfo propertyInfo, object newValue)
    {
      // private field 
      if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) == RelationshipTypes.PrivateField)
      {
        LoadProperty(propertyInfo, newValue);
        return false;
      }

#if IOS
      //manually call LoadProperty<T> if the type is nullable otherwise JIT error will occur
      if (propertyInfo.Type == typeof(int?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<int?>)propertyInfo, (int?)newValue);
      }
      else if (propertyInfo.Type == typeof(bool?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<bool?>)propertyInfo, (bool?)newValue);
      }
      else if (propertyInfo.Type == typeof(DateTime?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<DateTime?>)propertyInfo, (DateTime?)newValue);
      }
      else if (propertyInfo.Type == typeof(decimal?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<decimal?>)propertyInfo, (decimal?)newValue);
      }
      else if (propertyInfo.Type == typeof(double?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<double?>)propertyInfo, (double?)newValue);
      }
      else if (propertyInfo.Type == typeof(long?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<long?>)propertyInfo, (long?)newValue);
      }
      else if (propertyInfo.Type == typeof(byte?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<byte?>)propertyInfo, (byte?)newValue);
      }
      else if (propertyInfo.Type == typeof(char?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<char?>)propertyInfo, (char?)newValue);
      }
      else if (propertyInfo.Type == typeof(short?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<short?>)propertyInfo, (short?)newValue);
      }
      else if (propertyInfo.Type == typeof(uint?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<uint?>)propertyInfo, (uint?)newValue);
      }
      else if (propertyInfo.Type == typeof(ulong?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<ulong?>)propertyInfo, (ulong?)newValue);
      }
      else if (propertyInfo.Type == typeof(ushort?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<ushort?>)propertyInfo, (ushort?)newValue);
      }
      else
      {
        return (bool)LoadPropertyByReflection("LoadPropertyMarkDirty", propertyInfo, newValue);
      }
#else
      return (bool)LoadPropertyByReflection("LoadPropertyMarkDirty", propertyInfo, newValue);
#endif
    }


    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected virtual void LoadProperty(IPropertyInfo propertyInfo, object newValue)
    {
#if IOS
      //manually call LoadProperty<T> if the type is nullable otherwise JIT error will occur
      if (propertyInfo.Type == typeof(int?))
      {
        LoadProperty((PropertyInfo<int?>)propertyInfo, (int?)newValue);
      }
      else if (propertyInfo.Type == typeof(bool?))
      {
        LoadProperty((PropertyInfo<bool?>)propertyInfo, (bool?)newValue);
      }
      else if (propertyInfo.Type == typeof(DateTime?))
      {
        LoadProperty((PropertyInfo<DateTime?>)propertyInfo, (DateTime?)newValue);
      }
      else if (propertyInfo.Type == typeof(decimal?))
      {
        LoadProperty((PropertyInfo<decimal?>)propertyInfo, (decimal?)newValue);
      }
      else if (propertyInfo.Type == typeof(double?))
      {
        LoadProperty((PropertyInfo<double?>)propertyInfo, (double?)newValue);
      }
      else if (propertyInfo.Type == typeof(long?))
      {
        LoadProperty((PropertyInfo<long?>)propertyInfo, (long?)newValue);
      }
      else if (propertyInfo.Type == typeof(byte?))
      {
        LoadProperty((PropertyInfo<byte?>)propertyInfo, (byte?)newValue);
      }
      else if (propertyInfo.Type == typeof(char?))
      {
        LoadProperty((PropertyInfo<char?>)propertyInfo, (char?)newValue);
      }
      else if (propertyInfo.Type == typeof(short?))
      {
        LoadProperty((PropertyInfo<short?>)propertyInfo, (short?)newValue);
      }
      else if (propertyInfo.Type == typeof(uint?))
      {
        LoadProperty((PropertyInfo<uint?>)propertyInfo, (uint?)newValue);
      }
      else if (propertyInfo.Type == typeof(ulong?))
      {
        LoadProperty((PropertyInfo<ulong?>)propertyInfo, (ulong?)newValue);
      }
      else if (propertyInfo.Type == typeof(ushort?))
      {
        LoadProperty((PropertyInfo<ushort?>)propertyInfo, (ushort?)newValue);
      }
      else
      {
        LoadPropertyByReflection("LoadProperty", propertyInfo, newValue);
      }
#else
      LoadPropertyByReflection("LoadProperty", propertyInfo, newValue);
#endif
    }

    /// <summary>
    /// Calls the generic LoadProperty method via reflection.
    /// </summary>
    /// <param name="loadPropertyMethodName">
    /// The LoadProperty method name to call via reflection.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <returns></returns>
    private object LoadPropertyByReflection(string loadPropertyMethodName, IPropertyInfo propertyInfo, object newValue)
    {
      var t = this.GetType();
      var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
      var method = t.GetMethods(flags).FirstOrDefault(c => c.Name == loadPropertyMethodName && c.IsGenericMethod);
      var gm = method.MakeGenericMethod(propertyInfo.Type);
      var p = new object[] { propertyInfo, newValue };
      return gm.Invoke(this, p);
    }

    /// <summary>
    /// Makes sure that a child object is set up properly
    /// to be a child of this object.
    /// </summary>
    /// <param name="newValue">Potential child object</param>
    private void ResetChildEditLevel(object newValue)
    {
      IEditableBusinessObject child = newValue as IEditableBusinessObject;
      if (child != null)
      {
        child.SetParent(this);
        // set child edit level
        UndoableBase.ResetChildEditLevel(child, this.EditLevel, this.BindingEdit);
        // reset EditLevelAdded 
        child.EditLevelAdded = this.EditLevel;
      }
      else
      {
        IEditableCollection col = newValue as IEditableCollection;
        if (col != null)
        {
          col.SetParent(this);
          IUndoableObject undo = col as IUndoableObject;
          if (undo != null)
          {
            // set child edit level
            UndoableBase.ResetChildEditLevel(undo, this.EditLevel, this.BindingEdit);
          }
        }
      }
    }

    //private AsyncLoadManager
    [NonSerialized]
    [NotUndoable]
    private AsyncLoadManager _loadManager;
    internal AsyncLoadManager LoadManager
    {
      get
      {
        if (_loadManager == null)
        {
          _loadManager = new AsyncLoadManager(this, OnPropertyChanged);
          _loadManager.BusyChanged += loadManager_BusyChanged;
          _loadManager.UnhandledAsyncException += loadManager_UnhandledAsyncException;
        }
        return _loadManager;
      }
    }

    private void loadManager_UnhandledAsyncException(object sender, ErrorEventArgs e)
    {
      OnUnhandledAsyncException(e);
    }

    private void loadManager_BusyChanged(object sender, BusyChangedEventArgs e)
    {
      OnBusyChanged(e);
    }

    /// <summary>
    /// Load a property from an async method. 
    /// </summary>
    /// <typeparam name="R"></typeparam>
    /// <param name="property"></param>
    /// <param name="factory"></param>
    protected void LoadPropertyAsync<R>(PropertyInfo<R> property, Task<R> factory)
    {
      LoadManager.BeginLoad(new TaskLoader<R>(property, factory));
    }

#endregion

#region IsBusy / IsIdle

    [NonSerialized]
    [NotUndoable]
    private bool _isBusy;

    /// <summary>
    /// Mark the object as busy (it is
    /// running an async operation).
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkBusy()
    {
      if (_isBusy)
        throw new InvalidOperationException(Resources.BusyObjectsMayNotBeMarkedBusy);

      _isBusy = true;
      OnBusyChanged(new BusyChangedEventArgs("", true));
    }

    /// <summary>
    /// Mark the object as not busy (it is
    /// not running an async operation).
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkIdle()
    {
      _isBusy = false;
      OnBusyChanged(new BusyChangedEventArgs("", false));
    }

    /// <summary>
    /// Gets a value indicating if this
    /// object or its child objects are
    /// busy.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsBusy
    {
      get { return IsSelfBusy || (_fieldManager != null && FieldManager.IsBusy()); }
    }

    /// <summary>
    /// Gets a value indicating if this
    /// object is busy.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSelfBusy
    {
      get { return _isBusy || BusinessRules.RunningAsyncRules || LoadManager.IsLoading; }
    }

    [NotUndoable]
    [NonSerialized]
    private BusyChangedEventHandler _busyChanged;

    /// <summary>
    /// Event indicating that the IsBusy property has changed.
    /// </summary>
    public event BusyChangedEventHandler BusyChanged
    {
      add { _busyChanged = (BusyChangedEventHandler)Delegate.Combine(_busyChanged, value); }
      remove { _busyChanged = (BusyChangedEventHandler)Delegate.Remove(_busyChanged, value); }
    }

    /// <summary>
    /// Raise the BusyChanged event.
    /// </summary>
    /// <param name="args">Event args.</param>
    protected virtual void OnBusyChanged(BusyChangedEventArgs args)
    {
      if (_busyChanged != null)
        _busyChanged(this, args);
      MetaPropertyHasChanged("IsSelfBusy");
      MetaPropertyHasChanged("IsBusy");
    }

    /// <summary>
    /// Gets a value indicating whether a
    /// specific property is busy (has a
    /// currently executing async rule).
    /// </summary>
    /// <param name="property">
    /// Property to check.
    /// </param>
    public virtual bool IsPropertyBusy(Csla.Core.IPropertyInfo property)
    {
      return BusinessRules.GetPropertyBusy(property);
    }

    /// <summary>
    /// Gets a value indicating whether a
    /// specific property is busy (has a
    /// currently executing async rule).
    /// </summary>
    /// <param name="propertyName">
    /// Name of the property.
    /// </param>
    public bool IsPropertyBusy(string propertyName)
    {
      return IsPropertyBusy(FieldManager.GetRegisteredProperty(propertyName));
    }

#endregion

#region INotifyUnhandledAsyncException Members

    [NotUndoable]
    [NonSerialized]
    private EventHandler<ErrorEventArgs> _unhandledAsyncException;

    /// <summary>
    /// Event indicating that an exception occurred during
    /// the processing of an async operation.
    /// </summary>
    public event EventHandler<ErrorEventArgs> UnhandledAsyncException
    {
      add { _unhandledAsyncException = (EventHandler<ErrorEventArgs>)Delegate.Combine(_unhandledAsyncException, value); }
      remove { _unhandledAsyncException = (EventHandler<ErrorEventArgs>)Delegate.Remove(_unhandledAsyncException, value); }
    }

    /// <summary>
    /// Raises the UnhandledAsyncException event.
    /// </summary>
    /// <param name="error">Args parameter.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void OnUnhandledAsyncException(ErrorEventArgs error)
    {
      if (_unhandledAsyncException != null)
        _unhandledAsyncException(this, error);
    }

    /// <summary>
    /// Raises the UnhandledAsyncException event.
    /// </summary>
    /// <param name="originalSender">Original sender of
    /// the event.</param>
    /// <param name="error">Exception object.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void OnUnhandledAsyncException(object originalSender, Exception error)
    {
      OnUnhandledAsyncException(new ErrorEventArgs(originalSender, error));
    }

#endregion

#region Child Change Notification

    [NonSerialized]
    [NotUndoable]
    private EventHandler<Csla.Core.ChildChangedEventArgs> _childChangedHandlers;

    /// <summary>
    /// Event raised when a child object has been changed.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design",
      "CA1062:ValidateArgumentsOfPublicMethods")]
    public event EventHandler<Csla.Core.ChildChangedEventArgs> ChildChanged
    {
      add
      {
        _childChangedHandlers = (EventHandler<Csla.Core.ChildChangedEventArgs>)
          System.Delegate.Combine(_childChangedHandlers, value);
      }
      remove
      {
        _childChangedHandlers = (EventHandler<Csla.Core.ChildChangedEventArgs>)
          System.Delegate.Remove(_childChangedHandlers, value);
      }
    }

    /// <summary>
    /// Raises the ChildChanged event, indicating that a child
    /// object has been changed.
    /// </summary>
    /// <param name="e">
    /// ChildChangedEventArgs object.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void OnChildChanged(ChildChangedEventArgs e)
    {
      if (_childChangedHandlers != null)
        _childChangedHandlers.Invoke(this, e);
      MetaPropertyHasChanged("IsDirty");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(ChildChangedEventArgs e)
    {
      OnChildChanged(e);
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(
      object childObject, PropertyChangedEventArgs propertyArgs)
    {
      ChildChangedEventArgs args = new ChildChangedEventArgs(childObject, propertyArgs);
      OnChildChanged(args);
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(
      object childObject, PropertyChangedEventArgs propertyArgs, ListChangedEventArgs listArgs)
    {
      ChildChangedEventArgs args = new ChildChangedEventArgs(childObject, propertyArgs, listArgs);
      OnChildChanged(args);
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(
      object childObject, PropertyChangedEventArgs propertyArgs, NotifyCollectionChangedEventArgs listArgs)
    {
      ChildChangedEventArgs args = new ChildChangedEventArgs(childObject, propertyArgs, listArgs);
      OnChildChanged(args);
    }

    /// <summary>
    /// Handles any PropertyChanged event from 
    /// a child object and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      // Issue 813
      // MetaPropertyHasChanged calls in OnChildChanged we're leading to exponential growth in OnChildChanged calls
      // Those notifications are for the UI. Ignore them here
      if (!(e is MetaPropertyChangedEventArgs))
      {
        RaiseChildChanged(sender, e);
      }
    }

    /// <summary>
    /// Handles any ListChanged event from 
    /// a child list and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_ListChanged(object sender, ListChangedEventArgs e)
    {
      if (e.ListChangedType != ListChangedType.ItemChanged)
        RaiseChildChanged(sender, null, e);
    }

    /// <summary>
    /// Handles any CollectionChanged event
    /// from a child list and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
      RaiseChildChanged(sender, null, e);
    }

    /// <summary>
    /// Handles any ChildChanged event from
    /// a child object and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_Changed(object sender, ChildChangedEventArgs e)
    {
      RaiseChildChanged(e);
    }

#endregion

#region  Field Manager

    private FieldManager.FieldDataManager _fieldManager;

    /// <summary>
    /// Gets the PropertyManager object for this
    /// business object.
    /// </summary>
    protected FieldDataManager FieldManager
    {
      get
      {
        if (_fieldManager == null)
        {
          _fieldManager = new FieldDataManager(this.GetType());
          UndoableBase.ResetChildEditLevel(_fieldManager, this.EditLevel, this.BindingEdit);
        }
        return _fieldManager;
      }
    }

    private void FieldDataDeserialized()
    {
      foreach (object item in FieldManager.GetChildren())
      {
        if (item is IBusinessObject business)
          OnAddEventHooks(business);

        if (item is IEditableBusinessObject child)
        {
          child.SetParent(this);
        }
        if (item is IEditableCollection childCollection)
        {
          childCollection.SetParent(this);
        }
      }
    }

#endregion

#region  IParent

    /// <summary>
    /// Override this method to be notified when a child object's
    /// <see cref="Core.BusinessBase.ApplyEdit" /> method has
    /// completed.
    /// </summary>
    /// <param name="child">The child object that was edited.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void EditChildComplete(Core.IEditableBusinessObject child)
    {
      // do nothing, we don't really care
      // when a child has its edits applied
    }

    void IParent.ApplyEditChild(Core.IEditableBusinessObject child)
    {
      this.EditChildComplete(child);
    }

    void IParent.RemoveChild(IEditableBusinessObject child)
    {
      var info = FieldManager.FindProperty(child);
      FieldManager.RemoveField(info);
    }

    IParent Csla.Core.IParent.Parent
    {
      get { return this.Parent; }
    }

#endregion

#region IDataPortalTarget Members

    void Csla.Server.IDataPortalTarget.CheckRules()
    {
      BusinessRules.CheckRules();
    }

    void Csla.Server.IDataPortalTarget.MarkAsChild()
    {
      this.MarkAsChild();
    }

    void Csla.Server.IDataPortalTarget.MarkNew()
    {
      this.MarkNew();
    }

    void Csla.Server.IDataPortalTarget.MarkOld()
    {
      this.MarkOld();
    }

    void Csla.Server.IDataPortalTarget.DataPortal_OnDataPortalInvoke(DataPortalEventArgs e)
    {
      this.DataPortal_OnDataPortalInvoke(e);
    }

    void Csla.Server.IDataPortalTarget.DataPortal_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    {
      this.DataPortal_OnDataPortalInvokeComplete(e);
    }

    void Csla.Server.IDataPortalTarget.DataPortal_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    {
      this.DataPortal_OnDataPortalException(e, ex);
    }

    void Csla.Server.IDataPortalTarget.Child_OnDataPortalInvoke(DataPortalEventArgs e)
    {
      this.Child_OnDataPortalInvoke(e);
    }

    void Csla.Server.IDataPortalTarget.Child_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    {
      this.Child_OnDataPortalInvokeComplete(e);
    }

    void Csla.Server.IDataPortalTarget.Child_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    {
      this.Child_OnDataPortalException(e, ex);
    }

#endregion

#region IManageProperties Members

    bool IManageProperties.HasManagedProperties
    {
      get { return (_fieldManager != null && _fieldManager.HasFields); }
    }

    List<IPropertyInfo> IManageProperties.GetManagedProperties()
    {
      return FieldManager.GetRegisteredProperties();
    }

    object IManageProperties.GetProperty(IPropertyInfo propertyInfo)
    {
      return GetProperty(propertyInfo);
    }

    object IManageProperties.ReadProperty(IPropertyInfo propertyInfo)
    {
      return ReadProperty(propertyInfo);
    }

    P IManageProperties.ReadProperty<P>(PropertyInfo<P> propertyInfo)
    {
      return ReadProperty<P>(propertyInfo);
    }

    void IManageProperties.SetProperty(IPropertyInfo propertyInfo, object newValue)
    {
      SetProperty(propertyInfo, newValue);
    }

    void IManageProperties.LoadProperty(IPropertyInfo propertyInfo, object newValue)
    {
      LoadProperty(propertyInfo, newValue);
    }

    bool IManageProperties.LoadPropertyMarkDirty(IPropertyInfo propertyInfo, object newValue)
    {
      return LoadPropertyMarkDirty(propertyInfo, newValue);
    }

    List<object> IManageProperties.GetChildren()
    {
      return FieldManager.GetChildren();
    }
#endregion

#region MobileFormatter

    /// <summary>
    /// Override this method to insert your field values
    /// into the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="mode">
    /// The StateMode indicating why this method was invoked.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnGetState(Csla.Serialization.Mobile.SerializationInfo info, StateMode mode)
    {
      base.OnGetState(info, mode);
      info.AddValue("Csla.Core.BusinessBase._isNew", _isNew);
      info.AddValue("Csla.Core.BusinessBase._isDeleted", _isDeleted);
      info.AddValue("Csla.Core.BusinessBase._isDirty", _isDirty);
      info.AddValue("Csla.Core.BusinessBase._neverCommitted", _neverCommitted);
      info.AddValue("Csla.Core.BusinessBase._disableIEditableObject", _disableIEditableObject);
      info.AddValue("Csla.Core.BusinessBase._isChild", _isChild);
      info.AddValue("Csla.Core.BusinessBase._editLevelAdded", _editLevelAdded);
      info.AddValue("Csla.Core.BusinessBase._identity", _identity);
    }

    /// <summary>
    /// Override this method to retrieve your field values
    /// from the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="mode">
    /// The StateMode indicating why this method was invoked.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnSetState(Csla.Serialization.Mobile.SerializationInfo info, StateMode mode)
    {
      base.OnSetState(info, mode);
      _isNew = info.GetValue<bool>("Csla.Core.BusinessBase._isNew");
      _isDeleted = info.GetValue<bool>("Csla.Core.BusinessBase._isDeleted");
      _isDirty = info.GetValue<bool>("Csla.Core.BusinessBase._isDirty");
      _neverCommitted = info.GetValue<bool>("Csla.Core.BusinessBase._neverCommitted");
      _disableIEditableObject = info.GetValue<bool>("Csla.Core.BusinessBase._disableIEditableObject");
      _isChild = info.GetValue<bool>("Csla.Core.BusinessBase._isChild");
      if (mode != StateMode.Undo)
        _editLevelAdded = info.GetValue<int>("Csla.Core.BusinessBase._editLevelAdded");
      _identity = info.GetValue<int>("Csla.Core.BusinessBase._identity");
    }

    /// <summary>
    /// Override this method to insert your child object
    /// references into the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="formatter">
    /// Reference to MobileFormatter instance. Use this to
    /// convert child references to/from reference id values.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnGetChildren(
      Csla.Serialization.Mobile.SerializationInfo info, Csla.Serialization.Mobile.MobileFormatter formatter)
    {
      base.OnGetChildren(info, formatter);

      if (_fieldManager != null)
      {
        var fieldManagerInfo = formatter.SerializeObject(_fieldManager);
        info.AddChild("_fieldManager", fieldManagerInfo.ReferenceId);
      }

      if (_businessRules != null)
      {
        var vrInfo = formatter.SerializeObject(_businessRules);
        info.AddChild("_businessRules", vrInfo.ReferenceId);
      }
    }

    /// <summary>
    /// Override this method to retrieve your child object
    /// references from the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="formatter">
    /// Reference to MobileFormatter instance. Use this to
    /// convert child references to/from reference id values.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnSetChildren(Csla.Serialization.Mobile.SerializationInfo info, Csla.Serialization.Mobile.MobileFormatter formatter)
    {
      if (info.Children.ContainsKey("_fieldManager"))
      {
        var childData = info.Children["_fieldManager"];
        _fieldManager = (FieldManager.FieldDataManager)formatter.GetObject(childData.ReferenceId);
      }

      if (info.Children.ContainsKey("_businessRules"))
      {
        int refId = info.Children["_businessRules"].ReferenceId;
        _businessRules = (BusinessRules)formatter.GetObject(refId);
      }

      base.OnSetChildren(info, formatter);
    }

#endregion

#region Property Checks ByPass

    [NonSerialized]
    [NotUndoable]
    private bool _bypassPropertyChecks = false;

    /// <summary>
    /// Gets a value whether the business object is currently bypassing property checks?
    /// </summary>
    protected internal bool IsBypassingPropertyChecks { get { return _bypassPropertyChecks; } }
  
    [NonSerialized]
    [NotUndoable]
    private BypassPropertyChecksObject _bypassPropertyChecksObject = null;

    /// <summary>
    /// By wrapping this property inside Using block
    /// you can set property values on current business object
    /// without raising PropertyChanged events
    /// and checking user rights.
    /// </summary>
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    protected internal BypassPropertyChecksObject BypassPropertyChecks
    {
      get
      {
        return BypassPropertyChecksObject.GetManager(this);
      }
    }

    /// <summary>
    /// Class that allows setting of property values on 
    /// current business object
    /// without raising PropertyChanged events
    /// and checking user rights.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected internal class BypassPropertyChecksObject : IDisposable
    {
      private BusinessBase _businessObject;
      private static object _lock = new object();

      internal BypassPropertyChecksObject(BusinessBase businessObject)
      {
        _businessObject = businessObject;
        _businessObject._bypassPropertyChecks = true;
      }

#region IDisposable Members

      /// <summary>
      /// Disposes the object.
      /// </summary>
      public void Dispose()
      {
        Dispose(true);
        GC.SuppressFinalize(this);
      }

      /// <summary>
      /// Disposes the object.
      /// </summary>
      /// <param name="dispose">Dispose flag.</param>
      protected virtual void Dispose(bool dispose)
      {
        DeRef();
      }

      /// <summary>
      /// Gets the BypassPropertyChecks object.
      /// </summary>
      /// <param name="businessObject">The business object.</param>
      /// <returns></returns>
      public static BypassPropertyChecksObject GetManager(BusinessBase businessObject)
      {
        lock (_lock)
        {
          if (businessObject._bypassPropertyChecksObject == null)
            businessObject._bypassPropertyChecksObject = new BypassPropertyChecksObject(businessObject);

          businessObject._bypassPropertyChecksObject.AddRef();
        }
        return businessObject._bypassPropertyChecksObject;
      }

#region  Reference counting

      private int _refCount;

      /// <summary>
      /// Gets the current reference count for this
      /// object.
      /// </summary>
      public int RefCount
      {
        get { return _refCount; }
      }

      private void AddRef()
      {
        _refCount += 1;
      }

      private void DeRef()
      {

        lock (_lock)
        {
          _refCount -= 1;
          if (_refCount == 0)
          {
            _businessObject._bypassPropertyChecks = false;
            _businessObject._bypassPropertyChecksObject = null;
            _businessObject = null;
          }
        }
      }

#endregion
#endregion
    }

#endregion

#region ISuppressRuleChecking Members

    /// <summary>
    /// Sets value indicating no rule methods will be invoked.
    /// </summary>
    void ICheckRules.SuppressRuleChecking()
    {
      BusinessRules.SuppressRuleChecking = true;
    }

    /// <summary>
    /// Resets value indicating all rule methods will be invoked.
    /// </summary>
    void ICheckRules.ResumeRuleChecking()
    {
      BusinessRules.SuppressRuleChecking = false;
    }

    /// <summary>
    /// Invokes all rules for the business object.
    /// </summary>
    void ICheckRules.CheckRules()
    {
      BusinessRules.CheckRules();
    }

    /// <summary>
    /// Invokes all rules for the business object.
    /// </summary>
    Task ICheckRules.CheckRulesAsync()
    {
      return BusinessRules.CheckRulesAsync();
    }

    /// <summary>
    /// Gets the broken rules for this object
    /// </summary>
    public BrokenRulesCollection GetBrokenRules()
    {
      return BrokenRulesCollection;
    }

#endregion
  }
}
---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading.Tasks;
using Csla.Properties;
using System.Collections.Specialized;
using System.ComponentModel.DataAnnotations;
using System.Collections.ObjectModel;
using Csla.Core.LoadManager;
using Csla.Reflection;
using Csla.Server;
using Csla.Security;
using Csla.Serialization.Mobile;
using Csla.Rules;
using System.Security;
using Csla.Core.FieldManager;
using System.Reflection;

namespace Csla.Core
{

  /// <summary>
  /// This is the non-generic base class from which most
  /// business objects will be derived.
  /// </summary>
#if TESTING
  [System.Diagnostics.DebuggerStepThrough]
#endif
  [Serializable]
  public abstract class BusinessBase : UndoableBase,
    IEditableBusinessObject,
    IEditableObject,
    ICloneable,
    IAuthorizeReadWrite,
    IParent,
    IDataPortalTarget,
    IManageProperties,
    Rules.IHostRules,
    ICheckRules,
    INotifyBusy,
    INotifyChildChanged,
    ISerializationNotification
, IDataErrorInfo
  {

    /// <summary>
    /// Creates an instance of the object.
    /// </summary>
    protected BusinessBase()
    {
      InitializeIdentity();
      Initialize();
      InitializeBusinessRules();
    }

    #region Initialize

    /// <summary>
    /// Override this method to set up event handlers so user
    /// code in a partial class can respond to events raised by
    /// generated code.
    /// </summary>
    protected virtual void Initialize()
    { /* allows subclass to initialize events before any other activity occurs */ }

    #endregion

    #region Identity

    private int _identity = -1;

    int IBusinessObject.Identity
    {
      get { return _identity; }
    }

    private void InitializeIdentity()
    {
      _identity = ((IParent)this).GetNextIdentity(_identity);
    }

    [NonSerialized]
    [NotUndoable]
    private IdentityManager _identityManager;

    int IParent.GetNextIdentity(int current)
    {
      if (this.Parent != null)
      {
        return this.Parent.GetNextIdentity(current);
      }
      else
      {
        if (_identityManager == null)
          _identityManager = new IdentityManager();
        return _identityManager.GetNextIdentity(current);
      }
    }
    
    #endregion

    #region Parent/Child link

    [NotUndoable]
    [NonSerialized]
    private IParent _parent;

    /// <summary>
    /// Provide access to the parent reference for use
    /// in child object code.
    /// </summary>
    /// <remarks>
    /// This value will be Nothing for root objects.
    /// </remarks>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public Core.IParent Parent
    {
      get { return _parent; }
    }

    /// <summary>
    /// Used by BusinessListBase as a child object is 
    /// created to tell the child object about its
    /// parent.
    /// </summary>
    /// <param name="parent">A reference to the parent collection object.</param>
    protected virtual void SetParent(Core.IParent parent)
    {
      _parent = parent;
      _identityManager = null;
      InitializeIdentity();
    }

    #endregion

    #region IsNew, IsDeleted, IsDirty, IsSavable

    // keep track of whether we are new, deleted or dirty
    private bool _isNew = true;
    private bool _isDeleted;
    private bool _isDirty = true;

    /// <summary>
    /// Returns true if this is a new object, 
    /// false if it is a pre-existing object.
    /// </summary>
    /// <remarks>
    /// An object is considered to be new if its primary identifying (key) value 
    /// doesn't correspond to data in the database. In other words, 
    /// if the data values in this particular
    /// object have not yet been saved to the database the object is considered to
    /// be new. Likewise, if the object's data has been deleted from the database
    /// then the object is considered to be new.
    /// </remarks>
    /// <returns>A value indicating if this object is new.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public bool IsNew
    {
      get { return _isNew; }
    }

    /// <summary>
    /// Returns true if this object is marked for deletion.
    /// </summary>
    /// <remarks>
    /// CSLA .NET supports both immediate and deferred deletion of objects. This
    /// property is part of the support for deferred deletion, where an object
    /// can be marked for deletion, but isn't actually deleted until the object
    /// is saved to the database. This property indicates whether or not the
    /// current object has been marked for deletion. If it is true
    /// , the object will
    /// be deleted when it is saved to the database, otherwise it will be inserted
    /// or updated by the save operation.
    /// </remarks>
    /// <returns>A value indicating if this object is marked for deletion.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public bool IsDeleted
    {
      get { return _isDeleted; }
    }

    /// <summary>
    /// Returns true if this object's 
    /// data, or any of its fields or child objects data, 
    /// has been changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When an object's data is changed, CSLA .NET makes note of that change
    /// and considers the object to be 'dirty' or changed. This value is used to
    /// optimize data updates, since an unchanged object does not need to be
    /// updated into the database. All new objects are considered dirty. All objects
    /// marked for deletion are considered dirty.
    /// </para><para>
    /// Once an object's data has been saved to the database (inserted or updated)
    /// the dirty flag is cleared and the object is considered unchanged. Objects
    /// newly loaded from the database are also considered unchanged.
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if this object's data has been changed.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsDirty
    {
      get { return IsSelfDirty || (_fieldManager != null && FieldManager.IsDirty()); }
    }

    /// <summary>
    /// Returns true if this object's data has been changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When an object's data is changed, CSLA .NET makes note of that change
    /// and considers the object to be 'dirty' or changed. This value is used to
    /// optimize data updates, since an unchanged object does not need to be
    /// updated into the database. All new objects are considered dirty. All objects
    /// marked for deletion are considered dirty.
    /// </para><para>
    /// Once an object's data has been saved to the database (inserted or updated)
    /// the dirty flag is cleared and the object is considered unchanged. Objects
    /// newly loaded from the database are also considered unchanged.
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if this object's data has been changed.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSelfDirty
    {
      get { return _isDirty; }
    }

    /// <summary>
    /// Marks the object as being a new object. This also marks the object
    /// as being dirty and ensures that it is not marked for deletion.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Newly created objects are marked new by default. You should call
    /// this method in the implementation of DataPortal_Update when the
    /// object is deleted (due to being marked for deletion) to indicate
    /// that the object no longer reflects data in the database.
    /// </para><para>
    /// If you override this method, make sure to call the base
    /// implementation after executing your new code.
    /// </para>
    /// </remarks>
    protected virtual void MarkNew()
    {
      _isNew = true;
      _isDeleted = false;
      MetaPropertyHasChanged("IsNew");
      MetaPropertyHasChanged("IsDeleted");
      MarkDirty();
    }

    /// <summary>
    /// Marks the object as being an old (not new) object. This also
    /// marks the object as being unchanged (not dirty).
    /// </summary>
    /// <remarks>
    /// <para>
    /// You should call this method in the implementation of
    /// DataPortal_Fetch to indicate that an existing object has been
    /// successfully retrieved from the database.
    /// </para><para>
    /// You should call this method in the implementation of 
    /// DataPortal_Update to indicate that a new object has been successfully
    /// inserted into the database.
    /// </para><para>
    /// If you override this method, make sure to call the base
    /// implementation after executing your new code.
    /// </para>
    /// </remarks>
    protected virtual void MarkOld()
    {
      _isNew = false;
      MetaPropertyHasChanged("IsNew");
      MarkClean();
    }

    /// <summary>
    /// Marks an object for deletion. This also marks the object
    /// as being dirty.
    /// </summary>
    /// <remarks>
    /// You should call this method in your business logic in the
    /// case that you want to have the object deleted when it is
    /// saved to the database.
    /// </remarks>
    protected void MarkDeleted()
    {
      _isDeleted = true;
      MetaPropertyHasChanged("IsDeleted");
      MarkDirty();
    }

    /// <summary>
    /// Marks an object as being dirty, or changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// You should call this method in your business logic any time
    /// the object's internal data changes. Any time any instance
    /// variable changes within the object, this method should be called
    /// to tell CSLA .NET that the object's data has been changed.
    /// </para><para>
    /// Marking an object as dirty does two things. First it ensures
    /// that CSLA .NET will properly save the object as appropriate. Second,
    /// it causes CSLA .NET to tell Windows Forms data binding that the
    /// object's data has changed so any bound controls will update to
    /// reflect the new values.
    /// </para>
    /// </remarks>
    protected void MarkDirty()
    {
      MarkDirty(false);
    }

    /// <summary>
    /// Marks an object as being dirty, or changed.
    /// </summary>
    /// <param name="suppressEvent">
    /// true to supress the PropertyChanged event that is otherwise
    /// raised to indicate that the object's state has changed.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkDirty(bool suppressEvent)
    {
      bool old = _isDirty;
      _isDirty = true;
      if (!suppressEvent)
        OnUnknownPropertyChanged();
      if (_isDirty != old)
      {
        MetaPropertyHasChanged("IsSelfDirty");
        MetaPropertyHasChanged("IsDirty");
        MetaPropertyHasChanged("IsSavable");
      }
    }

    /// <summary>
    /// Performs processing required when a property
    /// has changed.
    /// </summary>
    /// <param name="property">Property that
    /// has changed.</param>
    /// <remarks>
    /// This method calls CheckRules(propertyName), MarkDirty and
    /// OnPropertyChanged(propertyName). MarkDirty is called such
    /// that no event is raised for IsDirty, so only the specific
    /// property changed event for the current property is raised.
    /// </remarks>
    protected virtual void PropertyHasChanged(Csla.Core.IPropertyInfo property)
    {
      MarkDirty(true);
      CheckPropertyRules(property);
    }

    private void PropertyHasChanged(string propertyName)
    {
      PropertyHasChanged(FieldManager.GetRegisteredProperty(propertyName));
    }

    /// <summary>
    /// Raises OnPropertyChanged for meta properties (IsXYZ) when PropertyChangedMode is not Windows
    /// </summary>
    /// <param name="name">meta property name that has cchanged.</param>
    protected virtual void MetaPropertyHasChanged(string name)
    {
      if (ApplicationContext.PropertyChangedMode != ApplicationContext.PropertyChangedModes.Windows)
        OnMetaPropertyChanged(name);
    }

    /// <summary>
    /// Check rules for the property and notifies UI of properties that may have changed.
    /// </summary>
    /// <param name="property">The property.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void CheckPropertyRules(IPropertyInfo property)
    {
      var propertyNames = BusinessRules.CheckRules(property);
      if (ApplicationContext.PropertyChangedMode == ApplicationContext.PropertyChangedModes.Windows)
        OnPropertyChanged(property);
      else
        foreach (var name in propertyNames)
          OnPropertyChanged(name);
    }

    /// <summary>
    /// Check object rules and notifies UI of properties that may have changed. 
    /// </summary>
    protected virtual void CheckObjectRules()
    {
      var propertyNames = BusinessRules.CheckObjectRules();
      if (ApplicationContext.PropertyChangedMode == ApplicationContext.PropertyChangedModes.Windows)
      {
        OnUnknownPropertyChanged();
      }
      else
        foreach (var name in propertyNames)
          OnPropertyChanged(name);
    }



    /// <summary>
    /// Forces the object's IsDirty flag to false.
    /// </summary>
    /// <remarks>
    /// This method is normally called automatically and is
    /// not intended to be called manually.
    /// </remarks>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkClean()
    {
      _isDirty = false;
      if (_fieldManager != null)
        FieldManager.MarkClean();
      OnUnknownPropertyChanged();
      MetaPropertyHasChanged("IsSelfDirty");
      MetaPropertyHasChanged("IsDirty");
      MetaPropertyHasChanged("IsSavable");
    }

    /// <summary>
    /// Returns true if this object is both dirty and valid.
    /// </summary>
    /// <remarks>
    /// An object is considered dirty (changed) if 
    /// <see cref="P:Csla.BusinessBase.IsDirty" /> returns true. It is
    /// considered valid if IsValid
    /// returns true. The IsSavable property is
    /// a combination of these two properties. 
    /// </remarks>
    /// <returns>A value indicating if this object is both dirty and valid.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSavable
    {
      get
      {
        bool auth;
        if (IsDeleted)
          auth = Csla.Rules.BusinessRules.HasPermission(Rules.AuthorizationActions.DeleteObject, this);
        else if (IsNew)
          auth = Csla.Rules.BusinessRules.HasPermission(Rules.AuthorizationActions.CreateObject, this);
        else
          auth = Csla.Rules.BusinessRules.HasPermission(Rules.AuthorizationActions.EditObject, this);
        return (auth && IsDirty && IsValid && !IsBusy);
      }
    }

    #endregion

    #region Authorization

    [NotUndoable]
    [NonSerialized]
    private ConcurrentDictionary<string, bool> _readResultCache;
    [NotUndoable]
    [NonSerialized]
    private ConcurrentDictionary<string, bool> _writeResultCache;
    [NotUndoable]
    [NonSerialized]
    private ConcurrentDictionary<string, bool> _executeResultCache;
    [NotUndoable]
    [NonSerialized]
    private System.Security.Principal.IPrincipal _lastPrincipal;

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// calling property.
    /// </summary>
    /// <param name="property">Property to check.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanReadProperty(Csla.Core.IPropertyInfo property)
    {
      var result = true;

      VerifyAuthorizationCache();

      if (!_readResultCache.TryGetValue(property.Name, out result))
      {
        result = BusinessRules.HasPermission(AuthorizationActions.ReadProperty, property);
        if (BusinessRules.CachePermissionResult(AuthorizationActions.ReadProperty, property))
        {
          // store value in cache
          _readResultCache.AddOrUpdate(property.Name, result, (a,b) => { return result; });
        }
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// calling property.
    /// </summary>
    /// <returns>true if read is allowed.</returns>
    /// <param name="property">Property to read.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanReadProperty(Csla.Core.IPropertyInfo property, bool throwOnFalse)
    {
      bool result = CanReadProperty(property);
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex = new Csla.Security.SecurityException(
          String.Format("{0} ({1})",
          Resources.PropertyGetNotAllowed, property.Name));
        throw ex;
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to read.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanReadProperty(string propertyName)
    {
      return CanReadProperty(propertyName, false);
    }

    /// <summary>
    /// Returns true if the user is allowed to read the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to read.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    private bool CanReadProperty(string propertyName, bool throwOnFalse)
    {
      var propertyInfo = FieldManager.GetRegisteredProperties().FirstOrDefault(p => p.Name == propertyName);
      if (propertyInfo == null)
      {
        Trace.TraceError("CanReadProperty: {0} is not a registered property of {1}.{2}", propertyName, this.GetType().Namespace, this.GetType().Name);
        return true;
      }
      return CanReadProperty(propertyInfo, throwOnFalse);
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// specified property.
    /// </summary>
    /// <param name="property">Property to write.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanWriteProperty(Csla.Core.IPropertyInfo property)
    {
      bool result = true;

      VerifyAuthorizationCache();

      if (!_writeResultCache.TryGetValue(property.Name, out result))
      {
        result = BusinessRules.HasPermission(AuthorizationActions.WriteProperty, property);
        if (BusinessRules.CachePermissionResult(AuthorizationActions.WriteProperty, property))
        {
          // store value in cache
          _writeResultCache.AddOrUpdate(property.Name, result, (a, b) => { return result; });
        }
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// calling property.
    /// </summary>
    /// <returns>true if write is allowed.</returns>
    /// <param name="property">Property to write.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanWriteProperty(Csla.Core.IPropertyInfo property, bool throwOnFalse)
    {
      bool result = CanWriteProperty(property);
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex = new Csla.Security.SecurityException(
          String.Format("{0} ({1})", Resources.PropertySetNotAllowed, property.Name));
        throw ex;
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to write.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanWriteProperty(string propertyName)
    {
      return CanWriteProperty(propertyName, false);
    }

    /// <summary>
    /// Returns true if the user is allowed to write the
    /// specified property.
    /// </summary>
    /// <param name="propertyName">Name of the property to write.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    private bool CanWriteProperty(string propertyName, bool throwOnFalse)
    {
      var propertyInfo = FieldManager.GetRegisteredProperties().FirstOrDefault(p => p.Name == propertyName);
      if (propertyInfo == null)
      {
        Trace.TraceError("CanReadProperty: {0} is not a registered property of {1}.{2}", propertyName, this.GetType().Namespace, this.GetType().Name);
        return true;
      }
      return CanWriteProperty(propertyInfo, throwOnFalse);
    }

    private void VerifyAuthorizationCache()
    {
      if (_readResultCache == null)
        _readResultCache = new ConcurrentDictionary<string, bool>();
      if (_writeResultCache == null)
        _writeResultCache = new ConcurrentDictionary<string, bool>();
      if (_executeResultCache == null)
        _executeResultCache = new ConcurrentDictionary<string, bool>();
      if (!ReferenceEquals(Csla.ApplicationContext.User, _lastPrincipal))
      {
        // the principal has changed - reset the cache
        _readResultCache.Clear();
        _writeResultCache.Clear();
        _executeResultCache.Clear();
        _lastPrincipal = Csla.ApplicationContext.User;
      }
    }

    /// <summary>
    /// Returns true if the user is allowed to execute
    /// the specified method.
    /// </summary>
    /// <param name="method">Method to execute.</param>
    /// <returns>true if execute is allowed.</returns>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanExecuteMethod(Csla.Core.IMemberInfo method)
    {
      bool result = true;

      VerifyAuthorizationCache();

      if (!_executeResultCache.TryGetValue(method.Name, out result))
      {
        result = BusinessRules.HasPermission(AuthorizationActions.ExecuteMethod, method);
        if (BusinessRules.CachePermissionResult(AuthorizationActions.ExecuteMethod, method))
        {
          // store value in cache
          _executeResultCache.AddOrUpdate(method.Name, result, (a, b) => { return result; });
        }
      }
      return result;
    }

    /// <summary>
    /// Returns true if the user is allowed to execute
    /// the specified method.
    /// </summary>
    /// <returns>true if execute is allowed.</returns>
    /// <param name="method">Method to execute.</param>
    /// <param name="throwOnFalse">Indicates whether a negative
    /// result should cause an exception.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool CanExecuteMethod(Csla.Core.IMemberInfo method, bool throwOnFalse)
    {

      bool result = CanExecuteMethod(method);
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex =
          new Csla.Security.SecurityException(string.Format("{0} ({1})", Properties.Resources.MethodExecuteNotAllowed, method.Name));
        throw ex;
      }
      return result;

    }


    /// <summary>
    /// Returns true if the user is allowed to execute
    /// the specified method.
    /// </summary>
    /// <param name="methodName">Name of the method to execute.</param>
    /// <returns>true if execute is allowed.</returns>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual bool CanExecuteMethod(string methodName)
    {
      return CanExecuteMethod(methodName, false);
    }

    private bool CanExecuteMethod(string methodName, bool throwOnFalse)
    {

      bool result = CanExecuteMethod(new MethodInfo(methodName));
      if (throwOnFalse && result == false)
      {
        Csla.Security.SecurityException ex = new Csla.Security.SecurityException(string.Format("{0} ({1})", Properties.Resources.MethodExecuteNotAllowed, methodName));
        throw ex;
      }
      return result;
    }

#endregion

#region System.ComponentModel.IEditableObject

    private bool _neverCommitted = true;
    [NotUndoable]
    private bool _disableIEditableObject;

    /// <summary>
    /// Gets or sets a value indicating whether the
    /// IEditableObject interface methods should
    /// be disabled for this object.
    /// </summary>
    /// <value>Defaults to False, indicating that
    /// the IEditableObject methods will behave
    /// normally.</value>
    /// <remarks>
    /// If you disable the IEditableObject methods
    /// then Windows Forms data binding will no longer
    /// automatically call BeginEdit, CancelEdit or
    /// ApplyEdit on your object, and you will have
    /// to call these methods manually to get proper
    /// n-level undo behavior.
    /// </remarks>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected bool DisableIEditableObject
    {
      get
      {
        return _disableIEditableObject;
      }
      set
      {
        _disableIEditableObject = value;
      }
    }

    /// <summary>
    /// Allow data binding to start a nested edit on the object.
    /// </summary>
    /// <remarks>
    /// Data binding may call this method many times. Only the first
    /// call should be honored, so we have extra code to detect this
    /// and do nothing for subsquent calls.
    /// </remarks>
    void System.ComponentModel.IEditableObject.BeginEdit()
    {
      if (!_disableIEditableObject && !BindingEdit)
      {
        BindingEdit = true;
        BeginEdit();
      }
    }

    /// <summary>
    /// Allow data binding to cancel the current edit.
    /// </summary>
    /// <remarks>
    /// Data binding may call this method many times. Only the first
    /// call to either IEditableObject.CancelEdit or 
    /// IEditableObject.EndEdit
    /// should be honored. We include extra code to detect this and do
    /// nothing for subsequent calls.
    /// </remarks>
    void System.ComponentModel.IEditableObject.CancelEdit()
    {
      if (!_disableIEditableObject && BindingEdit)
      {
        CancelEdit();
        BindingEdit = false;
        if (IsNew && _neverCommitted && EditLevel <= EditLevelAdded)
        {
          // we're new and no EndEdit or ApplyEdit has ever been
          // called on us, and now we've been cancelled back to
          // where we were added so we should have ourselves
          // removed from the parent collection
          if (Parent != null)
            Parent.RemoveChild(this);
        }
      }
    }

    /// <summary>
    /// Allow data binding to apply the current edit.
    /// </summary>
    /// <remarks>
    /// Data binding may call this method many times. Only the first
    /// call to either IEditableObject.EndEdit or 
    /// IEditableObject.CancelEdit
    /// should be honored. We include extra code to detect this and do
    /// nothing for subsequent calls.
    /// </remarks>
    void System.ComponentModel.IEditableObject.EndEdit()
    {
      if (!_disableIEditableObject && BindingEdit)
      {
        ApplyEdit();
        BindingEdit = false;
      }
    }

#endregion

#region Begin/Cancel/ApplyEdit

    /// <summary>
    /// Starts a nested edit on the object.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When this method is called the object takes a snapshot of
    /// its current state (the values of its variables). This snapshot
    /// can be restored by calling CancelEdit
    /// or committed by calling ApplyEdit.
    /// </para><para>
    /// This is a nested operation. Each call to BeginEdit adds a new
    /// snapshot of the object's state to a stack. You should ensure that 
    /// for each call to BeginEdit there is a corresponding call to either 
    /// CancelEdit or ApplyEdit to remove that snapshot from the stack.
    /// </para><para>
    /// See Chapters 2 and 3 for details on n-level undo and state stacking.
    /// </para>
    /// </remarks>
    public void BeginEdit()
    {
      CopyState(this.EditLevel + 1);
    }

    /// <summary>
    /// Cancels the current edit process, restoring the object's state to
    /// its previous values.
    /// </summary>
    /// <remarks>
    /// Calling this method causes the most recently taken snapshot of the 
    /// object's state to be restored. This resets the object's values
    /// to the point of the last BeginEdit call.
    /// </remarks>
    public void CancelEdit()
    {
      UndoChanges(this.EditLevel - 1);
    }

    /// <summary>
    /// Called when an undo operation has completed.
    /// </summary>
    /// <remarks> 
    /// This method resets the object as a result of
    /// deserialization and raises PropertyChanged events
    /// to notify data binding that the object has changed.
    /// </remarks>
    protected override void UndoChangesComplete()
    {
      BusinessRules.SetTarget(this);
      InitializeBusinessRules();
      OnUnknownPropertyChanged();
      base.UndoChangesComplete();
    }

    /// <summary>
    /// Commits the current edit process.
    /// </summary>
    /// <remarks>
    /// Calling this method causes the most recently taken snapshot of the 
    /// object's state to be discarded, thus committing any changes made
    /// to the object's state since the last BeginEdit call.
    /// </remarks>
    public void ApplyEdit()
    {
      _neverCommitted = false;
      AcceptChanges(this.EditLevel - 1);
      //Next line moved to IEditableObject.ApplyEdit 
      //BindingEdit = false;
    }

    /// <summary>
    /// Notifies the parent object (if any) that this
    /// child object's edits have been accepted.
    /// </summary>
    protected override void AcceptChangesComplete()
    {
      BindingEdit = false;
      base.AcceptChangesComplete();

      // !!!! Will trigger Save here when using DynamicListBase template
      if (Parent != null)
        Parent.ApplyEditChild(this);
    }

#endregion

#region IsChild

    [NotUndoable]
    private bool _isChild;

    /// <summary>
    /// Returns true if this is a child (non-root) object.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public bool IsChild
    {
      get { return _isChild; }
    }

    /// <summary>
    /// Marks the object as being a child object.
    /// </summary>
    protected void MarkAsChild()
    {
      _identity = -1;
      _isChild = true;
    }

#endregion

#region Delete

    /// <summary>
    /// Marks the object for deletion. The object will be deleted as part of the
    /// next save operation.
    /// </summary>
    /// <remarks>
    /// <para>
    /// CSLA .NET supports both immediate and deferred deletion of objects. This
    /// method is part of the support for deferred deletion, where an object
    /// can be marked for deletion, but isn't actually deleted until the object
    /// is saved to the database. This method is called by the UI developer to
    /// mark the object for deletion.
    /// </para><para>
    /// To 'undelete' an object, use n-level undo as discussed in Chapters 2 and 3.
    /// </para>
    /// </remarks>
    public virtual void Delete()
    {
      if (this.IsChild)
        throw new NotSupportedException(Resources.ChildDeleteException);

      MarkDeleted();
    }

    /// <summary>
    /// Called by a parent object to mark the child
    /// for deferred deletion.
    /// </summary>
    internal void DeleteChild()
    {
      if (!this.IsChild)
        throw new NotSupportedException(Resources.NoDeleteRootException);

      BindingEdit = false;
      MarkDeleted();
    }

#endregion

#region Edit Level Tracking (child only)

    // we need to keep track of the edit
    // level when we weere added so if the user
    // cancels below that level we can be destroyed
    [NotUndoable]
    private int _editLevelAdded;

    /// <summary>
    /// Gets or sets the current edit level of the
    /// object.
    /// </summary>
    /// <remarks>
    /// Allow the collection object to use the
    /// edit level as needed.
    /// </remarks>
    internal int EditLevelAdded
    {
      get { return _editLevelAdded; }
      set { _editLevelAdded = value; }
    }

    int IUndoableObject.EditLevel
    {
      get
      {
        return this.EditLevel;
      }
    }

#endregion

#region ICloneable

    object ICloneable.Clone()
    {
      return GetClone();
    }

    /// <summary>
    /// Creates a clone of the object.
    /// </summary>
    /// <returns>
    /// A new object containing the exact data of the original object.
    /// </returns>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual object GetClone()
    {
      return ObjectCloner.Clone(this);
    }

#endregion

#region BusinessRules, IsValid

    [NonSerialized]
    [NotUndoable]
    private EventHandler _validationCompleteHandlers;

    /// <summary>
    /// Event raised when validation is complete.
    /// </summary>
    public event EventHandler ValidationComplete
    {
      add
      {
        _validationCompleteHandlers = (EventHandler)
          System.Delegate.Combine(_validationCompleteHandlers, value);
      }
      remove
      {
        _validationCompleteHandlers = (EventHandler)
          System.Delegate.Remove(_validationCompleteHandlers, value);
      }
    }

    /// <summary>
    /// Raises the ValidationComplete event
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void OnValidationComplete()
    {
      if (_validationCompleteHandlers != null)
        _validationCompleteHandlers(this, EventArgs.Empty);
    }

    private void InitializeBusinessRules()
    {
      var rules = BusinessRuleManager.GetRulesForType(this.GetType());
      if (!rules.Initialized)
        lock (rules)
          if (!rules.Initialized)
          {
            try
            {
              AddBusinessRules();
              rules.Initialized = true;
            }
            catch (Exception)
            {
              BusinessRuleManager.CleanupRulesForType(this.GetType());
              throw;  // and rethrow exception
            }
          }
    }

    private Csla.Rules.BusinessRules _businessRules;

    /// <summary>
    /// Provides access to the broken rules functionality.
    /// </summary>
    /// <remarks>
    /// This property is used within your business logic so you can
    /// easily call the AddRule() method to associate business
    /// rules with your object's properties.
    /// </remarks>
    protected BusinessRules BusinessRules
    {
      get
      {
        if (_businessRules == null)
          _businessRules = new BusinessRules(this);
        else if (_businessRules.Target == null)
          _businessRules.SetTarget(this);
        return _businessRules;
      }
    }

    /// <summary>
    /// Gets the registered rules. Only for unit testing and not visible to code. 
    /// </summary>
    /// <returns></returns>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected BusinessRuleManager GetRegisteredRules()
    {
      return BusinessRules.TypeRules;
    }

    void IHostRules.RuleStart(IPropertyInfo property)
    {
      OnBusyChanged(new BusyChangedEventArgs(property.Name, true));
    }

    void IHostRules.RuleComplete(IPropertyInfo property)
    {
      OnPropertyChanged(property);
      OnBusyChanged(new BusyChangedEventArgs(property.Name, false));
      MetaPropertyHasChanged("IsSelfValid");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    void IHostRules.RuleComplete(string property)
    {
      OnPropertyChanged(property);
      MetaPropertyHasChanged("IsSelfValid");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    void Rules.IHostRules.AllRulesComplete()
    {
      OnValidationComplete();
      MetaPropertyHasChanged("IsSelfValid");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    /// <summary>
    /// Override this method in your business class to
    /// be notified when you need to set up shared 
    /// business rules.
    /// </summary>
    /// <remarks>
    /// This method is automatically called by CSLA .NET
    /// when your object should associate per-type 
    /// validation rules with its properties.
    /// </remarks>
    protected virtual void AddBusinessRules()
    {
      BusinessRules.AddDataAnnotations();
    }

    /// <summary>
    /// Returns true if the object 
    /// and its child objects are currently valid, 
    /// false if the
    /// object or any of its child objects have broken 
    /// rules or are otherwise invalid.
    /// </summary>
    /// <remarks>
    /// <para>
    /// By default this property relies on the underling BusinessRules
    /// object to track whether any business rules are currently broken for this object.
    /// </para><para>
    /// You can override this property to provide more sophisticated
    /// implementations of the behavior. For instance, you should always override
    /// this method if your object has child objects, since the validity of this object
    /// is affected by the validity of all child objects.
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if the object is currently valid.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsValid
    {
      get { return IsSelfValid && (_fieldManager == null || FieldManager.IsValid()); }
    }

    /// <summary>
    /// Returns true if the object is currently 
    /// valid, false if the
    /// object has broken rules or is otherwise invalid.
    /// </summary>
    /// <remarks>
    /// <para>
    /// By default this property relies on the underling BusinessRules
    /// object to track whether any business rules are currently broken for this object.
    /// </para><para>
    /// You can override this property to provide more sophisticated
    /// implementations of the behavior. 
    /// </para>
    /// </remarks>
    /// <returns>A value indicating if the object is currently valid.</returns>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSelfValid
    {
      get { return BusinessRules.IsValid; }
    }

    /// <summary>
    /// Provides access to the readonly collection of broken business rules
    /// for this object.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    [System.ComponentModel.DataAnnotations.Schema.NotMapped]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual Rules.BrokenRulesCollection BrokenRulesCollection
    {
      get { return BusinessRules.GetBrokenRules(); }
    }

#endregion

#region Data Access

    /// <summary>
    /// Override this method to load a new business object with default
    /// values from the database.
    /// </summary>
    /// <remarks>
    /// Normally you will overload this method to accept a strongly-typed
    /// criteria parameter, rather than overriding the method with a
    /// loosely-typed criteria parameter.
    /// </remarks>
    [RunLocal]
    protected virtual void DataPortal_Create()
    {
      BusinessRules.CheckRules();
    }

    /// <summary>
    /// Override this method to allow insertion of a business
    /// object.
    /// </summary>
    protected virtual void DataPortal_Insert()
    { }

    /// <summary>
    /// Override this method to allow update of a business
    /// object.
    /// </summary>
    protected virtual void DataPortal_Update()
    { }

    /// <summary>
    /// Override this method to allow deferred deletion of a business object.
    /// </summary>
    protected virtual void DataPortal_DeleteSelf()
    { }

    /// <summary>
    /// Called by the server-side DataPortal prior to calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void DataPortal_OnDataPortalInvoke(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal after calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void DataPortal_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal if an exception
    /// occurs during data access.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    /// <param name="ex">The Exception thrown during data access.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void DataPortal_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    { }

    /// <summary>
    /// Override this method to load a new business object with default
    /// values from the database.
    /// </summary>
    /// <remarks>
    /// Normally you will overload this method to accept a strongly-typed
    /// criteria parameter, rather than overriding the method with a
    /// loosely-typed criteria parameter.
    /// </remarks>
    protected virtual void Child_Create()
    {
      BusinessRules.CheckRules();
    }

    /// <summary>
    /// Called by the server-side DataPortal prior to calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void Child_OnDataPortalInvoke(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal after calling the 
    /// requested DataPortal_XYZ method.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void Child_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    { }

    /// <summary>
    /// Called by the server-side DataPortal if an exception
    /// occurs during data access.
    /// </summary>
    /// <param name="e">The DataPortalContext object passed to the DataPortal.</param>
    /// <param name="ex">The Exception thrown during data access.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void Child_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    { }

#endregion

#region IDataErrorInfo

    string IDataErrorInfo.Error
    {
      get
      {
        if (!IsSelfValid)
          return BusinessRules.GetBrokenRules().ToString(
            Csla.Rules.RuleSeverity.Error);
        else
          return String.Empty;
      }
    }

    string IDataErrorInfo.this[string columnName]
    {
      get
      {
        string result = string.Empty;
        if (!IsSelfValid)
        {
          Rules.BrokenRule rule =
            BusinessRules.GetBrokenRules().GetFirstBrokenRule(columnName);
          if (rule != null)
            result = rule.Description;
        }
        return result;
      }
    }

#endregion

#region Serialization Notification

    void ISerializationNotification.Deserialized()
    {
      OnDeserializedHandler(new System.Runtime.Serialization.StreamingContext());
    }

    [System.Runtime.Serialization.OnDeserialized]
    private void OnDeserializedHandler(System.Runtime.Serialization.StreamingContext context)
    {
      BusinessRules.SetTarget(this);
      if (_fieldManager != null)
        FieldManager.SetPropertyList(this.GetType());
      InitializeBusinessRules();
      FieldDataDeserialized();

      OnDeserialized(context);
    }

    /// <summary>
    /// This method is called on a newly deserialized object
    /// after deserialization is complete.
    /// </summary>
    /// <param name="context">Serialization context object.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void OnDeserialized(System.Runtime.Serialization.StreamingContext context)
    { }

#endregion

#region Bubbling event Hooks

    /// <summary>
    /// For internal use.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void AddEventHooks(IBusinessObject child)
    {
      OnAddEventHooks(child);
    }

    /// <summary>
    /// Hook child object events.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void OnAddEventHooks(IBusinessObject child)
    {
      if (child is INotifyBusy busy)
        busy.BusyChanged += Child_BusyChanged;

      if (child is INotifyUnhandledAsyncException unhandled)
        unhandled.UnhandledAsyncException += Child_UnhandledAsyncException;

      if (child is INotifyPropertyChanged pc)
        pc.PropertyChanged += Child_PropertyChanged;

      if (child is IBindingList bl)
        bl.ListChanged += Child_ListChanged;

      if (child is INotifyCollectionChanged ncc)
        ncc.CollectionChanged += Child_CollectionChanged;

      if (child is INotifyChildChanged cc)
        cc.ChildChanged += Child_Changed;
    }

    /// <summary>
    /// For internal use only.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void RemoveEventHooks(IBusinessObject child)
    {
      OnRemoveEventHooks(child);
    }

    /// <summary>
    /// Unhook child object events.
    /// </summary>
    /// <param name="child">Child object.</param>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void OnRemoveEventHooks(IBusinessObject child)
    {
      if (child is INotifyBusy busy)
        busy.BusyChanged -= Child_BusyChanged;

      if (child is INotifyUnhandledAsyncException unhandled)
        unhandled.UnhandledAsyncException -= Child_UnhandledAsyncException;

      if (child is INotifyPropertyChanged pc)
        pc.PropertyChanged -= Child_PropertyChanged;

      if (child is IBindingList bl)
        bl.ListChanged -= Child_ListChanged;

      if (child is INotifyCollectionChanged ncc)
        ncc.CollectionChanged -= Child_CollectionChanged;

      if (child is INotifyChildChanged cc)
        cc.ChildChanged -= Child_Changed;
    }

#endregion

#region Busy / Unhandled exception bubbling

    private void Child_UnhandledAsyncException(object sender, ErrorEventArgs e)
    {
      OnUnhandledAsyncException(e);
    }

    private void Child_BusyChanged(object sender, BusyChangedEventArgs e)
    {
      OnBusyChanged(e);
    }

#endregion

#region IEditableBusinessObject Members

    int IEditableBusinessObject.EditLevelAdded
    {
      get
      {
        return this.EditLevelAdded;
      }
      set
      {
        this.EditLevelAdded = value;
      }
    }

    void IEditableBusinessObject.DeleteChild()
    {
      this.DeleteChild();
    }

    void IEditableBusinessObject.SetParent(IParent parent)
    {
      this.SetParent(parent);
    }

#endregion

#region Register Methods

    /// <summary>
    /// Indicates that the specified method belongs
    /// to the type.
    /// </summary>
    /// <param name="objectType">
    /// Type of object to which the method belongs.
    /// </param>
    /// <param name="info">
    /// IMemberInfo object for the property.
    /// </param>
    /// <returns>
    /// The provided IMemberInfo object.
    /// </returns>
    protected static Csla.Core.IMemberInfo RegisterMethod(Type objectType, IMemberInfo info)
    {
      var reflected = objectType.GetMethod(info.Name);
      if (reflected == null)
        throw new ArgumentException(string.Format(Resources.NoSuchMethod, info.Name), "info");
      return info;
    }

    /// <summary>
    /// Indicates that the specified method belongs
    /// to the type.
    /// </summary>
    /// <param name="objectType">
    /// Type of object to which the method belongs.
    /// </param>
    /// <param name="methodName">
    /// Name of the method.
    /// </param>
    /// <returns>
    /// The provided IMemberInfo object.
    /// </returns>
    protected static MethodInfo RegisterMethod(Type objectType, string methodName)
    {
      var info = new MethodInfo(methodName);
      RegisterMethod(objectType, info);
      return info;
    }

#endregion

#region  Register Properties

    /// <summary>
    /// Indicates that the specified property belongs
    /// to the type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of property.
    /// </typeparam>
    /// <param name="objectType">
    /// Type of object to which the property belongs.
    /// </param>
    /// <param name="info">
    /// PropertyInfo object for the property.
    /// </param>
    /// <returns>
    /// The provided IPropertyInfo object.
    /// </returns>
    protected static PropertyInfo<P> RegisterProperty<P>(Type objectType, PropertyInfo<P> info)
    {
      return Core.FieldManager.PropertyInfoManager.RegisterProperty<P>(objectType, info);
    }

#endregion

#region  Get Properties

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="defaultValue">
    /// Value to be returned if the user is not
    /// authorized to read the property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(string propertyName, P field, P defaultValue)
    {
      return GetProperty<P>(propertyName, field, defaultValue, Security.NoAccessBehavior.SuppressException);
    }

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="defaultValue">
    /// Value to be returned if the user is not
    /// authorized to read the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    protected P GetProperty<P>(string propertyName, P field, P defaultValue, Security.NoAccessBehavior noAccess)
    {
#region Check to see if the property is marked with RelationshipTypes.PrivateField

      var propertyInfo = FieldManager.GetRegisteredProperty(propertyName);

      if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) != RelationshipTypes.PrivateField)
        throw new InvalidOperationException(Resources.PrivateFieldException);

#endregion

      if (_bypassPropertyChecks || CanReadProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        return field;

      return defaultValue;
    }

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo, P field)
    {
      return GetProperty<P>(propertyInfo.Name, field, propertyInfo.DefaultValue, Security.NoAccessBehavior.SuppressException);
    }

    /// <summary>
    /// Gets a property's value, first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="defaultValue">
    /// Value to be returned if the user is not
    /// authorized to read the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo, P field, P defaultValue, Security.NoAccessBehavior noAccess)
    {
      return GetProperty<P>(propertyInfo.Name, field, defaultValue, noAccess);
    }

    /// <summary>
    /// Gets a property's value as 
    /// a specified type, first checking authorization.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo, F field)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo.Name, field, propertyInfo.DefaultValue, Security.NoAccessBehavior.SuppressException));
    }

    /// <summary>
    /// Gets a property's value as a specified type, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="field">
    /// The backing field for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo, F field, Security.NoAccessBehavior noAccess)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo.Name, field, propertyInfo.DefaultValue, noAccess));
    }

    /// <summary>
    /// Gets a property's managed field value, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo)
    {
      return GetProperty<P>(propertyInfo, Security.NoAccessBehavior.SuppressException);
    }

    /// <summary>
    /// Gets a property's value from the list of 
    /// managed field values, first checking authorization,
    /// and converting the value to an appropriate type.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo, Security.NoAccessBehavior.SuppressException));
    }

    /// <summary>
    /// Gets a property's value from the list of 
    /// managed field values, first checking authorization,
    /// and converting the value to an appropriate type.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetPropertyConvert<F, P>(PropertyInfo<F> propertyInfo, Security.NoAccessBehavior noAccess)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, GetProperty<F>(propertyInfo, noAccess));
    }

    /// <summary>
    /// Gets a property's value as a specified type, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to read this property.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(PropertyInfo<P> propertyInfo, Security.NoAccessBehavior noAccess)
    {
      P result = default(P);
      if (_bypassPropertyChecks || CanReadProperty(propertyInfo, noAccess == Csla.Security.NoAccessBehavior.ThrowException))
        result = ReadProperty<P>(propertyInfo);
      else
        result = propertyInfo.DefaultValue;
      return result;
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected object GetProperty(IPropertyInfo propertyInfo)
    {
      object result = null;
      if (_bypassPropertyChecks || CanReadProperty(propertyInfo, false))
      {
        // call ReadProperty (may be overloaded in actual class)
        result = ReadProperty(propertyInfo);
      }
      else
      {
        result = propertyInfo.DefaultValue;
      }
      return result;
    }

    /// <summary>
    /// Gets a property's managed field value, 
    /// first checking authorization.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P GetProperty<P>(IPropertyInfo propertyInfo)
    {
      return (P)GetProperty(propertyInfo);
    }

    /// <summary>
    /// Lazily initializes a property and returns
    /// the resulting value.
    /// </summary>
    /// <typeparam name="P">Type of the property.</typeparam>
    /// <param name="property">PropertyInfo object containing property metadata.</param>
    /// <param name="valueGenerator">Method returning the new value.</param>
    /// <returns></returns>
    /// <remarks>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </remarks>
    protected P LazyGetProperty<P>(PropertyInfo<P> property, Func<P> valueGenerator)
    {
      if (!(FieldManager.FieldExists(property)))
      {
        var result = valueGenerator();
        LoadProperty(property, result);
      }
      return GetProperty<P>(property);
    }

    [NotUndoable]
    [NonSerialized]
    private List<Csla.Core.IPropertyInfo> _lazyLoadingProperties = new List<Csla.Core.IPropertyInfo>();

    /// <summary>
    /// Lazily initializes a property and returns
    /// the resulting value.
    /// </summary>
    /// <typeparam name="P">Type of the property.</typeparam>
    /// <param name="property">PropertyInfo object containing property metadata.</param>
    /// <param name="factory">Async method returning the new value.</param>
    /// <returns></returns>
    /// <remarks>
    /// <para>
    /// Note that the first value returned is almost certainly
    /// the defaultValue because the value is initialized asynchronously.
    /// The real value is provided later along with a PropertyChanged
    /// event to indicate the value has changed.
    /// </para><para>
    /// If the user is not authorized to read the property
    /// value, the defaultValue value is returned as a
    /// result.
    /// </para>
    /// </remarks>
    protected P LazyGetPropertyAsync<P>(PropertyInfo<P> property, Task<P> factory)
    {
      if (!(FieldManager.FieldExists(property)) && !_lazyLoadingProperties.Contains(property))
      {
        _lazyLoadingProperties.Add(property);
        LoadPropertyAsync(property, factory);
      }
      return GetProperty<P>(property);
    }

    object IManageProperties.LazyGetProperty<P>(PropertyInfo<P> propertyInfo, Func<P> valueGenerator)
    {
      return LazyGetProperty(propertyInfo, valueGenerator);
    }

    object IManageProperties.LazyGetPropertyAsync<P>(PropertyInfo<P> propertyInfo, Task<P> factory)
    {
      return LazyGetPropertyAsync(propertyInfo, factory);
    }

#endregion

#region  Read Properties

    /// <summary>
    /// Gets a property's value from the list of 
    /// managed field values, converting the 
    /// value to an appropriate type.
    /// </summary>
    /// <typeparam name="F">
    /// Type of the field.
    /// </typeparam>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    protected P ReadPropertyConvert<F, P>(PropertyInfo<F> propertyInfo)
    {
      return Utilities.CoerceValue<P>(typeof(F), null, ReadProperty<F>(propertyInfo));
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    protected P ReadProperty<P>(PropertyInfo<P> propertyInfo)
    {
      if (((propertyInfo.RelationshipType & RelationshipTypes.LazyLoad) == RelationshipTypes.LazyLoad) && !FieldManager.FieldExists(propertyInfo))
        throw new InvalidOperationException(Resources.PropertyGetNotAllowed);

      P result = default(P);
      FieldManager.IFieldData data = FieldManager.GetFieldData(propertyInfo);
      if (data != null)
      {
        if (data is FieldManager.IFieldData<P> fd)
          result = fd.Value;
        else
          result = (P)data.Value;
      }
      else
      {
        result = propertyInfo.DefaultValue;
        FieldManager.LoadFieldData<P>(propertyInfo, result);
      }
      return result;
    }

    /// <summary>
    /// Gets a property's value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    protected virtual object ReadProperty(IPropertyInfo propertyInfo)
    {
      if (((propertyInfo.RelationshipType & RelationshipTypes.LazyLoad) == RelationshipTypes.LazyLoad) && !FieldManager.FieldExists(propertyInfo))
        throw new InvalidOperationException(Resources.PropertyGetNotAllowed);

      if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) == RelationshipTypes.PrivateField)
      {
        using (BypassPropertyChecks)
        {
          return MethodCaller.CallPropertyGetter(this, propertyInfo.Name);
        }
      }

      object result = null;
      var info = FieldManager.GetFieldData(propertyInfo);
      if (info != null)
      {
        result = info.Value;
      }
      else
      {
        result = propertyInfo.DefaultValue;
        FieldManager.LoadFieldData(propertyInfo, result);
      }

      return result;
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="property">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="valueGenerator">Method returning the new value.</param>
    protected P LazyReadProperty<P>(PropertyInfo<P> property, Func<P> valueGenerator)
    {
      if (!(FieldManager.FieldExists(property)))
      {
        var result = valueGenerator();
        LoadProperty(property, result);
      }
      return ReadProperty<P>(property);
    }

    /// <summary>
    /// Gets a property's value as a specified type.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="property">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="factory">Async method returning the new value.</param>
    protected P LazyReadPropertyAsync<P>(PropertyInfo<P> property, Task<P> factory)
    {
      if (!(FieldManager.FieldExists(property)) && !_lazyLoadingProperties.Contains(property))
      {
        _lazyLoadingProperties.Add(property);
        LoadPropertyAsync(property, factory);
      }
      return ReadProperty<P>(property);
    }

    P IManageProperties.LazyReadProperty<P>(PropertyInfo<P> propertyInfo, Func<P> valueGenerator)
    {
      return LazyReadProperty(propertyInfo, valueGenerator);
    }

    P IManageProperties.LazyReadPropertyAsync<P>(PropertyInfo<P> propertyInfo, Task<P> factory)
    {
      return LazyReadPropertyAsync(propertyInfo, factory);
    }

#endregion

#region  Set Properties

    /// <summary>
    /// Sets a property's backing field with the supplied
    /// value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetProperty<P>(PropertyInfo<P> propertyInfo, ref P field, P newValue)
    {
      SetProperty<P>(propertyInfo.Name, ref field, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's backing field with the supplied
    /// value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetProperty<P>(string propertyName, ref P field, P newValue)
    {
      SetProperty<P>(propertyName, ref field, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's backing field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the field being set.
    /// </typeparam>
    /// <typeparam name="V">
    /// Type of the value provided to the field.
    /// </typeparam>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetPropertyConvert<P, V>(PropertyInfo<P> propertyInfo, ref P field, V newValue)
    {
      SetPropertyConvert<P, V>(propertyInfo, ref field, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's backing field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the field being set.
    /// </typeparam>
    /// <typeparam name="V">
    /// Type of the value provided to the field.
    /// </typeparam>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    /// <remarks>
    /// If the field value is of type string, any incoming
    /// null values are converted to string.Empty.
    /// </remarks>
    protected void SetPropertyConvert<P, V>(PropertyInfo<P> propertyInfo, ref P field, V newValue, Security.NoAccessBehavior noAccess)
    {
      SetPropertyConvert<P, V>(propertyInfo.Name, ref field, newValue, noAccess);
    }

    /// <summary>
    /// Sets a property's backing field with the supplied
    /// value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    protected void SetProperty<P>(string propertyName, ref P field, P newValue, Security.NoAccessBehavior noAccess)
    {
      try
      {
#region Check to see if the property is marked with RelationshipTypes.PrivateField

        var propertyInfo = FieldManager.GetRegisteredProperty(propertyName);

        if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) != RelationshipTypes.PrivateField)
          throw new InvalidOperationException(Resources.PrivateFieldException);

#endregion

        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        {
          bool doChange = false;
          if (field == null)
          {
            if (newValue != null)
              doChange = true;
          }
          else
          {
            if (typeof(P) == typeof(string) && newValue == null)
              newValue = Utilities.CoerceValue<P>(typeof(string), field, string.Empty);
            if (!field.Equals(newValue))
              doChange = true;
          }
          if (doChange)
          {
            if (!_bypassPropertyChecks) OnPropertyChanging(propertyName);
            field = newValue;
            if (!_bypassPropertyChecks) PropertyHasChanged(propertyName);
          }
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Resources.PropertyLoadException, propertyName, ex.Message, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's backing field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the field being set.
    /// </typeparam>
    /// <typeparam name="V">
    /// Type of the value provided to the field.
    /// </typeparam>
    /// <param name="field">
    /// A reference to the backing field for the property.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="propertyName">
    /// The name of the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    /// <remarks>
    /// If the field value is of type string, any incoming
    /// null values are converted to string.Empty.
    /// </remarks>
    protected void SetPropertyConvert<P, V>(string propertyName, ref P field, V newValue, Security.NoAccessBehavior noAccess)
    {
      try
      {
#region Check to see if the property is marked with RelationshipTypes.PrivateField

        var propertyInfo = FieldManager.GetRegisteredProperty(propertyName);

        if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) != RelationshipTypes.PrivateField)
          throw new InvalidOperationException(Resources.PrivateFieldException);

#endregion

        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        {
          bool doChange = false;
          if (field == null)
          {
            if (newValue != null)
              doChange = true;
          }
          else
          {
            if (typeof(V) == typeof(string) && newValue == null)
              newValue = Utilities.CoerceValue<V>(typeof(string), null, string.Empty);
            if (!field.Equals(newValue))
              doChange = true;
          }
          if (doChange)
          {
            if (!_bypassPropertyChecks) OnPropertyChanging(propertyName);
            field = Utilities.CoerceValue<P>(typeof(V), field, newValue);
            if (!_bypassPropertyChecks) PropertyHasChanged(propertyName);
          }
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyName, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">Property type.</typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetProperty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      SetProperty<P>(propertyInfo, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the property, this
    /// overload throws a SecurityException.
    /// </remarks>
    protected void SetPropertyConvert<P, F>(PropertyInfo<P> propertyInfo, F newValue)
    {
      SetPropertyConvert<P, F>(propertyInfo, newValue, Security.NoAccessBehavior.ThrowException);
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    protected void SetPropertyConvert<P, F>(PropertyInfo<P> propertyInfo, F newValue, Security.NoAccessBehavior noAccess)
    {
      try
      {
        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
        {
          P oldValue = default(P);
          var fieldData = FieldManager.GetFieldData(propertyInfo);
          if (fieldData == null)
          {
            oldValue = propertyInfo.DefaultValue;
            fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
          }
          else
          {
            if (fieldData is FieldManager.IFieldData<P> fd)
              oldValue = fd.Value;
            else
              oldValue = (P)fieldData.Value;
          }
          if (typeof(F) == typeof(string) && newValue == null)
            newValue = Utilities.CoerceValue<F>(typeof(string), null, string.Empty);
          LoadPropertyValue<P>(propertyInfo, oldValue, Utilities.CoerceValue<P>(typeof(F), oldValue, newValue), !_bypassPropertyChecks);
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, first checking authorization, and then
    /// calling PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <param name="noAccess">
    /// True if an exception should be thrown when the
    /// user is not authorized to change this property.</param>
    protected void SetProperty<P>(PropertyInfo<P> propertyInfo, P newValue, Security.NoAccessBehavior noAccess)
    {
      if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, noAccess == Security.NoAccessBehavior.ThrowException))
      {
        try
        {
          P oldValue = default(P);
          var fieldData = FieldManager.GetFieldData(propertyInfo);
          if (fieldData == null)
          {
            oldValue = propertyInfo.DefaultValue;
            fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
          }
          else
          {
            if (fieldData is FieldManager.IFieldData<P> fd)
              oldValue = fd.Value;
            else
              oldValue = (P)fieldData.Value;
          }
          if (typeof(P) == typeof(string) && newValue == null)
            newValue = Utilities.CoerceValue<P>(typeof(string), null, string.Empty);
          LoadPropertyValue<P>(propertyInfo, oldValue, newValue, !_bypassPropertyChecks);
        }
        catch (Exception ex)
        {
          throw new PropertyLoadException(
            string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
        }
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, and then
    /// calls PropertyHasChanged if the value does change.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the 
    /// property a SecurityException is thrown.
    /// </remarks>
    protected void SetProperty(IPropertyInfo propertyInfo, object newValue)
    {
      try
      {
        if (_bypassPropertyChecks || CanWriteProperty(propertyInfo, true))
        {
          if (!_bypassPropertyChecks) OnPropertyChanging(propertyInfo);
          FieldManager.SetFieldData(propertyInfo, newValue);
          if (!_bypassPropertyChecks) PropertyHasChanged(propertyInfo);
        }
      }
      catch (System.Security.SecurityException ex)
      {
        throw new Csla.Security.SecurityException(ex.Message);
      }
      catch (Csla.Security.SecurityException)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Sets a property's managed field with the 
    /// supplied value, and then
    /// calls PropertyHasChanged if the value does change.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// If the user is not authorized to change the 
    /// property a SecurityException is thrown.
    /// </remarks>
    protected void SetProperty<P>(IPropertyInfo propertyInfo, P newValue)
    {
      SetProperty(propertyInfo, (object)newValue);
    }

#endregion

#region  Load Properties

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected void LoadPropertyConvert<P, F>(PropertyInfo<P> propertyInfo, F newValue)
    {
      try
      {
        P oldValue = default(P);
        var fieldData = FieldManager.GetFieldData(propertyInfo);
        if (fieldData == null)
        {
          oldValue = propertyInfo.DefaultValue;
          fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
        }
        else
        {
          if (fieldData is FieldManager.IFieldData<P> fd)
            oldValue = fd.Value;
          else
            oldValue = (P)fieldData.Value;
        }
        LoadPropertyValue<P>(propertyInfo, oldValue, Utilities.CoerceValue<P>(typeof(F), oldValue, newValue), false);
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    void Core.IManageProperties.LoadProperty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      LoadProperty<P>(propertyInfo, newValue);
    }

    bool Core.IManageProperties.FieldExists(Core.IPropertyInfo property)
    {
      return FieldManager.FieldExists(property);
    }

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected void LoadProperty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      try
      {
        P oldValue = default(P);
        var fieldData = FieldManager.GetFieldData(propertyInfo);
        if (fieldData == null)
        {
          oldValue = propertyInfo.DefaultValue;
          fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
        }
        else
        {
          if (fieldData is FieldManager.IFieldData<P> fd)
            oldValue = fd.Value;
          else
            oldValue = (P)fieldData.Value;
        }
        LoadPropertyValue<P>(propertyInfo, oldValue, newValue, false);
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(
          string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value and mark field as dirty if value is modified.
    /// </summary> 
    /// <typeparam name="P">
    /// Type of the property.
    /// </typeparam>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected bool LoadPropertyMarkDirty<P>(PropertyInfo<P> propertyInfo, P newValue)
    {
      try
      {
        P oldValue = default(P);
        var fieldData = FieldManager.GetFieldData(propertyInfo);
        if (fieldData == null)
        {
          oldValue = propertyInfo.DefaultValue;
          fieldData = FieldManager.LoadFieldData<P>(propertyInfo, oldValue);
        }
        else
        {
          if (fieldData is FieldManager.IFieldData<P> fd)
            oldValue = fd.Value;
          else
            oldValue = (P)fieldData.Value;
        }

        var valuesDiffer = ValuesDiffer(propertyInfo, newValue, oldValue);
        if (valuesDiffer)
        {
          if (oldValue is IBusinessObject old)
            RemoveEventHooks(old);

          if (newValue is IBusinessObject @new)
            AddEventHooks(@new);

          if (typeof(IEditableBusinessObject).IsAssignableFrom(propertyInfo.Type))
          {
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            ResetChildEditLevel(newValue);
          }
          else if (typeof(IEditableCollection).IsAssignableFrom(propertyInfo.Type))
          {
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            ResetChildEditLevel(newValue);
          }
          else
          {
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
          }
        }
        return valuesDiffer;
      }
      catch (Exception ex)
      {
        throw new PropertyLoadException(string.Format(Properties.Resources.PropertyLoadException, propertyInfo.Name, ex.Message), ex);
      }
    }

    /// <summary>
    /// Check if old and new values are different.
    /// </summary>
    /// <typeparam name="P"></typeparam>
    /// <param name="propertyInfo">The property info.</param>
    /// <param name="newValue">The new value.</param>
    /// <param name="oldValue">The old value.</param>
    /// <returns></returns>
    private static bool ValuesDiffer<P>(PropertyInfo<P> propertyInfo, P newValue, P oldValue)
    {
      var valuesDiffer = false;
      if (oldValue == null)
        valuesDiffer = newValue != null;
      else
      {
        // use reference equals for objects that inherit from CSLA base class
        if (typeof (IBusinessObject).IsAssignableFrom(propertyInfo.Type))
        {
          valuesDiffer = !(ReferenceEquals(oldValue, newValue));
        }
        else
        {
          valuesDiffer = !(oldValue.Equals(newValue));
        }
      }
      return valuesDiffer;
    }

    private void LoadPropertyValue<P>(PropertyInfo<P> propertyInfo, P oldValue, P newValue, bool markDirty)
    {
      var valuesDiffer = ValuesDiffer(propertyInfo, newValue, oldValue);

      if (valuesDiffer)
      {
        if (oldValue is IBusinessObject old)
          RemoveEventHooks(old);

        if (newValue is IBusinessObject @new)
          AddEventHooks(@new);


        if (typeof(IEditableBusinessObject).IsAssignableFrom(propertyInfo.Type))
        {
          if (markDirty)
          {
            OnPropertyChanging(propertyInfo);
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            PropertyHasChanged(propertyInfo);
          }
          else
          {
            FieldManager.LoadFieldData<P>(propertyInfo, newValue);
          }
          ResetChildEditLevel(newValue);
        }
        else if (typeof(IEditableCollection).IsAssignableFrom(propertyInfo.Type))
        {
          if (markDirty)
          {
            OnPropertyChanging(propertyInfo);
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            PropertyHasChanged(propertyInfo);
          }
          else
          {
            FieldManager.LoadFieldData<P>(propertyInfo, newValue);
          }
          ResetChildEditLevel(newValue);
        }
        else
        {
          if (markDirty)
          {
            OnPropertyChanging(propertyInfo);
            FieldManager.SetFieldData<P>(propertyInfo, newValue);
            PropertyHasChanged(propertyInfo);
          }
          else
          {
            FieldManager.LoadFieldData<P>(propertyInfo, newValue);
          }
        }
      }
    }

    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected virtual bool LoadPropertyMarkDirty(IPropertyInfo propertyInfo, object newValue)
    {
      // private field 
      if ((propertyInfo.RelationshipType & RelationshipTypes.PrivateField) == RelationshipTypes.PrivateField)
      {
        LoadProperty(propertyInfo, newValue);
        return false;
      }

#if IOS
      //manually call LoadProperty<T> if the type is nullable otherwise JIT error will occur
      if (propertyInfo.Type == typeof(int?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<int?>)propertyInfo, (int?)newValue);
      }
      else if (propertyInfo.Type == typeof(bool?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<bool?>)propertyInfo, (bool?)newValue);
      }
      else if (propertyInfo.Type == typeof(DateTime?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<DateTime?>)propertyInfo, (DateTime?)newValue);
      }
      else if (propertyInfo.Type == typeof(decimal?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<decimal?>)propertyInfo, (decimal?)newValue);
      }
      else if (propertyInfo.Type == typeof(double?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<double?>)propertyInfo, (double?)newValue);
      }
      else if (propertyInfo.Type == typeof(long?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<long?>)propertyInfo, (long?)newValue);
      }
      else if (propertyInfo.Type == typeof(byte?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<byte?>)propertyInfo, (byte?)newValue);
      }
      else if (propertyInfo.Type == typeof(char?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<char?>)propertyInfo, (char?)newValue);
      }
      else if (propertyInfo.Type == typeof(short?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<short?>)propertyInfo, (short?)newValue);
      }
      else if (propertyInfo.Type == typeof(uint?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<uint?>)propertyInfo, (uint?)newValue);
      }
      else if (propertyInfo.Type == typeof(ulong?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<ulong?>)propertyInfo, (ulong?)newValue);
      }
      else if (propertyInfo.Type == typeof(ushort?))
      {
        return LoadPropertyMarkDirty((PropertyInfo<ushort?>)propertyInfo, (ushort?)newValue);
      }
      else
      {
        return (bool)LoadPropertyByReflection("LoadPropertyMarkDirty", propertyInfo, newValue);
      }
#else
      return (bool)LoadPropertyByReflection("LoadPropertyMarkDirty", propertyInfo, newValue);
#endif
    }


    /// <summary>
    /// Loads a property's managed field with the 
    /// supplied value.
    /// </summary>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <remarks>
    /// No authorization checks occur when this method is called,
    /// and no PropertyChanging or PropertyChanged events are raised.
    /// Loading values does not cause validation rules to be
    /// invoked.
    /// </remarks>
    protected virtual void LoadProperty(IPropertyInfo propertyInfo, object newValue)
    {
#if IOS
      //manually call LoadProperty<T> if the type is nullable otherwise JIT error will occur
      if (propertyInfo.Type == typeof(int?))
      {
        LoadProperty((PropertyInfo<int?>)propertyInfo, (int?)newValue);
      }
      else if (propertyInfo.Type == typeof(bool?))
      {
        LoadProperty((PropertyInfo<bool?>)propertyInfo, (bool?)newValue);
      }
      else if (propertyInfo.Type == typeof(DateTime?))
      {
        LoadProperty((PropertyInfo<DateTime?>)propertyInfo, (DateTime?)newValue);
      }
      else if (propertyInfo.Type == typeof(decimal?))
      {
        LoadProperty((PropertyInfo<decimal?>)propertyInfo, (decimal?)newValue);
      }
      else if (propertyInfo.Type == typeof(double?))
      {
        LoadProperty((PropertyInfo<double?>)propertyInfo, (double?)newValue);
      }
      else if (propertyInfo.Type == typeof(long?))
      {
        LoadProperty((PropertyInfo<long?>)propertyInfo, (long?)newValue);
      }
      else if (propertyInfo.Type == typeof(byte?))
      {
        LoadProperty((PropertyInfo<byte?>)propertyInfo, (byte?)newValue);
      }
      else if (propertyInfo.Type == typeof(char?))
      {
        LoadProperty((PropertyInfo<char?>)propertyInfo, (char?)newValue);
      }
      else if (propertyInfo.Type == typeof(short?))
      {
        LoadProperty((PropertyInfo<short?>)propertyInfo, (short?)newValue);
      }
      else if (propertyInfo.Type == typeof(uint?))
      {
        LoadProperty((PropertyInfo<uint?>)propertyInfo, (uint?)newValue);
      }
      else if (propertyInfo.Type == typeof(ulong?))
      {
        LoadProperty((PropertyInfo<ulong?>)propertyInfo, (ulong?)newValue);
      }
      else if (propertyInfo.Type == typeof(ushort?))
      {
        LoadProperty((PropertyInfo<ushort?>)propertyInfo, (ushort?)newValue);
      }
      else
      {
        LoadPropertyByReflection("LoadProperty", propertyInfo, newValue);
      }
#else
      LoadPropertyByReflection("LoadProperty", propertyInfo, newValue);
#endif
    }

    /// <summary>
    /// Calls the generic LoadProperty method via reflection.
    /// </summary>
    /// <param name="loadPropertyMethodName">
    /// The LoadProperty method name to call via reflection.</param>
    /// <param name="propertyInfo">
    /// PropertyInfo object containing property metadata.</param>
    /// <param name="newValue">
    /// The new value for the property.</param>
    /// <returns></returns>
    private object LoadPropertyByReflection(string loadPropertyMethodName, IPropertyInfo propertyInfo, object newValue)
    {
      var t = this.GetType();
      var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
      var method = t.GetMethods(flags).FirstOrDefault(c => c.Name == loadPropertyMethodName && c.IsGenericMethod);
      var gm = method.MakeGenericMethod(propertyInfo.Type);
      var p = new object[] { propertyInfo, newValue };
      return gm.Invoke(this, p);
    }

    /// <summary>
    /// Makes sure that a child object is set up properly
    /// to be a child of this object.
    /// </summary>
    /// <param name="newValue">Potential child object</param>
    private void ResetChildEditLevel(object newValue)
    {
      if (newValue is IEditableBusinessObject child)
      {
        child.SetParent(this);
        // set child edit level
        UndoableBase.ResetChildEditLevel(child, this.EditLevel, this.BindingEdit);
        // reset EditLevelAdded 
        child.EditLevelAdded = this.EditLevel;
      }
      else
      {
        if (newValue is IEditableCollection col)
        {
          col.SetParent(this);

          if (col is IUndoableObject undo)
          {
            // set child edit level
            UndoableBase.ResetChildEditLevel(undo, this.EditLevel, this.BindingEdit);
          }
        }
      }
    }

    //private AsyncLoadManager
    [NonSerialized]
    [NotUndoable]
    private AsyncLoadManager _loadManager;
    internal AsyncLoadManager LoadManager
    {
      get
      {
        if (_loadManager == null)
        {
          _loadManager = new AsyncLoadManager(this, OnPropertyChanged);
          _loadManager.BusyChanged += loadManager_BusyChanged;
          _loadManager.UnhandledAsyncException += loadManager_UnhandledAsyncException;
        }
        return _loadManager;
      }
    }

    private void loadManager_UnhandledAsyncException(object sender, ErrorEventArgs e)
    {
      OnUnhandledAsyncException(e);
    }

    private void loadManager_BusyChanged(object sender, BusyChangedEventArgs e)
    {
      OnBusyChanged(e);
    }

    /// <summary>
    /// Load a property from an async method. 
    /// </summary>
    /// <typeparam name="R"></typeparam>
    /// <param name="property"></param>
    /// <param name="factory"></param>
    protected void LoadPropertyAsync<R>(PropertyInfo<R> property, Task<R> factory)
    {
      LoadManager.BeginLoad(new TaskLoader<R>(property, factory));
    }

#endregion

#region IsBusy / IsIdle

    [NonSerialized]
    [NotUndoable]
    private bool _isBusy;

    /// <summary>
    /// Mark the object as busy (it is
    /// running an async operation).
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkBusy()
    {
      if (_isBusy)
        throw new InvalidOperationException(Resources.BusyObjectsMayNotBeMarkedBusy);

      _isBusy = true;
      OnBusyChanged(new BusyChangedEventArgs("", true));
    }

    /// <summary>
    /// Mark the object as not busy (it is
    /// not running an async operation).
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void MarkIdle()
    {
      _isBusy = false;
      OnBusyChanged(new BusyChangedEventArgs("", false));
    }

    /// <summary>
    /// Gets a value indicating if this
    /// object or its child objects are
    /// busy.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsBusy
    {
      get { return IsSelfBusy || (_fieldManager != null && FieldManager.IsBusy()); }
    }

    /// <summary>
    /// Gets a value indicating if this
    /// object is busy.
    /// </summary>
    [Browsable(false)]
    [Display(AutoGenerateField = false)]
    [ScaffoldColumn(false)]
    public virtual bool IsSelfBusy
    {
      get { return _isBusy || BusinessRules.RunningAsyncRules || LoadManager.IsLoading; }
    }

    [NotUndoable]
    [NonSerialized]
    private BusyChangedEventHandler _busyChanged;

    /// <summary>
    /// Event indicating that the IsBusy property has changed.
    /// </summary>
    public event BusyChangedEventHandler BusyChanged
    {
      add { _busyChanged = (BusyChangedEventHandler)Delegate.Combine(_busyChanged, value); }
      remove { _busyChanged = (BusyChangedEventHandler)Delegate.Remove(_busyChanged, value); }
    }

    /// <summary>
    /// Raise the BusyChanged event.
    /// </summary>
    /// <param name="args">Event args.</param>
    protected virtual void OnBusyChanged(BusyChangedEventArgs args)
    {
      if (_busyChanged != null)
        _busyChanged(this, args);
      MetaPropertyHasChanged("IsSelfBusy");
      MetaPropertyHasChanged("IsBusy");
    }

    /// <summary>
    /// Gets a value indicating whether a
    /// specific property is busy (has a
    /// currently executing async rule).
    /// </summary>
    /// <param name="property">
    /// Property to check.
    /// </param>
    public virtual bool IsPropertyBusy(Csla.Core.IPropertyInfo property)
    {
      return BusinessRules.GetPropertyBusy(property);
    }

    /// <summary>
    /// Gets a value indicating whether a
    /// specific property is busy (has a
    /// currently executing async rule).
    /// </summary>
    /// <param name="propertyName">
    /// Name of the property.
    /// </param>
    public bool IsPropertyBusy(string propertyName)
    {
      return IsPropertyBusy(FieldManager.GetRegisteredProperty(propertyName));
    }

#endregion

#region INotifyUnhandledAsyncException Members

    [NotUndoable]
    [NonSerialized]
    private EventHandler<ErrorEventArgs> _unhandledAsyncException;

    /// <summary>
    /// Event indicating that an exception occurred during
    /// the processing of an async operation.
    /// </summary>
    public event EventHandler<ErrorEventArgs> UnhandledAsyncException
    {
      add { _unhandledAsyncException = (EventHandler<ErrorEventArgs>)Delegate.Combine(_unhandledAsyncException, value); }
      remove { _unhandledAsyncException = (EventHandler<ErrorEventArgs>)Delegate.Remove(_unhandledAsyncException, value); }
    }

    /// <summary>
    /// Raises the UnhandledAsyncException event.
    /// </summary>
    /// <param name="error">Args parameter.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void OnUnhandledAsyncException(ErrorEventArgs error)
    {
      if (_unhandledAsyncException != null)
        _unhandledAsyncException(this, error);
    }

    /// <summary>
    /// Raises the UnhandledAsyncException event.
    /// </summary>
    /// <param name="originalSender">Original sender of
    /// the event.</param>
    /// <param name="error">Exception object.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected void OnUnhandledAsyncException(object originalSender, Exception error)
    {
      OnUnhandledAsyncException(new ErrorEventArgs(originalSender, error));
    }

#endregion

#region Child Change Notification

    [NonSerialized]
    [NotUndoable]
    private EventHandler<Csla.Core.ChildChangedEventArgs> _childChangedHandlers;

    /// <summary>
    /// Event raised when a child object has been changed.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design",
      "CA1062:ValidateArgumentsOfPublicMethods")]
    public event EventHandler<Csla.Core.ChildChangedEventArgs> ChildChanged
    {
      add
      {
        _childChangedHandlers = (EventHandler<Csla.Core.ChildChangedEventArgs>)
          System.Delegate.Combine(_childChangedHandlers, value);
      }
      remove
      {
        _childChangedHandlers = (EventHandler<Csla.Core.ChildChangedEventArgs>)
          System.Delegate.Remove(_childChangedHandlers, value);
      }
    }

    /// <summary>
    /// Raises the ChildChanged event, indicating that a child
    /// object has been changed.
    /// </summary>
    /// <param name="e">
    /// ChildChangedEventArgs object.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void OnChildChanged(ChildChangedEventArgs e)
    {
      if (_childChangedHandlers != null)
        _childChangedHandlers.Invoke(this, e);
      MetaPropertyHasChanged("IsDirty");
      MetaPropertyHasChanged("IsValid");
      MetaPropertyHasChanged("IsSavable");
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(ChildChangedEventArgs e)
    {
      OnChildChanged(e);
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(
      object childObject, PropertyChangedEventArgs propertyArgs)
    {
      ChildChangedEventArgs args = new ChildChangedEventArgs(childObject, propertyArgs);
      OnChildChanged(args);
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(
      object childObject, PropertyChangedEventArgs propertyArgs, ListChangedEventArgs listArgs)
    {
      ChildChangedEventArgs args = new ChildChangedEventArgs(childObject, propertyArgs, listArgs);
      OnChildChanged(args);
    }

    /// <summary>
    /// Creates a ChildChangedEventArgs and raises the event.
    /// </summary>
    private void RaiseChildChanged(
      object childObject, PropertyChangedEventArgs propertyArgs, NotifyCollectionChangedEventArgs listArgs)
    {
      ChildChangedEventArgs args = new ChildChangedEventArgs(childObject, propertyArgs, listArgs);
      OnChildChanged(args);
    }

    /// <summary>
    /// Handles any PropertyChanged event from 
    /// a child object and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      // Issue 813
      // MetaPropertyHasChanged calls in OnChildChanged we're leading to exponential growth in OnChildChanged calls
      // Those notifications are for the UI. Ignore them here
      if (!(e is MetaPropertyChangedEventArgs))
      {
        RaiseChildChanged(sender, e);
      }
    }

    /// <summary>
    /// Handles any ListChanged event from 
    /// a child list and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_ListChanged(object sender, ListChangedEventArgs e)
    {
      if (e.ListChangedType != ListChangedType.ItemChanged)
        RaiseChildChanged(sender, null, e);
    }

    /// <summary>
    /// Handles any CollectionChanged event
    /// from a child list and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
      RaiseChildChanged(sender, null, e);
    }

    /// <summary>
    /// Handles any ChildChanged event from
    /// a child object and echoes it up as
    /// a ChildChanged event.
    /// </summary>
    private void Child_Changed(object sender, ChildChangedEventArgs e)
    {
      RaiseChildChanged(e);
    }

#endregion

#region  Field Manager

    private FieldManager.FieldDataManager _fieldManager;

    /// <summary>
    /// Gets the PropertyManager object for this
    /// business object.
    /// </summary>
    protected FieldDataManager FieldManager
    {
      get
      {
        if (_fieldManager == null)
        {
          _fieldManager = new FieldDataManager(this.GetType());
          UndoableBase.ResetChildEditLevel(_fieldManager, this.EditLevel, this.BindingEdit);
        }
        return _fieldManager;
      }
    }

    private void FieldDataDeserialized()
    {
      foreach (object item in FieldManager.GetChildren())
      {
        if (item is IBusinessObject business)
          OnAddEventHooks(business);

        if (item is IEditableBusinessObject child)
        {
          child.SetParent(this);
        }
        if (item is IEditableCollection childCollection)
        {
          childCollection.SetParent(this);
        }
      }
    }

#endregion

#region  IParent

    /// <summary>
    /// Override this method to be notified when a child object's
    /// <see cref="Core.BusinessBase.ApplyEdit" /> method has
    /// completed.
    /// </summary>
    /// <param name="child">The child object that was edited.</param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void EditChildComplete(Core.IEditableBusinessObject child)
    {
      // do nothing, we don't really care
      // when a child has its edits applied
    }

    void IParent.ApplyEditChild(Core.IEditableBusinessObject child)
    {
      this.EditChildComplete(child);
    }

    void IParent.RemoveChild(IEditableBusinessObject child)
    {
      var info = FieldManager.FindProperty(child);
      FieldManager.RemoveField(info);
    }

    IParent Csla.Core.IParent.Parent
    {
      get { return this.Parent; }
    }

#endregion

#region IDataPortalTarget Members

    void Csla.Server.IDataPortalTarget.CheckRules()
    {
      BusinessRules.CheckRules();
    }

    void Csla.Server.IDataPortalTarget.MarkAsChild()
    {
      this.MarkAsChild();
    }

    void Csla.Server.IDataPortalTarget.MarkNew()
    {
      this.MarkNew();
    }

    void Csla.Server.IDataPortalTarget.MarkOld()
    {
      this.MarkOld();
    }

    void Csla.Server.IDataPortalTarget.DataPortal_OnDataPortalInvoke(DataPortalEventArgs e)
    {
      this.DataPortal_OnDataPortalInvoke(e);
    }

    void Csla.Server.IDataPortalTarget.DataPortal_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    {
      this.DataPortal_OnDataPortalInvokeComplete(e);
    }

    void Csla.Server.IDataPortalTarget.DataPortal_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    {
      this.DataPortal_OnDataPortalException(e, ex);
    }

    void Csla.Server.IDataPortalTarget.Child_OnDataPortalInvoke(DataPortalEventArgs e)
    {
      this.Child_OnDataPortalInvoke(e);
    }

    void Csla.Server.IDataPortalTarget.Child_OnDataPortalInvokeComplete(DataPortalEventArgs e)
    {
      this.Child_OnDataPortalInvokeComplete(e);
    }

    void Csla.Server.IDataPortalTarget.Child_OnDataPortalException(DataPortalEventArgs e, Exception ex)
    {
      this.Child_OnDataPortalException(e, ex);
    }

#endregion

#region IManageProperties Members

    bool IManageProperties.HasManagedProperties
    {
      get { return (_fieldManager != null && _fieldManager.HasFields); }
    }

    List<IPropertyInfo> IManageProperties.GetManagedProperties()
    {
      return FieldManager.GetRegisteredProperties();
    }

    object IManageProperties.GetProperty(IPropertyInfo propertyInfo)
    {
      return GetProperty(propertyInfo);
    }

    object IManageProperties.ReadProperty(IPropertyInfo propertyInfo)
    {
      return ReadProperty(propertyInfo);
    }

    P IManageProperties.ReadProperty<P>(PropertyInfo<P> propertyInfo)
    {
      return ReadProperty<P>(propertyInfo);
    }

    void IManageProperties.SetProperty(IPropertyInfo propertyInfo, object newValue)
    {
      SetProperty(propertyInfo, newValue);
    }

    void IManageProperties.LoadProperty(IPropertyInfo propertyInfo, object newValue)
    {
      LoadProperty(propertyInfo, newValue);
    }

    bool IManageProperties.LoadPropertyMarkDirty(IPropertyInfo propertyInfo, object newValue)
    {
      return LoadPropertyMarkDirty(propertyInfo, newValue);
    }

    List<object> IManageProperties.GetChildren()
    {
      return FieldManager.GetChildren();
    }
#endregion

#region MobileFormatter

    /// <summary>
    /// Override this method to insert your field values
    /// into the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="mode">
    /// The StateMode indicating why this method was invoked.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnGetState(Csla.Serialization.Mobile.SerializationInfo info, StateMode mode)
    {
      base.OnGetState(info, mode);
      info.AddValue("Csla.Core.BusinessBase._isNew", _isNew);
      info.AddValue("Csla.Core.BusinessBase._isDeleted", _isDeleted);
      info.AddValue("Csla.Core.BusinessBase._isDirty", _isDirty);
      info.AddValue("Csla.Core.BusinessBase._neverCommitted", _neverCommitted);
      info.AddValue("Csla.Core.BusinessBase._disableIEditableObject", _disableIEditableObject);
      info.AddValue("Csla.Core.BusinessBase._isChild", _isChild);
      info.AddValue("Csla.Core.BusinessBase._editLevelAdded", _editLevelAdded);
      info.AddValue("Csla.Core.BusinessBase._identity", _identity);
    }

    /// <summary>
    /// Override this method to retrieve your field values
    /// from the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="mode">
    /// The StateMode indicating why this method was invoked.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnSetState(Csla.Serialization.Mobile.SerializationInfo info, StateMode mode)
    {
      base.OnSetState(info, mode);
      _isNew = info.GetValue<bool>("Csla.Core.BusinessBase._isNew");
      _isDeleted = info.GetValue<bool>("Csla.Core.BusinessBase._isDeleted");
      _isDirty = info.GetValue<bool>("Csla.Core.BusinessBase._isDirty");
      _neverCommitted = info.GetValue<bool>("Csla.Core.BusinessBase._neverCommitted");
      _disableIEditableObject = info.GetValue<bool>("Csla.Core.BusinessBase._disableIEditableObject");
      _isChild = info.GetValue<bool>("Csla.Core.BusinessBase._isChild");
      if (mode != StateMode.Undo)
        _editLevelAdded = info.GetValue<int>("Csla.Core.BusinessBase._editLevelAdded");
      _identity = info.GetValue<int>("Csla.Core.BusinessBase._identity");
    }

    /// <summary>
    /// Override this method to insert your child object
    /// references into the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="formatter">
    /// Reference to MobileFormatter instance. Use this to
    /// convert child references to/from reference id values.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnGetChildren(
      Csla.Serialization.Mobile.SerializationInfo info, Csla.Serialization.Mobile.MobileFormatter formatter)
    {
      base.OnGetChildren(info, formatter);

      if (_fieldManager != null)
      {
        var fieldManagerInfo = formatter.SerializeObject(_fieldManager);
        info.AddChild("_fieldManager", fieldManagerInfo.ReferenceId);
      }

      if (_businessRules != null)
      {
        var vrInfo = formatter.SerializeObject(_businessRules);
        info.AddChild("_businessRules", vrInfo.ReferenceId);
      }
    }

    /// <summary>
    /// Override this method to retrieve your child object
    /// references from the MobileFormatter serialzation stream.
    /// </summary>
    /// <param name="info">
    /// Object containing the data to serialize.
    /// </param>
    /// <param name="formatter">
    /// Reference to MobileFormatter instance. Use this to
    /// convert child references to/from reference id values.
    /// </param>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected override void OnSetChildren(Csla.Serialization.Mobile.SerializationInfo info, Csla.Serialization.Mobile.MobileFormatter formatter)
    {
      if (info.Children.ContainsKey("_fieldManager"))
      {
        var childData = info.Children["_fieldManager"];
        _fieldManager = (FieldManager.FieldDataManager)formatter.GetObject(childData.ReferenceId);
      }

      if (info.Children.ContainsKey("_businessRules"))
      {
        int refId = info.Children["_businessRules"].ReferenceId;
        _businessRules = (BusinessRules)formatter.GetObject(refId);
      }

      base.OnSetChildren(info, formatter);
    }

#endregion

#region Property Checks ByPass

    [NonSerialized]
    [NotUndoable]
    private bool _bypassPropertyChecks = false;

    /// <summary>
    /// Gets a value whether the business object is currently bypassing property checks?
    /// </summary>
    protected internal bool IsBypassingPropertyChecks { get { return _bypassPropertyChecks; } }
  
    [NonSerialized]
    [NotUndoable]
    private BypassPropertyChecksObject _bypassPropertyChecksObject = null;

    /// <summary>
    /// By wrapping this property inside Using block
    /// you can set property values on current business object
    /// without raising PropertyChanged events
    /// and checking user rights.
    /// </summary>
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    protected internal BypassPropertyChecksObject BypassPropertyChecks
    {
      get
      {
        return BypassPropertyChecksObject.GetManager(this);
      }
    }

    /// <summary>
    /// Class that allows setting of property values on 
    /// current business object
    /// without raising PropertyChanged events
    /// and checking user rights.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected internal class BypassPropertyChecksObject : IDisposable
    {
      private BusinessBase _businessObject;
      private static object _lock = new object();

      internal BypassPropertyChecksObject(BusinessBase businessObject)
      {
        _businessObject = businessObject;
        _businessObject._bypassPropertyChecks = true;
      }

#region IDisposable Members

      /// <summary>
      /// Disposes the object.
      /// </summary>
      public void Dispose()
      {
        Dispose(true);
        GC.SuppressFinalize(this);
      }

      /// <summary>
      /// Disposes the object.
      /// </summary>
      /// <param name="dispose">Dispose flag.</param>
      protected virtual void Dispose(bool dispose)
      {
        DeRef();
      }

      /// <summary>
      /// Gets the BypassPropertyChecks object.
      /// </summary>
      /// <param name="businessObject">The business object.</param>
      /// <returns></returns>
      public static BypassPropertyChecksObject GetManager(BusinessBase businessObject)
      {
        lock (_lock)
        {
          if (businessObject._bypassPropertyChecksObject == null)
            businessObject._bypassPropertyChecksObject = new BypassPropertyChecksObject(businessObject);

          businessObject._bypassPropertyChecksObject.AddRef();
        }
        return businessObject._bypassPropertyChecksObject;
      }

#region  Reference counting

      private int _refCount;

      /// <summary>
      /// Gets the current reference count for this
      /// object.
      /// </summary>
      public int RefCount
      {
        get { return _refCount; }
      }

      private void AddRef()
      {
        _refCount += 1;
      }

      private void DeRef()
      {

        lock (_lock)
        {
          _refCount -= 1;
          if (_refCount == 0)
          {
            _businessObject._bypassPropertyChecks = false;
            _businessObject._bypassPropertyChecksObject = null;
            _businessObject = null;
          }
        }
      }

#endregion
#endregion
    }

#endregion

#region ISuppressRuleChecking Members

    /// <summary>
    /// Sets value indicating no rule methods will be invoked.
    /// </summary>
    void ICheckRules.SuppressRuleChecking()
    {
      BusinessRules.SuppressRuleChecking = true;
    }

    /// <summary>
    /// Resets value indicating all rule methods will be invoked.
    /// </summary>
    void ICheckRules.ResumeRuleChecking()
    {
      BusinessRules.SuppressRuleChecking = false;
    }

    /// <summary>
    /// Invokes all rules for the business object.
    /// </summary>
    void ICheckRules.CheckRules()
    {
      BusinessRules.CheckRules();
    }

    /// <summary>
    /// Invokes all rules for the business object.
    /// </summary>
    Task ICheckRules.CheckRulesAsync()
    {
      return BusinessRules.CheckRulesAsync();
    }

    /// <summary>
    /// Gets the broken rules for this object
    /// </summary>
    public BrokenRulesCollection GetBrokenRules()
    {
      return BrokenRulesCollection;
    }

#endregion
  }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\Csla\Core\BusinessBase.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Source\Csla\Core\BusinessBase.cs(25,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla\Core\BusinessBase.cs(2659,27): error CS0103: The name 'new' does not exist in the current context,D:\a\1\s\Source\Csla\Core\BusinessBase.cs(2722,25): error CS0103: The name 'new' does not exist in the current context,D:\a\1\s\Source\Csla\Core\BusinessBase.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Source\Csla\Core\BusinessBase.cs(25,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Source\Csla\Core\TypeConverters\SmartDateConverter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;

namespace Csla.Core.TypeConverters
{
  /// <summary>
  /// Converts values to and from a SmartDate.
  /// </summary>
  public class SmartDateConverter : TypeConverter
  {
    /// <summary>
    /// Determines if a value can be converted
    /// to a SmartDate.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="sourceType"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type sourceType)
    {
      if (sourceType == typeof(string))
        return true;
      else if (sourceType == typeof(DateTime))
        return true;
      else if (sourceType == typeof(DateTimeOffset))
        return true;
      else if (sourceType == typeof(System.DateTime?))
        return true;
      return base.CanConvertFrom(context, sourceType);
    }

    /// <summary>
    /// Converts values to a SmartDate.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="culture"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
    {
      if (value is string)
        return new SmartDate(System.Convert.ToString(value));
      else if (value is DateTime)
        return new SmartDate(System.Convert.ToDateTime(value));
      else if (value == null)
        return new SmartDate();
      else if (value is System.DateTime?)
        return new SmartDate((System.DateTime?)value);
      else if (value is DateTimeOffset)
        return new SmartDate(((DateTimeOffset)value).DateTime);
      return base.ConvertFrom(context, culture, value);
    }

    /// <summary>
    /// Determines if a SmartDate can be
    /// convert to a value.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="destinationType"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType)
    {
      if (destinationType == typeof(string))
        return true;
      else if (destinationType == typeof(DateTime))
        return true;
      else if (destinationType == typeof(DateTimeOffset))
        return true;
      else if (destinationType == typeof(System.DateTime?))
        return true;
      return base.CanConvertTo(context, destinationType);
    }

    /// <summary>
    /// Converts a SmartDate to a value.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="culture"></param>
    /// <param name="value"></param>
    /// <param name="destinationType"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override object ConvertTo(
      System.ComponentModel.ITypeDescriptorContext context,
      System.Globalization.CultureInfo culture, object value, System.Type destinationType)
  	{
	    SmartDate sd = (SmartDate)value;
      if (destinationType == typeof(string))
        return sd.Text;
      else if (destinationType == typeof(DateTime))
        return sd.Date;
      else if (destinationType == typeof(DateTimeOffset))
        return new DateTimeOffset(sd.Date);
      else if (destinationType == typeof(System.DateTime?))
        return new System.DateTime?(sd.Date);
      return base.ConvertTo(context, culture, value, destinationType);
    }
  }
}
#endif
---- Transformed Tree ----
using System;
using System.ComponentModel;

namespace Csla.Core.TypeConverters
{
  /// <summary>
  /// Converts values to and from a SmartDate.
  /// </summary>
  public class SmartDateConverter : TypeConverter
  {
    /// <summary>
    /// Determines if a value can be converted
    /// to a SmartDate.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="sourceType"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type sourceType)
    {
      if (sourceType == typeof(string))
        return true;
      else if (sourceType == typeof(DateTime))
        return true;
      else if (sourceType == typeof(DateTimeOffset))
        return true;
      else if (sourceType == typeof(System.DateTime?))
        return true;
      return base.CanConvertFrom(context, sourceType);
    }

    /// <summary>
    /// Converts values to a SmartDate.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="culture"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
    {
      if (value is string)
        return new SmartDate(System.Convert.ToString(value));
      else if (value is DateTime)
        return new SmartDate(System.Convert.ToDateTime(value));
      else if (value == null)
        return new SmartDate();
      else if (value is System.DateTime? dateTime?)
        return new SmartDate(dateTime?);
      else if (value is DateTimeOffset dateTimeOffset)
        return new SmartDate(dateTimeOffset.DateTime);
      return base.ConvertFrom(context, culture, value);
    }

    /// <summary>
    /// Determines if a SmartDate can be
    /// convert to a value.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="destinationType"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType)
    {
      if (destinationType == typeof(string))
        return true;
      else if (destinationType == typeof(DateTime))
        return true;
      else if (destinationType == typeof(DateTimeOffset))
        return true;
      else if (destinationType == typeof(System.DateTime?))
        return true;
      return base.CanConvertTo(context, destinationType);
    }

    /// <summary>
    /// Converts a SmartDate to a value.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="culture"></param>
    /// <param name="value"></param>
    /// <param name="destinationType"></param>
    /// <returns></returns>
    /// <remarks></remarks>
    public override object ConvertTo(
      System.ComponentModel.ITypeDescriptorContext context,
      System.Globalization.CultureInfo culture, object value, System.Type destinationType)
  	{
	    SmartDate sd = (SmartDate)value;
      if (destinationType == typeof(string))
        return sd.Text;
      else if (destinationType == typeof(DateTime))
        return sd.Date;
      else if (destinationType == typeof(DateTimeOffset))
        return new DateTimeOffset(sd.Date);
      else if (destinationType == typeof(System.DateTime?))
        return new System.DateTime?(sd.Date);
      return base.ConvertTo(context, culture, value, destinationType);
    }
  }
}
#endif
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\Csla\Core\TypeConverters\SmartDateConverter.cs(56,25): error CS8116: It is not legal to use nullable type 'DateTime?' in a pattern; use the underlying type 'DateTime' instead.
######################################################################


