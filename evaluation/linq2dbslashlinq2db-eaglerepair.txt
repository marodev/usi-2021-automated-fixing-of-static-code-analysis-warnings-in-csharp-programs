Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: LinqToDB(net45)
    #1 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1023, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1050, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1077, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1185, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1212, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1293, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 132, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1320, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1347, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1374, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1401, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1428, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1455, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1482, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1509, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1536, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1563, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1590, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 1617, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #28 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 213, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #29 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 24, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 240, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 267, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 294, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 321, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 348, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 375, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 402, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 429, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 456, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 483, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 510, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 537, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 564, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 591, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 618, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 645, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 672, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 699, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 726, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 753, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 78, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 780, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 807, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 834, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 861, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 888, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 915, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 942, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 969, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\Source\LinqToDB\AsyncExtensions.generated.cs, Line: 996, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\Source\LinqToDB\Common\Internal\Cache\MemoryCache.cs, Line: 181, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #62 Path: D:\a\1\s\Source\LinqToDB\Data\DataConnectionExtensions.LegacyMerge.cs, Line: 23, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #63 Path: D:\a\1\s\Source\LinqToDB\DataProvider\DB2\DB2LUWSchemaProvider.cs, Line: 501, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #64 Path: D:\a\1\s\Source\LinqToDB\DataProvider\DB2\DB2LUWSchemaProvider.cs, Line: 508, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #65 Path: D:\a\1\s\Source\LinqToDB\DataProvider\Oracle\OracleXmlTable.cs, Line: 139, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #66 Path: D:\a\1\s\Source\LinqToDB\DataProvider\SQLite\SQLiteSchemaProvider.cs, Line: 145, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #67 Path: D:\a\1\s\Source\LinqToDB\DataProvider\SQLite\SQLiteSchemaProvider.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #68 Path: D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionTestGenerator.cs, Line: 805, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #69 Path: D:\a\1\s\Source\LinqToDB\Linq\Builder\MergeBuilder.On.cs, Line: 80, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #70 Path: D:\a\1\s\Source\LinqToDB\LinqExtensions.cs, Line: 2347, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\Source\LinqToDB\LinqExtensions.cs, Line: 2355, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\Source\LinqToDB\Mapping\AssociationDescriptor.cs, Line: 209, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\Source\LinqToDB\Mapping\AssociationDescriptor.cs, Line: 222, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #74 Path: D:\a\1\s\Source\LinqToDB\Metadata\SystemComponentModelDataAnnotationsSchemaAttributeReader.cs, Line: 41, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #75 Path: D:\a\1\s\Source\LinqToDB\Metadata\SystemDataLinqAttributeReader.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #76 Path: D:\a\1\s\Source\LinqToDB\Metadata\SystemDataSqlServerAttributeReader.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #77 Path: D:\a\1\s\Source\LinqToDB\Metadata\XmlAttributeReader.cs, Line: 86, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: D:\a\1\s\Source\LinqToDB\Metadata\XmlAttributeReader.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #79 Path: D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs, Line: 377, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #80 Path: D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs, Line: 399, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs, Line: 647, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #82 Path: D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs, Line: 678, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #83 Path: D:\a\1\s\Source\LinqToDB\SqlQuery\ConditionBase`2.cs, Line: 108, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Tests.Model(net472)
    #84 Path: D:\a\1\s\Tests\Model\Extensions.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #85 Path: D:\a\1\s\Tests\Model\OracleSpecific.cs, Line: 34, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tests(net472)
    #86 Path: D:\a\1\s\Tests\Linq\Data\MiniProfilerTests.cs, Line: 1457, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #87 Path: D:\a\1\s\Tests\Linq\Data\MiniProfilerTests.cs, Line: 1459, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #88 Path: D:\a\1\s\Tests\Linq\DataProvider\AccessProceduresTests.cs, Line: 24, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #89 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1152, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #90 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1646, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #91 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1728, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #92 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1744, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #93 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1808, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #94 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1825, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #95 Path: D:\a\1\s\Tests\Linq\DataProvider\MySqlTests.cs, Line: 1896, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #96 Path: D:\a\1\s\Tests\Linq\DataProvider\OracleTests.cs, Line: 3460, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #97 Path: D:\a\1\s\Tests\Linq\DataProvider\OracleTests.cs, Line: 3490, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #98 Path: D:\a\1\s\Tests\Linq\DataProvider\OracleTests.cs, Line: 3699, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #99 Path: D:\a\1\s\Tests\Linq\DataProvider\OracleTests.cs, Line: 3700, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #100 Path: D:\a\1\s\Tests\Linq\DataProvider\OracleTests.cs, Line: 3701, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #101 Path: D:\a\1\s\Tests\Linq\DataProvider\OracleTests.cs, Line: 3702, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #102 Path: D:\a\1\s\Tests\Linq\DataProvider\PostgreSQLTests.cs, Line: 239, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #103 Path: D:\a\1\s\Tests\Linq\DataProvider\SQLiteTests.cs, Line: 42, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\Tests\Linq\DataProvider\SQLiteTests.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\Tests\Linq\DataProvider\SqlServerTests.cs, Line: 1653, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #106 Path: D:\a\1\s\Tests\Linq\DataProvider\SybaseTests.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #107 Path: D:\a\1\s\Tests\Linq\DataProvider\SybaseTests.cs, Line: 46, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\Tests\Linq\Exceptions\CommonTests.cs, Line: 39, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #109 Path: D:\a\1\s\Tests\Linq\Linq\AllAnyTests.cs, Line: 30, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #110 Path: D:\a\1\s\Tests\Linq\Linq\AssociationTests.cs, Line: 280, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #111 Path: D:\a\1\s\Tests\Linq\Linq\AssociationTests.cs, Line: 281, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #112 Path: D:\a\1\s\Tests\Linq\Linq\AssociationTests.cs, Line: 460, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #113 Path: D:\a\1\s\Tests\Linq\Linq\AssociationTests.cs, Line: 463, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #114 Path: D:\a\1\s\Tests\Linq\Linq\AssociationTests.cs, Line: 474, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #115 Path: D:\a\1\s\Tests\Linq\Linq\CountTests.cs, Line: 104, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #116 Path: D:\a\1\s\Tests\Linq\Linq\CountTests.cs, Line: 459, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #117 Path: D:\a\1\s\Tests\Linq\Linq\CountTests.cs, Line: 462, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #118 Path: D:\a\1\s\Tests\Linq\Linq\CountTests.cs, Line: 505, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #119 Path: D:\a\1\s\Tests\Linq\Linq\ExpressionsTests.cs, Line: 179, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #120 Path: D:\a\1\s\Tests\Linq\Linq\ExpressionsTests.cs, Line: 201, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #121 Path: D:\a\1\s\Tests\Linq\Linq\ExpressionsTests.cs, Line: 225, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #122 Path: D:\a\1\s\Tests\Linq\Linq\GenericExtensionsTests.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #123 Path: D:\a\1\s\Tests\Linq\Linq\GroupByExtensionsTests.cs, Line: 187, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #124 Path: D:\a\1\s\Tests\Linq\Linq\GroupByExtensionsTests.cs, Line: 218, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #125 Path: D:\a\1\s\Tests\Linq\Linq\GroupByTests.cs, Line: 1416, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #126 Path: D:\a\1\s\Tests\Linq\Linq\GroupByTests.cs, Line: 1419, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #127 Path: D:\a\1\s\Tests\Linq\Linq\GroupByTests.cs, Line: 803, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #128 Path: D:\a\1\s\Tests\Linq\Linq\GroupByTests.cs, Line: 811, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #129 Path: D:\a\1\s\Tests\Linq\Linq\InheritanceTests.cs, Line: 378, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #130 Path: D:\a\1\s\Tests\Linq\Linq\JoinTests.cs, Line: 1114, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #131 Path: D:\a\1\s\Tests\Linq\Linq\JoinTests.cs, Line: 1120, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #132 Path: D:\a\1\s\Tests\Linq\Linq\ParameterTests.cs, Line: 419, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #133 Path: D:\a\1\s\Tests\Linq\Linq\ParameterTests.cs, Line: 426, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #134 Path: D:\a\1\s\Tests\Linq\Linq\ParameterTests.cs, Line: 427, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #135 Path: D:\a\1\s\Tests\Linq\Linq\ParameterTests.cs, Line: 434, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #136 Path: D:\a\1\s\Tests\Linq\Linq\ParameterTests.cs, Line: 435, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #137 Path: D:\a\1\s\Tests\Linq\Linq\ParserTests.cs, Line: 947, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\Tests\Linq\Linq\QueryInheritanceTests.cs, Line: 203, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #139 Path: D:\a\1\s\Tests\Linq\Linq\QueryInheritanceTests.cs, Line: 260, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #140 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 103, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #141 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 113, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #142 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 123, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #143 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 133, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #144 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 224, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #145 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 235, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #146 Path: D:\a\1\s\Tests\Linq\Linq\SelectScalarTests.cs, Line: 236, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #147 Path: D:\a\1\s\Tests\Linq\Linq\SelectTests.cs, Line: 1460, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #148 Path: D:\a\1\s\Tests\Linq\Linq\SelectTests.cs, Line: 397, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #149 Path: D:\a\1\s\Tests\Linq\Linq\SetTests.cs, Line: 31, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #150 Path: D:\a\1\s\Tests\Linq\Linq\SetTests.cs, Line: 32, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #151 Path: D:\a\1\s\Tests\Linq\Linq\SubQueryTests.cs, Line: 154, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #152 Path: D:\a\1\s\Tests\Linq\Linq\SubQueryTests.cs, Line: 88, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #153 Path: D:\a\1\s\Tests\Linq\Linq\SubQueryTests.cs, Line: 89, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #154 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 1028, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #155 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 1102, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #156 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 1259, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #157 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 1487, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #158 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 370, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #159 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 882, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #160 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 892, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #161 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 971, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #162 Path: D:\a\1\s\Tests\Linq\OrmBattle\OrmBattleTests.cs, Line: 992, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #163 Path: D:\a\1\s\Tests\Linq\SchemaProvider\PostgreSQLSchemaProviderTests.cs, Line: 371, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #164 Path: D:\a\1\s\Tests\Linq\Update\UpdateTests.cs, Line: 1281, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #165 Path: D:\a\1\s\Tests\Linq\UserTests\Issue192Tests.cs, Line: 29, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #166 Path: D:\a\1\s\Tests\Linq\UserTests\Issue1983Tests.cs, Line: 32, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #167 Path: D:\a\1\s\Tests\Linq\UserTests\Issue781Tests.cs, Line: 62, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #168 Path: D:\a\1\s\Tests\Linq\UserTests\Issue873Tests.cs, Line: 40, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #169 Path: D:\a\1\s\Tests\Linq\UserTests\Issue873Tests.cs, Line: 41, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Tests.Base(net472)
    #170 Path: D:\a\1\s\Tests\Base\SqlServerTypes\Loader.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R8: 67
R4: 58
R9: 24
R6: 16
R5: 4
R7: 1

--- Summary ---
Fixed ReSharper issues: 170
Fixed SonarQube issues: 78
Total fixed issues: 170

Finished in: 1 min 15 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\DataProvider\SqlServer\SqlServerDataProvider.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.SqlTypes;
using System.Threading;
using System.Threading.Tasks;

namespace LinqToDB.DataProvider.SqlServer
{
	using Common;
	using Data;
	using Extensions;
	using Mapping;
	using SchemaProvider;
	using SqlProvider;

	public class SqlServerDataProvider : DynamicDataProviderBase<SqlServerProviderAdapter>
	{
		#region Init

		public SqlServerDataProvider(string name, SqlServerVersion version)
			: this(name, version, SqlServerProvider.MicrosoftDataSqlClient)
		{
		}

		public SqlServerDataProvider(string name, SqlServerVersion version, SqlServerProvider provider)
			: base(
				  name,
				  MappingSchemaInstance.Get(version),
				  SqlServerProviderAdapter.GetInstance(provider))
		{
			Version  = version;
			Provider = provider;

			SqlProviderFlags.IsDistinctOrderBySupported       = false;
			SqlProviderFlags.IsSubQueryOrderBySupported       = false;
			SqlProviderFlags.IsDistinctSetOperationsSupported = true;
			SqlProviderFlags.IsCountDistinctSupported         = true;
			SqlProviderFlags.IsUpdateFromSupported            = true;

			if (version == SqlServerVersion.v2000)
			{
				SqlProviderFlags.AcceptsTakeAsParameter   = false;
				SqlProviderFlags.IsSkipSupported          = false;
				SqlProviderFlags.IsCountSubQuerySupported = false;
			}
			else
			{
				SqlProviderFlags.IsApplyJoinSupported              = true;
				SqlProviderFlags.TakeHintsSupported                = TakeHints.Percent | TakeHints.WithTies;
				SqlProviderFlags.IsCommonTableExpressionsSupported = version >= SqlServerVersion.v2008;
			}

			SetCharField("char" , (r, i) => r.GetString(i).TrimEnd(' '));
			SetCharField("nchar", (r, i) => r.GetString(i).TrimEnd(' '));
			SetCharFieldToType<char>("char" , DataTools.GetCharExpression);
			SetCharFieldToType<char>("nchar", DataTools.GetCharExpression);

			_sqlOptimizer = version switch
			{
				SqlServerVersion.v2000 => new SqlServer2000SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2005 => new SqlServer2005SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2012 => new SqlServer2012SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2016 => new SqlServer2016SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2017 => new SqlServer2017SqlOptimizer(SqlProviderFlags),
				_                      => new SqlServer2008SqlOptimizer(SqlProviderFlags),
			};

			// missing:
			// GetSqlBytes
			// GetSqlChars
			SetProviderField<SqlBinary  , SqlBinary  >(SqlTypes.GetSqlBinaryReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlBoolean , SqlBoolean >(SqlTypes.GetSqlBooleanReaderMethod , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlByte    , SqlByte    >(SqlTypes.GetSqlByteReaderMethod    , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlDateTime, SqlDateTime>(SqlTypes.GetSqlDateTimeReaderMethod, dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlDecimal , SqlDecimal >(SqlTypes.GetSqlDecimalReaderMethod , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlDouble  , SqlDouble  >(SqlTypes.GetSqlDoubleReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlGuid    , SqlGuid    >(SqlTypes.GetSqlGuidReaderMethod    , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlInt16   , SqlInt16   >(SqlTypes.GetSqlInt16ReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlInt32   , SqlInt32   >(SqlTypes.GetSqlInt32ReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlInt64   , SqlInt64   >(SqlTypes.GetSqlInt64ReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlMoney   , SqlMoney   >(SqlTypes.GetSqlMoneyReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlSingle  , SqlSingle  >(SqlTypes.GetSqlSingleReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlString  , SqlString  >(SqlTypes.GetSqlStringReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlXml     , SqlXml     >(Adapter.GetSqlXmlReaderMethod      , dataReaderType: Adapter.DataReaderType);

			SetProviderField<DateTimeOffset>(Adapter.GetDateTimeOffsetReaderMethod        , dataReaderType: Adapter.DataReaderType);
			SetProviderField<TimeSpan>      (Adapter.GetTimeSpanReaderMethod              , dataReaderType: Adapter.DataReaderType);

			// non-specific fallback
			SetProviderField<IDataReader, SqlString, SqlString>((r, i) => r.GetString(i));

			SqlServerTypes.Configure(this);
		}

		#endregion

		#region Public Properties

		public SqlServerVersion Version { get; }

		public SqlServerProvider Provider { get; }

		#endregion

		#region Overrides

		static class MappingSchemaInstance
		{
			public static readonly MappingSchema SqlServer2000MappingSchema = new SqlServer2000MappingSchema();
			public static readonly MappingSchema SqlServer2005MappingSchema = new SqlServer2005MappingSchema();
			public static readonly MappingSchema SqlServer2008MappingSchema = new SqlServer2008MappingSchema();
			public static readonly MappingSchema SqlServer2012MappingSchema = new SqlServer2012MappingSchema();
			public static readonly MappingSchema SqlServer2016MappingSchema = new SqlServer2016MappingSchema();
			public static readonly MappingSchema SqlServer2017MappingSchema = new SqlServer2017MappingSchema();

			public static MappingSchema Get(SqlServerVersion version)
			{
				return version switch
				{
					SqlServerVersion.v2000 => SqlServer2000MappingSchema,
					SqlServerVersion.v2005 => SqlServer2005MappingSchema,
					SqlServerVersion.v2012 => SqlServer2012MappingSchema,
					SqlServerVersion.v2016 => SqlServer2016MappingSchema,
					SqlServerVersion.v2017 => SqlServer2017MappingSchema,
					_                      => SqlServer2008MappingSchema,
				};
			}
		}

		public override TableOptions SupportedTableOptions =>
			TableOptions.IsTemporary                |
			TableOptions.IsLocalTemporaryStructure  |
			TableOptions.IsGlobalTemporaryStructure |
			TableOptions.IsLocalTemporaryData       |
			TableOptions.IsGlobalTemporaryData      |
			TableOptions.CreateIfNotExists          |
			TableOptions.DropIfExists;

		public override ISqlBuilder CreateSqlBuilder(MappingSchema mappingSchema)
		{
			return Version switch
			{
				SqlServerVersion.v2000 => new SqlServer2000SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2005 => new SqlServer2005SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2008 => new SqlServer2008SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2012 => new SqlServer2012SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2016 => new SqlServer2016SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2017 => new SqlServer2017SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				_                      => throw new InvalidOperationException(),
			};
		}

		readonly ISqlOptimizer _sqlOptimizer;

		public override ISqlOptimizer GetSqlOptimizer() => _sqlOptimizer;

		public override ISchemaProvider GetSchemaProvider()
		{
			return Version == SqlServerVersion.v2000 ? new SqlServer2000SchemaProvider(this) : new SqlServerSchemaProvider(this);
		}

		static readonly ConcurrentDictionary<string,bool> _marsFlags = new ConcurrentDictionary<string,bool>();

		public override object? GetConnectionInfo(DataConnection dataConnection, string parameterName)
		{
			// take it from real Connection object, as dataConnection.ConnectionString could be null
			// also it will not cache original connection string with credentials in _marsFlags
			var connectionString = dataConnection.Connection.ConnectionString;
			switch (parameterName)
			{
				case "IsMarsEnabled" :
					if (connectionString != null)
					{
						if (!_marsFlags.TryGetValue(connectionString, out var flag))
						{
							flag = Adapter.CreateConnectionStringBuilder(connectionString).MultipleActiveResultSets;
							_marsFlags[connectionString] = flag;
						}

						return flag;
					}

					return false;
			}

			return null;
		}

		public override void SetParameter(DataConnection dataConnection, IDbDataParameter parameter, string name, DbDataType dataType, object? value)
		{
			var param = TryGetProviderParameter(parameter, MappingSchema);

			switch (dataType.DataType)
			{
				case DataType.DateTime2  :
					{
						if (value is DateTime dt)
							value = DataTools.AdjustPrecision(dt, (byte)(dataType.Precision ?? 7));
						break;
					}
				case DataType.Udt        :
					{
						if (param    != null
							&& value != null
							&& _udtTypeNames.TryGetValue(value.GetType(), out var typeName))
							Adapter.SetUdtTypeName(param, typeName);
					}

					break;
				case DataType.NText:
					     if (value is DateTimeOffset dto) value = dto.ToString("yyyy-MM-ddTHH:mm:ss.ffffff zzz");
					else if (value is DateTime dt)
					{
						value = dt.ToString(
							dt.Millisecond == 0
								? "yyyy-MM-ddTHH:mm:ss"
								: "yyyy-MM-ddTHH:mm:ss.fff");
					}
					else if (value is TimeSpan ts)
					{
						value = ts.ToString(
							ts.Days > 0
								? ts.Milliseconds > 0
									? "d\\.hh\\:mm\\:ss\\.fff"
									: "d\\.hh\\:mm\\:ss"
								: ts.Milliseconds > 0
									? "hh\\:mm\\:ss\\.fff"
									: "hh\\:mm\\:ss");
					}
					break;

				case DataType.Undefined:
					if (value != null
						&& (value is DataTable
						|| value is DbDataReader
							|| value is IEnumerable<DbDataRecord>
							|| value.GetType().IsEnumerableTType(Adapter.SqlDataRecordType)))
					{
						dataType = dataType.WithDataType(DataType.Structured);
					}

					break;
			}

			base.SetParameter(dataConnection, parameter, name, dataType, value);

			if (param != null)
			{
				// Setting for NVarChar and VarChar constant size. It reduces count of cached plans.
				switch (Adapter.GetDbType(param))
				{
					case SqlDbType.Structured:
						{
							if (!dataType.DbType.IsNullOrEmpty())
								Adapter.SetTypeName(param, dataType.DbType);

							// TVP doesn't support DBNull
							if (parameter.Value is DBNull)
								parameter.Value = null;

							break;
						}
					case SqlDbType.VarChar:
						{
							var strValue = value as string;
							if ((strValue != null && strValue.Length > 8000) || (value != null && strValue == null))
								parameter.Size = -1;
							else if (dataType.Length != null && dataType.Length <= 8000 && (strValue == null || strValue.Length <= dataType.Length))
								parameter.Size = dataType.Length.Value;
							else
								parameter.Size = 8000;

							break;
						}
					case SqlDbType.NVarChar:
						{
							var strValue = value as string;
							if ((strValue != null && strValue.Length > 4000) || (value != null && strValue == null))
								parameter.Size = -1;
							else if (dataType.Length != null && dataType.Length <= 4000 && (strValue == null || strValue.Length <= dataType.Length))
								parameter.Size = dataType.Length.Value;
							else
								parameter.Size = 4000;

							break;
						}
					case SqlDbType.VarBinary:
						{
							var binaryValue = value as byte[];
							if ((binaryValue != null && binaryValue.Length > 8000) || (value != null && binaryValue == null))
								parameter.Size = -1;
							else if (dataType.Length != null && dataType.Length <= 8000 && (binaryValue == null || binaryValue.Length <= dataType.Length))
								parameter.Size = dataType.Length.Value;
							else
								parameter.Size = 8000;

							break;
						}
				}
			}
		}

		protected override void SetParameterType(DataConnection dataConnection, IDbDataParameter parameter, DbDataType dataType)
		{
			if (parameter is BulkCopyReader.Parameter)
				return;

			SqlDbType? type = null;

			switch (dataType.DataType)
			{
				case DataType.Text          : type = SqlDbType.Text;          break;
				case DataType.NText         : type = SqlDbType.NText;         break;
				case DataType.Binary        : type = SqlDbType.Binary;        break;
				case DataType.Image         : type = SqlDbType.Image;         break;
				case DataType.SmallMoney    : type = SqlDbType.SmallMoney;    break;
				case DataType.Date          : type = SqlDbType.Date;          break;
				case DataType.Time          : type = SqlDbType.Time;          break;
				case DataType.SmallDateTime : type = SqlDbType.SmallDateTime; break;
				case DataType.Timestamp     : type = SqlDbType.Timestamp;     break;
				case DataType.Structured    : type = SqlDbType.Structured;    break;
			}

			if (type != null)
			{
				var param = TryGetProviderParameter(parameter, dataConnection.MappingSchema);
				if (param != null)
				{
					Adapter.SetDbType(param, type.Value);
					return;
				}
			}

			switch (dataType.DataType)
			{
				// including provider-specific fallbacks
				case DataType.Text          : parameter.DbType = DbType.AnsiString; break;
				case DataType.NText         : parameter.DbType = DbType.String;     break;
				case DataType.Binary        :
				case DataType.Timestamp     :
				case DataType.Image         : parameter.DbType = DbType.Binary;     break;
				case DataType.SmallMoney    :
				case DataType.Money         : parameter.DbType = DbType.Currency;    break;
				case DataType.SmallDateTime : parameter.DbType = DbType.DateTime;    break;
				case DataType.Structured    : parameter.DbType = DbType.Object;      break;
				case DataType.Xml           : parameter.DbType = DbType.Xml;         break;
				case DataType.SByte         : parameter.DbType = DbType.Int16;       break;
				case DataType.UInt16        : parameter.DbType = DbType.Int32;       break;
				case DataType.UInt32        : parameter.DbType = DbType.Int64;       break;
				case DataType.UInt64        :
				case DataType.VarNumeric    : parameter.DbType = DbType.Decimal;     break;
				case DataType.DateTime      :
				case DataType.DateTime2     :
					parameter.DbType =
						Version == SqlServerVersion.v2000 || Version == SqlServerVersion.v2005 ?
							DbType.DateTime :
							DbType.DateTime2;
					break;
				default                     : base.SetParameterType(dataConnection, parameter, dataType); break;
			}
		}

		#endregion

		#region UDT support

		private readonly ConcurrentDictionary<Type, string> _udtTypeNames = new ConcurrentDictionary<Type, string>();
		private readonly ConcurrentDictionary<string, Type> _udtTypes     = new ConcurrentDictionary<string, Type>();

		public void AddUdtType(Type type, string udtName)
		{
			MappingSchema.SetScalarType(type);

			_udtTypeNames[type] = udtName;
			_udtTypes[udtName]  = type;
		}

		public void AddUdtType(Type type, string udtName, object? defaultValue, DataType dataType = DataType.Undefined)
		{
			MappingSchema.AddScalarType(type, defaultValue, dataType);

			_udtTypeNames[type] = udtName;
			_udtTypes[udtName]  = type;
		}

		public void AddUdtType<T>(string udtName, T defaultValue, DataType dataType = DataType.Undefined)
		{
			MappingSchema.AddScalarType(typeof(T), defaultValue, dataType);

			_udtTypeNames[typeof(T)] = udtName;
			_udtTypes[udtName]       = typeof(T);
		}

		internal Type? GetUdtTypeByName(string udtName)
		{
			if (_udtTypes.TryGetValue(udtName, out var type))
				return type;

			return null;
		}

		#endregion

		#region BulkCopy

		SqlServerBulkCopy? _bulkCopy;

		public override BulkCopyRowsCopied BulkCopy<T>(ITable<T> table, BulkCopyOptions options, IEnumerable<T> source)
		{
			_bulkCopy ??= new SqlServerBulkCopy(this);

			return _bulkCopy.BulkCopy(
				options.BulkCopyType == BulkCopyType.Default ? SqlServerTools.DefaultBulkCopyType : options.BulkCopyType,
				table,
				options,
				source);
		}

		public override Task<BulkCopyRowsCopied> BulkCopyAsync<T>(ITable<T> table, BulkCopyOptions options, IEnumerable<T> source, CancellationToken cancellationToken)
		{
			_bulkCopy ??= new SqlServerBulkCopy(this);

			return _bulkCopy.BulkCopyAsync(
				options.BulkCopyType == BulkCopyType.Default ? SqlServerTools.DefaultBulkCopyType : options.BulkCopyType,
				table,
				options,
				source,
				cancellationToken);
		}

#if !NETFRAMEWORK
		public override Task<BulkCopyRowsCopied> BulkCopyAsync<T>(ITable<T> table, BulkCopyOptions options, IAsyncEnumerable<T> source, CancellationToken cancellationToken)
		{
			_bulkCopy ??= new SqlServerBulkCopy(this);

			return _bulkCopy.BulkCopyAsync(
				options.BulkCopyType == BulkCopyType.Default ? SqlServerTools.DefaultBulkCopyType : options.BulkCopyType,
				table,
				options,
				source,
				cancellationToken);
		}
#endif

		#endregion
	}
}

---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.SqlTypes;
using System.Threading;
using System.Threading.Tasks;

namespace LinqToDB.DataProvider.SqlServer
{
	using Common;
	using Data;
	using Extensions;
	using Mapping;
	using SchemaProvider;
	using SqlProvider;

	public class SqlServerDataProvider : DynamicDataProviderBase<SqlServerProviderAdapter>
	{
		#region Init

		public SqlServerDataProvider(string name, SqlServerVersion version)
			: this(name, version, SqlServerProvider.MicrosoftDataSqlClient)
		{
		}

		public SqlServerDataProvider(string name, SqlServerVersion version, SqlServerProvider provider)
			: base(
				  name,
				  MappingSchemaInstance.Get(version),
				  SqlServerProviderAdapter.GetInstance(provider))
		{
			Version  = version;
			Provider = provider;

			SqlProviderFlags.IsDistinctOrderBySupported       = false;
			SqlProviderFlags.IsSubQueryOrderBySupported       = false;
			SqlProviderFlags.IsDistinctSetOperationsSupported = true;
			SqlProviderFlags.IsCountDistinctSupported         = true;
			SqlProviderFlags.IsUpdateFromSupported            = true;

			if (version == SqlServerVersion.v2000)
			{
				SqlProviderFlags.AcceptsTakeAsParameter   = false;
				SqlProviderFlags.IsSkipSupported          = false;
				SqlProviderFlags.IsCountSubQuerySupported = false;
			}
			else
			{
				SqlProviderFlags.IsApplyJoinSupported              = true;
				SqlProviderFlags.TakeHintsSupported                = TakeHints.Percent | TakeHints.WithTies;
				SqlProviderFlags.IsCommonTableExpressionsSupported = version >= SqlServerVersion.v2008;
			}

			SetCharField("char" , (r, i) => r.GetString(i).TrimEnd(' '));
			SetCharField("nchar", (r, i) => r.GetString(i).TrimEnd(' '));
			SetCharFieldToType<char>("char" , DataTools.GetCharExpression);
			SetCharFieldToType<char>("nchar", DataTools.GetCharExpression);

			_sqlOptimizer = version switch
			{
				SqlServerVersion.v2000 => new SqlServer2000SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2005 => new SqlServer2005SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2012 => new SqlServer2012SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2016 => new SqlServer2016SqlOptimizer(SqlProviderFlags),
				SqlServerVersion.v2017 => new SqlServer2017SqlOptimizer(SqlProviderFlags),
				_                      => new SqlServer2008SqlOptimizer(SqlProviderFlags),
			};

			// missing:
			// GetSqlBytes
			// GetSqlChars
			SetProviderField<SqlBinary  , SqlBinary  >(SqlTypes.GetSqlBinaryReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlBoolean , SqlBoolean >(SqlTypes.GetSqlBooleanReaderMethod , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlByte    , SqlByte    >(SqlTypes.GetSqlByteReaderMethod    , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlDateTime, SqlDateTime>(SqlTypes.GetSqlDateTimeReaderMethod, dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlDecimal , SqlDecimal >(SqlTypes.GetSqlDecimalReaderMethod , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlDouble  , SqlDouble  >(SqlTypes.GetSqlDoubleReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlGuid    , SqlGuid    >(SqlTypes.GetSqlGuidReaderMethod    , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlInt16   , SqlInt16   >(SqlTypes.GetSqlInt16ReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlInt32   , SqlInt32   >(SqlTypes.GetSqlInt32ReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlInt64   , SqlInt64   >(SqlTypes.GetSqlInt64ReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlMoney   , SqlMoney   >(SqlTypes.GetSqlMoneyReaderMethod   , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlSingle  , SqlSingle  >(SqlTypes.GetSqlSingleReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlString  , SqlString  >(SqlTypes.GetSqlStringReaderMethod  , dataReaderType: Adapter.DataReaderType);
			SetProviderField<SqlXml     , SqlXml     >(Adapter.GetSqlXmlReaderMethod      , dataReaderType: Adapter.DataReaderType);

			SetProviderField<DateTimeOffset>(Adapter.GetDateTimeOffsetReaderMethod        , dataReaderType: Adapter.DataReaderType);
			SetProviderField<TimeSpan>      (Adapter.GetTimeSpanReaderMethod              , dataReaderType: Adapter.DataReaderType);

			// non-specific fallback
			SetProviderField<IDataReader, SqlString, SqlString>((r, i) => r.GetString(i));

			SqlServerTypes.Configure(this);
		}

		#endregion

		#region Public Properties

		public SqlServerVersion Version { get; }

		public SqlServerProvider Provider { get; }

		#endregion

		#region Overrides

		static class MappingSchemaInstance
		{
			public static readonly MappingSchema SqlServer2000MappingSchema = new SqlServer2000MappingSchema();
			public static readonly MappingSchema SqlServer2005MappingSchema = new SqlServer2005MappingSchema();
			public static readonly MappingSchema SqlServer2008MappingSchema = new SqlServer2008MappingSchema();
			public static readonly MappingSchema SqlServer2012MappingSchema = new SqlServer2012MappingSchema();
			public static readonly MappingSchema SqlServer2016MappingSchema = new SqlServer2016MappingSchema();
			public static readonly MappingSchema SqlServer2017MappingSchema = new SqlServer2017MappingSchema();

			public static MappingSchema Get(SqlServerVersion version)
			{
				return version switch
				{
					SqlServerVersion.v2000 => SqlServer2000MappingSchema,
					SqlServerVersion.v2005 => SqlServer2005MappingSchema,
					SqlServerVersion.v2012 => SqlServer2012MappingSchema,
					SqlServerVersion.v2016 => SqlServer2016MappingSchema,
					SqlServerVersion.v2017 => SqlServer2017MappingSchema,
					_                      => SqlServer2008MappingSchema,
				};
			}
		}

		public override TableOptions SupportedTableOptions =>
			TableOptions.IsTemporary                |
			TableOptions.IsLocalTemporaryStructure  |
			TableOptions.IsGlobalTemporaryStructure |
			TableOptions.IsLocalTemporaryData       |
			TableOptions.IsGlobalTemporaryData      |
			TableOptions.CreateIfNotExists          |
			TableOptions.DropIfExists;

		public override ISqlBuilder CreateSqlBuilder(MappingSchema mappingSchema)
		{
			return Version switch
			{
				SqlServerVersion.v2000 => new SqlServer2000SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2005 => new SqlServer2005SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2008 => new SqlServer2008SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2012 => new SqlServer2012SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2016 => new SqlServer2016SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				SqlServerVersion.v2017 => new SqlServer2017SqlBuilder(this, mappingSchema, GetSqlOptimizer(), SqlProviderFlags),
				_                      => throw new InvalidOperationException(),
			};
		}

		readonly ISqlOptimizer _sqlOptimizer;

		public override ISqlOptimizer GetSqlOptimizer() => _sqlOptimizer;

		public override ISchemaProvider GetSchemaProvider()
		{
			return Version == SqlServerVersion.v2000 ? new SqlServer2000SchemaProvider(this) : new SqlServerSchemaProvider(this);
		}

		static readonly ConcurrentDictionary<string,bool> _marsFlags = new ConcurrentDictionary<string,bool>();

		public override object? GetConnectionInfo(DataConnection dataConnection, string parameterName)
		{
			// take it from real Connection object, as dataConnection.ConnectionString could be null
			// also it will not cache original connection string with credentials in _marsFlags
			var connectionString = dataConnection.Connection.ConnectionString;
			switch (parameterName)
			{
				case "IsMarsEnabled" :
					if (connectionString != null)
					{
						if (!_marsFlags.TryGetValue(connectionString, out var flag))
						{
							flag = Adapter.CreateConnectionStringBuilder(connectionString).MultipleActiveResultSets;
							_marsFlags[connectionString] = flag;
						}

						return flag;
					}

					return false;
			}

			return null;
		}

		public override void SetParameter(DataConnection dataConnection, IDbDataParameter parameter, string name, DbDataType dataType, object? value)
		{
			var param = TryGetProviderParameter(parameter, MappingSchema);

			switch (dataType.DataType)
			{
				case DataType.DateTime2  :
					{
						if (value is DateTime dt)
							value = DataTools.AdjustPrecision(dt, (byte)(dataType.Precision ?? 7));
						break;
					}
				case DataType.Udt        :
					{
						if (param    != null
							&& value != null
							&& _udtTypeNames.TryGetValue(value.GetType(), out var typeName))
							Adapter.SetUdtTypeName(param, typeName);
					}

					break;
				case DataType.NText:
					     if (value is DateTimeOffset dto) value = dto.ToString("yyyy-MM-ddTHH:mm:ss.ffffff zzz");
					else if (value is DateTime dt)
					{
						value = dt.ToString(
							dt.Millisecond == 0
								? "yyyy-MM-ddTHH:mm:ss"
								: "yyyy-MM-ddTHH:mm:ss.fff");
					}
					else if (value is TimeSpan ts)
					{
						value = ts.ToString(
							ts.Days > 0
								? ts.Milliseconds > 0
									? "d\\.hh\\:mm\\:ss\\.fff"
									: "d\\.hh\\:mm\\:ss"
								: ts.Milliseconds > 0
									? "hh\\:mm\\:ss\\.fff"
									: "hh\\:mm\\:ss");
					}
					break;

				case DataType.Undefined:
					if (value != null
						&& (value is DataTable
						|| value is DbDataReader
							|| value is IEnumerable<DbDataRecord>
							|| value.GetType().IsEnumerableTType(Adapter.SqlDataRecordType)))
					{
						dataType = dataType.WithDataType(DataType.Structured);
					}

					break;
			}

			base.SetParameter(dataConnection, parameter, name, dataType, value);

			if (param != null)
			{
				// Setting for NVarChar and VarChar constant size. It reduces count of cached plans.
				switch (Adapter.GetDbType(param))
				{
					case SqlDbType.Structured:
						{
							if (!dataType.DbType.IsNullOrEmpty())
								Adapter.SetTypeName(param, dataType.DbType);

							// TVP doesn't support DBNull
							if (parameter.Value is DBNull)
								parameter.Value = null;

							break;
						}
					case SqlDbType.VarChar:
						{
							if ((value is string strValue && strValue.Length > 8000) || (value != null && strValue == null))
								parameter.Size = -1;
							else if (dataType.Length != null && dataType.Length <= 8000 && (strValue == null || strValue.Length <= dataType.Length))
								parameter.Size = dataType.Length.Value;
							else
								parameter.Size = 8000;

							break;
						}
					case SqlDbType.NVarChar:
						{
							if ((value is string strValue && strValue.Length > 4000) || (value != null && strValue == null))
								parameter.Size = -1;
							else if (dataType.Length != null && dataType.Length <= 4000 && (strValue == null || strValue.Length <= dataType.Length))
								parameter.Size = dataType.Length.Value;
							else
								parameter.Size = 4000;

							break;
						}
					case SqlDbType.VarBinary:
						{
							if ((value is byte[] binaryValue && binaryValue.Length > 8000) || (value != null && binaryValue == null))
								parameter.Size = -1;
							else if (dataType.Length != null && dataType.Length <= 8000 && (binaryValue == null || binaryValue.Length <= dataType.Length))
								parameter.Size = dataType.Length.Value;
							else
								parameter.Size = 8000;

							break;
						}
				}
			}
		}

		protected override void SetParameterType(DataConnection dataConnection, IDbDataParameter parameter, DbDataType dataType)
		{
			if (parameter is BulkCopyReader.Parameter)
				return;

			SqlDbType? type = null;

			switch (dataType.DataType)
			{
				case DataType.Text          : type = SqlDbType.Text;          break;
				case DataType.NText         : type = SqlDbType.NText;         break;
				case DataType.Binary        : type = SqlDbType.Binary;        break;
				case DataType.Image         : type = SqlDbType.Image;         break;
				case DataType.SmallMoney    : type = SqlDbType.SmallMoney;    break;
				case DataType.Date          : type = SqlDbType.Date;          break;
				case DataType.Time          : type = SqlDbType.Time;          break;
				case DataType.SmallDateTime : type = SqlDbType.SmallDateTime; break;
				case DataType.Timestamp     : type = SqlDbType.Timestamp;     break;
				case DataType.Structured    : type = SqlDbType.Structured;    break;
			}

			if (type != null)
			{
				var param = TryGetProviderParameter(parameter, dataConnection.MappingSchema);
				if (param != null)
				{
					Adapter.SetDbType(param, type.Value);
					return;
				}
			}

			switch (dataType.DataType)
			{
				// including provider-specific fallbacks
				case DataType.Text          : parameter.DbType = DbType.AnsiString; break;
				case DataType.NText         : parameter.DbType = DbType.String;     break;
				case DataType.Binary        :
				case DataType.Timestamp     :
				case DataType.Image         : parameter.DbType = DbType.Binary;     break;
				case DataType.SmallMoney    :
				case DataType.Money         : parameter.DbType = DbType.Currency;    break;
				case DataType.SmallDateTime : parameter.DbType = DbType.DateTime;    break;
				case DataType.Structured    : parameter.DbType = DbType.Object;      break;
				case DataType.Xml           : parameter.DbType = DbType.Xml;         break;
				case DataType.SByte         : parameter.DbType = DbType.Int16;       break;
				case DataType.UInt16        : parameter.DbType = DbType.Int32;       break;
				case DataType.UInt32        : parameter.DbType = DbType.Int64;       break;
				case DataType.UInt64        :
				case DataType.VarNumeric    : parameter.DbType = DbType.Decimal;     break;
				case DataType.DateTime      :
				case DataType.DateTime2     :
					parameter.DbType =
						Version == SqlServerVersion.v2000 || Version == SqlServerVersion.v2005 ?
							DbType.DateTime :
							DbType.DateTime2;
					break;
				default                     : base.SetParameterType(dataConnection, parameter, dataType); break;
			}
		}

		#endregion

		#region UDT support

		private readonly ConcurrentDictionary<Type, string> _udtTypeNames = new ConcurrentDictionary<Type, string>();
		private readonly ConcurrentDictionary<string, Type> _udtTypes     = new ConcurrentDictionary<string, Type>();

		public void AddUdtType(Type type, string udtName)
		{
			MappingSchema.SetScalarType(type);

			_udtTypeNames[type] = udtName;
			_udtTypes[udtName]  = type;
		}

		public void AddUdtType(Type type, string udtName, object? defaultValue, DataType dataType = DataType.Undefined)
		{
			MappingSchema.AddScalarType(type, defaultValue, dataType);

			_udtTypeNames[type] = udtName;
			_udtTypes[udtName]  = type;
		}

		public void AddUdtType<T>(string udtName, T defaultValue, DataType dataType = DataType.Undefined)
		{
			MappingSchema.AddScalarType(typeof(T), defaultValue, dataType);

			_udtTypeNames[typeof(T)] = udtName;
			_udtTypes[udtName]       = typeof(T);
		}

		internal Type? GetUdtTypeByName(string udtName)
		{
			if (_udtTypes.TryGetValue(udtName, out var type))
				return type;

			return null;
		}

		#endregion

		#region BulkCopy

		SqlServerBulkCopy? _bulkCopy;

		public override BulkCopyRowsCopied BulkCopy<T>(ITable<T> table, BulkCopyOptions options, IEnumerable<T> source)
		{
			_bulkCopy ??= new SqlServerBulkCopy(this);

			return _bulkCopy.BulkCopy(
				options.BulkCopyType == BulkCopyType.Default ? SqlServerTools.DefaultBulkCopyType : options.BulkCopyType,
				table,
				options,
				source);
		}

		public override Task<BulkCopyRowsCopied> BulkCopyAsync<T>(ITable<T> table, BulkCopyOptions options, IEnumerable<T> source, CancellationToken cancellationToken)
		{
			_bulkCopy ??= new SqlServerBulkCopy(this);

			return _bulkCopy.BulkCopyAsync(
				options.BulkCopyType == BulkCopyType.Default ? SqlServerTools.DefaultBulkCopyType : options.BulkCopyType,
				table,
				options,
				source,
				cancellationToken);
		}

#if !NETFRAMEWORK
		public override Task<BulkCopyRowsCopied> BulkCopyAsync<T>(ITable<T> table, BulkCopyOptions options, IAsyncEnumerable<T> source, CancellationToken cancellationToken)
		{
			_bulkCopy ??= new SqlServerBulkCopy(this);

			return _bulkCopy.BulkCopyAsync(
				options.BulkCopyType == BulkCopyType.Default ? SqlServerTools.DefaultBulkCopyType : options.BulkCopyType,
				table,
				options,
				source,
				cancellationToken);
		}
#endif

		#endregion
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\DataProvider\SqlServer\SqlServerDataProvider.cs(268,86): error CS0165: Use of unassigned local variable 'strValue',D:\a\1\s\Source\LinqToDB\DataProvider\SqlServer\SqlServerDataProvider.cs(279,86): error CS0165: Use of unassigned local variable 'strValue',D:\a\1\s\Source\LinqToDB\DataProvider\SqlServer\SqlServerDataProvider.cs(290,92): error CS0165: Use of unassigned local variable 'binaryValue'
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionBuilder.SqlBuilder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data.SqlTypes;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace LinqToDB.Linq.Builder
{
	using Common;
	using Data;
	using LinqToDB.Expressions;
	using Extensions;
	using Mapping;
	using Reflection;
	using SqlQuery;
	using SqlProvider;
	using Tools;
	using System.Threading;

	partial class ExpressionBuilder
	{
		#region Build Where

		public IBuildContext BuildWhere(IBuildContext? parent, IBuildContext sequence, LambdaExpression condition, bool checkForSubQuery, bool enforceHaving = false)
		{
			var prevParent = sequence.Parent;
			var ctx        = new ExpressionContext(parent, sequence, condition);
			var expr       = ConvertExpression(condition.Body.Unwrap());
			var makeHaving = false;

			if (checkForSubQuery && CheckSubQueryForWhere(ctx, expr, out makeHaving))
			{
				ReplaceParent(ctx, prevParent);

				sequence = new SubQueryContext(sequence);
				prevParent = sequence.Parent;

				ctx = new ExpressionContext(parent, sequence, condition);
			}

			var conditions = enforceHaving || makeHaving && !ctx.SelectQuery.GroupBy.IsEmpty?
				ctx.SelectQuery.Having.SearchCondition.Conditions :
				ctx.SelectQuery.Where. SearchCondition.Conditions;

			BuildSearchCondition(ctx, expr, conditions);

			ReplaceParent(ctx, prevParent);

			return sequence;
		}

		bool CheckSubQueryForWhere(IBuildContext context, Expression expression, out bool makeHaving)
		{
			var makeSubQuery = false;
			var isHaving     = false;
			var isWhere      = false;

			expression.Visit(expr =>
			{
				if (makeSubQuery)
					return false;

				if (_subQueryExpressions != null && _subQueryExpressions.Contains(expr))
				{
					makeSubQuery = true;
					isWhere      = true;
					return false;
				}

				switch (expr.NodeType)
				{
					case ExpressionType.MemberAccess:
					{
						var ma = (MemberExpression)expr;

						if (ma.Member.IsNullableValueMember())
							return true;

						if (Expressions.ConvertMember(MappingSchema, ma.Expression?.Type, ma.Member) != null)
							return true;

						var ctx = GetContext(context, expr);

						if (ctx == null)
							return true;

						var expres = ctx.IsExpression(expr, 0, RequestFor.Expression);

						if (expres.Result)
						{
							if (expres.Expression != null && IsGrouping(expres.Expression, MappingSchema))
							{
								isHaving = true;
								return false;
							}

							makeSubQuery = true;
						}
						else
						{
							if (IsGrouping(expr, MappingSchema))
							{
								isHaving = true;
								return false;
							}

							isWhere = ctx.IsExpression(expr, 0, RequestFor.Field).Result;
						}

						return false;
					}

					case ExpressionType.Call:
						{
							var e = (MethodCallExpression)expr;

							if (Expressions.ConvertMember(MappingSchema, e.Object?.Type, e.Method) != null)
								return true;

							if (IsGrouping(e, MappingSchema))
							{
								isHaving = true;
								return false;
							}

							break;
						}

					case ExpressionType.Parameter:
						{
							var ctx = GetContext(context, expr);

							if (ctx != null)
							{
								if (ctx.IsExpression(expr, 0, RequestFor.Expression).Result)
									makeSubQuery = true;
							}

							isWhere = true;

							break;
						}
				}

				return true;
			});

			makeHaving = isHaving && !isWhere;
			return makeSubQuery || isHaving && isWhere;
		}

		bool IsGrouping(Expression expression, MappingSchema mappingSchema)
		{
			switch (expression.NodeType)
			{
				case ExpressionType.MemberAccess:
				{
					var ma = (MemberExpression)expression;
					return ma.Expression != null && typeof(IGrouping<,>).IsSameOrParentOf(ma.Expression.Type);
				}

				case ExpressionType.Call:
				{
					var mce = (MethodCallExpression)expression;

					if (mce.Object != null && typeof(IGrouping<,>).IsSameOrParentOf(mce.Object.Type))
						return true;

					if (mce.Method == Methods.LinqToDB.GroupBy.Grouping)
						return true;

					return mce.Arguments.Any(a => typeof(IGrouping<,>).IsSameOrParentOf(a.Type));
				}
			}

			return false;
		}

		#endregion

		#region BuildTake

		public void BuildTake(IBuildContext context, ISqlExpression expr, TakeHints? hints)
		{
			var sql = context.SelectQuery;

			sql.Select.Take(expr, hints);

			if (sql.Select.SkipValue != null &&
				 DataContext.SqlProviderFlags.IsTakeSupported &&
				!DataContext.SqlProviderFlags.GetIsSkipSupportedFlag(sql.Select.TakeValue, sql.Select.SkipValue))
				sql.Select.Take(
					new SqlBinaryExpression(typeof(int), sql.Select.SkipValue, "+", sql.Select.TakeValue!, Precedence.Additive), hints);
		}

		#endregion

		#region SubQueryToSql

		public IBuildContext GetSubQuery(IBuildContext context, MethodCallExpression expr)
		{
			var info = new BuildInfo(context, expr, new SelectQuery { ParentSelect = context.SelectQuery });
			var ctx  = BuildSequence(info);

			if (ctx.SelectQuery.Select.Columns.Count == 0) 
			{
				if (ctx.IsExpression(null, 0, RequestFor.Field).Result)
					ctx.ConvertToIndex(null, 0, ConvertFlags.Field);
				if (ctx.IsExpression(null, 0, RequestFor.Expression).Result)
					ctx.ConvertToIndex(null, 0, ConvertFlags.All);
			}

			return ctx;
		}

		internal ISqlExpression SubQueryToSql(IBuildContext context, MethodCallExpression expression)
		{
			var sequence = GetSubQuery(context, expression);
			var subSql   = sequence.GetSubQuery(context);

			if (subSql == null)
			{
				var query    = context.SelectQuery;
				var subQuery = sequence.SelectQuery;

				// This code should be moved to context.
				//
				if (!query.GroupBy.IsEmpty && !subQuery.Where.IsEmpty)
				{
					var fromGroupBy = sequence.SelectQuery.Properties
						.OfType<Tuple<string,SelectQuery>>()
						.Any(p => p.Item1 == "from_group_by" && ReferenceEquals(p.Item2, context.SelectQuery));

					if (fromGroupBy)
					{
						if (subQuery.Select.Columns.Count == 1 &&
							subQuery.Select.Columns[0].Expression.ElementType == QueryElementType.SqlFunction &&
							subQuery.GroupBy.IsEmpty && !subQuery.Select.HasModifier && !subQuery.HasSetOperators &&
							subQuery.Where.SearchCondition.Conditions.Count == 1)
						{
							var cond = subQuery.Where.SearchCondition.Conditions[0];

							if (cond.Predicate.ElementType == QueryElementType.ExprExprPredicate && query.GroupBy.Items.Count == 1 ||
								cond.Predicate.ElementType == QueryElementType.SearchCondition &&
								query.GroupBy.Items.Count == ((SqlSearchCondition)cond.Predicate).Conditions.Count)
							{
								var func = (SqlFunction)subQuery.Select.Columns[0].Expression;

								if (CountBuilder.MethodNames.Contains(func.Name))
									return SqlFunction.CreateCount(func.SystemType, query);
							}
						}
					}
				}

				subSql = sequence.SelectQuery;
			}

			return subSql;
		}

		#endregion

		#region IsSubQuery

		bool IsSubQuery(IBuildContext context, MethodCallExpression call)
		{
			var isAggregate = call.IsAggregate(MappingSchema);

			if (isAggregate || call.IsQueryable())
			{
				var info = new BuildInfo(context, call, new SelectQuery { ParentSelect = context.SelectQuery });

				if (!IsSequence(info))
					return false;

				var arg = call.Arguments[0];

				if (isAggregate)
					while (arg.NodeType == ExpressionType.Call && ((MethodCallExpression)arg).Method.Name == "Select")
						arg = ((MethodCallExpression)arg).Arguments[0];

				arg = arg.SkipPathThrough();
				arg = arg.SkipMethodChain(MappingSchema);

				var mc = arg as MethodCallExpression;

				while (mc != null)
				{
					if (!mc.IsQueryable())
					{
						if (mc.IsAssociation(MappingSchema))
							return true;

						return GetTableFunctionAttribute(mc.Method) != null;
					}

					mc = mc.Arguments[0] as MethodCallExpression;
				}

				return arg.NodeType == ExpressionType.Call || IsSubQuerySource(context, arg);
			}

			return false;
		}

		bool IsSubQuerySource(IBuildContext context, Expression expr)
		{
			if (expr == null)
				return false;

			var ctx = GetContext(context, expr);

			if (ctx != null && ctx.IsExpression(expr, 0, RequestFor.Object).Result)
				return true;

			while (expr != null)
			{
				switch (expr)
				{
					case MemberExpression me:
						expr = me.Expression;
						continue;
					case MethodCallExpression mc when mc.IsQueryable("AsQueryable"):
						expr = mc.Arguments[0];
						continue;
				}

				break;
			}

			return expr != null && expr.NodeType == ExpressionType.Constant;
		}

		bool IsGroupJoinSource(IBuildContext context, MethodCallExpression call)
		{
			if (!call.IsQueryable() || CountBuilder.MethodNames.Contains(call.Method.Name))
				return false;

			Expression expr = call;

			while (expr.NodeType == ExpressionType.Call)
				expr = ((MethodCallExpression)expr).Arguments[0];

			var ctx = GetContext(context, expr);

			return ctx != null && ctx.IsExpression(expr, 0, RequestFor.GroupJoin).Result;
		}

		#endregion

		#region ConvertExpression

		interface IConvertHelper
		{
			Expression ConvertNull(MemberExpression expression);
		}

		class ConvertHelper<T> : IConvertHelper
			where T : struct
		{
			public Expression ConvertNull(MemberExpression expression)
			{
				return Expression.Call(
					null,
					MemberHelper.MethodOf<T?>(p => Sql.ToNotNull(p)),
					expression.Expression);
			}
		}

		internal Expression ConvertExpression(Expression expression)
		{
			return expression.Transform(e =>
			{
				if (CanBeConstant(e) || CanBeCompiled(e))
				//if ((CanBeConstant(e) || CanBeCompiled(e)) && !PreferServerSide(e))
					return new TransformInfo(e, true);

				switch (e.NodeType)
				{
					//This is to handle VB's weird expression generation when dealing with nullable properties.
					case ExpressionType.Coalesce:
						{
							var b = (BinaryExpression)e;

							if (b.Left is BinaryExpression equalityLeft && b.Right is ConstantExpression constantRight)
								if (equalityLeft.Type.GetGenericTypeDefinition() == typeof(Nullable<>))
									if (equalityLeft.NodeType == ExpressionType.Equal && equalityLeft.Left.Type == equalityLeft.Right.Type)
										if (constantRight.Value is bool val && val == false)
											return new TransformInfo(equalityLeft, false);

							break;
						}

					case ExpressionType.New:
						{
							var ex = ConvertNew((NewExpression)e);
							if (ex != null)
								return new TransformInfo(ConvertExpression(ex));
							break;
						}

					case ExpressionType.Call:
						{
							var expr = (MethodCallExpression)e;

							if (expr.Method.IsSqlPropertyMethodEx())
							{
								// transform Sql.Property into member access
								if (expr.Arguments[1].Type != typeof(string))
									throw new ArgumentException("Only strings are allowed for member name in Sql.Property expressions.");

								var entity           = ConvertExpression(expr.Arguments[0]);
								var memberName       = (string)expr.Arguments[1].EvaluateExpression()!;
								var entityDescriptor = MappingSchema.GetEntityDescriptor(entity.Type);

								var memberInfo = entityDescriptor[memberName]?.MemberInfo ?? entityDescriptor.Associations
													 .SingleOrDefault(a => a.MemberInfo.Name == memberName)?.MemberInfo;
								if (memberInfo == null)
									memberInfo = MemberHelper.GetMemberInfo(expr);

								return new TransformInfo(ConvertExpression(Expression.MakeMemberAccess(entity, memberInfo)));
							}

							var cm = ConvertMethod(expr);
							if (cm != null)
								//TODO: looks like a mess: ConvertExpression can not work without OptimizeExpression
								return new TransformInfo(OptimizeExpression(ConvertExpression(cm)));
							break;
						}

					case ExpressionType.MemberAccess:
						{
							var ma = (MemberExpression)e;
							var l  = Expressions.ConvertMember(MappingSchema, ma.Expression?.Type, ma.Member);

							if (l != null)
							{
								var body = l.Body.Unwrap();
								var expr = body.Transform(wpi => wpi.NodeType == ExpressionType.Parameter ? ma.Expression! : wpi);

								if (expr.Type != e.Type)
									expr = new ChangeTypeExpression(expr, e.Type);

								//TODO: looks like a mess: ConvertExpression can not work without OptimizeExpression
								return new TransformInfo(OptimizeExpression(ConvertExpression(expr)));
							}

							if (ma.Member.IsNullableValueMember())
							{
								var ntype  = typeof(ConvertHelper<>).MakeGenericType(ma.Type);
								var helper = (IConvertHelper)Activator.CreateInstance(ntype)!;
								var expr   = helper.ConvertNull(ma);

								return new TransformInfo(ConvertExpression(expr));
							}

							if (ma.Member.DeclaringType == typeof(TimeSpan))
							{
								switch (ma.Expression!.NodeType)
								{
									case ExpressionType.Subtract       :
									case ExpressionType.SubtractChecked:

										Sql.DateParts datePart;

										switch (ma.Member.Name)
										{
											case "TotalMilliseconds" : datePart = Sql.DateParts.Millisecond; break;
											case "TotalSeconds"      : datePart = Sql.DateParts.Second;      break;
											case "TotalMinutes"      : datePart = Sql.DateParts.Minute;      break;
											case "TotalHours"        : datePart = Sql.DateParts.Hour;        break;
											case "TotalDays"         : datePart = Sql.DateParts.Day;         break;
											default                  : return new TransformInfo(e);
										}

										var ex = (BinaryExpression)ma.Expression;
										if (ex.Left.Type == typeof(DateTime)
											&& ex.Right.Type == typeof(DateTime))
										{
											var method = MemberHelper.MethodOf(
												() => Sql.DateDiff(Sql.DateParts.Day, DateTime.MinValue, DateTime.MinValue));

											var call   =
												Expression.Convert(
													Expression.Call(
														null,
														method,
														Expression.Constant(datePart),
														Expression.Convert(ex.Right, typeof(DateTime?)),
														Expression.Convert(ex.Left,  typeof(DateTime?))),
													typeof(double));

											return new TransformInfo(ConvertExpression(call));
										}
										else
										{
											var method = MemberHelper.MethodOf(
												() => Sql.DateDiff(Sql.DateParts.Day, DateTimeOffset.MinValue, DateTimeOffset.MinValue));

											var call   =
												Expression.Convert(
													Expression.Call(
														null,
														method,
														Expression.Constant(datePart),
														Expression.Convert(ex.Right, typeof(DateTimeOffset?)),
														Expression.Convert(ex.Left,  typeof(DateTimeOffset?))),
													typeof(double));

											return new TransformInfo(ConvertExpression(call));
										}
								}
							}

							break;
						}

					default:
						{
							if (e is BinaryExpression binary)
							{
								var l = Expressions.ConvertBinary(MappingSchema, binary);
								if (l != null)
								{
									var body = l.Body.Unwrap();
									var expr = body.Transform(wpi =>
									{
										if (wpi.NodeType == ExpressionType.Parameter)
										{
											if (l.Parameters[0] == wpi)
												return binary.Left;
											if (l.Parameters[1] == wpi)
												return binary.Right;
										}

										return wpi;
									});

									if (expr.Type != e.Type)
										expr = new ChangeTypeExpression(expr, e.Type);

									return new TransformInfo(ConvertExpression(expr));
								}
							}
							break;
						}
				}

				return new TransformInfo(e);
			});
		}

		Expression? ConvertMethod(MethodCallExpression pi)
		{
			LambdaExpression? lambda = null;

			if (!pi.Method.IsStatic && pi.Object != null && pi.Object.Type != pi.Method.DeclaringType)
			{
				var concreteTypeMemberInfo = pi.Object.Type.GetMemberEx(pi.Method);
				if (concreteTypeMemberInfo != null)
					lambda = Expressions.ConvertMember(MappingSchema, pi.Object.Type, concreteTypeMemberInfo);
			}

			if (lambda == null)
				lambda = Expressions.ConvertMember(MappingSchema, pi.Object?.Type, pi.Method);

			return lambda == null ? null : ConvertMethod(pi, lambda);
		}

		static Expression ConvertMethod(MethodCallExpression pi, LambdaExpression lambda)
		{
			var ef    = lambda.Body.Unwrap();
			var parms = new Dictionary<ParameterExpression,int>(lambda.Parameters.Count);
			var pn    = pi.Method.IsStatic ? 0 : -1;

			foreach (var p in lambda.Parameters)
				parms.Add(p, pn++);

			var pie = ef.Transform(wpi =>
			{
				if (wpi.NodeType == ExpressionType.Parameter)
				{
					if (parms.TryGetValue((ParameterExpression)wpi, out var n))
					{
						if (n >= pi.Arguments.Count)
						{
							if (DataContextParam.Type.IsSameOrParentOf(wpi.Type))
							{
								if (DataContextParam.Type != wpi.Type)
									return Expression.Convert(DataContextParam, wpi.Type);
								return DataContextParam;
							}

							throw new LinqToDBException($"Can't convert {wpi} to expression.");
						}

						var result = n < 0 ? pi.Object : pi.Arguments[n];
						
						if (result.Type != wpi.Type)
						{
							if (result.Type.IsEnum)
								result = Expression.Convert(result, wpi.Type);
						}						

						return result;
					}
				}

				return wpi;
			});

			if (pi.Method.ReturnType != pie.Type)
				pie = new ChangeTypeExpression(pie, pi.Method.ReturnType);

			return pie;
		}

		Expression? ConvertNew(NewExpression pi)
		{
			var lambda = Expressions.ConvertMember(MappingSchema, pi.Type, pi.Constructor);

			if (lambda != null)
			{
				var ef    = lambda.Body.Unwrap();
				var parms = new Dictionary<string,int>(lambda.Parameters.Count);
				var pn    = 0;

				foreach (var p in lambda.Parameters)
					parms.Add(p.Name, pn++);

				return ef.Transform(wpi =>
				{
					if (wpi.NodeType == ExpressionType.Parameter)
					{
						var pe   = (ParameterExpression)wpi;
						var n    = parms[pe.Name];
						return pi.Arguments[n];
					}

					return wpi;
				});
			}

			return null;
		}

		#endregion

		#region BuildExpression

		public SqlInfo[] ConvertExpressions(IBuildContext context, Expression expression, ConvertFlags queryConvertFlag, ColumnDescriptor? columnDescriptor)
		{
			expression = ConvertExpression(expression).UnwrapConvertToObject();

			switch (expression.NodeType)
			{
				case ExpressionType.New :
					{
						var expr = (NewExpression)expression;

// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper disable HeuristicUnreachableCode
						if (expr.Members == null)
							return Array<SqlInfo>.Empty;
// ReSharper restore HeuristicUnreachableCode
// ReSharper restore ConditionIsAlwaysTrueOrFalse

						var ed = context.Builder.MappingSchema.GetEntityDescriptor(expr.Type);
						return expr.Arguments
							.Select((arg,i) =>
							{
								var mi = expr.Members[i];
								if (mi is MethodInfo info)
									mi = info.GetPropertyInfo();

								var descriptor = ed.FindColumnDescriptor(mi);

								return ConvertExpressions(context, arg.UnwrapConvertToObject(), queryConvertFlag, descriptor).Select(si => si.Clone(mi));
							})
							.SelectMany(si => si)
							.ToArray();
					}

				case ExpressionType.MemberInit :
					{
						var expr = (MemberInitExpression)expression;
						var ed   = context.Builder.MappingSchema.GetEntityDescriptor(expr.Type);
						var dic  = TypeAccessor.GetAccessor(expr.Type).Members
							.Select((m,i) => new { m, i })
							.ToDictionary(_ => _.m.MemberInfo, _ => _.i);

						return expr.Bindings
							.Where  (b => b is MemberAssignment)
							.Cast<MemberAssignment>()
							.OrderBy(b => dic[expr.Type.GetMemberEx(b.Member)!])
							.Select (a =>
							{
								var mi = a.Member;
								if (mi is MethodInfo info)
									mi = info.GetPropertyInfo();

								var descriptor = ed.FindColumnDescriptor(mi);

								return ConvertExpressions(context, a.Expression, queryConvertFlag, descriptor).Select(si => si.Clone(mi));
							})
							.SelectMany(si => si)
							.ToArray();
					}
				case ExpressionType.Call         :
					{
						var callCtx = GetContext(context, expression);
						if (callCtx != null)
						{
							var mc = (MethodCallExpression)expression;
							if (IsSubQuery(callCtx, mc))
							{
								var subQueryContextInfo = GetSubQueryContext(callCtx, mc);
								if (subQueryContextInfo.Context.IsExpression(null, 0, RequestFor.Object).Result)
								{
									var info = subQueryContextInfo.Context.ConvertToSql(null, 0, ConvertFlags.All);
									return info;
								}

								return new[] { new SqlInfo (subQueryContextInfo.Context.SelectQuery) };
							}
						}
						break;
					}
				case ExpressionType.NewArrayInit:
					{
						var expr = (NewArrayExpression)expression;
						var sql  = expr.Expressions
							.Select(arg => ConvertExpressions(context, arg, queryConvertFlag, columnDescriptor))
							.SelectMany(si => si)
							.ToArray();

						return sql;
					}
				case ExpressionType.ListInit:
					{
						var expr = (ListInitExpression)expression;
						var sql  = expr.Initializers
							.SelectMany(init => init.Arguments)
							.Select(arg => ConvertExpressions(context, arg, queryConvertFlag, columnDescriptor))
							.SelectMany(si => si)
							.ToArray();

						return sql;
					}
			}

			var ctx = GetContext(context, expression);

			if (ctx != null && ctx.IsExpression(expression, 0, RequestFor.Object).Result)
				return ctx.ConvertToSql(expression, 0, queryConvertFlag);

			return new[] { new SqlInfo(ConvertToSql(context, expression, false, columnDescriptor)) };
		}

		public ISqlExpression ConvertToSqlExpression(IBuildContext context, Expression expression, ColumnDescriptor? columnDescriptor, bool isPureExpression)
		{
			var expr = ConvertExpression(expression);
			return ConvertToSql(context, expr, false, columnDescriptor, isPureExpression);
		}

		public ISqlExpression ConvertToExtensionSql(IBuildContext context, Expression expression, ColumnDescriptor? columnDescriptor)
		{
			expression = expression.Unwrap();

			if (typeof(Sql.IQueryableContainer).IsSameOrParentOf(expression.Type))
			{
				Expression preparedExpression;
				if (expression.NodeType == ExpressionType.Call)
					preparedExpression = ((MethodCallExpression)expression).Arguments[0];
				else 
					preparedExpression = ((Sql.IQueryableContainer)expression.EvaluateExpression()!).Query.Expression;
				return ConvertToExtensionSql(context, preparedExpression, columnDescriptor);
			}

			if (expression is LambdaExpression lambda)
			{
				var saveParent = context.Parent;
				ExpressionContext exprCtx;

				IBuildContext valueSequence = context;

				if (context is SelectContext sc && sc.Sequence[0] is GroupByBuilder.GroupByContext)
					valueSequence = sc.Sequence[0];

				if (valueSequence is GroupByBuilder.GroupByContext groupByContext)
				{
					valueSequence = groupByContext.Element;
				}

				exprCtx = new ExpressionContext(valueSequence.Parent, valueSequence, lambda);

				var result = ConvertToSql(exprCtx, lambda.Body, false, columnDescriptor);
				ReplaceParent(context.Parent!, saveParent);
				if (!(result is SqlField field) || field.Table!.All != field)
					return result;
				result = context.ConvertToSql(null, 0, ConvertFlags.Field).Select(_ => _.Sql).FirstOrDefault();
				return result;
			}

			if (!MappingSchema.IsScalarType(expression.Type) && typeof(IQueryable<>).IsSameOrParentOf(expression.Type))
				return context.ConvertToSql(null, 0, ConvertFlags.Field).Select(_ => _.Sql).FirstOrDefault();

			return ConvertToSql(context, expression, false, columnDescriptor);
		}

		public ParameterAccessor? RegisterParameter(Expression expression) 
		{
			if (typeof(IToSqlConverter).IsSameOrParentOf(expression.Type))
			{
				//TODO: Check this
				var sql = ConvertToSqlConvertible(expression);
				if (sql != null)
					return null;
			}

			if (!PreferServerSide(expression, false))
			{
				if (CanBeConstant(expression))
					return null;

				if (CanBeCompiled(expression))
				{
					return BuildParameter(expression, null);
				}
			}

			return null;
		}

		public ISqlExpression ConvertToSql(IBuildContext? context, Expression expression, bool unwrap = false, ColumnDescriptor? columnDescriptor = null, bool isPureExpression = false)
		{
			if (typeof(IToSqlConverter).IsSameOrParentOf(expression.Type))
			{
				var sql = ConvertToSqlConvertible(expression);
				if (sql != null)
					return sql;
			}

			if (!PreferServerSide(expression, false))
			{
				if (columnDescriptor?.ValueConverter == null && CanBeConstant(expression))
					return BuildConstant(expression, columnDescriptor);

				if (CanBeCompiled(expression))
					return BuildParameter(expression, columnDescriptor).SqlParameter;
			}

			if (unwrap)
				expression = expression.Unwrap();

			switch (expression.NodeType)
			{
				case ExpressionType.AndAlso            :
				case ExpressionType.OrElse             :
				case ExpressionType.Not                :
				case ExpressionType.Equal              :
				case ExpressionType.NotEqual           :
				case ExpressionType.GreaterThan        :
				case ExpressionType.GreaterThanOrEqual :
				case ExpressionType.LessThan           :
				case ExpressionType.LessThanOrEqual    :
					{
						var condition = new SqlSearchCondition();
						BuildSearchCondition(context, expression, condition.Conditions);
						return condition;
					}

				case ExpressionType.And                :
				case ExpressionType.Or                 :
					{
						if (expression.Type == typeof(bool))
							goto case ExpressionType.AndAlso;
						goto case ExpressionType.Add;
					}

				case ExpressionType.Add                :
				case ExpressionType.AddChecked         :
				case ExpressionType.Divide             :
				case ExpressionType.ExclusiveOr        :
				case ExpressionType.Modulo             :
				case ExpressionType.Multiply           :
				case ExpressionType.MultiplyChecked    :
				case ExpressionType.Power              :
				case ExpressionType.Subtract           :
				case ExpressionType.SubtractChecked    :
				case ExpressionType.Coalesce           :
					{
						var e = (BinaryExpression)expression;
						
						ISqlExpression l;
						ISqlExpression r;
						var shouldCheckColumn =
							e.Left.Type.ToNullableUnderlying() == e.Right.Type.ToNullableUnderlying();

						if (shouldCheckColumn)
						{
							var ls = GetContext(context, e.Left);
							if (ls?.IsExpression(e.Left, 0, RequestFor.Field).Result == true)
							{
								l = ConvertToSql(context, e.Left);
								r = ConvertToSql(context, e.Right, true, QueryHelper.GetColumnDescriptor(l) ?? columnDescriptor);
							}
							else
							{
								r = ConvertToSql(context, e.Right, true);
								l = ConvertToSql(context, e.Left, false, QueryHelper.GetColumnDescriptor(r) ?? columnDescriptor);
							}
						}
						else
						{
							l = ConvertToSql(context, e.Left, true, columnDescriptor);
							r = ConvertToSql(context, e.Right, true, null);
						}

						var t = e.Type;

						switch (expression.NodeType)
						{
							case ExpressionType.Add             :
							case ExpressionType.AddChecked      : return new SqlBinaryExpression(t, l, "+", r, Precedence.Additive);
							case ExpressionType.And             : return new SqlBinaryExpression(t, l, "&", r, Precedence.Bitwise);
							case ExpressionType.Divide          : return new SqlBinaryExpression(t, l, "/", r, Precedence.Multiplicative);
							case ExpressionType.ExclusiveOr     : return new SqlBinaryExpression(t, l, "^", r, Precedence.Bitwise);
							case ExpressionType.Modulo          : return new SqlBinaryExpression(t, l, "%", r, Precedence.Multiplicative);
							case ExpressionType.Multiply:
							case ExpressionType.MultiplyChecked : return new SqlBinaryExpression(t, l, "*", r, Precedence.Multiplicative);
							case ExpressionType.Or              : return new SqlBinaryExpression(t, l, "|", r, Precedence.Bitwise);
							case ExpressionType.Power           : return new SqlFunction(t, "Power", l, r);
							case ExpressionType.Subtract        :
							case ExpressionType.SubtractChecked : return new SqlBinaryExpression(t, l, "-", r, Precedence.Subtraction);
							case ExpressionType.Coalesce        :
								{
									if (QueryHelper.UnwrapExpression(r) is SqlFunction c)
									{
										if (c.Name == "Coalesce")
										{
											var parms = new ISqlExpression[c.Parameters.Length + 1];

											parms[0] = l;
											c.Parameters.CopyTo(parms, 1);

											return new SqlFunction(t, "Coalesce", parms);
										}
									}

									return new SqlFunction(t, "Coalesce", l, r);
								}
						}

						break;
					}

				case ExpressionType.UnaryPlus      :
				case ExpressionType.Negate         :
				case ExpressionType.NegateChecked  :
					{
						var e = (UnaryExpression)expression;
						var o = ConvertToSql(context, e.Operand);
						var t = e.Type;

						switch (expression.NodeType)
						{
							case ExpressionType.UnaryPlus     : return o;
							case ExpressionType.Negate        :
							case ExpressionType.NegateChecked :
								return new SqlBinaryExpression(t, new SqlValue(-1), "*", o, Precedence.Multiplicative);
						}

						break;
					}

				case ExpressionType.Convert        :
				case ExpressionType.ConvertChecked :
					{
						var e = (UnaryExpression)expression;

						var o = ConvertToSql(context, e.Operand);

						if (e.Method == null && e.IsLifted)
							return o;

						if (e.Type == typeof(bool) && e.Operand.Type == typeof(SqlBoolean))
							return o;

						var t = e.Operand.Type;
						var s = SqlDataType.GetDataType(t);

						if (o.SystemType != null && s.Type.SystemType == typeof(object))
						{
							t = o.SystemType;
							s = SqlDataType.GetDataType(t);
						}

						if (e.Type == t ||
							t.IsEnum      && Enum.GetUnderlyingType(t)      == e.Type ||
							e.Type.IsEnum && Enum.GetUnderlyingType(e.Type) == t)
							return o;

						return new SqlFunction(e.Type, "$Convert$", SqlDataType.GetDataType(e.Type), s, o);
					}

				case ExpressionType.Conditional    :
					{
						var e = (ConditionalExpression)expression;
						var s = ConvertToSql(context, e.Test);
						var t = ConvertToSql(context, e.IfTrue);
						var f = ConvertToSql(context, e.IfFalse);

						if (QueryHelper.UnwrapExpression(f) is SqlFunction c && c.Name == "CASE")
						{
							var parms = new ISqlExpression[c.Parameters.Length + 2];

							parms[0] = s;
							parms[1] = t;
							c.Parameters.CopyTo(parms, 2);

							return new SqlFunction(e.Type, "CASE", parms) { CanBeNull = false };
						}

						return new SqlFunction(e.Type, "CASE", s, t, f) { CanBeNull = false };
					}

				case ExpressionType.MemberAccess :
					{
						var ma   = (MemberExpression)expression;
						var attr = GetExpressionAttribute(ma.Member);

						if (attr != null)
						{
							var converted = attr.GetExpression(DataContext, context!.SelectQuery, ma,
								(e, descriptor) => ConvertToExtensionSql(context, e, descriptor));

							if (converted == null)
							{
								if (attr.ExpectExpression)
								{
									var exp = ConvertToSql(context, ma.Expression);
									converted = attr.GetExpression(ma.Member, exp);
								}
								else
								{
									converted = attr.GetExpression(ma.Member);
								}
							}

							return converted;
						}

						var ctx = GetContext(context, expression);

						if (ctx != null)
						{
							var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

							switch (sql.Length)
							{
								case 0  : break;
								case 1  : return sql[0].Sql;
								default : throw new InvalidOperationException();
							}
						}

						break;
					}

				case ExpressionType.Parameter   :
					{
						var ctx = GetContext(context, expression);

						if (ctx != null)
						{
							var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

							switch (sql.Length)
							{
								case 0  : break;
								case 1  : return sql[0].Sql;
								default : throw new InvalidOperationException();
							}
						}

						break;
					}

				case ExpressionType.Extension   :
					{
						var ctx = GetContext(context, expression);

						if (ctx != null)
						{
							var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

							switch (sql.Length)
							{
								case 0  : break;
								case 1  : return sql[0].Sql;
								default : throw new InvalidOperationException();
							}
						}

						break;
					}

				case ExpressionType.Call        :
					{
						var e = (MethodCallExpression)expression;

						var isAggregation = e.IsAggregate(MappingSchema);
						if (isAggregation && !e.IsQueryable())
						{
							var arg = e.Arguments[0];
							var enumerableType = arg.Type;
							if (!EagerLoading.IsEnumerableType(enumerableType, MappingSchema))
								isAggregation = false;
							else
							{
								var elementType = EagerLoading.GetEnumerableElementType(enumerableType, MappingSchema);
								if (!e.Method.GetParameters()[0].ParameterType.IsSameOrParentOf(typeof(IEnumerable<>).MakeGenericType(elementType)))
									isAggregation = false;
							}
						}

						if ((isAggregation || e.IsQueryable()) && !ContainsBuilder.IsConstant(e))
						{
							if (IsSubQuery(context!, e))
								return SubQueryToSql(context!, e);

							if (isAggregation)
							{
								var ctx = GetContext(context, expression);

								if (ctx != null)
								{
									var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

									if (sql.Length != 1)
										throw new InvalidOperationException();

									return sql[0].Sql;
								}

								break;
							}

							return SubQueryToSql(context!, e);
						}

						var expr = ConvertMethod(e);

						if (expr != null)
							return ConvertToSql(context, expr, unwrap);

						var attr = GetExpressionAttribute(e.Method);

						if (attr != null)
						{
							return ConvertExtensionToSql(context!, attr, e);
						}

						if (e.Method.IsSqlPropertyMethodEx())
							return ConvertToSql(context, ConvertExpression(expression), unwrap);

						if (e.Method.DeclaringType == typeof(string) && e.Method.Name == "Format")
						{
							return ConvertFormatToSql(context, e, isPureExpression);
						}

						if (e.IsSameGenericMethod(Methods.LinqToDB.SqlExt.Alias))
						{
							var sql = ConvertToSql(context, e.Arguments[0], unwrap);
							return sql;
						}

						break;
					}

				case ExpressionType.Invoke :
					{
						var pi = (InvocationExpression)expression;
						var ex = pi.Expression;

						if (ex.NodeType == ExpressionType.Quote)
							ex = ((UnaryExpression)ex).Operand;

						if (ex.NodeType == ExpressionType.Lambda)
						{
							var l   = (LambdaExpression)ex;
							var dic = new Dictionary<Expression,Expression>();

							for (var i = 0; i < l.Parameters.Count; i++)
								dic.Add(l.Parameters[i], pi.Arguments[i]);

							var pie = l.Body.Transform(wpi => dic.TryGetValue(wpi, out var ppi) ? ppi : wpi);

							return ConvertToSql(context, pie);
						}

						break;
					}

				case ExpressionType.TypeIs :
					{
						var condition = new SqlSearchCondition();
						BuildSearchCondition(context, expression, condition.Conditions);
						return condition;
					}

				case ChangeTypeExpression.ChangeTypeType :
					return ConvertToSql(context, ((ChangeTypeExpression)expression).Expression);

				case ExpressionType.Constant:
					{
						var cnt = (ConstantExpression)expression;
						if (cnt.Value is ISqlExpression sql)
							return sql;
						break;
					}
			}

			if (expression.Type == typeof(bool) && _convertedPredicates.Add(expression))
			{
				var predicate = ConvertPredicate(context, expression);
				_convertedPredicates.Remove(expression);
				if (predicate != null)
					return new SqlSearchCondition(new SqlCondition(false, predicate));
			}

			throw new LinqException("'{0}' cannot be converted to SQL.", expression);
		}

		public ISqlExpression ConvertFormatToSql(IBuildContext? context, MethodCallExpression mc, bool isPureExpression)
		{
			// TODO: move PrepareRawSqlArguments to more correct location
			TableBuilder.PrepareRawSqlArguments(mc, null,
				out var format, out var arguments);
			var sqlArguments = arguments.Select(a => ConvertToSql(context, a)).ToArray();

			if (isPureExpression)
			{
				return new SqlExpression(mc.Type, format, Precedence.Primary, sqlArguments);
			}

			return QueryHelper.ConvertFormatToConcatenation(format, sqlArguments);
		}

		public ISqlExpression ConvertExtensionToSql(IBuildContext context, Sql.ExpressionAttribute attr, MethodCallExpression mc)
		{
			var inlineParameters = DataContext.InlineParameters;

			if (attr.InlineParameters)
				DataContext.InlineParameters = true;

			var sqlExpression =
				attr.GetExpression(DataContext, context!.SelectQuery, mc, (e, descriptor) => ConvertToExtensionSql(context, e, descriptor));
			if (sqlExpression != null)
				return sqlExpression;

			var parms = new List<ISqlExpression>();

			if (mc.Object != null)
				parms.Add(ConvertToSql(context, mc.Object));

			ParameterInfo[]? pis = null;

			for (var i = 0; i < mc.Arguments.Count; i++)
			{
				var arg = mc.Arguments[i];

				if (arg is NewArrayExpression nae)
				{
					if (pis == null)
						pis = mc.Method.GetParameters();

					var p = pis[i];

					if (p.GetCustomAttributes(true).OfType<ParamArrayAttribute>().Any())
					{
						parms.AddRange(nae.Expressions.Select(a => ConvertToSql(context, a)));
					}
					else
					{
						parms.Add(ConvertToSql(context, nae));
					}
				}
				else
				{
					parms.Add(ConvertToSql(context, arg));
				}
			}

			DataContext.InlineParameters = inlineParameters;

			return attr.GetExpression(mc.Method, parms.ToArray());
		}

		static ISqlExpression ConvertToSqlConvertible(Expression expression)
		{
			var l = Expression.Lambda<Func<IToSqlConverter>>(expression);
			var f = l.CompileExpression();
			var c = f();

			return c.ToSql(expression);
		}

		readonly HashSet<Expression> _convertedPredicates = new HashSet<Expression>();

		#endregion

		#region IsServerSideOnly

		public bool IsServerSideOnly(Expression expr)
		{
			return _optimizationContext.IsServerSideOnly(expr);
		}

		#endregion

		#region CanBeConstant

		bool CanBeConstant(Expression expr)
		{
			return _optimizationContext.CanBeConstant(expr);
		}

		#endregion

		#region CanBeCompiled

		bool CanBeCompiled(Expression expr)
		{
			return _optimizationContext.CanBeCompiled(expr);
		}

		#endregion

		#region Build Constant

		readonly Dictionary<Tuple<Expression, ColumnDescriptor?>,SqlValue> _constants = new Dictionary<Tuple<Expression, ColumnDescriptor?>,SqlValue>();

		SqlValue BuildConstant(Expression expr, ColumnDescriptor? columnDescriptor)
		{
			var key = Tuple.Create(expr, columnDescriptor);
			if (_constants.TryGetValue(key, out var sqlValue))
				return sqlValue;

			var dbType = columnDescriptor?.GetDbDataType(true).WithSystemType(expr.Type) ?? new DbDataType(expr.Type);

			var unwrapped = expr.Unwrap();
			if (unwrapped != expr && !MappingSchema.ValueToSqlConverter.CanConvert(dbType.SystemType) &&
			    MappingSchema.ValueToSqlConverter.CanConvert(unwrapped.Type))
			{
				dbType = dbType.WithSystemType(unwrapped.Type);
				expr = unwrapped;
			}

			dbType = dbType.WithSystemType(expr.Type);

			if (columnDescriptor != null)
			{
				expr = columnDescriptor.ApplyConversions(expr, dbType, true);
			}
			else
			{
				if (!MappingSchema.ValueToSqlConverter.CanConvert(dbType.SystemType))
					expr = ColumnDescriptor.ApplyConversions(MappingSchema, expr, dbType, null, true);
			}

			var value = expr.EvaluateExpression();

			if (value != null && MappingSchema.ValueToSqlConverter.CanConvert(dbType.SystemType))
				sqlValue = new SqlValue(dbType, value);
			else
			{
				if (value != null && value.GetType().IsEnum)
				{
					var attrs = value.GetType().GetCustomAttributes(typeof(Sql.EnumAttribute), true);

					if (attrs.Length == 0)
						value = MappingSchema.EnumToValue((Enum)value);
				}

				sqlValue = MappingSchema.GetSqlValue(expr.Type, value);
			}

			_constants.Add(key, sqlValue);

			return sqlValue;
		}

		#endregion

		#region Build Parameter

		internal readonly Dictionary<Expression,ParameterAccessor> _parameters = new Dictionary<Expression,ParameterAccessor>();

		internal void AddCurrentSqlParameter(ParameterAccessor parameterAccessor)
		{
			var idx = CurrentSqlParameters.Count;
			CurrentSqlParameters.Add(parameterAccessor);
			parameterAccessor.SqlParameter.AccessorId = idx;
		}

		internal enum BuildParameterType
		{
			Default,
			InPredicate
		}

		public ParameterAccessor BuildParameter(Expression expr, ColumnDescriptor? columnDescriptor, bool forceConstant = false,
			BuildParameterType buildParameterType = BuildParameterType.Default)
		{
			if (_parameters.TryGetValue(expr, out var p))
				return p;

			string? name = null;

			ValueTypeExpression newExpr;
			newExpr = ReplaceParameter(_expressionAccessors, expr, forceConstant, nm => name = nm);

			p = PrepareConvertersAndCreateParameter(newExpr, expr, name, columnDescriptor, buildParameterType);

			var found = p;
			foreach (var accessor in _parameters)
			{
				if (accessor.Value.SqlParameter.Type.Equals(p.SqlParameter.Type))
					continue;

				if (accessor.Key.EqualsTo(expr, DataContext, new Dictionary<Expression, QueryableAccessor>(), null,
					null, compareConstantValues: true))
				{
					found = accessor.Value;
					break;
				}
			}

			// We already have registered parameter for the same expression
			//
			if (!ReferenceEquals(found, p))
				return found;

			_parameters.Add(expr, p);
			AddCurrentSqlParameter(p);

			return p;
		}

		public ParameterAccessor BuildParameterFromArgumentProperty(MethodCallExpression methodCall, int argumentIndex, ColumnDescriptor columnDescriptor,
			BuildParameterType buildParameterType = BuildParameterType.Default)
		{
			var valueAccessor = GenerateArgumentAccessor(methodCall, argumentIndex, null);

			valueAccessor = Expression.MakeMemberAccess(valueAccessor, columnDescriptor.MemberInfo);

			var dataType = columnDescriptor.GetDbDataType(true);
			var newExpr  = new ValueTypeExpression
			{
				DataType             = dataType,
				DbDataTypeExpression = Expression.Constant(dataType),
				ValueExpression      = valueAccessor
			};

			var p = PrepareConvertersAndCreateParameter(newExpr, valueAccessor, null, columnDescriptor,
				buildParameterType);
			AddCurrentSqlParameter(p);

			return p;
		}

		public ParameterAccessor BuildParameterFromArgument(MethodCallExpression methodCall, int argumentIndex, ColumnDescriptor? columnDescriptor,
			BuildParameterType buildParameterType = BuildParameterType.Default)
		{
			var valueAccessor = GenerateArgumentAccessor(methodCall, argumentIndex, columnDescriptor);

			var dataType = new DbDataType(valueAccessor.Type);
			var newExpr  = new ValueTypeExpression
			{
				DataType             = dataType,
				DbDataTypeExpression = Expression.Constant(dataType),
				ValueExpression      = valueAccessor
			};

			var p = PrepareConvertersAndCreateParameter(newExpr, valueAccessor, null, columnDescriptor,
				buildParameterType);
			AddCurrentSqlParameter(p);

			return p;
		}

		Expression? GetActualMethodAccessor(MethodCallExpression methodCall)
		{
			Expression? current = methodCall;
			if (_expressionAccessors.TryGetValue(current, out var methodAccessor))
				return methodAccessor;

			// Looking in known accessors for method with only changed first parameter.
			// Typical case when we have transformed Queryable method chain.
			foreach (var accessorPair in _expressionAccessors)
			{
				if (accessorPair.Key.NodeType != ExpressionType.Call)
					continue;

				var mc = (MethodCallExpression)accessorPair.Key;
				if (mc.Method != methodCall.Method)
					continue;

				var isEqual = true;
				for (int i = 1; i < mc.Arguments.Count; i++)
				{
					isEqual = (mc.Arguments[i].Equals(methodCall.Arguments[i]));
					if (!isEqual)
						break;
				}
				if (isEqual)
				{
					return accessorPair.Value;
				}
			}

			return null;
		}

		Expression GenerateArgumentAccessor(MethodCallExpression methodCall, int argumentIndex, ColumnDescriptor? columnDescriptor)
		{
			var arg = methodCall.Arguments[argumentIndex];
			var methodAccessor = GetActualMethodAccessor(methodCall);
			if (methodAccessor == null)
			{
				// compiled query case
				//
				if (null == arg.Find(e => e == ParametersParam))
					throw new InvalidOperationException($"Method '{methodCall}' does not have accessor.");
				return arg;
			}

			var prop = Expression.Property(methodAccessor, ReflectionHelper.MethodCall.Arguments);
			var valueAccessorExpr = Expression.Call(prop, ReflectionHelper.IndexExpressor<Expression>.Item,
				Expression.Constant(argumentIndex));

			var expectedType = columnDescriptor?.MemberType ?? arg.Type;

			var evaluatedExpr = Expression.Call(null,
				MemberHelper.MethodOf(() => InternalExtensions.EvaluateExpression(null)),
				valueAccessorExpr);

			var valueAccessor = (Expression)evaluatedExpr;
			valueAccessor = Expression.Convert(valueAccessor, expectedType);

			return valueAccessor;
		}

		ParameterAccessor PrepareConvertersAndCreateParameter(ValueTypeExpression newExpr, Expression valueExpression, string? name, ColumnDescriptor? columnDescriptor, BuildParameterType buildParameterType)
		{
			var originalAccessor = newExpr.ValueExpression;
			if (buildParameterType != BuildParameterType.InPredicate)
			{
				if (!typeof(DataParameter).IsSameOrParentOf(newExpr.ValueExpression.Type))
				{
					if (columnDescriptor != null && !(originalAccessor is BinaryExpression))
					{
						newExpr.DataType = columnDescriptor.GetDbDataType(true);
						if (newExpr.ValueExpression.Type != columnDescriptor.MemberType)
						{
							newExpr.ValueExpression = newExpr.ValueExpression.UnwrapConvert()!;
							var memberType = columnDescriptor.MemberType;
							if (newExpr.ValueExpression.Type != memberType)
							{
								if (!newExpr.ValueExpression.Type.IsNullable() || newExpr.ValueExpression.Type.ToNullableUnderlying() != memberType)
								{
									var convertLambda = MappingSchema.GenerateSafeConvert(newExpr.ValueExpression.Type,
										memberType);
									newExpr.ValueExpression =
										InternalExtensions.ApplyLambdaToExpression(convertLambda,
											newExpr.ValueExpression);
								}
							}
						}				

						newExpr.ValueExpression = columnDescriptor.ApplyConversions(newExpr.ValueExpression, newExpr.DataType, true);

						if (name == null)
						{
							if (columnDescriptor.MemberName.Contains('.'))
								name = columnDescriptor.ColumnName;
							else
								name = columnDescriptor.MemberName;

						}

						newExpr.DbDataTypeExpression = Expression.Constant(newExpr.DataType);
					}
					else
					{
						newExpr.ValueExpression = ColumnDescriptor.ApplyConversions(MappingSchema, newExpr.ValueExpression, newExpr.DataType, null, true);
					}
				}

				if (typeof(DataParameter).IsSameOrParentOf(newExpr.ValueExpression.Type))
				{
					newExpr.DbDataTypeExpression = Expression.PropertyOrField(newExpr.ValueExpression, nameof(DataParameter.DbDataType));

					if (columnDescriptor != null)
					{
						var dbDataType = columnDescriptor.GetDbDataType(false);
						newExpr.DbDataTypeExpression = Expression.Call(Expression.Constant(dbDataType),
							DbDataType.WithSetValuesMethodInfo, newExpr.DbDataTypeExpression);
					}

					newExpr.ValueExpression      = Expression.PropertyOrField(newExpr.ValueExpression, nameof(DataParameter.Value));
				}
			}

			name ??= columnDescriptor?.MemberName;

			var p = CreateParameterAccessor(
				DataContext, newExpr.ValueExpression, originalAccessor, newExpr.DbDataTypeExpression, valueExpression, ExpressionParam,
				ParametersParam, DataContextParam, name);

			return p;
		}

		class ValueTypeExpression
		{
			public Expression ValueExpression      = null!;
			public Expression DbDataTypeExpression = null!;

			public DbDataType DataType;
		}

		ValueTypeExpression ReplaceParameter(IDictionary<Expression,Expression> expressionAccessors, Expression expression, bool forceConstant, Action<string> setName)
		{
			var result = new ValueTypeExpression
			{
				DataType             = new DbDataType(expression.Type),
				DbDataTypeExpression = Expression.Constant(new DbDataType(expression.Type), typeof(DbDataType)),
			};

			var unwrapped = expression.Unwrap();
			if (unwrapped.NodeType == ExpressionType.MemberAccess)
			{
				var ma = (MemberExpression)unwrapped;
				setName(ma.Member.Name);
			}

			result.ValueExpression = expression.Transform(expr =>
			{
				if (expr.NodeType == ExpressionType.Constant)
				{
					var c = (ConstantExpression)expr;

					if (forceConstant || !expr.Type.IsConstantable(false))
					{
						if (expressionAccessors.TryGetValue(expr, out var val))
						{
							expr = Expression.Convert(val, expr.Type);

							if (expression.NodeType == ExpressionType.MemberAccess)
							{
								var ma = (MemberExpression)expression;

								var mt = GetMemberDataType(ma.Member);

								if (mt.DataType != DataType.Undefined)
								{
									result.DataType             = result.DataType.WithDataType(mt.DataType);
									result.DbDataTypeExpression = Expression.Constant(mt);
								}

								if (mt.DbType != null)
								{
									result.DataType             = result.DataType.WithDbType(mt.DbType);
									result.DbDataTypeExpression = Expression.Constant(mt);
								}

								if (mt.Length != null)
								{
									result.DataType             = result.DataType.WithLength(mt.Length);
									result.DbDataTypeExpression = Expression.Constant(mt);
								}

								setName(ma.Member.Name);
							}
						}
					}
				}

				return expr;
			});

			return result;
		}

		#endregion

		#region Predicate Converter

		ISqlPredicate ConvertPredicate(IBuildContext? context, Expression expression)
		{
			var isPredicate = true;

			switch (expression.NodeType)
			{
				case ExpressionType.Equal              :
				case ExpressionType.NotEqual           :
				case ExpressionType.GreaterThan        :
				case ExpressionType.GreaterThanOrEqual :
				case ExpressionType.LessThan           :
				case ExpressionType.LessThanOrEqual    :
					{
						var e = (BinaryExpression)expression;
						return ConvertCompare(context, expression.NodeType, e.Left, e.Right);
					}

				case ExpressionType.Call               :
					{
						var e = (MethodCallExpression)expression;

						ISqlPredicate? predicate = null;

						if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)
							return ConvertCompare(context, ExpressionType.Equal, e.Object, e.Arguments[0]);

						if (e.Method.DeclaringType == typeof(string))
						{
							switch (e.Method.Name)
							{
								case "Contains"   : predicate = CreateStringPredicate(context, e, SqlPredicate.SearchString.SearchKind.Contains);   break;
								case "StartsWith" : predicate = CreateStringPredicate(context, e, SqlPredicate.SearchString.SearchKind.StartsWith); break;
								case "EndsWith"   : predicate = CreateStringPredicate(context, e, SqlPredicate.SearchString.SearchKind.EndsWith);   break;
							}
						}
						else if (e.Method.Name == "Contains")
						{
							if (e.Method.DeclaringType == typeof(Enumerable) ||
								typeof(IList).        IsSameOrParentOf(e.Method.DeclaringType!) ||
								typeof(ICollection<>).IsSameOrParentOf(e.Method.DeclaringType!))
							{
								predicate = ConvertInPredicate(context!, e);
							}
						}
						else if (e.Method.Name == "ContainsValue" && typeof(Dictionary<,>).IsSameOrParentOf(e.Method.DeclaringType!))
						{
							var args = e.Method.DeclaringType!.GetGenericArguments(typeof(Dictionary<,>))!;
							var minf = EnumerableMethods
								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)
								.MakeGenericMethod(args[1]);

							var expr = Expression.Call(
								minf,
								ExpressionHelper.PropertyOrField(e.Object!, "Values"),
								e.Arguments[0]);

							predicate = ConvertInPredicate(context!, expr);
						}
						else if (e.Method.Name == "ContainsKey" && typeof(IDictionary<,>).IsSameOrParentOf(e.Method.DeclaringType!))
						{
							var args = e.Method.DeclaringType!.GetGenericArguments(typeof(IDictionary<,>))!;
							var minf = EnumerableMethods
								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)
								.MakeGenericMethod(args[0]);

							var expr = Expression.Call(
								minf,
								ExpressionHelper.PropertyOrField(e.Object!, "Keys"),
								e.Arguments[0]);

							predicate = ConvertInPredicate(context!, expr);
						}
#if NETFRAMEWORK
						else if (e.Method == ReflectionHelper.Functions.String.Like11) predicate = ConvertLikePredicate(context!, e);
						else if (e.Method == ReflectionHelper.Functions.String.Like12) predicate = ConvertLikePredicate(context!, e);
#endif
						else if (e.Method == ReflectionHelper.Functions.String.Like21) predicate = ConvertLikePredicate(context!, e);
						else if (e.Method == ReflectionHelper.Functions.String.Like22) predicate = ConvertLikePredicate(context!, e);

						if (predicate != null)
							return predicate;

						var attr = GetExpressionAttribute(e.Method);

						if (attr != null && attr.GetIsPredicate(expression))
							break;

						isPredicate = false;
						break;
					}

				case ExpressionType.Conditional  :
					return new SqlPredicate.ExprExpr(
							ConvertToSql(context, expression),
							SqlPredicate.Operator.Equal,
							new SqlValue(true), null);

				case ExpressionType.MemberAccess :
					{
						var e = (MemberExpression)expression;

						var attr = GetExpressionAttribute(e.Member);

						if (attr != null && attr.GetIsPredicate(expression))
							break;

						isPredicate = false;
						break;
					}

				case ExpressionType.TypeIs:
					{
						var e   = (TypeBinaryExpression)expression;
						var ctx = GetContext(context, e.Expression);

						if (ctx != null && ctx.IsExpression(e.Expression, 0, RequestFor.Table).Result)
							return MakeIsPredicate(ctx, e);

						break;
					}

				case ExpressionType.Convert:
					{
						var e = (UnaryExpression)expression;

						if (e.Type == typeof(bool) && e.Operand.Type == typeof(SqlBoolean))
							return ConvertPredicate(context, e.Operand);

						isPredicate = false;
						break;
					}

				case ChangeTypeExpression.ChangeTypeType:
					isPredicate = false;
					break;

				default:
					isPredicate = false;
					break;
			}

			var ex = ConvertToSql(context, expression);

			if (!isPredicate && SqlExpression.NeedsEqual(ex))
			{
				var descriptor = QueryHelper.GetColumnDescriptor(ex);
				var trueValue  = ConvertToSql(context, ExpressionHelper.TrueConstant,  false, descriptor);
				var falseValue = ConvertToSql(context, ExpressionHelper.FalseConstant, false, descriptor);

				return new SqlPredicate.IsTrue(ex, trueValue, falseValue, Configuration.Linq.CompareNullsAsValues ? false : (bool?)null, false);
			}

			return new SqlPredicate.Expr(ex);
		}

		#region ConvertCompare

		ISqlPredicate ConvertCompare(IBuildContext? context, ExpressionType nodeType, Expression left, Expression right)
		{
			if (!RestoreCompare(ref left, ref right))
				RestoreCompare(ref right, ref left);

			switch (nodeType)
			{
				case ExpressionType.Equal    :
				case ExpressionType.NotEqual :

					var p = ConvertObjectComparison(nodeType, context!, left, context!, right);
					if (p != null)
						return p;

					p = ConvertObjectNullComparison(context, left, right, nodeType == ExpressionType.Equal);
					if (p != null)
						return p;

					p = ConvertObjectNullComparison(context, right, left, nodeType == ExpressionType.Equal);
					if (p != null)
						return p;

					if (left.NodeType == ExpressionType.New || right.NodeType == ExpressionType.New)
					{
						p = ConvertNewObjectComparison(context!, nodeType, left, right);
						if (p != null)
							return p;
					}

					break;
			}

			var op = nodeType switch
			{
				ExpressionType.Equal              => SqlPredicate.Operator.Equal,
				ExpressionType.NotEqual           => SqlPredicate.Operator.NotEqual,
				ExpressionType.GreaterThan        => SqlPredicate.Operator.Greater,
				ExpressionType.GreaterThanOrEqual => SqlPredicate.Operator.GreaterOrEqual,
				ExpressionType.LessThan           => SqlPredicate.Operator.Less,
				ExpressionType.LessThanOrEqual    => SqlPredicate.Operator.LessOrEqual,
				_                                 => throw new InvalidOperationException(),
			};
			if ((left.NodeType == ExpressionType.Convert || right.NodeType == ExpressionType.Convert) && op.In(SqlPredicate.Operator.Equal, SqlPredicate.Operator.NotEqual))
			{
				var p = ConvertEnumConversion(context!, left, op, right);
				if (p != null)
					return p;
			}

			ISqlExpression l;
			ISqlExpression r;
			var ls = GetContext(context, left);
			if (ls?.IsExpression(left, 0, RequestFor.Field).Result == true)
			{
				l = ConvertToSql(context, left);
				r = ConvertToSql(context, right, true, QueryHelper.GetColumnDescriptor(l));
			}
			else
			{
				r = ConvertToSql(context, right, true);
				l = ConvertToSql(context, left, false, QueryHelper.GetColumnDescriptor(r));
			}

			l = QueryHelper.UnwrapExpression(l);
			r = QueryHelper.UnwrapExpression(r);

			if (l is SqlValue lValue)
				lValue.ValueType = GetDataType(r, lValue.ValueType);

			if (r is SqlValue rValue)
				rValue.ValueType = GetDataType(l, rValue.ValueType);

			switch (nodeType)
			{
				case ExpressionType.Equal   :
				case ExpressionType.NotEqual:

					if (!context!.SelectQuery.IsParameterDependent &&
						(l is SqlParameter && l.CanBeNull || r is SqlParameter && r.CanBeNull))
						context.SelectQuery.IsParameterDependent = true;

					// | (SqlQuery(Select([]) as q), SqlValue(null))
					// | (SqlValue(null), SqlQuery(Select([]) as q))  =>

					var q =
						l.ElementType == QueryElementType.SqlQuery &&
						r.ElementType == QueryElementType.SqlValue &&
						((SqlValue)r).Value == null &&
						((SelectQuery)l).Select.Columns.Count == 0 ?
							(SelectQuery)l :
						r.ElementType == QueryElementType.SqlQuery &&
						l.ElementType == QueryElementType.SqlValue &&
						((SqlValue)l).Value == null &&
						((SelectQuery)r).Select.Columns.Count == 0 ?
							(SelectQuery)r :
							null;

					q?.Select.Columns.Add(new SqlColumn(q, new SqlValue(1)));

					break;
			}

			if (l is SqlSearchCondition)
			{
				l = new SqlFunction(typeof(bool), "CASE", l, new SqlValue(true), new SqlValue(false))
				{
					CanBeNull = false
				};
			}

			if (r is SqlSearchCondition)
			{
				r = new SqlFunction(typeof(bool), "CASE", r, new SqlValue(true), new SqlValue(false))
				{
					CanBeNull = false
				};
			}

			ISqlPredicate? predicate = null;
			if (op.In(SqlPredicate.Operator.Equal, SqlPredicate.Operator.NotEqual))
			{
				bool?           value      = null;
				ISqlExpression? expression = null;
				var             isNullable = false;
				if ((typeof(bool) == left.Type || typeof(bool?) == left.Type) && left.Unwrap() is ConstantExpression lc)
				{
					value      = lc.Value as bool?;
					isNullable = typeof(bool?) == left.Type || r.CanBeNull;
					expression = r;
				}
				else if ((typeof(bool) == right.Type || typeof(bool?) == right.Type) && right.Unwrap() is ConstantExpression rc)
				{
					value      = rc.Value as bool?;
					isNullable = typeof(bool?) == right.Type || l.CanBeNull;
					expression = l;
				}

				if (value != null 
				    && expression != null 
				    && !(expression.ElementType == QueryElementType.SqlValue && ((SqlValue) expression).Value == null))
				{
					var isNot = !value.Value;
					var withNull = false;
					if (op == SqlPredicate.Operator.NotEqual)
					{
						isNot    = !isNot;
						withNull = true;
					}
					var descriptor = QueryHelper.GetColumnDescriptor(expression);
					var trueValue  = ConvertToSql(context, ExpressionHelper.TrueConstant,  false, descriptor);
					var falseValue = ConvertToSql(context, ExpressionHelper.FalseConstant, false, descriptor);

					var withNullValue = Configuration.Linq.CompareNullsAsValues &&
					                    (isNullable || NeedNullCheck(expression))
						? withNull
						: (bool?)null;
					predicate = new SqlPredicate.IsTrue(expression, trueValue, falseValue, withNullValue, isNot);
				}
			}

			if (predicate == null)
				predicate = new SqlPredicate.ExprExpr(l, op, r, Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);
			return predicate;
		}

		// restores original types, lost due to C# compiler optimizations
		// e.g. see https://github.com/linq2db/linq2db/issues/2041
		private static bool RestoreCompare(ref Expression op1, ref Expression op2)
		{
			if (op1.NodeType == ExpressionType.Convert)
			{
				var op1conv = (UnaryExpression)op1;

				// handle char replaced with int
				// (int)chr op CONST
				if (op1.Type == typeof(int) && op1conv.Operand.Type == typeof(char)
					&& (op2.NodeType == ExpressionType.Constant || op2.NodeType == ExpressionType.Convert))
				{
					op1 = op1conv.Operand;
					op2 = op2.NodeType == ExpressionType.Constant
						? Expression.Constant(ConvertTo<char>.From(((ConstantExpression)op2).Value))
						: ((UnaryExpression)op2).Operand;
					return true;
				}
				// (int?)chr? op CONST
				else if (op1.Type == typeof(int?) && op1conv.Operand.Type == typeof(char?)
					&& (op2.NodeType == ExpressionType.Constant
						|| (op2.NodeType == ExpressionType.Convert && ((UnaryExpression)op2).Operand.NodeType == ExpressionType.Convert)))
				{
					op1 = op1conv.Operand;
					op2 = op2.NodeType == ExpressionType.Constant
						? Expression.Constant(ConvertTo<char>.From(((ConstantExpression)op2).Value))
						: ((UnaryExpression)((UnaryExpression)op2).Operand).Operand;
					return true;
				}
				// handle enum replaced with integer
				// here byte/short values replaced with int, int+ values replaced with actual underlying type
				// (int)enum op const
				else if (op1conv.Operand.Type.IsEnum
					&& op2.NodeType == ExpressionType.Constant
						&& (op2.Type == Enum.GetUnderlyingType(op1conv.Operand.Type) || op2.Type == typeof(int)))
				{
					op1 = op1conv.Operand;
					op2 = Expression.Constant(Enum.ToObject(op1conv.Operand.Type, ((ConstantExpression)op2).Value), op1conv.Operand.Type);
					return true;
				}
				// here underlying type used
				// (int?)enum? op (int?)enum
				else if (op1conv.Operand.Type.IsNullable() && Nullable.GetUnderlyingType(op1conv.Operand.Type)!.IsEnum
					&& op2.NodeType == ExpressionType.Convert
					&& op2 is UnaryExpression op2conv2
					&& op2conv2.Operand.NodeType == ExpressionType.Constant
					&& op2conv2.Operand.Type == Nullable.GetUnderlyingType(op1conv.Operand.Type))
				{
					op1 = op1conv.Operand;
					op2 = Expression.Convert(op2conv2.Operand, op1conv.Operand.Type);
					return true;
				}
				// https://github.com/linq2db/linq2db/issues/2039
				// byte, sbyte and ushort comparison operands upcasted to int
				else if (op2.NodeType == ExpressionType.Convert
					&& op2 is UnaryExpression op2conv1
					&& op1conv.Operand.Type == op2conv1.Operand.Type)
				{
					op1 = op1conv .Operand;
					op2 = op2conv1.Operand;
					return true;
				}

				// https://github.com/linq2db/linq2db/issues/2166
				// generates expression:
				// Convert(member, int) == const(value, int)
				// we must replace it with:
				// member == const(value, member_type)
				if (op2 is ConstantExpression const2
					&& const2.Type == typeof(int)
					&& ConvertUtils.TryConvert(const2.Value, op1conv.Operand.Type, out var convertedValue))
				{
					op1 = op1conv.Operand;
					op2 = Expression.Constant(convertedValue, op1conv.Operand.Type);
					return true;
				}
			}

			return false;
		}

		#endregion

		#region ConvertEnumConversion

		ISqlPredicate? ConvertEnumConversion(IBuildContext context, Expression left, SqlPredicate.Operator op, Expression right)
		{
			Expression value;
			Expression operand;

			if (left is MemberExpression)
			{
				operand = left;
				value   = right;
			}
			else if (left.NodeType == ExpressionType.Convert && ((UnaryExpression)left).Operand is MemberExpression)
			{
				operand = ((UnaryExpression)left).Operand;
				value   = right;
			}
			else if (right is MemberExpression)
			{
				operand = right;
				value   = left;
			}
			else if (right.NodeType == ExpressionType.Convert && ((UnaryExpression)right).Operand is MemberExpression)
			{
				operand = ((UnaryExpression)right).Operand;
				value   = left;
			}
			else if (left.NodeType == ExpressionType.Convert)
			{
				operand = ((UnaryExpression)left).Operand;
				value   = right;
			}
			else
			{
				operand = ((UnaryExpression)right).Operand;
				value = left;
			}

			var type = operand.Type;

			if (!type.ToNullableUnderlying().IsEnum)
				return null;

			var dic = new Dictionary<object, object?>();

			var mapValues = MappingSchema.GetMapValues(type);

			if (mapValues != null)
				foreach (var mv in mapValues)
					if (!dic.ContainsKey(mv.OrigValue))
						dic.Add(mv.OrigValue, mv.MapValues[0].Value);

			switch (value.NodeType)
			{
				case ExpressionType.Constant:
					{
						var name = Enum.GetName(type, ((ConstantExpression)value).Value);

// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper disable HeuristicUnreachableCode
						if (name == null)
							return null;
// ReSharper restore HeuristicUnreachableCode
// ReSharper restore ConditionIsAlwaysTrueOrFalse

						var origValue = Enum.Parse(type, name, false);

						if (!dic.TryGetValue(origValue, out var mapValue))
							mapValue = origValue;

						ISqlExpression l, r;

						SqlValue sqlvalue;
						var ce = MappingSchema.GetConverter(new DbDataType(type), new DbDataType(typeof(DataParameter)), false);

						if (ce != null)
						{
							sqlvalue = new SqlValue(ce.ConvertValueToParameter(origValue).Value!);
						}
						else
						{
							sqlvalue = MappingSchema.GetSqlValue(type, mapValue);
						}

						if (left.NodeType == ExpressionType.Convert)
						{
							l = ConvertToSql(context, operand);
							r = sqlvalue;
						}
						else
						{
							r = ConvertToSql(context, operand);
							l = sqlvalue;
						}

						return new SqlPredicate.ExprExpr(l, op, r, true);
					}

				case ExpressionType.Convert:
					{
						value = ((UnaryExpression)value).Operand;

						var l = ConvertToSql(context, operand);
						var r = ConvertToSql(context, value);

						return new SqlPredicate.ExprExpr(l, op, r, true);
					}
			}

			return null;
		}

		#endregion

		#region ConvertObjectNullComparison

		ISqlPredicate? ConvertObjectNullComparison(IBuildContext? context, Expression left, Expression right, bool isEqual)
		{
			if (right.NodeType == ExpressionType.Constant && ((ConstantExpression)right).Value == null)
			{
				if (left.NodeType == ExpressionType.MemberAccess || left.NodeType == ExpressionType.Parameter)
				{
					var ctx = GetContext(context, left);

					if (ctx != null && ctx.IsExpression(left, 0, RequestFor.Object).Result)
					{
						return new SqlPredicate.Expr(new SqlValue(!isEqual));
					}
				}
			}

			return null;
		}

		#endregion

		#region ConvertObjectComparison

		static Expression? ConstructMemberPath(IEnumerable<MemberInfo> memberPath, Expression ob, bool throwOnError)
		{
			Expression result = ob;
			var skipCount     = 0;
			foreach (var memberInfo in memberPath)
			{
				if (!memberInfo.DeclaringType!.IsAssignableFrom(result.Type))
				{
					// first element may have inappropriate nesting
					if (skipCount-- == 0)
						continue;

					if (throwOnError)
						throw new LinqToDBException($"Type {result.Type.Name} does not have member {memberInfo.Name}.");
					return null;
				}
				result = Expression.MakeMemberAccess(result, memberInfo);
			}

			return result;
		}
		
		public ISqlPredicate? ConvertObjectComparison(
			ExpressionType nodeType,
			IBuildContext  leftContext,
			Expression     left,
			IBuildContext  rightContext,
			Expression     right)
		{
			var qsl = GetContext(leftContext,  left);
			var qsr = GetContext(rightContext, right);

			var sl = qsl != null && qsl.IsExpression(left,  0, RequestFor.Object).Result;
			var sr = qsr != null && qsr.IsExpression(right, 0, RequestFor.Object).Result;

			bool      isNull;
			SqlInfo[] lcols;

			var rmembers = new Dictionary<MemberInfo,Expression>(new MemberInfoComparer());

			if (sl == false && sr == false)
			{
				var lmembers = new Dictionary<MemberInfo,Expression>(new MemberInfoComparer());

				var isl = ProcessProjection(lmembers, left);
				var isr = ProcessProjection(rmembers, right);

				if (!isl && !isr)
					return null;

				if (lmembers.Count == 0)
				{
					var r = right;
					right = left;
					left  = r;

					var c = rightContext;
					rightContext = leftContext;
					leftContext  = c;

					var q = qsr;
					qsl = q;

					sr = false;

					var lm = lmembers;
					lmembers = rmembers;
					rmembers = lm;
				}

				isNull = right is ConstantExpression expression && expression.Value == null;
				lcols  = lmembers.Select(m => new SqlInfo(m.Key, ConvertToSql(leftContext, m.Value))).ToArray();
			}
			else
			{
				if (sl == false)
				{
					var r = right;
					right = left;
					left  = r;

					var c = rightContext;
					rightContext = leftContext;
					leftContext  = c;

					var q = qsr;
					qsl = q;

					sr = false;
				}

				isNull = right is ConstantExpression expression && expression.Value == null;
				
				lcols  = qsl!.ConvertToSql(left, 0, ConvertFlags.Key);

				if (!sr)
					ProcessProjection(rmembers, right);
			}

			if (lcols.Length == 0)
				return null;

			var condition = new SqlSearchCondition();

			foreach (var lcol in lcols)
			{
				if (lcol.Sql is SelectQuery innerQuery && isNull)
				{
					var existsPredicate = new SqlPredicate.FuncLike(SqlFunction.CreateExists(innerQuery));
					condition.Conditions.Add(new SqlCondition(nodeType == ExpressionType.Equal, existsPredicate));
					continue;
				}

				if (lcol.MemberChain.Length == 0)
					throw new InvalidOperationException();

				ISqlExpression? rcol = null;

				var lmember = lcol.MemberChain[lcol.MemberChain.Length - 1];

				var columnDescriptor = QueryHelper.GetColumnDescriptor(lcol.Sql);

				if (sr)
				{
					var memeberPath = ConstructMemberPath(lcol.MemberChain, right, true)!;
					rcol = ConvertToSql(rightContext, memeberPath, unwrap: false, columnDescriptor);
				}	
				else if (rmembers.Count != 0)
					rcol = ConvertToSql(rightContext, rmembers[lmember], unwrap: false, columnDescriptor);

				var rex =
					isNull ?
						MappingSchema.GetSqlValue(right.Type, null) :
						rcol ?? GetParameter(right, lmember, columnDescriptor);

				var predicate = new SqlPredicate.ExprExpr(
					lcol.Sql,
					nodeType == ExpressionType.Equal ? SqlPredicate.Operator.Equal : SqlPredicate.Operator.NotEqual,
					rex, Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);

				condition.Conditions.Add(new SqlCondition(false, predicate));
			}

			if (nodeType == ExpressionType.NotEqual)
				foreach (var c in condition.Conditions)
					c.IsOr = true;

			return condition;
		}

		internal ISqlPredicate? ConvertNewObjectComparison(IBuildContext context, ExpressionType nodeType, Expression left, Expression right)
		{
			left  = FindExpression(left);
			right = FindExpression(right);

			var condition = new SqlSearchCondition();

			if (left.NodeType != ExpressionType.New)
			{
				var temp = left;
				left  = right;
				right = temp;
			}

			var newExpr  = (NewExpression)left;

// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper disable HeuristicUnreachableCode
			if (newExpr.Members == null)
				return null;
// ReSharper restore HeuristicUnreachableCode
// ReSharper restore ConditionIsAlwaysTrueOrFalse

			for (var i = 0; i < newExpr.Arguments.Count; i++)
			{
				var lex = ConvertToSql(context, newExpr.Arguments[i]);
				var rex =
					right is NewExpression newRight ?
						ConvertToSql(context, newRight.Arguments[i]) :
						GetParameter(right, newExpr.Members[i], QueryHelper.GetColumnDescriptor(lex));

				var predicate = 
					new SqlPredicate.ExprExpr(
						lex,
						nodeType == ExpressionType.Equal ? SqlPredicate.Operator.Equal : SqlPredicate.Operator.NotEqual,
						rex, Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);

				condition.Conditions.Add(new SqlCondition(false, predicate));
			}

			if (nodeType == ExpressionType.NotEqual)
				foreach (var c in condition.Conditions)
					c.IsOr = true;

			return condition;
		}

		static Expression FindExpression(Expression expr)
		{
			var ret = expr.Find(pi =>
			{
				switch (pi.NodeType)
				{
					case ExpressionType.Convert      :
					{
						var e = (UnaryExpression)expr;

						return
							e.Operand.NodeType == ExpressionType.ArrayIndex &&
							ReferenceEquals(((BinaryExpression)e.Operand).Left, ParametersParam);
					}

					case ExpressionType.MemberAccess :
					case ExpressionType.New          :
						return true;
				}

				return false;
			});

			if (ret == null)
				throw new NotImplementedException();

			return ret;
		}

		#endregion

		#region Parameters

		ISqlExpression GetParameter(Expression ex, MemberInfo? member, ColumnDescriptor? columnDescriptor)
		{
			if (member is MethodInfo mi)
				member = mi.GetPropertyInfo();

			var vte  = ReplaceParameter(_expressionAccessors, ex, forceConstant: false, _ => { });
			var par  = vte.ValueExpression;
			var expr = Expression.MakeMemberAccess(par.Type == typeof(object) ? Expression.Convert(par, member?.DeclaringType ?? typeof(object)) : par, member);

			vte.ValueExpression = expr;

			if (columnDescriptor != null)
			{
				var dbDataType = columnDescriptor.GetDbDataType(true);
				vte.DataType = dbDataType;
				vte.DbDataTypeExpression = Expression.Constant(dbDataType);
			}

			if (!expr.Type.IsSameOrParentOf(vte.DataType.SystemType))
			{
				var dbDataType = new DbDataType(expr.Type);
				vte.DataType = dbDataType;
				vte.DbDataTypeExpression = Expression.Constant(dbDataType);
			}

			var p = PrepareConvertersAndCreateParameter(vte, expr, member?.Name, columnDescriptor, BuildParameterType.Default);

			_parameters.Add(expr, p);
			AddCurrentSqlParameter(p);

			return p.SqlParameter;
		}

		DbDataType GetMemberDataType(MemberInfo member)
		{
			var typeResult = new DbDataType(member.GetMemberType());

			var dta      = MappingSchema.GetAttribute<DataTypeAttribute>(member.ReflectedType!, member);
			var ca       = MappingSchema.GetAttribute<ColumnAttribute>  (member.ReflectedType!, member);

			var dataType = ca?.DataType ?? dta?.DataType;

			if (dataType != null)
				typeResult = typeResult.WithDataType(dataType.Value);

			var dbType = ca?.DbType ?? dta?.DbType;
			if (dbType != null)
				typeResult = typeResult.WithDbType(dbType);

			if (ca != null && ca.HasLength())
				typeResult = typeResult.WithLength(ca.Length);

			return typeResult;
		}

		static DbDataType GetDataType(ISqlExpression expr, DbDataType baseType)
		{
			var systemType = baseType.SystemType;
			var dataType   = baseType.DataType;
			var dbType     = baseType.DbType;
			var length     = baseType.Length;
			var precision  = baseType.Precision;
			var scale      = baseType.Scale;

			new QueryVisitor().Find(expr, e =>
			{
				switch (e.ElementType)
				{
					case QueryElementType.SqlField:
						{
							var fld = (SqlField)e;
							if (fld.Type != null)
							{
								dataType     = fld.Type.Value.DataType;
								dbType       = fld.Type.Value.DbType;
								length       = fld.Type.Value.Length;
								precision    = fld.Type.Value.Precision;
								scale        = fld.Type.Value.Scale;
								//systemType = ((SqlField)e).SystemType;
							}
							return true;
						}
					case QueryElementType.SqlParameter:
						dataType     = ((SqlParameter)e).Type.DataType;
						dbType       = ((SqlParameter)e).Type.DbType;
						length       = ((SqlParameter)e).Type.Length;
						precision    = ((SqlParameter)e).Type.Precision;
						scale        = ((SqlParameter)e).Type.Scale;
						//systemType = ((SqlParameter)e).SystemType;
						return true;
					case QueryElementType.SqlDataType:
						dataType     = ((SqlDataType)e).Type.DataType;
						dbType       = ((SqlDataType)e).Type.DbType;
						length       = ((SqlDataType)e).Type.Length;
						precision    = ((SqlDataType)e).Type.Precision;
						scale        = ((SqlDataType)e).Type.Scale;
						//systemType = ((SqlDataType)e).SystemType;
						return true;
					case QueryElementType.SqlValue:
						dataType     = ((SqlValue)e).ValueType.DataType;
						dbType       = ((SqlValue)e).ValueType.DbType;
						length       = ((SqlValue)e).ValueType.Length;
						precision    = ((SqlValue)e).ValueType.Precision;
						scale        = ((SqlValue)e).ValueType.Scale;
						//systemType = ((SqlValue)e).ValueType.SystemType;
						return true;
					default:
						return false;
				}
			});

			return new DbDataType(
				systemType ?? baseType.SystemType,
				dataType == DataType.Undefined ? baseType.DataType : dataType,
				string.IsNullOrEmpty(dbType)   ? baseType.DbType   : dbType,
				length     ?? baseType.Length,
				precision  ?? baseType.Precision,
				scale      ?? baseType.Scale
			);
		}

		static Expression CorrectAccessorExpression(Expression accessorExpression, IDataContext dataContext, ParameterExpression dataContextParam)
		{
			// see #820
			accessorExpression = accessorExpression.Transform(e =>
			{
				if (e.NodeType.NotIn(ExpressionType.Parameter, ExpressionType.Convert, ExpressionType.ConvertChecked)
				    && dataContextParam.Type.IsSameOrParentOf(e.Type))
				{
					var newExpr = (Expression) dataContextParam;
					if (newExpr.Type != e.Type)
						newExpr = Expression.Convert(newExpr, e.Type);
					return newExpr;
				}

				switch (e.NodeType)
				{
					case ExpressionType.Parameter:
					{
						// DataContext creates DataConnection which is not compatible with QueryRunner and parameter evaluation.
						// It can be fixed by adding additional parameter to execution path, but it's may slowdown performance.
						// So for now decided to throw exception.
						if (e == dataContextParam && !typeof(DataConnection).IsSameOrParentOf(dataContext.GetType()))
							throw new LinqException("Only DataConnection descendants can be used as source of parameters.");
						return e;
					}
					case ExpressionType.MemberAccess:
					{
						var ma = (MemberExpression) e;

						if (ma.Member.IsNullableValueMember())
						{
							return Expression.Condition(
								Expression.Equal(ma.Expression, Expression.Constant(null, ma.Expression.Type)),
								Expression.Default(e.Type),
								e);
						}

						return e;
					}
					case ExpressionType.Convert:
					{
						var ce = (UnaryExpression) e;
						if (ce.Operand.Type.IsNullable() && !ce.Type.IsNullable())
						{
							return Expression.Condition(
								Expression.Equal(ce.Operand, Expression.Constant(null, ce.Operand.Type)),
								Expression.Default(e.Type),
								e);
						}

						return e;
					}
					default:
						return e;
				}
			})!;

			return accessorExpression;
		}

		internal static ParameterAccessor CreateParameterAccessor(
			IDataContext        dataContext,
			Expression          accessorExpression,
			Expression          originalAccessorExpression,
			Expression          dbDataTypeAccessorExpression,
			Expression          expression,
			ParameterExpression expressionParam,
			ParameterExpression parametersParam,
			ParameterExpression dataContextParam,
			string?             name)
		{
			// Extracting name for parameter
			//
			if (name == null && expression.Type == typeof(DataParameter))
			{
				var dp = expression.EvaluateExpression<DataParameter>();
				if (dp?.Name?.IsNullOrEmpty() == false)
					name = dp.Name;
			}

			// see #820
			accessorExpression         = CorrectAccessorExpression(accessorExpression, dataContext, dataContextParam);
			originalAccessorExpression = CorrectAccessorExpression(originalAccessorExpression, dataContext, dataContextParam);

			var mapper = Expression.Lambda<Func<Expression,IDataContext?,object?[]?,object?>>(
				Expression.Convert(accessorExpression, typeof(object)),
				expressionParam, dataContextParam, parametersParam);

			var original = Expression.Lambda<Func<Expression,IDataContext?,object?[]?,object?>>(
				Expression.Convert(originalAccessorExpression, typeof(object)),
				expressionParam, dataContextParam, parametersParam);

			var dbDataTypeAccessor = Expression.Lambda<Func<Expression,IDataContext?,object?[]?,DbDataType>>(
				Expression.Convert(dbDataTypeAccessorExpression, typeof(DbDataType)),
				expressionParam, dataContextParam, parametersParam);

			return new ParameterAccessor
			(
				expression,
				mapper.CompileExpression(),
				original.CompileExpression(),
				dbDataTypeAccessor.CompileExpression(),
				new SqlParameter(new DbDataType(accessorExpression.Type), name, null)
				{
					IsQueryParameter = !dataContext.InlineParameters
				}
			)
#if DEBUG
				{
					AccessorExpr = mapper
				}
#endif
				;
		}

		#endregion

		#region ConvertInPredicate

		private ISqlPredicate ConvertInPredicate(IBuildContext context, MethodCallExpression expression)
		{
			var e        = expression;
			var argIndex = e.Object != null ? 0 : 1;
			var arr      = e.Object ?? e.Arguments[0];
			var arg      = e.Arguments[argIndex];

			ISqlExpression? expr = null;

			var ctx = GetContext(context, arg);

			if (ctx is TableBuilder.TableContext &&
				ctx.SelectQuery != context.SelectQuery &&
				ctx.IsExpression(arg, 0, RequestFor.Object).Result)
			{
				expr = ctx.SelectQuery;
			}

			if (expr == null)
			{
				var sql = ConvertExpressions(context, arg, ConvertFlags.Key, null);

				if (sql.Length == 1 && sql[0].MemberChain.Length == 0)
					expr = sql[0].Sql;
				else
					expr = new SqlObjectExpression(MappingSchema, sql);
			}

			var columnDescriptor = QueryHelper.GetColumnDescriptor(expr);

			switch (arr.NodeType)
			{
				case ExpressionType.NewArrayInit :
					{
						var newArr = (NewArrayExpression)arr;

						if (newArr.Expressions.Count == 0)
							return new SqlPredicate.Expr(new SqlValue(false));

						var exprs  = new ISqlExpression[newArr.Expressions.Count];

						for (var i = 0; i < newArr.Expressions.Count; i++)
							exprs[i] = ConvertToSql(context, newArr.Expressions[i], columnDescriptor: columnDescriptor);

						return new SqlPredicate.InList(expr, Configuration.Linq.CompareNullsAsValues ? false : (bool?)null, false, exprs);
					}

				default :

					if (CanBeCompiled(arr))
					{
						var p = BuildParameter(arr, columnDescriptor, false, BuildParameterType.InPredicate).SqlParameter;
						p.IsQueryParameter = false;
						return new SqlPredicate.InList(expr, Configuration.Linq.CompareNullsAsValues ? false : (bool?)null, false, p);
					}

					break;
			}

			throw new LinqException("'{0}' cannot be converted to SQL.", expression);
		}

		#endregion

		#region LIKE predicate

		ISqlPredicate CreateStringPredicate(IBuildContext? context, MethodCallExpression expression, SqlPredicate.SearchString.SearchKind kind)
		{
			var e = expression;
			var o = ConvertToSql(context, e.Object);
			var a = ConvertToSql(context, e.Arguments[0]);

			return new SqlPredicate.SearchString(o, false, a, kind, true);
		}

		ISqlPredicate ConvertLikePredicate(IBuildContext context, MethodCallExpression expression)
		{
			var e  = expression;
			var a1 = ConvertToSql(context, e.Arguments[0]);
			var a2 = ConvertToSql(context, e.Arguments[1]);

			ISqlExpression? a3 = null;

			if (e.Arguments.Count == 3)
				a3 = ConvertToSql(context, e.Arguments[2]);

			return new SqlPredicate.Like(a1, false, a2, a3);
		}

		#endregion

		#region MakeIsPredicate

		internal ISqlPredicate MakeIsPredicate(TableBuilder.TableContext table, Type typeOperand)
		{
			if (typeOperand == table.ObjectType && table.InheritanceMapping.All(m => m.Type != typeOperand))
				return new SqlPredicate.Expr(new SqlValue(true));

			return MakeIsPredicate(table, table.InheritanceMapping, typeOperand, name => table.SqlTable[name] ?? throw new LinqException($"Field {name} not found in table {table.SqlTable}"));
		}

		internal ISqlPredicate MakeIsPredicate(
			IBuildContext               context,
			List<InheritanceMapping>    inheritanceMapping,
			Type                        toType,
			Func<string,ISqlExpression> getSql)
		{
			var mapping = inheritanceMapping
				.Where (m => m.Type == toType && !m.IsDefault)
				.ToList();

			switch (mapping.Count)
			{
				case 0 :
					{
						var cond = new SqlSearchCondition();

						if (inheritanceMapping.Any(m => m.Type == toType))
						{
							foreach (var m in inheritanceMapping.Where(m => !m.IsDefault))
							{
								cond.Conditions.Add(
									new SqlCondition(
										false,
											new SqlPredicate.ExprExpr(
												getSql(m.DiscriminatorName),
												SqlPredicate.Operator.NotEqual,
												MappingSchema.GetSqlValue(m.Discriminator.MemberType, m.Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null)));
							}
						}
						else
						{
							foreach (var m in inheritanceMapping.Where(m => toType.IsSameOrParentOf(m.Type)))
							{
								cond.Conditions.Add(
									new SqlCondition(
										false,
											new SqlPredicate.ExprExpr(
												getSql(m.DiscriminatorName),
												SqlPredicate.Operator.Equal,
												MappingSchema.GetSqlValue(m.Discriminator.MemberType, m.Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null),
										true));
							}
						}

						return cond;
					}

				case 1 :
					return new SqlPredicate.ExprExpr(
							getSql(mapping[0].DiscriminatorName),
							SqlPredicate.Operator.Equal,
							MappingSchema.GetSqlValue(mapping[0].Discriminator.MemberType, mapping[0].Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);

				default:
					{
						var cond = new SqlSearchCondition();

						foreach (var m in mapping)
						{
							cond.Conditions.Add(
								new SqlCondition(
									false,
										new SqlPredicate.ExprExpr(
											getSql(m.DiscriminatorName),
											SqlPredicate.Operator.Equal,
											MappingSchema.GetSqlValue(m.Discriminator.MemberType, m.Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null),
									true));
						}

						return cond;
					}
			}
		}

		ISqlPredicate MakeIsPredicate(IBuildContext context, TypeBinaryExpression expression)
		{
			var typeOperand = expression.TypeOperand;
			var table       = new TableBuilder.TableContext(this, new BuildInfo((IBuildContext?)null, Expression.Constant(null), new SelectQuery()), typeOperand);

			if (typeOperand == table.ObjectType && table.InheritanceMapping.All(m => m.Type != typeOperand))
				return new SqlPredicate.Expr(new SqlValue(true));

			var mapping = table.InheritanceMapping.Select((m, i) => new { m, i }).Where(m => typeOperand.IsAssignableFrom(m.m.Type) && !m.m.IsDefault).ToList();
			var isEqual = true;

			if (mapping.Count == 0)
			{
				mapping = table.InheritanceMapping.Select((m,i) => new { m, i }).Where(m => !m.m.IsDefault).ToList();
				isEqual = false;
			}

			Expression? expr = null;

			foreach (var m in mapping)
			{
				var field = table.SqlTable[table.InheritanceMapping[m.i].DiscriminatorName] ?? throw new LinqException($"Field {table.InheritanceMapping[m.i].DiscriminatorName} not found in table {table.SqlTable}");
				var ttype = field.ColumnDescriptor.MemberAccessor.TypeAccessor.Type;
				var obj   = expression.Expression;

				if (obj.Type != ttype)
					obj = Expression.Convert(expression.Expression, ttype);

				var left = ExpressionHelper.PropertyOrField(obj, field.Name);
				var code = m.m.Code;

				if (code == null)
					code = left.Type.GetDefaultValue();
				else if (left.Type != code.GetType())
					code = Converter.ChangeType(code, left.Type, MappingSchema);

				Expression right = Expression.Constant(code, left.Type);

				var e = isEqual ? Expression.Equal(left, right) : Expression.NotEqual(left, right);

				if (!isEqual)
					expr = expr != null ? Expression.AndAlso(expr, e) : e;
				else
					expr = expr != null ? Expression.OrElse(expr, e) : e;
			}

			return ConvertPredicate(context, expr!);
		}

		#endregion

		#endregion

		#region Search Condition Builder

		internal void BuildSearchCondition(IBuildContext? context, Expression expression, List<SqlCondition> conditions)
		{
			expression = expression.Transform(RemoveNullPropagation);

			switch (expression.NodeType)
			{
				case ExpressionType.And     :
				case ExpressionType.AndAlso :
					{
						var e = (BinaryExpression)expression;

						BuildSearchCondition(context, e.Left,  conditions);
						BuildSearchCondition(context, e.Right, conditions);

						break;
					}

				case ExpressionType.Extension :
					{
						break;
					}

				case ExpressionType.Or     :
				case ExpressionType.OrElse :
					{
						var e           = (BinaryExpression)expression;
						var orCondition = new SqlSearchCondition();

						BuildSearchCondition(context, e.Left,  orCondition.Conditions);
						orCondition.Conditions[orCondition.Conditions.Count - 1].IsOr = true;
						BuildSearchCondition(context, e.Right, orCondition.Conditions);

						conditions.Add(new SqlCondition(false, orCondition));

						break;
					}

				case ExpressionType.Not    :
					{
						var e            = (UnaryExpression)expression;
						var notCondition = new SqlSearchCondition();

						BuildSearchCondition(context, e.Operand, notCondition.Conditions);

						conditions.Add(new SqlCondition(true, notCondition));

						break;
					}

				default                    :
					var predicate = ConvertPredicate(context, expression);

					conditions.Add(new SqlCondition(false, predicate));

					break;
			}
		}


		static bool NeedNullCheck(ISqlExpression expr)
		{
			if (!expr.CanBeNull)
				return false;

			if (null != new QueryVisitor().Find(expr, e => e.ElementType == QueryElementType.SelectClause))
				return false;
			return true;
		}

		#endregion

		#region CanBeTranslatedToSql

		bool CanBeTranslatedToSql(IBuildContext context, Expression expr, bool canBeCompiled)
		{
			List<Expression>? ignoredMembers = null;

			return null == expr.Find(pi =>
			{
				if (ignoredMembers != null)
				{
					if (pi != ignoredMembers[ignoredMembers.Count - 1])
						throw new InvalidOperationException();

					if (ignoredMembers.Count == 1)
						ignoredMembers = null;
					else
						ignoredMembers.RemoveAt(ignoredMembers.Count - 1);

					return false;
				}

				switch (pi.NodeType)
				{
					case ExpressionType.MemberAccess :
						{
							var ma   = (MemberExpression)pi;
							var attr = GetExpressionAttribute(ma.Member);

							if (attr == null && !ma.Member.IsNullableValueMember())
							{
								if (canBeCompiled)
								{
									var ctx = GetContext(context, pi);

									if (ctx == null)
										return !CanBeCompiled(pi);

									if (ctx.IsExpression(pi, 0, RequestFor.Object).Result)
										return !CanBeCompiled(pi);

									ignoredMembers = ma.Expression.GetMembers();
								}
							}

							break;
						}

					case ExpressionType.Parameter    :
						{
							var ctx = GetContext(context, pi);

							if (ctx == null)
								if (canBeCompiled)
									return !CanBeCompiled(pi);

							break;
						}

					case ExpressionType.Call         :
						{
							var e = (MethodCallExpression)pi;

							if (e.Method.DeclaringType != typeof(Enumerable))
							{
								var attr = GetExpressionAttribute(e.Method);

								if (attr == null && canBeCompiled)
									return !CanBeCompiled(pi);
							}

							break;
						}

					case ExpressionType.TypeIs       : return canBeCompiled;
					case ExpressionType.TypeAs       :
					case ExpressionType.New          : return true;

					case ExpressionType.NotEqual     :
					case ExpressionType.Equal        :
						{
							var e = (BinaryExpression)pi;

							Expression? obj = null;

							if (e.Left.NodeType == ExpressionType.Constant && ((ConstantExpression)e.Left).Value == null)
								obj = e.Right;
							else if (e.Right.NodeType == ExpressionType.Constant && ((ConstantExpression)e.Right).Value == null)
								obj = e.Left;

							if (obj != null)
							{
								var ctx = GetContext(context, obj);

								if (ctx != null)
								{
									if (ctx.IsExpression(obj, 0, RequestFor.Table).      Result ||
										ctx.IsExpression(obj, 0, RequestFor.Association).Result)
									{
										ignoredMembers = obj.GetMembers();
									}
								}
							}

							break;
						}

					case ExpressionType.Conditional:
						{
							var cond = (ConditionalExpression)pi;
							if (!cond.Type.IsScalar())
								return true;
							break;
						}
				}

				return false;
			});
		}

		#endregion

		#region Helpers

		public IBuildContext? GetContext(IBuildContext? current, Expression? expression)
		{
			var root = GetRootObject(expression);
			root = root.Unwrap();

			if (root is ContextRefExpression refExpression)
				return refExpression.BuildContext;

			for (; current != null; current = current.Parent)
				if (current.IsExpression(root, 0, RequestFor.Root).Result)
					return current;

			return null;
		}

		Sql.ExpressionAttribute? GetExpressionAttribute(MemberInfo member)
		{
			return MappingSchema.GetAttribute<Sql.ExpressionAttribute>(member.ReflectedType!, member, a => a.Configuration);
		}

		internal Sql.TableFunctionAttribute? GetTableFunctionAttribute(MemberInfo member)
		{
			return MappingSchema.GetAttribute<Sql.TableFunctionAttribute>(member.ReflectedType!, member, a => a.Configuration);
		}

		bool IsNullConstant(Expression expr)
		{
			return expr.NodeType == ExpressionType.Constant  && ((ConstantExpression)expr).Value == null 
				|| expr.NodeType == ExpressionType.Extension && expr is DefaultValueExpression;
		}

		Expression RemoveNullPropagation(Expression expr)
		{
			// Do not modify parameters
			//
			if (CanBeCompiled(expr))
				return expr;

			switch (expr.NodeType)
			{
				case ExpressionType.Conditional:
					var conditional = (ConditionalExpression)expr;
					if (conditional.Test.NodeType == ExpressionType.NotEqual)
					{
						var binary    = (BinaryExpression)conditional.Test;
						var nullRight = IsNullConstant(binary.Right);
						var nullLeft  = IsNullConstant(binary.Left);
						if (nullRight || nullLeft)
						{
							if (nullRight && nullLeft)
							{
								return conditional.IfFalse.Transform(RemoveNullPropagation);
							}
							else if (IsNullConstant(conditional.IfFalse)
								&& ((nullRight && !MappingSchema.IsScalarType(binary.Left.Type)) ||
									(nullLeft  && !MappingSchema.IsScalarType(binary.Right.Type))))
							{
								return conditional.IfTrue.Transform(RemoveNullPropagation);
							}
						}
					}
					else if (conditional.Test.NodeType == ExpressionType.Equal)
					{
						var binary    = (BinaryExpression)conditional.Test;
						var nullRight = IsNullConstant(binary.Right);
						var nullLeft  = IsNullConstant(binary.Left);
						if (nullRight || nullLeft)
						{
							if (nullRight && nullLeft)
							{
								return conditional.IfTrue.Transform(RemoveNullPropagation);
							}
							else if (IsNullConstant(conditional.IfTrue)
								&& ((nullRight && !MappingSchema.IsScalarType(binary.Left.Type)) ||
									(nullLeft  && !MappingSchema.IsScalarType(binary.Right.Type))))
							{
								return conditional.IfFalse.Transform(RemoveNullPropagation);
							}
						}
					}
					break;
			}

			return expr;
		}

		public bool ProcessProjection(Dictionary<MemberInfo,Expression> members, Expression expression)
		{
			void CollectParameters(Type forType, MethodBase method, ReadOnlyCollection<Expression> arguments)
			{
				var pms = method.GetParameters();

				var typeMembers = TypeAccessor.GetAccessor(forType).Members;

				for (var i = 0; i < pms.Length; i++)
				{
					var param = pms[i];
					var foundMember = typeMembers.Find(tm => tm.Name == param.Name);
					if (foundMember == null)
						foundMember = typeMembers.Find(tm =>
							tm.Name.Equals(param.Name, StringComparison.OrdinalIgnoreCase));
					if (foundMember == null)
						continue;

					if (members.ContainsKey(foundMember.MemberInfo))
						continue;

					var converted = arguments[i].Transform(e => RemoveNullPropagation(e));

					if (!foundMember.MemberInfo.GetMemberType().IsAssignableFrom(converted.Type))
						continue;

					members.Add(foundMember.MemberInfo, converted);
				}
			}

			switch (expression.NodeType)
			{
				// new { ... }
				//
				case ExpressionType.New        :
					{
						var expr = (NewExpression)expression;

						if (expr.Members != null)
						{
							for (var i = 0; i < expr.Members.Count; i++)
							{
								var member = expr.Members[i];

								var converted = expr.Arguments[i].Transform(e => RemoveNullPropagation(e));
								members.Add(member, converted);

								if (member is MethodInfo info)
									members.Add(info.GetPropertyInfo(), converted);
							}
						}

						var isScalar = MappingSchema.IsScalarType(expr.Type);
						if (!isScalar)
							CollectParameters(expr.Type, expr.Constructor, expr.Arguments);

						return members.Count > 0 || !isScalar;
					}

				// new MyObject { ... }
				//
				case ExpressionType.MemberInit :
					{
						var expr = (MemberInitExpression)expression;
						var typeMembers = TypeAccessor.GetAccessor(expr.Type).Members;

						var dic  = typeMembers
							.Select((m,i) => new { m, i })
							.ToDictionary(_ => _.m.MemberInfo.Name, _ => _.i);

						foreach (var binding in expr.Bindings.Cast<MemberAssignment>().OrderBy(b => dic.ContainsKey(b.Member.Name) ? dic[b.Member.Name] : 1000000))
						{
							var converted = binding.Expression.Transform(e => RemoveNullPropagation(e));
							members.Add(binding.Member, converted);

							if (binding.Member is MethodInfo info)
								members.Add(info.GetPropertyInfo(), converted);
						}

						return true;
					}

				case ExpressionType.Call:
					{
						var mc = (MethodCallExpression)expression;

						// process fabric methods

						if (!MappingSchema.IsScalarType(mc.Type))
							CollectParameters(mc.Type, mc.Method, mc.Arguments);

						return members.Count > 0;
					}

				case ExpressionType.NewArrayInit:
				case ExpressionType.ListInit:
					{
						return true;
					}
				// .Select(p => everything else)
				//
				default                        :
					return false;
			}
		}

		public void ReplaceParent(IBuildContext oldParent, IBuildContext? newParent)
		{
			foreach (var context in Contexts)
				if (context != newParent)
					if (context.Parent == oldParent)
						if (newParent != null && newParent.Parent != context)
							context.Parent = newParent;
		}

		public static void EnsureAggregateColumns(IBuildContext context, SelectQuery query)
		{
			if (query.Select.Columns.Count == 0)
			{
				var sql = context.ConvertToSql(null, 0, ConvertFlags.All);
				if (sql.Length > 0)
				{
					// Handling case when all columns are aggregates, it cause query to produce only single record and we have to include at least one aggregation in Select statement.
					// 
					var allAggregate = sql.All(s => QueryHelper.IsAggregationOrWindowFunction(s.Sql));
					if (allAggregate)
					{
						query.Select.Add(sql[0].Sql);
					}
				}
			}
		}


		#endregion

		#region CTE

		List<Tuple<Expression, Tuple<CteClause, IBuildContext?>>>? _ctes;
		Dictionary<IQueryable, Expression>?                        _ctesObjectMapping;

		public Tuple<CteClause, IBuildContext?, Expression> RegisterCte(IQueryable? queryable, Expression? cteExpression, Func<CteClause> buildFunc)
		{
			if (cteExpression != null && queryable != null && (_ctesObjectMapping == null || !_ctesObjectMapping.ContainsKey(queryable)))
			{
				_ctesObjectMapping ??= new Dictionary<IQueryable, Expression>();

				_ctesObjectMapping.Add(queryable, cteExpression);
			}

			if (cteExpression == null)
			{
				if (_ctesObjectMapping == null)
					throw new InvalidOperationException();
				cteExpression = _ctesObjectMapping[queryable!];
			}

			var value = FindRegisteredCteByExpression(cteExpression, out _);

			if (value == null)
			{
				var cte = buildFunc();
				value = Tuple.Create<CteClause, IBuildContext?>(cte, null);

				_ctes ??= new List<Tuple<Expression, Tuple<CteClause, IBuildContext?>>>();
				_ctes.Add(Tuple.Create(cteExpression, value));
			}

			return Tuple.Create(value.Item1, value.Item2, cteExpression);
		}

		Tuple<CteClause, IBuildContext?>? FindRegisteredCteByExpression(Expression cteExpression, out int? idx)
		{
			if (_ctes != null)
			{
				var queryableAccessorDic = new Dictionary<Expression, QueryableAccessor>();
				for (var index = 0; index < _ctes.Count; index++)
				{
					var tuple = _ctes[index];
					if (tuple.Item1.EqualsTo(cteExpression, DataContext, queryableAccessorDic, null, null,
						compareConstantValues: false))
					{
						idx = index;
						return tuple.Item2;
					}
				}
			}

			idx = null;
			return null;
		}
		

		public Tuple<CteClause, IBuildContext?> BuildCte(Expression cteExpression, Func<CteClause?, Tuple<CteClause, IBuildContext?>> buildFunc)
		{
			var value = FindRegisteredCteByExpression(cteExpression, out var idx);
			if (value?.Item2 != null)
				return value;

			value = buildFunc(value?.Item1);

			if (idx != null)
			{
				_ctes!.RemoveAt(idx.Value);
			}
			else
			{
				_ctes ??= new List<Tuple<Expression, Tuple<CteClause, IBuildContext?>>>();
			}

			_ctes.Add(Tuple.Create(cteExpression, value));

			return value;
		}

		public IBuildContext? GetCteContext(Expression cteExpression)
		{
			return FindRegisteredCteByExpression(cteExpression, out _)?.Item2;
		}

		#endregion

		#region Eager Loading

		private List<Tuple<Func<IDataContext, Expression, object?[]?, object?>, Func<IDataContext, Expression, object?[]?, CancellationToken, Task<object?>>>>? _preambles;

		public static readonly ParameterExpression PreambleParam =
			Expression.Parameter(typeof(object[]), "preamble");

		public int RegisterPreamble<T>(Func<IDataContext, Expression, object?[]?, T> func, Func<IDataContext, Expression, object?[]?, CancellationToken, Task<T>> funcAsync)
		{
			if (_preambles == null)
				_preambles = new List<Tuple<Func<IDataContext, Expression, object?[]?, object?>,Func<IDataContext, Expression, object?[]?, CancellationToken, Task<object?>>>>();
			_preambles.Add(
				Tuple.Create< Func<IDataContext, Expression, object?[]?, object?>, Func<IDataContext, Expression, object?[]?, CancellationToken, Task<object?>>>(
					(dc, e, ps) => func(dc, e, ps),
					async (dc, e, ps, ct) => await funcAsync(dc, e, ps, ct).ConfigureAwait(Configuration.ContinueOnCapturedContext)));
			return _preambles.Count - 1;
		}

		#endregion

		#region Query Filter

		private Stack<Type[]>? _disabledFilters;

		public void AddDisabledQueryFilters(Type[] disabledFilters)
		{
			if (_disabledFilters == null)
				_disabledFilters = new Stack<Type[]>();
			_disabledFilters.Push(disabledFilters);
		}

		public bool IsFilterDisabled(Type entityType)
		{
			if (_disabledFilters == null || _disabledFilters.Count == 0)
				return false;
			var filter = _disabledFilters.Peek();
			if (filter.Length == 0)
				return true;
			return Array.IndexOf(filter, entityType) >= 0;
		}

		public void RemoveDisabledFilter()
		{
			if (_disabledFilters == null)
				throw new InvalidOperationException();

			_ = _disabledFilters.Pop();
		}

		#endregion

		#region Grouping Guard

		public bool IsGroupingGuardDisabled { get; set; }

		#endregion
	}
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data.SqlTypes;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace LinqToDB.Linq.Builder
{
	using Common;
	using Data;
	using LinqToDB.Expressions;
	using Extensions;
	using Mapping;
	using Reflection;
	using SqlQuery;
	using SqlProvider;
	using Tools;
	using System.Threading;

	partial class ExpressionBuilder
	{
		#region Build Where

		public IBuildContext BuildWhere(IBuildContext? parent, IBuildContext sequence, LambdaExpression condition, bool checkForSubQuery, bool enforceHaving = false)
		{
			var prevParent = sequence.Parent;
			var ctx        = new ExpressionContext(parent, sequence, condition);
			var expr       = ConvertExpression(condition.Body.Unwrap());
			var makeHaving = false;

			if (checkForSubQuery && CheckSubQueryForWhere(ctx, expr, out makeHaving))
			{
				ReplaceParent(ctx, prevParent);

				sequence = new SubQueryContext(sequence);
				prevParent = sequence.Parent;

				ctx = new ExpressionContext(parent, sequence, condition);
			}

			var conditions = enforceHaving || makeHaving && !ctx.SelectQuery.GroupBy.IsEmpty?
				ctx.SelectQuery.Having.SearchCondition.Conditions :
				ctx.SelectQuery.Where. SearchCondition.Conditions;

			BuildSearchCondition(ctx, expr, conditions);

			ReplaceParent(ctx, prevParent);

			return sequence;
		}

		bool CheckSubQueryForWhere(IBuildContext context, Expression expression, out bool makeHaving)
		{
			var makeSubQuery = false;
			var isHaving     = false;
			var isWhere      = false;

			expression.Visit(expr =>
			{
				if (makeSubQuery)
					return false;

				if (_subQueryExpressions != null && _subQueryExpressions.Contains(expr))
				{
					makeSubQuery = true;
					isWhere      = true;
					return false;
				}

				switch (expr.NodeType)
				{
					case ExpressionType.MemberAccess:
					{
						var ma = (MemberExpression)expr;

						if (ma.Member.IsNullableValueMember())
							return true;

						if (Expressions.ConvertMember(MappingSchema, ma.Expression?.Type, ma.Member) != null)
							return true;

						var ctx = GetContext(context, expr);

						if (ctx == null)
							return true;

						var expres = ctx.IsExpression(expr, 0, RequestFor.Expression);

						if (expres.Result)
						{
							if (expres.Expression != null && IsGrouping(expres.Expression, MappingSchema))
							{
								isHaving = true;
								return false;
							}

							makeSubQuery = true;
						}
						else
						{
							if (IsGrouping(expr, MappingSchema))
							{
								isHaving = true;
								return false;
							}

							isWhere = ctx.IsExpression(expr, 0, RequestFor.Field).Result;
						}

						return false;
					}

					case ExpressionType.Call:
						{
							var e = (MethodCallExpression)expr;

							if (Expressions.ConvertMember(MappingSchema, e.Object?.Type, e.Method) != null)
								return true;

							if (IsGrouping(e, MappingSchema))
							{
								isHaving = true;
								return false;
							}

							break;
						}

					case ExpressionType.Parameter:
						{
							var ctx = GetContext(context, expr);

							if (ctx != null)
							{
								if (ctx.IsExpression(expr, 0, RequestFor.Expression).Result)
									makeSubQuery = true;
							}

							isWhere = true;

							break;
						}
				}

				return true;
			});

			makeHaving = isHaving && !isWhere;
			return makeSubQuery || isHaving && isWhere;
		}

		bool IsGrouping(Expression expression, MappingSchema mappingSchema)
		{
			switch (expression.NodeType)
			{
				case ExpressionType.MemberAccess:
				{
					var ma = (MemberExpression)expression;
					return ma.Expression != null && typeof(IGrouping<,>).IsSameOrParentOf(ma.Expression.Type);
				}

				case ExpressionType.Call:
				{
					var mce = (MethodCallExpression)expression;

					if (mce.Object != null && typeof(IGrouping<,>).IsSameOrParentOf(mce.Object.Type))
						return true;

					if (mce.Method == Methods.LinqToDB.GroupBy.Grouping)
						return true;

					return mce.Arguments.Any(a => typeof(IGrouping<,>).IsSameOrParentOf(a.Type));
				}
			}

			return false;
		}

		#endregion

		#region BuildTake

		public void BuildTake(IBuildContext context, ISqlExpression expr, TakeHints? hints)
		{
			var sql = context.SelectQuery;

			sql.Select.Take(expr, hints);

			if (sql.Select.SkipValue != null &&
				 DataContext.SqlProviderFlags.IsTakeSupported &&
				!DataContext.SqlProviderFlags.GetIsSkipSupportedFlag(sql.Select.TakeValue, sql.Select.SkipValue))
				sql.Select.Take(
					new SqlBinaryExpression(typeof(int), sql.Select.SkipValue, "+", sql.Select.TakeValue!, Precedence.Additive), hints);
		}

		#endregion

		#region SubQueryToSql

		public IBuildContext GetSubQuery(IBuildContext context, MethodCallExpression expr)
		{
			var info = new BuildInfo(context, expr, new SelectQuery { ParentSelect = context.SelectQuery });
			var ctx  = BuildSequence(info);

			if (ctx.SelectQuery.Select.Columns.Count == 0) 
			{
				if (ctx.IsExpression(null, 0, RequestFor.Field).Result)
					ctx.ConvertToIndex(null, 0, ConvertFlags.Field);
				if (ctx.IsExpression(null, 0, RequestFor.Expression).Result)
					ctx.ConvertToIndex(null, 0, ConvertFlags.All);
			}

			return ctx;
		}

		internal ISqlExpression SubQueryToSql(IBuildContext context, MethodCallExpression expression)
		{
			var sequence = GetSubQuery(context, expression);
			var subSql   = sequence.GetSubQuery(context);

			if (subSql == null)
			{
				var query    = context.SelectQuery;
				var subQuery = sequence.SelectQuery;

				// This code should be moved to context.
				//
				if (!query.GroupBy.IsEmpty && !subQuery.Where.IsEmpty)
				{
					var fromGroupBy = sequence.SelectQuery.Properties
						.OfType<Tuple<string,SelectQuery>>()
						.Any(p => p.Item1 == "from_group_by" && ReferenceEquals(p.Item2, context.SelectQuery));

					if (fromGroupBy)
					{
						if (subQuery.Select.Columns.Count == 1 &&
							subQuery.Select.Columns[0].Expression.ElementType == QueryElementType.SqlFunction &&
							subQuery.GroupBy.IsEmpty && !subQuery.Select.HasModifier && !subQuery.HasSetOperators &&
							subQuery.Where.SearchCondition.Conditions.Count == 1)
						{
							var cond = subQuery.Where.SearchCondition.Conditions[0];

							if (cond.Predicate.ElementType == QueryElementType.ExprExprPredicate && query.GroupBy.Items.Count == 1 ||
								cond.Predicate.ElementType == QueryElementType.SearchCondition &&
								query.GroupBy.Items.Count == ((SqlSearchCondition)cond.Predicate).Conditions.Count)
							{
								var func = (SqlFunction)subQuery.Select.Columns[0].Expression;

								if (CountBuilder.MethodNames.Contains(func.Name))
									return SqlFunction.CreateCount(func.SystemType, query);
							}
						}
					}
				}

				subSql = sequence.SelectQuery;
			}

			return subSql;
		}

		#endregion

		#region IsSubQuery

		bool IsSubQuery(IBuildContext context, MethodCallExpression call)
		{
			var isAggregate = call.IsAggregate(MappingSchema);

			if (isAggregate || call.IsQueryable())
			{
				var info = new BuildInfo(context, call, new SelectQuery { ParentSelect = context.SelectQuery });

				if (!IsSequence(info))
					return false;

				var arg = call.Arguments[0];

				if (isAggregate)
					while (arg.NodeType == ExpressionType.Call && ((MethodCallExpression)arg).Method.Name == "Select")
						arg = ((MethodCallExpression)arg).Arguments[0];

				arg = arg.SkipPathThrough();
				arg = arg.SkipMethodChain(MappingSchema);

				while (arg is MethodCallExpression mc)
				{
					if (!mc.IsQueryable())
					{
						if (mc.IsAssociation(MappingSchema))
							return true;

						return GetTableFunctionAttribute(mc.Method) != null;
					}

					mc = mc.Arguments[0] as MethodCallExpression;
				}

				return arg.NodeType == ExpressionType.Call || IsSubQuerySource(context, arg);
			}

			return false;
		}

		bool IsSubQuerySource(IBuildContext context, Expression expr)
		{
			if (expr == null)
				return false;

			var ctx = GetContext(context, expr);

			if (ctx != null && ctx.IsExpression(expr, 0, RequestFor.Object).Result)
				return true;

			while (expr != null)
			{
				switch (expr)
				{
					case MemberExpression me:
						expr = me.Expression;
						continue;
					case MethodCallExpression mc when mc.IsQueryable("AsQueryable"):
						expr = mc.Arguments[0];
						continue;
				}

				break;
			}

			return expr != null && expr.NodeType == ExpressionType.Constant;
		}

		bool IsGroupJoinSource(IBuildContext context, MethodCallExpression call)
		{
			if (!call.IsQueryable() || CountBuilder.MethodNames.Contains(call.Method.Name))
				return false;

			Expression expr = call;

			while (expr.NodeType == ExpressionType.Call)
				expr = ((MethodCallExpression)expr).Arguments[0];

			var ctx = GetContext(context, expr);

			return ctx != null && ctx.IsExpression(expr, 0, RequestFor.GroupJoin).Result;
		}

		#endregion

		#region ConvertExpression

		interface IConvertHelper
		{
			Expression ConvertNull(MemberExpression expression);
		}

		class ConvertHelper<T> : IConvertHelper
			where T : struct
		{
			public Expression ConvertNull(MemberExpression expression)
			{
				return Expression.Call(
					null,
					MemberHelper.MethodOf<T?>(p => Sql.ToNotNull(p)),
					expression.Expression);
			}
		}

		internal Expression ConvertExpression(Expression expression)
		{
			return expression.Transform(e =>
			{
				if (CanBeConstant(e) || CanBeCompiled(e))
				//if ((CanBeConstant(e) || CanBeCompiled(e)) && !PreferServerSide(e))
					return new TransformInfo(e, true);

				switch (e.NodeType)
				{
					//This is to handle VB's weird expression generation when dealing with nullable properties.
					case ExpressionType.Coalesce:
						{
							var b = (BinaryExpression)e;

							if (b.Left is BinaryExpression equalityLeft && b.Right is ConstantExpression constantRight)
								if (equalityLeft.Type.GetGenericTypeDefinition() == typeof(Nullable<>))
									if (equalityLeft.NodeType == ExpressionType.Equal && equalityLeft.Left.Type == equalityLeft.Right.Type)
										if (constantRight.Value is bool val && val == false)
											return new TransformInfo(equalityLeft, false);

							break;
						}

					case ExpressionType.New:
						{
							var ex = ConvertNew((NewExpression)e);
							if (ex != null)
								return new TransformInfo(ConvertExpression(ex));
							break;
						}

					case ExpressionType.Call:
						{
							var expr = (MethodCallExpression)e;

							if (expr.Method.IsSqlPropertyMethodEx())
							{
								// transform Sql.Property into member access
								if (expr.Arguments[1].Type != typeof(string))
									throw new ArgumentException("Only strings are allowed for member name in Sql.Property expressions.");

								var entity           = ConvertExpression(expr.Arguments[0]);
								var memberName       = (string)expr.Arguments[1].EvaluateExpression()!;
								var entityDescriptor = MappingSchema.GetEntityDescriptor(entity.Type);

								var memberInfo = entityDescriptor[memberName]?.MemberInfo ?? entityDescriptor.Associations
													 .SingleOrDefault(a => a.MemberInfo.Name == memberName)?.MemberInfo;
								if (memberInfo == null)
									memberInfo = MemberHelper.GetMemberInfo(expr);

								return new TransformInfo(ConvertExpression(Expression.MakeMemberAccess(entity, memberInfo)));
							}

							var cm = ConvertMethod(expr);
							if (cm != null)
								//TODO: looks like a mess: ConvertExpression can not work without OptimizeExpression
								return new TransformInfo(OptimizeExpression(ConvertExpression(cm)));
							break;
						}

					case ExpressionType.MemberAccess:
						{
							var ma = (MemberExpression)e;
							var l  = Expressions.ConvertMember(MappingSchema, ma.Expression?.Type, ma.Member);

							if (l != null)
							{
								var body = l.Body.Unwrap();
								var expr = body.Transform(wpi => wpi.NodeType == ExpressionType.Parameter ? ma.Expression! : wpi);

								if (expr.Type != e.Type)
									expr = new ChangeTypeExpression(expr, e.Type);

								//TODO: looks like a mess: ConvertExpression can not work without OptimizeExpression
								return new TransformInfo(OptimizeExpression(ConvertExpression(expr)));
							}

							if (ma.Member.IsNullableValueMember())
							{
								var ntype  = typeof(ConvertHelper<>).MakeGenericType(ma.Type);
								var helper = (IConvertHelper)Activator.CreateInstance(ntype)!;
								var expr   = helper.ConvertNull(ma);

								return new TransformInfo(ConvertExpression(expr));
							}

							if (ma.Member.DeclaringType == typeof(TimeSpan))
							{
								switch (ma.Expression!.NodeType)
								{
									case ExpressionType.Subtract       :
									case ExpressionType.SubtractChecked:

										Sql.DateParts datePart;

										switch (ma.Member.Name)
										{
											case "TotalMilliseconds" : datePart = Sql.DateParts.Millisecond; break;
											case "TotalSeconds"      : datePart = Sql.DateParts.Second;      break;
											case "TotalMinutes"      : datePart = Sql.DateParts.Minute;      break;
											case "TotalHours"        : datePart = Sql.DateParts.Hour;        break;
											case "TotalDays"         : datePart = Sql.DateParts.Day;         break;
											default                  : return new TransformInfo(e);
										}

										var ex = (BinaryExpression)ma.Expression;
										if (ex.Left.Type == typeof(DateTime)
											&& ex.Right.Type == typeof(DateTime))
										{
											var method = MemberHelper.MethodOf(
												() => Sql.DateDiff(Sql.DateParts.Day, DateTime.MinValue, DateTime.MinValue));

											var call   =
												Expression.Convert(
													Expression.Call(
														null,
														method,
														Expression.Constant(datePart),
														Expression.Convert(ex.Right, typeof(DateTime?)),
														Expression.Convert(ex.Left,  typeof(DateTime?))),
													typeof(double));

											return new TransformInfo(ConvertExpression(call));
										}
										else
										{
											var method = MemberHelper.MethodOf(
												() => Sql.DateDiff(Sql.DateParts.Day, DateTimeOffset.MinValue, DateTimeOffset.MinValue));

											var call   =
												Expression.Convert(
													Expression.Call(
														null,
														method,
														Expression.Constant(datePart),
														Expression.Convert(ex.Right, typeof(DateTimeOffset?)),
														Expression.Convert(ex.Left,  typeof(DateTimeOffset?))),
													typeof(double));

											return new TransformInfo(ConvertExpression(call));
										}
								}
							}

							break;
						}

					default:
						{
							if (e is BinaryExpression binary)
							{
								var l = Expressions.ConvertBinary(MappingSchema, binary);
								if (l != null)
								{
									var body = l.Body.Unwrap();
									var expr = body.Transform(wpi =>
									{
										if (wpi.NodeType == ExpressionType.Parameter)
										{
											if (l.Parameters[0] == wpi)
												return binary.Left;
											if (l.Parameters[1] == wpi)
												return binary.Right;
										}

										return wpi;
									});

									if (expr.Type != e.Type)
										expr = new ChangeTypeExpression(expr, e.Type);

									return new TransformInfo(ConvertExpression(expr));
								}
							}
							break;
						}
				}

				return new TransformInfo(e);
			});
		}

		Expression? ConvertMethod(MethodCallExpression pi)
		{
			LambdaExpression? lambda = null;

			if (!pi.Method.IsStatic && pi.Object != null && pi.Object.Type != pi.Method.DeclaringType)
			{
				var concreteTypeMemberInfo = pi.Object.Type.GetMemberEx(pi.Method);
				if (concreteTypeMemberInfo != null)
					lambda = Expressions.ConvertMember(MappingSchema, pi.Object.Type, concreteTypeMemberInfo);
			}

			if (lambda == null)
				lambda = Expressions.ConvertMember(MappingSchema, pi.Object?.Type, pi.Method);

			return lambda == null ? null : ConvertMethod(pi, lambda);
		}

		static Expression ConvertMethod(MethodCallExpression pi, LambdaExpression lambda)
		{
			var ef    = lambda.Body.Unwrap();
			var parms = new Dictionary<ParameterExpression,int>(lambda.Parameters.Count);
			var pn    = pi.Method.IsStatic ? 0 : -1;

			foreach (var p in lambda.Parameters)
				parms.Add(p, pn++);

			var pie = ef.Transform(wpi =>
			{
				if (wpi.NodeType == ExpressionType.Parameter)
				{
					if (parms.TryGetValue((ParameterExpression)wpi, out var n))
					{
						if (n >= pi.Arguments.Count)
						{
							if (DataContextParam.Type.IsSameOrParentOf(wpi.Type))
							{
								if (DataContextParam.Type != wpi.Type)
									return Expression.Convert(DataContextParam, wpi.Type);
								return DataContextParam;
							}

							throw new LinqToDBException($"Can't convert {wpi} to expression.");
						}

						var result = n < 0 ? pi.Object : pi.Arguments[n];
						
						if (result.Type != wpi.Type)
						{
							if (result.Type.IsEnum)
								result = Expression.Convert(result, wpi.Type);
						}						

						return result;
					}
				}

				return wpi;
			});

			if (pi.Method.ReturnType != pie.Type)
				pie = new ChangeTypeExpression(pie, pi.Method.ReturnType);

			return pie;
		}

		Expression? ConvertNew(NewExpression pi)
		{
			var lambda = Expressions.ConvertMember(MappingSchema, pi.Type, pi.Constructor);

			if (lambda != null)
			{
				var ef    = lambda.Body.Unwrap();
				var parms = new Dictionary<string,int>(lambda.Parameters.Count);
				var pn    = 0;

				foreach (var p in lambda.Parameters)
					parms.Add(p.Name, pn++);

				return ef.Transform(wpi =>
				{
					if (wpi.NodeType == ExpressionType.Parameter)
					{
						var pe   = (ParameterExpression)wpi;
						var n    = parms[pe.Name];
						return pi.Arguments[n];
					}

					return wpi;
				});
			}

			return null;
		}

		#endregion

		#region BuildExpression

		public SqlInfo[] ConvertExpressions(IBuildContext context, Expression expression, ConvertFlags queryConvertFlag, ColumnDescriptor? columnDescriptor)
		{
			expression = ConvertExpression(expression).UnwrapConvertToObject();

			switch (expression.NodeType)
			{
				case ExpressionType.New :
					{
						var expr = (NewExpression)expression;

// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper disable HeuristicUnreachableCode
						if (expr.Members == null)
							return Array<SqlInfo>.Empty;
// ReSharper restore HeuristicUnreachableCode
// ReSharper restore ConditionIsAlwaysTrueOrFalse

						var ed = context.Builder.MappingSchema.GetEntityDescriptor(expr.Type);
						return expr.Arguments
							.Select((arg,i) =>
							{
								var mi = expr.Members[i];
								if (mi is MethodInfo info)
									mi = info.GetPropertyInfo();

								var descriptor = ed.FindColumnDescriptor(mi);

								return ConvertExpressions(context, arg.UnwrapConvertToObject(), queryConvertFlag, descriptor).Select(si => si.Clone(mi));
							})
							.SelectMany(si => si)
							.ToArray();
					}

				case ExpressionType.MemberInit :
					{
						var expr = (MemberInitExpression)expression;
						var ed   = context.Builder.MappingSchema.GetEntityDescriptor(expr.Type);
						var dic  = TypeAccessor.GetAccessor(expr.Type).Members
							.Select((m,i) => new { m, i })
							.ToDictionary(_ => _.m.MemberInfo, _ => _.i);

						return expr.Bindings
							.Where  (b => b is MemberAssignment)
							.Cast<MemberAssignment>()
							.OrderBy(b => dic[expr.Type.GetMemberEx(b.Member)!])
							.Select (a =>
							{
								var mi = a.Member;
								if (mi is MethodInfo info)
									mi = info.GetPropertyInfo();

								var descriptor = ed.FindColumnDescriptor(mi);

								return ConvertExpressions(context, a.Expression, queryConvertFlag, descriptor).Select(si => si.Clone(mi));
							})
							.SelectMany(si => si)
							.ToArray();
					}
				case ExpressionType.Call         :
					{
						var callCtx = GetContext(context, expression);
						if (callCtx != null)
						{
							var mc = (MethodCallExpression)expression;
							if (IsSubQuery(callCtx, mc))
							{
								var subQueryContextInfo = GetSubQueryContext(callCtx, mc);
								if (subQueryContextInfo.Context.IsExpression(null, 0, RequestFor.Object).Result)
								{
									var info = subQueryContextInfo.Context.ConvertToSql(null, 0, ConvertFlags.All);
									return info;
								}

								return new[] { new SqlInfo (subQueryContextInfo.Context.SelectQuery) };
							}
						}
						break;
					}
				case ExpressionType.NewArrayInit:
					{
						var expr = (NewArrayExpression)expression;
						var sql  = expr.Expressions
							.Select(arg => ConvertExpressions(context, arg, queryConvertFlag, columnDescriptor))
							.SelectMany(si => si)
							.ToArray();

						return sql;
					}
				case ExpressionType.ListInit:
					{
						var expr = (ListInitExpression)expression;
						var sql  = expr.Initializers
							.SelectMany(init => init.Arguments)
							.Select(arg => ConvertExpressions(context, arg, queryConvertFlag, columnDescriptor))
							.SelectMany(si => si)
							.ToArray();

						return sql;
					}
			}

			var ctx = GetContext(context, expression);

			if (ctx != null && ctx.IsExpression(expression, 0, RequestFor.Object).Result)
				return ctx.ConvertToSql(expression, 0, queryConvertFlag);

			return new[] { new SqlInfo(ConvertToSql(context, expression, false, columnDescriptor)) };
		}

		public ISqlExpression ConvertToSqlExpression(IBuildContext context, Expression expression, ColumnDescriptor? columnDescriptor, bool isPureExpression)
		{
			var expr = ConvertExpression(expression);
			return ConvertToSql(context, expr, false, columnDescriptor, isPureExpression);
		}

		public ISqlExpression ConvertToExtensionSql(IBuildContext context, Expression expression, ColumnDescriptor? columnDescriptor)
		{
			expression = expression.Unwrap();

			if (typeof(Sql.IQueryableContainer).IsSameOrParentOf(expression.Type))
			{
				Expression preparedExpression;
				if (expression.NodeType == ExpressionType.Call)
					preparedExpression = ((MethodCallExpression)expression).Arguments[0];
				else 
					preparedExpression = ((Sql.IQueryableContainer)expression.EvaluateExpression()!).Query.Expression;
				return ConvertToExtensionSql(context, preparedExpression, columnDescriptor);
			}

			if (expression is LambdaExpression lambda)
			{
				var saveParent = context.Parent;
				ExpressionContext exprCtx;

				IBuildContext valueSequence = context;

				if (context is SelectContext sc && sc.Sequence[0] is GroupByBuilder.GroupByContext)
					valueSequence = sc.Sequence[0];

				if (valueSequence is GroupByBuilder.GroupByContext groupByContext)
				{
					valueSequence = groupByContext.Element;
				}

				exprCtx = new ExpressionContext(valueSequence.Parent, valueSequence, lambda);

				var result = ConvertToSql(exprCtx, lambda.Body, false, columnDescriptor);
				ReplaceParent(context.Parent!, saveParent);
				if (!(result is SqlField field) || field.Table!.All != field)
					return result;
				result = context.ConvertToSql(null, 0, ConvertFlags.Field).Select(_ => _.Sql).FirstOrDefault();
				return result;
			}

			if (!MappingSchema.IsScalarType(expression.Type) && typeof(IQueryable<>).IsSameOrParentOf(expression.Type))
				return context.ConvertToSql(null, 0, ConvertFlags.Field).Select(_ => _.Sql).FirstOrDefault();

			return ConvertToSql(context, expression, false, columnDescriptor);
		}

		public ParameterAccessor? RegisterParameter(Expression expression) 
		{
			if (typeof(IToSqlConverter).IsSameOrParentOf(expression.Type))
			{
				//TODO: Check this
				var sql = ConvertToSqlConvertible(expression);
				if (sql != null)
					return null;
			}

			if (!PreferServerSide(expression, false))
			{
				if (CanBeConstant(expression))
					return null;

				if (CanBeCompiled(expression))
				{
					return BuildParameter(expression, null);
				}
			}

			return null;
		}

		public ISqlExpression ConvertToSql(IBuildContext? context, Expression expression, bool unwrap = false, ColumnDescriptor? columnDescriptor = null, bool isPureExpression = false)
		{
			if (typeof(IToSqlConverter).IsSameOrParentOf(expression.Type))
			{
				var sql = ConvertToSqlConvertible(expression);
				if (sql != null)
					return sql;
			}

			if (!PreferServerSide(expression, false))
			{
				if (columnDescriptor?.ValueConverter == null && CanBeConstant(expression))
					return BuildConstant(expression, columnDescriptor);

				if (CanBeCompiled(expression))
					return BuildParameter(expression, columnDescriptor).SqlParameter;
			}

			if (unwrap)
				expression = expression.Unwrap();

			switch (expression.NodeType)
			{
				case ExpressionType.AndAlso            :
				case ExpressionType.OrElse             :
				case ExpressionType.Not                :
				case ExpressionType.Equal              :
				case ExpressionType.NotEqual           :
				case ExpressionType.GreaterThan        :
				case ExpressionType.GreaterThanOrEqual :
				case ExpressionType.LessThan           :
				case ExpressionType.LessThanOrEqual    :
					{
						var condition = new SqlSearchCondition();
						BuildSearchCondition(context, expression, condition.Conditions);
						return condition;
					}

				case ExpressionType.And                :
				case ExpressionType.Or                 :
					{
						if (expression.Type == typeof(bool))
							goto case ExpressionType.AndAlso;
						goto case ExpressionType.Add;
					}

				case ExpressionType.Add                :
				case ExpressionType.AddChecked         :
				case ExpressionType.Divide             :
				case ExpressionType.ExclusiveOr        :
				case ExpressionType.Modulo             :
				case ExpressionType.Multiply           :
				case ExpressionType.MultiplyChecked    :
				case ExpressionType.Power              :
				case ExpressionType.Subtract           :
				case ExpressionType.SubtractChecked    :
				case ExpressionType.Coalesce           :
					{
						var e = (BinaryExpression)expression;
						
						ISqlExpression l;
						ISqlExpression r;
						var shouldCheckColumn =
							e.Left.Type.ToNullableUnderlying() == e.Right.Type.ToNullableUnderlying();

						if (shouldCheckColumn)
						{
							var ls = GetContext(context, e.Left);
							if (ls?.IsExpression(e.Left, 0, RequestFor.Field).Result == true)
							{
								l = ConvertToSql(context, e.Left);
								r = ConvertToSql(context, e.Right, true, QueryHelper.GetColumnDescriptor(l) ?? columnDescriptor);
							}
							else
							{
								r = ConvertToSql(context, e.Right, true);
								l = ConvertToSql(context, e.Left, false, QueryHelper.GetColumnDescriptor(r) ?? columnDescriptor);
							}
						}
						else
						{
							l = ConvertToSql(context, e.Left, true, columnDescriptor);
							r = ConvertToSql(context, e.Right, true, null);
						}

						var t = e.Type;

						switch (expression.NodeType)
						{
							case ExpressionType.Add             :
							case ExpressionType.AddChecked      : return new SqlBinaryExpression(t, l, "+", r, Precedence.Additive);
							case ExpressionType.And             : return new SqlBinaryExpression(t, l, "&", r, Precedence.Bitwise);
							case ExpressionType.Divide          : return new SqlBinaryExpression(t, l, "/", r, Precedence.Multiplicative);
							case ExpressionType.ExclusiveOr     : return new SqlBinaryExpression(t, l, "^", r, Precedence.Bitwise);
							case ExpressionType.Modulo          : return new SqlBinaryExpression(t, l, "%", r, Precedence.Multiplicative);
							case ExpressionType.Multiply:
							case ExpressionType.MultiplyChecked : return new SqlBinaryExpression(t, l, "*", r, Precedence.Multiplicative);
							case ExpressionType.Or              : return new SqlBinaryExpression(t, l, "|", r, Precedence.Bitwise);
							case ExpressionType.Power           : return new SqlFunction(t, "Power", l, r);
							case ExpressionType.Subtract        :
							case ExpressionType.SubtractChecked : return new SqlBinaryExpression(t, l, "-", r, Precedence.Subtraction);
							case ExpressionType.Coalesce        :
								{
									if (QueryHelper.UnwrapExpression(r) is SqlFunction c)
									{
										if (c.Name == "Coalesce")
										{
											var parms = new ISqlExpression[c.Parameters.Length + 1];

											parms[0] = l;
											c.Parameters.CopyTo(parms, 1);

											return new SqlFunction(t, "Coalesce", parms);
										}
									}

									return new SqlFunction(t, "Coalesce", l, r);
								}
						}

						break;
					}

				case ExpressionType.UnaryPlus      :
				case ExpressionType.Negate         :
				case ExpressionType.NegateChecked  :
					{
						var e = (UnaryExpression)expression;
						var o = ConvertToSql(context, e.Operand);
						var t = e.Type;

						switch (expression.NodeType)
						{
							case ExpressionType.UnaryPlus     : return o;
							case ExpressionType.Negate        :
							case ExpressionType.NegateChecked :
								return new SqlBinaryExpression(t, new SqlValue(-1), "*", o, Precedence.Multiplicative);
						}

						break;
					}

				case ExpressionType.Convert        :
				case ExpressionType.ConvertChecked :
					{
						var e = (UnaryExpression)expression;

						var o = ConvertToSql(context, e.Operand);

						if (e.Method == null && e.IsLifted)
							return o;

						if (e.Type == typeof(bool) && e.Operand.Type == typeof(SqlBoolean))
							return o;

						var t = e.Operand.Type;
						var s = SqlDataType.GetDataType(t);

						if (o.SystemType != null && s.Type.SystemType == typeof(object))
						{
							t = o.SystemType;
							s = SqlDataType.GetDataType(t);
						}

						if (e.Type == t ||
							t.IsEnum      && Enum.GetUnderlyingType(t)      == e.Type ||
							e.Type.IsEnum && Enum.GetUnderlyingType(e.Type) == t)
							return o;

						return new SqlFunction(e.Type, "$Convert$", SqlDataType.GetDataType(e.Type), s, o);
					}

				case ExpressionType.Conditional    :
					{
						var e = (ConditionalExpression)expression;
						var s = ConvertToSql(context, e.Test);
						var t = ConvertToSql(context, e.IfTrue);
						var f = ConvertToSql(context, e.IfFalse);

						if (QueryHelper.UnwrapExpression(f) is SqlFunction c && c.Name == "CASE")
						{
							var parms = new ISqlExpression[c.Parameters.Length + 2];

							parms[0] = s;
							parms[1] = t;
							c.Parameters.CopyTo(parms, 2);

							return new SqlFunction(e.Type, "CASE", parms) { CanBeNull = false };
						}

						return new SqlFunction(e.Type, "CASE", s, t, f) { CanBeNull = false };
					}

				case ExpressionType.MemberAccess :
					{
						var ma   = (MemberExpression)expression;
						var attr = GetExpressionAttribute(ma.Member);

						if (attr != null)
						{
							var converted = attr.GetExpression(DataContext, context!.SelectQuery, ma,
								(e, descriptor) => ConvertToExtensionSql(context, e, descriptor));

							if (converted == null)
							{
								if (attr.ExpectExpression)
								{
									var exp = ConvertToSql(context, ma.Expression);
									converted = attr.GetExpression(ma.Member, exp);
								}
								else
								{
									converted = attr.GetExpression(ma.Member);
								}
							}

							return converted;
						}

						var ctx = GetContext(context, expression);

						if (ctx != null)
						{
							var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

							switch (sql.Length)
							{
								case 0  : break;
								case 1  : return sql[0].Sql;
								default : throw new InvalidOperationException();
							}
						}

						break;
					}

				case ExpressionType.Parameter   :
					{
						var ctx = GetContext(context, expression);

						if (ctx != null)
						{
							var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

							switch (sql.Length)
							{
								case 0  : break;
								case 1  : return sql[0].Sql;
								default : throw new InvalidOperationException();
							}
						}

						break;
					}

				case ExpressionType.Extension   :
					{
						var ctx = GetContext(context, expression);

						if (ctx != null)
						{
							var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

							switch (sql.Length)
							{
								case 0  : break;
								case 1  : return sql[0].Sql;
								default : throw new InvalidOperationException();
							}
						}

						break;
					}

				case ExpressionType.Call        :
					{
						var e = (MethodCallExpression)expression;

						var isAggregation = e.IsAggregate(MappingSchema);
						if (isAggregation && !e.IsQueryable())
						{
							var arg = e.Arguments[0];
							var enumerableType = arg.Type;
							if (!EagerLoading.IsEnumerableType(enumerableType, MappingSchema))
								isAggregation = false;
							else
							{
								var elementType = EagerLoading.GetEnumerableElementType(enumerableType, MappingSchema);
								if (!e.Method.GetParameters()[0].ParameterType.IsSameOrParentOf(typeof(IEnumerable<>).MakeGenericType(elementType)))
									isAggregation = false;
							}
						}

						if ((isAggregation || e.IsQueryable()) && !ContainsBuilder.IsConstant(e))
						{
							if (IsSubQuery(context!, e))
								return SubQueryToSql(context!, e);

							if (isAggregation)
							{
								var ctx = GetContext(context, expression);

								if (ctx != null)
								{
									var sql = ctx.ConvertToSql(expression, 0, ConvertFlags.Field);

									if (sql.Length != 1)
										throw new InvalidOperationException();

									return sql[0].Sql;
								}

								break;
							}

							return SubQueryToSql(context!, e);
						}

						var expr = ConvertMethod(e);

						if (expr != null)
							return ConvertToSql(context, expr, unwrap);

						var attr = GetExpressionAttribute(e.Method);

						if (attr != null)
						{
							return ConvertExtensionToSql(context!, attr, e);
						}

						if (e.Method.IsSqlPropertyMethodEx())
							return ConvertToSql(context, ConvertExpression(expression), unwrap);

						if (e.Method.DeclaringType == typeof(string) && e.Method.Name == "Format")
						{
							return ConvertFormatToSql(context, e, isPureExpression);
						}

						if (e.IsSameGenericMethod(Methods.LinqToDB.SqlExt.Alias))
						{
							var sql = ConvertToSql(context, e.Arguments[0], unwrap);
							return sql;
						}

						break;
					}

				case ExpressionType.Invoke :
					{
						var pi = (InvocationExpression)expression;
						var ex = pi.Expression;

						if (ex.NodeType == ExpressionType.Quote)
							ex = ((UnaryExpression)ex).Operand;

						if (ex.NodeType == ExpressionType.Lambda)
						{
							var l   = (LambdaExpression)ex;
							var dic = new Dictionary<Expression,Expression>();

							for (var i = 0; i < l.Parameters.Count; i++)
								dic.Add(l.Parameters[i], pi.Arguments[i]);

							var pie = l.Body.Transform(wpi => dic.TryGetValue(wpi, out var ppi) ? ppi : wpi);

							return ConvertToSql(context, pie);
						}

						break;
					}

				case ExpressionType.TypeIs :
					{
						var condition = new SqlSearchCondition();
						BuildSearchCondition(context, expression, condition.Conditions);
						return condition;
					}

				case ChangeTypeExpression.ChangeTypeType :
					return ConvertToSql(context, ((ChangeTypeExpression)expression).Expression);

				case ExpressionType.Constant:
					{
						var cnt = (ConstantExpression)expression;
						if (cnt.Value is ISqlExpression sql)
							return sql;
						break;
					}
			}

			if (expression.Type == typeof(bool) && _convertedPredicates.Add(expression))
			{
				var predicate = ConvertPredicate(context, expression);
				_convertedPredicates.Remove(expression);
				if (predicate != null)
					return new SqlSearchCondition(new SqlCondition(false, predicate));
			}

			throw new LinqException("'{0}' cannot be converted to SQL.", expression);
		}

		public ISqlExpression ConvertFormatToSql(IBuildContext? context, MethodCallExpression mc, bool isPureExpression)
		{
			// TODO: move PrepareRawSqlArguments to more correct location
			TableBuilder.PrepareRawSqlArguments(mc, null,
				out var format, out var arguments);
			var sqlArguments = arguments.Select(a => ConvertToSql(context, a)).ToArray();

			if (isPureExpression)
			{
				return new SqlExpression(mc.Type, format, Precedence.Primary, sqlArguments);
			}

			return QueryHelper.ConvertFormatToConcatenation(format, sqlArguments);
		}

		public ISqlExpression ConvertExtensionToSql(IBuildContext context, Sql.ExpressionAttribute attr, MethodCallExpression mc)
		{
			var inlineParameters = DataContext.InlineParameters;

			if (attr.InlineParameters)
				DataContext.InlineParameters = true;

			var sqlExpression =
				attr.GetExpression(DataContext, context!.SelectQuery, mc, (e, descriptor) => ConvertToExtensionSql(context, e, descriptor));
			if (sqlExpression != null)
				return sqlExpression;

			var parms = new List<ISqlExpression>();

			if (mc.Object != null)
				parms.Add(ConvertToSql(context, mc.Object));

			ParameterInfo[]? pis = null;

			for (var i = 0; i < mc.Arguments.Count; i++)
			{
				var arg = mc.Arguments[i];

				if (arg is NewArrayExpression nae)
				{
					if (pis == null)
						pis = mc.Method.GetParameters();

					var p = pis[i];

					if (p.GetCustomAttributes(true).OfType<ParamArrayAttribute>().Any())
					{
						parms.AddRange(nae.Expressions.Select(a => ConvertToSql(context, a)));
					}
					else
					{
						parms.Add(ConvertToSql(context, nae));
					}
				}
				else
				{
					parms.Add(ConvertToSql(context, arg));
				}
			}

			DataContext.InlineParameters = inlineParameters;

			return attr.GetExpression(mc.Method, parms.ToArray());
		}

		static ISqlExpression ConvertToSqlConvertible(Expression expression)
		{
			var l = Expression.Lambda<Func<IToSqlConverter>>(expression);
			var f = l.CompileExpression();
			var c = f();

			return c.ToSql(expression);
		}

		readonly HashSet<Expression> _convertedPredicates = new HashSet<Expression>();

		#endregion

		#region IsServerSideOnly

		public bool IsServerSideOnly(Expression expr)
		{
			return _optimizationContext.IsServerSideOnly(expr);
		}

		#endregion

		#region CanBeConstant

		bool CanBeConstant(Expression expr)
		{
			return _optimizationContext.CanBeConstant(expr);
		}

		#endregion

		#region CanBeCompiled

		bool CanBeCompiled(Expression expr)
		{
			return _optimizationContext.CanBeCompiled(expr);
		}

		#endregion

		#region Build Constant

		readonly Dictionary<Tuple<Expression, ColumnDescriptor?>,SqlValue> _constants = new Dictionary<Tuple<Expression, ColumnDescriptor?>,SqlValue>();

		SqlValue BuildConstant(Expression expr, ColumnDescriptor? columnDescriptor)
		{
			var key = Tuple.Create(expr, columnDescriptor);
			if (_constants.TryGetValue(key, out var sqlValue))
				return sqlValue;

			var dbType = columnDescriptor?.GetDbDataType(true).WithSystemType(expr.Type) ?? new DbDataType(expr.Type);

			var unwrapped = expr.Unwrap();
			if (unwrapped != expr && !MappingSchema.ValueToSqlConverter.CanConvert(dbType.SystemType) &&
			    MappingSchema.ValueToSqlConverter.CanConvert(unwrapped.Type))
			{
				dbType = dbType.WithSystemType(unwrapped.Type);
				expr = unwrapped;
			}

			dbType = dbType.WithSystemType(expr.Type);

			if (columnDescriptor != null)
			{
				expr = columnDescriptor.ApplyConversions(expr, dbType, true);
			}
			else
			{
				if (!MappingSchema.ValueToSqlConverter.CanConvert(dbType.SystemType))
					expr = ColumnDescriptor.ApplyConversions(MappingSchema, expr, dbType, null, true);
			}

			var value = expr.EvaluateExpression();

			if (value != null && MappingSchema.ValueToSqlConverter.CanConvert(dbType.SystemType))
				sqlValue = new SqlValue(dbType, value);
			else
			{
				if (value != null && value.GetType().IsEnum)
				{
					var attrs = value.GetType().GetCustomAttributes(typeof(Sql.EnumAttribute), true);

					if (attrs.Length == 0)
						value = MappingSchema.EnumToValue((Enum)value);
				}

				sqlValue = MappingSchema.GetSqlValue(expr.Type, value);
			}

			_constants.Add(key, sqlValue);

			return sqlValue;
		}

		#endregion

		#region Build Parameter

		internal readonly Dictionary<Expression,ParameterAccessor> _parameters = new Dictionary<Expression,ParameterAccessor>();

		internal void AddCurrentSqlParameter(ParameterAccessor parameterAccessor)
		{
			var idx = CurrentSqlParameters.Count;
			CurrentSqlParameters.Add(parameterAccessor);
			parameterAccessor.SqlParameter.AccessorId = idx;
		}

		internal enum BuildParameterType
		{
			Default,
			InPredicate
		}

		public ParameterAccessor BuildParameter(Expression expr, ColumnDescriptor? columnDescriptor, bool forceConstant = false,
			BuildParameterType buildParameterType = BuildParameterType.Default)
		{
			if (_parameters.TryGetValue(expr, out var p))
				return p;

			string? name = null;

			ValueTypeExpression newExpr;
			newExpr = ReplaceParameter(_expressionAccessors, expr, forceConstant, nm => name = nm);

			p = PrepareConvertersAndCreateParameter(newExpr, expr, name, columnDescriptor, buildParameterType);

			var found = p;
			foreach (var accessor in _parameters)
			{
				if (accessor.Value.SqlParameter.Type.Equals(p.SqlParameter.Type))
					continue;

				if (accessor.Key.EqualsTo(expr, DataContext, new Dictionary<Expression, QueryableAccessor>(), null,
					null, compareConstantValues: true))
				{
					found = accessor.Value;
					break;
				}
			}

			// We already have registered parameter for the same expression
			//
			if (!ReferenceEquals(found, p))
				return found;

			_parameters.Add(expr, p);
			AddCurrentSqlParameter(p);

			return p;
		}

		public ParameterAccessor BuildParameterFromArgumentProperty(MethodCallExpression methodCall, int argumentIndex, ColumnDescriptor columnDescriptor,
			BuildParameterType buildParameterType = BuildParameterType.Default)
		{
			var valueAccessor = GenerateArgumentAccessor(methodCall, argumentIndex, null);

			valueAccessor = Expression.MakeMemberAccess(valueAccessor, columnDescriptor.MemberInfo);

			var dataType = columnDescriptor.GetDbDataType(true);
			var newExpr  = new ValueTypeExpression
			{
				DataType             = dataType,
				DbDataTypeExpression = Expression.Constant(dataType),
				ValueExpression      = valueAccessor
			};

			var p = PrepareConvertersAndCreateParameter(newExpr, valueAccessor, null, columnDescriptor,
				buildParameterType);
			AddCurrentSqlParameter(p);

			return p;
		}

		public ParameterAccessor BuildParameterFromArgument(MethodCallExpression methodCall, int argumentIndex, ColumnDescriptor? columnDescriptor,
			BuildParameterType buildParameterType = BuildParameterType.Default)
		{
			var valueAccessor = GenerateArgumentAccessor(methodCall, argumentIndex, columnDescriptor);

			var dataType = new DbDataType(valueAccessor.Type);
			var newExpr  = new ValueTypeExpression
			{
				DataType             = dataType,
				DbDataTypeExpression = Expression.Constant(dataType),
				ValueExpression      = valueAccessor
			};

			var p = PrepareConvertersAndCreateParameter(newExpr, valueAccessor, null, columnDescriptor,
				buildParameterType);
			AddCurrentSqlParameter(p);

			return p;
		}

		Expression? GetActualMethodAccessor(MethodCallExpression methodCall)
		{
			Expression? current = methodCall;
			if (_expressionAccessors.TryGetValue(current, out var methodAccessor))
				return methodAccessor;

			// Looking in known accessors for method with only changed first parameter.
			// Typical case when we have transformed Queryable method chain.
			foreach (var accessorPair in _expressionAccessors)
			{
				if (accessorPair.Key.NodeType != ExpressionType.Call)
					continue;

				var mc = (MethodCallExpression)accessorPair.Key;
				if (mc.Method != methodCall.Method)
					continue;

				var isEqual = true;
				for (int i = 1; i < mc.Arguments.Count; i++)
				{
					isEqual = (mc.Arguments[i].Equals(methodCall.Arguments[i]));
					if (!isEqual)
						break;
				}
				if (isEqual)
				{
					return accessorPair.Value;
				}
			}

			return null;
		}

		Expression GenerateArgumentAccessor(MethodCallExpression methodCall, int argumentIndex, ColumnDescriptor? columnDescriptor)
		{
			var arg = methodCall.Arguments[argumentIndex];
			var methodAccessor = GetActualMethodAccessor(methodCall);
			if (methodAccessor == null)
			{
				// compiled query case
				//
				if (null == arg.Find(e => e == ParametersParam))
					throw new InvalidOperationException($"Method '{methodCall}' does not have accessor.");
				return arg;
			}

			var prop = Expression.Property(methodAccessor, ReflectionHelper.MethodCall.Arguments);
			var valueAccessorExpr = Expression.Call(prop, ReflectionHelper.IndexExpressor<Expression>.Item,
				Expression.Constant(argumentIndex));

			var expectedType = columnDescriptor?.MemberType ?? arg.Type;

			var evaluatedExpr = Expression.Call(null,
				MemberHelper.MethodOf(() => InternalExtensions.EvaluateExpression(null)),
				valueAccessorExpr);

			var valueAccessor = (Expression)evaluatedExpr;
			valueAccessor = Expression.Convert(valueAccessor, expectedType);

			return valueAccessor;
		}

		ParameterAccessor PrepareConvertersAndCreateParameter(ValueTypeExpression newExpr, Expression valueExpression, string? name, ColumnDescriptor? columnDescriptor, BuildParameterType buildParameterType)
		{
			var originalAccessor = newExpr.ValueExpression;
			if (buildParameterType != BuildParameterType.InPredicate)
			{
				if (!typeof(DataParameter).IsSameOrParentOf(newExpr.ValueExpression.Type))
				{
					if (columnDescriptor != null && !(originalAccessor is BinaryExpression))
					{
						newExpr.DataType = columnDescriptor.GetDbDataType(true);
						if (newExpr.ValueExpression.Type != columnDescriptor.MemberType)
						{
							newExpr.ValueExpression = newExpr.ValueExpression.UnwrapConvert()!;
							var memberType = columnDescriptor.MemberType;
							if (newExpr.ValueExpression.Type != memberType)
							{
								if (!newExpr.ValueExpression.Type.IsNullable() || newExpr.ValueExpression.Type.ToNullableUnderlying() != memberType)
								{
									var convertLambda = MappingSchema.GenerateSafeConvert(newExpr.ValueExpression.Type,
										memberType);
									newExpr.ValueExpression =
										InternalExtensions.ApplyLambdaToExpression(convertLambda,
											newExpr.ValueExpression);
								}
							}
						}				

						newExpr.ValueExpression = columnDescriptor.ApplyConversions(newExpr.ValueExpression, newExpr.DataType, true);

						if (name == null)
						{
							if (columnDescriptor.MemberName.Contains('.'))
								name = columnDescriptor.ColumnName;
							else
								name = columnDescriptor.MemberName;

						}

						newExpr.DbDataTypeExpression = Expression.Constant(newExpr.DataType);
					}
					else
					{
						newExpr.ValueExpression = ColumnDescriptor.ApplyConversions(MappingSchema, newExpr.ValueExpression, newExpr.DataType, null, true);
					}
				}

				if (typeof(DataParameter).IsSameOrParentOf(newExpr.ValueExpression.Type))
				{
					newExpr.DbDataTypeExpression = Expression.PropertyOrField(newExpr.ValueExpression, nameof(DataParameter.DbDataType));

					if (columnDescriptor != null)
					{
						var dbDataType = columnDescriptor.GetDbDataType(false);
						newExpr.DbDataTypeExpression = Expression.Call(Expression.Constant(dbDataType),
							DbDataType.WithSetValuesMethodInfo, newExpr.DbDataTypeExpression);
					}

					newExpr.ValueExpression      = Expression.PropertyOrField(newExpr.ValueExpression, nameof(DataParameter.Value));
				}
			}

			name ??= columnDescriptor?.MemberName;

			var p = CreateParameterAccessor(
				DataContext, newExpr.ValueExpression, originalAccessor, newExpr.DbDataTypeExpression, valueExpression, ExpressionParam,
				ParametersParam, DataContextParam, name);

			return p;
		}

		class ValueTypeExpression
		{
			public Expression ValueExpression      = null!;
			public Expression DbDataTypeExpression = null!;

			public DbDataType DataType;
		}

		ValueTypeExpression ReplaceParameter(IDictionary<Expression,Expression> expressionAccessors, Expression expression, bool forceConstant, Action<string> setName)
		{
			var result = new ValueTypeExpression
			{
				DataType             = new DbDataType(expression.Type),
				DbDataTypeExpression = Expression.Constant(new DbDataType(expression.Type), typeof(DbDataType)),
			};

			var unwrapped = expression.Unwrap();
			if (unwrapped.NodeType == ExpressionType.MemberAccess)
			{
				var ma = (MemberExpression)unwrapped;
				setName(ma.Member.Name);
			}

			result.ValueExpression = expression.Transform(expr =>
			{
				if (expr.NodeType == ExpressionType.Constant)
				{
					var c = (ConstantExpression)expr;

					if (forceConstant || !expr.Type.IsConstantable(false))
					{
						if (expressionAccessors.TryGetValue(expr, out var val))
						{
							expr = Expression.Convert(val, expr.Type);

							if (expression.NodeType == ExpressionType.MemberAccess)
							{
								var ma = (MemberExpression)expression;

								var mt = GetMemberDataType(ma.Member);

								if (mt.DataType != DataType.Undefined)
								{
									result.DataType             = result.DataType.WithDataType(mt.DataType);
									result.DbDataTypeExpression = Expression.Constant(mt);
								}

								if (mt.DbType != null)
								{
									result.DataType             = result.DataType.WithDbType(mt.DbType);
									result.DbDataTypeExpression = Expression.Constant(mt);
								}

								if (mt.Length != null)
								{
									result.DataType             = result.DataType.WithLength(mt.Length);
									result.DbDataTypeExpression = Expression.Constant(mt);
								}

								setName(ma.Member.Name);
							}
						}
					}
				}

				return expr;
			});

			return result;
		}

		#endregion

		#region Predicate Converter

		ISqlPredicate ConvertPredicate(IBuildContext? context, Expression expression)
		{
			var isPredicate = true;

			switch (expression.NodeType)
			{
				case ExpressionType.Equal              :
				case ExpressionType.NotEqual           :
				case ExpressionType.GreaterThan        :
				case ExpressionType.GreaterThanOrEqual :
				case ExpressionType.LessThan           :
				case ExpressionType.LessThanOrEqual    :
					{
						var e = (BinaryExpression)expression;
						return ConvertCompare(context, expression.NodeType, e.Left, e.Right);
					}

				case ExpressionType.Call               :
					{
						var e = (MethodCallExpression)expression;

						ISqlPredicate? predicate = null;

						if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)
							return ConvertCompare(context, ExpressionType.Equal, e.Object, e.Arguments[0]);

						if (e.Method.DeclaringType == typeof(string))
						{
							switch (e.Method.Name)
							{
								case "Contains"   : predicate = CreateStringPredicate(context, e, SqlPredicate.SearchString.SearchKind.Contains);   break;
								case "StartsWith" : predicate = CreateStringPredicate(context, e, SqlPredicate.SearchString.SearchKind.StartsWith); break;
								case "EndsWith"   : predicate = CreateStringPredicate(context, e, SqlPredicate.SearchString.SearchKind.EndsWith);   break;
							}
						}
						else if (e.Method.Name == "Contains")
						{
							if (e.Method.DeclaringType == typeof(Enumerable) ||
								typeof(IList).        IsSameOrParentOf(e.Method.DeclaringType!) ||
								typeof(ICollection<>).IsSameOrParentOf(e.Method.DeclaringType!))
							{
								predicate = ConvertInPredicate(context!, e);
							}
						}
						else if (e.Method.Name == "ContainsValue" && typeof(Dictionary<,>).IsSameOrParentOf(e.Method.DeclaringType!))
						{
							var args = e.Method.DeclaringType!.GetGenericArguments(typeof(Dictionary<,>))!;
							var minf = EnumerableMethods
								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)
								.MakeGenericMethod(args[1]);

							var expr = Expression.Call(
								minf,
								ExpressionHelper.PropertyOrField(e.Object!, "Values"),
								e.Arguments[0]);

							predicate = ConvertInPredicate(context!, expr);
						}
						else if (e.Method.Name == "ContainsKey" && typeof(IDictionary<,>).IsSameOrParentOf(e.Method.DeclaringType!))
						{
							var args = e.Method.DeclaringType!.GetGenericArguments(typeof(IDictionary<,>))!;
							var minf = EnumerableMethods
								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)
								.MakeGenericMethod(args[0]);

							var expr = Expression.Call(
								minf,
								ExpressionHelper.PropertyOrField(e.Object!, "Keys"),
								e.Arguments[0]);

							predicate = ConvertInPredicate(context!, expr);
						}
#if NETFRAMEWORK
						else if (e.Method == ReflectionHelper.Functions.String.Like11) predicate = ConvertLikePredicate(context!, e);
						else if (e.Method == ReflectionHelper.Functions.String.Like12) predicate = ConvertLikePredicate(context!, e);
#endif
						else if (e.Method == ReflectionHelper.Functions.String.Like21) predicate = ConvertLikePredicate(context!, e);
						else if (e.Method == ReflectionHelper.Functions.String.Like22) predicate = ConvertLikePredicate(context!, e);

						if (predicate != null)
							return predicate;

						var attr = GetExpressionAttribute(e.Method);

						if (attr != null && attr.GetIsPredicate(expression))
							break;

						isPredicate = false;
						break;
					}

				case ExpressionType.Conditional  :
					return new SqlPredicate.ExprExpr(
							ConvertToSql(context, expression),
							SqlPredicate.Operator.Equal,
							new SqlValue(true), null);

				case ExpressionType.MemberAccess :
					{
						var e = (MemberExpression)expression;

						var attr = GetExpressionAttribute(e.Member);

						if (attr != null && attr.GetIsPredicate(expression))
							break;

						isPredicate = false;
						break;
					}

				case ExpressionType.TypeIs:
					{
						var e   = (TypeBinaryExpression)expression;
						var ctx = GetContext(context, e.Expression);

						if (ctx != null && ctx.IsExpression(e.Expression, 0, RequestFor.Table).Result)
							return MakeIsPredicate(ctx, e);

						break;
					}

				case ExpressionType.Convert:
					{
						var e = (UnaryExpression)expression;

						if (e.Type == typeof(bool) && e.Operand.Type == typeof(SqlBoolean))
							return ConvertPredicate(context, e.Operand);

						isPredicate = false;
						break;
					}

				case ChangeTypeExpression.ChangeTypeType:
					isPredicate = false;
					break;

				default:
					isPredicate = false;
					break;
			}

			var ex = ConvertToSql(context, expression);

			if (!isPredicate && SqlExpression.NeedsEqual(ex))
			{
				var descriptor = QueryHelper.GetColumnDescriptor(ex);
				var trueValue  = ConvertToSql(context, ExpressionHelper.TrueConstant,  false, descriptor);
				var falseValue = ConvertToSql(context, ExpressionHelper.FalseConstant, false, descriptor);

				return new SqlPredicate.IsTrue(ex, trueValue, falseValue, Configuration.Linq.CompareNullsAsValues ? false : (bool?)null, false);
			}

			return new SqlPredicate.Expr(ex);
		}

		#region ConvertCompare

		ISqlPredicate ConvertCompare(IBuildContext? context, ExpressionType nodeType, Expression left, Expression right)
		{
			if (!RestoreCompare(ref left, ref right))
				RestoreCompare(ref right, ref left);

			switch (nodeType)
			{
				case ExpressionType.Equal    :
				case ExpressionType.NotEqual :

					var p = ConvertObjectComparison(nodeType, context!, left, context!, right);
					if (p != null)
						return p;

					p = ConvertObjectNullComparison(context, left, right, nodeType == ExpressionType.Equal);
					if (p != null)
						return p;

					p = ConvertObjectNullComparison(context, right, left, nodeType == ExpressionType.Equal);
					if (p != null)
						return p;

					if (left.NodeType == ExpressionType.New || right.NodeType == ExpressionType.New)
					{
						p = ConvertNewObjectComparison(context!, nodeType, left, right);
						if (p != null)
							return p;
					}

					break;
			}

			var op = nodeType switch
			{
				ExpressionType.Equal              => SqlPredicate.Operator.Equal,
				ExpressionType.NotEqual           => SqlPredicate.Operator.NotEqual,
				ExpressionType.GreaterThan        => SqlPredicate.Operator.Greater,
				ExpressionType.GreaterThanOrEqual => SqlPredicate.Operator.GreaterOrEqual,
				ExpressionType.LessThan           => SqlPredicate.Operator.Less,
				ExpressionType.LessThanOrEqual    => SqlPredicate.Operator.LessOrEqual,
				_                                 => throw new InvalidOperationException(),
			};
			if ((left.NodeType == ExpressionType.Convert || right.NodeType == ExpressionType.Convert) && op.In(SqlPredicate.Operator.Equal, SqlPredicate.Operator.NotEqual))
			{
				var p = ConvertEnumConversion(context!, left, op, right);
				if (p != null)
					return p;
			}

			ISqlExpression l;
			ISqlExpression r;
			var ls = GetContext(context, left);
			if (ls?.IsExpression(left, 0, RequestFor.Field).Result == true)
			{
				l = ConvertToSql(context, left);
				r = ConvertToSql(context, right, true, QueryHelper.GetColumnDescriptor(l));
			}
			else
			{
				r = ConvertToSql(context, right, true);
				l = ConvertToSql(context, left, false, QueryHelper.GetColumnDescriptor(r));
			}

			l = QueryHelper.UnwrapExpression(l);
			r = QueryHelper.UnwrapExpression(r);

			if (l is SqlValue lValue)
				lValue.ValueType = GetDataType(r, lValue.ValueType);

			if (r is SqlValue rValue)
				rValue.ValueType = GetDataType(l, rValue.ValueType);

			switch (nodeType)
			{
				case ExpressionType.Equal   :
				case ExpressionType.NotEqual:

					if (!context!.SelectQuery.IsParameterDependent &&
						(l is SqlParameter && l.CanBeNull || r is SqlParameter && r.CanBeNull))
						context.SelectQuery.IsParameterDependent = true;

					// | (SqlQuery(Select([]) as q), SqlValue(null))
					// | (SqlValue(null), SqlQuery(Select([]) as q))  =>

					var q =
						l.ElementType == QueryElementType.SqlQuery &&
						r.ElementType == QueryElementType.SqlValue &&
						((SqlValue)r).Value == null &&
						((SelectQuery)l).Select.Columns.Count == 0 ?
							(SelectQuery)l :
						r.ElementType == QueryElementType.SqlQuery &&
						l.ElementType == QueryElementType.SqlValue &&
						((SqlValue)l).Value == null &&
						((SelectQuery)r).Select.Columns.Count == 0 ?
							(SelectQuery)r :
							null;

					q?.Select.Columns.Add(new SqlColumn(q, new SqlValue(1)));

					break;
			}

			if (l is SqlSearchCondition)
			{
				l = new SqlFunction(typeof(bool), "CASE", l, new SqlValue(true), new SqlValue(false))
				{
					CanBeNull = false
				};
			}

			if (r is SqlSearchCondition)
			{
				r = new SqlFunction(typeof(bool), "CASE", r, new SqlValue(true), new SqlValue(false))
				{
					CanBeNull = false
				};
			}

			ISqlPredicate? predicate = null;
			if (op.In(SqlPredicate.Operator.Equal, SqlPredicate.Operator.NotEqual))
			{
				bool?           value      = null;
				ISqlExpression? expression = null;
				var             isNullable = false;
				if ((typeof(bool) == left.Type || typeof(bool?) == left.Type) && left.Unwrap() is ConstantExpression lc)
				{
					value      = lc.Value as bool?;
					isNullable = typeof(bool?) == left.Type || r.CanBeNull;
					expression = r;
				}
				else if ((typeof(bool) == right.Type || typeof(bool?) == right.Type) && right.Unwrap() is ConstantExpression rc)
				{
					value      = rc.Value as bool?;
					isNullable = typeof(bool?) == right.Type || l.CanBeNull;
					expression = l;
				}

				if (value != null 
				    && expression != null 
				    && !(expression.ElementType == QueryElementType.SqlValue && ((SqlValue) expression).Value == null))
				{
					var isNot = !value.Value;
					var withNull = false;
					if (op == SqlPredicate.Operator.NotEqual)
					{
						isNot    = !isNot;
						withNull = true;
					}
					var descriptor = QueryHelper.GetColumnDescriptor(expression);
					var trueValue  = ConvertToSql(context, ExpressionHelper.TrueConstant,  false, descriptor);
					var falseValue = ConvertToSql(context, ExpressionHelper.FalseConstant, false, descriptor);

					var withNullValue = Configuration.Linq.CompareNullsAsValues &&
					                    (isNullable || NeedNullCheck(expression))
						? withNull
						: (bool?)null;
					predicate = new SqlPredicate.IsTrue(expression, trueValue, falseValue, withNullValue, isNot);
				}
			}

			if (predicate == null)
				predicate = new SqlPredicate.ExprExpr(l, op, r, Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);
			return predicate;
		}

		// restores original types, lost due to C# compiler optimizations
		// e.g. see https://github.com/linq2db/linq2db/issues/2041
		private static bool RestoreCompare(ref Expression op1, ref Expression op2)
		{
			if (op1.NodeType == ExpressionType.Convert)
			{
				var op1conv = (UnaryExpression)op1;

				// handle char replaced with int
				// (int)chr op CONST
				if (op1.Type == typeof(int) && op1conv.Operand.Type == typeof(char)
					&& (op2.NodeType == ExpressionType.Constant || op2.NodeType == ExpressionType.Convert))
				{
					op1 = op1conv.Operand;
					op2 = op2.NodeType == ExpressionType.Constant
						? Expression.Constant(ConvertTo<char>.From(((ConstantExpression)op2).Value))
						: ((UnaryExpression)op2).Operand;
					return true;
				}
				// (int?)chr? op CONST
				else if (op1.Type == typeof(int?) && op1conv.Operand.Type == typeof(char?)
					&& (op2.NodeType == ExpressionType.Constant
						|| (op2.NodeType == ExpressionType.Convert && ((UnaryExpression)op2).Operand.NodeType == ExpressionType.Convert)))
				{
					op1 = op1conv.Operand;
					op2 = op2.NodeType == ExpressionType.Constant
						? Expression.Constant(ConvertTo<char>.From(((ConstantExpression)op2).Value))
						: ((UnaryExpression)((UnaryExpression)op2).Operand).Operand;
					return true;
				}
				// handle enum replaced with integer
				// here byte/short values replaced with int, int+ values replaced with actual underlying type
				// (int)enum op const
				else if (op1conv.Operand.Type.IsEnum
					&& op2.NodeType == ExpressionType.Constant
						&& (op2.Type == Enum.GetUnderlyingType(op1conv.Operand.Type) || op2.Type == typeof(int)))
				{
					op1 = op1conv.Operand;
					op2 = Expression.Constant(Enum.ToObject(op1conv.Operand.Type, ((ConstantExpression)op2).Value), op1conv.Operand.Type);
					return true;
				}
				// here underlying type used
				// (int?)enum? op (int?)enum
				else if (op1conv.Operand.Type.IsNullable() && Nullable.GetUnderlyingType(op1conv.Operand.Type)!.IsEnum
					&& op2.NodeType == ExpressionType.Convert
					&& op2 is UnaryExpression op2conv2
					&& op2conv2.Operand.NodeType == ExpressionType.Constant
					&& op2conv2.Operand.Type == Nullable.GetUnderlyingType(op1conv.Operand.Type))
				{
					op1 = op1conv.Operand;
					op2 = Expression.Convert(op2conv2.Operand, op1conv.Operand.Type);
					return true;
				}
				// https://github.com/linq2db/linq2db/issues/2039
				// byte, sbyte and ushort comparison operands upcasted to int
				else if (op2.NodeType == ExpressionType.Convert
					&& op2 is UnaryExpression op2conv1
					&& op1conv.Operand.Type == op2conv1.Operand.Type)
				{
					op1 = op1conv .Operand;
					op2 = op2conv1.Operand;
					return true;
				}

				// https://github.com/linq2db/linq2db/issues/2166
				// generates expression:
				// Convert(member, int) == const(value, int)
				// we must replace it with:
				// member == const(value, member_type)
				if (op2 is ConstantExpression const2
					&& const2.Type == typeof(int)
					&& ConvertUtils.TryConvert(const2.Value, op1conv.Operand.Type, out var convertedValue))
				{
					op1 = op1conv.Operand;
					op2 = Expression.Constant(convertedValue, op1conv.Operand.Type);
					return true;
				}
			}

			return false;
		}

		#endregion

		#region ConvertEnumConversion

		ISqlPredicate? ConvertEnumConversion(IBuildContext context, Expression left, SqlPredicate.Operator op, Expression right)
		{
			Expression value;
			Expression operand;

			if (left is MemberExpression)
			{
				operand = left;
				value   = right;
			}
			else if (left.NodeType == ExpressionType.Convert && ((UnaryExpression)left).Operand is MemberExpression)
			{
				operand = ((UnaryExpression)left).Operand;
				value   = right;
			}
			else if (right is MemberExpression)
			{
				operand = right;
				value   = left;
			}
			else if (right.NodeType == ExpressionType.Convert && ((UnaryExpression)right).Operand is MemberExpression)
			{
				operand = ((UnaryExpression)right).Operand;
				value   = left;
			}
			else if (left.NodeType == ExpressionType.Convert)
			{
				operand = ((UnaryExpression)left).Operand;
				value   = right;
			}
			else
			{
				operand = ((UnaryExpression)right).Operand;
				value = left;
			}

			var type = operand.Type;

			if (!type.ToNullableUnderlying().IsEnum)
				return null;

			var dic = new Dictionary<object, object?>();

			var mapValues = MappingSchema.GetMapValues(type);

			if (mapValues != null)
				foreach (var mv in mapValues)
					if (!dic.ContainsKey(mv.OrigValue))
						dic.Add(mv.OrigValue, mv.MapValues[0].Value);

			switch (value.NodeType)
			{
				case ExpressionType.Constant:
					{
						var name = Enum.GetName(type, ((ConstantExpression)value).Value);

// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper disable HeuristicUnreachableCode
						if (name == null)
							return null;
// ReSharper restore HeuristicUnreachableCode
// ReSharper restore ConditionIsAlwaysTrueOrFalse

						var origValue = Enum.Parse(type, name, false);

						if (!dic.TryGetValue(origValue, out var mapValue))
							mapValue = origValue;

						ISqlExpression l, r;

						SqlValue sqlvalue;
						var ce = MappingSchema.GetConverter(new DbDataType(type), new DbDataType(typeof(DataParameter)), false);

						if (ce != null)
						{
							sqlvalue = new SqlValue(ce.ConvertValueToParameter(origValue).Value!);
						}
						else
						{
							sqlvalue = MappingSchema.GetSqlValue(type, mapValue);
						}

						if (left.NodeType == ExpressionType.Convert)
						{
							l = ConvertToSql(context, operand);
							r = sqlvalue;
						}
						else
						{
							r = ConvertToSql(context, operand);
							l = sqlvalue;
						}

						return new SqlPredicate.ExprExpr(l, op, r, true);
					}

				case ExpressionType.Convert:
					{
						value = ((UnaryExpression)value).Operand;

						var l = ConvertToSql(context, operand);
						var r = ConvertToSql(context, value);

						return new SqlPredicate.ExprExpr(l, op, r, true);
					}
			}

			return null;
		}

		#endregion

		#region ConvertObjectNullComparison

		ISqlPredicate? ConvertObjectNullComparison(IBuildContext? context, Expression left, Expression right, bool isEqual)
		{
			if (right.NodeType == ExpressionType.Constant && ((ConstantExpression)right).Value == null)
			{
				if (left.NodeType == ExpressionType.MemberAccess || left.NodeType == ExpressionType.Parameter)
				{
					var ctx = GetContext(context, left);

					if (ctx != null && ctx.IsExpression(left, 0, RequestFor.Object).Result)
					{
						return new SqlPredicate.Expr(new SqlValue(!isEqual));
					}
				}
			}

			return null;
		}

		#endregion

		#region ConvertObjectComparison

		static Expression? ConstructMemberPath(IEnumerable<MemberInfo> memberPath, Expression ob, bool throwOnError)
		{
			Expression result = ob;
			var skipCount     = 0;
			foreach (var memberInfo in memberPath)
			{
				if (!memberInfo.DeclaringType!.IsAssignableFrom(result.Type))
				{
					// first element may have inappropriate nesting
					if (skipCount-- == 0)
						continue;

					if (throwOnError)
						throw new LinqToDBException($"Type {result.Type.Name} does not have member {memberInfo.Name}.");
					return null;
				}
				result = Expression.MakeMemberAccess(result, memberInfo);
			}

			return result;
		}
		
		public ISqlPredicate? ConvertObjectComparison(
			ExpressionType nodeType,
			IBuildContext  leftContext,
			Expression     left,
			IBuildContext  rightContext,
			Expression     right)
		{
			var qsl = GetContext(leftContext,  left);
			var qsr = GetContext(rightContext, right);

			var sl = qsl != null && qsl.IsExpression(left,  0, RequestFor.Object).Result;
			var sr = qsr != null && qsr.IsExpression(right, 0, RequestFor.Object).Result;

			bool      isNull;
			SqlInfo[] lcols;

			var rmembers = new Dictionary<MemberInfo,Expression>(new MemberInfoComparer());

			if (sl == false && sr == false)
			{
				var lmembers = new Dictionary<MemberInfo,Expression>(new MemberInfoComparer());

				var isl = ProcessProjection(lmembers, left);
				var isr = ProcessProjection(rmembers, right);

				if (!isl && !isr)
					return null;

				if (lmembers.Count == 0)
				{
					var r = right;
					right = left;
					left  = r;

					var c = rightContext;
					rightContext = leftContext;
					leftContext  = c;

					var q = qsr;
					qsl = q;

					sr = false;

					var lm = lmembers;
					lmembers = rmembers;
					rmembers = lm;
				}

				isNull = right is ConstantExpression expression && expression.Value == null;
				lcols  = lmembers.Select(m => new SqlInfo(m.Key, ConvertToSql(leftContext, m.Value))).ToArray();
			}
			else
			{
				if (sl == false)
				{
					var r = right;
					right = left;
					left  = r;

					var c = rightContext;
					rightContext = leftContext;
					leftContext  = c;

					var q = qsr;
					qsl = q;

					sr = false;
				}

				isNull = right is ConstantExpression expression && expression.Value == null;
				
				lcols  = qsl!.ConvertToSql(left, 0, ConvertFlags.Key);

				if (!sr)
					ProcessProjection(rmembers, right);
			}

			if (lcols.Length == 0)
				return null;

			var condition = new SqlSearchCondition();

			foreach (var lcol in lcols)
			{
				if (lcol.Sql is SelectQuery innerQuery && isNull)
				{
					var existsPredicate = new SqlPredicate.FuncLike(SqlFunction.CreateExists(innerQuery));
					condition.Conditions.Add(new SqlCondition(nodeType == ExpressionType.Equal, existsPredicate));
					continue;
				}

				if (lcol.MemberChain.Length == 0)
					throw new InvalidOperationException();

				ISqlExpression? rcol = null;

				var lmember = lcol.MemberChain[lcol.MemberChain.Length - 1];

				var columnDescriptor = QueryHelper.GetColumnDescriptor(lcol.Sql);

				if (sr)
				{
					var memeberPath = ConstructMemberPath(lcol.MemberChain, right, true)!;
					rcol = ConvertToSql(rightContext, memeberPath, unwrap: false, columnDescriptor);
				}	
				else if (rmembers.Count != 0)
					rcol = ConvertToSql(rightContext, rmembers[lmember], unwrap: false, columnDescriptor);

				var rex =
					isNull ?
						MappingSchema.GetSqlValue(right.Type, null) :
						rcol ?? GetParameter(right, lmember, columnDescriptor);

				var predicate = new SqlPredicate.ExprExpr(
					lcol.Sql,
					nodeType == ExpressionType.Equal ? SqlPredicate.Operator.Equal : SqlPredicate.Operator.NotEqual,
					rex, Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);

				condition.Conditions.Add(new SqlCondition(false, predicate));
			}

			if (nodeType == ExpressionType.NotEqual)
				foreach (var c in condition.Conditions)
					c.IsOr = true;

			return condition;
		}

		internal ISqlPredicate? ConvertNewObjectComparison(IBuildContext context, ExpressionType nodeType, Expression left, Expression right)
		{
			left  = FindExpression(left);
			right = FindExpression(right);

			var condition = new SqlSearchCondition();

			if (left.NodeType != ExpressionType.New)
			{
				var temp = left;
				left  = right;
				right = temp;
			}

			var newExpr  = (NewExpression)left;

// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper disable HeuristicUnreachableCode
			if (newExpr.Members == null)
				return null;
// ReSharper restore HeuristicUnreachableCode
// ReSharper restore ConditionIsAlwaysTrueOrFalse

			for (var i = 0; i < newExpr.Arguments.Count; i++)
			{
				var lex = ConvertToSql(context, newExpr.Arguments[i]);
				var rex =
					right is NewExpression newRight ?
						ConvertToSql(context, newRight.Arguments[i]) :
						GetParameter(right, newExpr.Members[i], QueryHelper.GetColumnDescriptor(lex));

				var predicate = 
					new SqlPredicate.ExprExpr(
						lex,
						nodeType == ExpressionType.Equal ? SqlPredicate.Operator.Equal : SqlPredicate.Operator.NotEqual,
						rex, Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);

				condition.Conditions.Add(new SqlCondition(false, predicate));
			}

			if (nodeType == ExpressionType.NotEqual)
				foreach (var c in condition.Conditions)
					c.IsOr = true;

			return condition;
		}

		static Expression FindExpression(Expression expr)
		{
			var ret = expr.Find(pi =>
			{
				switch (pi.NodeType)
				{
					case ExpressionType.Convert      :
					{
						var e = (UnaryExpression)expr;

						return
							e.Operand.NodeType == ExpressionType.ArrayIndex &&
							ReferenceEquals(((BinaryExpression)e.Operand).Left, ParametersParam);
					}

					case ExpressionType.MemberAccess :
					case ExpressionType.New          :
						return true;
				}

				return false;
			});

			if (ret == null)
				throw new NotImplementedException();

			return ret;
		}

		#endregion

		#region Parameters

		ISqlExpression GetParameter(Expression ex, MemberInfo? member, ColumnDescriptor? columnDescriptor)
		{
			if (member is MethodInfo mi)
				member = mi.GetPropertyInfo();

			var vte  = ReplaceParameter(_expressionAccessors, ex, forceConstant: false, _ => { });
			var par  = vte.ValueExpression;
			var expr = Expression.MakeMemberAccess(par.Type == typeof(object) ? Expression.Convert(par, member?.DeclaringType ?? typeof(object)) : par, member);

			vte.ValueExpression = expr;

			if (columnDescriptor != null)
			{
				var dbDataType = columnDescriptor.GetDbDataType(true);
				vte.DataType = dbDataType;
				vte.DbDataTypeExpression = Expression.Constant(dbDataType);
			}

			if (!expr.Type.IsSameOrParentOf(vte.DataType.SystemType))
			{
				var dbDataType = new DbDataType(expr.Type);
				vte.DataType = dbDataType;
				vte.DbDataTypeExpression = Expression.Constant(dbDataType);
			}

			var p = PrepareConvertersAndCreateParameter(vte, expr, member?.Name, columnDescriptor, BuildParameterType.Default);

			_parameters.Add(expr, p);
			AddCurrentSqlParameter(p);

			return p.SqlParameter;
		}

		DbDataType GetMemberDataType(MemberInfo member)
		{
			var typeResult = new DbDataType(member.GetMemberType());

			var dta      = MappingSchema.GetAttribute<DataTypeAttribute>(member.ReflectedType!, member);
			var ca       = MappingSchema.GetAttribute<ColumnAttribute>  (member.ReflectedType!, member);

			var dataType = ca?.DataType ?? dta?.DataType;

			if (dataType != null)
				typeResult = typeResult.WithDataType(dataType.Value);

			var dbType = ca?.DbType ?? dta?.DbType;
			if (dbType != null)
				typeResult = typeResult.WithDbType(dbType);

			if (ca != null && ca.HasLength())
				typeResult = typeResult.WithLength(ca.Length);

			return typeResult;
		}

		static DbDataType GetDataType(ISqlExpression expr, DbDataType baseType)
		{
			var systemType = baseType.SystemType;
			var dataType   = baseType.DataType;
			var dbType     = baseType.DbType;
			var length     = baseType.Length;
			var precision  = baseType.Precision;
			var scale      = baseType.Scale;

			new QueryVisitor().Find(expr, e =>
			{
				switch (e.ElementType)
				{
					case QueryElementType.SqlField:
						{
							var fld = (SqlField)e;
							if (fld.Type != null)
							{
								dataType     = fld.Type.Value.DataType;
								dbType       = fld.Type.Value.DbType;
								length       = fld.Type.Value.Length;
								precision    = fld.Type.Value.Precision;
								scale        = fld.Type.Value.Scale;
								//systemType = ((SqlField)e).SystemType;
							}
							return true;
						}
					case QueryElementType.SqlParameter:
						dataType     = ((SqlParameter)e).Type.DataType;
						dbType       = ((SqlParameter)e).Type.DbType;
						length       = ((SqlParameter)e).Type.Length;
						precision    = ((SqlParameter)e).Type.Precision;
						scale        = ((SqlParameter)e).Type.Scale;
						//systemType = ((SqlParameter)e).SystemType;
						return true;
					case QueryElementType.SqlDataType:
						dataType     = ((SqlDataType)e).Type.DataType;
						dbType       = ((SqlDataType)e).Type.DbType;
						length       = ((SqlDataType)e).Type.Length;
						precision    = ((SqlDataType)e).Type.Precision;
						scale        = ((SqlDataType)e).Type.Scale;
						//systemType = ((SqlDataType)e).SystemType;
						return true;
					case QueryElementType.SqlValue:
						dataType     = ((SqlValue)e).ValueType.DataType;
						dbType       = ((SqlValue)e).ValueType.DbType;
						length       = ((SqlValue)e).ValueType.Length;
						precision    = ((SqlValue)e).ValueType.Precision;
						scale        = ((SqlValue)e).ValueType.Scale;
						//systemType = ((SqlValue)e).ValueType.SystemType;
						return true;
					default:
						return false;
				}
			});

			return new DbDataType(
				systemType ?? baseType.SystemType,
				dataType == DataType.Undefined ? baseType.DataType : dataType,
				string.IsNullOrEmpty(dbType)   ? baseType.DbType   : dbType,
				length     ?? baseType.Length,
				precision  ?? baseType.Precision,
				scale      ?? baseType.Scale
			);
		}

		static Expression CorrectAccessorExpression(Expression accessorExpression, IDataContext dataContext, ParameterExpression dataContextParam)
		{
			// see #820
			accessorExpression = accessorExpression.Transform(e =>
			{
				if (e.NodeType.NotIn(ExpressionType.Parameter, ExpressionType.Convert, ExpressionType.ConvertChecked)
				    && dataContextParam.Type.IsSameOrParentOf(e.Type))
				{
					var newExpr = (Expression) dataContextParam;
					if (newExpr.Type != e.Type)
						newExpr = Expression.Convert(newExpr, e.Type);
					return newExpr;
				}

				switch (e.NodeType)
				{
					case ExpressionType.Parameter:
					{
						// DataContext creates DataConnection which is not compatible with QueryRunner and parameter evaluation.
						// It can be fixed by adding additional parameter to execution path, but it's may slowdown performance.
						// So for now decided to throw exception.
						if (e == dataContextParam && !typeof(DataConnection).IsSameOrParentOf(dataContext.GetType()))
							throw new LinqException("Only DataConnection descendants can be used as source of parameters.");
						return e;
					}
					case ExpressionType.MemberAccess:
					{
						var ma = (MemberExpression) e;

						if (ma.Member.IsNullableValueMember())
						{
							return Expression.Condition(
								Expression.Equal(ma.Expression, Expression.Constant(null, ma.Expression.Type)),
								Expression.Default(e.Type),
								e);
						}

						return e;
					}
					case ExpressionType.Convert:
					{
						var ce = (UnaryExpression) e;
						if (ce.Operand.Type.IsNullable() && !ce.Type.IsNullable())
						{
							return Expression.Condition(
								Expression.Equal(ce.Operand, Expression.Constant(null, ce.Operand.Type)),
								Expression.Default(e.Type),
								e);
						}

						return e;
					}
					default:
						return e;
				}
			})!;

			return accessorExpression;
		}

		internal static ParameterAccessor CreateParameterAccessor(
			IDataContext        dataContext,
			Expression          accessorExpression,
			Expression          originalAccessorExpression,
			Expression          dbDataTypeAccessorExpression,
			Expression          expression,
			ParameterExpression expressionParam,
			ParameterExpression parametersParam,
			ParameterExpression dataContextParam,
			string?             name)
		{
			// Extracting name for parameter
			//
			if (name == null && expression.Type == typeof(DataParameter))
			{
				var dp = expression.EvaluateExpression<DataParameter>();
				if (dp?.Name?.IsNullOrEmpty() == false)
					name = dp.Name;
			}

			// see #820
			accessorExpression         = CorrectAccessorExpression(accessorExpression, dataContext, dataContextParam);
			originalAccessorExpression = CorrectAccessorExpression(originalAccessorExpression, dataContext, dataContextParam);

			var mapper = Expression.Lambda<Func<Expression,IDataContext?,object?[]?,object?>>(
				Expression.Convert(accessorExpression, typeof(object)),
				expressionParam, dataContextParam, parametersParam);

			var original = Expression.Lambda<Func<Expression,IDataContext?,object?[]?,object?>>(
				Expression.Convert(originalAccessorExpression, typeof(object)),
				expressionParam, dataContextParam, parametersParam);

			var dbDataTypeAccessor = Expression.Lambda<Func<Expression,IDataContext?,object?[]?,DbDataType>>(
				Expression.Convert(dbDataTypeAccessorExpression, typeof(DbDataType)),
				expressionParam, dataContextParam, parametersParam);

			return new ParameterAccessor
			(
				expression,
				mapper.CompileExpression(),
				original.CompileExpression(),
				dbDataTypeAccessor.CompileExpression(),
				new SqlParameter(new DbDataType(accessorExpression.Type), name, null)
				{
					IsQueryParameter = !dataContext.InlineParameters
				}
			)
#if DEBUG
				{
					AccessorExpr = mapper
				}
#endif
				;
		}

		#endregion

		#region ConvertInPredicate

		private ISqlPredicate ConvertInPredicate(IBuildContext context, MethodCallExpression expression)
		{
			var e        = expression;
			var argIndex = e.Object != null ? 0 : 1;
			var arr      = e.Object ?? e.Arguments[0];
			var arg      = e.Arguments[argIndex];

			ISqlExpression? expr = null;

			var ctx = GetContext(context, arg);

			if (ctx is TableBuilder.TableContext &&
				ctx.SelectQuery != context.SelectQuery &&
				ctx.IsExpression(arg, 0, RequestFor.Object).Result)
			{
				expr = ctx.SelectQuery;
			}

			if (expr == null)
			{
				var sql = ConvertExpressions(context, arg, ConvertFlags.Key, null);

				if (sql.Length == 1 && sql[0].MemberChain.Length == 0)
					expr = sql[0].Sql;
				else
					expr = new SqlObjectExpression(MappingSchema, sql);
			}

			var columnDescriptor = QueryHelper.GetColumnDescriptor(expr);

			switch (arr.NodeType)
			{
				case ExpressionType.NewArrayInit :
					{
						var newArr = (NewArrayExpression)arr;

						if (newArr.Expressions.Count == 0)
							return new SqlPredicate.Expr(new SqlValue(false));

						var exprs  = new ISqlExpression[newArr.Expressions.Count];

						for (var i = 0; i < newArr.Expressions.Count; i++)
							exprs[i] = ConvertToSql(context, newArr.Expressions[i], columnDescriptor: columnDescriptor);

						return new SqlPredicate.InList(expr, Configuration.Linq.CompareNullsAsValues ? false : (bool?)null, false, exprs);
					}

				default :

					if (CanBeCompiled(arr))
					{
						var p = BuildParameter(arr, columnDescriptor, false, BuildParameterType.InPredicate).SqlParameter;
						p.IsQueryParameter = false;
						return new SqlPredicate.InList(expr, Configuration.Linq.CompareNullsAsValues ? false : (bool?)null, false, p);
					}

					break;
			}

			throw new LinqException("'{0}' cannot be converted to SQL.", expression);
		}

		#endregion

		#region LIKE predicate

		ISqlPredicate CreateStringPredicate(IBuildContext? context, MethodCallExpression expression, SqlPredicate.SearchString.SearchKind kind)
		{
			var e = expression;
			var o = ConvertToSql(context, e.Object);
			var a = ConvertToSql(context, e.Arguments[0]);

			return new SqlPredicate.SearchString(o, false, a, kind, true);
		}

		ISqlPredicate ConvertLikePredicate(IBuildContext context, MethodCallExpression expression)
		{
			var e  = expression;
			var a1 = ConvertToSql(context, e.Arguments[0]);
			var a2 = ConvertToSql(context, e.Arguments[1]);

			ISqlExpression? a3 = null;

			if (e.Arguments.Count == 3)
				a3 = ConvertToSql(context, e.Arguments[2]);

			return new SqlPredicate.Like(a1, false, a2, a3);
		}

		#endregion

		#region MakeIsPredicate

		internal ISqlPredicate MakeIsPredicate(TableBuilder.TableContext table, Type typeOperand)
		{
			if (typeOperand == table.ObjectType && table.InheritanceMapping.All(m => m.Type != typeOperand))
				return new SqlPredicate.Expr(new SqlValue(true));

			return MakeIsPredicate(table, table.InheritanceMapping, typeOperand, name => table.SqlTable[name] ?? throw new LinqException($"Field {name} not found in table {table.SqlTable}"));
		}

		internal ISqlPredicate MakeIsPredicate(
			IBuildContext               context,
			List<InheritanceMapping>    inheritanceMapping,
			Type                        toType,
			Func<string,ISqlExpression> getSql)
		{
			var mapping = inheritanceMapping
				.Where (m => m.Type == toType && !m.IsDefault)
				.ToList();

			switch (mapping.Count)
			{
				case 0 :
					{
						var cond = new SqlSearchCondition();

						if (inheritanceMapping.Any(m => m.Type == toType))
						{
							foreach (var m in inheritanceMapping.Where(m => !m.IsDefault))
							{
								cond.Conditions.Add(
									new SqlCondition(
										false,
											new SqlPredicate.ExprExpr(
												getSql(m.DiscriminatorName),
												SqlPredicate.Operator.NotEqual,
												MappingSchema.GetSqlValue(m.Discriminator.MemberType, m.Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null)));
							}
						}
						else
						{
							foreach (var m in inheritanceMapping.Where(m => toType.IsSameOrParentOf(m.Type)))
							{
								cond.Conditions.Add(
									new SqlCondition(
										false,
											new SqlPredicate.ExprExpr(
												getSql(m.DiscriminatorName),
												SqlPredicate.Operator.Equal,
												MappingSchema.GetSqlValue(m.Discriminator.MemberType, m.Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null),
										true));
							}
						}

						return cond;
					}

				case 1 :
					return new SqlPredicate.ExprExpr(
							getSql(mapping[0].DiscriminatorName),
							SqlPredicate.Operator.Equal,
							MappingSchema.GetSqlValue(mapping[0].Discriminator.MemberType, mapping[0].Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null);

				default:
					{
						var cond = new SqlSearchCondition();

						foreach (var m in mapping)
						{
							cond.Conditions.Add(
								new SqlCondition(
									false,
										new SqlPredicate.ExprExpr(
											getSql(m.DiscriminatorName),
											SqlPredicate.Operator.Equal,
											MappingSchema.GetSqlValue(m.Discriminator.MemberType, m.Code), Configuration.Linq.CompareNullsAsValues ? true : (bool?)null),
									true));
						}

						return cond;
					}
			}
		}

		ISqlPredicate MakeIsPredicate(IBuildContext context, TypeBinaryExpression expression)
		{
			var typeOperand = expression.TypeOperand;
			var table       = new TableBuilder.TableContext(this, new BuildInfo((IBuildContext?)null, Expression.Constant(null), new SelectQuery()), typeOperand);

			if (typeOperand == table.ObjectType && table.InheritanceMapping.All(m => m.Type != typeOperand))
				return new SqlPredicate.Expr(new SqlValue(true));

			var mapping = table.InheritanceMapping.Select((m, i) => new { m, i }).Where(m => typeOperand.IsAssignableFrom(m.m.Type) && !m.m.IsDefault).ToList();
			var isEqual = true;

			if (mapping.Count == 0)
			{
				mapping = table.InheritanceMapping.Select((m,i) => new { m, i }).Where(m => !m.m.IsDefault).ToList();
				isEqual = false;
			}

			Expression? expr = null;

			foreach (var m in mapping)
			{
				var field = table.SqlTable[table.InheritanceMapping[m.i].DiscriminatorName] ?? throw new LinqException($"Field {table.InheritanceMapping[m.i].DiscriminatorName} not found in table {table.SqlTable}");
				var ttype = field.ColumnDescriptor.MemberAccessor.TypeAccessor.Type;
				var obj   = expression.Expression;

				if (obj.Type != ttype)
					obj = Expression.Convert(expression.Expression, ttype);

				var left = ExpressionHelper.PropertyOrField(obj, field.Name);
				var code = m.m.Code;

				if (code == null)
					code = left.Type.GetDefaultValue();
				else if (left.Type != code.GetType())
					code = Converter.ChangeType(code, left.Type, MappingSchema);

				Expression right = Expression.Constant(code, left.Type);

				var e = isEqual ? Expression.Equal(left, right) : Expression.NotEqual(left, right);

				if (!isEqual)
					expr = expr != null ? Expression.AndAlso(expr, e) : e;
				else
					expr = expr != null ? Expression.OrElse(expr, e) : e;
			}

			return ConvertPredicate(context, expr!);
		}

		#endregion

		#endregion

		#region Search Condition Builder

		internal void BuildSearchCondition(IBuildContext? context, Expression expression, List<SqlCondition> conditions)
		{
			expression = expression.Transform(RemoveNullPropagation);

			switch (expression.NodeType)
			{
				case ExpressionType.And     :
				case ExpressionType.AndAlso :
					{
						var e = (BinaryExpression)expression;

						BuildSearchCondition(context, e.Left,  conditions);
						BuildSearchCondition(context, e.Right, conditions);

						break;
					}

				case ExpressionType.Extension :
					{
						break;
					}

				case ExpressionType.Or     :
				case ExpressionType.OrElse :
					{
						var e           = (BinaryExpression)expression;
						var orCondition = new SqlSearchCondition();

						BuildSearchCondition(context, e.Left,  orCondition.Conditions);
						orCondition.Conditions[orCondition.Conditions.Count - 1].IsOr = true;
						BuildSearchCondition(context, e.Right, orCondition.Conditions);

						conditions.Add(new SqlCondition(false, orCondition));

						break;
					}

				case ExpressionType.Not    :
					{
						var e            = (UnaryExpression)expression;
						var notCondition = new SqlSearchCondition();

						BuildSearchCondition(context, e.Operand, notCondition.Conditions);

						conditions.Add(new SqlCondition(true, notCondition));

						break;
					}

				default                    :
					var predicate = ConvertPredicate(context, expression);

					conditions.Add(new SqlCondition(false, predicate));

					break;
			}
		}


		static bool NeedNullCheck(ISqlExpression expr)
		{
			if (!expr.CanBeNull)
				return false;

			if (null != new QueryVisitor().Find(expr, e => e.ElementType == QueryElementType.SelectClause))
				return false;
			return true;
		}

		#endregion

		#region CanBeTranslatedToSql

		bool CanBeTranslatedToSql(IBuildContext context, Expression expr, bool canBeCompiled)
		{
			List<Expression>? ignoredMembers = null;

			return null == expr.Find(pi =>
			{
				if (ignoredMembers != null)
				{
					if (pi != ignoredMembers[ignoredMembers.Count - 1])
						throw new InvalidOperationException();

					if (ignoredMembers.Count == 1)
						ignoredMembers = null;
					else
						ignoredMembers.RemoveAt(ignoredMembers.Count - 1);

					return false;
				}

				switch (pi.NodeType)
				{
					case ExpressionType.MemberAccess :
						{
							var ma   = (MemberExpression)pi;
							var attr = GetExpressionAttribute(ma.Member);

							if (attr == null && !ma.Member.IsNullableValueMember())
							{
								if (canBeCompiled)
								{
									var ctx = GetContext(context, pi);

									if (ctx == null)
										return !CanBeCompiled(pi);

									if (ctx.IsExpression(pi, 0, RequestFor.Object).Result)
										return !CanBeCompiled(pi);

									ignoredMembers = ma.Expression.GetMembers();
								}
							}

							break;
						}

					case ExpressionType.Parameter    :
						{
							var ctx = GetContext(context, pi);

							if (ctx == null)
								if (canBeCompiled)
									return !CanBeCompiled(pi);

							break;
						}

					case ExpressionType.Call         :
						{
							var e = (MethodCallExpression)pi;

							if (e.Method.DeclaringType != typeof(Enumerable))
							{
								var attr = GetExpressionAttribute(e.Method);

								if (attr == null && canBeCompiled)
									return !CanBeCompiled(pi);
							}

							break;
						}

					case ExpressionType.TypeIs       : return canBeCompiled;
					case ExpressionType.TypeAs       :
					case ExpressionType.New          : return true;

					case ExpressionType.NotEqual     :
					case ExpressionType.Equal        :
						{
							var e = (BinaryExpression)pi;

							Expression? obj = null;

							if (e.Left.NodeType == ExpressionType.Constant && ((ConstantExpression)e.Left).Value == null)
								obj = e.Right;
							else if (e.Right.NodeType == ExpressionType.Constant && ((ConstantExpression)e.Right).Value == null)
								obj = e.Left;

							if (obj != null)
							{
								var ctx = GetContext(context, obj);

								if (ctx != null)
								{
									if (ctx.IsExpression(obj, 0, RequestFor.Table).      Result ||
										ctx.IsExpression(obj, 0, RequestFor.Association).Result)
									{
										ignoredMembers = obj.GetMembers();
									}
								}
							}

							break;
						}

					case ExpressionType.Conditional:
						{
							var cond = (ConditionalExpression)pi;
							if (!cond.Type.IsScalar())
								return true;
							break;
						}
				}

				return false;
			});
		}

		#endregion

		#region Helpers

		public IBuildContext? GetContext(IBuildContext? current, Expression? expression)
		{
			var root = GetRootObject(expression);
			root = root.Unwrap();

			if (root is ContextRefExpression refExpression)
				return refExpression.BuildContext;

			for (; current != null; current = current.Parent)
				if (current.IsExpression(root, 0, RequestFor.Root).Result)
					return current;

			return null;
		}

		Sql.ExpressionAttribute? GetExpressionAttribute(MemberInfo member)
		{
			return MappingSchema.GetAttribute<Sql.ExpressionAttribute>(member.ReflectedType!, member, a => a.Configuration);
		}

		internal Sql.TableFunctionAttribute? GetTableFunctionAttribute(MemberInfo member)
		{
			return MappingSchema.GetAttribute<Sql.TableFunctionAttribute>(member.ReflectedType!, member, a => a.Configuration);
		}

		bool IsNullConstant(Expression expr)
		{
			return expr.NodeType == ExpressionType.Constant  && ((ConstantExpression)expr).Value == null 
				|| expr.NodeType == ExpressionType.Extension && expr is DefaultValueExpression;
		}

		Expression RemoveNullPropagation(Expression expr)
		{
			// Do not modify parameters
			//
			if (CanBeCompiled(expr))
				return expr;

			switch (expr.NodeType)
			{
				case ExpressionType.Conditional:
					var conditional = (ConditionalExpression)expr;
					if (conditional.Test.NodeType == ExpressionType.NotEqual)
					{
						var binary    = (BinaryExpression)conditional.Test;
						var nullRight = IsNullConstant(binary.Right);
						var nullLeft  = IsNullConstant(binary.Left);
						if (nullRight || nullLeft)
						{
							if (nullRight && nullLeft)
							{
								return conditional.IfFalse.Transform(RemoveNullPropagation);
							}
							else if (IsNullConstant(conditional.IfFalse)
								&& ((nullRight && !MappingSchema.IsScalarType(binary.Left.Type)) ||
									(nullLeft  && !MappingSchema.IsScalarType(binary.Right.Type))))
							{
								return conditional.IfTrue.Transform(RemoveNullPropagation);
							}
						}
					}
					else if (conditional.Test.NodeType == ExpressionType.Equal)
					{
						var binary    = (BinaryExpression)conditional.Test;
						var nullRight = IsNullConstant(binary.Right);
						var nullLeft  = IsNullConstant(binary.Left);
						if (nullRight || nullLeft)
						{
							if (nullRight && nullLeft)
							{
								return conditional.IfTrue.Transform(RemoveNullPropagation);
							}
							else if (IsNullConstant(conditional.IfTrue)
								&& ((nullRight && !MappingSchema.IsScalarType(binary.Left.Type)) ||
									(nullLeft  && !MappingSchema.IsScalarType(binary.Right.Type))))
							{
								return conditional.IfFalse.Transform(RemoveNullPropagation);
							}
						}
					}
					break;
			}

			return expr;
		}

		public bool ProcessProjection(Dictionary<MemberInfo,Expression> members, Expression expression)
		{
			void CollectParameters(Type forType, MethodBase method, ReadOnlyCollection<Expression> arguments)
			{
				var pms = method.GetParameters();

				var typeMembers = TypeAccessor.GetAccessor(forType).Members;

				for (var i = 0; i < pms.Length; i++)
				{
					var param = pms[i];
					var foundMember = typeMembers.Find(tm => tm.Name == param.Name);
					if (foundMember == null)
						foundMember = typeMembers.Find(tm =>
							tm.Name.Equals(param.Name, StringComparison.OrdinalIgnoreCase));
					if (foundMember == null)
						continue;

					if (members.ContainsKey(foundMember.MemberInfo))
						continue;

					var converted = arguments[i].Transform(e => RemoveNullPropagation(e));

					if (!foundMember.MemberInfo.GetMemberType().IsAssignableFrom(converted.Type))
						continue;

					members.Add(foundMember.MemberInfo, converted);
				}
			}

			switch (expression.NodeType)
			{
				// new { ... }
				//
				case ExpressionType.New        :
					{
						var expr = (NewExpression)expression;

						if (expr.Members != null)
						{
							for (var i = 0; i < expr.Members.Count; i++)
							{
								var member = expr.Members[i];

								var converted = expr.Arguments[i].Transform(e => RemoveNullPropagation(e));
								members.Add(member, converted);

								if (member is MethodInfo info)
									members.Add(info.GetPropertyInfo(), converted);
							}
						}

						var isScalar = MappingSchema.IsScalarType(expr.Type);
						if (!isScalar)
							CollectParameters(expr.Type, expr.Constructor, expr.Arguments);

						return members.Count > 0 || !isScalar;
					}

				// new MyObject { ... }
				//
				case ExpressionType.MemberInit :
					{
						var expr = (MemberInitExpression)expression;
						var typeMembers = TypeAccessor.GetAccessor(expr.Type).Members;

						var dic  = typeMembers
							.Select((m,i) => new { m, i })
							.ToDictionary(_ => _.m.MemberInfo.Name, _ => _.i);

						foreach (var binding in expr.Bindings.Cast<MemberAssignment>().OrderBy(b => dic.ContainsKey(b.Member.Name) ? dic[b.Member.Name] : 1000000))
						{
							var converted = binding.Expression.Transform(e => RemoveNullPropagation(e));
							members.Add(binding.Member, converted);

							if (binding.Member is MethodInfo info)
								members.Add(info.GetPropertyInfo(), converted);
						}

						return true;
					}

				case ExpressionType.Call:
					{
						var mc = (MethodCallExpression)expression;

						// process fabric methods

						if (!MappingSchema.IsScalarType(mc.Type))
							CollectParameters(mc.Type, mc.Method, mc.Arguments);

						return members.Count > 0;
					}

				case ExpressionType.NewArrayInit:
				case ExpressionType.ListInit:
					{
						return true;
					}
				// .Select(p => everything else)
				//
				default                        :
					return false;
			}
		}

		public void ReplaceParent(IBuildContext oldParent, IBuildContext? newParent)
		{
			foreach (var context in Contexts)
				if (context != newParent)
					if (context.Parent == oldParent)
						if (newParent != null && newParent.Parent != context)
							context.Parent = newParent;
		}

		public static void EnsureAggregateColumns(IBuildContext context, SelectQuery query)
		{
			if (query.Select.Columns.Count == 0)
			{
				var sql = context.ConvertToSql(null, 0, ConvertFlags.All);
				if (sql.Length > 0)
				{
					// Handling case when all columns are aggregates, it cause query to produce only single record and we have to include at least one aggregation in Select statement.
					// 
					var allAggregate = sql.All(s => QueryHelper.IsAggregationOrWindowFunction(s.Sql));
					if (allAggregate)
					{
						query.Select.Add(sql[0].Sql);
					}
				}
			}
		}


		#endregion

		#region CTE

		List<Tuple<Expression, Tuple<CteClause, IBuildContext?>>>? _ctes;
		Dictionary<IQueryable, Expression>?                        _ctesObjectMapping;

		public Tuple<CteClause, IBuildContext?, Expression> RegisterCte(IQueryable? queryable, Expression? cteExpression, Func<CteClause> buildFunc)
		{
			if (cteExpression != null && queryable != null && (_ctesObjectMapping == null || !_ctesObjectMapping.ContainsKey(queryable)))
			{
				_ctesObjectMapping ??= new Dictionary<IQueryable, Expression>();

				_ctesObjectMapping.Add(queryable, cteExpression);
			}

			if (cteExpression == null)
			{
				if (_ctesObjectMapping == null)
					throw new InvalidOperationException();
				cteExpression = _ctesObjectMapping[queryable!];
			}

			var value = FindRegisteredCteByExpression(cteExpression, out _);

			if (value == null)
			{
				var cte = buildFunc();
				value = Tuple.Create<CteClause, IBuildContext?>(cte, null);

				_ctes ??= new List<Tuple<Expression, Tuple<CteClause, IBuildContext?>>>();
				_ctes.Add(Tuple.Create(cteExpression, value));
			}

			return Tuple.Create(value.Item1, value.Item2, cteExpression);
		}

		Tuple<CteClause, IBuildContext?>? FindRegisteredCteByExpression(Expression cteExpression, out int? idx)
		{
			if (_ctes != null)
			{
				var queryableAccessorDic = new Dictionary<Expression, QueryableAccessor>();
				for (var index = 0; index < _ctes.Count; index++)
				{
					var tuple = _ctes[index];
					if (tuple.Item1.EqualsTo(cteExpression, DataContext, queryableAccessorDic, null, null,
						compareConstantValues: false))
					{
						idx = index;
						return tuple.Item2;
					}
				}
			}

			idx = null;
			return null;
		}
		

		public Tuple<CteClause, IBuildContext?> BuildCte(Expression cteExpression, Func<CteClause?, Tuple<CteClause, IBuildContext?>> buildFunc)
		{
			var value = FindRegisteredCteByExpression(cteExpression, out var idx);
			if (value?.Item2 != null)
				return value;

			value = buildFunc(value?.Item1);

			if (idx != null)
			{
				_ctes!.RemoveAt(idx.Value);
			}
			else
			{
				_ctes ??= new List<Tuple<Expression, Tuple<CteClause, IBuildContext?>>>();
			}

			_ctes.Add(Tuple.Create(cteExpression, value));

			return value;
		}

		public IBuildContext? GetCteContext(Expression cteExpression)
		{
			return FindRegisteredCteByExpression(cteExpression, out _)?.Item2;
		}

		#endregion

		#region Eager Loading

		private List<Tuple<Func<IDataContext, Expression, object?[]?, object?>, Func<IDataContext, Expression, object?[]?, CancellationToken, Task<object?>>>>? _preambles;

		public static readonly ParameterExpression PreambleParam =
			Expression.Parameter(typeof(object[]), "preamble");

		public int RegisterPreamble<T>(Func<IDataContext, Expression, object?[]?, T> func, Func<IDataContext, Expression, object?[]?, CancellationToken, Task<T>> funcAsync)
		{
			if (_preambles == null)
				_preambles = new List<Tuple<Func<IDataContext, Expression, object?[]?, object?>,Func<IDataContext, Expression, object?[]?, CancellationToken, Task<object?>>>>();
			_preambles.Add(
				Tuple.Create< Func<IDataContext, Expression, object?[]?, object?>, Func<IDataContext, Expression, object?[]?, CancellationToken, Task<object?>>>(
					(dc, e, ps) => func(dc, e, ps),
					async (dc, e, ps, ct) => await funcAsync(dc, e, ps, ct).ConfigureAwait(Configuration.ContinueOnCapturedContext)));
			return _preambles.Count - 1;
		}

		#endregion

		#region Query Filter

		private Stack<Type[]>? _disabledFilters;

		public void AddDisabledQueryFilters(Type[] disabledFilters)
		{
			if (_disabledFilters == null)
				_disabledFilters = new Stack<Type[]>();
			_disabledFilters.Push(disabledFilters);
		}

		public bool IsFilterDisabled(Type entityType)
		{
			if (_disabledFilters == null || _disabledFilters.Count == 0)
				return false;
			var filter = _disabledFilters.Peek();
			if (filter.Length == 0)
				return true;
			return Array.IndexOf(filter, entityType) >= 0;
		}

		public void RemoveDisabledFilter()
		{
			if (_disabledFilters == null)
				throw new InvalidOperationException();

			_ = _disabledFilters.Pop();
		}

		#endregion

		#region Grouping Guard

		public bool IsGroupingGuardDisabled { get; set; }

		#endregion
	}
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionBuilder.SqlBuilder.cs(9,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionBuilder.SqlBuilder.cs(21,2): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionBuilder.SqlBuilder.cs(301,11): warning CS8600: Converting null literal or possible null value to non-nullable type.,D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionBuilder.SqlBuilder.cs(9,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Source\LinqToDB\Linq\Builder\ExpressionBuilder.SqlBuilder.cs(21,2): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace LinqToDB.Linq.Builder
{
	using System;
	using Extensions;
	using LinqToDB.Expressions;
	using Mapping;
	using Common;
	using SqlQuery;

	class LoadWithBuilder : MethodCallBuilder
	{
		protected override bool CanBuildMethodCall(ExpressionBuilder builder, MethodCallExpression methodCall, BuildInfo buildInfo)
		{
			return methodCall.IsQueryable("LoadWith", "ThenLoad", "LoadWithAsTable");
		}

		static void CheckFilterFunc(Type expectedType, Type filterType, MappingSchema mappingSchema)
		{
			var propType = expectedType;
			if (EagerLoading.IsEnumerableType(expectedType, mappingSchema))
				propType = EagerLoading.GetEnumerableElementType(expectedType, mappingSchema);
			var itemType = typeof(Expression<>).IsSameOrParentOf(filterType) ? 
				filterType.GetGenericArguments()[0].GetGenericArguments()[0].GetGenericArguments()[0] :
				filterType.GetGenericArguments()[0].GetGenericArguments()[0];
			if (propType != itemType)
				throw new LinqException("Invalid filter function usage.");
		}

		protected override IBuildContext BuildMethodCall(ExpressionBuilder builder, MethodCallExpression methodCall, BuildInfo buildInfo)
		{
			var sequence = builder.BuildSequence(new BuildInfo(buildInfo, methodCall.Arguments[0]));

			var selector = (LambdaExpression)methodCall.Arguments[1].Unwrap();

			// reset LoadWith sequence
			if (methodCall.IsQueryable("LoadWith"))
			{
				for(;;)
				{
					if (sequence is LoadWithContext lw)
						sequence = lw.Context;
					else
						break;
				}
			}

			var path  = selector.Body.Unwrap();
			var table = GetTableContext(sequence, path, out var level);

			var associations = ExtractAssociations(builder, path, level)
				.Reverse()
				.ToArray();

			if (associations.Length == 0)
				throw new LinqToDBException($"Unable to retrieve properties path for LoadWith/ThenLoad. Path: '{path}'");

			if (methodCall.Method.Name == "ThenLoad")
			{
				if (!(table.LoadWith?.Count > 0))
					throw new LinqToDBException($"ThenLoad function should be followed after LoadWith. Can not find previous property for '{path}'.");

				var lastPath = table.LoadWith[table.LoadWith.Count - 1];
				associations = Array<LoadWithInfo>.Append(lastPath, associations);

				if (methodCall.Arguments.Count == 3)
				{
					var lastElement = associations[associations.Length - 1];
					lastElement.FilterFunc = (Expression?)methodCall.Arguments[2];
					CheckFilterFunc(lastElement.MemberInfo.GetMemberType(), lastElement.FilterFunc!.Type, builder.MappingSchema);
				}

				// append to the last member chain
				table.LoadWith[table.LoadWith.Count - 1] = associations;
			}
			else
			{
				if (table.LoadWith == null)
					table.LoadWith = new List<LoadWithInfo[]>();

				if (methodCall.Arguments.Count == 3)
				{
					var lastElement = associations[associations.Length - 1];
					lastElement.FilterFunc = (Expression?)methodCall.Arguments[2];
					CheckFilterFunc(lastElement.MemberInfo.GetMemberType(), lastElement.FilterFunc!.Type, builder.MappingSchema);
				}

				table.LoadWith.Add(associations);
			}

			var loadWithSequence = sequence as LoadWithContext ?? new LoadWithContext(sequence, table);

			return loadWithSequence;
		}

		TableBuilder.TableContext GetTableContext(IBuildContext ctx, Expression path, out Expression? stopExpression)
		{
			stopExpression = null;

			var table = ctx as TableBuilder.TableContext;

			if (table != null)
				return table;

			if (ctx is LoadWithContext lwCtx)
				return lwCtx.TableContext;

			if (table == null)
			{
				var isTableResult = ctx.IsExpression(null, 0, RequestFor.Table);
				if (isTableResult.Result)
				{
					table = isTableResult.Context as TableBuilder.TableContext;
					if (table != null)
						return table;
				}

			}

			var maxLevel = path.GetLevel(ctx.Builder.MappingSchema);
			var level    = 1;
			while (level <= maxLevel)
			{
				var levelExpression = path.GetLevelExpression(ctx.Builder.MappingSchema, level);
				var isTableResult = ctx.IsExpression(levelExpression, 1, RequestFor.Table);
				if (isTableResult.Result)
				{
					table = isTableResult.Context switch
					{
						TableBuilder.TableContext t => t,
						AssociationContext a => a.TableContext as TableBuilder.TableContext,
						_ => null
					};

					if (table != null)
					{
						stopExpression = levelExpression;
						return table;
					}
				}

				++level;
			}

			var expr = path.GetLevelExpression(ctx.Builder.MappingSchema, 0);

			throw new LinqToDBException(
				$"Unable to find table information for LoadWith. Consider moving LoadWith closer to GetTable<{expr.Type.Name}>() method.");
	
		}

		static IEnumerable<LoadWithInfo> ExtractAssociations(ExpressionBuilder builder, Expression expression, Expression? stopExpression)
		{
			var currentExpression = expression;

			while (currentExpression.NodeType == ExpressionType.Call)
			{
				var mc = (MethodCallExpression)currentExpression;
				if (mc.IsQueryable())
					currentExpression = mc.Arguments[0];
				else
					break;
			}

			LambdaExpression? filterExpression = null;
			if (currentExpression != expression)
			{
				var parameter  = Expression.Parameter(currentExpression.Type, "e");

				var body   = expression.Replace(currentExpression, parameter);
				var lambda = Expression.Lambda(body, parameter);

				filterExpression = lambda;
			}

			foreach (var member in GetAssociations(builder, currentExpression, stopExpression))
			{
				yield return new LoadWithInfo(member) { MemberFilter = filterExpression };
				filterExpression = null;
			}
		}

		static IEnumerable<MemberInfo> GetAssociations(ExpressionBuilder builder, Expression expression, Expression? stopExpression)
		{
			MemberInfo? lastMember = null;

			for (;;)
			{
				if (stopExpression == expression)
				{
					yield break;
				}

				switch (expression.NodeType)
				{
					case ExpressionType.Parameter :
						if (lastMember == null)
							goto default;
						yield break;

					case ExpressionType.Call      :
						{
							var cexpr = (MethodCallExpression)expression;

							if (cexpr.Method.IsSqlPropertyMethodEx())
							{
								foreach (var assoc in GetAssociations(builder, builder.ConvertExpression(expression), stopExpression))
									yield return assoc;

								yield break;
							}

							if (lastMember == null)
								goto default;
							
							var expr  = cexpr.Object;

							if (expr == null)
							{
								if (cexpr.Arguments.Count == 0)
									goto default;

								expr = cexpr.Arguments[0];
							}

							if (expr.NodeType != ExpressionType.MemberAccess)
								goto default;

							var member = ((MemberExpression)expr).Member;
							var mtype  = member.GetMemberType();

							if (lastMember.ReflectedType != mtype.GetItemType())
								goto default;

							expression = expr;

							break;
						}

					case ExpressionType.MemberAccess :
						{
							var mexpr  = (MemberExpression)expression;
							var member = lastMember = mexpr.Member;
							var attr   = builder.MappingSchema.GetAttribute<AssociationAttribute>(member.ReflectedType!, member);
							if (attr == null)
							{
								member = mexpr.Expression.Type.GetMemberEx(member)!;
								attr = builder.MappingSchema.GetAttribute<AssociationAttribute>(mexpr.Expression.Type, member);
							}	
							if (attr == null)
								throw new LinqToDBException($"Member '{expression}' is not an association.");

							yield return member;

							expression = mexpr.Expression;

							break;
						}

					case ExpressionType.ArrayIndex   :
						{
							expression = ((BinaryExpression)expression).Left;
							break;
						}

					case ExpressionType.Extension    :
						{
							if (expression is GetItemExpression getItemExpression)
							{
								expression = getItemExpression.Expression;
								break;
							}

							goto default;
						}

					case ExpressionType.Convert      :
						{
							expression = ((UnaryExpression)expression).Operand;
							break;
						}

					default :
						{
							throw new LinqToDBException($"Expression '{expression}' is not an association.");
						}
				}
			}
		}

		protected override SequenceConvertInfo? Convert(
			ExpressionBuilder builder, MethodCallExpression methodCall, BuildInfo buildInfo, ParameterExpression? param)
		{
			return null;
		}

		class LoadWithContext : PassThroughContext
		{
			private readonly TableBuilder.TableContext _tableContext;

			public TableBuilder.TableContext TableContext => _tableContext;

			public LoadWithContext(IBuildContext context, TableBuilder.TableContext tableContext) : base(context)
			{
				_tableContext = tableContext;
			}
		}
	}
}

---- Transformed Tree ----
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace LinqToDB.Linq.Builder
{
	using System;
	using Extensions;
	using LinqToDB.Expressions;
	using Mapping;
	using Common;
	using SqlQuery;

	class LoadWithBuilder : MethodCallBuilder
	{
		protected override bool CanBuildMethodCall(ExpressionBuilder builder, MethodCallExpression methodCall, BuildInfo buildInfo)
		{
			return methodCall.IsQueryable("LoadWith", "ThenLoad", "LoadWithAsTable");
		}

		static void CheckFilterFunc(Type expectedType, Type filterType, MappingSchema mappingSchema)
		{
			var propType = expectedType;
			if (EagerLoading.IsEnumerableType(expectedType, mappingSchema))
				propType = EagerLoading.GetEnumerableElementType(expectedType, mappingSchema);
			var itemType = typeof(Expression<>).IsSameOrParentOf(filterType) ? 
				filterType.GetGenericArguments()[0].GetGenericArguments()[0].GetGenericArguments()[0] :
				filterType.GetGenericArguments()[0].GetGenericArguments()[0];
			if (propType != itemType)
				throw new LinqException("Invalid filter function usage.");
		}

		protected override IBuildContext BuildMethodCall(ExpressionBuilder builder, MethodCallExpression methodCall, BuildInfo buildInfo)
		{
			var sequence = builder.BuildSequence(new BuildInfo(buildInfo, methodCall.Arguments[0]));

			var selector = (LambdaExpression)methodCall.Arguments[1].Unwrap();

			// reset LoadWith sequence
			if (methodCall.IsQueryable("LoadWith"))
			{
				for(;;)
				{
					if (sequence is LoadWithContext lw)
						sequence = lw.Context;
					else
						break;
				}
			}

			var path  = selector.Body.Unwrap();
			var table = GetTableContext(sequence, path, out var level);

			var associations = ExtractAssociations(builder, path, level)
				.Reverse()
				.ToArray();

			if (associations.Length == 0)
				throw new LinqToDBException($"Unable to retrieve properties path for LoadWith/ThenLoad. Path: '{path}'");

			if (methodCall.Method.Name == "ThenLoad")
			{
				if (!(table.LoadWith?.Count > 0))
					throw new LinqToDBException($"ThenLoad function should be followed after LoadWith. Can not find previous property for '{path}'.");

				var lastPath = table.LoadWith[table.LoadWith.Count - 1];
				associations = Array<LoadWithInfo>.Append(lastPath, associations);

				if (methodCall.Arguments.Count == 3)
				{
					var lastElement = associations[associations.Length - 1];
					lastElement.FilterFunc = (Expression?)methodCall.Arguments[2];
					CheckFilterFunc(lastElement.MemberInfo.GetMemberType(), lastElement.FilterFunc!.Type, builder.MappingSchema);
				}

				// append to the last member chain
				table.LoadWith[table.LoadWith.Count - 1] = associations;
			}
			else
			{
				if (table.LoadWith == null)
					table.LoadWith = new List<LoadWithInfo[]>();

				if (methodCall.Arguments.Count == 3)
				{
					var lastElement = associations[associations.Length - 1];
					lastElement.FilterFunc = (Expression?)methodCall.Arguments[2];
					CheckFilterFunc(lastElement.MemberInfo.GetMemberType(), lastElement.FilterFunc!.Type, builder.MappingSchema);
				}

				table.LoadWith.Add(associations);
			}

			var loadWithSequence = sequence as LoadWithContext ?? new LoadWithContext(sequence, table);

			return loadWithSequence;
		}

		TableBuilder.TableContext GetTableContext(IBuildContext ctx, Expression path, out Expression? stopExpression)
		{
			stopExpression = null;

			if (ctx is TableBuilder.TableContext table)
				return table;

			if (ctx is LoadWithContext lwCtx)
				return lwCtx.TableContext;

			if (table == null)
			{
				var isTableResult = ctx.IsExpression(null, 0, RequestFor.Table);
				if (isTableResult.Result)
				{
					table = isTableResult.Context as TableBuilder.TableContext;

					if (ctx is TableBuilder.TableContext table)
						return table;
				}

			}

			var maxLevel = path.GetLevel(ctx.Builder.MappingSchema);
			var level    = 1;
			while (level <= maxLevel)
			{
				var levelExpression = path.GetLevelExpression(ctx.Builder.MappingSchema, level);
				var isTableResult = ctx.IsExpression(levelExpression, 1, RequestFor.Table);
				if (isTableResult.Result)
				{
					table = isTableResult.Context switch
					{
						TableBuilder.TableContext t => t,
						AssociationContext a => a.TableContext as TableBuilder.TableContext,
						_ => null
					};

					if (ctx is TableBuilder.TableContext table)
					{
						stopExpression = levelExpression;
						return table;
					}
				}

				++level;
			}

			var expr = path.GetLevelExpression(ctx.Builder.MappingSchema, 0);

			throw new LinqToDBException(
				$"Unable to find table information for LoadWith. Consider moving LoadWith closer to GetTable<{expr.Type.Name}>() method.");
	
		}

		static IEnumerable<LoadWithInfo> ExtractAssociations(ExpressionBuilder builder, Expression expression, Expression? stopExpression)
		{
			var currentExpression = expression;

			while (currentExpression.NodeType == ExpressionType.Call)
			{
				var mc = (MethodCallExpression)currentExpression;
				if (mc.IsQueryable())
					currentExpression = mc.Arguments[0];
				else
					break;
			}

			LambdaExpression? filterExpression = null;
			if (currentExpression != expression)
			{
				var parameter  = Expression.Parameter(currentExpression.Type, "e");

				var body   = expression.Replace(currentExpression, parameter);
				var lambda = Expression.Lambda(body, parameter);

				filterExpression = lambda;
			}

			foreach (var member in GetAssociations(builder, currentExpression, stopExpression))
			{
				yield return new LoadWithInfo(member) { MemberFilter = filterExpression };
				filterExpression = null;
			}
		}

		static IEnumerable<MemberInfo> GetAssociations(ExpressionBuilder builder, Expression expression, Expression? stopExpression)
		{
			MemberInfo? lastMember = null;

			for (;;)
			{
				if (stopExpression == expression)
				{
					yield break;
				}

				switch (expression.NodeType)
				{
					case ExpressionType.Parameter :
						if (lastMember == null)
							goto default;
						yield break;

					case ExpressionType.Call      :
						{
							var cexpr = (MethodCallExpression)expression;

							if (cexpr.Method.IsSqlPropertyMethodEx())
							{
								foreach (var assoc in GetAssociations(builder, builder.ConvertExpression(expression), stopExpression))
									yield return assoc;

								yield break;
							}

							if (lastMember == null)
								goto default;
							
							var expr  = cexpr.Object;

							if (expr == null)
							{
								if (cexpr.Arguments.Count == 0)
									goto default;

								expr = cexpr.Arguments[0];
							}

							if (expr.NodeType != ExpressionType.MemberAccess)
								goto default;

							var member = ((MemberExpression)expr).Member;
							var mtype  = member.GetMemberType();

							if (lastMember.ReflectedType != mtype.GetItemType())
								goto default;

							expression = expr;

							break;
						}

					case ExpressionType.MemberAccess :
						{
							var mexpr  = (MemberExpression)expression;
							var member = lastMember = mexpr.Member;
							var attr   = builder.MappingSchema.GetAttribute<AssociationAttribute>(member.ReflectedType!, member);
							if (attr == null)
							{
								member = mexpr.Expression.Type.GetMemberEx(member)!;
								attr = builder.MappingSchema.GetAttribute<AssociationAttribute>(mexpr.Expression.Type, member);
							}	
							if (attr == null)
								throw new LinqToDBException($"Member '{expression}' is not an association.");

							yield return member;

							expression = mexpr.Expression;

							break;
						}

					case ExpressionType.ArrayIndex   :
						{
							expression = ((BinaryExpression)expression).Left;
							break;
						}

					case ExpressionType.Extension    :
						{
							if (expression is GetItemExpression getItemExpression)
							{
								expression = getItemExpression.Expression;
								break;
							}

							goto default;
						}

					case ExpressionType.Convert      :
						{
							expression = ((UnaryExpression)expression).Operand;
							break;
						}

					default :
						{
							throw new LinqToDBException($"Expression '{expression}' is not an association.");
						}
				}
			}
		}

		protected override SequenceConvertInfo? Convert(
			ExpressionBuilder builder, MethodCallExpression methodCall, BuildInfo buildInfo, ParameterExpression? param)
		{
			return null;
		}

		class LoadWithContext : PassThroughContext
		{
			private readonly TableBuilder.TableContext _tableContext;

			public TableBuilder.TableContext TableContext => _tableContext;

			public LoadWithContext(IBuildContext context, TableBuilder.TableContext tableContext) : base(context)
			{
				_tableContext = tableContext;
			}
		}
	}
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(13,2): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(115,6): error CS0841: Cannot use local variable 'table' before it is declared,D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(117,43): error CS0136: A local or parameter named 'table' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(131,6): error CS0841: Cannot use local variable 'table' before it is declared,D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(138,43): error CS0136: A local or parameter named 'table' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(118,14): warning CS8603: Possible null reference return.,D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(141,14): warning CS8603: Possible null reference return.,D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(110,8): error CS0165: Use of unassigned local variable 'table',D:\a\1\s\Source\LinqToDB\Linq\Builder\LoadWithBuilder.cs(13,2): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Collections.Generic;

namespace LinqToDB.Mapping
{
	using Expressions;
	using Extensions;
	using SqlQuery;
	using Common;

	/// <summary>
	/// Column or association fluent mapping builder.
	/// </summary>
	/// <typeparam name="TEntity">Entity type.</typeparam>
	/// <typeparam name="TProperty">Column or association member type.</typeparam>
	public class PropertyMappingBuilder<TEntity, TProperty>
	{
		#region Init

		/// <summary>
		/// Creates column or association fluent mapping builder.
		/// </summary>
		/// <param name="entity">Entity fluent mapping builder.</param>
		/// <param name="memberGetter">Column or association member getter expression.</param>
		public PropertyMappingBuilder(
			EntityMappingBuilder<TEntity>       entity,
			Expression<Func<TEntity,TProperty>> memberGetter)
		{
			_entity       = entity       ?? throw new ArgumentNullException(nameof(entity));
			_memberGetter = memberGetter ?? throw new ArgumentNullException(nameof(memberGetter));
			_memberInfo   = MemberHelper.MemberOf(memberGetter);

			if (_memberInfo.ReflectedType != typeof(TEntity))
				_memberInfo = typeof(TEntity).GetMemberEx(_memberInfo) ?? _memberInfo;
		}

		readonly Expression<Func<TEntity,TProperty>> _memberGetter;
		readonly MemberInfo                          _memberInfo;
		readonly EntityMappingBuilder<TEntity>       _entity;

		#endregion
		/// <summary>
		/// Adds attribute to current mapping member.
		/// </summary>
		/// <param name="attribute">Mapping attribute to add to specified member.</param>
		/// <returns>Returns current column or association mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasAttribute(Attribute attribute)
		{
			_entity.HasAttribute(_memberInfo, attribute);
			return this;
		}

		/// <summary>
		/// Creates entity builder for specified mapping type.
		/// </summary>
		/// <typeparam name="TE">Mapping type.</typeparam>
		/// <param name="configuration">Optional mapping schema configuration name, for which this entity builder should be taken into account.
		/// <see cref="ProviderName"/> for standard configuration names.</param>
		/// <returns>Returns entity mapping builder.</returns>
		public EntityMappingBuilder<TE> Entity<TE>(string? configuration = null)
		{
			return _entity.Entity<TE>(configuration);
		}

		/// <summary>
		/// Adds new column mapping to current column's entity.
		/// </summary>
		/// <param name="func">Column mapping property or field getter expression.</param>
		/// <returns>Returns property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TMember> Property<TMember>(Expression<Func<TEntity, TMember>> func)
		{
			return _entity.Property(func);
		}

		/// <summary>
		/// Adds member mapping to current entity.
		/// </summary>
		/// <param name="func">Column mapping property or field getter expression.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TMember> Member<TMember>(Expression<Func<TEntity,TMember>> func)
		{
			return _entity.Member(func);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Association member type.</typeparam>
		/// <typeparam name="TThisKey">This association side key type.</typeparam>
		/// <typeparam name="TOtherKey">Other association side key type.</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="thisKey">This association key getter expression.</param>
		/// <param name="otherKey">Other association key getter expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns association mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TOther> Association<TOther, TThisKey, TOtherKey>(
			Expression<Func<TEntity, TOther>>   prop,
			Expression<Func<TEntity, TThisKey>> thisKey,
			Expression<Func<TOther, TOtherKey>> otherKey,
			bool                                canBeNull = true)
		{
			return _entity.Association(prop, thisKey, otherKey, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TPropElement">Association member type.</typeparam>
		/// <typeparam name="TThisKey">This association side key type.</typeparam>
		/// <typeparam name="TOtherKey">Other association side key type.</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="thisKey">This association key getter expression.</param>
		/// <param name="otherKey">Other association key getter expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, IEnumerable<TPropElement>> Association<TPropElement, TThisKey, TOtherKey>(
			Expression<Func<TEntity, IEnumerable<TPropElement>>> prop,
			Expression<Func<TEntity, TThisKey>>                  thisKey,
			Expression<Func<TPropElement, TOtherKey>>            otherKey,
			bool                                                 canBeNull = true)
		{
			return _entity.Association(prop, thisKey, otherKey, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="predicate">Predicate expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, IEnumerable<TOther>> Association<TOther>(
			Expression<Func<TEntity, IEnumerable<TOther>>> prop,
			Expression<Func<TEntity, TOther, bool>>        predicate,
			bool                                           canBeNull = true)
		{
			return _entity.Association(prop, predicate, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="predicate">Predicate expression</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TOther> Association<TOther>(
			Expression<Func<TEntity, TOther>>       prop,
			Expression<Func<TEntity, TOther, bool>> predicate,
			bool                                    canBeNull = true)
		{
			return _entity.Association(prop, predicate, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="queryExpression">Query expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, IEnumerable<TOther>> Association<TOther>(
			Expression<Func<TEntity, IEnumerable<TOther>>>              prop,
			Expression<Func<TEntity, IDataContext, IQueryable<TOther>>> queryExpression,
			bool                                                        canBeNull = true)
		{
			return _entity.Association(prop, queryExpression, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="queryExpression">Query expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TOther> Association<TOther>(
			Expression<Func<TEntity, TOther>>                           prop,
			Expression<Func<TEntity, IDataContext, IQueryable<TOther>>> queryExpression,
			bool                                                        canBeNull = true)
		{
			return _entity.Association(prop, queryExpression, canBeNull);
		}

		/// <summary>
		/// Marks current column as primary key member.
		/// </summary>
		/// <param name="order">Order of property in primary key.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsPrimaryKey(int order = -1)
		{
			_entity.HasPrimaryKey(_memberGetter, order);
			return this;
		}

		/// <summary>
		/// Marks current column as identity column.
		/// </summary>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsIdentity()
		{
			_entity.HasIdentity(_memberGetter);
			return this;
		}

		PropertyMappingBuilder<TEntity, TProperty> SetColumn(Action<ColumnAttribute> setColumn)
		{
			var getter     = _memberGetter;
			var memberName = null as string;
			var me         = _memberGetter.Body.Unwrap() as MemberExpression;

			if (me != null && me.Expression is MemberExpression)
			{
				for (MemberExpression? m = me; m != null; m = m.Expression as MemberExpression)
				{
					memberName = m.Member.Name + (memberName != null ? "." + memberName : "");
				}

				_entity.SetAttribute(
					() =>
					{
						var a = new ColumnAttribute { Configuration = _entity.Configuration, MemberName = memberName };
						setColumn(a);
						return a;
					},
					setColumn,
					a => a.Configuration,
					attrs => attrs.FirstOrDefault(_ => memberName == null || memberName.Equals(_.MemberName)));

				return this;
			}

			_entity.SetAttribute(
					getter,
					false,
					 _ =>
					 {
						var a = new ColumnAttribute { Configuration = _entity.Configuration, MemberName = memberName};
						setColumn(a);
						return a;
					 },
					(_,a) => setColumn(a),
					a     => a.Configuration,
					a     => new ColumnAttribute(a),
					attrs => attrs.FirstOrDefault(_ => memberName == null || memberName.Equals(_.MemberName)));

			return this;
		}

		/// <summary>
		/// Sets name for current column.
		/// </summary>
		/// <param name="columnName">Column name.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasColumnName(string columnName)
		{
			return SetColumn(a => a.Name = columnName);
		}

		/// <summary>
		/// Sets LINQ to DB type for current column.
		/// </summary>
		/// <param name="dataType">Data type.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasDataType(DataType dataType)
		{
			return SetColumn(a => a.DataType = dataType);
		}

		/// <summary>
		/// Sets database type for current column.
		/// </summary>
		/// <param name="dbType">Column type.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasDbType(string dbType)
		{
			return SetColumn(a => a.DbType = dbType);
		}

		/// <summary>
		/// Sets custom column create SQL template.
		/// </summary>
		/// <param name="format">
		/// Custom template for column definition in create table SQL expression, generated using
		/// <see cref="DataExtensions.CreateTable{T}(IDataContext, string?, string?, string?, string?, string?, DefaultNullable, string?, TableOptions)"/> methods.
		/// Template accepts following string parameters:
		/// - {0} - column name;
		/// - {1} - column type;
		/// - {2} - NULL specifier;
		/// - {3} - identity specification.
		/// </param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasCreateFormat(string format)
		{
			return SetColumn(a => a.CreateFormat = format);
		}

		/// <summary>
		/// Adds data storage property or field for current column.
		/// </summary>
		/// <param name="storage">Name of storage property or field for current column.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasStorage(string storage)
		{
			return SetColumn(a => a.Storage = storage);
		}

		/// <summary>
		/// Marks current column as discriminator column for inheritance mapping.
		/// </summary>
		/// <param name="isDiscriminator">If <c>true</c> - column is used as inheritance mapping discriminator.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsDiscriminator(bool isDiscriminator = true)
		{
			return SetColumn(a => a.IsDiscriminator = isDiscriminator);
		}

		/// <summary>
		/// Marks current column to be skipped by default during a full entity fetch
		/// </summary>
		/// <param name="skipOnEntityFetch">If <c>true</c>, column won't be fetched unless explicity selected in a Linq query.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> SkipOnEntityFetch(bool skipOnEntityFetch = true)
		{
			return SetColumn(a => a.SkipOnEntityFetch = skipOnEntityFetch);
		}

		/// <summary>
		/// Sets whether a column is insertable.
		/// This flag will affect only insert operations with implicit columns specification like
		/// <see cref="DataExtensions.Insert{T}(IDataContext, T, string?, string?, string?, string?, TableOptions)"/>
		/// method and will be ignored when user explicitly specifies value for this column.
		/// </summary>
		/// <param name="skipOnInsert">If <c>true</c> - column will be ignored for implicit insert operations.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasSkipOnInsert(bool skipOnInsert = true)
		{
			return SetColumn(a => a.SkipOnInsert = skipOnInsert);
		}

		/// <summary>
		/// Sets whether a column is updatable.
		/// This flag will affect only update operations with implicit columns specification like
		/// <see cref="DataExtensions.Update{T}(IDataContext, T, string?, string?, string?, string?, TableOptions)"/>
		/// method and will be ignored when user explicitly specifies value for this column.
		/// </summary>
		/// <param name="skipOnUpdate">If <c>true</c> - column will be ignored for implicit update operations.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasSkipOnUpdate(bool skipOnUpdate = true)
		{
			return SetColumn(a => a.SkipOnUpdate = skipOnUpdate);
		}

		/// <summary>
		/// Sets whether a column can contain <c>NULL</c> values.
		/// </summary>
		/// <param name="isNullable">If <c>true</c> - column could contain <c>NULL</c> values.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsNullable(bool isNullable = true)
		{
			return SetColumn(a => a.CanBeNull = isNullable);
		}

		/// <summary>
		/// Sets current member to be excluded from mapping.
		/// </summary>
		/// <returns>Returns current mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsNotColumn()
		{
			return SetColumn(a => a.IsColumn = false);
		}

		/// <summary>
		/// Sets current member to be included into mapping as column.
		/// </summary>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsColumn()
		{
			return SetColumn(a => a.IsColumn = true);
		}

		/// <summary>
		/// Sets the length of the database column.
		/// </summary>
		/// <param name="length">Column length.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasLength(int length)
		{
			return SetColumn(a => a.Length = length);
		}

		/// <summary>
		/// Sets the precision of the database column.
		/// </summary>
		/// <param name="precision">Column precision.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasPrecision(int precision)
		{
			return SetColumn(a => a.Precision = precision);
		}

		/// <summary>
		/// Sets the Scale of the database column.
		/// </summary>
		/// <param name="scale">Column scale.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasScale(int scale)
		{
			return SetColumn(a => a.Scale = scale);
		}

		/// <summary>
		/// Sets the Order of the database column.
		/// </summary>
		/// <param name="order">Column order.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasOrder(int order)
		{
			return SetColumn(a => a.Order = order);
		}

		/// <summary>
		/// Sets that property is alias to another member.
		/// </summary>
		/// <param name="aliasMember">Alias member getter expression.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsAlias(Expression<Func<TEntity, object>> aliasMember)
		{
			if (aliasMember == null) throw new ArgumentNullException(nameof(aliasMember));

			var memberInfo = MemberHelper.GetMemberInfo(aliasMember);

			if (memberInfo == null)
				throw new ArgumentException($"Can not deduce MemberInfo from Lambda: '{aliasMember}'");

			return HasAttribute(new ColumnAliasAttribute(memberInfo.Name));
		}

		/// <summary>
		/// Sets that property is alias to another member.
		/// </summary>
		/// <param name="aliasMember">Alias member name.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsAlias(string aliasMember)
		{
			if (string.IsNullOrEmpty(aliasMember))
				throw new ArgumentException("Value cannot be null or empty.", nameof(aliasMember));

			var memberInfo = typeof(TEntity).GetMember(aliasMember);
			if (memberInfo == null)
				throw new ArgumentException($"Member '{aliasMember}' not found in type '{typeof(TEntity)}'");

			return HasAttribute(new ColumnAliasAttribute(aliasMember));
		}

		/// <summary>
		/// Configure property as alias to another member.
		/// </summary>
		/// <param name="expression">Expression for mapping member during read.</param>
		/// <param name="isColumn">Indicates whether a property value should be filled during entity materialization (calculated property).</param>
		/// <param name="alias">Optional alias for specific member expression. By default Member Name is used.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsExpression<TR>(Expression<Func<TEntity, TR>> expression, bool isColumn = false, string? alias = null)
		{
			if (expression == null) throw new ArgumentNullException(nameof(expression));

			return HasAttribute(new ExpressionMethodAttribute(expression) { IsColumn = isColumn, Alias = alias }).IsNotColumn();
		}

		/// <summary>
		///     Configures the property so that the property value is converted to the given type before
		///     writing to the database and converted back when reading from the database.
		/// </summary>
		/// <typeparam name="TProvider"> The type to convert to and from. </typeparam>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasConversionFunc<TProvider>(Func<TProperty, TProvider> toProvider, Func<TProvider, TProperty> toModel, bool handlesNulls = false)
		{
			return HasAttribute(new ValueConverterAttribute { ValueConverter = new ValueConverterFunc<TProperty, TProvider>(toProvider, toModel, handlesNulls) });
		}

		/// <summary>
		///     Configures the property so that the property value is converted to the given type before
		///     writing to the database and converted back when reading from the database.
		/// </summary>
		/// <typeparam name="TProvider"> The type to convert to and from. </typeparam>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasConversion<TProvider>(Expression<Func<TProperty, TProvider>> toProvider, Expression<Func<TProvider, TProperty>> toModel, bool handlesNulls = false)
		{
			return HasAttribute(new ValueConverterAttribute { ValueConverter = new ValueConverter<TProperty, TProvider>(toProvider, toModel, handlesNulls) });
		}
	}
}

---- Transformed Tree ----
using System;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Collections.Generic;

namespace LinqToDB.Mapping
{
	using Expressions;
	using Extensions;
	using SqlQuery;
	using Common;

	/// <summary>
	/// Column or association fluent mapping builder.
	/// </summary>
	/// <typeparam name="TEntity">Entity type.</typeparam>
	/// <typeparam name="TProperty">Column or association member type.</typeparam>
	public class PropertyMappingBuilder<TEntity, TProperty>
	{
		#region Init

		/// <summary>
		/// Creates column or association fluent mapping builder.
		/// </summary>
		/// <param name="entity">Entity fluent mapping builder.</param>
		/// <param name="memberGetter">Column or association member getter expression.</param>
		public PropertyMappingBuilder(
			EntityMappingBuilder<TEntity>       entity,
			Expression<Func<TEntity,TProperty>> memberGetter)
		{
			_entity       = entity       ?? throw new ArgumentNullException(nameof(entity));
			_memberGetter = memberGetter ?? throw new ArgumentNullException(nameof(memberGetter));
			_memberInfo   = MemberHelper.MemberOf(memberGetter);

			if (_memberInfo.ReflectedType != typeof(TEntity))
				_memberInfo = typeof(TEntity).GetMemberEx(_memberInfo) ?? _memberInfo;
		}

		readonly Expression<Func<TEntity,TProperty>> _memberGetter;
		readonly MemberInfo                          _memberInfo;
		readonly EntityMappingBuilder<TEntity>       _entity;

		#endregion
		/// <summary>
		/// Adds attribute to current mapping member.
		/// </summary>
		/// <param name="attribute">Mapping attribute to add to specified member.</param>
		/// <returns>Returns current column or association mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasAttribute(Attribute attribute)
		{
			_entity.HasAttribute(_memberInfo, attribute);
			return this;
		}

		/// <summary>
		/// Creates entity builder for specified mapping type.
		/// </summary>
		/// <typeparam name="TE">Mapping type.</typeparam>
		/// <param name="configuration">Optional mapping schema configuration name, for which this entity builder should be taken into account.
		/// <see cref="ProviderName"/> for standard configuration names.</param>
		/// <returns>Returns entity mapping builder.</returns>
		public EntityMappingBuilder<TE> Entity<TE>(string? configuration = null)
		{
			return _entity.Entity<TE>(configuration);
		}

		/// <summary>
		/// Adds new column mapping to current column's entity.
		/// </summary>
		/// <param name="func">Column mapping property or field getter expression.</param>
		/// <returns>Returns property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TMember> Property<TMember>(Expression<Func<TEntity, TMember>> func)
		{
			return _entity.Property(func);
		}

		/// <summary>
		/// Adds member mapping to current entity.
		/// </summary>
		/// <param name="func">Column mapping property or field getter expression.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TMember> Member<TMember>(Expression<Func<TEntity,TMember>> func)
		{
			return _entity.Member(func);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Association member type.</typeparam>
		/// <typeparam name="TThisKey">This association side key type.</typeparam>
		/// <typeparam name="TOtherKey">Other association side key type.</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="thisKey">This association key getter expression.</param>
		/// <param name="otherKey">Other association key getter expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns association mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TOther> Association<TOther, TThisKey, TOtherKey>(
			Expression<Func<TEntity, TOther>>   prop,
			Expression<Func<TEntity, TThisKey>> thisKey,
			Expression<Func<TOther, TOtherKey>> otherKey,
			bool                                canBeNull = true)
		{
			return _entity.Association(prop, thisKey, otherKey, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TPropElement">Association member type.</typeparam>
		/// <typeparam name="TThisKey">This association side key type.</typeparam>
		/// <typeparam name="TOtherKey">Other association side key type.</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="thisKey">This association key getter expression.</param>
		/// <param name="otherKey">Other association key getter expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, IEnumerable<TPropElement>> Association<TPropElement, TThisKey, TOtherKey>(
			Expression<Func<TEntity, IEnumerable<TPropElement>>> prop,
			Expression<Func<TEntity, TThisKey>>                  thisKey,
			Expression<Func<TPropElement, TOtherKey>>            otherKey,
			bool                                                 canBeNull = true)
		{
			return _entity.Association(prop, thisKey, otherKey, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="predicate">Predicate expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, IEnumerable<TOther>> Association<TOther>(
			Expression<Func<TEntity, IEnumerable<TOther>>> prop,
			Expression<Func<TEntity, TOther, bool>>        predicate,
			bool                                           canBeNull = true)
		{
			return _entity.Association(prop, predicate, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="predicate">Predicate expression</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TOther> Association<TOther>(
			Expression<Func<TEntity, TOther>>       prop,
			Expression<Func<TEntity, TOther, bool>> predicate,
			bool                                    canBeNull = true)
		{
			return _entity.Association(prop, predicate, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="queryExpression">Query expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, IEnumerable<TOther>> Association<TOther>(
			Expression<Func<TEntity, IEnumerable<TOther>>>              prop,
			Expression<Func<TEntity, IDataContext, IQueryable<TOther>>> queryExpression,
			bool                                                        canBeNull = true)
		{
			return _entity.Association(prop, queryExpression, canBeNull);
		}

		/// <summary>
		/// Adds association mapping to current column's entity.
		/// </summary>
		/// <typeparam name="TOther">Other association side type</typeparam>
		/// <param name="prop">Association member getter expression.</param>
		/// <param name="queryExpression">Query expression.</param>
		/// <param name="canBeNull">Defines type of join. True - left join, False - inner join.</param>
		/// <returns>Returns fluent property mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TOther> Association<TOther>(
			Expression<Func<TEntity, TOther>>                           prop,
			Expression<Func<TEntity, IDataContext, IQueryable<TOther>>> queryExpression,
			bool                                                        canBeNull = true)
		{
			return _entity.Association(prop, queryExpression, canBeNull);
		}

		/// <summary>
		/// Marks current column as primary key member.
		/// </summary>
		/// <param name="order">Order of property in primary key.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsPrimaryKey(int order = -1)
		{
			_entity.HasPrimaryKey(_memberGetter, order);
			return this;
		}

		/// <summary>
		/// Marks current column as identity column.
		/// </summary>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsIdentity()
		{
			_entity.HasIdentity(_memberGetter);
			return this;
		}

		PropertyMappingBuilder<TEntity, TProperty> SetColumn(Action<ColumnAttribute> setColumn)
		{
			var getter     = _memberGetter;

			if (_memberGetter.Body.Unwrap() is MemberExpression me && me.Expression is MemberExpression)
			{
				for (MemberExpression? m = me; m != null; m = m.Expression as MemberExpression)
				{
					memberName = m.Member.Name + (null is string memberName ? "." + memberName : "");
				}

				_entity.SetAttribute(
					() =>
					{
						var a = new ColumnAttribute { Configuration = _entity.Configuration, MemberName = memberName };
						setColumn(a);
						return a;
					},
					setColumn,
					a => a.Configuration,
					attrs => attrs.FirstOrDefault(_ => memberName == null || memberName.Equals(_.MemberName)));

				return this;
			}

			_entity.SetAttribute(
					getter,
					false,
					 _ =>
					 {
						var a = new ColumnAttribute { Configuration = _entity.Configuration, MemberName = memberName};
						setColumn(a);
						return a;
					 },
					(_,a) => setColumn(a),
					a     => a.Configuration,
					a     => new ColumnAttribute(a),
					attrs => attrs.FirstOrDefault(_ => memberName == null || memberName.Equals(_.MemberName)));

			return this;
		}

		/// <summary>
		/// Sets name for current column.
		/// </summary>
		/// <param name="columnName">Column name.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasColumnName(string columnName)
		{
			return SetColumn(a => a.Name = columnName);
		}

		/// <summary>
		/// Sets LINQ to DB type for current column.
		/// </summary>
		/// <param name="dataType">Data type.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasDataType(DataType dataType)
		{
			return SetColumn(a => a.DataType = dataType);
		}

		/// <summary>
		/// Sets database type for current column.
		/// </summary>
		/// <param name="dbType">Column type.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasDbType(string dbType)
		{
			return SetColumn(a => a.DbType = dbType);
		}

		/// <summary>
		/// Sets custom column create SQL template.
		/// </summary>
		/// <param name="format">
		/// Custom template for column definition in create table SQL expression, generated using
		/// <see cref="DataExtensions.CreateTable{T}(IDataContext, string?, string?, string?, string?, string?, DefaultNullable, string?, TableOptions)"/> methods.
		/// Template accepts following string parameters:
		/// - {0} - column name;
		/// - {1} - column type;
		/// - {2} - NULL specifier;
		/// - {3} - identity specification.
		/// </param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasCreateFormat(string format)
		{
			return SetColumn(a => a.CreateFormat = format);
		}

		/// <summary>
		/// Adds data storage property or field for current column.
		/// </summary>
		/// <param name="storage">Name of storage property or field for current column.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasStorage(string storage)
		{
			return SetColumn(a => a.Storage = storage);
		}

		/// <summary>
		/// Marks current column as discriminator column for inheritance mapping.
		/// </summary>
		/// <param name="isDiscriminator">If <c>true</c> - column is used as inheritance mapping discriminator.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsDiscriminator(bool isDiscriminator = true)
		{
			return SetColumn(a => a.IsDiscriminator = isDiscriminator);
		}

		/// <summary>
		/// Marks current column to be skipped by default during a full entity fetch
		/// </summary>
		/// <param name="skipOnEntityFetch">If <c>true</c>, column won't be fetched unless explicity selected in a Linq query.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> SkipOnEntityFetch(bool skipOnEntityFetch = true)
		{
			return SetColumn(a => a.SkipOnEntityFetch = skipOnEntityFetch);
		}

		/// <summary>
		/// Sets whether a column is insertable.
		/// This flag will affect only insert operations with implicit columns specification like
		/// <see cref="DataExtensions.Insert{T}(IDataContext, T, string?, string?, string?, string?, TableOptions)"/>
		/// method and will be ignored when user explicitly specifies value for this column.
		/// </summary>
		/// <param name="skipOnInsert">If <c>true</c> - column will be ignored for implicit insert operations.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasSkipOnInsert(bool skipOnInsert = true)
		{
			return SetColumn(a => a.SkipOnInsert = skipOnInsert);
		}

		/// <summary>
		/// Sets whether a column is updatable.
		/// This flag will affect only update operations with implicit columns specification like
		/// <see cref="DataExtensions.Update{T}(IDataContext, T, string?, string?, string?, string?, TableOptions)"/>
		/// method and will be ignored when user explicitly specifies value for this column.
		/// </summary>
		/// <param name="skipOnUpdate">If <c>true</c> - column will be ignored for implicit update operations.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasSkipOnUpdate(bool skipOnUpdate = true)
		{
			return SetColumn(a => a.SkipOnUpdate = skipOnUpdate);
		}

		/// <summary>
		/// Sets whether a column can contain <c>NULL</c> values.
		/// </summary>
		/// <param name="isNullable">If <c>true</c> - column could contain <c>NULL</c> values.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsNullable(bool isNullable = true)
		{
			return SetColumn(a => a.CanBeNull = isNullable);
		}

		/// <summary>
		/// Sets current member to be excluded from mapping.
		/// </summary>
		/// <returns>Returns current mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsNotColumn()
		{
			return SetColumn(a => a.IsColumn = false);
		}

		/// <summary>
		/// Sets current member to be included into mapping as column.
		/// </summary>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsColumn()
		{
			return SetColumn(a => a.IsColumn = true);
		}

		/// <summary>
		/// Sets the length of the database column.
		/// </summary>
		/// <param name="length">Column length.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasLength(int length)
		{
			return SetColumn(a => a.Length = length);
		}

		/// <summary>
		/// Sets the precision of the database column.
		/// </summary>
		/// <param name="precision">Column precision.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasPrecision(int precision)
		{
			return SetColumn(a => a.Precision = precision);
		}

		/// <summary>
		/// Sets the Scale of the database column.
		/// </summary>
		/// <param name="scale">Column scale.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasScale(int scale)
		{
			return SetColumn(a => a.Scale = scale);
		}

		/// <summary>
		/// Sets the Order of the database column.
		/// </summary>
		/// <param name="order">Column order.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasOrder(int order)
		{
			return SetColumn(a => a.Order = order);
		}

		/// <summary>
		/// Sets that property is alias to another member.
		/// </summary>
		/// <param name="aliasMember">Alias member getter expression.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsAlias(Expression<Func<TEntity, object>> aliasMember)
		{
			if (aliasMember == null) throw new ArgumentNullException(nameof(aliasMember));

			var memberInfo = MemberHelper.GetMemberInfo(aliasMember);

			if (memberInfo == null)
				throw new ArgumentException($"Can not deduce MemberInfo from Lambda: '{aliasMember}'");

			return HasAttribute(new ColumnAliasAttribute(memberInfo.Name));
		}

		/// <summary>
		/// Sets that property is alias to another member.
		/// </summary>
		/// <param name="aliasMember">Alias member name.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsAlias(string aliasMember)
		{
			if (string.IsNullOrEmpty(aliasMember))
				throw new ArgumentException("Value cannot be null or empty.", nameof(aliasMember));

			var memberInfo = typeof(TEntity).GetMember(aliasMember);
			if (memberInfo == null)
				throw new ArgumentException($"Member '{aliasMember}' not found in type '{typeof(TEntity)}'");

			return HasAttribute(new ColumnAliasAttribute(aliasMember));
		}

		/// <summary>
		/// Configure property as alias to another member.
		/// </summary>
		/// <param name="expression">Expression for mapping member during read.</param>
		/// <param name="isColumn">Indicates whether a property value should be filled during entity materialization (calculated property).</param>
		/// <param name="alias">Optional alias for specific member expression. By default Member Name is used.</param>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> IsExpression<TR>(Expression<Func<TEntity, TR>> expression, bool isColumn = false, string? alias = null)
		{
			if (expression == null) throw new ArgumentNullException(nameof(expression));

			return HasAttribute(new ExpressionMethodAttribute(expression) { IsColumn = isColumn, Alias = alias }).IsNotColumn();
		}

		/// <summary>
		///     Configures the property so that the property value is converted to the given type before
		///     writing to the database and converted back when reading from the database.
		/// </summary>
		/// <typeparam name="TProvider"> The type to convert to and from. </typeparam>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasConversionFunc<TProvider>(Func<TProperty, TProvider> toProvider, Func<TProvider, TProperty> toModel, bool handlesNulls = false)
		{
			return HasAttribute(new ValueConverterAttribute { ValueConverter = new ValueConverterFunc<TProperty, TProvider>(toProvider, toModel, handlesNulls) });
		}

		/// <summary>
		///     Configures the property so that the property value is converted to the given type before
		///     writing to the database and converted back when reading from the database.
		/// </summary>
		/// <typeparam name="TProvider"> The type to convert to and from. </typeparam>
		/// <returns>Returns current column mapping builder.</returns>
		public PropertyMappingBuilder<TEntity, TProperty> HasConversion<TProvider>(Expression<Func<TProperty, TProvider>> toProvider, Expression<Func<TProvider, TProperty>> toModel, bool handlesNulls = false)
		{
			return HasAttribute(new ValueConverterAttribute { ValueConverter = new ValueConverter<TProperty, TProvider>(toProvider, toModel, handlesNulls) });
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(221,6): error CS0841: Cannot use local variable 'memberName' before it is declared,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(221,36): error CS8117: Invalid operand for pattern match; value required, but found '<null>'.,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(227,89): error CS0103: The name 'memberName' does not exist in the current context,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(232,13): error CS1061: 'bool' does not contain a definition for 'Configuration' and no accessible extension method 'Configuration' accepting a first argument of type 'bool' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(233,41): error CS0103: The name 'memberName' does not exist in the current context,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(233,63): error CS0103: The name 'memberName' does not exist in the current context,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(243,89): error CS0103: The name 'memberName' does not exist in the current context,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(250,41): error CS0103: The name 'memberName' does not exist in the current context,D:\a\1\s\Source\LinqToDB\Mapping\PropertyMappingBuilder.cs(250,63): error CS0103: The name 'memberName' does not exist in the current context
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\SqlQuery\ConvertVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;

namespace LinqToDB.SqlQuery
{
	using LinqToDB.Linq.Builder;

	public class ConvertVisitor
	{
		// when true, only changed (and explicitly added) elements added to VisitedElements
		// greatly reduce memory allocation for majority of cases, where there is nothing to replace
		private readonly bool                                             _visitAll;
		private readonly bool                                             _allowMutation;
		private readonly Func<ConvertVisitor,IQueryElement,IQueryElement> _convert;
		private readonly Func<VisitArgs, bool>?                           _parentAction;
		private readonly VisitArgs?                                       _visitArgs;

		public class VisitArgs
		{
			public VisitArgs(ConvertVisitor visitor)
			{
				Visitor = visitor;
			}

			public readonly ConvertVisitor Visitor;
			public          IQueryElement  Element = null!;
		}

		delegate T Clone<T>(T obj);

		public Dictionary<IQueryElement,IQueryElement?>  VisitedElements { get; } =  new Dictionary<IQueryElement,IQueryElement?>();
		public List<IQueryElement>                       Stack           { get; } =  new List<IQueryElement>();
		public IQueryElement?                            ParentElement            => Stack.Count == 0 ? null : Stack[Stack.Count - 1];
		public IQueryElement?                            SecondParentElement      => Stack.Count < 2 ? null  : Stack[Stack.Count - 2];

		public static T Convert<T>(T element, Func<ConvertVisitor, IQueryElement, IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, false, false).ConvertInternal(element) ?? element;
		}


		public static T Convert<T>(T element, bool allowMutation, Func<ConvertVisitor,IQueryElement,IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, false, allowMutation).ConvertInternal(element) ?? element;
		}


		public static T ConvertAll<T>(T element, Func<ConvertVisitor, IQueryElement, IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, true, false).ConvertInternal(element) ?? element;
		}

		public static T ConvertAll<T>(T element, Func<ConvertVisitor, IQueryElement, IQueryElement> convertAction, Func<VisitArgs, bool> parentAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, true, false, parentAction).ConvertInternal(element) ?? element;
		}

		public static T ConvertAll<T>(T element, bool allowMutation, Func<ConvertVisitor,IQueryElement,IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, true, allowMutation).ConvertInternal(element) ?? element;
		}

		ConvertVisitor(Func<ConvertVisitor,IQueryElement,IQueryElement> convertAction, bool visitAll, bool allowMutation, Func<VisitArgs, bool>? parentAction = default)
		{
			_visitAll      = visitAll;
			_convert       = convertAction;
			_allowMutation = allowMutation;
			_parentAction  = parentAction;
			if (_parentAction != null)
			{
				_visitArgs = new VisitArgs(this);
			}
		}

		void CorrectQueryHierarchy(SelectQuery? parentQuery)
		{
			if (parentQuery == null)
				return;

			new QueryVisitor().Visit(parentQuery, element =>
			{
				if (element is SelectQuery q)
					q.ParentSelect = parentQuery;
			});

			parentQuery.ParentSelect = null;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		void AddVisited(IQueryElement element, IQueryElement? newElement)
		{
			VisitedElements[element] = newElement;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		void ReplaceVisited(IQueryElement element, IQueryElement? newElement)
		{
			var forDelete = VisitedElements
				.Where(pair => pair.Value != null && QueryHelper.ContainsElement(pair.Value, element))
				.Select(pair => pair.Key).ToList();

			foreach (var e in forDelete)
			{
				VisitedElements.Remove(e);
			}

			VisitedElements[element] = newElement;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		IQueryElement? GetCurrentReplaced(IQueryElement element)
		{
			if (VisitedElements.TryGetValue(element, out var replaced))
			{
				if (replaced != null && replaced != element)
				{
					while (replaced != null && VisitedElements.TryGetValue(replaced, out var another))
					{
						if (replaced == another)
							break;
						replaced = another;
					}
				}
				return replaced;
			}

			return null;
		}

		[return:NotNullIfNotNull("element")]
		IQueryElement? ConvertInternal(IQueryElement? element)
		{
			if (element == null)
				return null;

			// if element manually added outside to VisitedElements as null, it will be processed continuously.
			// Useful when we have to duplicate such items, especially parameters
			var newElement = GetCurrentReplaced(element);
			if (newElement != null)
				return newElement;

			if (_parentAction != null)
			{
				_visitArgs!.Element = element;
				var stop = !_parentAction(_visitArgs!);
				element = _visitArgs!.Element;
				if (stop)
					return element;
			}

			Stack.Add(element);
			{
				switch (element.ElementType)
				{
					case QueryElementType.SqlFunction:
						{
							var func  = (SqlFunction)element;
							var parms = Convert(func.Parameters);

							if (parms != null && !ReferenceEquals(parms, func.Parameters))
								newElement =
									new SqlFunction(func.SystemType, func.Name, func.IsAggregate, func.IsPure, func.Precedence, parms) 
										{ CanBeNull = func.CanBeNull, DoNotOptimize = func.DoNotOptimize };

							break;
						}

					case QueryElementType.SqlExpression:
						{
							var expr      = (SqlExpression)element;
							var parameter = Convert(expr.Parameters);

							if (parameter != null && !ReferenceEquals(parameter, expr.Parameters))
								newElement = new SqlExpression(expr.SystemType, expr.Expr, expr.Precedence, expr.Flags, parameter);

							break;
						}

					case QueryElementType.SqlObjectExpression:
						{
							var expr      = (SqlObjectExpression)element;

							if (_allowMutation)
							{
								for (int i = 0; i < expr.InfoParameters.Length; i++)
								{
									var sqlInfo = expr.InfoParameters[i];

									expr.InfoParameters[i] = sqlInfo.WithSql((ISqlExpression)ConvertInternal(sqlInfo.Sql));
								}
							}
							else
							{
								List<SqlInfo>? currentParams = null;

								for (int i = 0; i < expr.InfoParameters.Length; i++)
								{
									var sqlInfo = expr.InfoParameters[i];

									var newExpr = (ISqlExpression)ConvertInternal(sqlInfo.Sql);

									if (!ReferenceEquals(newExpr, sqlInfo.Sql))
									{
										if (currentParams == null)
										{
											currentParams = new List<SqlInfo>(expr.InfoParameters.Take(i));
										}

										var newInfo = sqlInfo.WithSql(newExpr);
										currentParams.Add(newInfo);
									}
									else
									{
										currentParams?.Add(sqlInfo);
									}
								}

								if (currentParams != null)
									newElement = new SqlObjectExpression(expr.MappingSchema, currentParams.ToArray());
						}

							break;
						}

					case QueryElementType.SqlBinaryExpression:
						{
							var bexpr = (SqlBinaryExpression)element;
							var expr1 = (ISqlExpression?)ConvertInternal(bexpr.Expr1);
							var expr2 = (ISqlExpression?)ConvertInternal(bexpr.Expr2);

							if (expr1 != null && !ReferenceEquals(expr1, bexpr.Expr1) ||
								expr2 != null && !ReferenceEquals(expr2, bexpr.Expr2))
								newElement = new SqlBinaryExpression(bexpr.SystemType, expr1 ?? bexpr.Expr1, bexpr.Operation, expr2 ?? bexpr.Expr2, bexpr.Precedence);

							break;
						}

					case QueryElementType.SqlTable:
						{
							var table    = (SqlTable)element;
							var newTable = (SqlTable)_convert(this, table);

							if (ReferenceEquals(newTable, table))
							{
								var targs = table.TableArguments == null || table.TableArguments.Length == 0 ?
									null : Convert(table.TableArguments);

								if (targs != null && !ReferenceEquals(table.TableArguments, targs))
								{
									var newFields = table.Fields.Select(f => new SqlField(f));
									newTable = new SqlTable(table, newFields, targs);
								}
							}

							if (!ReferenceEquals(table, newTable))
							{
								AddVisited(table.All, newTable.All);
								foreach (var prevField in table.Fields)
								{
									var newField = newTable[prevField.Name];
									if (newField != null)
										AddVisited(prevField, newField);
								}
							}

							newElement = newTable;

							break;
						}

					case QueryElementType.SqlCteTable:
						{
							var table    = (SqlCteTable)element;
								var cte = (CteClause?)ConvertInternal(table.Cte);

							if (cte != null && !ReferenceEquals(table.Cte, cte))
							{
								var newFields = table.Fields.Select(f => new SqlField(f));
								var newTable  = new SqlCteTable(table, newFields, cte!);

								ReplaceVisited(table.All, newTable.All);
								foreach (var prevField in table.Fields)
								{
									var newField = newTable[prevField.Name];
									if (newField != null)
								{
									ReplaceVisited(prevField, newField);
								}
							}

							newElement = newTable;
						}


							break;
						}

					case QueryElementType.Column:
					{
						break;
					}

					case QueryElementType.TableSource:
						{
							var table  = (SqlTableSource)element;
							var source = (ISqlTableSource?)ConvertInternal(table.Source);
							var joins  = Convert(table.Joins);

							List<ISqlExpression[]>? uk = null;
								if (table.HasUniqueKeys)
									uk = ConvertListArray(table.UniqueKeys, null);

								if (source != null && !ReferenceEquals(source, table.Source) ||
								joins  != null && !ReferenceEquals(table.Joins, joins))
								newElement = new SqlTableSource(
									source ?? table.Source,
									table._alias,
									joins ?? table.Joins,
									uk ?? (table.HasUniqueKeys ? table.UniqueKeys : null));

							break;
						}

					case QueryElementType.JoinedTable:
						{
							var join  = (SqlJoinedTable)element;
							var table = (SqlTableSource?)    ConvertInternal(join.Table    );
							var cond  = (SqlSearchCondition?)ConvertInternal(join.Condition);

							if (table != null && !ReferenceEquals(table, join.Table) ||
								cond  != null && !ReferenceEquals(cond,  join.Condition))
								newElement = new SqlJoinedTable(join.JoinType, table ?? join.Table, join.IsWeak, cond ?? join.Condition);

							break;
						}

					case QueryElementType.SearchCondition:
						{
							var sc    = (SqlSearchCondition)element;
							var conds = Convert(sc.Conditions);

							if (conds != null && !ReferenceEquals(sc.Conditions, conds))
								newElement = new SqlSearchCondition(conds);

							break;
						}

					case QueryElementType.Condition:
						{
							var c = (SqlCondition)element;
							var p = (ISqlPredicate?)ConvertInternal(c.Predicate);

							if (p != null && !ReferenceEquals(c.Predicate, p))
								newElement = new SqlCondition(c.IsNot, p, c.IsOr);

							break;
						}

					case QueryElementType.ExprPredicate:
						{
							var p = (SqlPredicate.Expr)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);

							if (e != null && !ReferenceEquals(p.Expr1, e))
								newElement = new SqlPredicate.Expr(e, p.Precedence);

							break;
						}

					case QueryElementType.NotExprPredicate:
						{
							var p = (SqlPredicate.NotExpr)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);

							if (e != null && !ReferenceEquals(p.Expr1, e))
								newElement = new SqlPredicate.NotExpr(e, p.IsNot, p.Precedence);

							break;
						}

					case QueryElementType.ExprExprPredicate:
						{
							var p  = (SqlPredicate.ExprExpr)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1);
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2);

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) || e2 != null && !ReferenceEquals(p.Expr2, e2))
								newElement = new SqlPredicate.ExprExpr(e1 ?? p.Expr1, p.Operator, e2 ?? p.Expr2, p.WithNull);

							break;
						}

					case QueryElementType.LikePredicate:
						{
							var p  = (SqlPredicate.Like)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1 );
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2 );
							var es = (ISqlExpression?)ConvertInternal(p.Escape);

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) ||
								e2 != null && !ReferenceEquals(p.Expr2, e2) ||
								es != null && !ReferenceEquals(p.Escape, es))
								newElement = new SqlPredicate.Like(e1 ?? p.Expr1, p.IsNot, e2 ?? p.Expr2, es ?? p.Escape);

							break;
						}

					case QueryElementType.SearchStringPredicate:
						{
							var p  = (SqlPredicate.SearchString)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1 );
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2 );

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) ||
								e2 != null && !ReferenceEquals(p.Expr2, e2))
								newElement = new SqlPredicate.SearchString(e1 ?? p.Expr1, p.IsNot, e2 ?? p.Expr2, p.Kind, p.IgnoreCase);

							break;
						}

					case QueryElementType.BetweenPredicate:
						{
							var p = (SqlPredicate.Between)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1);
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2);
							var e3 = (ISqlExpression?)ConvertInternal(p.Expr3);

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) ||
								e2 != null && !ReferenceEquals(p.Expr2, e2) ||
								e3 != null && !ReferenceEquals(p.Expr3, e3))
								newElement = new SqlPredicate.Between(e1 ?? p.Expr1, p.IsNot, e2 ?? p.Expr2, e3 ?? p.Expr3);

							break;
						}

					case QueryElementType.IsTruePredicate:
						{
							var p = (SqlPredicate.IsTrue)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);
							var t = (ISqlExpression?)ConvertInternal(p.TrueValue);
							var f = (ISqlExpression?)ConvertInternal(p.FalseValue);

							if (e != null && !ReferenceEquals(p.Expr1, e) ||
							    t != null && !ReferenceEquals(p.TrueValue,  t) ||
								f != null && !ReferenceEquals(p.FalseValue, f)
							    )
								newElement = new SqlPredicate.IsTrue(e ?? p.Expr1, t ?? p.TrueValue, f ?? p.FalseValue, p.WithNull, p.IsNot);

							break;
						}

					case QueryElementType.IsNullPredicate:
						{
							var p = (SqlPredicate.IsNull)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);

							if (e != null && !ReferenceEquals(p.Expr1, e))
								newElement = new SqlPredicate.IsNull(e, p.IsNot);

							break;
						}

					case QueryElementType.InSubQueryPredicate:
						{
							var p = (SqlPredicate.InSubQuery)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);
							var q = (SelectQuery?)   ConvertInternal(p.SubQuery);

							if (e != null && !ReferenceEquals(p.Expr1, e) || q != null && !ReferenceEquals(p.SubQuery, q))
								newElement = new SqlPredicate.InSubQuery(e ?? p.Expr1, p.IsNot, q ?? p.SubQuery);

							break;
						}

					case QueryElementType.InListPredicate:
						{
							var p = (SqlPredicate.InList)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);
							var v = Convert(p.Values);

							if (e != null && !ReferenceEquals(p.Expr1, e) || v != null && !ReferenceEquals(p.Values, v))
								newElement = new SqlPredicate.InList(e ?? p.Expr1, p.WithNull, p.IsNot, v ?? p.Values);

							break;
						}

					case QueryElementType.FuncLikePredicate:
						{
							var p = (SqlPredicate.FuncLike)element;
							var f = (ISqlExpression?)ConvertInternal(p.Function);

							if (f != null && !ReferenceEquals(p.Function, f))
							{
								if (f is SqlFunction function)
									newElement = new SqlPredicate.FuncLike(function);
								else if (f is ISqlPredicate predicate)
									newElement = predicate;
								else
									throw new InvalidCastException("Converted FuncLikePredicate expression is not a Predicate expression.");
							}

							break;
						}

					case QueryElementType.SetExpression:
						{
							var s = (SqlSetExpression)element;
							var c = (ISqlExpression?)ConvertInternal(s.Column    );
							var e = (ISqlExpression?)ConvertInternal(s.Expression);

							if (c != null && !ReferenceEquals(s.Column, c) || e != null && !ReferenceEquals(s.Expression, e))
								newElement = new SqlSetExpression(c ?? s.Column, e ?? s.Expression!);

							break;
						}

					case QueryElementType.InsertClause:
						{
							var s = (SqlInsertClause)element;
							var t = s.Into != null ? (SqlTable?)ConvertInternal(s.Into) : null;
							var i = Convert(s.Items);

							if (t != null && !ReferenceEquals(s.Into, t) || i != null && !ReferenceEquals(s.Items, i))
							{
								var sc = new SqlInsertClause { Into = t ?? s.Into };

								sc.Items.AddRange(i ?? s.Items);
								sc.WithIdentity = s.WithIdentity;

								newElement = sc;
							}

							break;
						}

					case QueryElementType.UpdateClause:
						{
							var s = (SqlUpdateClause)element;
							var t = s.Table != null ? (SqlTable?)ConvertInternal(s.Table) : null;
							var i = Convert(s.Items);
							var k = Convert(s.Keys );

							if (t != null && !ReferenceEquals(s.Table, t) ||
								i != null && !ReferenceEquals(s.Items, i) ||
								k != null && !ReferenceEquals(s.Keys,  k))
							{
								var sc = new SqlUpdateClause { Table = t ?? s.Table };

								sc.Items.AddRange(i ?? s.Items);
								sc.Keys. AddRange(k ?? s.Keys);

								newElement = sc;
							}

							break;
						}

					case QueryElementType.SelectStatement:
						{
							var s = (SqlSelectStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?)ConvertInternal(s.SelectQuery);

							if (selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with))
							{
								newElement = new SqlSelectStatement(selectQuery ?? s.SelectQuery);
								((SqlSelectStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlSelectStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.InsertStatement:
						{
							var s = (SqlInsertStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?    )ConvertInternal(s.SelectQuery);
							var insert      = (SqlInsertClause?)ConvertInternal(s.Insert);
							var output      = s.Output      != null ? (SqlOutputClause?)ConvertInternal(s.Output     ) : null;

							if (insert      != null && !ReferenceEquals(s.Insert,      insert)       ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with)         ||
								output      != null && !ReferenceEquals(s.Output,      output))
							{
								newElement = new SqlInsertStatement(selectQuery ?? s.SelectQuery)
							{
									Insert = insert ?? s.Insert,
									Output = output ?? s.Output,
									With   = with   ?? s.With
								};
								CorrectQueryHierarchy(((SqlInsertStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.UpdateStatement:
						{
							var s = (SqlUpdateStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?    )ConvertInternal(s.SelectQuery);
							var update      = (SqlUpdateClause?)ConvertInternal(s.Update);

							if (update      != null && !ReferenceEquals(s.Update,      update)       ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with))
							{
								newElement = new SqlUpdateStatement(selectQuery ?? s.SelectQuery) { Update = update ?? s.Update };
								((SqlUpdateStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlUpdateStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.InsertOrUpdateStatement:
						{
							var s = (SqlInsertOrUpdateStatement)element;

							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?    )ConvertInternal(s.SelectQuery);
							var insert      = (SqlInsertClause?)ConvertInternal(s.Insert);
							var update      = (SqlUpdateClause?)ConvertInternal(s.Update);

							if (insert      != null && !ReferenceEquals(s.Insert,      insert)       ||
								update      != null && !ReferenceEquals(s.Update,      update)       ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with))
							{
								newElement = new SqlInsertOrUpdateStatement(selectQuery ?? s.SelectQuery) { Insert = insert ?? s.Insert, Update = update ?? s.Update };
								((SqlInsertOrUpdateStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlInsertOrUpdateStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.DeleteStatement:
						{
							var s = (SqlDeleteStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = s.SelectQuery != null ? (SelectQuery?)   ConvertInternal(s.SelectQuery) : null;
							var table       = s.Table       != null ? (SqlTable?)      ConvertInternal(s.Table      ) : null;
							var top         = s.Top         != null ? (ISqlExpression?) ConvertInternal(s.Top        ) : null;
							var output      = s.Output      != null ? (SqlOutputClause?)ConvertInternal(s.Output     ) : null;

							if (table       != null && !ReferenceEquals(s.Table,       table)       ||
								top         != null && !ReferenceEquals(s.Top,         top)         ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery) ||
								with        != null && !ReferenceEquals(s.With,        with)        ||
								output      != null && !ReferenceEquals(s.Output,      output))
							{
								newElement = new SqlDeleteStatement
								{
									Table                = table       ?? s.Table,
									SelectQuery          = selectQuery ?? s.SelectQuery,
									Top                  = top         ?? s.Top!,
									Output               = output      ?? s.Output,
									IsParameterDependent = s.IsParameterDependent
								};
								((SqlDeleteStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlDeleteStatement)newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.CreateTableStatement:
						{
							var s  = (SqlCreateTableStatement)element;
							var t  = (SqlTable)ConvertInternal(s.Table);

							if (t != null && !ReferenceEquals(s.Table, t))
							{
								newElement = new SqlCreateTableStatement(t ?? s.Table);
							}

							break;
						}

					case QueryElementType.DropTableStatement:
						{
							var s  = (SqlDropTableStatement)element;
							var t  = (SqlTable)ConvertInternal(s.Table);

							if (!ReferenceEquals(s.Table, t))
							{
								newElement = new SqlDropTableStatement(t);
							}

							break;
						}

					case QueryElementType.SelectClause:
						{
							var sc   = (SqlSelectClause)element;

							List<SqlColumn>? cols = null;

							if (_allowMutation)
							{
								for (int i = 0; i < sc.Columns.Count; i++)
								{
									var column = sc.Columns[i];

									Stack.Add(column);
									var expr = (ISqlExpression)ConvertInternal(column.Expression);
									Stack.RemoveAt(Stack.Count - 1);

									if (!ReferenceEquals(column.Expression, expr))
										column.Expression = expr;
								}
							}
							else
							{
								for (int i = 0; i < sc.Columns.Count; i++)
								{
									var column = sc.Columns[i];

									Stack.Add(column);
									var expr = (ISqlExpression)ConvertInternal(column.Expression);
									Stack.RemoveAt(Stack.Count - 1);

									if (!ReferenceEquals(expr, column.Expression))
									{
										if (cols == null)
										{
											cols = new List<SqlColumn>(sc.Columns.Take(i));
										}

										var newColumn = new SqlColumn(null, expr, column.Alias);
										cols.Add(newColumn);
										AddVisited(column, newColumn);
									}
									else
									{
										cols?.Add(column);
										AddVisited(column, column);
									}
								}
							}

							var take = (ISqlExpression?)ConvertInternal(sc.TakeValue);
							var skip = (ISqlExpression?)ConvertInternal(sc.SkipValue);

							if (
								cols != null && !ReferenceEquals(sc.Columns,   cols) ||
								take != null && !ReferenceEquals(sc.TakeValue, take) ||
								skip != null && !ReferenceEquals(sc.SkipValue, skip))
							{
								newElement = new SqlSelectClause(sc.IsDistinct, take ?? sc.TakeValue, sc.TakeHints, skip ?? sc.SkipValue, cols ?? sc.Columns);
							}

							break;
						}

					case QueryElementType.FromClause:
						{
							var fc   = (SqlFromClause)element;
							var ts = Convert(fc.Tables);

							if (ts != null && !ReferenceEquals(fc.Tables, ts))
							{
								newElement = new SqlFromClause(ts ?? fc.Tables);
								((SqlFromClause)newElement).SetSqlQuery(fc.SelectQuery);
							}

							break;
						}

					case QueryElementType.WhereClause:
						{
							var wc   = (SqlWhereClause)element;
							var cond = (SqlSearchCondition?)ConvertInternal(wc.SearchCondition);

							if (cond != null && !ReferenceEquals(wc.SearchCondition, cond))
							{
								newElement = new SqlWhereClause(cond ?? wc.SearchCondition);
								((SqlWhereClause)newElement).SetSqlQuery(wc.SelectQuery);
							}

							break;
						}

					case QueryElementType.GroupByClause:
						{
							var gc = (SqlGroupByClause)element;
							var es = Convert(gc.Items);

							if (es != null && !ReferenceEquals(gc.Items, es))
							{
								newElement = new SqlGroupByClause(gc.GroupingType, es ?? gc.Items);
								((SqlGroupByClause)newElement).SetSqlQuery(gc.SelectQuery);
							}

							break;
						}

					case QueryElementType.GroupingSet:
						{
							var gc = (SqlGroupingSet)element;
							var es = Convert(gc.Items);

							if (es != null && !ReferenceEquals(gc.Items, es))
							{
								newElement = new SqlGroupingSet(es ?? gc.Items);
							}

							break;
						}

					case QueryElementType.OrderByClause:
						{
							var oc = (SqlOrderByClause)element;
							var es = Convert(oc.Items);

							if (es != null && !ReferenceEquals(oc.Items, es))
							{
								newElement = new SqlOrderByClause(es ?? oc.Items);
								((SqlOrderByClause)newElement).SetSqlQuery(oc.SelectQuery);
							}

							break;
						}

					case QueryElementType.OrderByItem:
						{
							var i = (SqlOrderByItem)element;
							var e = (ISqlExpression?)ConvertInternal(i.Expression);

							if (e != null && !ReferenceEquals(i.Expression, e))
								newElement = new SqlOrderByItem(e, i.IsDescending);

							break;
						}

					case QueryElementType.SetOperator:
						{
							var u = (SqlSetOperator)element;
							var q = (SelectQuery?)ConvertInternal(u.SelectQuery);

							if (q != null && !ReferenceEquals(u.SelectQuery, q))
								newElement = new SqlSetOperator(q, u.Operation);

							break;
						}

					case QueryElementType.SqlQuery:
						{
							var q = (SelectQuery)element;

							var fc = (SqlFromClause?)   ConvertInternal(q.From   ) ?? q.From;
							var sc = (SqlSelectClause?) ConvertInternal(q.Select ) ?? q.Select;
							var wc = (SqlWhereClause?)  ConvertInternal(q.Where  ) ?? q.Where;
							var gc = (SqlGroupByClause?)ConvertInternal(q.GroupBy) ?? q.GroupBy;
							var hc = (SqlWhereClause?)  ConvertInternal(q.Having ) ?? q.Having;
							var oc = (SqlOrderByClause?)ConvertInternal(q.OrderBy) ?? q.OrderBy;
							var us = q.HasSetOperators ? Convert(q.SetOperators) : q.SetOperators;

							List<ISqlExpression[]>? uk = null;
							if (q.HasUniqueKeys)
								uk = ConvertListArray(q.UniqueKeys, null) ?? q.UniqueKeys;

							if (   !ReferenceEquals(fc, q.From)
								|| !ReferenceEquals(sc, q.Select)
								|| !ReferenceEquals(wc, q.Where)
								|| !ReferenceEquals(gc, q.GroupBy)
								|| !ReferenceEquals(hc, q.Having)
								|| !ReferenceEquals(oc, q.OrderBy)
								|| us != null && !ReferenceEquals(us, q.SetOperators)
								|| uk != null && !ReferenceEquals(uk, q.UniqueKeys)
							)
							{
								var nq = new SelectQuery();

								var objTree = new Dictionary<ICloneableElement, ICloneableElement>();

								// try to correct if there q.* in columns expressions
								// TODO: not performant, it is bad that Columns has reference on this select query
								sc = ConvertAll(sc, (v, e) => ReferenceEquals(e, q.All) ? nq.All : e);
								
								if (ReferenceEquals(sc, q.Select))
									sc = new SqlSelectClause(nq, sc, objTree, e => e is SqlColumn c && c.Parent == q);
								
								if (ReferenceEquals(fc, q.From))
									fc = new SqlFromClause   (nq, fc, objTree, e => false);
								if (ReferenceEquals(wc, q.Where))
									wc = new SqlWhereClause  (nq, wc, objTree, e => false);
								if (ReferenceEquals(gc, q.GroupBy))
									gc = new SqlGroupByClause(nq, gc, objTree, e => false);
								if (ReferenceEquals(hc, q.Having))
									hc = new SqlWhereClause  (nq, hc, objTree, e => false);
								if (ReferenceEquals(oc, q.OrderBy))
									oc = new SqlOrderByClause(nq, oc, objTree, e => false);
								if (us == null || ReferenceEquals(us, q.SetOperators))
									us = new List<SqlSetOperator>(us ?? q.SetOperators);

								AddVisited(q.All, nq.All);

								nq.Init(sc, fc, wc, gc, hc, oc, us, uk,
									q.ParentSelect,
									q.IsParameterDependent);

								// update visited in case if columns were cloned
								foreach (var pair in objTree)
								{
									if (pair.Key is IQueryElement queryElement)
										VisitedElements[queryElement] = (IQueryElement)pair.Value;
								}

								newElement = nq;
							}
							break;
						}

					case QueryElementType.MergeStatement:
						{
							var merge = (SqlMergeStatement)element;

							var target     = (SqlTableSource?)     ConvertInternal(merge.Target);
							var source     = (SqlMergeSourceTable?)ConvertInternal(merge.Source);
							var on         = (SqlSearchCondition?) ConvertInternal(merge.On);
							var operations = ConvertSafe(merge.Operations);

							if (target     != null && !ReferenceEquals(merge.Target, target) ||
								source     != null && !ReferenceEquals(merge.Source, source) ||
								on         != null && !ReferenceEquals(merge.On, on) ||
								operations != null && !ReferenceEquals(merge.Operations, operations))
							{
								newElement = new SqlMergeStatement(
									merge.Hint,
									target ?? merge.Target,
									source ?? merge.Source,
									on ?? merge.On,
									operations ?? merge.Operations);
							}

							break;
						}

					case QueryElementType.MergeSourceTable:
						{
							var source = (SqlMergeSourceTable)element;

							var enumerableSource          = (SqlValuesTable?)ConvertInternal(source.SourceEnumerable);
							var querySource               = (SelectQuery?)   ConvertInternal(source.SourceQuery);

							if (enumerableSource != null && !ReferenceEquals(source.SourceEnumerable, enumerableSource) ||
								querySource      != null && !ReferenceEquals(source.SourceQuery, querySource))
							{
								var newFields = source.SourceFields.Select(f => new SqlField(f)).ToArray();
								for (var i = 0; i < source.SourceFields.Count; i++)
								{
									var newField           = newFields[i];
									var oldField           = source.SourceFields[i];
									ReplaceVisited(oldField, newField);
								}

								newElement = new SqlMergeSourceTable(
									source.SourceID,
									enumerableSource ?? source.SourceEnumerable!,
									querySource ?? source.SourceQuery!,
									newFields);

								ReplaceVisited(((ISqlTableSource)source).All, ((ISqlTableSource)newElement).All);
						}

								break;
							}

					case QueryElementType.SqlValuesTable:
						{
							var table = (SqlValuesTable)element;

							List<ISqlExpression[]>? convertedRows = null;
							var rowsConverted = false;

							if (table.Rows != null)
							{
								convertedRows = new List<ISqlExpression[]>();
								foreach (var row in table.Rows)
								{
									var convertedRow = ConvertSafe(row);
									rowsConverted    = rowsConverted || (convertedRow != null && !ReferenceEquals(convertedRow, row));

									convertedRows.Add(convertedRow?.ToArray() ?? row!);
								}
							}

							var fields1 = table.Fields.ToArray();
							var fields2 = Convert(fields1, f => new SqlField(f));

							var fieldsConverted = fields2 != null && !ReferenceEquals(fields1, fields2);

							if (fieldsConverted || rowsConverted)
							{
								if (!fieldsConverted)
								{
									fields2 = fields1;

									for (var i = 0; i < fields2.Length; i++)
									{
										var field = fields2[i];

										fields2[i] = new SqlField(field);

										VisitedElements[field] = fields2[i];
									}
								}

								newElement = new SqlValuesTable(table.Source!, table.ValueBuilders!, fields2!, rowsConverted ? convertedRows : table.Rows);
							}

							break;
						}

					case QueryElementType.OutputClause:
					{
						var output    = (SqlOutputClause)element;
						var sourceT   = ConvertInternal(output.SourceTable)   as SqlTable;
						var insertedT = ConvertInternal(output.InsertedTable) as SqlTable;
						var deletedT  = ConvertInternal(output.DeletedTable)  as SqlTable;
						var outputT   = ConvertInternal(output.OutputTable)   as SqlTable;
						var outputQ   = output.OutputQuery != null ? ConvertInternal(output.OutputQuery) as SelectQuery : null;

						if (
							sourceT   != null && !ReferenceEquals(output.SourceTable, sourceT)     ||
							insertedT != null && !ReferenceEquals(output.InsertedTable, insertedT) ||
							deletedT  != null && !ReferenceEquals(output.DeletedTable, deletedT)   ||
							outputT   != null && !ReferenceEquals(output.OutputTable, outputT)     ||
							outputQ   != null && !ReferenceEquals(output.OutputQuery, outputQ)
						)
						{
							newElement = new SqlOutputClause
							{
								SourceTable   =  sourceT   ?? output.SourceTable,
								InsertedTable =  insertedT ?? output.InsertedTable,
								DeletedTable  =  deletedT  ?? output.DeletedTable,
								OutputTable   =  outputT   ?? output.OutputTable,
								OutputQuery   =  outputQ   ?? output.OutputQuery,
							};                            
						}
						
						break;
					}

					case QueryElementType.MergeOperationClause:
						{
							var operation = (SqlMergeOperationClause)element;

							var where       = (SqlSearchCondition?)ConvertInternal(operation.Where);
							var whereDelete = (SqlSearchCondition?)ConvertInternal(operation.WhereDelete);
							var items       = ConvertSafe(operation.Items);

							if (where       != null && !ReferenceEquals(operation.Where, where)             ||
								whereDelete != null && !ReferenceEquals(operation.WhereDelete, whereDelete) ||
								items       != null && !ReferenceEquals(operation.Items, items))
							{
								newElement = new SqlMergeOperationClause(
									operation.OperationType,
									where ?? operation.Where,
									whereDelete ?? operation.WhereDelete,
									items ?? operation.Items);
							}

							break;
						}

					case QueryElementType.TruncateTableStatement:
						{
							var truncate = (SqlTruncateTableStatement)element;

							if (truncate.Table != null)
							{
								var table = (SqlTable?)ConvertInternal(truncate.Table);

								if (table != null && !ReferenceEquals(truncate.Table, table))
								{
									newElement = new SqlTruncateTableStatement()
										{
											Table = table,
											ResetIdentity = truncate.ResetIdentity
										};
								}
							}

							break;
						}

					case QueryElementType.SqlRawSqlTable:
						{
							var table   = (SqlRawSqlTable)element;
							var fields1 = table.Fields.ToArray();
							var fields2 = Convert(fields1, f => new SqlField(f));
							var targs   = table.Parameters == null || table.Parameters.Length == 0 ?
								null : Convert(table.Parameters);

							var fe = fields2 != null && !ReferenceEquals(fields1, fields2);
							var ta = targs   != null && !ReferenceEquals(table.Parameters, targs);

							if (fe || ta)
							{
								if (!fe)
								{
									fields2 = fields1;

									for (var i = 0; i < fields2.Length; i++)
									{
										var field = fields2[i];

										fields2[i] = new SqlField(field);

										VisitedElements[field] = fields2[i];
									}
								}

								newElement = new SqlRawSqlTable(table, fields2!, targs ?? table.Parameters!);

								VisitedElements[table.All] = ((SqlRawSqlTable)newElement).All;
							}

							break;
						}

					case QueryElementType.CteClause:
						{
							var cte = (CteClause)element;

							// for avoiding recursion
							if (SecondParentElement?.ElementType != QueryElementType.WithClause)
								break;

							var body   = (SelectQuery?)ConvertInternal(cte.Body);

							if (body   != null && !ReferenceEquals(cte.Body, body))
							{
								var objTree = new Dictionary<ICloneableElement, ICloneableElement>();

								newElement = new CteClause(
									body,
									cte.Fields!.Select(f => (SqlField)f.Clone(objTree, e => true)).ToList(),
											cte.ObjectType,
											cte.IsRecursive,
											cte.Name);

								var correctedBody = Convert(body,
									(v, e) =>
									{
										if (e.ElementType == QueryElementType.CteClause)
										{
											var inner = (CteClause)e;
											if (ReferenceEquals(inner, cte))
												return newElement;
										}	
											
										if (e is ICloneableElement clonable && objTree.TryGetValue(clonable, out var newValue))
											return (IQueryElement)newValue;
										return e;

									});

								// update visited for cloned fields
								foreach (var pair in objTree)
								{
									if (pair.Key is IQueryElement queryElement)
										VisitedElements[queryElement] = (IQueryElement)pair.Value;
								}

								VisitedElements.Remove(element);
								AddVisited(element, newElement);

								((CteClause)newElement).Body = correctedBody;
							}

							break;
						}

					case QueryElementType.WithClause:
						{
							var with = (SqlWithClause)element;

							var clauses = ConvertSafe(with.Clauses);

							if (clauses != null && !ReferenceEquals(with.Clauses, clauses))
							{
								newElement = new SqlWithClause()
								{
									Clauses = clauses
								};

								newElement = new SqlWithClause() { Clauses = clauses };
							}
							break;
						}

					case QueryElementType.SqlField           :
					case QueryElementType.SqlParameter       :
					case QueryElementType.SqlValue           :
					case QueryElementType.SqlDataType        :
					case QueryElementType.SqlAliasPlaceholder:
						break;

					default:
						throw new InvalidOperationException($"Convert visitor not implemented for element {element.ElementType}");
				}
			}
			Stack.RemoveAt(Stack.Count - 1);

			newElement = _convert(this, newElement ?? element);

			if (!_visitAll || !ReferenceEquals(element, newElement))
				AddVisited(element, newElement);

			return newElement;
		}

		T[]? Convert<T>(T[] arr)
			where T : class, IQueryElement
		{
			return Convert(arr, null);
		}

		T[]? Convert<T>(T[] arr1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < arr1.Length; i++)
				{
					var elem = (T?)ConvertInternal(arr1[i]);
					if (elem != null)
						arr1[i] = elem;
				}
				return arr1;
			}

			T[]? arr2 = null;

			for (var i = 0; i < arr1.Length; i++)
			{
				var elem1 = arr1[i];
				var elem2 = (T?)ConvertInternal(elem1);

				if (elem2 != null && !ReferenceEquals(elem1, elem2))
				{
					if (arr2 == null)
					{
						arr2 = new T[arr1.Length];

						for (var j = 0; j < i; j++)
							arr2[j] = clone == null ? arr1[j] : clone(arr1[j]);
					}

					arr2[i] = elem2;
				}
				else if (arr2 != null)
					arr2[i] = clone == null ? elem1 : clone(elem1);
			}

			return arr2;
		}

		List<T>? ConvertSafe<T>(IList<T> list)
			where T : class, IQueryElement
		{
			return ConvertSafe(list, null);
		}

		List<T>? ConvertSafe<T>(IList<T> list1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < list1.Count; i++)
				{
					var elem = (T?)ConvertInternal(list1[i]);
					if (elem != null)
						list1[i] = elem;
				}
				return null;
			}

			List<T>? list2 = null;

			for (var i = 0; i < list1.Count; i++)
			{
				var elem1 = list1[i];

				if (ConvertInternal(elem1) is T elem2 && !ReferenceEquals(elem1, elem2))
				{
					if (list2 == null)
					{
						list2 = new List<T>(list1.Count);

						for (var j = 0; j < i; j++)
							list2.Add(clone == null ? list1[j] : clone(list1[j]));
					}

					list2.Add(elem2);
				}
				else
					list2?.Add(clone == null ? elem1 : clone(elem1));
			}

			return list2;
		}

		List<T>? Convert<T>(List<T> list)
			where T : class, IQueryElement
		{
			return Convert(list, null);
		}

		List<T>? Convert<T>(List<T> list1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < list1.Count; i++)
				{
					var elem = (T?)ConvertInternal(list1[i]);
					if (elem != null)
						list1[i] = elem;
				}
				return list1;
			}

			List<T>? list2 = null;

			for (var i = 0; i < list1.Count; i++)
			{
				var elem1 = list1[i];
				var elem2 = (T?)ConvertInternal(elem1);

				if (elem2 != null && !ReferenceEquals(elem1, elem2))
				{
					if (list2 == null)
					{
						list2 = new List<T>(list1.Count);

						for (var j = 0; j < i; j++)
						{
							var elem = list1[j];
							if (clone != null)
								VisitedElements[elem] = elem = clone(elem);

							list2.Add(elem);
						}
					}

					list2.Add(elem2);
				}
				else if (list2 != null)
				{
					if (clone != null)
						VisitedElements[elem1] = elem1 = clone(elem1);

					list2.Add(elem1);
				}
			}

			return list2;
		}

		List<T[]>? ConvertListArray<T>(List<T[]> list1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < list1.Count; i++)
				{
					var elem = Convert(list1[i]);
					if (elem != null)
						list1[i] = elem;
				}
				return list1;
			}

			List<T[]>? list2 = null;

			for (var i = 0; i < list1.Count; i++)
			{
				var elem1 = list1[i];
				var elem2 = Convert(elem1);

				if (elem2 != null && !ReferenceEquals(elem1, elem2))
				{
					if (list2 == null)
					{
						list2 = new List<T[]>(list1.Count);

						for (var j = 0; j < i; j++)
							list2.Add(clone == null ? list1[j] : list1[j].Select(e => clone(e)).ToArray() );
					}

					list2.Add(elem2);
				}
				else
					list2?.Add(clone == null ? elem1 : elem1.Select(e => clone(e)).ToArray());
			}

			return list2;
		}
	}
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;

namespace LinqToDB.SqlQuery
{
	using LinqToDB.Linq.Builder;

	public class ConvertVisitor
	{
		// when true, only changed (and explicitly added) elements added to VisitedElements
		// greatly reduce memory allocation for majority of cases, where there is nothing to replace
		private readonly bool                                             _visitAll;
		private readonly bool                                             _allowMutation;
		private readonly Func<ConvertVisitor,IQueryElement,IQueryElement> _convert;
		private readonly Func<VisitArgs, bool>?                           _parentAction;
		private readonly VisitArgs?                                       _visitArgs;

		public class VisitArgs
		{
			public VisitArgs(ConvertVisitor visitor)
			{
				Visitor = visitor;
			}

			public readonly ConvertVisitor Visitor;
			public          IQueryElement  Element = null!;
		}

		delegate T Clone<T>(T obj);

		public Dictionary<IQueryElement,IQueryElement?>  VisitedElements { get; } =  new Dictionary<IQueryElement,IQueryElement?>();
		public List<IQueryElement>                       Stack           { get; } =  new List<IQueryElement>();
		public IQueryElement?                            ParentElement            => Stack.Count == 0 ? null : Stack[Stack.Count - 1];
		public IQueryElement?                            SecondParentElement      => Stack.Count < 2 ? null  : Stack[Stack.Count - 2];

		public static T Convert<T>(T element, Func<ConvertVisitor, IQueryElement, IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, false, false).ConvertInternal(element) ?? element;
		}


		public static T Convert<T>(T element, bool allowMutation, Func<ConvertVisitor,IQueryElement,IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, false, allowMutation).ConvertInternal(element) ?? element;
		}


		public static T ConvertAll<T>(T element, Func<ConvertVisitor, IQueryElement, IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, true, false).ConvertInternal(element) ?? element;
		}

		public static T ConvertAll<T>(T element, Func<ConvertVisitor, IQueryElement, IQueryElement> convertAction, Func<VisitArgs, bool> parentAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, true, false, parentAction).ConvertInternal(element) ?? element;
		}

		public static T ConvertAll<T>(T element, bool allowMutation, Func<ConvertVisitor,IQueryElement,IQueryElement> convertAction)
			where T : class, IQueryElement
		{
			return (T?)new ConvertVisitor(convertAction, true, allowMutation).ConvertInternal(element) ?? element;
		}

		ConvertVisitor(Func<ConvertVisitor,IQueryElement,IQueryElement> convertAction, bool visitAll, bool allowMutation, Func<VisitArgs, bool>? parentAction = default)
		{
			_visitAll      = visitAll;
			_convert       = convertAction;
			_allowMutation = allowMutation;
			_parentAction  = parentAction;
			if (_parentAction != null)
			{
				_visitArgs = new VisitArgs(this);
			}
		}

		void CorrectQueryHierarchy(SelectQuery? parentQuery)
		{
			if (parentQuery == null)
				return;

			new QueryVisitor().Visit(parentQuery, element =>
			{
				if (element is SelectQuery q)
					q.ParentSelect = parentQuery;
			});

			parentQuery.ParentSelect = null;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		void AddVisited(IQueryElement element, IQueryElement? newElement)
		{
			VisitedElements[element] = newElement;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		void ReplaceVisited(IQueryElement element, IQueryElement? newElement)
		{
			var forDelete = VisitedElements
				.Where(pair => pair.Value != null && QueryHelper.ContainsElement(pair.Value, element))
				.Select(pair => pair.Key).ToList();

			foreach (var e in forDelete)
			{
				VisitedElements.Remove(e);
			}

			VisitedElements[element] = newElement;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		IQueryElement? GetCurrentReplaced(IQueryElement element)
		{
			if (VisitedElements.TryGetValue(element, out var replaced))
			{
				if (replaced != null && replaced != element)
				{
					while (replaced != null && VisitedElements.TryGetValue(replaced, out var another))
					{
						if (replaced == another)
							break;
						replaced = another;
					}
				}
				return replaced;
			}

			return null;
		}

		[return:NotNullIfNotNull("element")]
		IQueryElement? ConvertInternal(IQueryElement? element)
		{
			if (element == null)
				return null;

			// if element manually added outside to VisitedElements as null, it will be processed continuously.
			// Useful when we have to duplicate such items, especially parameters
			var newElement = GetCurrentReplaced(element);
			if (newElement != null)
				return newElement;

			if (_parentAction != null)
			{
				_visitArgs!.Element = element;
				var stop = !_parentAction(_visitArgs!);
				element = _visitArgs!.Element;
				if (stop)
					return element;
			}

			Stack.Add(element);
			{
				switch (element.ElementType)
				{
					case QueryElementType.SqlFunction:
						{
							var func  = (SqlFunction)element;
							var parms = Convert(func.Parameters);

							if (parms != null && !ReferenceEquals(parms, func.Parameters))
								newElement =
									new SqlFunction(func.SystemType, func.Name, func.IsAggregate, func.IsPure, func.Precedence, parms) 
										{ CanBeNull = func.CanBeNull, DoNotOptimize = func.DoNotOptimize };

							break;
						}

					case QueryElementType.SqlExpression:
						{
							var expr      = (SqlExpression)element;
							var parameter = Convert(expr.Parameters);

							if (parameter != null && !ReferenceEquals(parameter, expr.Parameters))
								newElement = new SqlExpression(expr.SystemType, expr.Expr, expr.Precedence, expr.Flags, parameter);

							break;
						}

					case QueryElementType.SqlObjectExpression:
						{
							var expr      = (SqlObjectExpression)element;

							if (_allowMutation)
							{
								for (int i = 0; i < expr.InfoParameters.Length; i++)
								{
									var sqlInfo = expr.InfoParameters[i];

									expr.InfoParameters[i] = sqlInfo.WithSql((ISqlExpression)ConvertInternal(sqlInfo.Sql));
								}
							}
							else
							{
								List<SqlInfo>? currentParams = null;

								for (int i = 0; i < expr.InfoParameters.Length; i++)
								{
									var sqlInfo = expr.InfoParameters[i];

									var newExpr = (ISqlExpression)ConvertInternal(sqlInfo.Sql);

									if (!ReferenceEquals(newExpr, sqlInfo.Sql))
									{
										if (currentParams == null)
										{
											currentParams = new List<SqlInfo>(expr.InfoParameters.Take(i));
										}

										var newInfo = sqlInfo.WithSql(newExpr);
										currentParams.Add(newInfo);
									}
									else
									{
										currentParams?.Add(sqlInfo);
									}
								}

								if (currentParams != null)
									newElement = new SqlObjectExpression(expr.MappingSchema, currentParams.ToArray());
						}

							break;
						}

					case QueryElementType.SqlBinaryExpression:
						{
							var bexpr = (SqlBinaryExpression)element;
							var expr1 = (ISqlExpression?)ConvertInternal(bexpr.Expr1);
							var expr2 = (ISqlExpression?)ConvertInternal(bexpr.Expr2);

							if (expr1 != null && !ReferenceEquals(expr1, bexpr.Expr1) ||
								expr2 != null && !ReferenceEquals(expr2, bexpr.Expr2))
								newElement = new SqlBinaryExpression(bexpr.SystemType, expr1 ?? bexpr.Expr1, bexpr.Operation, expr2 ?? bexpr.Expr2, bexpr.Precedence);

							break;
						}

					case QueryElementType.SqlTable:
						{
							var table    = (SqlTable)element;
							var newTable = (SqlTable)_convert(this, table);

							if (ReferenceEquals(newTable, table))
							{
								var targs = table.TableArguments == null || table.TableArguments.Length == 0 ?
									null : Convert(table.TableArguments);

								if (targs != null && !ReferenceEquals(table.TableArguments, targs))
								{
									var newFields = table.Fields.Select(f => new SqlField(f));
									newTable = new SqlTable(table, newFields, targs);
								}
							}

							if (!ReferenceEquals(table, newTable))
							{
								AddVisited(table.All, newTable.All);
								foreach (var prevField in table.Fields)
								{
									var newField = newTable[prevField.Name];
									if (newField != null)
										AddVisited(prevField, newField);
								}
							}

							newElement = newTable;

							break;
						}

					case QueryElementType.SqlCteTable:
						{
							var table    = (SqlCteTable)element;
								var cte = (CteClause?)ConvertInternal(table.Cte);

							if (cte != null && !ReferenceEquals(table.Cte, cte))
							{
								var newFields = table.Fields.Select(f => new SqlField(f));
								var newTable  = new SqlCteTable(table, newFields, cte!);

								ReplaceVisited(table.All, newTable.All);
								foreach (var prevField in table.Fields)
								{
									var newField = newTable[prevField.Name];
									if (newField != null)
								{
									ReplaceVisited(prevField, newField);
								}
							}

							newElement = newTable;
						}


							break;
						}

					case QueryElementType.Column:
					{
						break;
					}

					case QueryElementType.TableSource:
						{
							var table  = (SqlTableSource)element;
							var source = (ISqlTableSource?)ConvertInternal(table.Source);
							var joins  = Convert(table.Joins);

							List<ISqlExpression[]>? uk = null;
								if (table.HasUniqueKeys)
									uk = ConvertListArray(table.UniqueKeys, null);

								if (source != null && !ReferenceEquals(source, table.Source) ||
								joins  != null && !ReferenceEquals(table.Joins, joins))
								newElement = new SqlTableSource(
									source ?? table.Source,
									table._alias,
									joins ?? table.Joins,
									uk ?? (table.HasUniqueKeys ? table.UniqueKeys : null));

							break;
						}

					case QueryElementType.JoinedTable:
						{
							var join  = (SqlJoinedTable)element;
							var table = (SqlTableSource?)    ConvertInternal(join.Table    );
							var cond  = (SqlSearchCondition?)ConvertInternal(join.Condition);

							if (table != null && !ReferenceEquals(table, join.Table) ||
								cond  != null && !ReferenceEquals(cond,  join.Condition))
								newElement = new SqlJoinedTable(join.JoinType, table ?? join.Table, join.IsWeak, cond ?? join.Condition);

							break;
						}

					case QueryElementType.SearchCondition:
						{
							var sc    = (SqlSearchCondition)element;
							var conds = Convert(sc.Conditions);

							if (conds != null && !ReferenceEquals(sc.Conditions, conds))
								newElement = new SqlSearchCondition(conds);

							break;
						}

					case QueryElementType.Condition:
						{
							var c = (SqlCondition)element;
							var p = (ISqlPredicate?)ConvertInternal(c.Predicate);

							if (p != null && !ReferenceEquals(c.Predicate, p))
								newElement = new SqlCondition(c.IsNot, p, c.IsOr);

							break;
						}

					case QueryElementType.ExprPredicate:
						{
							var p = (SqlPredicate.Expr)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);

							if (e != null && !ReferenceEquals(p.Expr1, e))
								newElement = new SqlPredicate.Expr(e, p.Precedence);

							break;
						}

					case QueryElementType.NotExprPredicate:
						{
							var p = (SqlPredicate.NotExpr)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);

							if (e != null && !ReferenceEquals(p.Expr1, e))
								newElement = new SqlPredicate.NotExpr(e, p.IsNot, p.Precedence);

							break;
						}

					case QueryElementType.ExprExprPredicate:
						{
							var p  = (SqlPredicate.ExprExpr)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1);
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2);

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) || e2 != null && !ReferenceEquals(p.Expr2, e2))
								newElement = new SqlPredicate.ExprExpr(e1 ?? p.Expr1, p.Operator, e2 ?? p.Expr2, p.WithNull);

							break;
						}

					case QueryElementType.LikePredicate:
						{
							var p  = (SqlPredicate.Like)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1 );
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2 );
							var es = (ISqlExpression?)ConvertInternal(p.Escape);

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) ||
								e2 != null && !ReferenceEquals(p.Expr2, e2) ||
								es != null && !ReferenceEquals(p.Escape, es))
								newElement = new SqlPredicate.Like(e1 ?? p.Expr1, p.IsNot, e2 ?? p.Expr2, es ?? p.Escape);

							break;
						}

					case QueryElementType.SearchStringPredicate:
						{
							var p  = (SqlPredicate.SearchString)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1 );
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2 );

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) ||
								e2 != null && !ReferenceEquals(p.Expr2, e2))
								newElement = new SqlPredicate.SearchString(e1 ?? p.Expr1, p.IsNot, e2 ?? p.Expr2, p.Kind, p.IgnoreCase);

							break;
						}

					case QueryElementType.BetweenPredicate:
						{
							var p = (SqlPredicate.Between)element;
							var e1 = (ISqlExpression?)ConvertInternal(p.Expr1);
							var e2 = (ISqlExpression?)ConvertInternal(p.Expr2);
							var e3 = (ISqlExpression?)ConvertInternal(p.Expr3);

							if (e1 != null && !ReferenceEquals(p.Expr1, e1) ||
								e2 != null && !ReferenceEquals(p.Expr2, e2) ||
								e3 != null && !ReferenceEquals(p.Expr3, e3))
								newElement = new SqlPredicate.Between(e1 ?? p.Expr1, p.IsNot, e2 ?? p.Expr2, e3 ?? p.Expr3);

							break;
						}

					case QueryElementType.IsTruePredicate:
						{
							var p = (SqlPredicate.IsTrue)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);
							var t = (ISqlExpression?)ConvertInternal(p.TrueValue);
							var f = (ISqlExpression?)ConvertInternal(p.FalseValue);

							if (e != null && !ReferenceEquals(p.Expr1, e) ||
							    t != null && !ReferenceEquals(p.TrueValue,  t) ||
								f != null && !ReferenceEquals(p.FalseValue, f)
							    )
								newElement = new SqlPredicate.IsTrue(e ?? p.Expr1, t ?? p.TrueValue, f ?? p.FalseValue, p.WithNull, p.IsNot);

							break;
						}

					case QueryElementType.IsNullPredicate:
						{
							var p = (SqlPredicate.IsNull)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);

							if (e != null && !ReferenceEquals(p.Expr1, e))
								newElement = new SqlPredicate.IsNull(e, p.IsNot);

							break;
						}

					case QueryElementType.InSubQueryPredicate:
						{
							var p = (SqlPredicate.InSubQuery)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);
							var q = (SelectQuery?)   ConvertInternal(p.SubQuery);

							if (e != null && !ReferenceEquals(p.Expr1, e) || q != null && !ReferenceEquals(p.SubQuery, q))
								newElement = new SqlPredicate.InSubQuery(e ?? p.Expr1, p.IsNot, q ?? p.SubQuery);

							break;
						}

					case QueryElementType.InListPredicate:
						{
							var p = (SqlPredicate.InList)element;
							var e = (ISqlExpression?)ConvertInternal(p.Expr1);
							var v = Convert(p.Values);

							if (e != null && !ReferenceEquals(p.Expr1, e) || v != null && !ReferenceEquals(p.Values, v))
								newElement = new SqlPredicate.InList(e ?? p.Expr1, p.WithNull, p.IsNot, v ?? p.Values);

							break;
						}

					case QueryElementType.FuncLikePredicate:
						{
							var p = (SqlPredicate.FuncLike)element;
							var f = (ISqlExpression?)ConvertInternal(p.Function);

							if (f != null && !ReferenceEquals(p.Function, f))
							{
								if (f is SqlFunction function)
									newElement = new SqlPredicate.FuncLike(function);
								else if (f is ISqlPredicate predicate)
									newElement = predicate;
								else
									throw new InvalidCastException("Converted FuncLikePredicate expression is not a Predicate expression.");
							}

							break;
						}

					case QueryElementType.SetExpression:
						{
							var s = (SqlSetExpression)element;
							var c = (ISqlExpression?)ConvertInternal(s.Column    );
							var e = (ISqlExpression?)ConvertInternal(s.Expression);

							if (c != null && !ReferenceEquals(s.Column, c) || e != null && !ReferenceEquals(s.Expression, e))
								newElement = new SqlSetExpression(c ?? s.Column, e ?? s.Expression!);

							break;
						}

					case QueryElementType.InsertClause:
						{
							var s = (SqlInsertClause)element;
							var t = s.Into != null ? (SqlTable?)ConvertInternal(s.Into) : null;
							var i = Convert(s.Items);

							if (t != null && !ReferenceEquals(s.Into, t) || i != null && !ReferenceEquals(s.Items, i))
							{
								var sc = new SqlInsertClause { Into = t ?? s.Into };

								sc.Items.AddRange(i ?? s.Items);
								sc.WithIdentity = s.WithIdentity;

								newElement = sc;
							}

							break;
						}

					case QueryElementType.UpdateClause:
						{
							var s = (SqlUpdateClause)element;
							var t = s.Table != null ? (SqlTable?)ConvertInternal(s.Table) : null;
							var i = Convert(s.Items);
							var k = Convert(s.Keys );

							if (t != null && !ReferenceEquals(s.Table, t) ||
								i != null && !ReferenceEquals(s.Items, i) ||
								k != null && !ReferenceEquals(s.Keys,  k))
							{
								var sc = new SqlUpdateClause { Table = t ?? s.Table };

								sc.Items.AddRange(i ?? s.Items);
								sc.Keys. AddRange(k ?? s.Keys);

								newElement = sc;
							}

							break;
						}

					case QueryElementType.SelectStatement:
						{
							var s = (SqlSelectStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?)ConvertInternal(s.SelectQuery);

							if (selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with))
							{
								newElement = new SqlSelectStatement(selectQuery ?? s.SelectQuery);
								((SqlSelectStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlSelectStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.InsertStatement:
						{
							var s = (SqlInsertStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?    )ConvertInternal(s.SelectQuery);
							var insert      = (SqlInsertClause?)ConvertInternal(s.Insert);
							var output      = s.Output      != null ? (SqlOutputClause?)ConvertInternal(s.Output     ) : null;

							if (insert      != null && !ReferenceEquals(s.Insert,      insert)       ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with)         ||
								output      != null && !ReferenceEquals(s.Output,      output))
							{
								newElement = new SqlInsertStatement(selectQuery ?? s.SelectQuery)
							{
									Insert = insert ?? s.Insert,
									Output = output ?? s.Output,
									With   = with   ?? s.With
								};
								CorrectQueryHierarchy(((SqlInsertStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.UpdateStatement:
						{
							var s = (SqlUpdateStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?    )ConvertInternal(s.SelectQuery);
							var update      = (SqlUpdateClause?)ConvertInternal(s.Update);

							if (update      != null && !ReferenceEquals(s.Update,      update)       ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with))
							{
								newElement = new SqlUpdateStatement(selectQuery ?? s.SelectQuery) { Update = update ?? s.Update };
								((SqlUpdateStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlUpdateStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.InsertOrUpdateStatement:
						{
							var s = (SqlInsertOrUpdateStatement)element;

							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = (SelectQuery?    )ConvertInternal(s.SelectQuery);
							var insert      = (SqlInsertClause?)ConvertInternal(s.Insert);
							var update      = (SqlUpdateClause?)ConvertInternal(s.Update);

							if (insert      != null && !ReferenceEquals(s.Insert,      insert)       ||
								update      != null && !ReferenceEquals(s.Update,      update)       ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery)  ||
								with        != null && !ReferenceEquals(s.With,        with))
							{
								newElement = new SqlInsertOrUpdateStatement(selectQuery ?? s.SelectQuery) { Insert = insert ?? s.Insert, Update = update ?? s.Update };
								((SqlInsertOrUpdateStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlInsertOrUpdateStatement) newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.DeleteStatement:
						{
							var s = (SqlDeleteStatement)element;
							var with        = s.With        != null ? (SqlWithClause?)  ConvertInternal(s.With       ) : null;
							var selectQuery = s.SelectQuery != null ? (SelectQuery?)   ConvertInternal(s.SelectQuery) : null;
							var table       = s.Table       != null ? (SqlTable?)      ConvertInternal(s.Table      ) : null;
							var top         = s.Top         != null ? (ISqlExpression?) ConvertInternal(s.Top        ) : null;
							var output      = s.Output      != null ? (SqlOutputClause?)ConvertInternal(s.Output     ) : null;

							if (table       != null && !ReferenceEquals(s.Table,       table)       ||
								top         != null && !ReferenceEquals(s.Top,         top)         ||
								selectQuery != null && !ReferenceEquals(s.SelectQuery, selectQuery) ||
								with        != null && !ReferenceEquals(s.With,        with)        ||
								output      != null && !ReferenceEquals(s.Output,      output))
							{
								newElement = new SqlDeleteStatement
								{
									Table                = table       ?? s.Table,
									SelectQuery          = selectQuery ?? s.SelectQuery,
									Top                  = top         ?? s.Top!,
									Output               = output      ?? s.Output,
									IsParameterDependent = s.IsParameterDependent
								};
								((SqlDeleteStatement)newElement).With = with ?? s.With;
								CorrectQueryHierarchy(((SqlDeleteStatement)newElement).SelectQuery);
							}

							break;
						}

					case QueryElementType.CreateTableStatement:
						{
							var s  = (SqlCreateTableStatement)element;
							var t  = (SqlTable)ConvertInternal(s.Table);

							if (t != null && !ReferenceEquals(s.Table, t))
							{
								newElement = new SqlCreateTableStatement(t ?? s.Table);
							}

							break;
						}

					case QueryElementType.DropTableStatement:
						{
							var s  = (SqlDropTableStatement)element;
							var t  = (SqlTable)ConvertInternal(s.Table);

							if (!ReferenceEquals(s.Table, t))
							{
								newElement = new SqlDropTableStatement(t);
							}

							break;
						}

					case QueryElementType.SelectClause:
						{
							var sc   = (SqlSelectClause)element;

							List<SqlColumn>? cols = null;

							if (_allowMutation)
							{
								for (int i = 0; i < sc.Columns.Count; i++)
								{
									var column = sc.Columns[i];

									Stack.Add(column);
									var expr = (ISqlExpression)ConvertInternal(column.Expression);
									Stack.RemoveAt(Stack.Count - 1);

									if (!ReferenceEquals(column.Expression, expr))
										column.Expression = expr;
								}
							}
							else
							{
								for (int i = 0; i < sc.Columns.Count; i++)
								{
									var column = sc.Columns[i];

									Stack.Add(column);
									var expr = (ISqlExpression)ConvertInternal(column.Expression);
									Stack.RemoveAt(Stack.Count - 1);

									if (!ReferenceEquals(expr, column.Expression))
									{
										if (cols == null)
										{
											cols = new List<SqlColumn>(sc.Columns.Take(i));
										}

										var newColumn = new SqlColumn(null, expr, column.Alias);
										cols.Add(newColumn);
										AddVisited(column, newColumn);
									}
									else
									{
										cols?.Add(column);
										AddVisited(column, column);
									}
								}
							}

							var take = (ISqlExpression?)ConvertInternal(sc.TakeValue);
							var skip = (ISqlExpression?)ConvertInternal(sc.SkipValue);

							if (
								cols != null && !ReferenceEquals(sc.Columns,   cols) ||
								take != null && !ReferenceEquals(sc.TakeValue, take) ||
								skip != null && !ReferenceEquals(sc.SkipValue, skip))
							{
								newElement = new SqlSelectClause(sc.IsDistinct, take ?? sc.TakeValue, sc.TakeHints, skip ?? sc.SkipValue, cols ?? sc.Columns);
							}

							break;
						}

					case QueryElementType.FromClause:
						{
							var fc   = (SqlFromClause)element;
							var ts = Convert(fc.Tables);

							if (ts != null && !ReferenceEquals(fc.Tables, ts))
							{
								newElement = new SqlFromClause(ts ?? fc.Tables);
								((SqlFromClause)newElement).SetSqlQuery(fc.SelectQuery);
							}

							break;
						}

					case QueryElementType.WhereClause:
						{
							var wc   = (SqlWhereClause)element;
							var cond = (SqlSearchCondition?)ConvertInternal(wc.SearchCondition);

							if (cond != null && !ReferenceEquals(wc.SearchCondition, cond))
							{
								newElement = new SqlWhereClause(cond ?? wc.SearchCondition);
								((SqlWhereClause)newElement).SetSqlQuery(wc.SelectQuery);
							}

							break;
						}

					case QueryElementType.GroupByClause:
						{
							var gc = (SqlGroupByClause)element;
							var es = Convert(gc.Items);

							if (es != null && !ReferenceEquals(gc.Items, es))
							{
								newElement = new SqlGroupByClause(gc.GroupingType, es ?? gc.Items);
								((SqlGroupByClause)newElement).SetSqlQuery(gc.SelectQuery);
							}

							break;
						}

					case QueryElementType.GroupingSet:
						{
							var gc = (SqlGroupingSet)element;
							var es = Convert(gc.Items);

							if (es != null && !ReferenceEquals(gc.Items, es))
							{
								newElement = new SqlGroupingSet(es ?? gc.Items);
							}

							break;
						}

					case QueryElementType.OrderByClause:
						{
							var oc = (SqlOrderByClause)element;
							var es = Convert(oc.Items);

							if (es != null && !ReferenceEquals(oc.Items, es))
							{
								newElement = new SqlOrderByClause(es ?? oc.Items);
								((SqlOrderByClause)newElement).SetSqlQuery(oc.SelectQuery);
							}

							break;
						}

					case QueryElementType.OrderByItem:
						{
							var i = (SqlOrderByItem)element;
							var e = (ISqlExpression?)ConvertInternal(i.Expression);

							if (e != null && !ReferenceEquals(i.Expression, e))
								newElement = new SqlOrderByItem(e, i.IsDescending);

							break;
						}

					case QueryElementType.SetOperator:
						{
							var u = (SqlSetOperator)element;
							var q = (SelectQuery?)ConvertInternal(u.SelectQuery);

							if (q != null && !ReferenceEquals(u.SelectQuery, q))
								newElement = new SqlSetOperator(q, u.Operation);

							break;
						}

					case QueryElementType.SqlQuery:
						{
							var q = (SelectQuery)element;

							var fc = (SqlFromClause?)   ConvertInternal(q.From   ) ?? q.From;
							var sc = (SqlSelectClause?) ConvertInternal(q.Select ) ?? q.Select;
							var wc = (SqlWhereClause?)  ConvertInternal(q.Where  ) ?? q.Where;
							var gc = (SqlGroupByClause?)ConvertInternal(q.GroupBy) ?? q.GroupBy;
							var hc = (SqlWhereClause?)  ConvertInternal(q.Having ) ?? q.Having;
							var oc = (SqlOrderByClause?)ConvertInternal(q.OrderBy) ?? q.OrderBy;
							var us = q.HasSetOperators ? Convert(q.SetOperators) : q.SetOperators;

							List<ISqlExpression[]>? uk = null;
							if (q.HasUniqueKeys)
								uk = ConvertListArray(q.UniqueKeys, null) ?? q.UniqueKeys;

							if (   !ReferenceEquals(fc, q.From)
								|| !ReferenceEquals(sc, q.Select)
								|| !ReferenceEquals(wc, q.Where)
								|| !ReferenceEquals(gc, q.GroupBy)
								|| !ReferenceEquals(hc, q.Having)
								|| !ReferenceEquals(oc, q.OrderBy)
								|| us != null && !ReferenceEquals(us, q.SetOperators)
								|| uk != null && !ReferenceEquals(uk, q.UniqueKeys)
							)
							{
								var nq = new SelectQuery();

								var objTree = new Dictionary<ICloneableElement, ICloneableElement>();

								// try to correct if there q.* in columns expressions
								// TODO: not performant, it is bad that Columns has reference on this select query
								sc = ConvertAll(sc, (v, e) => ReferenceEquals(e, q.All) ? nq.All : e);
								
								if (ReferenceEquals(sc, q.Select))
									sc = new SqlSelectClause(nq, sc, objTree, e => e is SqlColumn c && c.Parent == q);
								
								if (ReferenceEquals(fc, q.From))
									fc = new SqlFromClause   (nq, fc, objTree, e => false);
								if (ReferenceEquals(wc, q.Where))
									wc = new SqlWhereClause  (nq, wc, objTree, e => false);
								if (ReferenceEquals(gc, q.GroupBy))
									gc = new SqlGroupByClause(nq, gc, objTree, e => false);
								if (ReferenceEquals(hc, q.Having))
									hc = new SqlWhereClause  (nq, hc, objTree, e => false);
								if (ReferenceEquals(oc, q.OrderBy))
									oc = new SqlOrderByClause(nq, oc, objTree, e => false);
								if (us == null || ReferenceEquals(us, q.SetOperators))
									us = new List<SqlSetOperator>(us ?? q.SetOperators);

								AddVisited(q.All, nq.All);

								nq.Init(sc, fc, wc, gc, hc, oc, us, uk,
									q.ParentSelect,
									q.IsParameterDependent);

								// update visited in case if columns were cloned
								foreach (var pair in objTree)
								{
									if (pair.Key is IQueryElement queryElement)
										VisitedElements[queryElement] = (IQueryElement)pair.Value;
								}

								newElement = nq;
							}
							break;
						}

					case QueryElementType.MergeStatement:
						{
							var merge = (SqlMergeStatement)element;

							var target     = (SqlTableSource?)     ConvertInternal(merge.Target);
							var source     = (SqlMergeSourceTable?)ConvertInternal(merge.Source);
							var on         = (SqlSearchCondition?) ConvertInternal(merge.On);
							var operations = ConvertSafe(merge.Operations);

							if (target     != null && !ReferenceEquals(merge.Target, target) ||
								source     != null && !ReferenceEquals(merge.Source, source) ||
								on         != null && !ReferenceEquals(merge.On, on) ||
								operations != null && !ReferenceEquals(merge.Operations, operations))
							{
								newElement = new SqlMergeStatement(
									merge.Hint,
									target ?? merge.Target,
									source ?? merge.Source,
									on ?? merge.On,
									operations ?? merge.Operations);
							}

							break;
						}

					case QueryElementType.MergeSourceTable:
						{
							var source = (SqlMergeSourceTable)element;

							var enumerableSource          = (SqlValuesTable?)ConvertInternal(source.SourceEnumerable);
							var querySource               = (SelectQuery?)   ConvertInternal(source.SourceQuery);

							if (enumerableSource != null && !ReferenceEquals(source.SourceEnumerable, enumerableSource) ||
								querySource      != null && !ReferenceEquals(source.SourceQuery, querySource))
							{
								var newFields = source.SourceFields.Select(f => new SqlField(f)).ToArray();
								for (var i = 0; i < source.SourceFields.Count; i++)
								{
									var newField           = newFields[i];
									var oldField           = source.SourceFields[i];
									ReplaceVisited(oldField, newField);
								}

								newElement = new SqlMergeSourceTable(
									source.SourceID,
									enumerableSource ?? source.SourceEnumerable!,
									querySource ?? source.SourceQuery!,
									newFields);

								ReplaceVisited(((ISqlTableSource)source).All, ((ISqlTableSource)newElement).All);
						}

								break;
							}

					case QueryElementType.SqlValuesTable:
						{
							var table = (SqlValuesTable)element;

							List<ISqlExpression[]>? convertedRows = null;
							var rowsConverted = false;

							if (table.Rows != null)
							{
								convertedRows = new List<ISqlExpression[]>();
								foreach (var row in table.Rows)
								{
									var convertedRow = ConvertSafe(row);
									rowsConverted    = rowsConverted || (convertedRow != null && !ReferenceEquals(convertedRow, row));

									convertedRows.Add(convertedRow?.ToArray() ?? row!);
								}
							}

							var fields1 = table.Fields.ToArray();
							var fields2 = Convert(fields1, f => new SqlField(f));

							var fieldsConverted = fields2 != null && !ReferenceEquals(fields1, fields2);

							if (fieldsConverted || rowsConverted)
							{
								if (!fieldsConverted)
								{
									fields2 = fields1;

									for (var i = 0; i < fields2.Length; i++)
									{
										var field = fields2[i];

										fields2[i] = new SqlField(field);

										VisitedElements[field] = fields2[i];
									}
								}

								newElement = new SqlValuesTable(table.Source!, table.ValueBuilders!, fields2!, rowsConverted ? convertedRows : table.Rows);
							}

							break;
						}

					case QueryElementType.OutputClause:
					{
						var output    = (SqlOutputClause)element;
						var outputQ   = output.OutputQuery != null ? ConvertInternal(output.OutputQuery) as SelectQuery : null;

						if (
ConvertInternal(output.SourceTable) is SqlTable sourceT && !ReferenceEquals(output.SourceTable, sourceT)     ||
ConvertInternal(output.InsertedTable) is SqlTable insertedT && !ReferenceEquals(output.InsertedTable, insertedT) ||
ConvertInternal(output.DeletedTable) is SqlTable deletedT && !ReferenceEquals(output.DeletedTable, deletedT)   ||
ConvertInternal(output.OutputTable) is SqlTable outputT && !ReferenceEquals(output.OutputTable, outputT)     ||
							outputQ   != null && !ReferenceEquals(output.OutputQuery, outputQ)
						)
						{
							newElement = new SqlOutputClause
							{
								SourceTable   =  sourceT   ?? output.SourceTable,
								InsertedTable =  insertedT ?? output.InsertedTable,
								DeletedTable  =  deletedT  ?? output.DeletedTable,
								OutputTable   =  outputT   ?? output.OutputTable,
								OutputQuery   =  outputQ   ?? output.OutputQuery,
							};                            
						}
						
						break;
					}

					case QueryElementType.MergeOperationClause:
						{
							var operation = (SqlMergeOperationClause)element;

							var where       = (SqlSearchCondition?)ConvertInternal(operation.Where);
							var whereDelete = (SqlSearchCondition?)ConvertInternal(operation.WhereDelete);
							var items       = ConvertSafe(operation.Items);

							if (where       != null && !ReferenceEquals(operation.Where, where)             ||
								whereDelete != null && !ReferenceEquals(operation.WhereDelete, whereDelete) ||
								items       != null && !ReferenceEquals(operation.Items, items))
							{
								newElement = new SqlMergeOperationClause(
									operation.OperationType,
									where ?? operation.Where,
									whereDelete ?? operation.WhereDelete,
									items ?? operation.Items);
							}

							break;
						}

					case QueryElementType.TruncateTableStatement:
						{
							var truncate = (SqlTruncateTableStatement)element;

							if (truncate.Table != null)
							{
								var table = (SqlTable?)ConvertInternal(truncate.Table);

								if (table != null && !ReferenceEquals(truncate.Table, table))
								{
									newElement = new SqlTruncateTableStatement()
										{
											Table = table,
											ResetIdentity = truncate.ResetIdentity
										};
								}
							}

							break;
						}

					case QueryElementType.SqlRawSqlTable:
						{
							var table   = (SqlRawSqlTable)element;
							var fields1 = table.Fields.ToArray();
							var fields2 = Convert(fields1, f => new SqlField(f));
							var targs   = table.Parameters == null || table.Parameters.Length == 0 ?
								null : Convert(table.Parameters);

							var fe = fields2 != null && !ReferenceEquals(fields1, fields2);
							var ta = targs   != null && !ReferenceEquals(table.Parameters, targs);

							if (fe || ta)
							{
								if (!fe)
								{
									fields2 = fields1;

									for (var i = 0; i < fields2.Length; i++)
									{
										var field = fields2[i];

										fields2[i] = new SqlField(field);

										VisitedElements[field] = fields2[i];
									}
								}

								newElement = new SqlRawSqlTable(table, fields2!, targs ?? table.Parameters!);

								VisitedElements[table.All] = ((SqlRawSqlTable)newElement).All;
							}

							break;
						}

					case QueryElementType.CteClause:
						{
							var cte = (CteClause)element;

							// for avoiding recursion
							if (SecondParentElement?.ElementType != QueryElementType.WithClause)
								break;

							var body   = (SelectQuery?)ConvertInternal(cte.Body);

							if (body   != null && !ReferenceEquals(cte.Body, body))
							{
								var objTree = new Dictionary<ICloneableElement, ICloneableElement>();

								newElement = new CteClause(
									body,
									cte.Fields!.Select(f => (SqlField)f.Clone(objTree, e => true)).ToList(),
											cte.ObjectType,
											cte.IsRecursive,
											cte.Name);

								var correctedBody = Convert(body,
									(v, e) =>
									{
										if (e.ElementType == QueryElementType.CteClause)
										{
											var inner = (CteClause)e;
											if (ReferenceEquals(inner, cte))
												return newElement;
										}	
											
										if (e is ICloneableElement clonable && objTree.TryGetValue(clonable, out var newValue))
											return (IQueryElement)newValue;
										return e;

									});

								// update visited for cloned fields
								foreach (var pair in objTree)
								{
									if (pair.Key is IQueryElement queryElement)
										VisitedElements[queryElement] = (IQueryElement)pair.Value;
								}

								VisitedElements.Remove(element);
								AddVisited(element, newElement);

								((CteClause)newElement).Body = correctedBody;
							}

							break;
						}

					case QueryElementType.WithClause:
						{
							var with = (SqlWithClause)element;

							var clauses = ConvertSafe(with.Clauses);

							if (clauses != null && !ReferenceEquals(with.Clauses, clauses))
							{
								newElement = new SqlWithClause()
								{
									Clauses = clauses
								};

								newElement = new SqlWithClause() { Clauses = clauses };
							}
							break;
						}

					case QueryElementType.SqlField           :
					case QueryElementType.SqlParameter       :
					case QueryElementType.SqlValue           :
					case QueryElementType.SqlDataType        :
					case QueryElementType.SqlAliasPlaceholder:
						break;

					default:
						throw new InvalidOperationException($"Convert visitor not implemented for element {element.ElementType}");
				}
			}
			Stack.RemoveAt(Stack.Count - 1);

			newElement = _convert(this, newElement ?? element);

			if (!_visitAll || !ReferenceEquals(element, newElement))
				AddVisited(element, newElement);

			return newElement;
		}

		T[]? Convert<T>(T[] arr)
			where T : class, IQueryElement
		{
			return Convert(arr, null);
		}

		T[]? Convert<T>(T[] arr1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < arr1.Length; i++)
				{
					var elem = (T?)ConvertInternal(arr1[i]);
					if (elem != null)
						arr1[i] = elem;
				}
				return arr1;
			}

			T[]? arr2 = null;

			for (var i = 0; i < arr1.Length; i++)
			{
				var elem1 = arr1[i];
				var elem2 = (T?)ConvertInternal(elem1);

				if (elem2 != null && !ReferenceEquals(elem1, elem2))
				{
					if (arr2 == null)
					{
						arr2 = new T[arr1.Length];

						for (var j = 0; j < i; j++)
							arr2[j] = clone == null ? arr1[j] : clone(arr1[j]);
					}

					arr2[i] = elem2;
				}
				else if (arr2 != null)
					arr2[i] = clone == null ? elem1 : clone(elem1);
			}

			return arr2;
		}

		List<T>? ConvertSafe<T>(IList<T> list)
			where T : class, IQueryElement
		{
			return ConvertSafe(list, null);
		}

		List<T>? ConvertSafe<T>(IList<T> list1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < list1.Count; i++)
				{
					var elem = (T?)ConvertInternal(list1[i]);
					if (elem != null)
						list1[i] = elem;
				}
				return null;
			}

			List<T>? list2 = null;

			for (var i = 0; i < list1.Count; i++)
			{
				var elem1 = list1[i];

				if (ConvertInternal(elem1) is T elem2 && !ReferenceEquals(elem1, elem2))
				{
					if (list2 == null)
					{
						list2 = new List<T>(list1.Count);

						for (var j = 0; j < i; j++)
							list2.Add(clone == null ? list1[j] : clone(list1[j]));
					}

					list2.Add(elem2);
				}
				else
					list2?.Add(clone == null ? elem1 : clone(elem1));
			}

			return list2;
		}

		List<T>? Convert<T>(List<T> list)
			where T : class, IQueryElement
		{
			return Convert(list, null);
		}

		List<T>? Convert<T>(List<T> list1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < list1.Count; i++)
				{
					var elem = (T?)ConvertInternal(list1[i]);
					if (elem != null)
						list1[i] = elem;
				}
				return list1;
			}

			List<T>? list2 = null;

			for (var i = 0; i < list1.Count; i++)
			{
				var elem1 = list1[i];
				var elem2 = (T?)ConvertInternal(elem1);

				if (elem2 != null && !ReferenceEquals(elem1, elem2))
				{
					if (list2 == null)
					{
						list2 = new List<T>(list1.Count);

						for (var j = 0; j < i; j++)
						{
							var elem = list1[j];
							if (clone != null)
								VisitedElements[elem] = elem = clone(elem);

							list2.Add(elem);
						}
					}

					list2.Add(elem2);
				}
				else if (list2 != null)
				{
					if (clone != null)
						VisitedElements[elem1] = elem1 = clone(elem1);

					list2.Add(elem1);
				}
			}

			return list2;
		}

		List<T[]>? ConvertListArray<T>(List<T[]> list1, Clone<T>? clone)
			where T : class, IQueryElement
		{
			if (_allowMutation)
			{
				for (var i = 0; i < list1.Count; i++)
				{
					var elem = Convert(list1[i]);
					if (elem != null)
						list1[i] = elem;
				}
				return list1;
			}

			List<T[]>? list2 = null;

			for (var i = 0; i < list1.Count; i++)
			{
				var elem1 = list1[i];
				var elem2 = Convert(elem1);

				if (elem2 != null && !ReferenceEquals(elem1, elem2))
				{
					if (list2 == null)
					{
						list2 = new List<T[]>(list1.Count);

						for (var j = 0; j < i; j++)
							list2.Add(clone == null ? list1[j] : list1[j].Select(e => clone(e)).ToArray() );
					}

					list2.Add(elem2);
				}
				else
					list2?.Add(clone == null ? elem1 : elem1.Select(e => clone(e)).ToArray());
			}

			return list2;
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\SqlQuery\ConvertVisitor.cs(1043,26): error CS0165: Use of unassigned local variable 'sourceT',D:\a\1\s\Source\LinqToDB\SqlQuery\ConvertVisitor.cs(1044,26): error CS0165: Use of unassigned local variable 'insertedT',D:\a\1\s\Source\LinqToDB\SqlQuery\ConvertVisitor.cs(1045,26): error CS0165: Use of unassigned local variable 'deletedT',D:\a\1\s\Source\LinqToDB\SqlQuery\ConvertVisitor.cs(1046,26): error CS0165: Use of unassigned local variable 'outputT'
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\SqlQuery\SqlMergeSourceTable.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using LinqToDB.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace LinqToDB.SqlQuery
{
	public class SqlMergeSourceTable : ISqlTableSource
	{
		public SqlMergeSourceTable()
		{
			SourceID = Interlocked.Increment(ref SelectQuery.SourceIDCounter);
		}

		internal SqlMergeSourceTable(
			int id,
			SqlValuesTable sourceEnumerable,
			SelectQuery sourceQuery,
			IEnumerable<SqlField> sourceFields)
		{
			SourceID         = id;
			SourceEnumerable = sourceEnumerable;
			SourceQuery      = sourceQuery;

			foreach (var field in sourceFields)
				AddField(field);
		}

		public string          Name   => "Source";

		public List<SqlField> SourceFields { get; } = new List<SqlField>();

		private void AddField(SqlField field)
		{
			field.Table = this;
			SourceFields.Add(field);
		}

		public SqlValuesTable?  SourceEnumerable { get; internal set; }
		public SelectQuery?     SourceQuery      { get; internal set; }
		public ISqlTableSource  Source => (ISqlTableSource?)SourceQuery ?? SourceEnumerable!;

		public void WalkQueries(Func<SelectQuery, SelectQuery> func)
		{
			if (SourceQuery != null)
				SourceQuery = func(SourceQuery);
		}

		public bool IsParameterDependent
		{
			// enumerable source allways parameter-dependent
			get => SourceQuery?.IsParameterDependent ?? true;
			set
			{
				if (SourceQuery != null)
					SourceQuery.IsParameterDependent = value;
			}
		}

		private readonly IDictionary<SqlField, Tuple<SqlField, int>>       _sourceFieldsByBase       = new Dictionary<SqlField, Tuple<SqlField, int>>();
		private readonly IDictionary<ISqlExpression, Tuple<SqlField, int>> _sourceFieldsByExpression = new Dictionary<ISqlExpression, Tuple<SqlField, int>>();

		internal SqlField RegisterSourceField(ISqlExpression baseExpression, ISqlExpression expression, int index, Func<SqlField> fieldFactory)
		{
			var baseField = baseExpression as SqlField;

			if (baseField != null && _sourceFieldsByBase.TryGetValue(baseField, out var value))
				return value.Item1;

			if (baseField == null && expression != null && _sourceFieldsByExpression.TryGetValue(expression, out value))
				return value.Item1;

			var newField = fieldFactory();

			Utils.MakeUniqueNames(new[] { newField }, _sourceFieldsByExpression.Values.Select(t => t.Item1.Name), f => f.Name, (f, n, a) =>
			{
				f.Name = n;
				f.PhysicalName = n;
			}, f => "source_field");

			SourceFields.Insert(index, newField);

			if (expression != null && !_sourceFieldsByExpression.ContainsKey(expression))
				_sourceFieldsByExpression.Add(expression, Tuple.Create(newField, index));

			if (baseField != null)
				_sourceFieldsByBase.Add(baseField, Tuple.Create(newField, index));

			return newField;
		}

		#region IQueryElement

		QueryElementType IQueryElement.ElementType => QueryElementType.MergeSourceTable;

		public StringBuilder ToString(StringBuilder sb, Dictionary<IQueryElement, IQueryElement> dic)
		{
			return Source.ToString(sb, dic);
		}

		#endregion

		#region ISqlTableSource

		SqlTableType ISqlTableSource.SqlTableType => SqlTableType.MergeSource;

		private SqlField? _all;
		SqlField ISqlTableSource.All => _all ??= SqlField.All(this);


		public int SourceID { get; }

		IList<ISqlExpression> ISqlTableSource.GetKeys(bool allIfEmpty) => throw new NotImplementedException();

		#endregion

		#region ISqlExpressionWalkable

		public ISqlExpression? Walk(WalkOptions options, Func<ISqlExpression, ISqlExpression> func)
		{
			return SourceQuery?.Walk(options, func);
		}

		#endregion

		#region ISqlExpression

		bool ISqlExpression.CanBeNull => throw new NotImplementedException();

		int ISqlExpression.Precedence => throw new NotImplementedException();

		Type ISqlExpression.SystemType => throw new NotImplementedException();

		bool ISqlExpression.Equals(ISqlExpression other, Func<ISqlExpression, ISqlExpression, bool> comparer) => throw new NotImplementedException();
		
		#endregion

		#region ICloneableElement

		ICloneableElement ICloneableElement.Clone(Dictionary<ICloneableElement, ICloneableElement> objectTree, Predicate<ICloneableElement> doClone) => throw new NotImplementedException();

		#endregion

		#region IEquatable

		bool IEquatable<ISqlExpression>.Equals(ISqlExpression? other) => throw new NotImplementedException();

		#endregion

	}
}

---- Transformed Tree ----
using LinqToDB.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace LinqToDB.SqlQuery
{
	public class SqlMergeSourceTable : ISqlTableSource
	{
		public SqlMergeSourceTable()
		{
			SourceID = Interlocked.Increment(ref SelectQuery.SourceIDCounter);
		}

		internal SqlMergeSourceTable(
			int id,
			SqlValuesTable sourceEnumerable,
			SelectQuery sourceQuery,
			IEnumerable<SqlField> sourceFields)
		{
			SourceID         = id;
			SourceEnumerable = sourceEnumerable;
			SourceQuery      = sourceQuery;

			foreach (var field in sourceFields)
				AddField(field);
		}

		public string          Name   => "Source";

		public List<SqlField> SourceFields { get; } = new List<SqlField>();

		private void AddField(SqlField field)
		{
			field.Table = this;
			SourceFields.Add(field);
		}

		public SqlValuesTable?  SourceEnumerable { get; internal set; }
		public SelectQuery?     SourceQuery      { get; internal set; }
		public ISqlTableSource  Source => (ISqlTableSource?)SourceQuery ?? SourceEnumerable!;

		public void WalkQueries(Func<SelectQuery, SelectQuery> func)
		{
			if (SourceQuery != null)
				SourceQuery = func(SourceQuery);
		}

		public bool IsParameterDependent
		{
			// enumerable source allways parameter-dependent
			get => SourceQuery?.IsParameterDependent ?? true;
			set
			{
				if (SourceQuery != null)
					SourceQuery.IsParameterDependent = value;
			}
		}

		private readonly IDictionary<SqlField, Tuple<SqlField, int>>       _sourceFieldsByBase       = new Dictionary<SqlField, Tuple<SqlField, int>>();
		private readonly IDictionary<ISqlExpression, Tuple<SqlField, int>> _sourceFieldsByExpression = new Dictionary<ISqlExpression, Tuple<SqlField, int>>();

		internal SqlField RegisterSourceField(ISqlExpression baseExpression, ISqlExpression expression, int index, Func<SqlField> fieldFactory)
		{
			if (baseExpression is SqlField baseField && _sourceFieldsByBase.TryGetValue(baseField, out var value))
				return value.Item1;

			if (baseField == null && expression != null && _sourceFieldsByExpression.TryGetValue(expression, out value))
				return value.Item1;

			var newField = fieldFactory();

			Utils.MakeUniqueNames(new[] { newField }, _sourceFieldsByExpression.Values.Select(t => t.Item1.Name), f => f.Name, (f, n, a) =>
			{
				f.Name = n;
				f.PhysicalName = n;
			}, f => "source_field");

			SourceFields.Insert(index, newField);

			if (expression != null && !_sourceFieldsByExpression.ContainsKey(expression))
				_sourceFieldsByExpression.Add(expression, Tuple.Create(newField, index));

			if (baseExpression is SqlField baseField)
				_sourceFieldsByBase.Add(baseField, Tuple.Create(newField, index));

			return newField;
		}

		#region IQueryElement

		QueryElementType IQueryElement.ElementType => QueryElementType.MergeSourceTable;

		public StringBuilder ToString(StringBuilder sb, Dictionary<IQueryElement, IQueryElement> dic)
		{
			return Source.ToString(sb, dic);
		}

		#endregion

		#region ISqlTableSource

		SqlTableType ISqlTableSource.SqlTableType => SqlTableType.MergeSource;

		private SqlField? _all;
		SqlField ISqlTableSource.All => _all ??= SqlField.All(this);


		public int SourceID { get; }

		IList<ISqlExpression> ISqlTableSource.GetKeys(bool allIfEmpty) => throw new NotImplementedException();

		#endregion

		#region ISqlExpressionWalkable

		public ISqlExpression? Walk(WalkOptions options, Func<ISqlExpression, ISqlExpression> func)
		{
			return SourceQuery?.Walk(options, func);
		}

		#endregion

		#region ISqlExpression

		bool ISqlExpression.CanBeNull => throw new NotImplementedException();

		int ISqlExpression.Precedence => throw new NotImplementedException();

		Type ISqlExpression.SystemType => throw new NotImplementedException();

		bool ISqlExpression.Equals(ISqlExpression other, Func<ISqlExpression, ISqlExpression, bool> comparer) => throw new NotImplementedException();
		
		#endregion

		#region ICloneableElement

		ICloneableElement ICloneableElement.Clone(Dictionary<ICloneableElement, ICloneableElement> objectTree, Predicate<ICloneableElement> doClone) => throw new NotImplementedException();

		#endregion

		#region IEquatable

		bool IEquatable<ISqlExpression>.Equals(ISqlExpression? other) => throw new NotImplementedException();

		#endregion

	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\SqlQuery\SqlMergeSourceTable.cs(86,35): error CS0128: A local variable or function named 'baseField' is already defined in this scope,D:\a\1\s\Source\LinqToDB\SqlQuery\SqlMergeSourceTable.cs(87,29): warning CS8604: Possible null reference argument for parameter 'key' in 'void IDictionary<SqlField, Tuple<SqlField, int>>.Add(SqlField key, Tuple<SqlField, int> value)'.,D:\a\1\s\Source\LinqToDB\SqlQuery\SqlMergeSourceTable.cs(70,8): error CS0165: Use of unassigned local variable 'baseField'
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using LinqToDB.Mapping;

using JetBrains.Annotations;

namespace LinqToDB
{
	using Common;
	using Expressions;
	using Extensions;
	using SqlQuery;

	[AttributeUsage(AttributeTargets.Parameter)]
	[MeansImplicitUse]
	public class ExprParameterAttribute : Attribute
	{
		public string? Name { get; set; }

		public ExprParameterAttribute(string name)
		{
			Name = name;
		}

		public ExprParameterAttribute()
		{
		}
	}

	public static class ExtensionlBuilderExtensions
	{
		public static Sql.SqlExtensionParam AddParameter(this Sql.ISqExtensionBuilder builder, string name, string value)
		{
			return builder.AddParameter(name, new SqlValue(value));
		}

		public static Sql.SqlExtensionParam AddExpression(this Sql.ISqExtensionBuilder builder, string name, string expr)
		{
			return builder.AddParameter(name, new SqlExpression(expr, Precedence.Primary));
		}

		public static ISqlExpression Add(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right, Type type)
		{
			return new SqlBinaryExpression(type, left, "+", right, Precedence.Additive);
		}
		public static ISqlExpression Add<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right)
		{
			return builder.Add(left, right, typeof(T));
		}

		public static ISqlExpression Add(this Sql.ISqExtensionBuilder builder, ISqlExpression left, int value)
		{
			return builder.Add<int>(left, new SqlValue(value));
		}

		public static ISqlExpression Inc(this Sql.ISqExtensionBuilder builder, ISqlExpression expr)
		{
			return builder.Add(expr, 1);
		}

		public static ISqlExpression Sub(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right, Type type)
		{
			return new SqlBinaryExpression(type, left, "-", right, Precedence.Subtraction);
		}

		public static ISqlExpression Sub<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right)
		{
			return builder.Sub(left, right, typeof(T));
		}

		public static ISqlExpression Sub(this Sql.ISqExtensionBuilder builder, ISqlExpression left, int value)
		{
			return builder.Sub<int>(left, new SqlValue(value));
		}

		public static ISqlExpression Dec(this Sql.ISqExtensionBuilder builder, ISqlExpression expr)
		{
			return builder.Sub(expr, 1);
		}

		public static ISqlExpression Mul(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right, Type type)
		{
			return new SqlBinaryExpression(type, left, "*", right, Precedence.Multiplicative);
		}

		public static ISqlExpression Mul<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right)
		{
			return builder.Mul(left, right, typeof(T));
		}

		public static ISqlExpression Mul(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, int value)
		{
			return builder.Mul<int>(expr1, new SqlValue(value));
		}

		public static ISqlExpression Div(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, ISqlExpression expr2, Type type)
		{
			return new SqlBinaryExpression(type, expr1, "/", expr2, Precedence.Multiplicative);
		}

		public static ISqlExpression Div<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, ISqlExpression expr2)
		{
			return builder.Div(expr1, expr2, typeof(T));
		}

		public static ISqlExpression Div(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, int value)
		{
			return builder.Div<int>(expr1, new SqlValue(value));
		}
	}

	public partial class Sql
	{
		public interface ISqlExtension
		{
		}

		public static ISqlExtension? Ext => null;

		public interface IExtensionCallBuilder
		{
			void Build(ISqExtensionBuilder builder);
		}

		public interface IQueryableContainer
		{
			[EditorBrowsable(EditorBrowsableState.Never)]
			IQueryable Query { get; }
		}

		public interface ISqExtensionBuilder
		{
			string?         Configuration    { get; }
			object?         BuilderValue     { get; }
			IDataContext    DataContext      { get; }
			MappingSchema   Mapping          { get; }
			SelectQuery     Query            { get; }
			MemberInfo      Member           { get; }
			SqlExtension    Extension        { get; }
			ISqlExpression? ResultExpression { get; set; }
			string          Expression       { get; set; }
			Expression[]    Arguments        { get; }

			T GetValue<T>(int index);
			T GetValue<T>(string argName);

			ISqlExpression GetExpression(int index);
			ISqlExpression GetExpression(string argName);
			ISqlExpression ConvertToSqlExpression();
			ISqlExpression ConvertToSqlExpression(int precedence);
			ISqlExpression ConvertExpressionToSql(Expression expression);

			SqlExtensionParam AddParameter(string name, ISqlExpression expr);
		}

		public class SqlExtension
		{
			public Dictionary<string, List<SqlExtensionParam>> NamedParameters { get; }

			public int ChainPrecedence { get; set; }

			public SqlExtension(Type? systemType, string expr, int precedence, int chainPrecedence, 
				bool isAggregate, 
				bool isWindowFunction,
				bool isPure, 
				bool isPredicate,
				bool? canBeNull, 
				params SqlExtensionParam[] parameters)
			{
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));

				foreach (var value in parameters)
					if (value == null) throw new ArgumentNullException(nameof(parameters));

				SystemType       = systemType;
				Expr             = expr;
				Precedence       = precedence;
				ChainPrecedence  = chainPrecedence;
				IsAggregate      = isAggregate;
				IsWindowFunction = isWindowFunction;
				IsPure           = isPure;
				IsPredicate      = isPredicate;
				CanBeNull        = canBeNull;
				NamedParameters  = parameters.ToLookup(p => p.Name ?? string.Empty).ToDictionary(p => p.Key, p => p.ToList());
			}

			public SqlExtension(string expr, params SqlExtensionParam[] parameters)
				: this(null, expr, SqlQuery.Precedence.Unknown, 0, false, false, true, true, false, parameters)
			{
			}

			public Type?  SystemType       { get; set; }
			public string Expr             { get; set; }
			public int    Precedence       { get; set; }
			public bool   IsAggregate      { get; set; }
			public bool   IsWindowFunction { get; set; }
			public bool   IsPure           { get; set; }
			public bool   IsPredicate      { get; set; }
			public bool?  CanBeNull        { get; set; }

			public SqlExtensionParam AddParameter(string name, ISqlExpression sqlExpression)
			{
				return AddParameter(new SqlExtensionParam(name ?? string.Empty, sqlExpression));
			}

			public SqlExtensionParam AddParameter(SqlExtensionParam param)
			{
				var key = param.Name ?? string.Empty;

				if (!NamedParameters.TryGetValue(key, out var list))
				{
					list = new List<SqlExtensionParam>();
					NamedParameters.Add(key, list);
				}

				list.Add(param);
				return param;
			}

			public IEnumerable<SqlExtensionParam> GetParametersByName(string name)
			{
				if (NamedParameters.TryGetValue(name, out var list))
					return list;
				return Enumerable.Empty<SqlExtensionParam>();
			}

			public SqlExtensionParam[] GetParameters()
			{
				return NamedParameters.Values.SelectMany(_ => _).ToArray();
			}
		}

		[DebuggerDisplay("{ToDebugString()}")]
		public class SqlExtensionParam
		{
#if DEBUG
			private static int _paramCounter;
			private readonly int _paramNumber;
			public int ParamNumber => _paramNumber;
#endif

			public SqlExtensionParam(string? name, ISqlExpression expression)
			{
				Name       = name;
				Expression = expression;
#if DEBUG
				_paramNumber = Interlocked.Add(ref _paramCounter, 1);
#endif
			}

			public SqlExtensionParam(string? name, SqlExtension extension)
			{
				Name      = name;
				Extension = extension;
#if DEBUG
				_paramNumber = Interlocked.Add(ref _paramCounter, 1);
#endif
			}

			public string ToDebugString()
			{
				string str;

#if DEBUG
				var paramPrefix = $"Param[{ParamNumber}]";
#else
				var paramPrefix = $"Param";
#endif

				if (Extension != null)
				{
					str = $"{paramPrefix}('{Name ?? ""}', {Extension.ChainPrecedence}): {Extension.Expr}";
				}
				else if (Expression != null)
				{
					var sb = new StringBuilder();
					Expression.ToString(sb, new Dictionary<IQueryElement, IQueryElement>());
					str = $"{paramPrefix}('{Name ?? ""}'): {sb}";
				}
				else
					str = $"{paramPrefix}('{Name ?? ""}')";

				return str;
			}

			public string?         Name       { get; set; }
			public SqlExtension?   Extension  { get; set; }
			public ISqlExpression? Expression { get; set; }
		}

		[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]
		public class ExtensionAttribute : ExpressionAttribute
		{
			private static readonly ConcurrentDictionary<Type, IExtensionCallBuilder> _builders = new ConcurrentDictionary<Type, IExtensionCallBuilder>();

			public string? TokenName { get; set; }

			protected class ExtensionBuilder: ISqExtensionBuilder
			{
				readonly ConvertHelper _convert;

				public ExtensionBuilder(
					string?       configuration,
					object?       builderValue,
					IDataContext  dataContext,
					SelectQuery   query,
					SqlExtension  extension,
					ConvertHelper convertHeper,
					MemberInfo    member,
					Expression[]  arguments)
				{
					Configuration = configuration;
					BuilderValue  = builderValue;
					DataContext   = dataContext  ?? throw new ArgumentNullException(nameof(dataContext));
					Query         = query        ?? throw new ArgumentNullException(nameof(query));
					Extension     = extension    ?? throw new ArgumentNullException(nameof(extension));
					_convert      = convertHeper ?? throw new ArgumentNullException(nameof(convertHeper));
					Member        = member;
					Method        = member as MethodInfo;
					Arguments     = arguments    ?? throw new ArgumentNullException(nameof(arguments));
				}

				public MethodInfo?  Method { get; }

				public ISqlExpression ConvertExpression(Expression expr, ColumnDescriptor? columnDescriptor)
				{
					return _convert.Convert(expr, columnDescriptor);
				}

				#region ISqExtensionBuilder Members

				public string?         Configuration    { get; }
				public object?         BuilderValue     { get; }
				public IDataContext    DataContext      { get; }
				public MappingSchema   Mapping          => DataContext.MappingSchema;
				public SelectQuery     Query            { get; }
				public MemberInfo      Member           { get; }
				public SqlExtension    Extension        { get; }
				public ISqlExpression? ResultExpression { get; set; }
				public Expression[]    Arguments        { get; }

				public string Expression
				{
					get => Extension.Expr;
					set => Extension.Expr = value;
				}

				public T GetValue<T>(int index)
				{
					var lambda = System.Linq.Expressions.Expression.Lambda<Func<T>>(Arguments[index]);
					return lambda.CompileExpression()();
				}

				public T GetValue<T>(string argName)
				{
					if (Method != null)
					{
						var parameters = Method.GetParameters();
						for (int i = 0; i < parameters.Length; i++)
						{
							if (parameters[i].Name == argName)
							{
								return GetValue<T>(i);
							}
						}
					}

					throw new InvalidOperationException(string.Format("Argument '{0}' not found", argName));
				}

				public ISqlExpression GetExpression(int index)
				{
					return ConvertExpression(Arguments[index], null);
				}

				public ISqlExpression GetExpression(string argName)
				{
					if (Method != null)
					{
						var parameters = Method.GetParameters();
						for (int i = 0; i < parameters.Length; i++)
						{
							if (parameters[i].Name == argName)
							{
								return GetExpression(i);
							}
						}
					}

					throw new InvalidOperationException(string.Format("Argument '{0}' not found", argName));
				}

				public ISqlExpression ConvertToSqlExpression()
				{
					return ConvertToSqlExpression(Extension.Precedence);
				}

				public ISqlExpression ConvertToSqlExpression(int precedence)
				{
					return BuildSqlExpression(Extension, Extension.SystemType, precedence,
						(Extension.IsAggregate      ? SqlFlags.IsAggregate      : SqlFlags.None) |
						(Extension.IsPure           ? SqlFlags.IsPure           : SqlFlags.None) |
						(Extension.IsPredicate      ? SqlFlags.IsPredicate      : SqlFlags.None) | 
						(Extension.IsWindowFunction ? SqlFlags.IsWindowFunction : SqlFlags.None), 
						Extension.CanBeNull, IsNullableType.Undefined);
				}

				public ISqlExpression ConvertExpressionToSql(Expression expression)
				{
					return ConvertExpression(expression, null);
				}

				public SqlExtensionParam AddParameter(string name, ISqlExpression expr)
				{
					return Extension.AddParameter(name, expr);
				}

				#endregion

			}

			public Type?     BuilderType     { get; set; }
			public object?   BuilderValue    { get; set; }

			/// <summary>
			/// Defines in which order process extensions. Items will be ordered Descending.
			/// </summary>
			public int       ChainPrecedence { get; set; }

			public ExtensionAttribute(string expression): this(string.Empty, expression)
			{
			}

			public ExtensionAttribute(string configuration, string expression) : base(configuration, expression)
			{
				ExpectExpression = true;
				ServerSideOnly   = true;
				PreferServerSide = true;
				ChainPrecedence  = -1;
			}

			public ExtensionAttribute(Type builderType): this(string.Empty, builderType)
			{
			}

			public ExtensionAttribute(string configuration, Type builderType) : this(configuration, string.Empty)
			{
				BuilderType = builderType;
			}

			static T GetExpressionValue<T>(Expression expr)
			{
				var lambda = System.Linq.Expressions.Expression.Lambda<Func<T>>(expr);
				return lambda.CompileExpression()();
			}

			public static ExtensionAttribute[] GetExtensionAttributes(Expression expression, MappingSchema mapping)
			{
				MemberInfo memberInfo;

				switch (expression.NodeType)
				{
					case ExpressionType.MemberAccess:
						memberInfo = ((MemberExpression) expression).Member;
						break;
					case ExpressionType.Call:
						memberInfo = ((MethodCallExpression) expression).Method;
						break;
					default:
						return Array<ExtensionAttribute>.Empty;
				}

				var attributes =
						mapping.GetAttributes<ExtensionAttribute>(memberInfo.ReflectedType!, memberInfo,
							a => a.Configuration, inherit: true, exactForConfiguration: true);

				if (attributes.Length == 0)
				{
					// notify if there is method that has no defined attribute for specific configuration
					attributes = mapping.GetAttributes<ExtensionAttribute>(memberInfo.ReflectedType!, memberInfo);
					if (attributes.Length > 0)
						throw new LinqToDBException($"Expression {expression}, unsupported for configuration(s) '{string.Join(", ", mapping.ConfigurationList)}'.");
				}

				return attributes;
			}

			public static Expression ExcludeExtensionChain(MappingSchema mapping, Expression expr)
			{
				var current = expr;

				while (true)
				{
					var attributes = GetExtensionAttributes(current, mapping);

					if (attributes.Length == 0)
						break;

					switch (current.NodeType)
					{
						case ExpressionType.MemberAccess :
							{
								var memberExpr = (MemberExpression)current;
								current        = memberExpr.Expression;

								break;
							}

						case ExpressionType.Call :
							{
								var call = (MethodCallExpression) current;

								if (call.Method.IsStatic)
								{
									if (call.Arguments.Count > 0)
										current = call.Arguments[0];
									else
										return current;
								}
								else
									current = call.Object;

								break;
							}
						default:
							{
								return current;
							}
					}
				}

				return current;
			}

			protected List<SqlExtensionParam> BuildFunctionsChain(IDataContext dataContext, SelectQuery query, Expression expr, ConvertHelper convertHelper)
			{
				var chains           = new List<SqlExtensionParam>();
				Expression? current  = expr;

				while (current != null)
				{
					MemberInfo?   memberInfo = null;
					Expression[]? arguments  = null;
					Expression?   next       = null;

					switch (current.NodeType)
					{
						case ExpressionType.MemberAccess :
							{
								var memberExpr = (MemberExpression)current;

								memberInfo = memberExpr.Member;
								arguments  = Array<Expression>.Empty;
								next       = memberExpr.Expression;

								break;
							}

						case ExpressionType.Call :
							{
								var call = (MethodCallExpression) current;

								memberInfo = call.Method;
								arguments  = call.Arguments.ToArray();

								if (call.Method.IsStatic)
									next = call.Arguments.FirstOrDefault();
								else
									next = call.Object;

								break;
							}

						case ExpressionType.Constant:
							{
								if (typeof(IQueryableContainer).IsSameOrParentOf(current.Type))
								{
									next = ((IQueryableContainer)current.EvaluateExpression()!).Query.Expression;
								}
								break;
							}
					}

					if (memberInfo != null)
					{
						var attributes = GetExtensionAttributes(current, dataContext.MappingSchema);
						var continueChain = false;

						foreach (var attr in attributes)
						{
							var param = attr.BuildExtensionParam(dataContext, query, memberInfo, arguments!, convertHelper);
							continueChain = continueChain || !string.IsNullOrEmpty(param.Name) ||
							                param.Extension != null && param.Extension.ChainPrecedence != -1;
							chains.Add(param);
						}

						if (!continueChain)
							break;
					}

					current = next;
				}

				return chains;
			}


			const  string MatchParamPattern = @"{([0-9a-z_A-Z?]*)(,\s'(.*)')?}";
			static Regex  _matchParamRegEx  = new Regex(MatchParamPattern, RegexOptions.Compiled);

			public static string ResolveExpressionValues(string expression, Func<string, string?, string?> valueProvider)
			{
				if (expression    == null) throw new ArgumentNullException(nameof(expression));
				if (valueProvider == null) throw new ArgumentNullException(nameof(valueProvider));

				int  prevMatch         = -1;
				int  prevNotEmptyMatch = -1;
				bool spaceNeeded       = false;

				var str = _matchParamRegEx.Replace(expression, match =>
				{
					var paramName = match.Groups[1].Value;
					var canBeOptional = paramName.EndsWith("?");
					if (canBeOptional)
						paramName = paramName.TrimEnd('?');

					if (paramName == "_")
					{
						spaceNeeded = true;
						prevMatch = match.Index + match.Length;
						return string.Empty;
					}

					var delimiter  = match.Groups[3].Success ? match.Groups[3].Value : null;
					var calculated = valueProvider(paramName, delimiter);

					if (string.IsNullOrEmpty(calculated) && !canBeOptional)
						throw new InvalidOperationException(string.Format("Non optional parameter '{0}' not found", paramName));

					var res = calculated;
					if (spaceNeeded)
					{
						if (!string.IsNullOrEmpty(calculated))
						{
							var e = expression;
							if (prevMatch == match.Index && prevNotEmptyMatch == match.Index - 3 || (prevNotEmptyMatch >= 0 && e[prevNotEmptyMatch] != ' '))
								res = " " + calculated;
						}
						spaceNeeded = false;
					}

					if (!string.IsNullOrEmpty(calculated))
					{
						prevNotEmptyMatch = match.Index + match.Length;
					}

					return res;
				});

				return str;
			}

			SqlExtensionParam BuildExtensionParam(IDataContext dataContext, SelectQuery query, MemberInfo member, Expression[] arguments, ConvertHelper convertHelper)
			{
				var method = member as MethodInfo;
				var type   = member.GetMemberType();
				if (method != null)
					type = method.ReturnType ?? type;
				else if (member is PropertyInfo propertyInfo)
					type = propertyInfo.PropertyType;

				var extension = new SqlExtension(type, Expression!, Precedence, ChainPrecedence, IsAggregate, IsWindowFunction, IsPure, IsPredicate, _canBeNull);

				SqlExtensionParam? result = null;

				if (method != null)
				{
					var parameters = method.GetParameters();

					var genericDefinition        = method.IsGenericMethod ? method.GetGenericMethodDefinition() : method;
					var templateParameters       = genericDefinition.GetParameters();
					var templateGenericArguments = genericDefinition.GetGenericArguments();
					var descriptorMapping        = new Dictionary<Type, ColumnDescriptor?>();
					var genericMapping           = new Dictionary<Type, Type?>();

					for (var i = 0; i < parameters.Length; i++)
					{
						var arg   = arguments[i];
						var param = parameters[i];
						var names = param.GetCustomAttributes(true).OfType<ExprParameterAttribute>()
							.Select(a => a.Name ?? param.Name)
							.Distinct()
							.ToArray()!;

						ColumnDescriptor? descriptor;
						if (names.Length > 0)
						{
							if (method.IsGenericMethod)
							{
								var templateParam  = templateParameters[i];
								var elementType    = templateParam.ParameterType!;
								var argElementType = param.ParameterType;
								if (elementType.IsArray && argElementType.IsArray)
								{
									elementType    = elementType.GetElementType()!;
									argElementType = argElementType.GetElementType()!;
								}
								descriptorMapping.TryGetValue(elementType, out descriptor);

								ISqlExpression[] sqlExpressions;
								if (arg is NewArrayExpression arrayInit)
								{
									sqlExpressions = arrayInit.Expressions.Select(e => convertHelper.Convert(e, descriptor)).ToArray();
								}	
								else
								{
									var sqlExpression = convertHelper.Convert(arg, descriptor);
									sqlExpressions = new[] { sqlExpression };
								}


								if (descriptor == null)
								{
									descriptor = sqlExpressions.Select(e => QueryHelper.GetColumnDescriptor(e)).FirstOrDefault(d => d != null);
									if (descriptor != null)
									{
										foreach (var pair
											in TypeHelper.EnumTypeRemapping(elementType, argElementType, templateGenericArguments))
										{
											if (!descriptorMapping.ContainsKey(pair.Item1))
												descriptorMapping.Add(pair.Item1, descriptor);
										}
									}
								}

								foreach (var name in names)
								{
									foreach (var sqlExpr in sqlExpressions)
									{
										extension.AddParameter(name!, sqlExpr);
									}
								}
							}
							else
							{
								var sqlExpressions = arg is NewArrayExpression arrayInit
									? arrayInit.Expressions.Select(e => convertHelper.Convert(e, null)).ToArray()
									: new[] { convertHelper.Convert(arg, null) };

								foreach (var name in names)
								{
									foreach (var sqlExpr in sqlExpressions)
									{
										extension.AddParameter(name!, sqlExpr);
									}
								}
							}
						}
					}
				}

				if (BuilderType != null)
				{
					var callBuilder = _builders.GetOrAdd(BuilderType, t =>
						{
							if (Activator.CreateInstance(BuilderType)! is IExtensionCallBuilder res)
								return res;

							throw new ArgumentException(
								$"Type '{BuilderType}' does not implement {nameof(IExtensionCallBuilder)} interface.");
						}
					);

					var builder = new ExtensionBuilder(Configuration, BuilderValue, dataContext, query, extension, convertHelper, member, arguments);
					callBuilder.Build(builder);

					result = builder.ResultExpression != null ?
						new SqlExtensionParam(TokenName, builder.ResultExpression) :
						new SqlExtensionParam(TokenName, builder.Extension);
				}

				if (!extension.CanBeNull.HasValue)
					extension.CanBeNull = CalcCanBeNull(IsNullable,
						extension.GetParameters().Select(p => p.Expression?.CanBeNull ?? p.Extension?.CanBeNull ?? true));

				result ??= new SqlExtensionParam(TokenName, extension);

				return result;
			}

			static IEnumerable<Expression> ExtractArray(Expression expression)
			{
				var array = (NewArrayExpression) expression;
				return array.Expressions;
			}

			protected class ConvertHelper
			{
				readonly Func<Expression, ColumnDescriptor?, ISqlExpression> _converter;

				public ConvertHelper(Func<Expression, ColumnDescriptor?, ISqlExpression> converter)
				{
					_converter = converter ?? throw new ArgumentNullException(nameof(converter));
				}

				public ISqlExpression Convert(Expression exp, ColumnDescriptor? descriptor)
				{
					return _converter(exp, descriptor);
				}
			}

			public static SqlExpression BuildSqlExpression(SqlExtension root, Type? systemType, int precedence,
				SqlFlags flags, bool? canBeNull, IsNullableType isNullable)
			{
				var sb             = new StringBuilder();
				var resolvedParams = new Dictionary<SqlExtensionParam, string?>();
				var resolving      = new HashSet<SqlExtensionParam>();
				var newParams      = new List<ISqlExpression>();

				Func<string, string?, string?>? valueProvider = null;
				Stack<SqlExtension> current                   = new Stack<SqlExtension>();

				valueProvider = (name, delimiter) =>
				{
					var found = root.GetParametersByName(name);
					if (current.Count != 0)
						found = current.Peek().GetParametersByName(name).Concat(found);
					string? result = null;
					foreach (var p in found)
					{
						if (resolvedParams.TryGetValue(p, out var paramValue))
						{
							result = paramValue;
						}
						else
						{
							if (resolving.Contains(p))
								throw new InvalidOperationException("Circular reference");

							resolving.Add(p);
							var ext = p.Extension;
							if (ext != null)
							{
								current.Push(ext);
								paramValue = ResolveExpressionValues(ext.Expr, valueProvider!);
								current.Pop();
							}
							else
							{
								sb.Length = 0;
								if (p.Expression != null)
								{
									paramValue = string.Format("{{{0}}}", newParams.Count);
									newParams.Add(p.Expression);
								}
							}

							resolvedParams.Add(p, paramValue);

							if (string.IsNullOrEmpty(paramValue))
								continue;

							if (!string.IsNullOrEmpty(result))
								result += delimiter;
							result += paramValue;
						}

						if (delimiter == null && !string.IsNullOrEmpty(result))
							break;
					}

					return result;
				};

				var expr          = ResolveExpressionValues(root.Expr, valueProvider);
				var sqlExpression = new SqlExpression(systemType, expr, precedence, flags, newParams.ToArray());
				if (!canBeNull.HasValue)
					canBeNull = root.CanBeNull;

				if (!canBeNull.HasValue)
					canBeNull = CalcCanBeNull(isNullable, sqlExpression.Parameters.Select(p => p.CanBeNull));

				if (canBeNull.HasValue)
					sqlExpression.CanBeNull = canBeNull.Value;

				return sqlExpression;
			}

			public override ISqlExpression GetExpression(IDataContext dataContext, SelectQuery query, Expression expression, Func<Expression, ColumnDescriptor?, ISqlExpression> converter)
			{
				var helper = new ConvertHelper(converter);

				// chain starts from the tail
				var chain  = BuildFunctionsChain(dataContext, query, expression, helper);

				if (chain.Count == 0)
					throw new InvalidOperationException("No sequence found for expression '{expression}'");

				var ordered = chain
					.Select((c, i) => Tuple.Create(c, i))
					.OrderByDescending(t => t.Item1.Extension?.ChainPrecedence ?? int.MinValue)
					.ThenByDescending(t => t.Item2)
					.Select(t => t.Item1)
					.ToArray();

				var main    = ordered.FirstOrDefault(c => c.Extension != null);

				if (main == null)
				{
					var replaced = chain.Where(c => c.Expression != null).ToArray();
					if (replaced.Length == 0)
						throw new InvalidOperationException($"Can not find root sequence for expression '{expression}'");
					else if (replaced.Length > 1)
						throw new InvalidOperationException($"Multiple root sequences found for expression '{expression}'");

					return replaced[0].Expression!;
				}

				var mainExtension = main.Extension!;

				// suggesting type
				var type = ordered
					.Select(c => c.Extension?.SystemType)
					.FirstOrDefault(t => t != null && dataContext.MappingSchema.IsScalarType(t));

				if (type == null)
					type = ordered
						.Select(c => c.Expression?.SystemType)
						.FirstOrDefault(t => t != null && dataContext.MappingSchema.IsScalarType(t));

				mainExtension.SystemType = type ?? expression.Type;

				// calculating that extension is aggregate
				var isAggregate  = ordered.Any(c => c.Extension?.IsAggregate == true);
				var isPure       = ordered.All(c => c.Extension?.IsPure != false);
				var isWindowFunc = ordered.Any(c => c.Extension?.IsWindowFunction == true);
				var isPredicate  = mainExtension.IsPredicate;

				// calculating replacements
				var replacementMap = ordered
					.Where(c => c.Extension != mainExtension)
					.Select((c, i) => Tuple.Create(c, i))
					.GroupBy(e => e.Item1.Name ?? "")
					.Select(g => new
					{
						Name = g.Key,
						UnderName = g
							.OrderByDescending(e => e.Item1.Extension?.ChainPrecedence ?? int.MinValue)
							.ThenBy(e => e.Item2)
							.Select(e => e.Item1)
							.ToArray()
					})
					.ToArray();

				foreach (var c in replacementMap)
				{
					var first = c.UnderName[0];
					if (c.Name == "" || first.Extension == null)
					{
						for (var i = 0; i < c.UnderName.Length; i++)
						{
							var e = c.UnderName[i];
							mainExtension.AddParameter(e);
						}
					}	
					else
					{
						var firstPrecedence = first.Extension.ChainPrecedence;
						mainExtension.AddParameter(first);
						// append all replaced under superior
						for (int i = 1; i < c.UnderName.Length; i++)
						{
							var item = c.UnderName[i];
							if (firstPrecedence > (item.Extension?.ChainPrecedence ?? int.MinValue))
								first.Extension.AddParameter(item);
							else
								mainExtension.AddParameter(item);
						}
					}
				}

				//TODO: Precedence calculation
				var res = BuildSqlExpression(mainExtension, mainExtension.SystemType, 
					mainExtension.Precedence,
					(isAggregate  ? SqlFlags.IsAggregate      : SqlFlags.None) |
					(isPure       ? SqlFlags.IsPure           : SqlFlags.None) |
					(isPredicate  ? SqlFlags.IsPredicate      : SqlFlags.None) |
					(isWindowFunc ? SqlFlags.IsWindowFunction : SqlFlags.None),
					mainExtension.CanBeNull, IsNullable);

				return res;
			}
		}
	}
}

---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using LinqToDB.Mapping;

using JetBrains.Annotations;

namespace LinqToDB
{
	using Common;
	using Expressions;
	using Extensions;
	using SqlQuery;

	[AttributeUsage(AttributeTargets.Parameter)]
	[MeansImplicitUse]
	public class ExprParameterAttribute : Attribute
	{
		public string? Name { get; set; }

		public ExprParameterAttribute(string name)
		{
			Name = name;
		}

		public ExprParameterAttribute()
		{
		}
	}

	public static class ExtensionlBuilderExtensions
	{
		public static Sql.SqlExtensionParam AddParameter(this Sql.ISqExtensionBuilder builder, string name, string value)
		{
			return builder.AddParameter(name, new SqlValue(value));
		}

		public static Sql.SqlExtensionParam AddExpression(this Sql.ISqExtensionBuilder builder, string name, string expr)
		{
			return builder.AddParameter(name, new SqlExpression(expr, Precedence.Primary));
		}

		public static ISqlExpression Add(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right, Type type)
		{
			return new SqlBinaryExpression(type, left, "+", right, Precedence.Additive);
		}
		public static ISqlExpression Add<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right)
		{
			return builder.Add(left, right, typeof(T));
		}

		public static ISqlExpression Add(this Sql.ISqExtensionBuilder builder, ISqlExpression left, int value)
		{
			return builder.Add<int>(left, new SqlValue(value));
		}

		public static ISqlExpression Inc(this Sql.ISqExtensionBuilder builder, ISqlExpression expr)
		{
			return builder.Add(expr, 1);
		}

		public static ISqlExpression Sub(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right, Type type)
		{
			return new SqlBinaryExpression(type, left, "-", right, Precedence.Subtraction);
		}

		public static ISqlExpression Sub<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right)
		{
			return builder.Sub(left, right, typeof(T));
		}

		public static ISqlExpression Sub(this Sql.ISqExtensionBuilder builder, ISqlExpression left, int value)
		{
			return builder.Sub<int>(left, new SqlValue(value));
		}

		public static ISqlExpression Dec(this Sql.ISqExtensionBuilder builder, ISqlExpression expr)
		{
			return builder.Sub(expr, 1);
		}

		public static ISqlExpression Mul(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right, Type type)
		{
			return new SqlBinaryExpression(type, left, "*", right, Precedence.Multiplicative);
		}

		public static ISqlExpression Mul<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression left, ISqlExpression right)
		{
			return builder.Mul(left, right, typeof(T));
		}

		public static ISqlExpression Mul(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, int value)
		{
			return builder.Mul<int>(expr1, new SqlValue(value));
		}

		public static ISqlExpression Div(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, ISqlExpression expr2, Type type)
		{
			return new SqlBinaryExpression(type, expr1, "/", expr2, Precedence.Multiplicative);
		}

		public static ISqlExpression Div<T>(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, ISqlExpression expr2)
		{
			return builder.Div(expr1, expr2, typeof(T));
		}

		public static ISqlExpression Div(this Sql.ISqExtensionBuilder builder, ISqlExpression expr1, int value)
		{
			return builder.Div<int>(expr1, new SqlValue(value));
		}
	}

	public partial class Sql
	{
		public interface ISqlExtension
		{
		}

		public static ISqlExtension? Ext => null;

		public interface IExtensionCallBuilder
		{
			void Build(ISqExtensionBuilder builder);
		}

		public interface IQueryableContainer
		{
			[EditorBrowsable(EditorBrowsableState.Never)]
			IQueryable Query { get; }
		}

		public interface ISqExtensionBuilder
		{
			string?         Configuration    { get; }
			object?         BuilderValue     { get; }
			IDataContext    DataContext      { get; }
			MappingSchema   Mapping          { get; }
			SelectQuery     Query            { get; }
			MemberInfo      Member           { get; }
			SqlExtension    Extension        { get; }
			ISqlExpression? ResultExpression { get; set; }
			string          Expression       { get; set; }
			Expression[]    Arguments        { get; }

			T GetValue<T>(int index);
			T GetValue<T>(string argName);

			ISqlExpression GetExpression(int index);
			ISqlExpression GetExpression(string argName);
			ISqlExpression ConvertToSqlExpression();
			ISqlExpression ConvertToSqlExpression(int precedence);
			ISqlExpression ConvertExpressionToSql(Expression expression);

			SqlExtensionParam AddParameter(string name, ISqlExpression expr);
		}

		public class SqlExtension
		{
			public Dictionary<string, List<SqlExtensionParam>> NamedParameters { get; }

			public int ChainPrecedence { get; set; }

			public SqlExtension(Type? systemType, string expr, int precedence, int chainPrecedence, 
				bool isAggregate, 
				bool isWindowFunction,
				bool isPure, 
				bool isPredicate,
				bool? canBeNull, 
				params SqlExtensionParam[] parameters)
			{
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));

				foreach (var value in parameters)
					if (value == null) throw new ArgumentNullException(nameof(parameters));

				SystemType       = systemType;
				Expr             = expr;
				Precedence       = precedence;
				ChainPrecedence  = chainPrecedence;
				IsAggregate      = isAggregate;
				IsWindowFunction = isWindowFunction;
				IsPure           = isPure;
				IsPredicate      = isPredicate;
				CanBeNull        = canBeNull;
				NamedParameters  = parameters.ToLookup(p => p.Name ?? string.Empty).ToDictionary(p => p.Key, p => p.ToList());
			}

			public SqlExtension(string expr, params SqlExtensionParam[] parameters)
				: this(null, expr, SqlQuery.Precedence.Unknown, 0, false, false, true, true, false, parameters)
			{
			}

			public Type?  SystemType       { get; set; }
			public string Expr             { get; set; }
			public int    Precedence       { get; set; }
			public bool   IsAggregate      { get; set; }
			public bool   IsWindowFunction { get; set; }
			public bool   IsPure           { get; set; }
			public bool   IsPredicate      { get; set; }
			public bool?  CanBeNull        { get; set; }

			public SqlExtensionParam AddParameter(string name, ISqlExpression sqlExpression)
			{
				return AddParameter(new SqlExtensionParam(name ?? string.Empty, sqlExpression));
			}

			public SqlExtensionParam AddParameter(SqlExtensionParam param)
			{
				var key = param.Name ?? string.Empty;

				if (!NamedParameters.TryGetValue(key, out var list))
				{
					list = new List<SqlExtensionParam>();
					NamedParameters.Add(key, list);
				}

				list.Add(param);
				return param;
			}

			public IEnumerable<SqlExtensionParam> GetParametersByName(string name)
			{
				if (NamedParameters.TryGetValue(name, out var list))
					return list;
				return Enumerable.Empty<SqlExtensionParam>();
			}

			public SqlExtensionParam[] GetParameters()
			{
				return NamedParameters.Values.SelectMany(_ => _).ToArray();
			}
		}

		[DebuggerDisplay("{ToDebugString()}")]
		public class SqlExtensionParam
		{
#if DEBUG
			private static int _paramCounter;
			private readonly int _paramNumber;
			public int ParamNumber => _paramNumber;
#endif

			public SqlExtensionParam(string? name, ISqlExpression expression)
			{
				Name       = name;
				Expression = expression;
#if DEBUG
				_paramNumber = Interlocked.Add(ref _paramCounter, 1);
#endif
			}

			public SqlExtensionParam(string? name, SqlExtension extension)
			{
				Name      = name;
				Extension = extension;
#if DEBUG
				_paramNumber = Interlocked.Add(ref _paramCounter, 1);
#endif
			}

			public string ToDebugString()
			{
				string str;

#if DEBUG
				var paramPrefix = $"Param[{ParamNumber}]";
#else
				var paramPrefix = $"Param";
#endif

				if (Extension != null)
				{
					str = $"{paramPrefix}('{Name ?? ""}', {Extension.ChainPrecedence}): {Extension.Expr}";
				}
				else if (Expression != null)
				{
					var sb = new StringBuilder();
					Expression.ToString(sb, new Dictionary<IQueryElement, IQueryElement>());
					str = $"{paramPrefix}('{Name ?? ""}'): {sb}";
				}
				else
					str = $"{paramPrefix}('{Name ?? ""}')";

				return str;
			}

			public string?         Name       { get; set; }
			public SqlExtension?   Extension  { get; set; }
			public ISqlExpression? Expression { get; set; }
		}

		[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]
		public class ExtensionAttribute : ExpressionAttribute
		{
			private static readonly ConcurrentDictionary<Type, IExtensionCallBuilder> _builders = new ConcurrentDictionary<Type, IExtensionCallBuilder>();

			public string? TokenName { get; set; }

			protected class ExtensionBuilder: ISqExtensionBuilder
			{
				readonly ConvertHelper _convert;

				public ExtensionBuilder(
					string?       configuration,
					object?       builderValue,
					IDataContext  dataContext,
					SelectQuery   query,
					SqlExtension  extension,
					ConvertHelper convertHeper,
					MemberInfo    member,
					Expression[]  arguments)
				{
					Configuration = configuration;
					BuilderValue  = builderValue;
					DataContext   = dataContext  ?? throw new ArgumentNullException(nameof(dataContext));
					Query         = query        ?? throw new ArgumentNullException(nameof(query));
					Extension     = extension    ?? throw new ArgumentNullException(nameof(extension));
					_convert      = convertHeper ?? throw new ArgumentNullException(nameof(convertHeper));
					Member        = member;
					Method        = member as MethodInfo;
					Arguments     = arguments    ?? throw new ArgumentNullException(nameof(arguments));
				}

				public MethodInfo?  Method { get; }

				public ISqlExpression ConvertExpression(Expression expr, ColumnDescriptor? columnDescriptor)
				{
					return _convert.Convert(expr, columnDescriptor);
				}

				#region ISqExtensionBuilder Members

				public string?         Configuration    { get; }
				public object?         BuilderValue     { get; }
				public IDataContext    DataContext      { get; }
				public MappingSchema   Mapping          => DataContext.MappingSchema;
				public SelectQuery     Query            { get; }
				public MemberInfo      Member           { get; }
				public SqlExtension    Extension        { get; }
				public ISqlExpression? ResultExpression { get; set; }
				public Expression[]    Arguments        { get; }

				public string Expression
				{
					get => Extension.Expr;
					set => Extension.Expr = value;
				}

				public T GetValue<T>(int index)
				{
					var lambda = System.Linq.Expressions.Expression.Lambda<Func<T>>(Arguments[index]);
					return lambda.CompileExpression()();
				}

				public T GetValue<T>(string argName)
				{
					if (Method != null)
					{
						var parameters = Method.GetParameters();
						for (int i = 0; i < parameters.Length; i++)
						{
							if (parameters[i].Name == argName)
							{
								return GetValue<T>(i);
							}
						}
					}

					throw new InvalidOperationException(string.Format("Argument '{0}' not found", argName));
				}

				public ISqlExpression GetExpression(int index)
				{
					return ConvertExpression(Arguments[index], null);
				}

				public ISqlExpression GetExpression(string argName)
				{
					if (Method != null)
					{
						var parameters = Method.GetParameters();
						for (int i = 0; i < parameters.Length; i++)
						{
							if (parameters[i].Name == argName)
							{
								return GetExpression(i);
							}
						}
					}

					throw new InvalidOperationException(string.Format("Argument '{0}' not found", argName));
				}

				public ISqlExpression ConvertToSqlExpression()
				{
					return ConvertToSqlExpression(Extension.Precedence);
				}

				public ISqlExpression ConvertToSqlExpression(int precedence)
				{
					return BuildSqlExpression(Extension, Extension.SystemType, precedence,
						(Extension.IsAggregate      ? SqlFlags.IsAggregate      : SqlFlags.None) |
						(Extension.IsPure           ? SqlFlags.IsPure           : SqlFlags.None) |
						(Extension.IsPredicate      ? SqlFlags.IsPredicate      : SqlFlags.None) | 
						(Extension.IsWindowFunction ? SqlFlags.IsWindowFunction : SqlFlags.None), 
						Extension.CanBeNull, IsNullableType.Undefined);
				}

				public ISqlExpression ConvertExpressionToSql(Expression expression)
				{
					return ConvertExpression(expression, null);
				}

				public SqlExtensionParam AddParameter(string name, ISqlExpression expr)
				{
					return Extension.AddParameter(name, expr);
				}

				#endregion

			}

			public Type?     BuilderType     { get; set; }
			public object?   BuilderValue    { get; set; }

			/// <summary>
			/// Defines in which order process extensions. Items will be ordered Descending.
			/// </summary>
			public int       ChainPrecedence { get; set; }

			public ExtensionAttribute(string expression): this(string.Empty, expression)
			{
			}

			public ExtensionAttribute(string configuration, string expression) : base(configuration, expression)
			{
				ExpectExpression = true;
				ServerSideOnly   = true;
				PreferServerSide = true;
				ChainPrecedence  = -1;
			}

			public ExtensionAttribute(Type builderType): this(string.Empty, builderType)
			{
			}

			public ExtensionAttribute(string configuration, Type builderType) : this(configuration, string.Empty)
			{
				BuilderType = builderType;
			}

			static T GetExpressionValue<T>(Expression expr)
			{
				var lambda = System.Linq.Expressions.Expression.Lambda<Func<T>>(expr);
				return lambda.CompileExpression()();
			}

			public static ExtensionAttribute[] GetExtensionAttributes(Expression expression, MappingSchema mapping)
			{
				MemberInfo memberInfo;

				switch (expression.NodeType)
				{
					case ExpressionType.MemberAccess:
						memberInfo = ((MemberExpression) expression).Member;
						break;
					case ExpressionType.Call:
						memberInfo = ((MethodCallExpression) expression).Method;
						break;
					default:
						return Array<ExtensionAttribute>.Empty;
				}

				var attributes =
						mapping.GetAttributes<ExtensionAttribute>(memberInfo.ReflectedType!, memberInfo,
							a => a.Configuration, inherit: true, exactForConfiguration: true);

				if (attributes.Length == 0)
				{
					// notify if there is method that has no defined attribute for specific configuration
					attributes = mapping.GetAttributes<ExtensionAttribute>(memberInfo.ReflectedType!, memberInfo);
					if (attributes.Length > 0)
						throw new LinqToDBException($"Expression {expression}, unsupported for configuration(s) '{string.Join(", ", mapping.ConfigurationList)}'.");
				}

				return attributes;
			}

			public static Expression ExcludeExtensionChain(MappingSchema mapping, Expression expr)
			{
				var current = expr;

				while (true)
				{
					var attributes = GetExtensionAttributes(current, mapping);

					if (attributes.Length == 0)
						break;

					switch (current.NodeType)
					{
						case ExpressionType.MemberAccess :
							{
								var memberExpr = (MemberExpression)current;
								current        = memberExpr.Expression;

								break;
							}

						case ExpressionType.Call :
							{
								var call = (MethodCallExpression) current;

								if (call.Method.IsStatic)
								{
									if (call.Arguments.Count > 0)
										current = call.Arguments[0];
									else
										return current;
								}
								else
									current = call.Object;

								break;
							}
						default:
							{
								return current;
							}
					}
				}

				return current;
			}

			protected List<SqlExtensionParam> BuildFunctionsChain(IDataContext dataContext, SelectQuery query, Expression expr, ConvertHelper convertHelper)
			{
				var chains           = new List<SqlExtensionParam>();
				Expression? current  = expr;

				while (current != null)
				{
					MemberInfo?   memberInfo = null;
					Expression[]? arguments  = null;
					Expression?   next       = null;

					switch (current.NodeType)
					{
						case ExpressionType.MemberAccess :
							{
								var memberExpr = (MemberExpression)current;

								memberInfo = memberExpr.Member;
								arguments  = Array<Expression>.Empty;
								next       = memberExpr.Expression;

								break;
							}

						case ExpressionType.Call :
							{
								var call = (MethodCallExpression) current;

								memberInfo = call.Method;
								arguments  = call.Arguments.ToArray();

								if (call.Method.IsStatic)
									next = call.Arguments.FirstOrDefault();
								else
									next = call.Object;

								break;
							}

						case ExpressionType.Constant:
							{
								if (typeof(IQueryableContainer).IsSameOrParentOf(current.Type))
								{
									next = ((IQueryableContainer)current.EvaluateExpression()!).Query.Expression;
								}
								break;
							}
					}

					if (memberInfo != null)
					{
						var attributes = GetExtensionAttributes(current, dataContext.MappingSchema);
						var continueChain = false;

						foreach (var attr in attributes)
						{
							var param = attr.BuildExtensionParam(dataContext, query, memberInfo, arguments!, convertHelper);
							continueChain = continueChain || !string.IsNullOrEmpty(param.Name) ||
							                param.Extension != null && param.Extension.ChainPrecedence != -1;
							chains.Add(param);
						}

						if (!continueChain)
							break;
					}

					current = next;
				}

				return chains;
			}


			const  string MatchParamPattern = @"{([0-9a-z_A-Z?]*)(,\s'(.*)')?}";
			static Regex  _matchParamRegEx  = new Regex(MatchParamPattern, RegexOptions.Compiled);

			public static string ResolveExpressionValues(string expression, Func<string, string?, string?> valueProvider)
			{
				if (expression    == null) throw new ArgumentNullException(nameof(expression));
				if (valueProvider == null) throw new ArgumentNullException(nameof(valueProvider));

				int  prevMatch         = -1;
				int  prevNotEmptyMatch = -1;
				bool spaceNeeded       = false;

				var str = _matchParamRegEx.Replace(expression, match =>
				{
					var paramName = match.Groups[1].Value;
					var canBeOptional = paramName.EndsWith("?");
					if (canBeOptional)
						paramName = paramName.TrimEnd('?');

					if (paramName == "_")
					{
						spaceNeeded = true;
						prevMatch = match.Index + match.Length;
						return string.Empty;
					}

					var delimiter  = match.Groups[3].Success ? match.Groups[3].Value : null;
					var calculated = valueProvider(paramName, delimiter);

					if (string.IsNullOrEmpty(calculated) && !canBeOptional)
						throw new InvalidOperationException(string.Format("Non optional parameter '{0}' not found", paramName));

					var res = calculated;
					if (spaceNeeded)
					{
						if (!string.IsNullOrEmpty(calculated))
						{
							var e = expression;
							if (prevMatch == match.Index && prevNotEmptyMatch == match.Index - 3 || (prevNotEmptyMatch >= 0 && e[prevNotEmptyMatch] != ' '))
								res = " " + calculated;
						}
						spaceNeeded = false;
					}

					if (!string.IsNullOrEmpty(calculated))
					{
						prevNotEmptyMatch = match.Index + match.Length;
					}

					return res;
				});

				return str;
			}

			SqlExtensionParam BuildExtensionParam(IDataContext dataContext, SelectQuery query, MemberInfo member, Expression[] arguments, ConvertHelper convertHelper)
			{
				var type   = member.GetMemberType();

				if (member is MethodInfo method)
					type = method.ReturnType ?? type;
				else if (member is PropertyInfo propertyInfo)
					type = propertyInfo.PropertyType;

				var extension = new SqlExtension(type, Expression!, Precedence, ChainPrecedence, IsAggregate, IsWindowFunction, IsPure, IsPredicate, _canBeNull);

				SqlExtensionParam? result = null;

				if (member is MethodInfo method)
				{
					var parameters = method.GetParameters();

					var genericDefinition        = method.IsGenericMethod ? method.GetGenericMethodDefinition() : method;
					var templateParameters       = genericDefinition.GetParameters();
					var templateGenericArguments = genericDefinition.GetGenericArguments();
					var descriptorMapping        = new Dictionary<Type, ColumnDescriptor?>();
					var genericMapping           = new Dictionary<Type, Type?>();

					for (var i = 0; i < parameters.Length; i++)
					{
						var arg   = arguments[i];
						var param = parameters[i];
						var names = param.GetCustomAttributes(true).OfType<ExprParameterAttribute>()
							.Select(a => a.Name ?? param.Name)
							.Distinct()
							.ToArray()!;

						ColumnDescriptor? descriptor;
						if (names.Length > 0)
						{
							if (method.IsGenericMethod)
							{
								var templateParam  = templateParameters[i];
								var elementType    = templateParam.ParameterType!;
								var argElementType = param.ParameterType;
								if (elementType.IsArray && argElementType.IsArray)
								{
									elementType    = elementType.GetElementType()!;
									argElementType = argElementType.GetElementType()!;
								}
								descriptorMapping.TryGetValue(elementType, out descriptor);

								ISqlExpression[] sqlExpressions;
								if (arg is NewArrayExpression arrayInit)
								{
									sqlExpressions = arrayInit.Expressions.Select(e => convertHelper.Convert(e, descriptor)).ToArray();
								}	
								else
								{
									var sqlExpression = convertHelper.Convert(arg, descriptor);
									sqlExpressions = new[] { sqlExpression };
								}


								if (descriptor == null)
								{
									descriptor = sqlExpressions.Select(e => QueryHelper.GetColumnDescriptor(e)).FirstOrDefault(d => d != null);
									if (descriptor != null)
									{
										foreach (var pair
											in TypeHelper.EnumTypeRemapping(elementType, argElementType, templateGenericArguments))
										{
											if (!descriptorMapping.ContainsKey(pair.Item1))
												descriptorMapping.Add(pair.Item1, descriptor);
										}
									}
								}

								foreach (var name in names)
								{
									foreach (var sqlExpr in sqlExpressions)
									{
										extension.AddParameter(name!, sqlExpr);
									}
								}
							}
							else
							{
								var sqlExpressions = arg is NewArrayExpression arrayInit
									? arrayInit.Expressions.Select(e => convertHelper.Convert(e, null)).ToArray()
									: new[] { convertHelper.Convert(arg, null) };

								foreach (var name in names)
								{
									foreach (var sqlExpr in sqlExpressions)
									{
										extension.AddParameter(name!, sqlExpr);
									}
								}
							}
						}
					}
				}

				if (BuilderType != null)
				{
					var callBuilder = _builders.GetOrAdd(BuilderType, t =>
						{
							if (Activator.CreateInstance(BuilderType)! is IExtensionCallBuilder res)
								return res;

							throw new ArgumentException(
								$"Type '{BuilderType}' does not implement {nameof(IExtensionCallBuilder)} interface.");
						}
					);

					var builder = new ExtensionBuilder(Configuration, BuilderValue, dataContext, query, extension, convertHelper, member, arguments);
					callBuilder.Build(builder);

					result = builder.ResultExpression != null ?
						new SqlExtensionParam(TokenName, builder.ResultExpression) :
						new SqlExtensionParam(TokenName, builder.Extension);
				}

				if (!extension.CanBeNull.HasValue)
					extension.CanBeNull = CalcCanBeNull(IsNullable,
						extension.GetParameters().Select(p => p.Expression?.CanBeNull ?? p.Extension?.CanBeNull ?? true));

				result ??= new SqlExtensionParam(TokenName, extension);

				return result;
			}

			static IEnumerable<Expression> ExtractArray(Expression expression)
			{
				var array = (NewArrayExpression) expression;
				return array.Expressions;
			}

			protected class ConvertHelper
			{
				readonly Func<Expression, ColumnDescriptor?, ISqlExpression> _converter;

				public ConvertHelper(Func<Expression, ColumnDescriptor?, ISqlExpression> converter)
				{
					_converter = converter ?? throw new ArgumentNullException(nameof(converter));
				}

				public ISqlExpression Convert(Expression exp, ColumnDescriptor? descriptor)
				{
					return _converter(exp, descriptor);
				}
			}

			public static SqlExpression BuildSqlExpression(SqlExtension root, Type? systemType, int precedence,
				SqlFlags flags, bool? canBeNull, IsNullableType isNullable)
			{
				var sb             = new StringBuilder();
				var resolvedParams = new Dictionary<SqlExtensionParam, string?>();
				var resolving      = new HashSet<SqlExtensionParam>();
				var newParams      = new List<ISqlExpression>();

				Func<string, string?, string?>? valueProvider = null;
				Stack<SqlExtension> current                   = new Stack<SqlExtension>();

				valueProvider = (name, delimiter) =>
				{
					var found = root.GetParametersByName(name);
					if (current.Count != 0)
						found = current.Peek().GetParametersByName(name).Concat(found);
					string? result = null;
					foreach (var p in found)
					{
						if (resolvedParams.TryGetValue(p, out var paramValue))
						{
							result = paramValue;
						}
						else
						{
							if (resolving.Contains(p))
								throw new InvalidOperationException("Circular reference");

							resolving.Add(p);
							var ext = p.Extension;
							if (ext != null)
							{
								current.Push(ext);
								paramValue = ResolveExpressionValues(ext.Expr, valueProvider!);
								current.Pop();
							}
							else
							{
								sb.Length = 0;
								if (p.Expression != null)
								{
									paramValue = string.Format("{{{0}}}", newParams.Count);
									newParams.Add(p.Expression);
								}
							}

							resolvedParams.Add(p, paramValue);

							if (string.IsNullOrEmpty(paramValue))
								continue;

							if (!string.IsNullOrEmpty(result))
								result += delimiter;
							result += paramValue;
						}

						if (delimiter == null && !string.IsNullOrEmpty(result))
							break;
					}

					return result;
				};

				var expr          = ResolveExpressionValues(root.Expr, valueProvider);
				var sqlExpression = new SqlExpression(systemType, expr, precedence, flags, newParams.ToArray());
				if (!canBeNull.HasValue)
					canBeNull = root.CanBeNull;

				if (!canBeNull.HasValue)
					canBeNull = CalcCanBeNull(isNullable, sqlExpression.Parameters.Select(p => p.CanBeNull));

				if (canBeNull.HasValue)
					sqlExpression.CanBeNull = canBeNull.Value;

				return sqlExpression;
			}

			public override ISqlExpression GetExpression(IDataContext dataContext, SelectQuery query, Expression expression, Func<Expression, ColumnDescriptor?, ISqlExpression> converter)
			{
				var helper = new ConvertHelper(converter);

				// chain starts from the tail
				var chain  = BuildFunctionsChain(dataContext, query, expression, helper);

				if (chain.Count == 0)
					throw new InvalidOperationException("No sequence found for expression '{expression}'");

				var ordered = chain
					.Select((c, i) => Tuple.Create(c, i))
					.OrderByDescending(t => t.Item1.Extension?.ChainPrecedence ?? int.MinValue)
					.ThenByDescending(t => t.Item2)
					.Select(t => t.Item1)
					.ToArray();

				var main    = ordered.FirstOrDefault(c => c.Extension != null);

				if (main == null)
				{
					var replaced = chain.Where(c => c.Expression != null).ToArray();
					if (replaced.Length == 0)
						throw new InvalidOperationException($"Can not find root sequence for expression '{expression}'");
					else if (replaced.Length > 1)
						throw new InvalidOperationException($"Multiple root sequences found for expression '{expression}'");

					return replaced[0].Expression!;
				}

				var mainExtension = main.Extension!;

				// suggesting type
				var type = ordered
					.Select(c => c.Extension?.SystemType)
					.FirstOrDefault(t => t != null && dataContext.MappingSchema.IsScalarType(t));

				if (type == null)
					type = ordered
						.Select(c => c.Expression?.SystemType)
						.FirstOrDefault(t => t != null && dataContext.MappingSchema.IsScalarType(t));

				mainExtension.SystemType = type ?? expression.Type;

				// calculating that extension is aggregate
				var isAggregate  = ordered.Any(c => c.Extension?.IsAggregate == true);
				var isPure       = ordered.All(c => c.Extension?.IsPure != false);
				var isWindowFunc = ordered.Any(c => c.Extension?.IsWindowFunction == true);
				var isPredicate  = mainExtension.IsPredicate;

				// calculating replacements
				var replacementMap = ordered
					.Where(c => c.Extension != mainExtension)
					.Select((c, i) => Tuple.Create(c, i))
					.GroupBy(e => e.Item1.Name ?? "")
					.Select(g => new
					{
						Name = g.Key,
						UnderName = g
							.OrderByDescending(e => e.Item1.Extension?.ChainPrecedence ?? int.MinValue)
							.ThenBy(e => e.Item2)
							.Select(e => e.Item1)
							.ToArray()
					})
					.ToArray();

				foreach (var c in replacementMap)
				{
					var first = c.UnderName[0];
					if (c.Name == "" || first.Extension == null)
					{
						for (var i = 0; i < c.UnderName.Length; i++)
						{
							var e = c.UnderName[i];
							mainExtension.AddParameter(e);
						}
					}	
					else
					{
						var firstPrecedence = first.Extension.ChainPrecedence;
						mainExtension.AddParameter(first);
						// append all replaced under superior
						for (int i = 1; i < c.UnderName.Length; i++)
						{
							var item = c.UnderName[i];
							if (firstPrecedence > (item.Extension?.ChainPrecedence ?? int.MinValue))
								first.Extension.AddParameter(item);
							else
								mainExtension.AddParameter(item);
						}
					}
				}

				//TODO: Precedence calculation
				var res = BuildSqlExpression(mainExtension, mainExtension.SystemType, 
					mainExtension.Precedence,
					(isAggregate  ? SqlFlags.IsAggregate      : SqlFlags.None) |
					(isPure       ? SqlFlags.IsPure           : SqlFlags.None) |
					(isPredicate  ? SqlFlags.IsPredicate      : SqlFlags.None) |
					(isWindowFunc ? SqlFlags.IsWindowFunction : SqlFlags.None),
					mainExtension.CanBeNull, IsNullable);

				return res;
			}
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs(685,30): error CS0128: A local variable or function named 'method' is already defined in this scope,D:\a\1\s\Source\LinqToDB\Sql\Sql.ExtensionAttribute.cs(687,23): error CS0165: Use of unassigned local variable 'method'
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Linq;

using LinqToDB;
using LinqToDB.Data;
using LinqToDB.DataProvider.SqlServer;

using NUnit.Framework;

namespace Tests.Linq
{
	[TestFixture]
	public class QueryHintsTests : TestBase
	{
		[Test]
		public void Comment([DataSources(TestProvName.AllAccess, TestProvName.AllMySql)] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.QueryHints.Add("---");
				db.NextQueryHints.Add("----");

				var q = db.Parent.Select(p => p);

				var str = q.ToString();

				TestContext.WriteLine(str);

				Assert.That(str, Contains.Substring("---"));
				Assert.That(str, Contains.Substring("----"));

				var list = q.ToList();

				var ctx = db as DataConnection;

				if (ctx != null)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("---"));
					Assert.That(ctx.LastQuery, Contains.Substring("----"));
				}

				str = q.ToString();

				TestContext.WriteLine(str);

				Assert.That(str, Contains.Substring("---"));
				Assert.That(str, Is.Not.Contains("----"));

				list = q.ToList();

				if (ctx != null)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("---"));
					Assert.That(ctx.LastQuery, Is.Not.Contains("----"));
				}
			}
		}

		[Test]
		public void Option1([IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.QueryHints.Add(SqlServerTools.Sql.OptionRecompile);

				var q = db.Parent.Select(p => p);

				var list = q.ToList();

				var ctx = db as DataConnection;

				if (ctx != null)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("OPTION"));
				}

				list = q.ToList();

				if (ctx != null)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("OPTION"));
				}
			}
		}

		[Test]
		public void Option2([IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.NextQueryHints.Add(SqlServerTools.Sql.OptionRecompile);

				var q = db.Parent.Select(p => p);

				var list = q.ToList();

				var ctx = db as DataConnection;

				if (ctx != null)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("OPTION"));
				}

				list = q.ToList();

				if (ctx != null)
				{
					Assert.That(ctx.LastQuery, Is.Not.Contains("OPTION"));
				}
			}
		}
	}
}

---- Transformed Tree ----
using System.Linq;

using LinqToDB;
using LinqToDB.Data;
using LinqToDB.DataProvider.SqlServer;

using NUnit.Framework;

namespace Tests.Linq
{
	[TestFixture]
	public class QueryHintsTests : TestBase
	{
		[Test]
		public void Comment([DataSources(TestProvName.AllAccess, TestProvName.AllMySql)] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.QueryHints.Add("---");
				db.NextQueryHints.Add("----");

				var q = db.Parent.Select(p => p);

				var str = q.ToString();

				TestContext.WriteLine(str);

				Assert.That(str, Contains.Substring("---"));
				Assert.That(str, Contains.Substring("----"));

				var list = q.ToList();

				if (db is DataConnection ctx)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("---"));
					Assert.That(ctx.LastQuery, Contains.Substring("----"));
				}

				str = q.ToString();

				TestContext.WriteLine(str);

				Assert.That(str, Contains.Substring("---"));
				Assert.That(str, Is.Not.Contains("----"));

				list = q.ToList();

				if (db is DataConnection ctx)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("---"));
					Assert.That(ctx.LastQuery, Is.Not.Contains("----"));
				}
			}
		}

		[Test]
		public void Option1([IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.QueryHints.Add(SqlServerTools.Sql.OptionRecompile);

				var q = db.Parent.Select(p => p);

				var list = q.ToList();

				if (db is DataConnection ctx)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("OPTION"));
				}

				list = q.ToList();

				if (db is DataConnection ctx)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("OPTION"));
				}
			}
		}

		[Test]
		public void Option2([IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.NextQueryHints.Add(SqlServerTools.Sql.OptionRecompile);

				var q = db.Parent.Select(p => p);

				var list = q.ToList();

				if (db is DataConnection ctx)
				{
					Assert.That(ctx.LastQuery, Contains.Substring("OPTION"));
				}

				list = q.ToList();

				if (db is DataConnection ctx)
				{
					Assert.That(ctx.LastQuery, Is.Not.Contains("OPTION"));
				}
			}
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs(48,30): error CS0128: A local variable or function named 'ctx' is already defined in this scope,D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs(50,18): error CS0165: Use of unassigned local variable 'ctx',D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs(74,30): error CS0128: A local variable or function named 'ctx' is already defined in this scope,D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs(76,18): error CS0165: Use of unassigned local variable 'ctx',D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs(99,30): error CS0128: A local variable or function named 'ctx' is already defined in this scope,D:\a\1\s\Tests\Linq\Linq\QueryHintsTests.cs(101,18): error CS0165: Use of unassigned local variable 'ctx'
######################################################################


######################################################################
Nr: 9 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Tests\Linq\Update\UpdateTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using LinqToDB;
using LinqToDB.Data;
using LinqToDB.Mapping;

using NUnit.Framework;

#region ReSharper disable
// ReSharper disable ConvertToConstant.Local
#endregion

namespace Tests.xUpdate
{
	using LinqToDB.Common;
	using Model;

	[TestFixture]
//	[Order(10000)]
	public class UpdateTests : TestBase
	{
		[Test]
		public void Update1([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					db.Parent.Delete(p => p.ParentID > 1000);
					db.Insert(parent);

					Assert.AreEqual(1, db.Parent.Count (p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, db.Parent.Update(p => p.ParentID == parent.ParentID, p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, db.Parent.Count (p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public async Task Update1Async([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					await db.Parent.DeleteAsync(p => p.ParentID > 1000);
					await db.InsertAsync(parent);

					Assert.AreEqual(1, await db.Parent.CountAsync (p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, await db.Parent.UpdateAsync(p => p.ParentID == parent.ParentID, p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, await db.Parent.CountAsync (p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					await db.Child.DeleteAsync(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update2([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					db.Parent.Delete(p => p.ParentID > 1000);
					db.Insert(parent);

					Assert.AreEqual(1, db.Parent.Count(p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, db.Parent.Where(p => p.ParentID == parent.ParentID).Update(p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, db.Parent.Count(p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public async Task Update2Async([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					await db.Parent.DeleteAsync(p => p.ParentID > 1000);
					await db.InsertAsync(parent);

					Assert.AreEqual(1, await db.Parent.CountAsync(p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, await db.Parent.Where(p => p.ParentID == parent.ParentID).UpdateAsync(p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, await db.Parent.CountAsync(p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					await db.Child.DeleteAsync(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update3([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1, db.Child.Where(c => c.ChildID == id && c.Parent!.Value1 == 1).Update(c => new Child { ChildID = c.ChildID + 1 }));
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update4([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1,
						db.Child
							.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
								.Set(c => c.ChildID, c => c.ChildID + 1)
							.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update4String([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				var id = 1001;

				var updatable =
					db.Child
						.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
						.Set(c => c.ChildID, c => c.ChildID + 1);

				var sql = updatable.ToString();
				TestContext.WriteLine(sql);

				Assert.That(sql, Does.Contain("UPDATE"));
			}
		}

		[Test]
		public async Task Update4Async([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					await db.Child.DeleteAsync(c => c.ChildID > 1000);
					await db.Child.InsertAsync(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, await db.Child.CountAsync(c => c.ChildID == id));
					Assert.AreEqual(1,
						await db.Child
							.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
								.Set(c => c.ChildID, c => c.ChildID + 1)
							.UpdateAsync());
					Assert.AreEqual(1, await db.Child.CountAsync(c => c.ChildID == id + 1));
				}
				finally
				{
					await db.Child.DeleteAsync(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update5([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id });

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1,
						db.Child
							.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
								.Set(c => c.ChildID, () => id + 1)
							.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update6([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Parent4.Delete(p => p.ParentID > 1000);
					db.Insert(new Parent4 { ParentID = id, Value1 = TypeValue.Value1 });

					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value1));
					Assert.AreEqual(1,
						db.Parent4
							.Where(p => p.ParentID == id)
								.Set(p => p.Value1, () => TypeValue.Value2)
							.Update());
					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value2));
				}
				finally
				{
					db.Parent4.Delete(p => p.ParentID > 1000);
				}
			}
		}

		[Test]
		public void Update7([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Parent4.Delete(p => p.ParentID > 1000);
					db.Insert(new Parent4 { ParentID = id, Value1 = TypeValue.Value1 });

					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value1));
					Assert.AreEqual(1,
						db.Parent4
							.Where(p => p.ParentID == id)
								.Set(p => p.Value1, TypeValue.Value2)
							.Update());
					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value2));

					Assert.AreEqual(1,
						db.Parent4
							.Where(p => p.ParentID == id)
								.Set(p => p.Value1, TypeValue.Value3)
							.Update());
					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value3));
				}
				finally
				{
					db.Parent4.Delete(p => p.ParentID > 1000);
				}
			}
		}

		[Test]
		public void Update8([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					db.Parent.Delete(p => p.ParentID > 1000);
					db.Insert(parent);

					parent.Value1++;

					db.Update(parent);

					Assert.AreEqual(1002, db.Parent.Single(p => p.ParentID == parent.ParentID).Value1);
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update9(
			[DataSources(
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllMySql,
				TestProvName.AllSQLite,
				ProviderName.Access,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					var q =
						from c in db.Child
						join p in db.Parent on c.ParentID equals p.ParentID
						where c.ChildID == id && c.Parent!.Value1 == 1
						select new { c, p };

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1, q.Update(db.Child, _ => new Child { ChildID = _.c.ChildID + 1, ParentID = _.p.ParentID }));
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update10(
			[DataSources(
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllMySql,
				TestProvName.AllSQLite,
				ProviderName.Access,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					var q =
						from p in db.Parent
						join c in db.Child on p.ParentID equals c.ParentID
						where c.ChildID == id && c.Parent!.Value1 == 1
						select new { c, p };

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1, q.Update(db.Child, _ => new Child { ChildID = _.c.ChildID + 1, ParentID = _.p.ParentID }));
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		//[Test]
		public void Update11([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.BeginTransaction();

				var q = db.GetTable<LinqDataTypes2>().Union(db.GetTable<LinqDataTypes2>());

				//db.GetTable<LinqDataTypes2>().Update(_ => q.Contains(_), _ => new LinqDataTypes2 { GuidValue = _.GuidValue });

				q.Update(_ => new LinqDataTypes2 { GuidValue = _.GuidValue });
			}
		}

		[Test]
		public void Update12(
			[DataSources(
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				(
					from p1 in db.Parent
					join p2 in db.Parent on p1.ParentID equals p2.ParentID
					where p1.ParentID < 3
					select new { p1, p2 }
				)
				.Update(q => q.p1, q => new Parent { ParentID = q.p2.ParentID });
			}
		}

		[Test]
		public async Task Update12Async(
			[DataSources(
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				await (
					from p1 in db.Parent
					join p2 in db.Parent on p1.ParentID equals p2.ParentID
					where p1.ParentID < 3
					select new { p1, p2 }
				)
				.UpdateAsync(q => q.p1, q => new Parent { ParentID = q.p2.ParentID });
			}
		}

		[Test]
		public void Update13(
			[DataSources(
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				(
					from p1 in db.Parent
					join p2 in db.Parent on p1.ParentID equals p2.ParentID
					where p1.ParentID < 3
					select new { p1, p2 }
				)
				.Update(q => q.p2, q => new Parent { ParentID = q.p1.ParentID });
			}
		}

		[Test]
		public void Update14([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.Insert(new Person()
				{
					FirstName = "Update14",
					LastName  = "whatever"
				});

				try
				{
					var name = "Update14";
					var idx = 4;

					db.Person
						.Where(_ => _.FirstName.StartsWith("Update14"))
						.Update(p => new Person()
						{
							LastName = (Sql.AsSql(name).Length + idx).ToString(),
						});

					var cnt = db.Person.Where(_ => _.FirstName.StartsWith("Update14")).Count();
					Assert.AreEqual(1, cnt);
				}
				finally
				{
					db.Person.Where(_ => _.FirstName.StartsWith("Update14")).Delete();
				}
			}
		}

		[Test]
		public void TestUpdateWithColumnFilter1([DataSources] string context, [Values] bool withMiddleName)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				var newName = "UpdateColumnFilterUpdated";
				try
				{
					var p = new Person()
					{
						FirstName = newName,
						LastName = "whatever",
						MiddleName = "som middle name",
						Gender = Gender.Male
					};

					db.Insert(p);

					p = db.GetTable<Person>().Where(x => x.FirstName == p.FirstName).First();

					p.MiddleName = "updated name";

					db.Update(p, (a, b) => b.ColumnName != nameof(Model.Person.MiddleName) || withMiddleName);

					p = db.GetTable<Person>().Where(x => x.FirstName == p.FirstName).First();

					if (withMiddleName)
						Assert.AreEqual("updated name", p.MiddleName);
					else
						Assert.AreNotEqual("updated name", p.MiddleName);
				}
				finally
				{
					db.Person.Where(x => x.FirstName == newName).Delete();
				}
			}
		}

		[Test]
		public void TestUpdateWithColumnFilter2([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				var newName = "UpdateColumnFilterUpdated";
				var p = new Person()
				{
					FirstName = "UpdateColumnFilter",
					LastName  = "whatever"
				};

				db.Insert(p);

				try
				{
					p = db.GetTable<Person>().Where(x => x.FirstName == p.FirstName).Single();

					p.FirstName = newName;
					p.LastName  = newName;

					var columsToUpdate = new HashSet<string> { nameof(p.FirstName) };

					db.Update(p, (a, b) => columsToUpdate.Contains(b.ColumnName));

					var updatedPerson = db.GetTable<Person>().Where(x => x.ID == p.ID).Single();
					Assert.AreEqual("whatever", updatedPerson.LastName);
					Assert.AreEqual(newName   , updatedPerson.FirstName);

					// test for cached update query - must update both columns
					db.Update(p);
					updatedPerson = db.GetTable<Person>().Where(_ => _.ID == p.ID).Single();

					Assert.AreEqual(newName, updatedPerson.LastName);
					Assert.AreEqual(newName, updatedPerson.FirstName);
				}
				finally
				{
					db.Person.Where(x => x.ID == p.ID).Delete();
				}
			}
		}

		[Test]
		public void UpdateComplex1([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				try
				{

					var id = Convert.ToInt32(db.InsertWithIdentity(
						new ComplexPerson2
						{
							Name = new FullName
							{
								FirstName = "UpdateComplex",
								LastName  = "Empty"
							}
						}));

					var obj = db.GetTable<ComplexPerson2>().First(_ => _.ID == id);
					obj.Name.LastName = obj.Name.FirstName;

					db.Update(obj);

					obj = db.GetTable<ComplexPerson2>().First(_ => _.ID == id);

					Assert.AreEqual(obj.Name.FirstName, obj.Name.LastName);
				}
				finally
				{
					db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				}
			}
		}

		[Test]
		public async Task UpdateComplex1Async([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				await db.Person.DeleteAsync(_ => _.FirstName.StartsWith("UpdateComplex"));

				try
				{

					var id = Convert.ToInt32(await db.InsertWithIdentityAsync(
						new ComplexPerson2
						{
							Name = new FullName
							{
								FirstName = "UpdateComplex",
								LastName  = "Empty"
							}
						}));

					var obj = await db.GetTable<ComplexPerson2>().FirstAsync(_ => _.ID == id);
					obj.Name.LastName = obj.Name.FirstName;

					await db.UpdateAsync(obj);

					obj = await db.GetTable<ComplexPerson2>().FirstAsync(_ => _.ID == id);

					Assert.AreEqual(obj.Name.FirstName, obj.Name.LastName);
				}
				finally
				{
					await db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).DeleteAsync();
				}
			}
		}

		[Test]
		public void UpdateComplex2([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				try
				{

					var id = Convert.ToInt32(db.InsertWithIdentity(
						new ComplexPerson2()
						{
							Name = new FullName
							{
								FirstName = "UpdateComplex",
								LastName  = "Empty"
							}
						}));

					var cnt = db.GetTable<ComplexPerson2>()
						.Where(_ => _.Name.FirstName.StartsWith("UpdateComplex"))
						.Set(_ => _.Name.LastName, _ => _.Name.FirstName)
						.Update();

					Assert.AreEqual(1, cnt);

					var obj = db.GetTable<ComplexPerson2>().First(_ => _.ID == id);

					Assert.AreEqual(obj.Name.FirstName, obj.Name.LastName);
				}
				finally
				{
					db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				}

			}
		}

		[Test]
		public void UpdateAssociation1([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Update(db.Parent, x => new Parent { Value1 = 5 }));
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public async Task UpdateAssociation1Async([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					await db.Child. DeleteAsync(x => x.ChildID  == childId);
					await db.Parent.DeleteAsync(x => x.ParentID == parentId);

					await db.Parent.InsertAsync(() => new Parent { ParentID = parentId, Value1 = parentId });
					await db.Child. InsertAsync(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, await parents.UpdateAsync(db.Parent, x => new Parent { Value1 = 5 }));
				}
				finally
				{
					await db.Child. DeleteAsync(x => x.ChildID  == childId);
					await db.Parent.DeleteAsync(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public void UpdateAssociation2([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Update(x => new Parent { Value1 = 5 }));
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public void UpdateAssociation3([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Update(x => x.ParentID > 0, x => new Parent { Value1 = 5 }));
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public void UpdateAssociation4([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Set(x => x.Value1, 5).Update());
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		static readonly Func<TestDataConnection,int,string,int> _updateQuery =
			CompiledQuery.Compile<TestDataConnection,int,string,int>((ctx,key,value) =>
				ctx.Person
					.Where(_ => _.ID == key)
					.Set(_ => _.FirstName, value)
					.Update());

		[Test]
		public void CompiledUpdate()
		{
			using (var ctx = new TestDataConnection())
			{
				_updateQuery(ctx, 12345, "54321");
			}
		}

		[Table("LinqDataTypes")]
		class Table1
		{
			[Column] public int  ID;
			[Column] public bool BoolValue;

			[Association(ThisKey = "ID", OtherKey = "ParentID", CanBeNull = false)]
			public List<Table2> Tables2 = null!;
		}

		[Table("Parent")]
		class Table2
		{
			[Column] public int  ParentID;
			[Column] public int? Value1;

			[Association(ThisKey = "ParentID", OtherKey = "ID", CanBeNull = false)]
			public Table1 Table1 = null!;
		}

		[Test]
		public void UpdateAssociation5(
			[DataSources(
				false,
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllFirebird,
				ProviderName.SqlCe,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = new DataConnection(context))
			{
				var ids = new[] { 10000, 20000 };

				db.GetTable<Table2>()
					.Where (x => ids.Contains(x.ParentID))
					.Select(x => x.Table1)
					.Distinct()
					.Set(y => y.BoolValue, y => y.Tables2.All(x => x.Value1 == 1))
					.Update();

				if (!context.StartsWith(ProviderName.Sybase))
				{
					var idx = db.LastQuery!.IndexOf("INNER JOIN");

					Assert.That(idx, Is.Not.EqualTo(-1));

					idx = db.LastQuery.IndexOf("INNER JOIN", idx + 1);

					Assert.That(idx, Is.EqualTo(-1));
				}
				else
				{
					var idx = db.LastQuery!.IndexOf("INNER JOIN");

					Assert.That(idx, Is.EqualTo(-1));
				}
			}
		}

		[Test]
		public void AsUpdatableTest([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));

					var q  = db.Child.Where(c => c.ChildID == id && c.Parent!.Value1 == 1);
					var uq = q.AsUpdatable();

					uq = uq.Set(c => c.ChildID, c => c.ChildID + 1);

					Assert.AreEqual(1, uq.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void AsUpdatableDuplicate([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id });

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));

					var q  = db.Child.Where(c => c.ChildID == id && c.Parent!.Value1 == 1);
					var uq = q.AsUpdatable();

					uq = uq.Set(c => c.ChildID, c => c.ChildID + 1);
					uq = uq.Set(c => c.ChildID, c => c.ChildID + 2);

					Assert.AreEqual(1, uq.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 2));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Table("GrandChild")]
		class Table3
		{
			[PrimaryKey(1)] public int? ParentID;
			[PrimaryKey(2)] public int? ChildID;
			[Column]        public int? GrandChildID;
		}

		[Test]
		public void UpdateNullablePrimaryKey([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.Update(new Table3 { ParentID = 10000, ChildID = null, GrandChildID = 1000 });

				if (db is DataConnection)
					Assert.IsTrue(((DataConnection)db).LastQuery!.Contains("IS NULL"));

				db.Update(new Table3 { ParentID = 10000, ChildID = 111, GrandChildID = 1000 });

				if (db is DataConnection)
					Assert.IsFalse(((DataConnection)db).LastQuery!.Contains("IS NULL"));
			}
		}

		[Test]
		public void UpdateTop(
			[DataSources(
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllPostgreSQL,
				TestProvName.AllSQLite,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					db.Parent.Delete(c => c.ParentID >= 1000);

					using (new DisableLogging())
					{
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent { ParentID = 1000 + i });
					}

					var rowsAffected = db.Parent
						.Where(p => p.ParentID >= 1000)
						.Take(5)
						.Set(p => p.Value1, 1)
						.Update();

					Assert.That(rowsAffected, Is.EqualTo(5));
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void TestUpdateTakeOrdered(
			[DataSources(
				ProviderName.Access,
				ProviderName.DB2,
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				TestProvName.AllMySql,
				TestProvName.AllSybase,
				TestProvName.AllOracle)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					using (new DisableLogging())
					{
						db.Parent.Delete(c => c.ParentID >= 1000);
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent { ParentID = 1000 + i });
					}

					var entities =
						from x in db.Parent
						where x.ParentID > 1000
						orderby x.ParentID descending
						select x;

					var rowsAffected = entities
						.Take(5)
						.Update(x => new Parent { Value1 = 1 });

					Assert.That(rowsAffected, Is.EqualTo(5));
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void TestUpdateSkipTake(
			[DataSources(
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				TestProvName.AllMySql,
				TestProvName.AllSybase,
				TestProvName.AllOracle)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					using (new DisableLogging())
					{
						db.Parent.Delete(c => c.ParentID >= 1000);
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent {ParentID = 1000 + i});
					}

					var entities =
						from x in db.Parent
						where x.ParentID > 1000
						orderby x.ParentID descending
						select x;

					var rowsAffected = entities
						.Skip(1)
						.Take(5)
						.Update(x => new Parent { Value1 = 1 });

					Assert.That(rowsAffected, Is.EqualTo(5));

					Assert.False(db.Parent.Where(p => p.ParentID == 1000 + 9).Single().Value1 == 1);
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void TestUpdateTakeNotOrdered(
			[DataSources(
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					using (new DisableLogging())
					{
						db.Parent.Delete(c => c.ParentID >= 1000);
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent {ParentID = 1000 + i});
					}

					var entities =
						from x in db.Parent
						where x.ParentID > 1000
						select x;

					var rowsAffected = entities
						.Take(5)
						.Update(x => new Parent { Value1 = 1 });

					Assert.That(rowsAffected, Is.EqualTo(5));
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void UpdateSetSelect([DataSources(
			TestProvName.AllAccess, TestProvName.AllInformix, ProviderName.SqlCe)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				db.Parent.Delete(_ => _.ParentID > 1000);

				var res =
				(
					from p in db.Parent
					join c in db.Child on p.ParentID equals c.ParentID
					where p.ParentID == 1
					select p
				)
				.Set(p => p.ParentID, p => db.Child.SingleOrDefault(c => c.ChildID == 11)!.ParentID + 1000)
				.Update();

				Assert.AreEqual(1, res);

				res = db.Parent.Where(_ => _.ParentID == 1001).Set(_ => _.ParentID, 1).Update();
				Assert.AreEqual(1, res);
			}
		}

		[Test]
		public void UpdateIssue319Regression(
			[DataSources(
				TestProvName.AllAccess,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				TestProvName.AllMySql,
				TestProvName.AllSybase,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				var id = 100500;
				try
				{
					db.Insert(new Parent1()
					{
						ParentID = id
					});

					var query = db.GetTable<Parent1>()
						.Where(_ => _.ParentID == id)
						.Select(_ => new Parent1()
						{
							ParentID = _.ParentID
						});

					var queryResult = new Lazy<Parent1>(() => query.First());

					var cnt = db.GetTable<Parent1>()
						.Where(_ => _.ParentID == id && query.Any())
						.Update(_ => new Parent1()
						{
							Value1 = queryResult.Value.ParentID
						});

					Assert.AreEqual(1, cnt);
				}
				finally
				{
					db.GetTable<Parent1>().Delete(_ => _.ParentID == id);
				}
			}
		}

		// looks like managed provider handle null bit parameters as false, because it doesn't fail
		// maybe we need to do the same for unmanaged
		[ActiveIssue("AseException : Null value is not allowed in BIT TYPE", Configuration = ProviderName.Sybase)]
		[Test]
		public void UpdateIssue321Regression([DataSources(ProviderName.DB2, TestProvName.AllInformix, TestProvName.AllFirebird)] string context)
		{
			using (var db = GetDataContext(context))
			{
				var id = 100500;

				try
				{
					var value1 = 3000m;
					var value2 = 13621m;
					var value3 = 60;

					db.Insert(new LinqDataTypes2()
					{
						ID         = id,
						MoneyValue = value1,
						IntValue   = value3
					});

					db.GetTable<LinqDataTypes2>()
						.Update(
							_ => _.ID == id,
							_ => new LinqDataTypes2
							{
								SmallIntValue = (short)(_.MoneyValue / (value2 / _.IntValue!))
							});

					var dbResult = db.GetTable<LinqDataTypes2>()
						.Where(_ => _.ID == id)
						.Select(_ => _.SmallIntValue).First();

					var expected = (short)(value1 / (value2 / value3));

					Assert.AreEqual(expected, dbResult);
				}
				finally
				{
					db.GetTable<LinqDataTypes2>().Delete(c => c.ID == id);
				}
			}
		}

		[Test()]
		public void UpdateMultipleColumns([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				var ldt = new LinqDataTypes
				{
					ID            = 1001,
					MoneyValue    = 1000,
					SmallIntValue = 100,
				};

				try
				{
					db.Types.Delete(c => c.ID == ldt.ID);
					db.Types
						.Value (t => t.ID,            ldt.ID)
						.Value (t => t.MoneyValue,    () => ldt.MoneyValue)
						.Value (t => t.SmallIntValue, () => ldt.SmallIntValue)
						.Insert()
						;

					db.Types
						.Where (t => t.ID == ldt.ID)
						.Set   (t => t.MoneyValue,    () => 2000)
						.Set   (t => t.SmallIntValue, () => 200)
						.Update()
						;

					var udt = db.Types.Single(t => t.ID == ldt.ID);

					Assert.That(udt.MoneyValue,    Is.Not.EqualTo(ldt.MoneyValue));
					Assert.That(udt.SmallIntValue, Is.Not.EqualTo(ldt.SmallIntValue));
				}
				finally
				{
					db.Types.Delete(t => t.ID == ldt.ID);
				}
			}
		}

		[Test]
		public void UpdateByTableName([DataSources] string context)
		{
			const string? schemaName = null;
			var tableName  = InsertTests.GetTableName(context, "32");

			using (var db = GetDataContext(context))
			{
				db.DropTable<Patient>(tableName, schemaName: schemaName, throwExceptionIfNotExists: false);
			}

			using (var db = GetDataContext(context))
			{
				var table = db.CreateTable<Person>(tableName, schemaName: schemaName);

				Assert.AreEqual(tableName,  table.TableName);
				Assert.AreEqual(schemaName, table.SchemaName);

				var person = new Person()
				{
					FirstName = "Steven",
					LastName  = "King",
					Gender    = Gender.Male,
				};

				// insert a row into the table
				db.Insert(person, tableName: tableName, schemaName: schemaName);
				var newCount  = table.Count();
				Assert.AreEqual(1, newCount);

				var personForUpdate = table.Single();

				// update that row
				personForUpdate.MiddleName = "None";
				db.Update(personForUpdate, tableName: tableName, schemaName: schemaName);

				var updatedPerson = table.Single();
				Assert.AreEqual("None", updatedPerson.MiddleName);

				table.Drop();
			}
		}

		[Test]
		public async Task UpdateByTableNameAsync([DataSources] string context)
		{
			const string? schemaName = null;
			var tableName  = InsertTests.GetTableName(context, "33");

			using (var db = GetDataContext(context))
			{
				await db.DropTableAsync<Patient>(tableName, schemaName: schemaName, throwExceptionIfNotExists: false);
			}

			using (var db = GetDataContext(context))
			{
				var table = await db.CreateTableAsync<Person>(tableName, schemaName: schemaName);

				Assert.AreEqual(tableName,  table.TableName);
				Assert.AreEqual(schemaName, table.SchemaName);

				var person = new Person()
				{
					FirstName = "Steven",
					LastName  = "King",
					Gender    = Gender.Male,
				};

				// insert a row into the table
				await db.InsertAsync(person, tableName: tableName, schemaName: schemaName);
				var newCount  = await table.CountAsync();
				Assert.AreEqual(1, newCount);

				var personForUpdate = await table.SingleAsync();

				// update that row
				personForUpdate.MiddleName = "None";
				await db.UpdateAsync(personForUpdate, tableName: tableName, schemaName: schemaName);

				var updatedPerson = await table.SingleAsync();
				Assert.AreEqual("None", updatedPerson.MiddleName);

				await table.DropAsync();
			}
		}

		[Table("gt_s_one")]
		class UpdateFromJoin
		{
			[PrimaryKey] public int id  { get; set; }
			[Column] public string? col1 { get; set; }
			[Column] public string? col2 { get; set; }
			[Column] public string? col3 { get; set; }
			[Column] public string? col4 { get; set; }
			[Column] public string? col5 { get; set; }
			[Column] public string? col6 { get; set; }

			public static UpdateFromJoin[] Data = Array<UpdateFromJoin>.Empty;
		}

		[Table("access_mode")]
		class AccessMode
		{
			[PrimaryKey]
			public int id { get; set; }

			[Column]
			public string? code { get; set; }

			public static AccessMode[] Data = Array<AccessMode>.Empty;
		}

		// https://stackoverflow.com/questions/57115728/
		[Test]
		public void TestUpdateFromJoin([DataSources(
			TestProvName.AllAccess, // access doesn't have Replace mapping
			ProviderName.SqlCe,
			TestProvName.AllInformix)] string context)
		{
			using (var db          = GetDataContext(context))
			using (var gt_s_one    = db.CreateLocalTable(UpdateFromJoin.Data))
			using (var access_mode = db.CreateLocalTable(AccessMode.Data))
			{
				gt_s_one
					.GroupJoin(
						access_mode,
						l => l.col3!.Replace("auth.", "").ToUpper(),
						am => am.code!.ToUpper(),
						(l, am) => new
						{
							l,
							am
						})
					.SelectMany(
						x => x.am.DefaultIfEmpty(),
						(x1, y1) => new
						{
							gt    = x1.l,
							theAM = y1!.id
						})
					.Update(
						gt_s_one,
						s => new UpdateFromJoin()
						{
							col1 = s.gt.col1,
							col2 = s.gt.col2,
							col3 = s.gt.col3!.Replace("auth.", ""),
							col4 = s.gt.col4,
							col5 = s.gt.col3 == "empty" ? "1" : "0",
							col6 = s.gt.col3 == "empty" ? "" : s.theAM.ToString()
						});
			}
		}
		enum UpdateSetEnum
		{
			Value1 = 6,
			Value2 = 7,
			Value3 = 8
		}
		[Table]
		class UpdateSetTest
		{
			[PrimaryKey] public int            Id     { get; set; }
			[Column]     public Guid           Value1 { get; set; }
			[Column]     public int            Value2 { get; set; }
			[Column]     public UpdateSetEnum  Value3 { get; set; }
			[Column]     public Guid?          Value4 { get; set; }
			[Column]     public int?           Value5 { get; set; }
			[Column]     public UpdateSetEnum? Value6 { get; set; }

			public static UpdateSetTest[] Data = new UpdateSetTest[]
			{
				new UpdateSetTest() { Id = 1, Value1 = TestData.Guid3, Value2 = 10, Value3 = UpdateSetEnum.Value1 }
			};
		}

		[Test]
		public void TestSetValueCaching1(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = TestData.Guid1;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value1, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value1).Single());

				value = TestData.Guid2;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value1, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value1).Single());
			}
		}

		[Test]
		public void TestSetValueCaching2(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = 11;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value2, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value2).Single());

				value = 12;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value2, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value2).Single());
			}
		}

		[Test]
		public void TestSetValueCaching3(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = UpdateSetEnum.Value2;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value3, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value3).Single());

				value = UpdateSetEnum.Value3;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value3, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value3).Single());
			}
		}

		[Test]
		public void TestSetValueCaching4(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = TestData.Guid1;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value4, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value4).Single());

				value = TestData.Guid2;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value4, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value4).Single());
			}
		}

		[Test]
		public void TestSetValueCaching5(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = 11;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value5, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value5).Single());

				value = 12;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value5, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value5).Single());
			}
		}

		[Test]
		public void TestSetValueCaching6(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = UpdateSetEnum.Value2;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value6, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value6).Single());

				value = UpdateSetEnum.Value3;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value6, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value6).Single());
			}
		}


		class TextData
		{
			[Column]
			public int Id { get; set; }

			[Column(Length = int.MaxValue)]
			public string? Items1 { get; set; }

			[Column(Length = int.MaxValue)]
			public string? Items2 { get; set; }
		}


		[Test]
		public void TestSetValueExpr(
			[IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context, [Values("zz", "yy")] string str)
		{
			var data = new[]
			{
				new TextData { Id = 1, Items1 = "T1", Items2 = "Z1" },
				new TextData { Id = 2, Items1 = "T2", Items2 = "Z2" },
			};

			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(data))
			{
				var id = 1;

				table.Where(_ => _.Id >= id)
					.Set(x => $"{x.Items1} += {str}")
					.Set(x => $"{x.Items2} += {str}")
					//.Set(x => $"{x.Items}.WRITE({item}, {2}, {2})")
					.Update();

				var result = table.ToArray();

				Assert.That(result[0].Items1, Is.EqualTo("T1" + str));
				Assert.That(result[0].Items2, Is.EqualTo("Z1" + str));

				Assert.That(result[1].Items1, Is.EqualTo("T2" + str));
				Assert.That(result[1].Items2, Is.EqualTo("Z2" + str));

			}
		}

		[Test]
		public void TestSetValueExpr2(
			[IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context, [Values("zz", "yy")] string str)
		{
			var data = new[]
			{
				new TextData { Id = 1, Items1 = "T1", Items2 = "Z1" },
				new TextData { Id = 2, Items1 = "T2", Items2 = "Z2" },
			};

			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(data))
			{
				var id = 1;

				table.Where(_ => _.Id >= id)
					.Set(x => x.Items1, x => $"{x.Items1}{str}")
					.Set(x => x.Items2, x => $"{x.Items2}{str}")
					.Update();

				var result = table.ToArray();

				Assert.That(result[0].Items1, Is.EqualTo("T1" + str));
				Assert.That(result[0].Items2, Is.EqualTo("Z1" + str));

				Assert.That(result[1].Items1, Is.EqualTo("T2" + str));
				Assert.That(result[1].Items2, Is.EqualTo("Z2" + str));

			}
		}

		[Table]
		class MainTable
		{
			[Column] public int Id;
			[Column] public string? Field;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(AssociatedTable.Id))]
			public AssociatedTable AssociatedOptional = null!;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(AssociatedTable.Id), CanBeNull = false)]
			public AssociatedTable AssociatedRequired = null!;

			public static readonly MainTable[] Data = new []
			{
				new MainTable() { Id = 1, Field = "value 1" },
				new MainTable() { Id = 2, Field = "value 2" },
				new MainTable() { Id = 3, Field = "value 3" },
			};
		}

		[Table]
		class AssociatedTable
		{
			[Column] public int Id;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(MainTable.Id))]
			public MainTable MainOptional = null!;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(MainTable.Id), CanBeNull = false)]
			public MainTable MainRequired = null!;

			public static readonly AssociatedTable[] Data = new []
			{
				new AssociatedTable() { Id = 1 },
				new AssociatedTable() { Id = 3 },
			};
		}

		[Test]
		public void UpdateByAssociationOptional([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db   = GetDataContext(context))
			using (var main = db.CreateLocalTable(MainTable.Data))
			using (db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
					var cnt = main
						.Where(_ => _.Id == id)
						.Select(_ => _.AssociatedOptional!.MainOptional)
						.Update(p => new MainTable()
						{
							Field = "test"
						});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

		[Test]
		public void UpdateByAssociationRequired([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			using (var main = db.CreateLocalTable(MainTable.Data))
			using (db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
				var cnt = main
						.Where(_ => _.Id == id)
						.Select(_ => _.AssociatedRequired!.MainRequired)
						.Update(p => new MainTable()
						{
							Field = "test"
						});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

		[Test]
		public void UpdateByAssociation2Optional([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db         = GetDataContext(context))
			using (var main       = db.CreateLocalTable(MainTable.Data))
			using (var associated = db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
				var cnt = associated
					.Where(pat => pat.Id == id)
					.Select(p => p.MainOptional)
					.Update(p => new MainTable()
					{
						Field = "test"
					});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

		[Test]
		public void UpdateByAssociation2Required([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			using (var main = db.CreateLocalTable(MainTable.Data))
			using (var associated = db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
				var cnt = associated
					.Where(pat => pat.Id == id)
					.Select(p => p.MainRequired)
					.Update(p => new MainTable()
					{
						Field = "test"
					});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

	}
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using LinqToDB;
using LinqToDB.Data;
using LinqToDB.Mapping;

using NUnit.Framework;

#region ReSharper disable
// ReSharper disable ConvertToConstant.Local
#endregion

namespace Tests.xUpdate
{
	using LinqToDB.Common;
	using Model;

	[TestFixture]
//	[Order(10000)]
	public class UpdateTests : TestBase
	{
		[Test]
		public void Update1([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					db.Parent.Delete(p => p.ParentID > 1000);
					db.Insert(parent);

					Assert.AreEqual(1, db.Parent.Count (p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, db.Parent.Update(p => p.ParentID == parent.ParentID, p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, db.Parent.Count (p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public async Task Update1Async([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					await db.Parent.DeleteAsync(p => p.ParentID > 1000);
					await db.InsertAsync(parent);

					Assert.AreEqual(1, await db.Parent.CountAsync (p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, await db.Parent.UpdateAsync(p => p.ParentID == parent.ParentID, p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, await db.Parent.CountAsync (p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					await db.Child.DeleteAsync(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update2([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					db.Parent.Delete(p => p.ParentID > 1000);
					db.Insert(parent);

					Assert.AreEqual(1, db.Parent.Count(p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, db.Parent.Where(p => p.ParentID == parent.ParentID).Update(p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, db.Parent.Count(p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public async Task Update2Async([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					await db.Parent.DeleteAsync(p => p.ParentID > 1000);
					await db.InsertAsync(parent);

					Assert.AreEqual(1, await db.Parent.CountAsync(p => p.ParentID == parent.ParentID));
					Assert.AreEqual(1, await db.Parent.Where(p => p.ParentID == parent.ParentID).UpdateAsync(p => new Parent { ParentID = p.ParentID + 1 }));
					Assert.AreEqual(1, await db.Parent.CountAsync(p => p.ParentID == parent.ParentID + 1));
				}
				finally
				{
					await db.Child.DeleteAsync(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update3([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1, db.Child.Where(c => c.ChildID == id && c.Parent!.Value1 == 1).Update(c => new Child { ChildID = c.ChildID + 1 }));
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update4([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1,
						db.Child
							.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
								.Set(c => c.ChildID, c => c.ChildID + 1)
							.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update4String([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				var id = 1001;

				var updatable =
					db.Child
						.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
						.Set(c => c.ChildID, c => c.ChildID + 1);

				var sql = updatable.ToString();
				TestContext.WriteLine(sql);

				Assert.That(sql, Does.Contain("UPDATE"));
			}
		}

		[Test]
		public async Task Update4Async([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					await db.Child.DeleteAsync(c => c.ChildID > 1000);
					await db.Child.InsertAsync(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, await db.Child.CountAsync(c => c.ChildID == id));
					Assert.AreEqual(1,
						await db.Child
							.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
								.Set(c => c.ChildID, c => c.ChildID + 1)
							.UpdateAsync());
					Assert.AreEqual(1, await db.Child.CountAsync(c => c.ChildID == id + 1));
				}
				finally
				{
					await db.Child.DeleteAsync(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update5([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id });

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1,
						db.Child
							.Where(c => c.ChildID == id && c.Parent!.Value1 == 1)
								.Set(c => c.ChildID, () => id + 1)
							.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update6([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Parent4.Delete(p => p.ParentID > 1000);
					db.Insert(new Parent4 { ParentID = id, Value1 = TypeValue.Value1 });

					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value1));
					Assert.AreEqual(1,
						db.Parent4
							.Where(p => p.ParentID == id)
								.Set(p => p.Value1, () => TypeValue.Value2)
							.Update());
					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value2));
				}
				finally
				{
					db.Parent4.Delete(p => p.ParentID > 1000);
				}
			}
		}

		[Test]
		public void Update7([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Parent4.Delete(p => p.ParentID > 1000);
					db.Insert(new Parent4 { ParentID = id, Value1 = TypeValue.Value1 });

					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value1));
					Assert.AreEqual(1,
						db.Parent4
							.Where(p => p.ParentID == id)
								.Set(p => p.Value1, TypeValue.Value2)
							.Update());
					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value2));

					Assert.AreEqual(1,
						db.Parent4
							.Where(p => p.ParentID == id)
								.Set(p => p.Value1, TypeValue.Value3)
							.Update());
					Assert.AreEqual(1, db.Parent4.Count(p => p.ParentID == id && p.Value1 == TypeValue.Value3));
				}
				finally
				{
					db.Parent4.Delete(p => p.ParentID > 1000);
				}
			}
		}

		[Test]
		public void Update8([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var parent = new Parent1 { ParentID = 1001, Value1 = 1001 };

					db.Parent.Delete(p => p.ParentID > 1000);
					db.Insert(parent);

					parent.Value1++;

					db.Update(parent);

					Assert.AreEqual(1002, db.Parent.Single(p => p.ParentID == parent.ParentID).Value1);
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update9(
			[DataSources(
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllMySql,
				TestProvName.AllSQLite,
				ProviderName.Access,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					var q =
						from c in db.Child
						join p in db.Parent on c.ParentID equals p.ParentID
						where c.ChildID == id && c.Parent!.Value1 == 1
						select new { c, p };

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1, q.Update(db.Child, _ => new Child { ChildID = _.c.ChildID + 1, ParentID = _.p.ParentID }));
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void Update10(
			[DataSources(
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllMySql,
				TestProvName.AllSQLite,
				ProviderName.Access,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					var q =
						from p in db.Parent
						join c in db.Child on p.ParentID equals c.ParentID
						where c.ChildID == id && c.Parent!.Value1 == 1
						select new { c, p };

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));
					Assert.AreEqual(1, q.Update(db.Child, _ => new Child { ChildID = _.c.ChildID + 1, ParentID = _.p.ParentID }));
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		//[Test]
		public void Update11([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.BeginTransaction();

				var q = db.GetTable<LinqDataTypes2>().Union(db.GetTable<LinqDataTypes2>());

				//db.GetTable<LinqDataTypes2>().Update(_ => q.Contains(_), _ => new LinqDataTypes2 { GuidValue = _.GuidValue });

				q.Update(_ => new LinqDataTypes2 { GuidValue = _.GuidValue });
			}
		}

		[Test]
		public void Update12(
			[DataSources(
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				(
					from p1 in db.Parent
					join p2 in db.Parent on p1.ParentID equals p2.ParentID
					where p1.ParentID < 3
					select new { p1, p2 }
				)
				.Update(q => q.p1, q => new Parent { ParentID = q.p2.ParentID });
			}
		}

		[Test]
		public async Task Update12Async(
			[DataSources(
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				await (
					from p1 in db.Parent
					join p2 in db.Parent on p1.ParentID equals p2.ParentID
					where p1.ParentID < 3
					select new { p1, p2 }
				)
				.UpdateAsync(q => q.p1, q => new Parent { ParentID = q.p2.ParentID });
			}
		}

		[Test]
		public void Update13(
			[DataSources(
				ProviderName.SqlCe,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				(
					from p1 in db.Parent
					join p2 in db.Parent on p1.ParentID equals p2.ParentID
					where p1.ParentID < 3
					select new { p1, p2 }
				)
				.Update(q => q.p2, q => new Parent { ParentID = q.p1.ParentID });
			}
		}

		[Test]
		public void Update14([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.Insert(new Person()
				{
					FirstName = "Update14",
					LastName  = "whatever"
				});

				try
				{
					var name = "Update14";
					var idx = 4;

					db.Person
						.Where(_ => _.FirstName.StartsWith("Update14"))
						.Update(p => new Person()
						{
							LastName = (Sql.AsSql(name).Length + idx).ToString(),
						});

					var cnt = db.Person.Where(_ => _.FirstName.StartsWith("Update14")).Count();
					Assert.AreEqual(1, cnt);
				}
				finally
				{
					db.Person.Where(_ => _.FirstName.StartsWith("Update14")).Delete();
				}
			}
		}

		[Test]
		public void TestUpdateWithColumnFilter1([DataSources] string context, [Values] bool withMiddleName)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				var newName = "UpdateColumnFilterUpdated";
				try
				{
					var p = new Person()
					{
						FirstName = newName,
						LastName = "whatever",
						MiddleName = "som middle name",
						Gender = Gender.Male
					};

					db.Insert(p);

					p = db.GetTable<Person>().Where(x => x.FirstName == p.FirstName).First();

					p.MiddleName = "updated name";

					db.Update(p, (a, b) => b.ColumnName != nameof(Model.Person.MiddleName) || withMiddleName);

					p = db.GetTable<Person>().Where(x => x.FirstName == p.FirstName).First();

					if (withMiddleName)
						Assert.AreEqual("updated name", p.MiddleName);
					else
						Assert.AreNotEqual("updated name", p.MiddleName);
				}
				finally
				{
					db.Person.Where(x => x.FirstName == newName).Delete();
				}
			}
		}

		[Test]
		public void TestUpdateWithColumnFilter2([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				var newName = "UpdateColumnFilterUpdated";
				var p = new Person()
				{
					FirstName = "UpdateColumnFilter",
					LastName  = "whatever"
				};

				db.Insert(p);

				try
				{
					p = db.GetTable<Person>().Where(x => x.FirstName == p.FirstName).Single();

					p.FirstName = newName;
					p.LastName  = newName;

					var columsToUpdate = new HashSet<string> { nameof(p.FirstName) };

					db.Update(p, (a, b) => columsToUpdate.Contains(b.ColumnName));

					var updatedPerson = db.GetTable<Person>().Where(x => x.ID == p.ID).Single();
					Assert.AreEqual("whatever", updatedPerson.LastName);
					Assert.AreEqual(newName   , updatedPerson.FirstName);

					// test for cached update query - must update both columns
					db.Update(p);
					updatedPerson = db.GetTable<Person>().Where(_ => _.ID == p.ID).Single();

					Assert.AreEqual(newName, updatedPerson.LastName);
					Assert.AreEqual(newName, updatedPerson.FirstName);
				}
				finally
				{
					db.Person.Where(x => x.ID == p.ID).Delete();
				}
			}
		}

		[Test]
		public void UpdateComplex1([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				try
				{

					var id = Convert.ToInt32(db.InsertWithIdentity(
						new ComplexPerson2
						{
							Name = new FullName
							{
								FirstName = "UpdateComplex",
								LastName  = "Empty"
							}
						}));

					var obj = db.GetTable<ComplexPerson2>().First(_ => _.ID == id);
					obj.Name.LastName = obj.Name.FirstName;

					db.Update(obj);

					obj = db.GetTable<ComplexPerson2>().First(_ => _.ID == id);

					Assert.AreEqual(obj.Name.FirstName, obj.Name.LastName);
				}
				finally
				{
					db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				}
			}
		}

		[Test]
		public async Task UpdateComplex1Async([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				await db.Person.DeleteAsync(_ => _.FirstName.StartsWith("UpdateComplex"));

				try
				{

					var id = Convert.ToInt32(await db.InsertWithIdentityAsync(
						new ComplexPerson2
						{
							Name = new FullName
							{
								FirstName = "UpdateComplex",
								LastName  = "Empty"
							}
						}));

					var obj = await db.GetTable<ComplexPerson2>().FirstAsync(_ => _.ID == id);
					obj.Name.LastName = obj.Name.FirstName;

					await db.UpdateAsync(obj);

					obj = await db.GetTable<ComplexPerson2>().FirstAsync(_ => _.ID == id);

					Assert.AreEqual(obj.Name.FirstName, obj.Name.LastName);
				}
				finally
				{
					await db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).DeleteAsync();
				}
			}
		}

		[Test]
		public void UpdateComplex2([DataSources] string context)
		{
			ResetPersonIdentity(context);

			using (var db = GetDataContext(context))
			{
				db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				try
				{

					var id = Convert.ToInt32(db.InsertWithIdentity(
						new ComplexPerson2()
						{
							Name = new FullName
							{
								FirstName = "UpdateComplex",
								LastName  = "Empty"
							}
						}));

					var cnt = db.GetTable<ComplexPerson2>()
						.Where(_ => _.Name.FirstName.StartsWith("UpdateComplex"))
						.Set(_ => _.Name.LastName, _ => _.Name.FirstName)
						.Update();

					Assert.AreEqual(1, cnt);

					var obj = db.GetTable<ComplexPerson2>().First(_ => _.ID == id);

					Assert.AreEqual(obj.Name.FirstName, obj.Name.LastName);
				}
				finally
				{
					db.Person.Where(_ => _.FirstName.StartsWith("UpdateComplex")).Delete();
				}

			}
		}

		[Test]
		public void UpdateAssociation1([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Update(db.Parent, x => new Parent { Value1 = 5 }));
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public async Task UpdateAssociation1Async([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					await db.Child. DeleteAsync(x => x.ChildID  == childId);
					await db.Parent.DeleteAsync(x => x.ParentID == parentId);

					await db.Parent.InsertAsync(() => new Parent { ParentID = parentId, Value1 = parentId });
					await db.Child. InsertAsync(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, await parents.UpdateAsync(db.Parent, x => new Parent { Value1 = 5 }));
				}
				finally
				{
					await db.Child. DeleteAsync(x => x.ChildID  == childId);
					await db.Parent.DeleteAsync(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public void UpdateAssociation2([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Update(x => new Parent { Value1 = 5 }));
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public void UpdateAssociation3([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Update(x => x.ParentID > 0, x => new Parent { Value1 = 5 }));
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		[Test]
		public void UpdateAssociation4([DataSources(TestProvName.AllSybase, TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				const int childId  = 10000;
				const int parentId = 20000;

				try
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);

					db.Parent.Insert(() => new Parent { ParentID = parentId, Value1 = parentId });
					db.Child. Insert(() => new Child  { ChildID = childId, ParentID = parentId });

					var parents =
						from child in db.Child
						where child.ChildID == childId
						select child.Parent;

					Assert.AreEqual(1, parents.Set(x => x.Value1, 5).Update());
				}
				finally
				{
					db.Child. Delete(x => x.ChildID  == childId);
					db.Parent.Delete(x => x.ParentID == parentId);
				}
			}
		}

		static readonly Func<TestDataConnection,int,string,int> _updateQuery =
			CompiledQuery.Compile<TestDataConnection,int,string,int>((ctx,key,value) =>
				ctx.Person
					.Where(_ => _.ID == key)
					.Set(_ => _.FirstName, value)
					.Update());

		[Test]
		public void CompiledUpdate()
		{
			using (var ctx = new TestDataConnection())
			{
				_updateQuery(ctx, 12345, "54321");
			}
		}

		[Table("LinqDataTypes")]
		class Table1
		{
			[Column] public int  ID;
			[Column] public bool BoolValue;

			[Association(ThisKey = "ID", OtherKey = "ParentID", CanBeNull = false)]
			public List<Table2> Tables2 = null!;
		}

		[Table("Parent")]
		class Table2
		{
			[Column] public int  ParentID;
			[Column] public int? Value1;

			[Association(ThisKey = "ParentID", OtherKey = "ID", CanBeNull = false)]
			public Table1 Table1 = null!;
		}

		[Test]
		public void UpdateAssociation5(
			[DataSources(
				false,
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllOracle,
				TestProvName.AllSQLite,
				TestProvName.AllFirebird,
				ProviderName.SqlCe,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = new DataConnection(context))
			{
				var ids = new[] { 10000, 20000 };

				db.GetTable<Table2>()
					.Where (x => ids.Contains(x.ParentID))
					.Select(x => x.Table1)
					.Distinct()
					.Set(y => y.BoolValue, y => y.Tables2.All(x => x.Value1 == 1))
					.Update();

				if (!context.StartsWith(ProviderName.Sybase))
				{
					var idx = db.LastQuery!.IndexOf("INNER JOIN");

					Assert.That(idx, Is.Not.EqualTo(-1));

					idx = db.LastQuery.IndexOf("INNER JOIN", idx + 1);

					Assert.That(idx, Is.EqualTo(-1));
				}
				else
				{
					var idx = db.LastQuery!.IndexOf("INNER JOIN");

					Assert.That(idx, Is.EqualTo(-1));
				}
			}
		}

		[Test]
		public void AsUpdatableTest([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id});

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));

					var q  = db.Child.Where(c => c.ChildID == id && c.Parent!.Value1 == 1);
					var uq = q.AsUpdatable();

					uq = uq.Set(c => c.ChildID, c => c.ChildID + 1);

					Assert.AreEqual(1, uq.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 1));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Test]
		public void AsUpdatableDuplicate([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					var id = 1001;

					db.Child.Delete(c => c.ChildID > 1000);
					db.Child.Insert(() => new Child { ParentID = 1, ChildID = id });

					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id));

					var q  = db.Child.Where(c => c.ChildID == id && c.Parent!.Value1 == 1);
					var uq = q.AsUpdatable();

					uq = uq.Set(c => c.ChildID, c => c.ChildID + 1);
					uq = uq.Set(c => c.ChildID, c => c.ChildID + 2);

					Assert.AreEqual(1, uq.Update());
					Assert.AreEqual(1, db.Child.Count(c => c.ChildID == id + 2));
				}
				finally
				{
					db.Child.Delete(c => c.ChildID > 1000);
				}
			}
		}

		[Table("GrandChild")]
		class Table3
		{
			[PrimaryKey(1)] public int? ParentID;
			[PrimaryKey(2)] public int? ChildID;
			[Column]        public int? GrandChildID;
		}

		[Test]
		public void UpdateNullablePrimaryKey([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				db.Update(new Table3 { ParentID = 10000, ChildID = null, GrandChildID = 1000 });

				if (db is DataConnection dataConnection)
					Assert.IsTrue(dataConnection.LastQuery!.Contains("IS NULL"));

				db.Update(new Table3 { ParentID = 10000, ChildID = 111, GrandChildID = 1000 });

				if (db is DataConnection dataConnection)
					Assert.IsFalse(dataConnection.LastQuery!.Contains("IS NULL"));
			}
		}

		[Test]
		public void UpdateTop(
			[DataSources(
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllPostgreSQL,
				TestProvName.AllSQLite,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					db.Parent.Delete(c => c.ParentID >= 1000);

					using (new DisableLogging())
					{
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent { ParentID = 1000 + i });
					}

					var rowsAffected = db.Parent
						.Where(p => p.ParentID >= 1000)
						.Take(5)
						.Set(p => p.Value1, 1)
						.Update();

					Assert.That(rowsAffected, Is.EqualTo(5));
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void TestUpdateTakeOrdered(
			[DataSources(
				ProviderName.Access,
				ProviderName.DB2,
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				TestProvName.AllMySql,
				TestProvName.AllSybase,
				TestProvName.AllOracle)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					using (new DisableLogging())
					{
						db.Parent.Delete(c => c.ParentID >= 1000);
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent { ParentID = 1000 + i });
					}

					var entities =
						from x in db.Parent
						where x.ParentID > 1000
						orderby x.ParentID descending
						select x;

					var rowsAffected = entities
						.Take(5)
						.Update(x => new Parent { Value1 = 1 });

					Assert.That(rowsAffected, Is.EqualTo(5));
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void TestUpdateSkipTake(
			[DataSources(
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				TestProvName.AllMySql,
				TestProvName.AllSybase,
				TestProvName.AllOracle)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					using (new DisableLogging())
					{
						db.Parent.Delete(c => c.ParentID >= 1000);
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent {ParentID = 1000 + i});
					}

					var entities =
						from x in db.Parent
						where x.ParentID > 1000
						orderby x.ParentID descending
						select x;

					var rowsAffected = entities
						.Skip(1)
						.Take(5)
						.Update(x => new Parent { Value1 = 1 });

					Assert.That(rowsAffected, Is.EqualTo(5));

					Assert.False(db.Parent.Where(p => p.ParentID == 1000 + 9).Single().Value1 == 1);
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void TestUpdateTakeNotOrdered(
			[DataSources(
				TestProvName.AllAccess,
				ProviderName.DB2,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				ProviderName.SqlCe,
				ProviderName.SqlServer2000,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				try
				{
					using (new DisableLogging())
					{
						db.Parent.Delete(c => c.ParentID >= 1000);
						for (var i = 0; i < 10; i++)
							db.Insert(new Parent {ParentID = 1000 + i});
					}

					var entities =
						from x in db.Parent
						where x.ParentID > 1000
						select x;

					var rowsAffected = entities
						.Take(5)
						.Update(x => new Parent { Value1 = 1 });

					Assert.That(rowsAffected, Is.EqualTo(5));
				}
				finally
				{
					db.Parent.Delete(c => c.ParentID >= 1000);
				}
			}
		}

		[Test]
		public void UpdateSetSelect([DataSources(
			TestProvName.AllAccess, TestProvName.AllInformix, ProviderName.SqlCe)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				db.Parent.Delete(_ => _.ParentID > 1000);

				var res =
				(
					from p in db.Parent
					join c in db.Child on p.ParentID equals c.ParentID
					where p.ParentID == 1
					select p
				)
				.Set(p => p.ParentID, p => db.Child.SingleOrDefault(c => c.ChildID == 11)!.ParentID + 1000)
				.Update();

				Assert.AreEqual(1, res);

				res = db.Parent.Where(_ => _.ParentID == 1001).Set(_ => _.ParentID, 1).Update();
				Assert.AreEqual(1, res);
			}
		}

		[Test]
		public void UpdateIssue319Regression(
			[DataSources(
				TestProvName.AllAccess,
				TestProvName.AllInformix,
				TestProvName.AllFirebird,
				TestProvName.AllSQLite,
				TestProvName.AllMySql,
				TestProvName.AllSybase,
				TestProvName.AllSapHana)]
			string context)
		{
			using (var db = GetDataContext(context))
			{
				var id = 100500;
				try
				{
					db.Insert(new Parent1()
					{
						ParentID = id
					});

					var query = db.GetTable<Parent1>()
						.Where(_ => _.ParentID == id)
						.Select(_ => new Parent1()
						{
							ParentID = _.ParentID
						});

					var queryResult = new Lazy<Parent1>(() => query.First());

					var cnt = db.GetTable<Parent1>()
						.Where(_ => _.ParentID == id && query.Any())
						.Update(_ => new Parent1()
						{
							Value1 = queryResult.Value.ParentID
						});

					Assert.AreEqual(1, cnt);
				}
				finally
				{
					db.GetTable<Parent1>().Delete(_ => _.ParentID == id);
				}
			}
		}

		// looks like managed provider handle null bit parameters as false, because it doesn't fail
		// maybe we need to do the same for unmanaged
		[ActiveIssue("AseException : Null value is not allowed in BIT TYPE", Configuration = ProviderName.Sybase)]
		[Test]
		public void UpdateIssue321Regression([DataSources(ProviderName.DB2, TestProvName.AllInformix, TestProvName.AllFirebird)] string context)
		{
			using (var db = GetDataContext(context))
			{
				var id = 100500;

				try
				{
					var value1 = 3000m;
					var value2 = 13621m;
					var value3 = 60;

					db.Insert(new LinqDataTypes2()
					{
						ID         = id,
						MoneyValue = value1,
						IntValue   = value3
					});

					db.GetTable<LinqDataTypes2>()
						.Update(
							_ => _.ID == id,
							_ => new LinqDataTypes2
							{
								SmallIntValue = (short)(_.MoneyValue / (value2 / _.IntValue!))
							});

					var dbResult = db.GetTable<LinqDataTypes2>()
						.Where(_ => _.ID == id)
						.Select(_ => _.SmallIntValue).First();

					var expected = (short)(value1 / (value2 / value3));

					Assert.AreEqual(expected, dbResult);
				}
				finally
				{
					db.GetTable<LinqDataTypes2>().Delete(c => c.ID == id);
				}
			}
		}

		[Test()]
		public void UpdateMultipleColumns([DataSources] string context)
		{
			using (var db = GetDataContext(context))
			{
				var ldt = new LinqDataTypes
				{
					ID            = 1001,
					MoneyValue    = 1000,
					SmallIntValue = 100,
				};

				try
				{
					db.Types.Delete(c => c.ID == ldt.ID);
					db.Types
						.Value (t => t.ID,            ldt.ID)
						.Value (t => t.MoneyValue,    () => ldt.MoneyValue)
						.Value (t => t.SmallIntValue, () => ldt.SmallIntValue)
						.Insert()
						;

					db.Types
						.Where (t => t.ID == ldt.ID)
						.Set   (t => t.MoneyValue,    () => 2000)
						.Set   (t => t.SmallIntValue, () => 200)
						.Update()
						;

					var udt = db.Types.Single(t => t.ID == ldt.ID);

					Assert.That(udt.MoneyValue,    Is.Not.EqualTo(ldt.MoneyValue));
					Assert.That(udt.SmallIntValue, Is.Not.EqualTo(ldt.SmallIntValue));
				}
				finally
				{
					db.Types.Delete(t => t.ID == ldt.ID);
				}
			}
		}

		[Test]
		public void UpdateByTableName([DataSources] string context)
		{
			const string? schemaName = null;
			var tableName  = InsertTests.GetTableName(context, "32");

			using (var db = GetDataContext(context))
			{
				db.DropTable<Patient>(tableName, schemaName: schemaName, throwExceptionIfNotExists: false);
			}

			using (var db = GetDataContext(context))
			{
				var table = db.CreateTable<Person>(tableName, schemaName: schemaName);

				Assert.AreEqual(tableName,  table.TableName);
				Assert.AreEqual(schemaName, table.SchemaName);

				var person = new Person()
				{
					FirstName = "Steven",
					LastName  = "King",
					Gender    = Gender.Male,
				};

				// insert a row into the table
				db.Insert(person, tableName: tableName, schemaName: schemaName);
				var newCount  = table.Count();
				Assert.AreEqual(1, newCount);

				var personForUpdate = table.Single();

				// update that row
				personForUpdate.MiddleName = "None";
				db.Update(personForUpdate, tableName: tableName, schemaName: schemaName);

				var updatedPerson = table.Single();
				Assert.AreEqual("None", updatedPerson.MiddleName);

				table.Drop();
			}
		}

		[Test]
		public async Task UpdateByTableNameAsync([DataSources] string context)
		{
			const string? schemaName = null;
			var tableName  = InsertTests.GetTableName(context, "33");

			using (var db = GetDataContext(context))
			{
				await db.DropTableAsync<Patient>(tableName, schemaName: schemaName, throwExceptionIfNotExists: false);
			}

			using (var db = GetDataContext(context))
			{
				var table = await db.CreateTableAsync<Person>(tableName, schemaName: schemaName);

				Assert.AreEqual(tableName,  table.TableName);
				Assert.AreEqual(schemaName, table.SchemaName);

				var person = new Person()
				{
					FirstName = "Steven",
					LastName  = "King",
					Gender    = Gender.Male,
				};

				// insert a row into the table
				await db.InsertAsync(person, tableName: tableName, schemaName: schemaName);
				var newCount  = await table.CountAsync();
				Assert.AreEqual(1, newCount);

				var personForUpdate = await table.SingleAsync();

				// update that row
				personForUpdate.MiddleName = "None";
				await db.UpdateAsync(personForUpdate, tableName: tableName, schemaName: schemaName);

				var updatedPerson = await table.SingleAsync();
				Assert.AreEqual("None", updatedPerson.MiddleName);

				await table.DropAsync();
			}
		}

		[Table("gt_s_one")]
		class UpdateFromJoin
		{
			[PrimaryKey] public int id  { get; set; }
			[Column] public string? col1 { get; set; }
			[Column] public string? col2 { get; set; }
			[Column] public string? col3 { get; set; }
			[Column] public string? col4 { get; set; }
			[Column] public string? col5 { get; set; }
			[Column] public string? col6 { get; set; }

			public static UpdateFromJoin[] Data = Array<UpdateFromJoin>.Empty;
		}

		[Table("access_mode")]
		class AccessMode
		{
			[PrimaryKey]
			public int id { get; set; }

			[Column]
			public string? code { get; set; }

			public static AccessMode[] Data = Array<AccessMode>.Empty;
		}

		// https://stackoverflow.com/questions/57115728/
		[Test]
		public void TestUpdateFromJoin([DataSources(
			TestProvName.AllAccess, // access doesn't have Replace mapping
			ProviderName.SqlCe,
			TestProvName.AllInformix)] string context)
		{
			using (var db          = GetDataContext(context))
			using (var gt_s_one    = db.CreateLocalTable(UpdateFromJoin.Data))
			using (var access_mode = db.CreateLocalTable(AccessMode.Data))
			{
				gt_s_one
					.GroupJoin(
						access_mode,
						l => l.col3!.Replace("auth.", "").ToUpper(),
						am => am.code!.ToUpper(),
						(l, am) => new
						{
							l,
							am
						})
					.SelectMany(
						x => x.am.DefaultIfEmpty(),
						(x1, y1) => new
						{
							gt    = x1.l,
							theAM = y1!.id
						})
					.Update(
						gt_s_one,
						s => new UpdateFromJoin()
						{
							col1 = s.gt.col1,
							col2 = s.gt.col2,
							col3 = s.gt.col3!.Replace("auth.", ""),
							col4 = s.gt.col4,
							col5 = s.gt.col3 == "empty" ? "1" : "0",
							col6 = s.gt.col3 == "empty" ? "" : s.theAM.ToString()
						});
			}
		}
		enum UpdateSetEnum
		{
			Value1 = 6,
			Value2 = 7,
			Value3 = 8
		}
		[Table]
		class UpdateSetTest
		{
			[PrimaryKey] public int            Id     { get; set; }
			[Column]     public Guid           Value1 { get; set; }
			[Column]     public int            Value2 { get; set; }
			[Column]     public UpdateSetEnum  Value3 { get; set; }
			[Column]     public Guid?          Value4 { get; set; }
			[Column]     public int?           Value5 { get; set; }
			[Column]     public UpdateSetEnum? Value6 { get; set; }

			public static UpdateSetTest[] Data = new UpdateSetTest[]
			{
				new UpdateSetTest() { Id = 1, Value1 = TestData.Guid3, Value2 = 10, Value3 = UpdateSetEnum.Value1 }
			};
		}

		[Test]
		public void TestSetValueCaching1(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = TestData.Guid1;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value1, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value1).Single());

				value = TestData.Guid2;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value1, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value1).Single());
			}
		}

		[Test]
		public void TestSetValueCaching2(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = 11;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value2, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value2).Single());

				value = 12;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value2, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value2).Single());
			}
		}

		[Test]
		public void TestSetValueCaching3(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = UpdateSetEnum.Value2;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value3, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value3).Single());

				value = UpdateSetEnum.Value3;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value3, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value3).Single());
			}
		}

		[Test]
		public void TestSetValueCaching4(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = TestData.Guid1;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value4, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value4).Single());

				value = TestData.Guid2;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value4, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value4).Single());
			}
		}

		[Test]
		public void TestSetValueCaching5(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = 11;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value5, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value5).Single());

				value = 12;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value5, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value5).Single());
			}
		}

		[Test]
		public void TestSetValueCaching6(
			[DataSources(
			TestProvName.AllSybase,
			TestProvName.AllMySql,
			TestProvName.AllFirebird,
			TestProvName.AllInformix,
			ProviderName.DB2,
			ProviderName.SqlCe)] string context)
		{
			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(UpdateSetTest.Data))
			{
				var id = 1;
				var value = UpdateSetEnum.Value2;

				table.Where(_ => _.Id == id)
					.Set(_ => _.Value6, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value6).Single());

				value = UpdateSetEnum.Value3;
				table.Where(_ => _.Id == id)
					.Set(_ => _.Value6, value)
					.Update();

				Assert.AreEqual(value, table.Where(_ => _.Id == id).Select(_ => _.Value6).Single());
			}
		}


		class TextData
		{
			[Column]
			public int Id { get; set; }

			[Column(Length = int.MaxValue)]
			public string? Items1 { get; set; }

			[Column(Length = int.MaxValue)]
			public string? Items2 { get; set; }
		}


		[Test]
		public void TestSetValueExpr(
			[IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context, [Values("zz", "yy")] string str)
		{
			var data = new[]
			{
				new TextData { Id = 1, Items1 = "T1", Items2 = "Z1" },
				new TextData { Id = 2, Items1 = "T2", Items2 = "Z2" },
			};

			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(data))
			{
				var id = 1;

				table.Where(_ => _.Id >= id)
					.Set(x => $"{x.Items1} += {str}")
					.Set(x => $"{x.Items2} += {str}")
					//.Set(x => $"{x.Items}.WRITE({item}, {2}, {2})")
					.Update();

				var result = table.ToArray();

				Assert.That(result[0].Items1, Is.EqualTo("T1" + str));
				Assert.That(result[0].Items2, Is.EqualTo("Z1" + str));

				Assert.That(result[1].Items1, Is.EqualTo("T2" + str));
				Assert.That(result[1].Items2, Is.EqualTo("Z2" + str));

			}
		}

		[Test]
		public void TestSetValueExpr2(
			[IncludeDataSources(TestProvName.AllSqlServer2008Plus)] string context, [Values("zz", "yy")] string str)
		{
			var data = new[]
			{
				new TextData { Id = 1, Items1 = "T1", Items2 = "Z1" },
				new TextData { Id = 2, Items1 = "T2", Items2 = "Z2" },
			};

			using (var db = GetDataContext(context))
			using (var table = db.CreateLocalTable(data))
			{
				var id = 1;

				table.Where(_ => _.Id >= id)
					.Set(x => x.Items1, x => $"{x.Items1}{str}")
					.Set(x => x.Items2, x => $"{x.Items2}{str}")
					.Update();

				var result = table.ToArray();

				Assert.That(result[0].Items1, Is.EqualTo("T1" + str));
				Assert.That(result[0].Items2, Is.EqualTo("Z1" + str));

				Assert.That(result[1].Items1, Is.EqualTo("T2" + str));
				Assert.That(result[1].Items2, Is.EqualTo("Z2" + str));

			}
		}

		[Table]
		class MainTable
		{
			[Column] public int Id;
			[Column] public string? Field;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(AssociatedTable.Id))]
			public AssociatedTable AssociatedOptional = null!;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(AssociatedTable.Id), CanBeNull = false)]
			public AssociatedTable AssociatedRequired = null!;

			public static readonly MainTable[] Data = new []
			{
				new MainTable() { Id = 1, Field = "value 1" },
				new MainTable() { Id = 2, Field = "value 2" },
				new MainTable() { Id = 3, Field = "value 3" },
			};
		}

		[Table]
		class AssociatedTable
		{
			[Column] public int Id;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(MainTable.Id))]
			public MainTable MainOptional = null!;

			[Association(ThisKey = nameof(Id), OtherKey = nameof(MainTable.Id), CanBeNull = false)]
			public MainTable MainRequired = null!;

			public static readonly AssociatedTable[] Data = new []
			{
				new AssociatedTable() { Id = 1 },
				new AssociatedTable() { Id = 3 },
			};
		}

		[Test]
		public void UpdateByAssociationOptional([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db   = GetDataContext(context))
			using (var main = db.CreateLocalTable(MainTable.Data))
			using (db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
					var cnt = main
						.Where(_ => _.Id == id)
						.Select(_ => _.AssociatedOptional!.MainOptional)
						.Update(p => new MainTable()
						{
							Field = "test"
						});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

		[Test]
		public void UpdateByAssociationRequired([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			using (var main = db.CreateLocalTable(MainTable.Data))
			using (db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
				var cnt = main
						.Where(_ => _.Id == id)
						.Select(_ => _.AssociatedRequired!.MainRequired)
						.Update(p => new MainTable()
						{
							Field = "test"
						});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

		[Test]
		public void UpdateByAssociation2Optional([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db         = GetDataContext(context))
			using (var main       = db.CreateLocalTable(MainTable.Data))
			using (var associated = db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
				var cnt = associated
					.Where(pat => pat.Id == id)
					.Select(p => p.MainOptional)
					.Update(p => new MainTable()
					{
						Field = "test"
					});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

		[Test]
		public void UpdateByAssociation2Required([DataSources(TestProvName.AllInformix)] string context)
		{
			using (var db = GetDataContext(context))
			using (var main = db.CreateLocalTable(MainTable.Data))
			using (var associated = db.CreateLocalTable(AssociatedTable.Data))
			{
				var id = 3;
				var cnt = associated
					.Where(pat => pat.Id == id)
					.Select(p => p.MainRequired)
					.Update(p => new MainTable()
					{
						Field = "test"
					});

				var data = main.OrderBy(_ => _.Id).ToArray();

				Assert.AreEqual(1, cnt);
				Assert.AreEqual("value 1", data[0].Field);
				Assert.AreEqual("value 2", data[1].Field);
				Assert.AreEqual("test", data[2].Field);
			}
		}

	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Tests\Linq\Update\UpdateTests.cs(1040,30): error CS0128: A local variable or function named 'dataConnection' is already defined in this scope,D:\a\1\s\Tests\Linq\Update\UpdateTests.cs(1041,21): error CS0165: Use of unassigned local variable 'dataConnection'
######################################################################


