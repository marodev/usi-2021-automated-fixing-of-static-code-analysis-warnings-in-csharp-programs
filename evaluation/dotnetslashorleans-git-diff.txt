diff --git a/src/AWS/Orleans.Clustering.DynamoDB/Membership/DynamoDBMembershipTable.cs b/src/AWS/Orleans.Clustering.DynamoDB/Membership/DynamoDBMembershipTable.cs
index 17eb4f81a..36c33efb9 100644
--- a/src/AWS/Orleans.Clustering.DynamoDB/Membership/DynamoDBMembershipTable.cs
+++ b/src/AWS/Orleans.Clustering.DynamoDB/Membership/DynamoDBMembershipTable.cs
@@ -148,8 +148,7 @@ public async Task DeleteMembershipTableEntries(string clusterId)
             }
             catch (Exception exc)
             {
-                this.logger.Error(ErrorCode.MembershipBase, string.Format("Unable to delete membership records on table {0} for clusterId {1}: Exception={2}",
-                    this.options.TableName, clusterId, exc));
+                this.logger.Error(ErrorCode.MembershipBase, $"Unable to delete membership records on table {this.options.TableName} for clusterId {clusterId}: Exception={exc}");
                 throw;
             }
         }
@@ -471,7 +470,7 @@ private MembershipEntry Parse(SiloInstanceRecord tableEntry)
             }
 
             if (suspectingSilos.Count != suspectingTimes.Count)
-                throw new OrleansException(String.Format("SuspectingSilos.Length of {0} as read from Azure table is not equal to SuspectingTimes.Length of {1}", suspectingSilos.Count, suspectingTimes.Count));
+                throw new OrleansException($"SuspectingSilos.Length of {suspectingSilos.Count} as read from Azure table is not equal to SuspectingTimes.Length of {suspectingTimes.Count}");
 
             for (int i = 0; i < suspectingSilos.Count; i++)
                 parse.AddSuspector(suspectingSilos[i], suspectingTimes[i]);
diff --git a/src/AWS/Orleans.Clustering.DynamoDB/Membership/SiloInstanceRecord.cs b/src/AWS/Orleans.Clustering.DynamoDB/Membership/SiloInstanceRecord.cs
index 976a616e2..adf4d500c 100644
--- a/src/AWS/Orleans.Clustering.DynamoDB/Membership/SiloInstanceRecord.cs
+++ b/src/AWS/Orleans.Clustering.DynamoDB/Membership/SiloInstanceRecord.cs
@@ -150,7 +150,7 @@ public override string ToString()
 
         public static string ConstructSiloIdentity(SiloAddress silo)
         {
-            return string.Format("{0}-{1}-{2}", silo.Endpoint.Address, silo.Endpoint.Port, silo.Generation);
+            return $"{silo.Endpoint.Address}-{silo.Endpoint.Port}-{silo.Generation}";
         }
 
         public Dictionary<string, AttributeValue> GetKeys()
diff --git a/src/AWS/Orleans.Persistence.DynamoDB/Provider/DynamoDBGrainStorage.cs b/src/AWS/Orleans.Persistence.DynamoDB/Provider/DynamoDBGrainStorage.cs
index 53d947aae..c694524fb 100755
--- a/src/AWS/Orleans.Persistence.DynamoDB/Provider/DynamoDBGrainStorage.cs
+++ b/src/AWS/Orleans.Persistence.DynamoDB/Provider/DynamoDBGrainStorage.cs
@@ -74,8 +74,7 @@ public async Task Init(CancellationToken ct)
 
             try
             {
-                var initMsg = string.Format("Init: Name={0} ServiceId={1} Table={2} DeleteStateOnClear={3}",
-                        this.name, this.options.ServiceId, this.options.TableName, this.options.DeleteStateOnClear);
+                var initMsg = $"Init: Name={this.name} ServiceId={this.options.ServiceId} Table={this.options.TableName} DeleteStateOnClear={this.options.DeleteStateOnClear}";
 
                 this.jsonSettings = OrleansJsonSerializer.UpdateSerializerSettings(
                     OrleansJsonSerializer.GetDefaultSerializerSettings(this.serviceProvider),
@@ -180,8 +179,7 @@ public async Task WriteStateAsync(string grainType, GrainReference grainReferenc
             catch (Exception exc)
             {
                 this.logger.Error(ErrorCode.StorageProviderBase,
-                    string.Format("Error Writing: GrainType={0} Grainid={1} ETag={2} to Table={3} Exception={4}",
-                    grainType, grainReference, grainState.ETag, this.options.TableName, exc.Message), exc);
+                    $"Error Writing: GrainType={grainType} Grainid={grainReference} ETag={grainState.ETag} to Table={this.options.TableName} Exception={exc.Message}", exc);
                 throw;
             }
         }
@@ -287,8 +285,7 @@ public async Task ClearStateAsync(string grainType, GrainReference grainReferenc
             }
             catch (Exception exc)
             {
-                this.logger.Error(ErrorCode.StorageProviderBase, string.Format("Error {0}: GrainType={1} Grainid={2} ETag={3} from Table={4} Exception={5}",
-                    operation, grainType, grainReference, grainState.ETag, this.options.TableName, exc.Message), exc);
+                this.logger.Error(ErrorCode.StorageProviderBase, $"Error {operation}: GrainType={grainType} Grainid={grainReference} ETag={grainState.ETag} from Table={this.options.TableName} Exception={exc.Message}", exc);
                 throw;
             }
         }
@@ -304,7 +301,7 @@ internal class GrainStateRecord
 
         private string GetKeyString(GrainReference grainReference)
         {
-            var key = string.Format("{0}_{1}", this.options.ServiceId, this.grainReferenceConverter.ToKeyString(grainReference));
+            var key = $"{this.options.ServiceId}_{this.grainReferenceConverter.ToKeyString(grainReference)}";
             return AWSUtils.ValidateDynamoDBPartitionKey(key);
         }
 
@@ -379,7 +376,7 @@ internal void ConvertToStorageFormat(object grainState, GrainStateRecord entity)
 
             if ((pkSize + rkSize + versionSize + dataSize) > MAX_DATA_SIZE)
             {
-                var msg = string.Format("Data too large to write to DynamoDB table. Size={0} MaxSize={1}", dataSize, MAX_DATA_SIZE);
+                var msg = $"Data too large to write to DynamoDB table. Size={dataSize} MaxSize={MAX_DATA_SIZE}";
                 throw new ArgumentOutOfRangeException("GrainState.Size", msg);
             }
         }
diff --git a/src/AWS/Orleans.Streaming.SQS/Streams/SQSBatchContainer.cs b/src/AWS/Orleans.Streaming.SQS/Streams/SQSBatchContainer.cs
index 39e079c43..7af49ed4f 100644
--- a/src/AWS/Orleans.Streaming.SQS/Streams/SQSBatchContainer.cs
+++ b/src/AWS/Orleans.Streaming.SQS/Streams/SQSBatchContainer.cs
@@ -99,7 +99,7 @@ public bool ImportRequestContext()
 
         public override string ToString()
         {
-            return string.Format("[SQSBatchContainer:Stream={0},#Items={1}]", StreamId, events.Count);
+            return $"[SQSBatchContainer:Stream={StreamId},#Items={events.Count}]";
         }
     }
 }
diff --git a/src/AWS/Shared/AWSUtils.cs b/src/AWS/Shared/AWSUtils.cs
index 269935ce8..7c24e8e71 100644
--- a/src/AWS/Shared/AWSUtils.cs
+++ b/src/AWS/Shared/AWSUtils.cs
@@ -40,7 +40,7 @@ internal static RegionEndpoint GetRegionEndpoint(string zone = "")
         public static string ValidateDynamoDBPartitionKey(string key)
         {
             if (key.Length >= 2048)
-                throw new ArgumentException(string.Format("Key length {0} is too long to be an DynamoDB partition key. Key={1}", key.Length, key));
+                throw new ArgumentException($"Key length {key.Length} is too long to be an DynamoDB partition key. Key={key}");
 
             return key;
         }
@@ -53,7 +53,7 @@ public static string ValidateDynamoDBPartitionKey(string key)
         public static string ValidateDynamoDBRowKey(string key)
         {
             if (key.Length >= 1024)
-                throw new ArgumentException(string.Format("Key length {0} is too long to be an DynamoDB row key. Key={1}", key.Length, key));
+                throw new ArgumentException($"Key length {key.Length} is too long to be an DynamoDB row key. Key={key}");
 
             return key;
         }
diff --git a/src/AdoNet/Orleans.Clustering.AdoNet/Messaging/AdoNetClusteringTable.cs b/src/AdoNet/Orleans.Clustering.AdoNet/Messaging/AdoNetClusteringTable.cs
index ea71c6c50..a9452baea 100644
--- a/src/AdoNet/Orleans.Clustering.AdoNet/Messaging/AdoNetClusteringTable.cs
+++ b/src/AdoNet/Orleans.Clustering.AdoNet/Messaging/AdoNetClusteringTable.cs
@@ -51,7 +51,7 @@ public async Task InitializeMembershipTable(bool tryInitTableVersion)
 
         public async Task<MembershipTableData> ReadRow(SiloAddress key)
         {
-            if (logger.IsEnabled(LogLevel.Trace)) logger.Trace(string.Format("AdoNetClusteringTable.ReadRow called with key: {0}.", key));
+            if (logger.IsEnabled(LogLevel.Trace)) logger.Trace($"AdoNetClusteringTable.ReadRow called with key: {key}.");
             try
             {
                 return await orleansQueries.MembershipReadRowAsync(this.clusterId, key);                
@@ -113,7 +113,7 @@ public async Task<bool> InsertRow(MembershipEntry entry, TableVersion tableVersi
 
         public async Task<bool> UpdateRow(MembershipEntry entry, string etag, TableVersion tableVersion)
         {
-            if (logger.IsEnabled(LogLevel.Trace)) logger.Trace(string.Format("IMembershipTable.UpdateRow called with entry {0}, etag {1} and tableVersion {2}.", entry, etag, tableVersion));
+            if (logger.IsEnabled(LogLevel.Trace)) logger.Trace($"IMembershipTable.UpdateRow called with entry {entry}, etag {etag} and tableVersion {tableVersion}.");
 
             //The "tableVersion" parameter should always exist when updating a row as Init should
             //have been called and membership version created and read. This is an optimization to
@@ -145,7 +145,7 @@ public async Task<bool> UpdateRow(MembershipEntry entry, string etag, TableVersi
 
         public async Task UpdateIAmAlive(MembershipEntry entry)
         {
-            if(logger.IsEnabled(LogLevel.Trace)) logger.Trace(string.Format("IMembershipTable.UpdateIAmAlive called with entry {0}.", entry));
+            if(logger.IsEnabled(LogLevel.Trace)) logger.Trace($"IMembershipTable.UpdateIAmAlive called with entry {entry}.");
             if (entry == null)
             {
                 if (logger.IsEnabled(LogLevel.Debug)) logger.Debug("AdoNetClusteringTable.UpdateIAmAlive aborted due to null check. MembershipEntry is null.");
@@ -165,7 +165,7 @@ public async Task UpdateIAmAlive(MembershipEntry entry)
 
         public async Task DeleteMembershipTableEntries(string clusterId)
         {
-            if (logger.IsEnabled(LogLevel.Trace)) logger.Trace(string.Format("IMembershipTable.DeleteMembershipTableEntries called with clusterId {0}.", clusterId));
+            if (logger.IsEnabled(LogLevel.Trace)) logger.Trace($"IMembershipTable.DeleteMembershipTableEntries called with clusterId {clusterId}.");
             try
             {
                 await orleansQueries.DeleteMembershipTableEntriesAsync(clusterId);
diff --git a/src/AdoNet/Shared/Storage/AdoNetFormatProvider.cs b/src/AdoNet/Shared/Storage/AdoNetFormatProvider.cs
index 234dd70bd..9d2df9fdb 100644
--- a/src/AdoNet/Shared/Storage/AdoNetFormatProvider.cs
+++ b/src/AdoNet/Shared/Storage/AdoNetFormatProvider.cs
@@ -41,24 +41,24 @@ public string Format(string format, object arg, IFormatProvider formatProvider)
                     return "NULL";
                 }
 
-                if(arg is string)
+                if(arg is string s)
                 {
-                    return "N'" + ((string)arg).Replace("'", "''") + "'";
+                    return "N'" + s.Replace("'", "''") + "'";
                 }
 
-                if(arg is DateTime)
+                if(arg is DateTime dateTime)
                 {
-                    return "'" + ((DateTime)arg).ToString("O") + "'";
+                    return "'" + dateTime.ToString("O") + "'";
                 }
 
-                if(arg is DateTimeOffset)
+                if(arg is DateTimeOffset dateTimeOffset)
                 {
-                    return "'" + ((DateTimeOffset)arg).ToString("O") + "'";
+                    return "'" + dateTimeOffset.ToString("O") + "'";
                 }
 
-                if(arg is IFormattable)
+                if(arg is IFormattable iFormattable)
                 {
-                    return ((IFormattable)arg).ToString(format, CultureInfo.InvariantCulture);
+                    return iFormattable.ToString(format, CultureInfo.InvariantCulture);
                 }
 
                 return arg.ToString();
diff --git a/src/AdoNet/Shared/Storage/RelationalStorageExtensions.cs b/src/AdoNet/Shared/Storage/RelationalStorageExtensions.cs
index 3b7c586c6..41ecb7214 100644
--- a/src/AdoNet/Shared/Storage/RelationalStorageExtensions.cs
+++ b/src/AdoNet/Shared/Storage/RelationalStorageExtensions.cs
@@ -78,7 +78,7 @@ public static Task<int> ExecuteMultipleInsertIntoAsync<T>(this IRelationalStorag
                 //order as is the index iteration done.                                
                 var onlyOnceRow = new List<string>();
                 var properties = parameters.First().GetType().GetProperties();
-                columns = string.Join(",", nameMap == null ? properties.Select(pn => string.Format("{0}{1}{2}", startEscapeIndicator, pn.Name, endEscapeIndicator)) : properties.Select(pn => string.Format("{0}{1}{2}", startEscapeIndicator, (nameMap.ContainsKey(pn.Name) ? nameMap[pn.Name] : pn.Name), endEscapeIndicator)));
+                columns = string.Join(",", nameMap == null ? properties.Select(pn => $"{startEscapeIndicator}{pn.Name}{endEscapeIndicator}") : properties.Select(pn => $"{startEscapeIndicator}{(nameMap.ContainsKey(pn.Name) ? nameMap[pn.Name] : pn.Name)}{endEscapeIndicator}"));
                 if(onlyOnceColumns != null && onlyOnceColumns.Any())
                 {
                     var onlyOnceProperties = properties.Where(pn => onlyOnceColumns.Contains(pn.Name)).Select(pn => pn).ToArray();
@@ -89,7 +89,7 @@ public static Task<int> ExecuteMultipleInsertIntoAsync<T>(this IRelationalStorag
                         var parameterValue = currentProperty.GetValue(onlyOnceData, null);
                         if(useSqlParams)
                         {
-                            var parameterName = string.Format("@{0}", (nameMap.ContainsKey(onlyOnceProperties[i].Name) ? nameMap[onlyOnceProperties[i].Name] : onlyOnceProperties[i].Name));
+                            var parameterName = $"@{(nameMap.ContainsKey(onlyOnceProperties[i].Name) ? nameMap[onlyOnceProperties[i].Name] : onlyOnceProperties[i].Name)}";
                             onlyOnceRow.Add(parameterName);
                             sqlParameters.Add(parameterName, parameterValue);
                         }
@@ -122,7 +122,7 @@ public static Task<int> ExecuteMultipleInsertIntoAsync<T>(this IRelationalStorag
                         }
                     }
 
-                    values.Add(string.Format("{0}", string.Join(",", onlyOnceRow.Concat(dataRows))));
+                    values.Add($"{string.Join(",", onlyOnceRow.Concat(dataRows))}");
                     dataRows.Clear();
                 }
             }
diff --git a/src/Azure/Orleans.Clustering.AzureStorage/AzureBasedMembershipTable.cs b/src/Azure/Orleans.Clustering.AzureStorage/AzureBasedMembershipTable.cs
index 24e02d2ae..05f00e402 100644
--- a/src/Azure/Orleans.Clustering.AzureStorage/AzureBasedMembershipTable.cs
+++ b/src/Azure/Orleans.Clustering.AzureStorage/AzureBasedMembershipTable.cs
@@ -263,7 +263,7 @@ private static MembershipEntry Parse(SiloInstanceTableEntry tableEntry)
             }
 
             if (suspectingSilos.Count != suspectingTimes.Count)
-                throw new OrleansException(String.Format("SuspectingSilos.Length of {0} as read from Azure table is not equal to SuspectingTimes.Length of {1}", suspectingSilos.Count, suspectingTimes.Count));
+                throw new OrleansException($"SuspectingSilos.Length of {suspectingSilos.Count} as read from Azure table is not equal to SuspectingTimes.Length of {suspectingTimes.Count}");
 
             for (int i = 0; i < suspectingSilos.Count; i++)
                 parse.AddSuspector(suspectingSilos[i], suspectingTimes[i]);
diff --git a/src/Azure/Orleans.Clustering.AzureStorage/OrleansSiloInstanceManager.cs b/src/Azure/Orleans.Clustering.AzureStorage/OrleansSiloInstanceManager.cs
index 05357d265..1b4fa8860 100644
--- a/src/Azure/Orleans.Clustering.AzureStorage/OrleansSiloInstanceManager.cs
+++ b/src/Azure/Orleans.Clustering.AzureStorage/OrleansSiloInstanceManager.cs
@@ -54,7 +54,7 @@ internal class OrleansSiloInstanceManager
             }
             catch (Exception ex)
             {
-                string errorMsg = string.Format("Exception trying to create or connect to the Azure table: {0}", ex.Message);
+                string errorMsg = $"Exception trying to create or connect to the Azure table: {ex.Message}";
                 instance.logger.Error((int)TableStorageErrorCode.AzureTable_33, errorMsg, ex);
                 throw new OrleansException(errorMsg, ex);
             }
@@ -133,7 +133,7 @@ public async Task<IList<Uri>> FindAllGatewayProxyEndpoints()
                 return gatewaySiloInstances;
             }catch(Exception exc)
             {
-                logger.Error(ErrorCode.Runtime_Error_100331, string.Format("Error searching for active gateway silos for deployment {0} ", this.DeploymentId), exc);
+                logger.Error(ErrorCode.Runtime_Error_100331, $"Error searching for active gateway silos for deployment {this.DeploymentId} ", exc);
                 throw;
             }
         }
@@ -145,7 +145,7 @@ public async Task<string> DumpSiloInstanceTable()
             SiloInstanceTableEntry[] entries = queryResults.Select(entry => entry.Item1).ToArray();
 
             var sb = new StringBuilder();
-            sb.Append(String.Format("Deployment {0}. Silos: ", DeploymentId));
+            sb.Append($"Deployment {DeploymentId}. Silos: ");
 
             // Loop through the results, displaying information about the entity
             Array.Sort(entries,
@@ -159,8 +159,7 @@ public async Task<string> DumpSiloInstanceTable()
                 });
             foreach (SiloInstanceTableEntry entry in entries)
             {
-                sb.AppendLine(String.Format("[IP {0}:{1}:{2}, {3}, Instance={4}, Status={5}]", entry.Address, entry.Port, entry.Generation,
-                    entry.HostName, entry.SiloName, entry.Status));
+                sb.AppendLine($"[IP {entry.Address}:{entry.Port}:{entry.Generation}, {entry.HostName}, Instance={entry.SiloName}, Status={entry.Status}]");
             }
             return sb.ToString();
         }
@@ -230,14 +229,14 @@ private async Task DeleteEntriesBatch(List<Tuple<SiloInstanceTableEntry, string>
 
             var asList = queryResults.ToList();
             if (asList.Count < 1 || asList.Count > 2)
-                throw new KeyNotFoundException(string.Format("Could not find table version row or found too many entries. Was looking for key {0}, found = {1}", siloAddress.ToLongString(), Utils.EnumerableToString(asList)));
+                throw new KeyNotFoundException($"Could not find table version row or found too many entries. Was looking for key {siloAddress.ToLongString()}, found = {Utils.EnumerableToString(asList)}");
 
             int numTableVersionRows = asList.Count(tuple => tuple.Item1.RowKey == SiloInstanceTableEntry.TABLE_VERSION_ROW);
             if (numTableVersionRows < 1)
-                throw new KeyNotFoundException(string.Format("Did not read table version row. Read = {0}", Utils.EnumerableToString(asList)));
+                throw new KeyNotFoundException($"Did not read table version row. Read = {Utils.EnumerableToString(asList)}");
 
             if (numTableVersionRows > 1)
-                throw new KeyNotFoundException(string.Format("Read {0} table version rows, while was expecting only 1. Read = {1}", numTableVersionRows, Utils.EnumerableToString(asList)));
+                throw new KeyNotFoundException($"Read {numTableVersionRows} table version rows, while was expecting only 1. Read = {Utils.EnumerableToString(asList)}");
 
             return asList;
         }
@@ -248,13 +247,13 @@ private async Task DeleteEntriesBatch(List<Tuple<SiloInstanceTableEntry, string>
 
             var asList = queryResults.ToList();
             if (asList.Count < 1)
-                throw new KeyNotFoundException(string.Format("Could not find enough rows in the FindAllSiloEntries call. Found = {0}", Utils.EnumerableToString(asList)));
+                throw new KeyNotFoundException($"Could not find enough rows in the FindAllSiloEntries call. Found = {Utils.EnumerableToString(asList)}");
 
             int numTableVersionRows = asList.Count(tuple => tuple.Item1.RowKey == SiloInstanceTableEntry.TABLE_VERSION_ROW);
             if (numTableVersionRows < 1)
-                throw new KeyNotFoundException(string.Format("Did not find table version row. Read = {0}", Utils.EnumerableToString(asList)));
+                throw new KeyNotFoundException($"Did not find table version row. Read = {Utils.EnumerableToString(asList)}");
             if (numTableVersionRows > 1)
-                throw new KeyNotFoundException(string.Format("Read {0} table version rows, while was expecting only 1. Read = {1}", numTableVersionRows, Utils.EnumerableToString(asList)));
+                throw new KeyNotFoundException($"Read {numTableVersionRows} table version rows, while was expecting only 1. Read = {Utils.EnumerableToString(asList)}");
 
             return asList;
         }
@@ -267,7 +266,7 @@ internal async Task<bool> TryCreateTableVersionEntryAsync()
             try
             {
                 var versionRow = await storage.ReadSingleTableEntryAsync(DeploymentId, SiloInstanceTableEntry.TABLE_VERSION_ROW);
-                if (versionRow != null && versionRow.Item1 != null)
+                if (versionRow?.Item1 != null)
                 {
                     return false;
                 }
diff --git a/src/Azure/Orleans.Clustering.AzureStorage/SiloInstanceTableEntry.cs b/src/Azure/Orleans.Clustering.AzureStorage/SiloInstanceTableEntry.cs
index f83480916..0ea68b7bb 100644
--- a/src/Azure/Orleans.Clustering.AzureStorage/SiloInstanceTableEntry.cs
+++ b/src/Azure/Orleans.Clustering.AzureStorage/SiloInstanceTableEntry.cs
@@ -36,7 +36,7 @@ internal class SiloInstanceTableEntry : TableEntity
 
         public static string ConstructRowKey(SiloAddress silo)
         {
-            return String.Format("{0}-{1}-{2}", silo.Endpoint.Address, silo.Endpoint.Port, silo.Generation);
+            return $"{silo.Endpoint.Address}-{silo.Endpoint.Port}-{silo.Generation}";
         }
         internal static SiloAddress UnpackRowKey(string rowKey)
         {
@@ -44,19 +44,19 @@ internal static SiloAddress UnpackRowKey(string rowKey)
             try
             {
 #if DEBUG
-                debugInfo = String.Format("UnpackRowKey: RowKey={0}", rowKey);
+                debugInfo = $"UnpackRowKey: RowKey={rowKey}";
                 Trace.TraceInformation(debugInfo);
 #endif
                 int idx1 = rowKey.IndexOf(Seperator);
                 int idx2 = rowKey.LastIndexOf(Seperator);
 #if DEBUG
-                debugInfo = String.Format("UnpackRowKey: RowKey={0} Idx1={1} Idx2={2}", rowKey, idx1, idx2);
+                debugInfo = $"UnpackRowKey: RowKey={rowKey} Idx1={idx1} Idx2={idx2}";
 #endif
                 var addressStr = rowKey.Substring(0, idx1);
                 var portStr = rowKey.Substring(idx1 + 1, idx2 - idx1 - 1);
                 var genStr = rowKey.Substring(idx2 + 1);
 #if DEBUG
-                debugInfo = String.Format("UnpackRowKey: RowKey={0} -> Address={1} Port={2} Generation={3}", rowKey, addressStr, portStr, genStr);
+                debugInfo = $"UnpackRowKey: RowKey={rowKey} -> Address={addressStr} Port={portStr} Generation={genStr}";
                 Trace.TraceInformation(debugInfo);
 #endif
                 IPAddress address = IPAddress.Parse(addressStr);
diff --git a/src/Azure/Orleans.Hosting.AzureCloudServices/Hosting/ServiceRuntimeWrapper.cs b/src/Azure/Orleans.Hosting.AzureCloudServices/Hosting/ServiceRuntimeWrapper.cs
index 41d67b12a..5c3bc3dce 100644
--- a/src/Azure/Orleans.Hosting.AzureCloudServices/Hosting/ServiceRuntimeWrapper.cs
+++ b/src/Azure/Orleans.Hosting.AzureCloudServices/Hosting/ServiceRuntimeWrapper.cs
@@ -145,8 +145,7 @@ public IPEndPoint GetIPEndpoint(string endpointName)
             }
             catch (Exception exc)
             {
-                string errorMsg = string.Format("Unable to obtain endpoint info for role {0} from role config parameter {1} -- Endpoints defined = [{2}]",
-                    RoleName, endpointName, string.Join(", ", instanceEndpoints));
+                string errorMsg = $"Unable to obtain endpoint info for role {RoleName} from role config parameter {endpointName} -- Endpoints defined = [{string.Join(", ", instanceEndpoints)}]";
 
                 logger.Error(ErrorCode.SiloEndpointConfigError, errorMsg, exc);
                 throw new OrleansException(errorMsg, exc);
diff --git a/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureBlobStorage.cs b/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureBlobStorage.cs
index 92f734faf..cf9aa70e2 100644
--- a/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureBlobStorage.cs
+++ b/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureBlobStorage.cs
@@ -103,7 +103,7 @@ public async Task ReadStateAsync(string grainType, GrainReference grainId, IGrai
             catch (Exception ex)
             {
                 logger.Error((int)AzureProviderErrorCode.AzureBlobProvider_ReadError,
-                    string.Format("Error reading: GrainType={0} Grainid={1} ETag={2} from BlobName={3} in Container={4} Exception={5}", grainType, grainId, grainState.ETag, blobName, container.Name, ex.Message),
+                    $"Error reading: GrainType={grainType} Grainid={grainId} ETag={grainState.ETag} from BlobName={blobName} in Container={container.Name} Exception={ex.Message}",
                     ex);
 
                 throw;
@@ -112,7 +112,7 @@ public async Task ReadStateAsync(string grainType, GrainReference grainId, IGrai
 
         private static string GetBlobName(string grainType, GrainReference grainId)
         {
-            return string.Format("{0}-{1}.json", grainType, grainId.ToKeyString());
+            return $"{grainType}-{grainId.ToKeyString()}.json";
         }
 
         /// <summary> Write state data function for this storage provider. </summary>
@@ -135,7 +135,7 @@ public async Task WriteStateAsync(string grainType, GrainReference grainId, IGra
             catch (Exception ex)
             {
                 logger.Error((int)AzureProviderErrorCode.AzureBlobProvider_WriteError,
-                    string.Format("Error writing: GrainType={0} Grainid={1} ETag={2} to BlobName={3} in Container={4} Exception={5}", grainType, grainId, grainState.ETag, blobName, container.Name, ex.Message),
+                    $"Error writing: GrainType={grainType} Grainid={grainId} ETag={grainState.ETag} to BlobName={blobName} in Container={container.Name} Exception={ex.Message}",
                     ex);
 
                 throw;
@@ -168,7 +168,7 @@ public async Task ClearStateAsync(string grainType, GrainReference grainId, IGra
             catch (Exception ex)
             {
                 logger.Error((int)AzureProviderErrorCode.AzureBlobProvider_ClearError,
-                  string.Format("Error clearing: GrainType={0} Grainid={1} ETag={2} BlobName={3} in Container={4} Exception={5}", grainType, grainId, grainState.ETag, blobName, container.Name, ex.Message),
+                  $"Error clearing: GrainType={grainType} Grainid={grainId} ETag={grainState.ETag} BlobName={blobName} in Container={container.Name} Exception={ex.Message}",
                   ex);
 
                 throw;
diff --git a/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs b/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs
index 37163cc4b..8b225a3a5 100644
--- a/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs
+++ b/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs
@@ -151,8 +151,7 @@ public async Task ClearStateAsync(string grainType, GrainReference grainReferenc
             }
             catch (Exception exc)
             {
-                logger.Error((int)AzureProviderErrorCode.AzureTableProvider_DeleteError, string.Format("Error {0}: GrainType={1} Grainid={2} ETag={3} from Table={4} Exception={5}",
-                    operation, grainType, grainReference, grainState.ETag, this.options.TableName, exc.Message), exc);
+                logger.Error((int)AzureProviderErrorCode.AzureTableProvider_DeleteError, $"Error {operation}: GrainType={grainType} Grainid={grainReference} ETag={grainState.ETag} from Table={this.options.TableName} Exception={exc.Message}", exc);
                 throw;
             }
         }
@@ -227,7 +226,7 @@ private void CheckMaxDataSize(int dataSize, int maxDataSize)
         {
             if (dataSize > maxDataSize)
             {
-                var msg = string.Format("Data too large to write to Azure table. Size={0} MaxSize={1}", dataSize, maxDataSize);
+                var msg = $"Data too large to write to Azure table. Size={dataSize} MaxSize={maxDataSize}";
                 logger.Error(0, msg);
                 throw new ArgumentOutOfRangeException("GrainState.Size", msg);
             }
@@ -386,7 +385,7 @@ internal object ConvertFromStorageFormat(DynamicTableEntity entity, Type stateTy
 
         private string GetKeyString(GrainReference grainReference)
         {
-            var key = String.Format("{0}_{1}", this.clusterOptions.ServiceId, grainReference.ToKeyString());
+            var key = $"{this.clusterOptions.ServiceId}_{grainReference.ToKeyString()}";
             return AzureTableUtils.SanitizeTableProperty(key);
         }
 
diff --git a/src/Azure/Orleans.Reminders.AzureStorage/Storage/AzureBasedReminderTable.cs b/src/Azure/Orleans.Reminders.AzureStorage/Storage/AzureBasedReminderTable.cs
index 9d5a77203..e8cb520bc 100644
--- a/src/Azure/Orleans.Reminders.AzureStorage/Storage/AzureBasedReminderTable.cs
+++ b/src/Azure/Orleans.Reminders.AzureStorage/Storage/AzureBasedReminderTable.cs
@@ -111,7 +111,7 @@ private static ReminderTableEntry ConvertToTableEntry(ReminderEntry remEntry, st
                 StartAt = LogFormatter.PrintDate(remEntry.StartAt),
                 Period = remEntry.Period.ToString(),
 
-                GrainRefConsistentHash = string.Format("{0:X8}", consistentHash),
+                GrainRefConsistentHash = $"{consistentHash:X8}",
                 ETag = remEntry.ETag,
             };
         }
diff --git a/src/Azure/Orleans.Reminders.AzureStorage/Storage/RemindersTableManager.cs b/src/Azure/Orleans.Reminders.AzureStorage/Storage/RemindersTableManager.cs
index 9539a45cb..4266b97bb 100644
--- a/src/Azure/Orleans.Reminders.AzureStorage/Storage/RemindersTableManager.cs
+++ b/src/Azure/Orleans.Reminders.AzureStorage/Storage/RemindersTableManager.cs
@@ -26,7 +26,7 @@ internal class ReminderTableEntry : TableEntity
 
         public static string ConstructRowKey(GrainReference grainRef, string reminderName)
         {
-            var key = string.Format("{0}-{1}", grainRef.ToKeyString(), reminderName);
+            var key = $"{grainRef.ToKeyString()}-{reminderName}";
             return AzureTableUtils.SanitizeTableProperty(key);
         }
 
diff --git a/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueBatchContainer.cs b/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueBatchContainer.cs
index 5e8a4656a..8930eede1 100644
--- a/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueBatchContainer.cs
+++ b/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueBatchContainer.cs
@@ -69,7 +69,7 @@ public bool ImportRequestContext()
 
         public override string ToString()
         {
-            return string.Format("[AzureQueueBatchContainer:Stream={0},#Items={1}]", StreamId, events.Count);
+            return $"[AzureQueueBatchContainer:Stream={StreamId},#Items={events.Count}]";
             //return string.Format("[AzureBatch:#Items={0},Items{1}]", events.Count, Utils.EnumerableToString(events.Select((e, i) => String.Format("{0}-{1}", e, sequenceToken.CreateSequenceTokenForEvent(i)))));
         }
     }
diff --git a/src/Azure/Orleans.Streaming.AzureStorage/Storage/AzureQueueDataManager.cs b/src/Azure/Orleans.Streaming.AzureStorage/Storage/AzureQueueDataManager.cs
index 5dafb3652..54e29c3b6 100644
--- a/src/Azure/Orleans.Streaming.AzureStorage/Storage/AzureQueueDataManager.cs
+++ b/src/Azure/Orleans.Streaming.AzureStorage/Storage/AzureQueueDataManager.cs
@@ -389,37 +389,37 @@ private void ValidateQueueName(string queueName)
             if (!(queueName.Length >= 3 && queueName.Length <= 63))
             {
                 // A queue name must be from 3 through 63 characters long.
-                throw new ArgumentException(String.Format("A queue name must be from 3 through 63 characters long, while your queueName length is {0}, queueName is {1}.", queueName.Length, queueName), queueName);
+                throw new ArgumentException($"A queue name must be from 3 through 63 characters long, while your queueName length is {queueName.Length}, queueName is {queueName}.", queueName);
             }
 
             if (!Char.IsLetterOrDigit(queueName.First()))
             {
                 // A queue name must start with a letter or number
-                throw new ArgumentException(String.Format("A queue name must start with a letter or number, while your queueName is {0}.", queueName), queueName);
+                throw new ArgumentException($"A queue name must start with a letter or number, while your queueName is {queueName}.", queueName);
             }
 
             if (!Char.IsLetterOrDigit(queueName.Last()))
             {
                 // The first and last letters in the queue name must be alphanumeric. The dash (-) character cannot be the first or last character.
-                throw new ArgumentException(String.Format("The last letter in the queue name must be alphanumeric, while your queueName is {0}.", queueName), queueName);
+                throw new ArgumentException($"The last letter in the queue name must be alphanumeric, while your queueName is {queueName}.", queueName);
             }
 
             if (!queueName.All(c => Char.IsLetterOrDigit(c) || c.Equals('-')))
             {
                 // A queue name can only contain letters, numbers, and the dash (-) character.
-                throw new ArgumentException(String.Format("A queue name can only contain letters, numbers, and the dash (-) character, while your queueName is {0}.", queueName), queueName);
+                throw new ArgumentException($"A queue name can only contain letters, numbers, and the dash (-) character, while your queueName is {queueName}.", queueName);
             }
 
             if (queueName.Contains("--"))
             {
                 // Consecutive dash characters are not permitted in the queue name.
-                throw new ArgumentException(String.Format("Consecutive dash characters are not permitted in the queue name, while your queueName is {0}.", queueName), queueName);
+                throw new ArgumentException($"Consecutive dash characters are not permitted in the queue name, while your queueName is {queueName}.", queueName);
             }
 
             if (queueName.Where(Char.IsLetter).Any(c => !Char.IsLower(c)))
             {
                 // All letters in a queue name must be lowercase.
-                throw new ArgumentException(String.Format("All letters in a queue name must be lowercase, while your queueName is {0}.", queueName), queueName);
+                throw new ArgumentException($"All letters in a queue name must be lowercase, while your queueName is {queueName}.", queueName);
             }
         }
     }
diff --git a/src/Azure/Orleans.Transactions.AzureStorage/TransactionalState/StateEntity.cs b/src/Azure/Orleans.Transactions.AzureStorage/TransactionalState/StateEntity.cs
index b69b9a663..aac128a2f 100644
--- a/src/Azure/Orleans.Transactions.AzureStorage/TransactionalState/StateEntity.cs
+++ b/src/Azure/Orleans.Transactions.AzureStorage/TransactionalState/StateEntity.cs
@@ -163,7 +163,7 @@ private void CheckMaxDataSize(int dataSize, int maxDataSize)
         {
             if (dataSize > maxDataSize)
             {
-                var msg = string.Format("Data too large to write to table. Size={0} MaxSize={1}", dataSize, maxDataSize);
+                var msg = $"Data too large to write to table. Size={dataSize} MaxSize={maxDataSize}";
                 throw new ArgumentOutOfRangeException("state", msg);
             }
         }
diff --git a/src/Azure/Shared/Storage/AzureTableDataManager.cs b/src/Azure/Shared/Storage/AzureTableDataManager.cs
index c611eb0cf..ba56c1367 100644
--- a/src/Azure/Shared/Storage/AzureTableDataManager.cs
+++ b/src/Azure/Shared/Storage/AzureTableDataManager.cs
@@ -524,7 +524,7 @@ public async Task DeleteTableEntriesAsync(IReadOnlyCollection<Tuple<T, string>>
                         TableQuerySegment<T> querySegment = null;
                         var list = new List<T>();
                         //ExecuteSegmentedAsync not supported in "WindowsAzure.Storage": "7.2.1" yet
-                        while (querySegment == null || querySegment.ContinuationToken != null)
+                        while (querySegment?.ContinuationToken != null)
                         {
                             querySegment = await Table.ExecuteQuerySegmentedAsync(cloudTableQuery, querySegment?.ContinuationToken);
                             list.AddRange(querySegment);
diff --git a/src/Azure/Shared/Storage/AzureTableUtils.cs b/src/Azure/Shared/Storage/AzureTableUtils.cs
index a2c841597..c72897c06 100644
--- a/src/Azure/Shared/Storage/AzureTableUtils.cs
+++ b/src/Azure/Shared/Storage/AzureTableUtils.cs
@@ -223,7 +223,7 @@ public static string SanitizeTableProperty(string key)
                 .Replace('?', '_');       // Question mark
 
             if (key.Length >= 1024)
-                throw new ArgumentException(string.Format("Key length {0} is too long to be an Azure table key. Key={1}", key.Length, key));
+                throw new ArgumentException($"Key length {key.Length} is too long to be an Azure table key. Key={key}");
 
             return key;
         }
@@ -231,8 +231,8 @@ public static string SanitizeTableProperty(string key)
         internal static bool AnalyzeReadException(Exception exc, int iteration, string tableName, ILogger logger)
         {
             bool isLastErrorRetriable;
-            var we = exc as WebException;
-            if (we != null)
+
+            if (exc is WebException we)
             {
                 isLastErrorRetriable = true;
                 var statusCode = we.Status;
@@ -282,17 +282,14 @@ internal static string PrintStorageException(Exception exception)
         {
             var storeExc = exception as StorageException;
             if(storeExc == null)
-                throw new ArgumentException(String.Format("Unexpected exception type {0}", exception.GetType().FullName));
+                throw new ArgumentException($"Unexpected exception type {exception.GetType().FullName}");
 
             var result = storeExc.RequestInformation;
             if (result == null) return storeExc.Message;
             var extendedError = storeExc.RequestInformation.ExtendedErrorInformation;
             if (extendedError == null)
             {
-                return String.Format("Message = {0}, HttpStatusCode = {1}, HttpStatusMessage = {2}.",
-                        storeExc.Message,
-                        result.HttpStatusCode,
-                        result.HttpStatusMessage);
+                return $"Message = {storeExc.Message}, HttpStatusCode = {result.HttpStatusCode}, HttpStatusMessage = {result.HttpStatusMessage}.";
 
             }
             return String.Format("Message = {0}, HttpStatusCode = {1}, HttpStatusMessage = {2}, " +
@@ -303,7 +300,7 @@ internal static string PrintStorageException(Exception exception)
                         extendedError.ErrorCode,
                         extendedError.ErrorMessage,
                         (extendedError.AdditionalDetails != null && extendedError.AdditionalDetails.Count > 0) ?
-                            String.Format(", ExtendedErrorInformation.AdditionalDetails = {0}", Utils.DictionaryToString(extendedError.AdditionalDetails)) : String.Empty);
+                            $", ExtendedErrorInformation.AdditionalDetails = {Utils.DictionaryToString(extendedError.AdditionalDetails)}" : String.Empty);
         }
 
         internal static string PointQuery(string partitionKey, string rowKey)
diff --git a/src/Orleans.CodeGenerator.MSBuild/LogFormatter.cs b/src/Orleans.CodeGenerator.MSBuild/LogFormatter.cs
index e2ef7e88f..cef40368e 100644
--- a/src/Orleans.CodeGenerator.MSBuild/LogFormatter.cs
+++ b/src/Orleans.CodeGenerator.MSBuild/LogFormatter.cs
@@ -37,9 +37,9 @@ private static string PrintException_Helper(Exception exception, int level, bool
                     }
                 }
             }
-            else if (exception is AggregateException)
+            else if (exception is AggregateException aggregateException)
             {
-                var innerExceptions = ((AggregateException)exception).InnerExceptions;
+                var innerExceptions = aggregateException.InnerExceptions;
                 if (innerExceptions == null) return sb.ToString();
 
                 foreach (Exception inner in innerExceptions)
diff --git a/src/Orleans.Core.Abstractions/CodeGeneration/GrainFactoryBase.cs b/src/Orleans.Core.Abstractions/CodeGeneration/GrainFactoryBase.cs
index 653fdfc59..8b82dd904 100644
--- a/src/Orleans.Core.Abstractions/CodeGeneration/GrainFactoryBase.cs
+++ b/src/Orleans.Core.Abstractions/CodeGeneration/GrainFactoryBase.cs
@@ -29,7 +29,7 @@ public static void CheckGrainObserverParamInternal(IGrainObserver grainObserver)
             }
             else
             {
-                string errMsg = string.Format("IGrainObserver parameters must be GrainReference or Grain and cannot be type {0}. Did you forget to CreateObjectReference?", grainObserver.GetType());
+                string errMsg = $"IGrainObserver parameters must be GrainReference or Grain and cannot be type {grainObserver.GetType()}. Did you forget to CreateObjectReference?";
                 throw new NotSupportedException(errMsg);
             }
         }
diff --git a/src/Orleans.Core.Abstractions/Core/GrainExtensions.cs b/src/Orleans.Core.Abstractions/Core/GrainExtensions.cs
index 06856921c..6717b7c8a 100644
--- a/src/Orleans.Core.Abstractions/Core/GrainExtensions.cs
+++ b/src/Orleans.Core.Abstractions/Core/GrainExtensions.cs
@@ -15,11 +15,9 @@ internal static GrainReference AsReference(this IAddressable grain)
             ThrowIfNullGrain(grain);
 
             // When called against an instance of a grain reference class, do nothing
-            var reference = grain as GrainReference;
-            if (reference != null) return reference;
+            if (grain is GrainReference reference) return reference;
 
-            var grainBase = grain as Grain;
-            if (grainBase != null)
+            if (grain is Grain grainBase)
             {
                 if (grainBase.Data?.GrainReference is GrainReference grainRef)
                 {
@@ -31,8 +29,7 @@ internal static GrainReference AsReference(this IAddressable grain)
                 }
             }
 
-            var systemTarget = grain as ISystemTargetBase;
-            if (systemTarget != null) return systemTarget.GrainReference;
+            if (grain is ISystemTargetBase systemTarget) return systemTarget.GrainReference;
 
             throw new ArgumentException(
                 $"AsWeaklyTypedReference has been called on an unexpected type: {grain.GetType().FullName}.",
@@ -92,7 +89,7 @@ public static GrainId GetGrainId(this IAddressable grain)
                 case ISystemTargetBase systemTarget:
                     return systemTarget.GrainId;
                 default:
-                    throw new ArgumentException(String.Format("GetGrainIdentity has been called on an unexpected type: {0}.", grain.GetType().FullName), "grain");
+                    throw new ArgumentException($"GetGrainIdentity has been called on an unexpected type: {grain.GetType().FullName}.", "grain");
             }
         }
 
diff --git a/src/Orleans.Core.Abstractions/Exceptions/DeadlockException.cs b/src/Orleans.Core.Abstractions/Exceptions/DeadlockException.cs
index 59513ee40..3c91a0797 100644
--- a/src/Orleans.Core.Abstractions/Exceptions/DeadlockException.cs
+++ b/src/Orleans.Core.Abstractions/Exceptions/DeadlockException.cs
@@ -46,10 +46,7 @@ protected DeadlockException(SerializationInfo info, StreamingContext context)
 
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            if (info != null)
-            {
-                info.AddValue("CallChain", this.CallChain, typeof(IEnumerable<GrainId>));
-            }
+            info?.AddValue("CallChain", this.CallChain, typeof(IEnumerable<GrainId>));
 
             base.GetObjectData(info, context);
         }
diff --git a/src/Orleans.Core.Abstractions/Exceptions/LimitExceededException.cs b/src/Orleans.Core.Abstractions/Exceptions/LimitExceededException.cs
index 43ff4ee92..18b7d92a8 100644
--- a/src/Orleans.Core.Abstractions/Exceptions/LimitExceededException.cs
+++ b/src/Orleans.Core.Abstractions/Exceptions/LimitExceededException.cs
@@ -22,7 +22,7 @@ public class LimitExceededException : OrleansException
         public LimitExceededException(string message, Exception innerException) : base(message, innerException) { }
 
         public LimitExceededException(string limitName, int current, int threshold, object extraInfo) 
-            : base(string.Format("Limit exceeded {0} Current={1} Threshold={2} {3}", limitName, current, threshold, extraInfo)) { }
+            : base($"Limit exceeded {limitName} Current={current} Threshold={threshold} {extraInfo}") { }
 
         protected LimitExceededException(SerializationInfo info, StreamingContext context)
             : base(info, context)
diff --git a/src/Orleans.Core.Abstractions/IDs/ActivationAddress.cs b/src/Orleans.Core.Abstractions/IDs/ActivationAddress.cs
index 431b5cc3f..e8f072245 100644
--- a/src/Orleans.Core.Abstractions/IDs/ActivationAddress.cs
+++ b/src/Orleans.Core.Abstractions/IDs/ActivationAddress.cs
@@ -44,11 +44,7 @@ public static ActivationAddress GetAddress(SiloAddress silo, GrainId grain, Acti
         public string ToFullString()
         {
             return
-                String.Format(
-                    "[ActivationAddress: {0}, Full GrainId: {1}, Full ActivationId: {2}]",
-                    this.ToString(),                        // 0
-                    this.Grain.ToString(),                  // 1
-                    this.Activation.ToFullString());        // 2
+                $"[ActivationAddress: {this.ToString()}, Full GrainId: {this.Grain.ToString()}, Full ActivationId: {this.Activation.ToFullString()}]";        // 2
         }
 
         public bool Matches(ActivationAddress other)
diff --git a/src/Orleans.Core.Abstractions/IDs/ActivationId.cs b/src/Orleans.Core.Abstractions/IDs/ActivationId.cs
index dad68fc17..40d544302 100644
--- a/src/Orleans.Core.Abstractions/IDs/ActivationId.cs
+++ b/src/Orleans.Core.Abstractions/IDs/ActivationId.cs
@@ -58,8 +58,7 @@ internal static ActivationId GetActivationId(UniqueKey key)
 
         public override bool Equals(object obj)
         {
-            var o = obj as ActivationId;
-            return o != null && Key.Equals(o.Key);
+            return obj is ActivationId o && Key.Equals(o.Key);
         }
 
         public bool Equals(ActivationId other)
diff --git a/src/Orleans.Core.Abstractions/IDs/Legacy/LegacyGrainId.cs b/src/Orleans.Core.Abstractions/IDs/Legacy/LegacyGrainId.cs
index be10256fd..4da6dc7d6 100644
--- a/src/Orleans.Core.Abstractions/IDs/Legacy/LegacyGrainId.cs
+++ b/src/Orleans.Core.Abstractions/IDs/Legacy/LegacyGrainId.cs
@@ -261,8 +261,7 @@ public bool Equals(LegacyGrainId other)
 
         public override bool Equals(object obj)
         {
-            var o = obj as LegacyGrainId;
-            return o != null && Key.Equals(o.Key);
+            return obj is LegacyGrainId o && Key.Equals(o.Key);
         }
 
         // Keep compiler happy -- it does not like classes to have Equals(...) without GetHashCode() methods
@@ -331,7 +330,7 @@ private string ToStringImpl(bool detailed)
                     fullString = "???/" + idString;
                     break;
             }
-            return detailed ? String.Format("{0}-0x{1, 8:X8}", fullString, GetUniformHashCode()) : fullString;
+            return detailed ? $"{fullString}-0x{GetUniformHashCode():X8}" : fullString;
         }
 
         public static bool IsLegacyGrainType(Type type)
diff --git a/src/Orleans.Core.Abstractions/IDs/Legacy/UniqueKey.cs b/src/Orleans.Core.Abstractions/IDs/Legacy/UniqueKey.cs
index a07f23b5c..3788f0574 100644
--- a/src/Orleans.Core.Abstractions/IDs/Legacy/UniqueKey.cs
+++ b/src/Orleans.Core.Abstractions/IDs/Legacy/UniqueKey.cs
@@ -152,9 +152,7 @@ private void ThrowIfHasKeyExt(string methodName)
         {
             if (KeyExt != null)
                 throw new InvalidOperationException(
-                    string.Format(
-                        "This overload of {0} cannot be used if the grain uses the primary key extension feature.",
-                        methodName));
+                    $"This overload of {methodName} cannot be used if the grain uses the primary key extension feature.");
         }
 
         public long PrimaryKeyToLong(out string extendedKey)
diff --git a/src/Orleans.Core.Abstractions/IDs/SiloAddress.cs b/src/Orleans.Core.Abstractions/IDs/SiloAddress.cs
index a015f68c2..e17f65b9e 100644
--- a/src/Orleans.Core.Abstractions/IDs/SiloAddress.cs
+++ b/src/Orleans.Core.Abstractions/IDs/SiloAddress.cs
@@ -83,7 +83,7 @@ public string ToParsableString()
             // This must be the "inverse" of FromParsableString, and must be the same across all silos in a deployment.
             // Basically, this should never change unless the data content of SiloAddress changes
             if (utf8 != null) return Encoding.UTF8.GetString(utf8);
-            return String.Format("{0}:{1}@{2}", Endpoint.Address, Endpoint.Port, Generation);
+            return $"{Endpoint.Address}:{Endpoint.Port}@{Generation}";
         }
 
         internal unsafe byte[] ToUtf8String()
diff --git a/src/Orleans.Core.Abstractions/Placement/StatelessWorkerPlacement.cs b/src/Orleans.Core.Abstractions/Placement/StatelessWorkerPlacement.cs
index f1df2c346..4c9b83963 100644
--- a/src/Orleans.Core.Abstractions/Placement/StatelessWorkerPlacement.cs
+++ b/src/Orleans.Core.Abstractions/Placement/StatelessWorkerPlacement.cs
@@ -31,7 +31,7 @@ public StatelessWorkerPlacement() : this(-1)
 
         public override string ToString()
         {
-            return string.Format("StatelessWorkerPlacement(max={0})", this.MaxLocal);
+            return $"StatelessWorkerPlacement(max={this.MaxLocal})";
         }
 
         public override void Initialize(GrainProperties properties)
diff --git a/src/Orleans.Core.Abstractions/Timers/IRemindable.cs b/src/Orleans.Core.Abstractions/Timers/IRemindable.cs
index e2b81106f..7f912561f 100644
--- a/src/Orleans.Core.Abstractions/Timers/IRemindable.cs
+++ b/src/Orleans.Core.Abstractions/Timers/IRemindable.cs
@@ -68,7 +68,7 @@ internal static TickStatus NewStruct(DateTime firstTickTime, TimeSpan period, Da
 
             public override String ToString()
             {
-                return String.Format("<{0}, {1}, {2}>", FirstTickTime, Period, CurrentTickTime);
+                return $"<{FirstTickTime}, {Period}, {CurrentTickTime}>";
             }
         }
 
diff --git a/src/Orleans.Core/Async/TaskExtensions.cs b/src/Orleans.Core/Async/TaskExtensions.cs
index 5debccfd4..b877b6854 100644
--- a/src/Orleans.Core/Async/TaskExtensions.cs
+++ b/src/Orleans.Core/Async/TaskExtensions.cs
@@ -193,7 +193,7 @@ public static async Task ExecuteAndIgnoreException(Func<Task> action)
 
         internal static String ToString(this Task t)
         {
-            return t == null ? "null" : string.Format("[Id={0}, Status={1}]", t.Id, Enum.GetName(typeof(TaskStatus), t.Status));
+            return t == null ? "null" : $"[Id={t.Id}, Status={Enum.GetName(typeof(TaskStatus), t.Status)}]";
         }
 
         public static void WaitWithThrow(this Task task, TimeSpan timeout)
diff --git a/src/Orleans.Core/CodeGeneration/TypeUtils.cs b/src/Orleans.Core/CodeGeneration/TypeUtils.cs
index 8635e0140..694d04edc 100644
--- a/src/Orleans.Core/CodeGeneration/TypeUtils.cs
+++ b/src/Orleans.Core/CodeGeneration/TypeUtils.cs
@@ -292,7 +292,7 @@ public static bool IsConcreteGrainClass(Type type, out IEnumerable<string> compl
             if (!IsGrainClass(type)) return false;
             if (!type.IsAbstract) return true;
 
-            complaints = complain ? new[] { string.Format("Grain type {0} is abstract and cannot be instantiated.", type.FullName) } : null;
+            complaints = complain ? new[] { $"Grain type {type.FullName} is abstract and cannot be instantiated." } : null;
             return false;
         }
 
@@ -483,8 +483,7 @@ string BuildParseableName()
         /// </returns>
         public static MethodInfo Method<T, TResult>(Expression<Func<T, TResult>> expression)
         {
-            var methodCall = expression.Body as MethodCallExpression;
-            if (methodCall != null)
+            if (expression.Body is MethodCallExpression methodCall)
             {
                 return methodCall.Method;
             }
@@ -509,8 +508,7 @@ string BuildParseableName()
         /// </returns>
         public static PropertyInfo Property<T, TResult>(Expression<Func<T, TResult>> expression)
         {
-            var property = expression.Body as MemberExpression;
-            if (property != null)
+            if (expression.Body is MemberExpression property)
             {
                 return property.Member as PropertyInfo;
             }
@@ -532,8 +530,7 @@ string BuildParseableName()
         /// </returns>
         public static PropertyInfo Property<TResult>(Expression<Func<TResult>> expression)
         {
-            var property = expression.Body as MemberExpression;
-            if (property != null)
+            if (expression.Body is MemberExpression property)
             {
                 return property.Member as PropertyInfo;
             }
@@ -547,8 +544,7 @@ public static PropertyInfo Property<TResult>(Expression<Func<TResult>> expressio
         /// <returns>The <see cref="MethodInfo"/> for the simple method call in the provided <paramref name="expression"/>.</returns>
         public static MethodInfo Method<T>(Expression<Func<T>> expression)
         {
-            var methodCall = expression.Body as MethodCallExpression;
-            if (methodCall != null)
+            if (expression.Body is MethodCallExpression methodCall)
             {
                 return methodCall.Method;
             }
@@ -563,8 +559,7 @@ public static MethodInfo Method<T>(Expression<Func<T>> expression)
         /// <returns>The <see cref="MethodInfo"/> for the simple method call in the provided <paramref name="expression"/>.</returns>
         public static MethodInfo Method<T>(Expression<Action<T>> expression)
         {
-            var methodCall = expression.Body as MethodCallExpression;
-            if (methodCall != null)
+            if (expression.Body is MethodCallExpression methodCall)
             {
                 return methodCall.Method;
             }
@@ -583,8 +578,7 @@ public static MethodInfo Method<T>(Expression<Action<T>> expression)
         /// </returns>
         public static MethodInfo Method(Expression<Action> expression)
         {
-            var methodCall = expression.Body as MethodCallExpression;
-            if (methodCall != null)
+            if (expression.Body is MethodCallExpression methodCall)
             {
                 return methodCall.Method;
             }
diff --git a/src/Orleans.Core/Configuration/LimitValue.cs b/src/Orleans.Core/Configuration/LimitValue.cs
index 9f54fb784..5b62ea0bb 100644
--- a/src/Orleans.Core/Configuration/LimitValue.cs
+++ b/src/Orleans.Core/Configuration/LimitValue.cs
@@ -24,8 +24,7 @@ public class LimitValue
 
         public override string ToString()
         {
-            return string.Format("Limit:{0},SoftLimitThreshold={1},HardLimitThreshold={2}",
-                Name, SoftLimitThreshold, HardLimitThreshold);
+            return $"Limit:{Name},SoftLimitThreshold={SoftLimitThreshold},HardLimitThreshold={HardLimitThreshold}";
         }
     }
 }
diff --git a/src/Orleans.Core/Logging/LogFormatter.cs b/src/Orleans.Core/Logging/LogFormatter.cs
index d353274a8..8b479f03a 100644
--- a/src/Orleans.Core/Logging/LogFormatter.cs
+++ b/src/Orleans.Core/Logging/LogFormatter.cs
@@ -57,10 +57,10 @@ private static string PrintException_Helper(Exception exception, int level, bool
             if (exception == null) return String.Empty;
             var sb = new StringBuilder();
             sb.Append(PrintOneException(exception, level, includeStackTrace));
-            if (exception is ReflectionTypeLoadException)
+            if (exception is ReflectionTypeLoadException reflectionTypeLoadException)
             {
                 Exception[] loaderExceptions =
-                    ((ReflectionTypeLoadException)exception).LoaderExceptions;
+                    reflectionTypeLoadException.LoaderExceptions;
                 if (loaderExceptions == null || loaderExceptions.Length == 0)
                 {
                     sb.Append("No LoaderExceptions found");
@@ -74,9 +74,9 @@ private static string PrintException_Helper(Exception exception, int level, bool
                     }
                 }
             }
-            else if (exception is AggregateException)
+            else if (exception is AggregateException aggregateException)
             {
-                var innerExceptions = ((AggregateException)exception).InnerExceptions;
+                var innerExceptions = aggregateException.InnerExceptions;
                 if (innerExceptions == null) return sb.ToString();
 
                 foreach (Exception inner in innerExceptions)
diff --git a/src/Orleans.Core/Messaging/ClientMessageCenter.cs b/src/Orleans.Core/Messaging/ClientMessageCenter.cs
index 6de1671a6..484bd76e1 100644
--- a/src/Orleans.Core/Messaging/ClientMessageCenter.cs
+++ b/src/Orleans.Core/Messaging/ClientMessageCenter.cs
@@ -335,7 +335,7 @@ private ValueTask<Connection> GetGatewayConnection(Message msg)
                 }
                 catch (Exception exception) when (directGatewayMessage)
                 {
-                    RejectMessage(message, string.Format("Target silo {0} is unavailable", message.TargetSilo), exception);
+                    RejectMessage(message, $"Target silo {message.TargetSilo} is unavailable", exception);
                     return null;
                 }
                 finally
diff --git a/src/Orleans.Core/Messaging/Message.cs b/src/Orleans.Core/Messaging/Message.cs
index 8009b8a20..6c42e0707 100644
--- a/src/Orleans.Core/Messaging/Message.cs
+++ b/src/Orleans.Core/Messaging/Message.cs
@@ -424,7 +424,7 @@ public override string ToString()
                         break;
 
                     case ResponseTypes.Rejection:
-                        response = string.Format("{0} Rejection (info: {1}) ", RejectionType, RejectionInfo);
+                        response = $"{RejectionType} Rejection (info: {RejectionInfo}) ";
                         break;
 
                     case ResponseTypes.Status:
@@ -435,17 +435,7 @@ public override string ToString()
                         break;
                 }
             }
-            return String.Format("{0}{1}{2}{3}{4} {5}->{6}{7} #{8}{9}",
-                IsReadOnly ? "ReadOnly " : "", //0
-                IsAlwaysInterleave ? "IsAlwaysInterleave " : "", //1
-                IsNewPlacement ? "NewPlacement " : "", // 2
-                response,  //3
-                Direction, //4
-                $"[{SendingSilo} {SendingGrain} {SendingActivation}]", //5
-                $"[{TargetSilo} {TargetGrain} {TargetActivation}]", //6
-                BodyObject is InvokeMethodRequest request ? $" {request.ToString()}" : string.Empty, // 7
-                Id, //8
-                ForwardCount > 0 ? "[ForwardCount=" + ForwardCount + "]" : ""); //9
+            return $"{(IsReadOnly ? "ReadOnly " : "")}{(IsAlwaysInterleave ? "IsAlwaysInterleave " : "")}{(IsNewPlacement ? "NewPlacement " : "")}{response}{Direction} {$"[{SendingSilo} {SendingGrain} {SendingActivation}]"}->{$"[{TargetSilo} {TargetGrain} {TargetActivation}]"}{(BodyObject is InvokeMethodRequest request ? $" {request.ToString()}" : string.Empty)} #{Id}{(ForwardCount > 0 ? "[ForwardCount=" + ForwardCount + "]" : "")}"; //9
         }
 
         internal void SetTargetPlacement(PlacementResult value)
diff --git a/src/Orleans.Core/Providers/IGrainStorage.cs b/src/Orleans.Core/Providers/IGrainStorage.cs
index a1995084a..b58bf495d 100644
--- a/src/Orleans.Core/Providers/IGrainStorage.cs
+++ b/src/Orleans.Core/Providers/IGrainStorage.cs
@@ -129,8 +129,7 @@ public InconsistentStateException(string storedEtag, string currentEtag, Excepti
 
         public override string ToString()
         {
-            return String.Format("InconsistentStateException: {0} Expected Etag={1} Received Etag={2} {3}",
-                Message, StoredEtag, CurrentEtag, InnerException);
+            return $"InconsistentStateException: {Message} Expected Etag={StoredEtag} Received Etag={CurrentEtag} {InnerException}";
         }
 
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
diff --git a/src/Orleans.Core/Runtime/GrainReferenceRuntime.cs b/src/Orleans.Core/Runtime/GrainReferenceRuntime.cs
index d78c94d03..976e97d53 100644
--- a/src/Orleans.Core/Runtime/GrainReferenceRuntime.cs
+++ b/src/Orleans.Core/Runtime/GrainReferenceRuntime.cs
@@ -122,7 +122,7 @@ private static void CheckForGrainArguments(object[] arguments)
             {
                 if (argument is Grain)
                 {
-                    throw new ArgumentException(String.Format("Cannot pass a grain object {0} as an argument to a method. Pass this.AsReference<GrainInterface>() instead.", argument.GetType().FullName));
+                    throw new ArgumentException($"Cannot pass a grain object {argument.GetType().FullName} as an argument to a method. Pass this.AsReference<GrainInterface>() instead.");
                 }
             }
         }
diff --git a/src/Orleans.Core/Runtime/HashRing.cs b/src/Orleans.Core/Runtime/HashRing.cs
index 2afb99629..7e0f0937c 100644
--- a/src/Orleans.Core/Runtime/HashRing.cs
+++ b/src/Orleans.Core/Runtime/HashRing.cs
@@ -46,7 +46,7 @@ public override string ToString()
                 typeof(T).Name,
                 Utils.EnumerableToString(
                     sortedRingList,
-                    elem => String.Format("{0}/x{1,8:X8}", elem, elem.GetUniformHashCode()),
+                    elem => $"{elem}/x{elem.GetUniformHashCode():X8}",
                     Environment.NewLine,
                     false));
         }
diff --git a/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs b/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs
index e5b4e18d3..7dfa20994 100644
--- a/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs
+++ b/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs
@@ -142,8 +142,7 @@ internal void ConsumeServices(IServiceProvider services)
                 logger.Info(ErrorCode.ClientInitializing, string.Format(
                     "{0} Initializing OutsideRuntimeClient on {1} at {2} Client Id = {3} {0}",
                     BARS, Dns.GetHostName(), localAddress,  clientId));
-                string startMsg = string.Format("{0} Starting OutsideRuntimeClient with runtime Version='{1}' in AppDomain={2}",
-                    BARS, RuntimeVersion.Current, PrintAppDomainDetails());
+                string startMsg = $"{BARS} Starting OutsideRuntimeClient with runtime Version='{RuntimeVersion.Current}' in AppDomain={PrintAppDomainDetails()}";
                 logger.Info(ErrorCode.ClientStarting, startMsg);
 
                 if (TestOnlyThrowExceptionDuringInit)
@@ -357,10 +356,7 @@ public void Reset(bool cleanup)
         {
             Utils.SafeExecute(() =>
             {
-                if (logger != null)
-                {
-                    logger.Info("OutsideRuntimeClient.Reset(): client Id " + clientId);
-                }
+                logger?.Info("OutsideRuntimeClient.Reset(): client Id " + clientId);
             }, this.logger);
 
             Utils.SafeExecute(() =>
@@ -370,17 +366,11 @@ public void Reset(bool cleanup)
 
             Utils.SafeExecute(() =>
                 {
-                    if (MessageCenter != null)
-                    {
-                        MessageCenter.Stop();
-                    }
+                    MessageCenter?.Stop();
                 }, logger, "Client.Stop-Transport");
             Utils.SafeExecute(() =>
             {
-                if (ClientStatistics != null)
-                {
-                    ClientStatistics.Stop();
-                }
+                ClientStatistics?.Stop();
             }, logger, "Client.Stop-ClientStatistics");
             ConstructorReset();
         }
@@ -389,10 +379,7 @@ private void ConstructorReset()
         {
             Utils.SafeExecute(() =>
             {
-                if (logger != null)
-                {
-                    logger.Info("OutsideRuntimeClient.ConstructorReset(): client Id " + clientId);
-                }
+                logger?.Info("OutsideRuntimeClient.ConstructorReset(): client Id " + clientId);
             });
             
             Utils.SafeExecute(() => this.Dispose());
@@ -445,7 +432,7 @@ public void DeleteObjectReference(IAddressable obj)
 
         private string PrintAppDomainDetails()
         {
-            return string.Format("<AppDomain.Id={0}, AppDomain.FriendlyName={1}>", AppDomain.CurrentDomain.Id, AppDomain.CurrentDomain.FriendlyName);
+            return $"<AppDomain.Id={AppDomain.CurrentDomain.Id}, AppDomain.FriendlyName={AppDomain.CurrentDomain.FriendlyName}>";
         }
 
         public void Dispose()
diff --git a/src/Orleans.Core/Runtime/RingRange.cs b/src/Orleans.Core/Runtime/RingRange.cs
index 1bfd37784..d6a170f8c 100644
--- a/src/Orleans.Core/Runtime/RingRange.cs
+++ b/src/Orleans.Core/Runtime/RingRange.cs
@@ -264,14 +264,14 @@ public override string ToString()
         {
             if (ranges.Count == 0) return "Empty MultiRange";
             if (ranges.Count == 1) return ranges[0].ToString();
-            return String.Format("<MultiRange: Size=x{0,8:X8}, %Ring={1:0.000}%>", RangeSize(), RangePercentage());
+            return $"<MultiRange: Size=x{RangeSize():X8}, %Ring={RangePercentage():0.000}%>";
         }
 
         public string ToFullString()
         {
             if (ranges.Count == 0) return "Empty MultiRange";
             if (ranges.Count == 1) return ranges[0].ToString();
-            return String.Format("<MultiRange: Size=x{0,8:X8}, %Ring={1:0.000}%, {2} Ranges: {3}>", RangeSize(), RangePercentage(), ranges.Count, Utils.EnumerableToString(ranges, r => r.ToFullString()));
+            return $"<MultiRange: Size=x{RangeSize():X8}, %Ring={RangePercentage():0.000}%, {ranges.Count} Ranges: {Utils.EnumerableToString(ranges, r => r.ToFullString())}>";
         }
     }
 
diff --git a/src/Orleans.Core/Serialization/BinaryTokenStreamReader.cs b/src/Orleans.Core/Serialization/BinaryTokenStreamReader.cs
index 59ecff7b3..623b99a20 100644
--- a/src/Orleans.Core/Serialization/BinaryTokenStreamReader.cs
+++ b/src/Orleans.Core/Serialization/BinaryTokenStreamReader.cs
@@ -646,8 +646,7 @@ private byte[] CheckLength(int n, out int offset, out bool safeToUse)
             if ((CurrentPosition + n > totalLength))
             {
                 throw new SerializationException(
-                    String.Format("Attempt to read past the end of the input stream: CurrentPosition={0}, n={1}, totalLength={2}",
-                    CurrentPosition, n, totalLength));
+                    $"Attempt to read past the end of the input stream: CurrentPosition={CurrentPosition}, n={n}, totalLength={totalLength}");
             }
 
             var temp = new byte[n];
@@ -665,7 +664,7 @@ private byte[] CheckLength(int n, out int offset, out bool safeToUse)
                     if (currentSegmentIndex >= buffersCount)
                     {
                         throw new SerializationException(
-                            String.Format("Attempt to read past buffers.Count: currentSegmentIndex={0}, buffers.Count={1}.", currentSegmentIndex, buffers.Count));
+                            $"Attempt to read past buffers.Count: currentSegmentIndex={currentSegmentIndex}, buffers.Count={buffers.Count}.");
                     }
 
                     StartNextSegment();
@@ -986,7 +985,7 @@ private void Trace(string format, params object[] args)
         {
             if (trace == null)
             {
-                var path = String.Format("d:\\Trace-{0}.{1}.{2}.txt", DateTime.UtcNow.Hour, DateTime.UtcNow.Minute, DateTime.UtcNow.Ticks);
+                var path = $"d:\\Trace-{DateTime.UtcNow.Hour}.{DateTime.UtcNow.Minute}.{DateTime.UtcNow.Ticks}.txt";
                 Console.WriteLine("Opening trace file at '{0}'", path);
                 trace = File.CreateText(path);
             }
diff --git a/src/Orleans.Core/Serialization/BinaryTokenStreamWriter.cs b/src/Orleans.Core/Serialization/BinaryTokenStreamWriter.cs
index b916c9f0c..b8e729ff5 100644
--- a/src/Orleans.Core/Serialization/BinaryTokenStreamWriter.cs
+++ b/src/Orleans.Core/Serialization/BinaryTokenStreamWriter.cs
@@ -589,7 +589,7 @@ private void Trace(string format, params object[] args)
         {
             if (trace == null)
             {
-                var path = String.Format("d:\\Trace-{0}.{1}.{2}.txt", DateTime.UtcNow.Hour, DateTime.UtcNow.Minute, DateTime.UtcNow.Ticks);
+                var path = $"d:\\Trace-{DateTime.UtcNow.Hour}.{DateTime.UtcNow.Minute}.{DateTime.UtcNow.Ticks}.txt";
                 Console.WriteLine("Opening trace file at '{0}'", path);
                 trace = File.CreateText(path);
             }
diff --git a/src/Orleans.Core/Serialization/ILBasedExceptionSerializer.cs b/src/Orleans.Core/Serialization/ILBasedExceptionSerializer.cs
index 3d47f03eb..e6dd4917f 100644
--- a/src/Orleans.Core/Serialization/ILBasedExceptionSerializer.cs
+++ b/src/Orleans.Core/Serialization/ILBasedExceptionSerializer.cs
@@ -80,10 +80,8 @@ public void Serialize(object item, ISerializationContext outerContext, Type expe
             
             var actualType = item.GetType();
 
-            // To support loss-free serialization where possible, instances of the fallback exception type are serialized in a
-            // semi-manual fashion.
-            var fallbackException = item as RemoteNonDeserializableException;
-            if (fallbackException != null)
+            // To support loss-free serialization where possible, instances of the fallback exception type are serialized in a            // semi-manual fashion.
+            if (item is RemoteNonDeserializableException fallbackException)
             {
                 this.ReserializeFallback(fallbackException, outerContext);
                 return;
diff --git a/src/Orleans.Core/Serialization/SerializationManager.cs b/src/Orleans.Core/Serialization/SerializationManager.cs
index a5d9865da..319a5d0c4 100644
--- a/src/Orleans.Core/Serialization/SerializationManager.cs
+++ b/src/Orleans.Core/Serialization/SerializationManager.cs
@@ -618,10 +618,8 @@ public static object DeepCopyInner(object original, ICopyContext context)
 
         private object DeepCopierHelper(Type t, object original, ICopyContext context)
         {
-            // Arrays are all that's left. 
-            // Handling arbitrary-rank arrays is a bit complex, but why not?
-            var originalArray = original as Array;
-            if (originalArray != null)
+            // Arrays are all that's left.             // Handling arbitrary-rank arrays is a bit complex, but why not?
+            if (original is Array originalArray)
             {
                 if (originalArray.Rank == 1 && originalArray.GetLength(0) == 0)
                 {
diff --git a/src/Orleans.Core/Statistics/AverageValueStatistic.cs b/src/Orleans.Core/Statistics/AverageValueStatistic.cs
index 12270911d..0cccc2807 100644
--- a/src/Orleans.Core/Statistics/AverageValueStatistic.cs
+++ b/src/Orleans.Core/Statistics/AverageValueStatistic.cs
@@ -71,8 +71,8 @@ internal class MultiThreadedAverageValueStatistic : AverageValueStatistic
         internal MultiThreadedAverageValueStatistic(StatisticName name)
             : base(name)
         {
-            totalSum = CounterStatistic.FindOrCreate(new StatisticName(String.Format("{0}.{1}", name.Name, "TotalSum.Hidden")), false, CounterStorage.DontStore);
-            numItems = CounterStatistic.FindOrCreate(new StatisticName(String.Format("{0}.{1}", name.Name, "NumItems.Hidden")), false, CounterStorage.DontStore);
+            totalSum = CounterStatistic.FindOrCreate(new StatisticName($"{name.Name}.{"TotalSum.Hidden"}"), false, CounterStorage.DontStore);
+            numItems = CounterStatistic.FindOrCreate(new StatisticName($"{name.Name}.{"NumItems.Hidden"}"), false, CounterStorage.DontStore);
         }
 
         public override void AddValue(long value)
diff --git a/src/Orleans.Core/Statistics/HistogramValueStatistic.cs b/src/Orleans.Core/Statistics/HistogramValueStatistic.cs
index f232c89fa..599dc7235 100644
--- a/src/Orleans.Core/Statistics/HistogramValueStatistic.cs
+++ b/src/Orleans.Core/Statistics/HistogramValueStatistic.cs
@@ -23,7 +23,7 @@ protected HistogramValueStatistic(string name, int numBuckets)
             // Create a hidden counter per bucket to reuse the counter code for efficient counting without reporting each individual counter as a statistic.
             for (int i = 0; i < numBuckets; i++)
                 Buckets[i] = CounterStatistic.FindOrCreate(
-                    new StatisticName(String.Format("{0}.Bucket#{1}", name, i)),
+                    new StatisticName($"{name}.Bucket#{i}"),
                     false,
                     CounterStorage.DontStore,
                     isHidden: true);
diff --git a/src/Orleans.Core/Statistics/IPerformanceMetrics.cs b/src/Orleans.Core/Statistics/IPerformanceMetrics.cs
index 3226e6cb3..e2ba3e265 100644
--- a/src/Orleans.Core/Statistics/IPerformanceMetrics.cs
+++ b/src/Orleans.Core/Statistics/IPerformanceMetrics.cs
@@ -147,7 +147,7 @@ internal class GrainStatistic
         /// </summary>
         public override string ToString()
         {
-            return string.Format("GrainStatistic: GrainType={0} NumSilos={1} NumGrains={2} NumActivations={3} ", GrainType, SiloCount, GrainCount, ActivationCount);
+            return $"GrainStatistic: GrainType={GrainType} NumSilos={SiloCount} NumGrains={GrainCount} NumActivations={ActivationCount} ";
         }
     }
 
@@ -177,7 +177,7 @@ public class SimpleGrainStatistic
         /// </summary>
         public override string ToString()
         {
-            return string.Format("SimpleGrainStatistic: GrainType={0} Silo={1} NumActivations={2} ", GrainType, SiloAddress, ActivationCount);
+            return $"SimpleGrainStatistic: GrainType={GrainType} Silo={SiloAddress} NumActivations={ActivationCount} ";
         }
     }
 
@@ -242,7 +242,7 @@ public override string ToString()
                     PrimaryForGrain,                                            // {5}
                     GrainClassTypeName,                                         // {6}
                     Utils.EnumerableToString(LocalActivations,                  // {7}
-                        str => string.Format("      {0}", str), "\n"));
+                        str => $"      {str}", "\n"));
         }
     }
 }
diff --git a/src/Orleans.Core/Statistics/LogStatistics.cs b/src/Orleans.Core/Statistics/LogStatistics.cs
index 9fd06b95e..9f951e981 100644
--- a/src/Orleans.Core/Statistics/LogStatistics.cs
+++ b/src/Orleans.Core/Statistics/LogStatistics.cs
@@ -51,10 +51,7 @@ private Task Reporter(object context)
 
         public void Stop()
         {
-            if (reportTimer != null)
-            {
-                reportTimer.Dispose();
-            }
+            reportTimer?.Dispose();
             reportTimer = null;
         }
 
diff --git a/src/Orleans.Core/Statistics/SchedulerStatisticsGroup.cs b/src/Orleans.Core/Statistics/SchedulerStatisticsGroup.cs
index 03414a7e2..12eb3e664 100644
--- a/src/Orleans.Core/Statistics/SchedulerStatisticsGroup.cs
+++ b/src/Orleans.Core/Statistics/SchedulerStatisticsGroup.cs
@@ -77,11 +77,11 @@ internal void UnRegisterWorkItemGroup(int workItemGroup)
         {
             Utils.SafeExecute(() => CounterStatistic.Delete(turnsExecutedPerWorkItemGroup[workItemGroup].Name),
                 logger,
-                () => String.Format("SchedulerStatisticsGroup.UnRegisterWorkItemGroup({0})", turnsExecutedPerWorkItemGroup[workItemGroup].Name));
+                () => $"SchedulerStatisticsGroup.UnRegisterWorkItemGroup({turnsExecutedPerWorkItemGroup[workItemGroup].Name})");
 
             Utils.SafeExecute(() => StringValueStatistic.Delete(workItemGroupStatuses[workItemGroup].Name),
                 logger,
-                () => String.Format("SchedulerStatisticsGroup.UnRegisterWorkItemGroup({0})", workItemGroupStatuses[workItemGroup].Name));  
+                () => $"SchedulerStatisticsGroup.UnRegisterWorkItemGroup({workItemGroupStatuses[workItemGroup].Name})");  
         }
     }
 }
diff --git a/src/Orleans.Core/SystemTargetInterfaces/IMembershipTable.cs b/src/Orleans.Core/SystemTargetInterfaces/IMembershipTable.cs
index 55501d33d..00e80f375 100644
--- a/src/Orleans.Core/SystemTargetInterfaces/IMembershipTable.cs
+++ b/src/Orleans.Core/SystemTargetInterfaces/IMembershipTable.cs
@@ -135,7 +135,7 @@ public TableVersion Next()
 
         public override string ToString()
         {
-            return string.Format("<{0}, {1}>", Version, VersionEtag);
+            return $"<{Version}, {VersionEtag}>";
         }
     }
 
@@ -191,19 +191,9 @@ public override string ToString()
             int shuttingDown = Members.Count(e => e.Item1.Status == SiloStatus.ShuttingDown);
             int stopping = Members.Count(e => e.Item1.Status == SiloStatus.Stopping);
 
-            string otherCounts = String.Format("{0}{1}{2}{3}",
-                                created > 0 ? (", " + created + " are Created") : "",
-                                joining > 0 ? (", " + joining + " are Joining") : "",
-                                shuttingDown > 0 ? (", " + shuttingDown + " are ShuttingDown") : "",
-                                stopping > 0 ? (", " + stopping + " are Stopping") : "");
-
-            return string.Format("{0} silos, {1} are Active, {2} are Dead{3}, Version={4}. All silos: {5}",
-                Members.Count,
-                active,
-                dead,
-                otherCounts,
-                Version,
-                Utils.EnumerableToString(Members, tuple => tuple.Item1.ToFullString()));
+            string otherCounts = $"{(created > 0 ? (", " + created + " are Created") : "")}{(joining > 0 ? (", " + joining + " are Joining") : "")}{(shuttingDown > 0 ? (", " + shuttingDown + " are ShuttingDown") : "")}{(stopping > 0 ? (", " + stopping + " are Stopping") : "")}";
+
+            return $"{Members.Count} silos, {active} are Active, {dead} are Dead{otherCounts}, Version={Version}. All silos: {Utils.EnumerableToString(Members, tuple => tuple.Item1.ToFullString())}";
         }
 
         // return a copy of the table removing all dead appereances of dead nodes, except for the last one.
@@ -352,7 +342,7 @@ internal MembershipEntry WithStatus(SiloStatus status)
 
         public override string ToString()
         {
-            return string.Format("SiloAddress={0} SiloName={1} Status={2}", SiloAddress.ToLongString(), SiloName, Status);
+            return $"SiloAddress={SiloAddress.ToLongString()} SiloName={SiloName} Status={Status}";
         }
 
         public string ToFullString(bool full = false)
diff --git a/src/Orleans.Core/SystemTargetInterfaces/IReminderTable.cs b/src/Orleans.Core/SystemTargetInterfaces/IReminderTable.cs
index 2c925b58c..79283b61c 100644
--- a/src/Orleans.Core/SystemTargetInterfaces/IReminderTable.cs
+++ b/src/Orleans.Core/SystemTargetInterfaces/IReminderTable.cs
@@ -81,8 +81,7 @@ public ReminderTableData()
 
         public override string ToString()
         {
-            return string.Format("[{0} reminders: {1}.", Reminders.Count, 
-                Utils.EnumerableToString(Reminders, e => e.ToString()));
+            return $"[{Reminders.Count} reminders: {Utils.EnumerableToString(Reminders, e => e.ToString())}.";
         }
     }
 
@@ -116,7 +115,7 @@ public class ReminderEntry
 
         public override string ToString()
         {
-            return string.Format("<GrainRef={0} ReminderName={1} Period={2}>", GrainRef.ToString(), ReminderName, Period);
+            return $"<GrainRef={GrainRef.ToString()} ReminderName={ReminderName} Period={Period}>";
         }
 
         internal IGrainReminder ToIGrainReminder()
@@ -141,7 +140,7 @@ internal ReminderData(GrainReference grainRef, string reminderName, string eTag)
 
         public override string ToString()
         {
-            return string.Format("<IOrleansReminder: GrainRef={0} ReminderName={1} ETag={2}>", GrainRef.ToString(), ReminderName, ETag);
+            return $"<IOrleansReminder: GrainRef={GrainRef.ToString()} ReminderName={ReminderName} ETag={ETag}>";
         }
     }
 }
diff --git a/src/Orleans.Core/Telemetry/Consumers/FileTelemetryConsumer.cs b/src/Orleans.Core/Telemetry/Consumers/FileTelemetryConsumer.cs
index bd14604ad..91aa67e77 100644
--- a/src/Orleans.Core/Telemetry/Consumers/FileTelemetryConsumer.cs
+++ b/src/Orleans.Core/Telemetry/Consumers/FileTelemetryConsumer.cs
@@ -75,8 +75,7 @@ public void Close()
             }
             catch (Exception exc)
             {
-                var msg = string.Format("Ignoring error closing log file {0} - {1}", _logFileName,
-                    LogFormatter.PrintException(exc));
+                var msg = $"Ignoring error closing log file {_logFileName} - {LogFormatter.PrintException(exc)}";
                 Console.WriteLine(msg);
             }
             finally
diff --git a/src/Orleans.Core/Timers/SafeTimerBase.cs b/src/Orleans.Core/Timers/SafeTimerBase.cs
index 8d822b5e0..35b2dd358 100644
--- a/src/Orleans.Core/Timers/SafeTimerBase.cs
+++ b/src/Orleans.Core/Timers/SafeTimerBase.cs
@@ -48,7 +48,7 @@ internal SafeTimerBase(ILogger logger, TimerCallback syncCallback, object state,
 
         public void Start(TimeSpan due, TimeSpan period)
         {
-            if (timerStarted) throw new InvalidOperationException(String.Format("Calling start on timer {0} is not allowed, since it was already created in a started mode with specified due.", GetFullName()));
+            if (timerStarted) throw new InvalidOperationException($"Calling start on timer {GetFullName()} is not allowed, since it was already created in a started mode with specified due.");
             if (period == TimeSpan.Zero) throw new ArgumentOutOfRangeException("period", period, "Cannot use TimeSpan.Zero for timer period");
            
             timerFrequency = period;
@@ -108,7 +108,7 @@ internal void DisposeTimer()
                 catch (Exception exc)
                 {
                     logger.Warn(ErrorCode.TimerDisposeError,
-                        string.Format("Ignored error disposing timer {0}", GetFullName()), exc);
+                        $"Ignored error disposing timer {GetFullName()}", exc);
                 }
             }
         }
@@ -127,7 +127,7 @@ private string GetFullName()
         public bool CheckTimerFreeze(DateTime lastCheckTime, Func<string> callerName)
         {
             return CheckTimerDelay(previousTickTime, totalNumTicks,
-                        dueTime, timerFrequency, logger, () => String.Format("{0}.{1}", GetFullName(), callerName()), ErrorCode.Timer_SafeTimerIsNotTicking, true);
+                        dueTime, timerFrequency, logger, () => $"{GetFullName()}.{callerName()}", ErrorCode.Timer_SafeTimerIsNotTicking, true);
         }
 
         public static bool CheckTimerDelay(DateTime previousTickTime, int totalNumTicks, 
@@ -147,12 +147,7 @@ public bool CheckTimerFreeze(DateTime lastCheckTime, Func<string> callerName)
             if (timeSinceLastTick <= exceptedTimeWithSlack) return true;
 
             // did not tick in the last period.
-            var errMsg = String.Format("{0}{1} did not fire on time. Last fired at {2}, {3} since previous fire, should have fired after {4}.",
-                freezeCheck ? "Watchdog Freeze Alert: " : "-", // 0
-                getName == null ? "" : getName(),   // 1
-                LogFormatter.PrintDate(previousTickTime), // 2
-                timeSinceLastTick,                  // 3
-                exceptedTimeToNexTick);             // 4
+            var errMsg = $"{(freezeCheck ? "Watchdog Freeze Alert: " : "-")}{(getName == null ? "" : getName())} did not fire on time. Last fired at {LogFormatter.PrintDate(previousTickTime)}, {timeSinceLastTick} since previous fire, should have fired after {exceptedTimeToNexTick}.";             // 4
 
             if(freezeCheck)
             {
@@ -173,7 +168,7 @@ public bool CheckTimerFreeze(DateTime lastCheckTime, Func<string> callerName)
         [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
         private bool Change(TimeSpan newDueTime, TimeSpan period)
         {
-            if (period == TimeSpan.Zero) throw new ArgumentOutOfRangeException("period", period, string.Format("Cannot use TimeSpan.Zero for timer {0} period", GetFullName()));
+            if (period == TimeSpan.Zero) throw new ArgumentOutOfRangeException("period", period, $"Cannot use TimeSpan.Zero for timer {GetFullName()} period");
 
             if (timer == null) return false;
 
@@ -189,7 +184,7 @@ private bool Change(TimeSpan newDueTime, TimeSpan period)
             catch (Exception exc)
             {
                 logger.Warn(ErrorCode.TimerChangeError,
-                    string.Format("Error changing timer period - timer {0} not changed", GetFullName()), exc);
+                    $"Error changing timer period - timer {GetFullName()} not changed", exc);
                 return false;
             }
         }
@@ -219,7 +214,7 @@ private void HandleSyncTimerCallback(object state)
             }
             catch (Exception exc)
             {
-                logger.Warn(ErrorCode.TimerCallbackError, string.Format("Ignored exception {0} during sync timer callback {1}", exc.Message, GetFullName()), exc);
+                logger.Warn(ErrorCode.TimerCallbackError, $"Ignored exception {exc.Message} during sync timer callback {GetFullName()}", exc);
             }
             finally
             {
@@ -250,7 +245,7 @@ private async void HandleAsyncTaskTimerCallback(object state)
             }
             catch (Exception exc)
             {
-                logger.Warn(ErrorCode.TimerCallbackError, string.Format("Ignored exception {0} during async task timer callback {1}", exc.Message, GetFullName()), exc);
+                logger.Warn(ErrorCode.TimerCallbackError, $"Ignored exception {exc.Message} during async task timer callback {GetFullName()}", exc);
             }
             finally
             {
@@ -288,12 +283,12 @@ private void QueueNextTimerTick()
             catch (ObjectDisposedException ode)
             {
                 logger.Warn(ErrorCode.TimerDisposeError,
-                    string.Format("Timer {0} already disposed - will not queue next timer tick", GetFullName()), ode);
+                    $"Timer {GetFullName()} already disposed - will not queue next timer tick", ode);
             }
             catch (Exception exc)
             {
                 logger.Error(ErrorCode.TimerQueueTickError,
-                    string.Format("Error queueing next timer tick - WARNING: timer {0} is now stopped", GetFullName()), exc);
+                    $"Error queueing next timer tick - WARNING: timer {GetFullName()} is now stopped", exc);
             }
         }
     }
diff --git a/src/Orleans.Core/Transactions/OrleansTransactionException.cs b/src/Orleans.Core/Transactions/OrleansTransactionException.cs
index f5b469c08..7434323e6 100644
--- a/src/Orleans.Core/Transactions/OrleansTransactionException.cs
+++ b/src/Orleans.Core/Transactions/OrleansTransactionException.cs
@@ -77,17 +77,17 @@ public class OrleansTransactionInDoubtException : OrleansTransactionException
     {
         public string TransactionId { get; private set; }
 
-        public OrleansTransactionInDoubtException(string transactionId) : base(string.Format("Transaction {0} is InDoubt", transactionId))
+        public OrleansTransactionInDoubtException(string transactionId) : base($"Transaction {transactionId} is InDoubt")
         {
             this.TransactionId = transactionId;
         }
 
-        public OrleansTransactionInDoubtException(string transactionId, Exception exc) : base(string.Format("Transaction {0} is InDoubt", transactionId), exc)
+        public OrleansTransactionInDoubtException(string transactionId, Exception exc) : base($"Transaction {transactionId} is InDoubt", exc)
         {
             this.TransactionId = transactionId;
         }
 
-        public OrleansTransactionInDoubtException(string transactionId, string msg, Exception innerException) : base(string.Format("Transaction {0} is InDoubt: {1}", transactionId, msg), innerException)
+        public OrleansTransactionInDoubtException(string transactionId, string msg, Exception innerException) : base($"Transaction {transactionId} is InDoubt: {msg}", innerException)
         {
             this.TransactionId = transactionId;
         }
@@ -154,18 +154,18 @@ public class OrleansCascadingAbortException : OrleansTransactionTransientFailure
         public string DependentTransactionId { get; private set; }
 
         public OrleansCascadingAbortException(string transactionId, string dependentId)
-            : base(transactionId, string.Format("Transaction {0} aborted because its dependent transaction {1} aborted", transactionId, dependentId))
+            : base(transactionId, $"Transaction {transactionId} aborted because its dependent transaction {dependentId} aborted")
         {
             this.DependentTransactionId = dependentId;
         }
 
         public OrleansCascadingAbortException(string transactionId)
-            : base(transactionId, string.Format("Transaction {0} aborted because a dependent transaction aborted", transactionId))
+            : base(transactionId, $"Transaction {transactionId} aborted because a dependent transaction aborted")
         {
         }
 
         public OrleansCascadingAbortException(string transactionId, Exception innerException)
-            : base(transactionId, string.Format("Transaction {0} aborted because a dependent transaction aborted", transactionId), innerException)
+            : base(transactionId, $"Transaction {transactionId} aborted because a dependent transaction aborted", innerException)
         {
         }
 
@@ -208,7 +208,7 @@ public OrleansOrphanCallException(SerializationInfo info, StreamingContext conte
     public class OrleansReadOnlyViolatedException : OrleansTransactionAbortedException
     {
         public OrleansReadOnlyViolatedException(string transactionId)
-            : base(transactionId, string.Format("Transaction {0} aborted because it attempted to write a grain", transactionId))
+            : base(transactionId, $"Transaction {transactionId} aborted because it attempted to write a grain")
         {
         }
 
diff --git a/src/Orleans.Core/Utils/CachedTypeResolver.cs b/src/Orleans.Core/Utils/CachedTypeResolver.cs
index 6f9faf9fd..221a9ccf8 100644
--- a/src/Orleans.Core/Utils/CachedTypeResolver.cs
+++ b/src/Orleans.Core/Utils/CachedTypeResolver.cs
@@ -15,7 +15,7 @@ public Type ResolveType(string name)
         {
             if (this.TryResolveType(name, out var result)) return result;
             
-            throw new TypeAccessException(string.Format("Unable to find a type named {0}", name));
+            throw new TypeAccessException($"Unable to find a type named {name}");
         }
 
         /// <inheritdoc />
@@ -34,7 +34,7 @@ protected virtual bool TryPerformUncachedTypeResolution(string name, out Type ty
             Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
             if (!this.TryPerformUncachedTypeResolution(name, out type, assemblies)) return false;
 
-            if (type.Assembly.ReflectionOnly) throw new InvalidOperationException(string.Format("Type resolution for {0} yielded reflection-only type.", name));
+            if (type.Assembly.ReflectionOnly) throw new InvalidOperationException($"Type resolution for {name} yielded reflection-only type.");
 
             return true;
         }
diff --git a/src/Orleans.Core/Utils/Utils.cs b/src/Orleans.Core/Utils/Utils.cs
index 63ad61aa3..73f9369df 100644
--- a/src/Orleans.Core/Utils/Utils.cs
+++ b/src/Orleans.Core/Utils/Utils.cs
@@ -113,7 +113,7 @@ public static class Utils
         public static string TimeSpanToString(TimeSpan timeSpan)
         {
             //00:03:32.8289777
-            return String.Format("{0}h:{1}m:{2}s.{3}ms", timeSpan.Hours, timeSpan.Minutes, timeSpan.Seconds, timeSpan.Milliseconds);
+            return $"{timeSpan.Hours}h:{timeSpan.Minutes}m:{timeSpan.Seconds}s.{timeSpan.Milliseconds}ms";
         }
 
         public static long TicksToMilliSeconds(long ticks) => ticks / TimeSpan.TicksPerMillisecond;
diff --git a/src/Orleans.EventSourcing/Common/PrimaryBasedLogViewAdaptor.cs b/src/Orleans.EventSourcing/Common/PrimaryBasedLogViewAdaptor.cs
index 5dbcd930d..8a3fff22a 100644
--- a/src/Orleans.EventSourcing/Common/PrimaryBasedLogViewAdaptor.cs
+++ b/src/Orleans.EventSourcing/Common/PrimaryBasedLogViewAdaptor.cs
@@ -89,16 +89,14 @@ public virtual Task<IReadOnlyList<TLogEntry>> RetrieveLogSegment(int fromVersion
         /// </summary>
         protected virtual void OnNotificationReceived(INotificationMessage payload)
         {        
-            var msg = payload as VersionNotificationMessage; 
-            if (msg != null)
+            if (payload is VersionNotificationMessage msg)
             {
                 if (msg.Version > lastVersionNotified)
                     lastVersionNotified = msg.Version;
                 return;
             }
 
-            var batchmsg = payload as BatchedNotificationMessage;
-            if (batchmsg != null)
+            if (payload is BatchedNotificationMessage batchmsg)
             {
                 foreach (var bm in batchmsg.Notifications)
                     OnNotificationReceived(bm);
@@ -106,7 +104,7 @@ protected virtual void OnNotificationReceived(INotificationMessage payload)
             }
 
             // subclass should have handled this in override
-            throw new ProtocolTransportException(string.Format("message type {0} not handled by OnNotificationReceived", payload.GetType().FullName));
+            throw new ProtocolTransportException($"message type {payload.GetType().FullName} not handled by OnNotificationReceived");
         }
 
         /// <summary>
@@ -430,9 +428,7 @@ public int ConfirmedVersion
         /// <returns></returns>
         public async Task<ILogConsistencyProtocolMessage> OnProtocolMessageReceived(ILogConsistencyProtocolMessage payLoad)
         {
-            var notificationMessage = payLoad as INotificationMessage;
-
-            if (notificationMessage != null)
+            if (payLoad is INotificationMessage notificationMessage)
             {
                 Services.Log(LogLevel.Debug, "NotificationReceived v{0}", notificationMessage.Version);
 
diff --git a/src/Orleans.EventSourcing/Common/StringEncodedWriteVector.cs b/src/Orleans.EventSourcing/Common/StringEncodedWriteVector.cs
index 1df9265c9..d11494185 100644
--- a/src/Orleans.EventSourcing/Common/StringEncodedWriteVector.cs
+++ b/src/Orleans.EventSourcing/Common/StringEncodedWriteVector.cs
@@ -44,7 +44,7 @@ public static bool FlipBit(ref string writeVector, string Replica)
             }
             else
             {
-                writeVector = string.Format(",{0}{1}", Replica, writeVector);
+                writeVector = $",{Replica}{writeVector}";
                 return true;
             }
         }
diff --git a/src/Orleans.EventSourcing/CustomStorage/LogViewAdaptor.cs b/src/Orleans.EventSourcing/CustomStorage/LogViewAdaptor.cs
index 964ca2d91..e48236149 100644
--- a/src/Orleans.EventSourcing/CustomStorage/LogViewAdaptor.cs
+++ b/src/Orleans.EventSourcing/CustomStorage/LogViewAdaptor.cs
@@ -265,7 +265,7 @@ protected class UpdateNotificationMessage : INotificationMessage
             /// </summary>
             public override string ToString()
             {
-                return string.Format("v{0} ({1} updates)", Version, Updates.Count);
+                return $"v{Version} ({Updates.Count} updates)";
             }
         }
    
@@ -274,8 +274,7 @@ public override string ToString()
         /// <inheritdoc/>
         protected override void OnNotificationReceived(INotificationMessage payload)
         {
-           var um = payload as UpdateNotificationMessage;
-            if (um != null)
+            if (payload is UpdateNotificationMessage um)
                 notifications.Add(um.Version - um.Updates.Count, um);
             else
                 base.OnNotificationReceived(payload);
diff --git a/src/Orleans.EventSourcing/LogConsistency/ProtocolServices.cs b/src/Orleans.EventSourcing/LogConsistency/ProtocolServices.cs
index f4564916c..3032c2e6e 100644
--- a/src/Orleans.EventSourcing/LogConsistency/ProtocolServices.cs
+++ b/src/Orleans.EventSourcing/LogConsistency/ProtocolServices.cs
@@ -43,40 +43,31 @@ public void ProtocolError(string msg, bool throwexception)
         {
 
             log?.Error((int)(throwexception ? ErrorCode.LogConsistency_ProtocolFatalError : ErrorCode.LogConsistency_ProtocolError),
-                string.Format("{0} Protocol Error: {1}",
-                    grain.GrainReference,
-                    msg));
+                $"{grain.GrainReference} Protocol Error: {msg}");
 
             if (!throwexception)
                 return;
 
-            throw new OrleansException(string.Format("{0} (grain={1}, cluster={2})", msg, grain.GrainReference, this.MyClusterId));
+            throw new OrleansException($"{msg} (grain={grain.GrainReference}, cluster={this.MyClusterId})");
         }
 
         public void CaughtException(string where, Exception e)
         {
             log?.Error((int)ErrorCode.LogConsistency_CaughtException,
-               string.Format("{0} Exception Caught at {1}",
-                   grain.GrainReference,
-                   where),e);
+               $"{grain.GrainReference} Exception Caught at {where}",e);
         }
 
         public void CaughtUserCodeException(string callback, string where, Exception e)
         {
             log?.Warn((int)ErrorCode.LogConsistency_UserCodeException,
-                string.Format("{0} Exception caught in user code for {1}, called from {2}",
-                   grain.GrainReference,
-                   callback,
-                   where), e);
+                $"{grain.GrainReference} Exception caught in user code for {callback}, called from {where}", e);
         }
 
         public void Log(LogLevel level, string format, params object[] args)
         {
             if (log != null && log.IsEnabled(level))
             {
-                var msg = string.Format("{0} {1}",
-                        grain.GrainReference,
-                        string.Format(format, args));
+                var msg = $"{grain.GrainReference} {string.Format(format, args)}";
                 log.Log(level, 0, msg, null, (m, exc) => $"{m}");
             }
         }
diff --git a/src/Orleans.EventSourcing/LogStorage/LogStateWithMetaData.cs b/src/Orleans.EventSourcing/LogStorage/LogStateWithMetaData.cs
index a033d4545..e49683717 100644
--- a/src/Orleans.EventSourcing/LogStorage/LogStateWithMetaData.cs
+++ b/src/Orleans.EventSourcing/LogStorage/LogStateWithMetaData.cs
@@ -54,7 +54,7 @@ public LogStateWithMetaDataAndETag()
         /// </summary>
         public override string ToString()
         {
-            return string.Format("v{0} Flags={1} ETag={2} Data={3}", StateAndMetaData.GlobalVersion, StateAndMetaData.WriteVector, ETag, StateAndMetaData.Log);
+            return $"v{StateAndMetaData.GlobalVersion} Flags={StateAndMetaData.WriteVector} ETag={ETag} Data={StateAndMetaData.Log}";
         }
     }
 
diff --git a/src/Orleans.EventSourcing/LogStorage/LogViewAdaptor.cs b/src/Orleans.EventSourcing/LogStorage/LogViewAdaptor.cs
index cdd8d0eae..79cdab618 100644
--- a/src/Orleans.EventSourcing/LogStorage/LogViewAdaptor.cs
+++ b/src/Orleans.EventSourcing/LogStorage/LogViewAdaptor.cs
@@ -265,18 +265,16 @@ protected class UpdateNotificationMessage : INotificationMessage
             /// <inheritdoc/>
             public override string ToString()
             {
-                return string.Format("v{0} ({1} updates by {2}) etag={3}", Version, Updates.Count, Origin, ETag);
+                return $"v{Version} ({Updates.Count} updates by {Origin}) etag={ETag}";
             }
          }
 
         /// <inheritdoc/>
         protected override INotificationMessage Merge(INotificationMessage earlierMessage, INotificationMessage laterMessage)
         {
-            var earlier = earlierMessage as UpdateNotificationMessage;
-            var later = laterMessage as UpdateNotificationMessage;
 
-            if (earlier != null
-                && later != null
+            if (earlierMessage is UpdateNotificationMessage earlier
+                && laterMessage is UpdateNotificationMessage later
                 && earlier.Origin == later.Origin
                 && earlier.Version + later.Updates.Count == later.Version
                 && earlier.Updates.Count + later.Updates.Count < maxEntriesInNotifications)
@@ -298,8 +296,7 @@ protected override INotificationMessage Merge(INotificationMessage earlierMessag
         /// <inheritdoc/>
         protected override void OnNotificationReceived(INotificationMessage payload)
         {
-            var um = payload as UpdateNotificationMessage;
-            if (um != null)
+            if (payload is UpdateNotificationMessage um)
                 notifications.Add(um.Version - um.Updates.Count, um);
             else
                 base.OnNotificationReceived(payload);
diff --git a/src/Orleans.EventSourcing/StateStorage/GrainStateWithMetaData.cs b/src/Orleans.EventSourcing/StateStorage/GrainStateWithMetaData.cs
index 135da9936..4e6db623a 100644
--- a/src/Orleans.EventSourcing/StateStorage/GrainStateWithMetaData.cs
+++ b/src/Orleans.EventSourcing/StateStorage/GrainStateWithMetaData.cs
@@ -61,7 +61,7 @@ public GrainStateWithMetaDataAndETag()
         /// </summary>
         public override string ToString()
         {
-            return string.Format("v{0} Flags={1} ETag={2} Data={3}", StateAndMetaData.GlobalVersion, StateAndMetaData.WriteVector, ETag, StateAndMetaData.State);
+            return $"v{StateAndMetaData.GlobalVersion} Flags={StateAndMetaData.WriteVector} ETag={ETag} Data={StateAndMetaData.State}";
         }
     }
 
diff --git a/src/Orleans.EventSourcing/StateStorage/LogViewAdaptor.cs b/src/Orleans.EventSourcing/StateStorage/LogViewAdaptor.cs
index 1bc9c342b..8fa3420c6 100644
--- a/src/Orleans.EventSourcing/StateStorage/LogViewAdaptor.cs
+++ b/src/Orleans.EventSourcing/StateStorage/LogViewAdaptor.cs
@@ -235,18 +235,16 @@ protected class UpdateNotificationMessage : INotificationMessage
             /// <inheritdoc/>
             public override string ToString()
             {
-                return string.Format("v{0} ({1} updates by {2}) etag={3}", Version, Updates.Count, Origin, ETag);
+                return $"v{Version} ({Updates.Count} updates by {Origin}) etag={ETag}";
             }
          }
 
         /// <inheritdoc/>
         protected override INotificationMessage Merge(INotificationMessage earlierMessage, INotificationMessage laterMessage)
         {
-            var earlier = earlierMessage as UpdateNotificationMessage;
-            var later = laterMessage as UpdateNotificationMessage;
 
-            if (earlier != null
-                && later != null
+            if (earlierMessage is UpdateNotificationMessage earlier
+                && laterMessage is UpdateNotificationMessage later
                 && earlier.Origin == later.Origin
                 && earlier.Version + later.Updates.Count == later.Version
                 && earlier.Updates.Count + later.Updates.Count < maxEntriesInNotifications)
@@ -268,8 +266,7 @@ protected override INotificationMessage Merge(INotificationMessage earlierMessag
         /// <inheritdoc/>
         protected override void OnNotificationReceived(INotificationMessage payload)
         {
-            var um = payload as UpdateNotificationMessage;
-            if (um != null)
+            if (payload is UpdateNotificationMessage um)
                 notifications.Add(um.Version - um.Updates.Count, um);
             else
                 base.OnNotificationReceived(payload);
diff --git a/src/Orleans.Persistence.Memory/Storage/HierarchicalKeyStore.cs b/src/Orleans.Persistence.Memory/Storage/HierarchicalKeyStore.cs
index 6430d8cc6..4720f8e6d 100644
--- a/src/Orleans.Persistence.Memory/Storage/HierarchicalKeyStore.cs
+++ b/src/Orleans.Persistence.Memory/Storage/HierarchicalKeyStore.cs
@@ -29,7 +29,7 @@ public string WriteRow(IList<Tuple<string, string>> keys, IDictionary<string, ob
         {
             if (keys.Count > numKeyLayers)
             {
-                var error = string.Format("Wrong number of keys supplied -- Expected count = {0} Received = {1}", numKeyLayers, keys.Count);
+                var error = $"Wrong number of keys supplied -- Expected count = {numKeyLayers} Received = {keys.Count}";
                 Trace.TraceError(error);
                 throw new ArgumentOutOfRangeException("keys", keys.Count, error);
             }
@@ -57,7 +57,7 @@ public string WriteRow(IList<Tuple<string, string>> keys, IDictionary<string, ob
         {
             if (keys.Count > numKeyLayers)
             {
-                var error = string.Format("Not enough keys supplied -- Expected count = {0} Received = {1}", numKeyLayers, keys.Count);
+                var error = $"Not enough keys supplied -- Expected count = {numKeyLayers} Received = {keys.Count}";
                 Trace.TraceError(error);
                 throw new ArgumentOutOfRangeException("keys", keys.Count, error);
             }
@@ -79,7 +79,7 @@ public string WriteRow(IList<Tuple<string, string>> keys, IDictionary<string, ob
             if (keys.Count > numKeyLayers)
             {
                 throw new ArgumentOutOfRangeException("keys", keys.Count,
-                    string.Format("Too many key supplied -- Expected count = {0} Received = {1}", numKeyLayers, keys.Count));
+                    $"Too many key supplied -- Expected count = {numKeyLayers} Received = {keys.Count}");
             }
 
             lock (lockable)
@@ -98,7 +98,7 @@ public bool DeleteRow(IList<Tuple<string, string>> keys, string eTag)
             if (keys.Count > numKeyLayers)
             {
                 throw new ArgumentOutOfRangeException("keys", keys.Count,
-                    string.Format("Not enough keys supplied -- Expected count = {0} Received = {1}", numKeyLayers, keys.Count));
+                    $"Not enough keys supplied -- Expected count = {numKeyLayers} Received = {keys.Count}");
             }
 
             string keyStr = MakeStoreKey(keys);
diff --git a/src/Orleans.Persistence.Memory/Storage/StorageProviderUtils.cs b/src/Orleans.Persistence.Memory/Storage/StorageProviderUtils.cs
index 0b3b1c7e8..43312b69e 100644
--- a/src/Orleans.Persistence.Memory/Storage/StorageProviderUtils.cs
+++ b/src/Orleans.Persistence.Memory/Storage/StorageProviderUtils.cs
@@ -27,7 +27,7 @@ public static int PositiveHash(int hash, int hashRange)
         public static string PrintKeys(IEnumerable<Tuple<string, string>> keys)
         {
             return Utils.EnumerableToString(keys,
-                keyTuple => string.Format("Key:{0}={1}", keyTuple.Item1, keyTuple.Item2 ?? "null"));
+                keyTuple => $"Key:{keyTuple.Item1}={keyTuple.Item2 ?? "null"}");
         }
 
         public static string PrintData(object data)
diff --git a/src/Orleans.Runtime/Catalog/ActivationCollector.cs b/src/Orleans.Runtime/Catalog/ActivationCollector.cs
index 122289341..fcd8fd3a2 100644
--- a/src/Orleans.Runtime/Catalog/ActivationCollector.cs
+++ b/src/Orleans.Runtime/Catalog/ActivationCollector.cs
@@ -160,11 +160,7 @@ public override string ToString()
         {
             var now = DateTime.UtcNow;
             var all = buckets.ToList();
-            return string.Format("<#Activations={0}, #Buckets={1}, buckets={2}>",
-                    all.Sum(b => b.Value.ApproximateCount),
-                    all.Count,
-                    Utils.EnumerableToString(
-                        all.Select(i => i.Value).OrderBy(bucket => bucket.Key), bucket => Utils.TimeSpanToString(bucket.Key - now) + "->" + bucket.ApproximateCount + " items"));
+            return $"<#Activations={all.Sum(b => b.Value.ApproximateCount)}, #Buckets={all.Count}, buckets={Utils.EnumerableToString(all.Select(i => i.Value).OrderBy(bucket => bucket.Key), bucket => Utils.TimeSpanToString(bucket.Key - now) + "->" + bucket.ApproximateCount + " items")}>";
         }
 
         /// <summary>
@@ -302,7 +298,7 @@ private void ThrowIfTicketIsInvalid(DateTime ticket)
             if (ticket.Ticks == 0) throw new ArgumentException("Empty ticket is not allowed in this context.");
             if (0 != ticket.Ticks % quantum.Ticks)
             {
-                throw new ArgumentException(string.Format("invalid ticket ({0})", ticket));
+                throw new ArgumentException($"invalid ticket ({ticket})");
             }
         }
 
@@ -317,7 +313,7 @@ private DateTime MakeTicketFromDateTime(DateTime timestamp)
             DateTime ticket = new DateTime(((timestamp.Ticks - 1) / quantum.Ticks + 1) * quantum.Ticks, DateTimeKind.Utc);
             if (ticket < nextTicket)
             {
-                throw new ArgumentException(string.Format("The earliest collection that can be scheduled from now is for {0}", new DateTime(nextTicket.Ticks - quantum.Ticks + 1, DateTimeKind.Utc)));
+                throw new ArgumentException($"The earliest collection that can be scheduled from now is for {new DateTime(nextTicket.Ticks - quantum.Ticks + 1, DateTimeKind.Utc)}");
             }
             return ticket;
         }
@@ -326,7 +322,7 @@ private DateTime MakeTicketFromTimeSpan(TimeSpan timeout)
         {
             if (timeout < quantum)
             {
-                throw new ArgumentException(String.Format("timeout must be at least {0}, but it is {1}", quantum, timeout), "timeout");
+                throw new ArgumentException($"timeout must be at least {quantum}, but it is {timeout}", "timeout");
             }
 
             return MakeTicketFromDateTime(DateTime.UtcNow + timeout);
diff --git a/src/Orleans.Runtime/Catalog/ActivationData.cs b/src/Orleans.Runtime/Catalog/ActivationData.cs
index 11ad6c548..2f80f6a29 100644
--- a/src/Orleans.Runtime/Catalog/ActivationData.cs
+++ b/src/Orleans.Runtime/Catalog/ActivationData.cs
@@ -757,42 +757,20 @@ public string DumpStatus()
 
         public override string ToString()
         {
-            return String.Format("[Activation: {0}/{1}{2}{3} State={4}]",
-                 Silo,
-                 this.GrainId,
-                 this.ActivationId,
-                 GetActivationInfoString(),
-                 State);
+            return $"[Activation: {Silo}/{this.GrainId}{this.ActivationId}{GetActivationInfoString()} State={State}]";
         }
 
         internal string ToDetailedString(bool includeExtraDetails = false)
         {
             return
-                String.Format(
-                    "[Activation: {0}/{1}{2} {3} State={4} NonReentrancyQueueSize={5} EnqueuedOnDispatcher={6} InFlightCount={7} NumRunning={8} IdlenessTimeSpan={9} CollectionAgeLimit={10}{11}]",
-                    Silo.ToLongString(),
-                    this.GrainId.ToString(),
-                    this.ActivationId,
-                    GetActivationInfoString(),
-                    State,                          // 4
-                    WaitingCount,                   // 5 NonReentrancyQueueSize
-                    EnqueuedOnDispatcherCount,      // 6 EnqueuedOnDispatcher
-                    InFlightCount,                  // 7 InFlightCount
-                    RunningRequests.Count,          // 8 NumRunning
-                    GetIdleness(DateTime.UtcNow),   // 9 IdlenessTimeSpan
-                    CollectionAgeLimit,             // 10 CollectionAgeLimit
-                    (includeExtraDetails && this.Blocking != null) ? " CurrentlyExecuting=" + this.Blocking : "");  // 11: Running
+                $"[Activation: {Silo.ToLongString()}/{this.GrainId.ToString()}{this.ActivationId} {GetActivationInfoString()} State={State} NonReentrancyQueueSize={WaitingCount} EnqueuedOnDispatcher={EnqueuedOnDispatcherCount} InFlightCount={InFlightCount} NumRunning={RunningRequests.Count} IdlenessTimeSpan={GetIdleness(DateTime.UtcNow)} CollectionAgeLimit={CollectionAgeLimit}{((includeExtraDetails && this.Blocking != null) ? " CurrentlyExecuting=" + this.Blocking : "")}]";  // 11: Running
         }
 
         public string Name
         {
             get
             {
-                return String.Format("[Activation: {0}{1}{2}{3}]",
-                     Silo,
-                     this.GrainId,
-                     this.ActivationId,
-                     GetActivationInfoString());
+                return $"[Activation: {Silo}{this.GrainId}{this.ActivationId}{GetActivationInfoString()}]";
             }
         }
 
diff --git a/src/Orleans.Runtime/Catalog/ActivationDirectory.cs b/src/Orleans.Runtime/Catalog/ActivationDirectory.cs
index 5fc300eee..20b97156d 100644
--- a/src/Orleans.Runtime/Catalog/ActivationDirectory.cs
+++ b/src/Orleans.Runtime/Catalog/ActivationDirectory.cs
@@ -145,7 +145,7 @@ public void PrintActivationDirectory()
             if (logger.IsEnabled(LogLevel.Information))
             {
                 var all = activations.ToList();
-                string stats = Utils.EnumerableToString(all.Select(i => i.Value).OrderBy(act => act.Name), act => string.Format("++{0}", act.DumpStatus()), Environment.NewLine);
+                string stats = Utils.EnumerableToString(all.Select(i => i.Value).OrderBy(act => act.Name), act => $"++{act.DumpStatus()}", Environment.NewLine);
                 if (stats.Length > 0)
                 {
                     logger.Info(ErrorCode.Catalog_ActivationDirectory_Statistics, $"ActivationDirectory.PrintActivationDirectory(): Size = { all.Count}, Directory:{Environment.NewLine}{stats}");
diff --git a/src/Orleans.Runtime/Catalog/Catalog.cs b/src/Orleans.Runtime/Catalog/Catalog.cs
index 736528e3d..9cc8c975b 100644
--- a/src/Orleans.Runtime/Catalog/Catalog.cs
+++ b/src/Orleans.Runtime/Catalog/Catalog.cs
@@ -670,7 +670,7 @@ private async Task InitActivation(ActivationData activation, Dictionary<string,
                     {
                         failedActivations.Add(activation.Address, ExceptionDispatchInfo.Capture(exception));
                         activation.SetState(ActivationState.FailedToActivate);
-                        logger.Warn(ErrorCode.Catalog_Failed_InvokeActivate, string.Format("Failed to InvokeActivate for {0}.", activation), exception);
+                        logger.Warn(ErrorCode.Catalog_Failed_InvokeActivate, $"Failed to InvokeActivate for {activation}.", exception);
                         // Reject all of the messages queued for this activation.
                         var activationFailedMsg = nameof(Grain.OnActivateAsync) + " failed";
                         RejectAllQueuedMessages(activation, activationFailedMsg, exception);
@@ -768,15 +768,11 @@ private void DeactivateActivationImpl(ActivationData data, StatisticName statist
                 }
                 else if (data.State == ActivationState.Create)
                 {
-                    throw new InvalidOperationException(String.Format(
-                        "Activation {0} has called DeactivateOnIdle from within a constructor, which is not allowed.",
-                            data.ToString()));
+                    throw new InvalidOperationException($"Activation {data.ToString()} has called DeactivateOnIdle from within a constructor, which is not allowed.");
                 }
                 else if (data.State == ActivationState.Activating)
                 {
-                    throw new InvalidOperationException(String.Format(
-                        "Activation {0} has called DeactivateOnIdle from within OnActivateAsync, which is not allowed.",
-                            data.ToString()));
+                    throw new InvalidOperationException($"Activation {data.ToString()} has called DeactivateOnIdle from within OnActivateAsync, which is not allowed.");
                 }
                 else
                 {
@@ -884,7 +880,7 @@ private void RerouteAllQueuedMessages(ActivationData activation, ActivationAddre
                 List<Message> msgs = activation.DequeueAllWaitingMessages();
                 if (msgs == null || msgs.Count <= 0) return;
 
-                if (logger.IsEnabled(LogLevel.Debug)) logger.Debug(ErrorCode.Catalog_RerouteAllQueuedMessages, String.Format("RerouteAllQueuedMessages: {0} msgs from Invalid activation {1}.", msgs.Count, activation));
+                if (logger.IsEnabled(LogLevel.Debug)) logger.Debug(ErrorCode.Catalog_RerouteAllQueuedMessages, $"RerouteAllQueuedMessages: {msgs.Count} msgs from Invalid activation {activation}.");
                 this.directory.InvalidateCacheEntry(activation.Address);
                 this.Dispatcher.ProcessRequestsToInvalidActivation(msgs, activation.Address, forwardingAddress, failedOperation, exc);
             }
@@ -909,7 +905,7 @@ private void RerouteAllQueuedMessages(ActivationData activation, ActivationAddre
                 if (logger.IsEnabled(LogLevel.Debug))
                     logger.Debug(
                         ErrorCode.Catalog_RerouteAllQueuedMessages,
-                        string.Format("RejectAllQueuedMessages: {0} msgs from Invalid activation {1}.", msgs.Count, activation));
+                        $"RejectAllQueuedMessages: {msgs.Count} msgs from Invalid activation {activation}.");
                 this.directory.InvalidateCacheEntry(activation.Address);
                 this.Dispatcher.ProcessRequestsToInvalidActivation(
                     msgs,
@@ -938,7 +934,7 @@ private async Task CallGrainActivate(ActivationData activation, Dictionary<strin
             catch (Exception exc)
             {
                 logger.Error(ErrorCode.Catalog_ErrorCallingActivate,
-                    string.Format("Error calling grain's OnActivateAsync() method - Grain type = {1} Activation = {0}", activation, grainTypeName), exc);
+                    $"Error calling grain's OnActivateAsync() method - Grain type = {activation} Activation = {grainTypeName}", exc);
 
                 activationsFailedToActivate.Increment();
 
@@ -982,12 +978,12 @@ private async Task<ActivationData> CallGrainDeactivateAndCleanupStreams(Activati
                 catch (Exception exc)
                 {
                     logger.Error(ErrorCode.Catalog_ErrorCallingDeactivate,
-                        string.Format("Error calling grain's OnDeactivateAsync() method - Grain type = {1} Activation = {0}", activation, grainTypeName), exc);
+                        $"Error calling grain's OnDeactivateAsync() method - Grain type = {activation} Activation = {grainTypeName}", exc);
                 }
             }
             catch (Exception exc)
             {
-                logger.Error(ErrorCode.Catalog_FinishGrainDeactivateAndCleanupStreams_Exception, String.Format("CallGrainDeactivateAndCleanupStreams Activation = {0} failed.", activation), exc);
+                logger.Error(ErrorCode.Catalog_FinishGrainDeactivateAndCleanupStreams_Exception, $"CallGrainDeactivateAndCleanupStreams Activation = {activation} failed.", exc);
             }
             return activation;
         }
@@ -1189,13 +1185,12 @@ private void OnSiloStatusChange(SiloAddress updatedSilo, SiloStatus status)
                         catch (Exception exc)
                         {
                             logger.Error(ErrorCode.Catalog_SiloStatusChangeNotification_Exception,
-                                String.Format("Catalog has thrown an exception while executing OnSiloStatusChange of silo {0}.", updatedSilo.ToStringWithHashCode()), exc);
+                                $"Catalog has thrown an exception while executing OnSiloStatusChange of silo {updatedSilo.ToStringWithHashCode()}.", exc);
                         }
                     }
                 }
                 logger.Info(ErrorCode.Catalog_SiloStatusChangeNotification,
-                    String.Format("Catalog is deactivating {0} activations due to a failure of silo {1}, since it is a primary directory partition to these grain ids.",
-                        activationsToShutdown.Count, updatedSilo.ToStringWithHashCode()));
+                    $"Catalog is deactivating {activationsToShutdown.Count} activations due to a failure of silo {updatedSilo.ToStringWithHashCode()}, since it is a primary directory partition to these grain ids.");
             }
             finally
             {
diff --git a/src/Orleans.Runtime/ConsistentRing/ConsistentRingProvider.cs b/src/Orleans.Runtime/ConsistentRing/ConsistentRingProvider.cs
index 11a152c4c..eb00754f9 100644
--- a/src/Orleans.Runtime/ConsistentRing/ConsistentRingProvider.cs
+++ b/src/Orleans.Runtime/ConsistentRing/ConsistentRingProvider.cs
@@ -74,7 +74,7 @@ internal void AddServer(SiloAddress silo)
                 int myOldIndex = membershipRingList.IndexOf(MyAddress);
 
                 if (!(membershipRingList.Count == 0 || myOldIndex != -1))
-                    throw new OrleansException(string.Format("{0}: Couldn't find my position in the ring {1}.", MyAddress, Utils.EnumerableToString(membershipRingList)));
+                    throw new OrleansException($"{MyAddress}: Couldn't find my position in the ring {Utils.EnumerableToString(membershipRingList)}.");
 
 
                 // insert new silo in the sorted order
@@ -98,8 +98,7 @@ internal void AddServer(SiloAddress silo)
                     catch (OverflowException exc)
                     {
                         log.Error(ErrorCode.ConsistentRingProviderBase + 5,
-                            String.Format("OverflowException: hash as int= x{0, 8:X8}, hash as uint= x{1, 8:X8}, myKey as int x{2, 8:X8}, myKey as uint x{3, 8:X8}.",
-                            hash, (uint)hash, myKey, (uint)myKey), exc);
+                            $"OverflowException: hash as int= x{hash:X8}, hash as uint= x{(uint)hash:X8}, myKey as int x{myKey:X8}, myKey as uint x{(uint)myKey:X8}.", exc);
                     }
                     NotifyLocalRangeSubscribers(oldRange, myRange, false);
                 }
@@ -113,7 +112,7 @@ public override string ToString()
             lock (membershipRingList)
             {
                 if (membershipRingList.Count == 1)
-                    return Utils.EnumerableToString(membershipRingList, silo => String.Format("{0} -> {1}", silo.ToStringWithHashCode(), RangeFactory.CreateFullRange()));
+                    return Utils.EnumerableToString(membershipRingList, silo => $"{silo.ToStringWithHashCode()} -> {RangeFactory.CreateFullRange()}");
 
                 var sb = new StringBuilder("[");
                 for (int i = 0; i < membershipRingList.Count; i++)
@@ -121,7 +120,7 @@ public override string ToString()
                     SiloAddress curr = membershipRingList[i];
                     SiloAddress next = membershipRingList[(i + 1) % membershipRingList.Count];
                     IRingRange range = RangeFactory.CreateRange(unchecked((uint)curr.GetConsistentHashCode()), unchecked((uint)next.GetConsistentHashCode()));
-                    sb.Append(String.Format("{0} -> {1},  ", curr.ToStringWithHashCode(), range));
+                    sb.Append($"{curr.ToStringWithHashCode()} -> {range},  ");
                 }
                 sb.Append("]");
                 return sb.ToString();
@@ -141,7 +140,7 @@ internal void RemoveServer(SiloAddress silo)
                 int myNewIndex = membershipRingList.IndexOf(MyAddress);
 
                 if (myNewIndex == -1)
-                    throw new OrleansException(string.Format("{0}: Couldn't find my position in the ring {1}.", MyAddress, this.ToString()));
+                    throw new OrleansException($"{MyAddress}: Couldn't find my position in the ring {this.ToString()}.");
 
                 bool wasMyPred = ((myNewIndex == indexOfFailedSilo) || (myNewIndex == 0 && indexOfFailedSilo == membershipRingList.Count)); // no need for '- 1'
                 if (wasMyPred) // failed node was our predecessor
@@ -203,8 +202,7 @@ private void NotifyLocalRangeSubscribers(IRingRange old, IRingRange now, bool in
                 catch (Exception exc)
                 {
                     log.Error(ErrorCode.CRP_Local_Subscriber_Exception,
-                        String.Format("Local IRangeChangeListener {0} has thrown an exception when was notified about RangeChangeNotification about old {1} new {2} increased? {3}",
-                        listener.GetType().FullName, old, now, increased), exc);
+                        $"Local IRangeChangeListener {listener.GetType().FullName} has thrown an exception when was notified about RangeChangeNotification about old {old} new {now} increased? {increased}", exc);
                 }
             }
         }
diff --git a/src/Orleans.Runtime/ConsistentRing/VirtualBucketsRingProvider.cs b/src/Orleans.Runtime/ConsistentRing/VirtualBucketsRingProvider.cs
index e3ed346ca..306f2042d 100644
--- a/src/Orleans.Runtime/ConsistentRing/VirtualBucketsRingProvider.cs
+++ b/src/Orleans.Runtime/ConsistentRing/VirtualBucketsRingProvider.cs
@@ -41,7 +41,7 @@ internal VirtualBucketsRingProvider(SiloAddress siloAddress, ILoggerFactory logg
 
             StringValueStatistic.FindOrCreate(StatisticNames.CONSISTENTRING_RING, ToString);
             IntValueStatistic.FindOrCreate(StatisticNames.CONSISTENTRING_RINGSIZE, () => GetRingSize());
-            StringValueStatistic.FindOrCreate(StatisticNames.CONSISTENTRING_MYRANGE_RINGDISTANCE, () => String.Format("x{0,8:X8}", ((IRingRangeInternal)myRange).RangeSize()));
+            StringValueStatistic.FindOrCreate(StatisticNames.CONSISTENTRING_MYRANGE_RINGDISTANCE, () => $"x{((IRingRangeInternal)myRange).RangeSize():X8}");
             FloatValueStatistic.FindOrCreate(StatisticNames.CONSISTENTRING_MYRANGE_RINGPERCENTAGE, () => (float)((IRingRangeInternal)myRange).RangePercentage());
             FloatValueStatistic.FindOrCreate(StatisticNames.CONSISTENTRING_AVERAGERINGPERCENTAGE, () =>
             {
@@ -107,8 +107,7 @@ private void NotifyLocalRangeSubscribers(IRingRange old, IRingRange now, bool in
                 catch (Exception exc)
                 {
                     logger.Error(ErrorCode.CRP_Local_Subscriber_Exception,
-                        String.Format("Local IRangeChangeListener {0} has thrown an exception when was notified about RangeChangeNotification about old {1} new {2} increased? {3}",
-                        listener.GetType().FullName, old, now, increased), exc);
+                        $"Local IRangeChangeListener {listener.GetType().FullName} has thrown an exception when was notified about RangeChangeNotification about old {old} new {now} increased? {increased}", exc);
                 }
             }
         }
@@ -191,7 +190,7 @@ public override string ToString()
         {
             var sortedList = GetRanges();
             sortedList.Sort((t1, t2) => t1.Value.RangePercentage().CompareTo(t2.Value.RangePercentage()));
-            return Utils.EnumerableToString(sortedList, kv => String.Format("{0} -> {1}", kv.Key, kv.Value.ToString()));
+            return Utils.EnumerableToString(sortedList, kv => $"{kv.Key} -> {kv.Value.ToString()}");
         }
 
         // Internal: for testing/logging only!
diff --git a/src/Orleans.Runtime/Core/Dispatcher.cs b/src/Orleans.Runtime/Core/Dispatcher.cs
index 1076d4b30..babeb5378 100644
--- a/src/Orleans.Runtime/Core/Dispatcher.cs
+++ b/src/Orleans.Runtime/Core/Dispatcher.cs
@@ -64,7 +64,7 @@ internal class Dispatcher
             {
                 this.messagingTrace.OnDispatcherRejectMessage(message, rejectionType, rejectInfo, exc);
 
-                var str = string.Format("{0} {1}", rejectInfo ?? "", exc == null ? "" : exc.ToString());
+                var str = $"{rejectInfo ?? ""} {(exc == null ? "" : exc.ToString())}";
                 var rejection = this.messageFactory.CreateRejectionResponse(message, rejectionType, str, exc);
                 messageCenter.SendMessage(rejection);
             }
diff --git a/src/Orleans.Runtime/Core/HostedClient.cs b/src/Orleans.Runtime/Core/HostedClient.cs
index eeffba087..41045bada 100644
--- a/src/Orleans.Runtime/Core/HostedClient.cs
+++ b/src/Orleans.Runtime/Core/HostedClient.cs
@@ -101,7 +101,7 @@ public IAddressable CreateObjectReference(IAddressable obj, IGrainMethodInvoker
             if (!this.invokableObjects.TryRegister(obj, observerId, invoker))
             {
                 throw new ArgumentException(
-                    string.Format("Failed to add new observer {0} to localObjects collection.", grainReference),
+                    $"Failed to add new observer {grainReference} to localObjects collection.",
                     nameof(grainReference));
             }
 
diff --git a/src/Orleans.Runtime/Core/InsideRuntimeClient.cs b/src/Orleans.Runtime/Core/InsideRuntimeClient.cs
index 38b7b52ca..390ab5847 100644
--- a/src/Orleans.Runtime/Core/InsideRuntimeClient.cs
+++ b/src/Orleans.Runtime/Core/InsideRuntimeClient.cs
@@ -328,10 +328,8 @@ public async Task Invoke(IGrainContext target, Message message)
                         }
                     }
 
-                    // If a grain allowed an inconsistent state exception to escape and the exception originated from
-                    // this activation, then deactivate it.
-                    var ise = exc1 as InconsistentStateException;
-                    if (ise != null && ise.IsSourceActivation)
+                    // If a grain allowed an inconsistent state exception to escape and the exception originated from                    // this activation, then deactivate it.
+                    if (exc1 is InconsistentStateException ise && ise.IsSourceActivation)
                     {
                         // Mark the exception so that it doesn't deactivate any other activations.
                         ise.IsSourceActivation = false;
diff --git a/src/Orleans.Runtime/Core/ManagementGrain.cs b/src/Orleans.Runtime/Core/ManagementGrain.cs
index dc38bcdfe..c04049136 100644
--- a/src/Orleans.Runtime/Core/ManagementGrain.cs
+++ b/src/Orleans.Runtime/Core/ManagementGrain.cs
@@ -211,7 +211,7 @@ public async Task<int> GetTotalActivationCount()
         public Task<object[]> SendControlCommandToProvider(string providerTypeFullName, string providerName, int command, object arg)
         {
             return ExecutePerSiloCall(isc => isc.SendControlCommandToProvider(providerTypeFullName, providerName, command, arg),
-                String.Format("SendControlCommandToProvider of type {0} and name {1} command {2}.", providerTypeFullName, providerName, command));
+                $"SendControlCommandToProvider of type {providerTypeFullName} and name {providerName} command {command}.");
         }
 
         public ValueTask<SiloAddress> GetActivationAddress(IAddressable reference)
diff --git a/src/Orleans.Runtime/Core/SystemStatus.cs b/src/Orleans.Runtime/Core/SystemStatus.cs
index 5ba906c24..fbc9b38a5 100644
--- a/src/Orleans.Runtime/Core/SystemStatus.cs
+++ b/src/Orleans.Runtime/Core/SystemStatus.cs
@@ -60,7 +60,7 @@ private enum InternalSystemStatus
         /// <see cref="Object.GetHashCode"/>
         public override int GetHashCode() { return this.value.GetHashCode(); }
         /// <see cref="Object.Equals(Object)"/>
-        public override bool Equals(object obj) { var ss = obj as SystemStatus; return ss != null && this.Equals(ss); }
+        public override bool Equals(object obj) { return obj is SystemStatus ss && this.Equals(ss); }
         /// <see cref="IEquatable{T}.Equals"/>
         public bool Equals(SystemStatus other) { return (other != null) && this.value.Equals(other.value); }
     }
diff --git a/src/Orleans.Runtime/Core/SystemTarget.cs b/src/Orleans.Runtime/Core/SystemTarget.cs
index 21617b9d8..fb0f085e4 100644
--- a/src/Orleans.Runtime/Core/SystemTarget.cs
+++ b/src/Orleans.Runtime/Core/SystemTarget.cs
@@ -166,7 +166,7 @@ public override string ToString()
         /// <summary>Adds details about message currently being processed</summary>
         internal string ToDetailedString()
         {
-            return String.Format("{0} CurrentlyExecuting={1}", ToString(), running != null ? running.ToString() : "null");
+            return $"{ToString()} CurrentlyExecuting={(running != null ? running.ToString() : "null")}";
         }
 
         bool IEquatable<IGrainContext>.Equals(IGrainContext other) => ReferenceEquals(this, other);
diff --git a/src/Orleans.Runtime/GrainDirectory/GrainDirectoryCacheFactory.cs b/src/Orleans.Runtime/GrainDirectory/GrainDirectoryCacheFactory.cs
index 2923e8ebe..0789233d5 100644
--- a/src/Orleans.Runtime/GrainDirectory/GrainDirectoryCacheFactory.cs
+++ b/src/Orleans.Runtime/GrainDirectory/GrainDirectoryCacheFactory.cs
@@ -29,8 +29,7 @@ internal static IGrainDirectoryCache CreateGrainDirectoryCache(GrainDirectoryOpt
             IInternalGrainFactory grainFactory,
             ILoggerFactory loggerFactory)
         {
-            var adaptiveCache = cache as AdaptiveGrainDirectoryCache;
-            return adaptiveCache != null
+            return cache is AdaptiveGrainDirectoryCache adaptiveCache
                 ? new AdaptiveDirectoryCacheMaintainer(router, adaptiveCache, grainFactory, loggerFactory)
                 : null;
         }
diff --git a/src/Orleans.Runtime/GrainDirectory/GrainDirectoryHandoffManager.cs b/src/Orleans.Runtime/GrainDirectory/GrainDirectoryHandoffManager.cs
index cd54b70e3..b6a94d3df 100644
--- a/src/Orleans.Runtime/GrainDirectory/GrainDirectoryHandoffManager.cs
+++ b/src/Orleans.Runtime/GrainDirectory/GrainDirectoryHandoffManager.cs
@@ -292,9 +292,7 @@ internal void AcceptHandoffPartition(SiloAddress source, Dictionary<GrainId, IGr
                     if (!isFullCopy)
                     {
                         logger.Warn(ErrorCode.DirectoryUnexpectedDelta,
-                            String.Format("Got delta of the directory partition from silo {0} (Membership status {1}) while not holding a full copy. Membership active cluster size is {2}",
-                                source, this.siloStatusOracle.GetApproximateSiloStatus(source),
-                                this.siloStatusOracle.GetApproximateSiloStatuses(true).Count));
+                            $"Got delta of the directory partition from silo {source} (Membership status {this.siloStatusOracle.GetApproximateSiloStatus(source)}) while not holding a full copy. Membership active cluster size is {this.siloStatusOracle.GetApproximateSiloStatuses(true).Count}");
                     }
 
                     directoryPartitionsMap[source] = sourcePartition = this.createPartion();
diff --git a/src/Orleans.Runtime/GrainDirectory/GrainDirectoryPartition.cs b/src/Orleans.Runtime/GrainDirectory/GrainDirectoryPartition.cs
index 1a021f8a7..de778ef74 100644
--- a/src/Orleans.Runtime/GrainDirectory/GrainDirectoryPartition.cs
+++ b/src/Orleans.Runtime/GrainDirectory/GrainDirectoryPartition.cs
@@ -52,7 +52,7 @@ public bool OkToRemove(UnregistrationCause cause, TimeSpan lazyDeregistrationDel
 
         public override string ToString()
         {
-            return String.Format("{0}, {1}", SiloAddress, TimeCreated);
+            return $"{SiloAddress}, {TimeCreated}";
         }
     }
 
diff --git a/src/Orleans.Runtime/GrainDirectory/LocalGrainDirectory.cs b/src/Orleans.Runtime/GrainDirectory/LocalGrainDirectory.cs
index 791654aec..44a9a310b 100644
--- a/src/Orleans.Runtime/GrainDirectory/LocalGrainDirectory.cs
+++ b/src/Orleans.Runtime/GrainDirectory/LocalGrainDirectory.cs
@@ -150,9 +150,7 @@ internal class LocalGrainDirectory :
                     long delta1, delta2;
                     long curr1 = cacheSuccesses.GetCurrentValueAndDelta(out delta1);
                     long curr2 = cacheLookups.GetCurrentValueAndDelta(out delta2);
-                    return String.Format("{0}, Delta={1}", 
-                        (curr2 != 0 ? (float)curr1 / (float)curr2 : 0)
-                        ,(delta2 !=0 ? (float)delta1 / (float)delta2 : 0));
+                    return $"{(curr2 != 0 ? (float)curr1 / (float)curr2 : 0)}, Delta={(delta2 != 0 ? (float)delta1 / (float)delta2 : 0)}";
                 });
 
             CacheValidationsSent = CounterStatistic.FindOrCreate(StatisticNames.DIRECTORY_VALIDATIONS_CACHE_SENT);
@@ -196,10 +194,7 @@ public void Start()
         {
             log.Info("Start");
             Running = true;
-            if (maintainer != null)
-            {
-                maintainer.Start();
-            }
+            maintainer?.Start();
         }
 
         // Note that this implementation stops processing directory change requests (Register, Unregister, etc.) when the Stop event is raised. 
@@ -218,10 +213,7 @@ public void Stop()
             //mark Running as false will exclude myself from CalculateGrainDirectoryPartition(grainId)
             Running = false;
 
-            if (maintainer != null)
-            {
-                maintainer.Stop();
-            }
+            maintainer?.Stop();
 
             DirectoryPartition.Clear();
             DirectoryCache.Clear();
@@ -281,7 +273,7 @@ protected void RemoveServer(SiloAddress silo, SiloStatus status)
                 catch (Exception exc)
                 {
                     log.Error(ErrorCode.Directory_SiloStatusChangeNotification_Exception,
-                        String.Format("CatalogSiloStatusListener.SiloStatusChangeNotification has thrown an exception when notified about removed silo {0}.", silo.ToStringWithHashCode()), exc);
+                        $"CatalogSiloStatusListener.SiloStatusChangeNotification has thrown an exception when notified about removed silo {silo.ToStringWithHashCode()}.", exc);
                 }
 
                 var existing = this.directoryMembership;
@@ -845,7 +837,7 @@ public async Task<AddressesAndTag> LookupAsync(GrainId grainId, int hopCount = 0
                 // Just a optimization. Why sending a message to someone we know is not valid.
                 if (!IsValidSilo(forwardAddress))
                 {
-                    throw new OrleansException(String.Format("Current directory at {0} is not stable to perform the lookup for grainId {1} (it maps to {2}, which is not a valid silo). Retry later.", MyAddress, grainId, forwardAddress));
+                    throw new OrleansException($"Current directory at {MyAddress} is not stable to perform the lookup for grainId {grainId} (it maps to {forwardAddress}, which is not a valid silo). Retry later.");
                 }
 
                 RemoteLookupsSent.Increment();
diff --git a/src/Orleans.Runtime/MembershipService/ClusterHealthMonitor.cs b/src/Orleans.Runtime/MembershipService/ClusterHealthMonitor.cs
index 2ef846d3c..57c616098 100644
--- a/src/Orleans.Runtime/MembershipService/ClusterHealthMonitor.cs
+++ b/src/Orleans.Runtime/MembershipService/ClusterHealthMonitor.cs
@@ -131,7 +131,7 @@ await foreach (var tableSnapshot in this.membershipService.MembershipTableUpdate
             if (myIndex < 0)
             {
                 // this should not happen ...
-                var error = string.Format("This silo {0} status {1} is not in its own local silo list! This is a bug!", self.SiloAddress.ToLongString(), self.Status);
+                var error = $"This silo {self.SiloAddress.ToLongString()} status {self.Status} is not in its own local silo list! This is a bug!";
                 log.Error(ErrorCode.Runtime_Error_100305, error);
                 throw new OrleansMissingMembershipEntryException(error);
             }
diff --git a/src/Orleans.Runtime/MembershipService/InMemoryMembershipTable.cs b/src/Orleans.Runtime/MembershipService/InMemoryMembershipTable.cs
index 02ee50c92..de9878dda 100644
--- a/src/Orleans.Runtime/MembershipService/InMemoryMembershipTable.cs
+++ b/src/Orleans.Runtime/MembershipService/InMemoryMembershipTable.cs
@@ -78,7 +78,7 @@ public void UpdateIAmAlive(MembershipEntry entry)
 
         public override string ToString()
         {
-            return String.Format("Table = {0}, ETagCounter={1}", ReadAll().ToString(), lastETagCounter);
+            return $"Table = {ReadAll().ToString()}, ETagCounter={lastETagCounter}";
         }
 
         private string NewETag()
diff --git a/src/Orleans.Runtime/MembershipService/MembershipTableManager.cs b/src/Orleans.Runtime/MembershipService/MembershipTableManager.cs
index ddd20c83d..98e47ed30 100644
--- a/src/Orleans.Runtime/MembershipService/MembershipTableManager.cs
+++ b/src/Orleans.Runtime/MembershipService/MembershipTableManager.cs
@@ -218,14 +218,12 @@ private void DetectNodeMigration(MembershipTableSnapshot snapshot, string myHost
                 bool physicalHostChanged = !myHostname.Equals(mostRecentPreviousEntry.HostName) || !myAddress.Endpoint.Equals(mostRecentPreviousEntry.SiloAddress.Endpoint);
                 if (physicalHostChanged)
                 {
-                    string error = string.Format("Silo {0} migrated from host {1} silo address {2} to host {3} silo address {4}.",
-                        mySiloName, myHostname, myAddress, mostRecentPreviousEntry.HostName, mostRecentPreviousEntry.SiloAddress);
+                    string error = $"Silo {mySiloName} migrated from host {myHostname} silo address {myAddress} to host {mostRecentPreviousEntry.HostName} silo address {mostRecentPreviousEntry.SiloAddress}.";
                     log.Warn(ErrorCode.MembershipNodeMigrated, error);
                 }
                 else
                 {
-                    string error = string.Format("Silo {0} restarted on same host {1} New silo address = {2} Previous silo address = {3}",
-                        mySiloName, myHostname, myAddress, mostRecentPreviousEntry.SiloAddress);
+                    string error = $"Silo {mySiloName} restarted on same host {myHostname} New silo address = {myAddress} Previous silo address = {mostRecentPreviousEntry.SiloAddress}";
                     log.Warn(ErrorCode.MembershipNodeRestarted, error);
                 }
             }
@@ -389,7 +387,7 @@ private async Task<bool> TryUpdateMyStatusGlobalOnce(SiloStatus newStatus)
 
             if (myEntry.Status == SiloStatus.Dead && myEntry.Status != newStatus)
             {
-                var msg = string.Format("I should be Dead according to membership table (in TryUpdateMyStatusGlobalOnce): myEntry = {0}.", myEntry.ToFullString(full: true));
+                var msg = $"I should be Dead according to membership table (in TryUpdateMyStatusGlobalOnce): myEntry = {myEntry.ToFullString(full: true)}.";
                 this.log.Warn(ErrorCode.MembershipFoundMyselfDead1, msg);
                 this.KillMyselfLocally(msg);
                 return true;
@@ -513,7 +511,7 @@ private async Task<bool> CleanupMyTableEntries(MembershipTableData table)
                 {
                     if (entry.Status == SiloStatus.Dead)
                     {
-                        var msg = string.Format("I should be Dead according to membership table (in CleanupTableEntries): entry = {0}.", entry.ToFullString(full: true));
+                        var msg = $"I should be Dead according to membership table (in CleanupTableEntries): entry = {entry.ToFullString(full: true)}.";
                         log.Warn(ErrorCode.MembershipFoundMyselfDead2, msg);
                         KillMyselfLocally(msg);
                     }
@@ -540,8 +538,7 @@ private async Task<bool> CleanupMyTableEntries(MembershipTableData table)
                 else if (siloAddress.Generation > myAddress.Generation)
                 {
                     // I am the older clone - Newer version of me should survive - I need to kill myself
-                    var msg = string.Format("Detected newer version of myself - I am the older clone so I will stop -- Current Me={0} Newer Me={1}, Current entry= {2}",
-                        myAddress, siloAddress, entry.ToFullString());
+                    var msg = $"Detected newer version of myself - I am the older clone so I will stop -- Current Me={myAddress} Newer Me={siloAddress}, Current entry= {entry.ToFullString()}";
                     log.Warn(ErrorCode.MembershipDetectedNewer, msg);
                     await this.UpdateStatus(SiloStatus.Dead);
                     KillMyselfLocally(msg);
@@ -629,7 +626,7 @@ public async Task<bool> TryKill(SiloAddress silo)
             var (localSiloEntry, _) = this.GetOrCreateLocalSiloEntry(table, this.CurrentStatus);
             if (localSiloEntry.Status == SiloStatus.Dead)
             {
-                var msg = string.Format("I should be Dead according to membership table (in TryKill): entry = {0}.", localSiloEntry.ToFullString(full: true));
+                var msg = $"I should be Dead according to membership table (in TryKill): entry = {localSiloEntry.ToFullString(full: true)}.";
                 log.LogWarning((int)ErrorCode.MembershipFoundMyselfDead3, msg);
                 KillMyselfLocally(msg);
                 return true;
@@ -637,7 +634,7 @@ public async Task<bool> TryKill(SiloAddress silo)
 
             if (!table.Contains(silo))
             {
-                var str = string.Format("Could not find silo entry for silo {0} in the table.", silo);
+                var str = $"Could not find silo entry for silo {silo} in the table.";
                 log.LogError((int)ErrorCode.MembershipFailedToReadSilo, str);
                 throw new KeyNotFoundException(str);
             }
@@ -678,7 +675,7 @@ public async Task<bool> TryToSuspectOrKill(SiloAddress silo)
             var (localSiloEntry, _) = this.GetOrCreateLocalSiloEntry(table, this.CurrentStatus);
             if (localSiloEntry.Status == SiloStatus.Dead)
             {
-                var msg = string.Format("I should be Dead according to membership table (in TryToSuspectOrKill): entry = {0}.", localSiloEntry.ToFullString(full: true));
+                var msg = $"I should be Dead according to membership table (in TryToSuspectOrKill): entry = {localSiloEntry.ToFullString(full: true)}.";
                 log.Warn(ErrorCode.MembershipFoundMyselfDead3, msg);
                 KillMyselfLocally(msg);
                 return true;
@@ -687,7 +684,7 @@ public async Task<bool> TryToSuspectOrKill(SiloAddress silo)
             if (!table.Contains(silo))
             {
                 // this should not happen ...
-                var str = string.Format("-Could not find silo entry for silo {0} in the table.", silo);
+                var str = $"-Could not find silo entry for silo {silo} in the table.";
                 log.Error(ErrorCode.MembershipFailedToReadSilo, str);
                 throw new KeyNotFoundException(str);
             }
@@ -717,8 +714,7 @@ public async Task<bool> TryToSuspectOrKill(SiloAddress silo)
             if (freshVotes.Count >= this.clusterMembershipOptions.NumVotesForDeathDeclaration)
             {
                 // this should not happen ...
-                var str = string.Format("-Silo {0} is suspected by {1} which is more or equal than {2}, but is not marked as dead. This is a bug!!!",
-                    entry.SiloAddress, freshVotes.Count.ToString(), this.clusterMembershipOptions.NumVotesForDeathDeclaration.ToString());
+                var str = $"-Silo {entry.SiloAddress} is suspected by {freshVotes.Count.ToString()} which is more or equal than {this.clusterMembershipOptions.NumVotesForDeathDeclaration.ToString()}, but is not marked as dead. This is a bug!!!";
                 log.Error(ErrorCode.Runtime_Error_100053, str);
                 KillMyselfLocally("Found a bug! Will stop.");
                 return false;
@@ -807,8 +803,7 @@ public async Task<bool> TryToSuspectOrKill(SiloAddress silo)
 
             string PrintSuspectList(IEnumerable<Tuple<SiloAddress, DateTime>> list)
             {
-                return Utils.EnumerableToString(list, t => string.Format("<{0}, {1}>",
-                    t.Item1, LogFormatter.PrintDate(t.Item2)));
+                return Utils.EnumerableToString(list, t => $"<{t.Item1}, {LogFormatter.PrintDate(t.Item2)}>");
             }
         }
 
diff --git a/src/Orleans.Runtime/Networking/GatewayInboundConnection.cs b/src/Orleans.Runtime/Networking/GatewayInboundConnection.cs
index afebd58cb..edb725443 100644
--- a/src/Orleans.Runtime/Networking/GatewayInboundConnection.cs
+++ b/src/Orleans.Runtime/Networking/GatewayInboundConnection.cs
@@ -151,7 +151,7 @@ public void FailMessage(Message msg, string reason)
                 if (this.Log.IsEnabled(LogLevel.Debug)) this.Log.Debug(ErrorCode.MessagingSendingRejection, "Silo {siloAddress} is rejecting message: {message}. Reason = {reason}", this.myAddress, msg, reason);
 
                 // Done retrying, send back an error instead
-                this.messageCenter.SendRejection(msg, Message.RejectionTypes.Transient, String.Format("Silo {0} is rejecting message: {1}. Reason = {2}", this.myAddress, msg, reason));
+                this.messageCenter.SendRejection(msg, Message.RejectionTypes.Transient, $"Silo {this.myAddress} is rejecting message: {msg}. Reason = {reason}");
             }
             else
             {
diff --git a/src/Orleans.Runtime/Placement/ActivationCountPlacementDirector.cs b/src/Orleans.Runtime/Placement/ActivationCountPlacementDirector.cs
index 58b48712a..206c56c7e 100644
--- a/src/Orleans.Runtime/Placement/ActivationCountPlacementDirector.cs
+++ b/src/Orleans.Runtime/Placement/ActivationCountPlacementDirector.cs
@@ -101,10 +101,7 @@ private Task<SiloAddress> SelectSiloPowerOfK(PlacementTarget target, IPlacementC
             }
 
             var all = localCache.ToList();
-            var debugLog = string.Format("Unable to select a candidate from {0} silos: {1}", all.Count,
-                Utils.EnumerableToString(
-                    all,
-                    kvp => String.Format("SiloAddress = {0} -> {1}", kvp.Key.ToString(), kvp.Value.ToString())));
+            var debugLog = $"Unable to select a candidate from {all.Count} silos: {Utils.EnumerableToString(all, kvp => String.Format("SiloAddress = {0} -> {1}", kvp.Key.ToString(), kvp.Value.ToString()))}";
             logger.Warn(ErrorCode.Placement_ActivationCountBasedDirector_NoSilos, debugLog);
             throw new OrleansException(debugLog);
         }
diff --git a/src/Orleans.Runtime/Placement/DeploymentLoadPublisher.cs b/src/Orleans.Runtime/Placement/DeploymentLoadPublisher.cs
index b9df879eb..d565baa11 100644
--- a/src/Orleans.Runtime/Placement/DeploymentLoadPublisher.cs
+++ b/src/Orleans.Runtime/Placement/DeploymentLoadPublisher.cs
@@ -160,7 +160,7 @@ public Task UpdateRuntimeStatistics(SiloAddress siloAddress, SiloRuntimeStatisti
                                         else
                                         {
                                             logger.Warn(ErrorCode.Placement_RuntimeStatisticsUpdateFailure_3,
-                                                String.Format("An unexpected exception was thrown from RefreshStatistics by ISiloControl.GetRuntimeStatistics({0}). Will keep using stale statistics.", capture),
+                                                $"An unexpected exception was thrown from RefreshStatistics by ISiloControl.GetRuntimeStatistics({capture}). Will keep using stale statistics.",
                                                 statsTask.Exception);
                                         }
                                     });
diff --git a/src/Orleans.Runtime/ReminderService/LocalReminderService.cs b/src/Orleans.Runtime/ReminderService/LocalReminderService.cs
index ff335a3df..65d8236a2 100644
--- a/src/Orleans.Runtime/ReminderService/LocalReminderService.cs
+++ b/src/Orleans.Runtime/ReminderService/LocalReminderService.cs
@@ -102,7 +102,7 @@ public async Task<IGrainReminder> RegisterOrUpdateReminder(GrainReference grainR
                 return new ReminderData(grainRef, reminderName, newEtag) as IGrainReminder;
             }
 
-            var msg = string.Format("Could not register reminder {0} to reminder table due to a race. Please try again later.", entry);
+            var msg = $"Could not register reminder {entry} to reminder table due to a race. Please try again later.";
             logger.Error(ErrorCode.RS_Register_TableError, msg);
             throw new ReminderException(msg);
         }
@@ -134,7 +134,7 @@ public async Task UnregisterReminder(IGrainReminder reminder)
                 if (removed)
                 {
                     if(logger.IsEnabled(LogLevel.Debug)) logger.Debug(ErrorCode.RS_Stop, "Stopped reminder {0}", reminder);
-                    if (logger.IsEnabled(LogLevel.Trace)) PrintReminders(string.Format("After removing {0}.", reminder));
+                    if (logger.IsEnabled(LogLevel.Trace)) PrintReminders($"After removing {reminder}.");
                 }
                 else
                 {
@@ -144,7 +144,7 @@ public async Task UnregisterReminder(IGrainReminder reminder)
             }
             else
             {
-                var msg = string.Format("Could not unregister reminder {0} from the reminder table, due to tag mismatch. You can retry.", reminder);
+                var msg = $"Could not unregister reminder {reminder} from the reminder table, due to tag mismatch. You can retry.";
                 logger.Error(ErrorCode.RS_Unregister_TableError, msg);
                 throw new ReminderException(msg);
             }
@@ -265,7 +265,7 @@ private async Task DoInitialReadAndUpdateReminders()
                 {
                     logger.Warn(
                         ErrorCode.RS_ServiceInitialLoadFailing,
-                        string.Format("ReminderService failed initial load of reminders and will retry. Attempt #{0}", this.initialReadCallCount),
+                        $"ReminderService failed initial load of reminders and will retry. Attempt #{this.initialReadCallCount}",
                         ex);
                 }
                 else
@@ -479,8 +479,7 @@ private void PrintReminders(string msg = null)
         {
             if (!logger.IsEnabled(LogLevel.Trace)) return;
 
-            var str = String.Format("{0}{1}{2}", (msg ?? "Current list of reminders:"), Environment.NewLine,
-                Utils.EnumerableToString(localReminders, null, Environment.NewLine));
+            var str = $"{(msg ?? "Current list of reminders:")}{Environment.NewLine}{Utils.EnumerableToString(localReminders, null, Environment.NewLine)}";
             logger.Trace(str);
         }
 
@@ -626,7 +625,7 @@ public async Task OnTimerTick()
                     var after = DateTime.UtcNow;
                     logger.Error(
                         ErrorCode.RS_Tick_Delivery_Error,
-                        string.Format("Could not deliver reminder tick for {0}, next {1}.",  this.ToString(), after + this.period),
+                        $"Could not deliver reminder tick for {this.ToString()}, next {after + this.period}.",
                             exc);
                     // What to do with repeated failures to deliver a reminder's ticks?
                 }
@@ -634,14 +633,7 @@ public async Task OnTimerTick()
 
             public override string ToString()
             {
-                return string.Format("[{0}, {1}, {2}, {3}, {4}, {5}, {6}]",
-                                        Identity.ReminderName,
-                                        Identity.GrainRef?.ToString(),
-                                        period,
-                                        LogFormatter.PrintDate(firstTickTime),
-                                        ETag,
-                                        LocalSequenceNumber,
-                                        timer == null ? "Not_ticking" : "Ticking");
+                return $"[{Identity.ReminderName}, {Identity.GrainRef?.ToString()}, {period}, {LogFormatter.PrintDate(firstTickTime)}, {ETag}, {LocalSequenceNumber}, {(timer == null ? "Not_ticking" : "Ticking")}]";
             }
         }
 
diff --git a/src/Orleans.Runtime/ReminderService/ReminderRegistry.cs b/src/Orleans.Runtime/ReminderService/ReminderRegistry.cs
index e4c8b8904..d2fc69684 100644
--- a/src/Orleans.Runtime/ReminderService/ReminderRegistry.cs
+++ b/src/Orleans.Runtime/ReminderService/ReminderRegistry.cs
@@ -57,11 +57,7 @@ public Task<IGrainReminder> RegisterOrUpdateReminder(string reminderName, TimeSp
             if (period < minReminderPeriod)
             {
                 var msg =
-                    string.Format(
-                        "Cannot register reminder {0} as requested period ({1}) is less than minimum allowed reminder period ({2})",
-                        reminderName,
-                        period,
-                        minReminderPeriod);
+                    $"Cannot register reminder {reminderName} as requested period ({period}) is less than minimum allowed reminder period ({minReminderPeriod})";
                 throw new ArgumentException(msg);
             }
             if (string.IsNullOrEmpty(reminderName))
diff --git a/src/Orleans.Runtime/Scheduler/ActivationTaskScheduler.cs b/src/Orleans.Runtime/Scheduler/ActivationTaskScheduler.cs
index c20c1090a..bbc34a5ab 100644
--- a/src/Orleans.Runtime/Scheduler/ActivationTaskScheduler.cs
+++ b/src/Orleans.Runtime/Scheduler/ActivationTaskScheduler.cs
@@ -114,7 +114,7 @@ protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQu
 
         public override string ToString()
         {
-            return string.Format("{0}-{1}:Queued={2}", GetType().Name, myId, workerGroup.ExternalWorkItemCount);
+            return $"{GetType().Name}-{myId}:Queued={workerGroup.ExternalWorkItemCount}";
         }
     }
 }
diff --git a/src/Orleans.Runtime/Scheduler/ClosureWorkItem.cs b/src/Orleans.Runtime/Scheduler/ClosureWorkItem.cs
index 81a0b1e06..cbe876952 100644
--- a/src/Orleans.Runtime/Scheduler/ClosureWorkItem.cs
+++ b/src/Orleans.Runtime/Scheduler/ClosureWorkItem.cs
@@ -52,10 +52,7 @@ public override async void Execute()
         internal static string GetMethodName(Delegate action)
         {
             var continuationMethodInfo = action.GetMethodInfo();
-            return string.Format(
-                "{0}->{1}",
-                action.Target?.ToString() ?? string.Empty,
-                continuationMethodInfo == null ? string.Empty : continuationMethodInfo.ToString());
+            return $"{action.Target?.ToString() ?? string.Empty}->{(continuationMethodInfo == null ? string.Empty : continuationMethodInfo.ToString())}";
         }
     }
 
diff --git a/src/Orleans.Runtime/Scheduler/InvokeWorkItem.cs b/src/Orleans.Runtime/Scheduler/InvokeWorkItem.cs
index c83944287..36548bbdf 100644
--- a/src/Orleans.Runtime/Scheduler/InvokeWorkItem.cs
+++ b/src/Orleans.Runtime/Scheduler/InvokeWorkItem.cs
@@ -75,7 +75,7 @@ private void OnComplete()
 
         public override string ToString()
         {
-            return String.Format("{0} for activation={1} Message={2}", base.ToString(), activation, message);
+            return $"{base.ToString()} for activation={activation} Message={message}";
         }
     }
 }
diff --git a/src/Orleans.Runtime/Scheduler/OrleansTaskScheduler.cs b/src/Orleans.Runtime/Scheduler/OrleansTaskScheduler.cs
index e882cda28..906e2d16b 100644
--- a/src/Orleans.Runtime/Scheduler/OrleansTaskScheduler.cs
+++ b/src/Orleans.Runtime/Scheduler/OrleansTaskScheduler.cs
@@ -280,7 +280,7 @@ internal void DumpSchedulerStatus(bool alwaysOutput = true)
 
             if (logger.IsEnabled(LogLevel.Information))
             {
-                var stats = Utils.EnumerableToString(all.Select(i => i.Value).OrderBy(wg => wg.Name), wg => string.Format("--{0}", wg.DumpStatus()), Environment.NewLine);
+                var stats = Utils.EnumerableToString(all.Select(i => i.Value).OrderBy(wg => wg.Name), wg => $"--{wg.DumpStatus()}", Environment.NewLine);
                 if (stats.Length > 0)
                     logger.Info(ErrorCode.SchedulerStatistics,
                         "OrleansTaskScheduler.PrintStatistics(): WorkItems={0}, Directory:" + Environment.NewLine + "{1}", all.Count, stats);
diff --git a/src/Orleans.Runtime/Scheduler/RequestWorkItem.cs b/src/Orleans.Runtime/Scheduler/RequestWorkItem.cs
index f008aa745..e98c979e3 100644
--- a/src/Orleans.Runtime/Scheduler/RequestWorkItem.cs
+++ b/src/Orleans.Runtime/Scheduler/RequestWorkItem.cs
@@ -37,7 +37,7 @@ public override void Execute()
 
         public override string ToString()
         {
-            return String.Format("{0}: {1} -> {2}", base.ToString(), target, request);
+            return $"{base.ToString()}: {target} -> {request}";
         }
     }
 }
diff --git a/src/Orleans.Runtime/Scheduler/ResponseWorkItem.cs b/src/Orleans.Runtime/Scheduler/ResponseWorkItem.cs
index e89e30137..08eb220a5 100644
--- a/src/Orleans.Runtime/Scheduler/ResponseWorkItem.cs
+++ b/src/Orleans.Runtime/Scheduler/ResponseWorkItem.cs
@@ -37,7 +37,7 @@ public override void Execute()
 
         public override string ToString()
         {
-            return String.Format("{0}: Grain: {1} -> {2}", base.ToString(), target, response);
+            return $"{base.ToString()}: Grain: {target} -> {response}";
         }
     }
 }
diff --git a/src/Orleans.Runtime/Scheduler/WorkItemBase.cs b/src/Orleans.Runtime/Scheduler/WorkItemBase.cs
index 34e1618db..837df7556 100644
--- a/src/Orleans.Runtime/Scheduler/WorkItemBase.cs
+++ b/src/Orleans.Runtime/Scheduler/WorkItemBase.cs
@@ -23,11 +23,7 @@ public TimeSpan TimeSinceQueued
 
         public override string ToString()
         {
-            return string.Format("[{0} WorkItem Name={1}, Ctx={2}]", 
-                ItemType, 
-                Name ?? string.Empty,
-                GrainContext?.ToString() ?? "null"
-            );
+            return $"[{ItemType} WorkItem Name={Name ?? string.Empty}, Ctx={GrainContext?.ToString() ?? "null"}]";
         }
     }
 }
diff --git a/src/Orleans.Runtime/Silo/Silo.cs b/src/Orleans.Runtime/Silo/Silo.cs
index ec33c8438..94051c3cb 100644
--- a/src/Orleans.Runtime/Silo/Silo.cs
+++ b/src/Orleans.Runtime/Silo/Silo.cs
@@ -274,7 +274,7 @@ private Task OnRuntimeInitializeStart(CancellationToken ct)
             lock (lockable)
             {
                 if (!this.SystemStatus.Equals(SystemStatus.Created))
-                    throw new InvalidOperationException(String.Format("Calling Silo.Start() on a silo which is not in the Created state. This silo is in the {0} state.", this.SystemStatus));
+                    throw new InvalidOperationException($"Calling Silo.Start() on a silo which is not in the Created state. This silo is in the {this.SystemStatus} state.");
 
                 this.SystemStatus = SystemStatus.Starting;
             }
@@ -356,7 +356,7 @@ await this.LocalScheduler.QueueTask(deploymentLoadPublisher.Start, deploymentLoa
             }
             catch (Exception exc)
             {
-                this.SafeExecute(() => this.logger.Error(ErrorCode.Runtime_Error_100330, String.Format("Error starting silo {0}. Going to FastKill().", this.SiloAddress), exc));
+                this.SafeExecute(() => this.logger.Error(ErrorCode.Runtime_Error_100330, $"Error starting silo {this.SiloAddress}. Going to FastKill().", exc));
                 throw;
             }
             if (logger.IsEnabled(LogLevel.Debug)) { logger.Debug("Silo.Start complete: System status = {0}", this.SystemStatus); }
diff --git a/src/Orleans.Runtime/Timers/GrainTimer.cs b/src/Orleans.Runtime/Timers/GrainTimer.cs
index 6174df8dc..111508922 100644
--- a/src/Orleans.Runtime/Timers/GrainTimer.cs
+++ b/src/Orleans.Runtime/Timers/GrainTimer.cs
@@ -58,7 +58,7 @@ private GrainTimer(OrleansTaskScheduler scheduler, IActivationData activationDat
         public void Start()
         {
             if (TimerAlreadyStopped)
-                throw new ObjectDisposedException(String.Format("The timer {0} was already disposed.", GetFullName()));
+                throw new ObjectDisposedException($"The timer {GetFullName()} was already disposed.");
 
             timer.Start(dueTime, timerFrequency);
         }
@@ -80,8 +80,7 @@ private async Task TimerTick(object state, IGrainContext context)
             catch (InvalidSchedulingContextException exc)
             {
                 logger.Error(ErrorCode.Timer_InvalidContext,
-                    string.Format("Caught an InvalidSchedulingContextException on timer {0}, context is {1}. Going to dispose this timer!",
-                        GetFullName(), context), exc);
+                    $"Caught an InvalidSchedulingContextException on timer {GetFullName()}, context is {context}. Going to dispose this timer!", exc);
                 DisposeTimer();
             }
         }
@@ -109,10 +108,7 @@ private async Task ForwardToAsyncCallback(object state)
             {
                 logger.Error( 
                     ErrorCode.Timer_GrainTimerCallbackError,
-                    string.Format( "Caught and ignored exception: {0} with message: {1} thrown from timer callback {2}",
-                        exc.GetType(),
-                        exc.Message,
-                        GetFullName()),
+                    $"Caught and ignored exception: {exc.GetType()} with message: {exc.Message} thrown from timer callback {GetFullName()}",
                     exc);       
             }
             finally
diff --git a/src/Orleans.Streaming.Abstractions/LegacyStreamId.cs b/src/Orleans.Streaming.Abstractions/LegacyStreamId.cs
index 535586e1f..17f6e8604 100644
--- a/src/Orleans.Streaming.Abstractions/LegacyStreamId.cs
+++ b/src/Orleans.Streaming.Abstractions/LegacyStreamId.cs
@@ -89,7 +89,7 @@ public override string ToString()
         {
             return Namespace == null ? 
                 Guid.ToString() : 
-                String.Format("{0}-{1}-{2}", Namespace, Guid, ProviderName);
+                $"{Namespace}-{Guid}-{ProviderName}";
         }
 
         public void GetObjectData(SerializationInfo info, StreamingContext context)
diff --git a/src/Orleans.Streaming/Common/EventSequenceToken.cs b/src/Orleans.Streaming/Common/EventSequenceToken.cs
index d0bac2b66..5bc50b132 100644
--- a/src/Orleans.Streaming/Common/EventSequenceToken.cs
+++ b/src/Orleans.Streaming/Common/EventSequenceToken.cs
@@ -72,8 +72,7 @@ public override bool Equals(object obj)
         /// <param name="other">An object to compare with this object.</param>
         public override bool Equals(StreamSequenceToken other)
         {
-            var token = other as EventSequenceToken;
-            return token != null && (token.SequenceNumber == SequenceNumber &&
+            return other is EventSequenceToken token && (token.SequenceNumber == SequenceNumber &&
                                      token.EventIndex == EventIndex);
         }
 
diff --git a/src/Orleans.Streaming/Common/EventSequenceTokenV2.cs b/src/Orleans.Streaming/Common/EventSequenceTokenV2.cs
index 8aaecfc12..a4f18ba7e 100644
--- a/src/Orleans.Streaming/Common/EventSequenceTokenV2.cs
+++ b/src/Orleans.Streaming/Common/EventSequenceTokenV2.cs
@@ -72,8 +72,7 @@ public override bool Equals(object obj)
         /// <param name="other">An object to compare with this object.</param>
         public override bool Equals(StreamSequenceToken other)
         {
-            var token = other as EventSequenceTokenV2;
-            return token != null && (token.SequenceNumber == SequenceNumber &&
+            return other is EventSequenceTokenV2 token && (token.SequenceNumber == SequenceNumber &&
                                      token.EventIndex == EventIndex);
         }
 
diff --git a/src/Orleans.Streaming/Internal/StreamImpl.cs b/src/Orleans.Streaming/Internal/StreamImpl.cs
index 4f120cc78..1c4eab113 100644
--- a/src/Orleans.Streaming/Internal/StreamImpl.cs
+++ b/src/Orleans.Streaming/Internal/StreamImpl.cs
@@ -182,14 +182,12 @@ public int CompareTo(IAsyncStream<T> other)
 
         public bool Equals(IAsyncStream<T> other)
         {
-            var o = other as StreamImpl<T>;
-            return o != null && streamId.Equals(o.streamId);
+            return other is StreamImpl<T> o && streamId.Equals(o.streamId);
         }
 
         public override bool Equals(object obj)
         {
-            var o = obj as StreamImpl<T>;
-            return o != null && streamId.Equals(o.streamId);
+            return obj is StreamImpl<T> o && streamId.Equals(o.streamId);
         }
 
         public override int GetHashCode()
diff --git a/src/Orleans.Streaming/Internal/StreamSubscriptionHandleImpl.cs b/src/Orleans.Streaming/Internal/StreamSubscriptionHandleImpl.cs
index 017c89919..4d5b9aef7 100644
--- a/src/Orleans.Streaming/Internal/StreamSubscriptionHandleImpl.cs
+++ b/src/Orleans.Streaming/Internal/StreamSubscriptionHandleImpl.cs
@@ -233,8 +233,7 @@ internal bool SameStreamId(InternalStreamId streamId)
 
         public override bool Equals(StreamSubscriptionHandle<T> other)
         {
-            var o = other as StreamSubscriptionHandleImpl<T>;
-            return o != null && SubscriptionId.Equals(o.SubscriptionId);
+            return other is StreamSubscriptionHandleImpl<T> o && SubscriptionId.Equals(o.SubscriptionId);
         }
 
         public override bool Equals(object obj)
@@ -249,7 +248,7 @@ public override int GetHashCode()
 
         public override string ToString()
         {
-            return String.Format("StreamSubscriptionHandleImpl:Stream={0},HandleId={1}", IsValid ? streamImpl.InternalStreamId.ToString() : "null", HandleId);
+            return $"StreamSubscriptionHandleImpl:Stream={(IsValid ? streamImpl.InternalStreamId.ToString() : "null")},HandleId={HandleId}";
         }
     }
 }
diff --git a/src/Orleans.Streaming/PersistentStreams/PersistentStreamProvider.cs b/src/Orleans.Streaming/PersistentStreams/PersistentStreamProvider.cs
index 3b57b2a82..94da3e092 100644
--- a/src/Orleans.Streaming/PersistentStreams/PersistentStreamProvider.cs
+++ b/src/Orleans.Streaming/PersistentStreams/PersistentStreamProvider.cs
@@ -79,8 +79,7 @@ private async Task Start(CancellationToken token)
             if (this.queueAdapter.Direction.Equals(StreamProviderDirection.ReadOnly) ||
                 this.queueAdapter.Direction.Equals(StreamProviderDirection.ReadWrite))
             {
-                var siloRuntime = this.runtime as ISiloSideStreamProviderRuntime;
-                if (siloRuntime != null)
+                if (this.runtime is ISiloSideStreamProviderRuntime siloRuntime)
                 {
                     this.pullingAgentManager = await siloRuntime.InitializePullingAgents(this.Name, this.adapterFactory, this.queueAdapter);
 
diff --git a/src/Orleans.Streaming/PersistentStreams/PersistentStreamPullingManager.cs b/src/Orleans.Streaming/PersistentStreams/PersistentStreamPullingManager.cs
index d143fc09c..db301942e 100644
--- a/src/Orleans.Streaming/PersistentStreams/PersistentStreamPullingManager.cs
+++ b/src/Orleans.Streaming/PersistentStreams/PersistentStreamPullingManager.cs
@@ -96,7 +96,7 @@ public async Task Initialize(Immutable<IQueueAdapter> qAdapter)
             queueBalancer.SubscribeToQueueDistributionChangeEvents(this);
 
             List<QueueId> myQueues = queueBalancer.GetMyQueues().ToList();
-            Log(ErrorCode.PersistentStreamPullingManager_03, String.Format("Initialize: I am now responsible for {0} queues: {1}.", myQueues.Count, PrintQueues(myQueues)));
+            Log(ErrorCode.PersistentStreamPullingManager_03, $"Initialize: I am now responsible for {myQueues.Count} queues: {PrintQueues(myQueues)}.");
 
             queuePrintTimer = this.RegisterTimer(AsyncTimerCallback, null, QUEUES_PRINT_PERIOD, QUEUES_PRINT_PERIOD);
             managerState = RunState.Initialized;
@@ -269,7 +269,7 @@ private async Task InitAgent(PersistentStreamPullingAgent agent)
             IStreamFailureHandler deliveryFailureHandler = await adapterFactory.GetDeliveryFailureHandler(agent.QueueId);
             // Need to call it as a grain reference.
             var task = OrleansTaskExtentions.SafeExecute(() => agentGrainRef.Initialize(queueAdapter.AsImmutable(), queueAdapterCacheAsImmutable, deliveryFailureHandler.AsImmutable()));
-            await task.LogException(logger, ErrorCode.PersistentStreamPullingManager_09, String.Format("PersistentStreamPullingAgent {0} failed to Initialize.", agent.QueueId));
+            await task.LogException(logger, ErrorCode.PersistentStreamPullingManager_09, $"PersistentStreamPullingAgent {agent.QueueId} failed to Initialize.");
         }
 
         private async Task RemoveQueues(List<QueueId> queuesToRemove)
@@ -293,7 +293,7 @@ private async Task RemoveQueues(List<QueueId> queuesToRemove)
                 var agentGrainRef = agent.AsReference<IPersistentStreamPullingAgent>();
                 var task = OrleansTaskExtentions.SafeExecute(agentGrainRef.Shutdown);
                 task = task.LogException(logger, ErrorCode.PersistentStreamPullingManager_11,
-                    String.Format("PersistentStreamPullingAgent {0} failed to Shutdown.", agent.QueueId));
+                    $"PersistentStreamPullingAgent {agent.QueueId} failed to Shutdown.");
                 removeTasks.Add(task);
             }
             try
@@ -337,8 +337,7 @@ public async Task<object> ExecuteCommand(PersistentStreamProviderCommand command
             try
             {
                 Log(ErrorCode.PersistentStreamPullingManager_13,
-                    String.Format("Got command {0}{1}: commandSeqNumber = {2}, managerState = {3}.",
-                    command, arg != null ? " with arg " + arg : String.Empty, commandSeqNumber, managerState));
+                    $"Got command {command}{(arg != null ? " with arg " + arg : String.Empty)}: commandSeqNumber = {commandSeqNumber}, managerState = {managerState}.");
 
                 switch (command)
                 {
@@ -351,14 +350,13 @@ public async Task<object> ExecuteCommand(PersistentStreamProviderCommand command
                     case PersistentStreamProviderCommand.GetNumberRunningAgents:
                         return NumberRunningAgents;
                     default:
-                        throw new OrleansException(String.Format("PullingAgentManager does not support command {0}.", command));
+                        throw new OrleansException($"PullingAgentManager does not support command {command}.");
                 }
             }
             finally
             {
                 Log(ErrorCode.PersistentStreamPullingManager_15,
-                    String.Format("Done executing command {0}: commandSeqNumber = {1}, managerState = {2}, num running agents = {3}.", 
-                    command, commandSeqNumber, managerState, NumberRunningAgents));
+                    $"Done executing command {command}: commandSeqNumber = {commandSeqNumber}, managerState = {managerState}, num running agents = {NumberRunningAgents}.");
             }
         }
 
@@ -384,7 +382,7 @@ private Task QueueCommandForExecution(PersistentStreamProviderCommand command, i
                     case PersistentStreamProviderCommand.StopAgents:
                         return StopAgents();
                     default:
-                        throw new OrleansException(String.Format("PullingAgentManager got unsupported command {0}", command));
+                        throw new OrleansException($"PullingAgentManager got unsupported command {command}");
                 }
             });
         }
diff --git a/src/Orleans.Streaming/PersistentStreams/QueueStreamDataStructures.cs b/src/Orleans.Streaming/PersistentStreams/QueueStreamDataStructures.cs
index c88827795..cb272a735 100644
--- a/src/Orleans.Streaming/PersistentStreams/QueueStreamDataStructures.cs
+++ b/src/Orleans.Streaming/PersistentStreams/QueueStreamDataStructures.cs
@@ -38,7 +38,7 @@ internal void SafeDisposeCursor(ILogger logger)
                 {
                     // kill cursor activity and ensure it does not start again on this consumer data.
                     Utils.SafeExecute(Cursor.Dispose, logger,
-                        () => String.Format("Cursor.Dispose on stream {0}, StreamConsumer {1} has thrown exception.", StreamId, StreamConsumer));
+                        () => $"Cursor.Dispose on stream {StreamId}, StreamConsumer {StreamConsumer} has thrown exception.");
                 }
             }
             finally
diff --git a/src/Orleans.Streaming/PubSub/PubSubPublisherState.cs b/src/Orleans.Streaming/PubSub/PubSubPublisherState.cs
index 15529f26a..9ebfd64fd 100644
--- a/src/Orleans.Streaming/PubSub/PubSubPublisherState.cs
+++ b/src/Orleans.Streaming/PubSub/PubSubPublisherState.cs
@@ -64,7 +64,7 @@ public override int GetHashCode()
 
         public override string ToString()
         {
-            return string.Format("PubSubPublisherState:StreamId={0},Producer={1}.", Stream, Producer);
+            return $"PubSubPublisherState:StreamId={Stream},Producer={Producer}.";
         }
     }
 }
diff --git a/src/Orleans.Streaming/PubSub/PubSubRendezvousGrain.cs b/src/Orleans.Streaming/PubSub/PubSubRendezvousGrain.cs
index dac9e1aeb..0cb8e0224 100644
--- a/src/Orleans.Streaming/PubSub/PubSubRendezvousGrain.cs
+++ b/src/Orleans.Streaming/PubSub/PubSubRendezvousGrain.cs
@@ -311,8 +311,7 @@ public async Task Validate()
 
         public Task<List<StreamSubscription>> GetAllSubscriptions(InternalStreamId streamId, IStreamConsumerExtension streamConsumer)
         {
-            var grainRef = streamConsumer as GrainReference;
-            if (grainRef != null)
+            if (streamConsumer is GrainReference grainRef)
             {
                 List<StreamSubscription> subscriptions =
                     State.Consumers.Where(c => !c.IsFaulted && c.Consumer.Equals(streamConsumer))
diff --git a/src/Orleans.Streaming/PubSub/PubSubSubscriptionState.cs b/src/Orleans.Streaming/PubSub/PubSubSubscriptionState.cs
index 48c527860..052b45b4c 100644
--- a/src/Orleans.Streaming/PubSub/PubSubSubscriptionState.cs
+++ b/src/Orleans.Streaming/PubSub/PubSubSubscriptionState.cs
@@ -100,8 +100,7 @@ public override int GetHashCode()
 
         public override string ToString()
         {
-            return string.Format("PubSubSubscriptionState:SubscriptionId={0},StreamId={1},Consumer={2}.",
-                SubscriptionId, Stream, Consumer);
+            return $"PubSubSubscriptionState:SubscriptionId={SubscriptionId},StreamId={Stream},Consumer={Consumer}.";
         }
 
         public void Fault()
diff --git a/src/Orleans.Streaming/QueueBalancer/BestFitBalancer.cs b/src/Orleans.Streaming/QueueBalancer/BestFitBalancer.cs
index 835d3449a..35d1c30b5 100644
--- a/src/Orleans.Streaming/QueueBalancer/BestFitBalancer.cs
+++ b/src/Orleans.Streaming/QueueBalancer/BestFitBalancer.cs
@@ -77,7 +77,7 @@ public BestFitBalancer(IEnumerable<TBucket> buckets, IEnumerable<TResource> reso
             {
                 if (!idealDistribution.ContainsKey(bucket))
                 {
-                    throw new ArgumentOutOfRangeException("activeBuckets", String.Format("Active buckets contain a bucket {0} not in the master list.", bucket));
+                    throw new ArgumentOutOfRangeException("activeBuckets", $"Active buckets contain a bucket {bucket} not in the master list.");
                 }
             }
 
diff --git a/src/Orleans.Streaming/SimpleMessageStream/SimpleMessageStreamProducer.cs b/src/Orleans.Streaming/SimpleMessageStream/SimpleMessageStreamProducer.cs
index 3bf61e3f0..06139358b 100644
--- a/src/Orleans.Streaming/SimpleMessageStream/SimpleMessageStreamProducer.cs
+++ b/src/Orleans.Streaming/SimpleMessageStream/SimpleMessageStreamProducer.cs
@@ -77,7 +77,7 @@ private async Task<ISet<PubSubSubscriptionState>> RegisterProducer()
         private async Task ConnectToRendezvous()
         {
             if (isDisposed)
-                throw new ObjectDisposedException(string.Format("{0}-{1}", GetType(), "ConnectToRendezvous"));
+                throw new ObjectDisposedException($"{GetType()}-{"ConnectToRendezvous"}");
 
             // the caller should check _connectedToRendezvous before calling this method.
             using (await initLock.LockAsync())
@@ -97,7 +97,7 @@ public async Task OnNextAsync(T item, StreamSequenceToken token)
                 throw new ArgumentNullException("token", "Passing a non-null token to a non-rewindable IAsyncBatchObserver.");
             
 
-            if (isDisposed) throw new ObjectDisposedException(string.Format("{0}-{1}", GetType(), "OnNextAsync"));
+            if (isDisposed) throw new ObjectDisposedException($"{GetType()}-{"OnNextAsync"}");
 
             if (!connectedToRendezvous)
             {
@@ -123,7 +123,7 @@ public Task OnNextBatchAsync(IEnumerable<T> batch, StreamSequenceToken token)
 
         public async Task OnCompletedAsync()
         {
-            if (isDisposed) throw new ObjectDisposedException(string.Format("{0}-{1}", GetType(), "OnCompletedAsync"));
+            if (isDisposed) throw new ObjectDisposedException($"{GetType()}-{"OnCompletedAsync"}");
 
             if (!connectedToRendezvous)
                 await ConnectToRendezvous();
@@ -133,7 +133,7 @@ public async Task OnCompletedAsync()
 
         public async Task OnErrorAsync(Exception exc)
         {
-            if (isDisposed) throw new ObjectDisposedException(string.Format("{0}-{1}", GetType(), "OnErrorAsync"));
+            if (isDisposed) throw new ObjectDisposedException($"{GetType()}-{"OnErrorAsync"}");
 
             if (!connectedToRendezvous)
                 await ConnectToRendezvous();
diff --git a/src/Orleans.TestingHost/Logging/FileLogger.cs b/src/Orleans.TestingHost/Logging/FileLogger.cs
index e616b3f23..c22ff88b5 100644
--- a/src/Orleans.TestingHost/Logging/FileLogger.cs
+++ b/src/Orleans.TestingHost/Logging/FileLogger.cs
@@ -85,14 +85,7 @@ public FileLoggingOutput(string fileName)
                 message = "!!!!!!!!!! " + message;
 
             var exc = LogFormatter.PrintException(exception);
-            var msg = string.Format("[{0} {1}\t{2}\t{3}\t{4}]\t{5}\t{6}",
-                LogFormatter.PrintDate(timestamp),           //0
-                Thread.CurrentThread.ManagedThreadId,   //1
-                logLevel.ToString(),    //2
-                errorCode.ToString(),                              //3
-                caller,                                 //4
-                message,                                //5
-                exc);      //6
+            var msg = $"[{LogFormatter.PrintDate(timestamp)} {Thread.CurrentThread.ManagedThreadId}\t{logLevel.ToString()}\t{errorCode.ToString()}\t{caller}]\t{message}\t{exc}";      //6
 
             return msg;
         }
@@ -120,8 +113,7 @@ private void Dispose(bool disposing)
             }
             catch (Exception exc)
             {
-                var msg = string.Format("Ignoring error closing log file {0} - {1}", this.logFileName,
-                    LogFormatter.PrintException(exc));
+                var msg = $"Ignoring error closing log file {this.logFileName} - {LogFormatter.PrintException(exc)}";
                 Console.WriteLine(msg);
             }
         }
diff --git a/test/DefaultCluster.Tests/ErrorGrainTest.cs b/test/DefaultCluster.Tests/ErrorGrainTest.cs
index df598d3d0..43e75994a 100644
--- a/test/DefaultCluster.Tests/ErrorGrainTest.cs
+++ b/test/DefaultCluster.Tests/ErrorGrainTest.cs
@@ -222,11 +222,11 @@ private void CreateGR(int n, int type)
             Guid guid;
             if (type == 1)
             {
-                guid = Guid.Parse(string.Format("00000000-0000-0000-0000-{0:X12}", n));
+                guid = Guid.Parse($"00000000-0000-0000-0000-{n:X12}");
             }
             else
             {
-                guid = Guid.Parse(string.Format("{0:X8}-0000-0000-0000-000000000000", n));
+                guid = Guid.Parse($"{n:X8}-0000-0000-0000-000000000000");
             }
             IEchoGrain grain = this.GrainFactory.GetGrain<IEchoGrain>(guid);
             GrainId grainId = ((GrainReference)grain.AsReference<IEchoGrain>()).GrainId;
diff --git a/test/DefaultCluster.Tests/GenericGrainTests.cs b/test/DefaultCluster.Tests/GenericGrainTests.cs
index b14aa1b51..ba82a121d 100644
--- a/test/DefaultCluster.Tests/GenericGrainTests.cs
+++ b/test/DefaultCluster.Tests/GenericGrainTests.cs
@@ -365,7 +365,7 @@ public async Task GrainWithListFields()
 
             Assert.True(
                 (a == r1[0] && b == r1[1]) || (b == r1[0] && a == r1[1]), // Message ordering was not necessarily preserved.
-                string.Format("Result: r[0]={0}, r[1]={1}", r1[0], r1[1]));
+                $"Result: r[0]={r1[0]}, r[1]={r1[1]}");
         }
 
         [Fact, TestCategory("BVT"), TestCategory("Generics")]
@@ -385,7 +385,7 @@ public async Task Generic_GrainWithListFields()
 
             Assert.True(
                 (a == r1[0] && b == r1[1]) || (b == r1[0] && a == r1[1]), // Message ordering was not necessarily preserved.
-                string.Format("Result: r[0]={0}, r[1]={1}", r1[0], r1[1]));
+                $"Result: r[0]={r1[0]}, r[1]={r1[1]}");
         }
 
         [Fact, TestCategory("BVT"), TestCategory("Generics")]
diff --git a/test/DefaultCluster.Tests/ObserverTests.cs b/test/DefaultCluster.Tests/ObserverTests.cs
index 20d167341..ef06a90e9 100644
--- a/test/DefaultCluster.Tests/ObserverTests.cs
+++ b/test/DefaultCluster.Tests/ObserverTests.cs
@@ -140,7 +140,7 @@ public async Task ObserverTest_DoubleSubscriptionSameReference()
 
             await grain.SetA(2); // Use grain
 
-            Assert.False(await result.WaitForFinished(timeout), string.Format("Should timeout waiting {0} for SetA(2)", timeout));
+            Assert.False(await result.WaitForFinished(timeout), $"Should timeout waiting {timeout} for SetA(2)");
 
             await this.GrainFactory.DeleteObjectReference<ISimpleGrainObserver>(reference);
         }
@@ -167,12 +167,12 @@ public async Task ObserverTest_SubscribeUnsubscribe()
             ISimpleGrainObserver reference = await this.GrainFactory.CreateObjectReference<ISimpleGrainObserver>(observer1);
             await grain.Subscribe(reference);
             await grain.SetA(5);
-            Assert.True(await result.WaitForContinue(timeout), string.Format("Should not timeout waiting {0} for SetA", timeout));
+            Assert.True(await result.WaitForContinue(timeout), $"Should not timeout waiting {timeout} for SetA");
 
             await grain.Unsubscribe(reference);
             await grain.SetB(3);
 
-            Assert.False(await result.WaitForFinished(timeout), string.Format("Should timeout waiting {0} for SetB", timeout));
+            Assert.False(await result.WaitForFinished(timeout), $"Should timeout waiting {timeout} for SetB");
 
             await this.GrainFactory.DeleteObjectReference<ISimpleGrainObserver>(reference);
         }
@@ -230,7 +230,7 @@ public async Task ObserverTest_DoubleSubscriptionDifferentReferences()
             await grain.Subscribe(reference2);
             grain.SetA(6).Ignore();
 
-            Assert.True(await result.WaitForFinished(timeout), string.Format("Should not timeout waiting {0} for SetA", timeout));
+            Assert.True(await result.WaitForFinished(timeout), $"Should not timeout waiting {timeout} for SetA");
 
             await this.GrainFactory.DeleteObjectReference<ISimpleGrainObserver>(reference1);
             await this.GrainFactory.DeleteObjectReference<ISimpleGrainObserver>(reference2);
@@ -260,11 +260,11 @@ public async Task ObserverTest_DeleteObject()
             ISimpleGrainObserver reference = await this.GrainFactory.CreateObjectReference<ISimpleGrainObserver>(observer1);
             await grain.Subscribe(reference);
             await grain.SetA(5);
-            Assert.True(await result.WaitForContinue(timeout), string.Format("Should not timeout waiting {0} for SetA", timeout));
+            Assert.True(await result.WaitForContinue(timeout), $"Should not timeout waiting {timeout} for SetA");
             await this.GrainFactory.DeleteObjectReference<ISimpleGrainObserver>(reference);
             await grain.SetB(3);
 
-            Assert.False(await result.WaitForFinished(timeout), string.Format("Should timeout waiting {0} for SetB", timeout));
+            Assert.False(await result.WaitForFinished(timeout), $"Should timeout waiting {timeout} for SetB");
         }
 
         void ObserverTest_DeleteObject_Callback(int a, int b, AsyncResultHandle result)
diff --git a/test/Extensions/AWSUtils.Tests/StorageTests/Base_PersistenceGrainTests_AWSStore.cs b/test/Extensions/AWSUtils.Tests/StorageTests/Base_PersistenceGrainTests_AWSStore.cs
index d0165ad8f..d275069be 100644
--- a/test/Extensions/AWSUtils.Tests/StorageTests/Base_PersistenceGrainTests_AWSStore.cs
+++ b/test/Extensions/AWSUtils.Tests/StorageTests/Base_PersistenceGrainTests_AWSStore.cs
@@ -398,7 +398,7 @@ protected async Task Persistence_Silo_StorageProvider_AWS(Type providerType)
 
             if (elapsed > target.Multiply(timingFactor))
             {
-                string msg = string.Format("{0}: Elapsed time {1} exceeds target time {2}", testName, elapsed, target);
+                string msg = $"{testName}: Elapsed time {elapsed} exceeds target time {target}";
 
                 if (elapsed > target.Multiply(2.0 * timingFactor))
                 {
diff --git a/test/Extensions/AWSUtils.Tests/StorageTests/DynamoDBStorageProviderTests.cs b/test/Extensions/AWSUtils.Tests/StorageTests/DynamoDBStorageProviderTests.cs
index c9b1a85fe..2bc61241e 100644
--- a/test/Extensions/AWSUtils.Tests/StorageTests/DynamoDBStorageProviderTests.cs
+++ b/test/Extensions/AWSUtils.Tests/StorageTests/DynamoDBStorageProviderTests.cs
@@ -48,10 +48,7 @@ public DynamoDBStorageProviderTests(ITestOutputHelper output, TestEnvironmentFix
         [InlineData(15 * 32 * 1024 - 256, true)]
         public async Task PersistenceProvider_DynamoDB_WriteRead(int? stringLength, bool useJson)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4})",
-                nameof(PersistenceProvider_DynamoDB_WriteRead),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                nameof(useJson), useJson);
+            var testName = $"{nameof(PersistenceProvider_DynamoDB_WriteRead)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJson)} = {useJson})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -68,10 +65,7 @@ public async Task PersistenceProvider_DynamoDB_WriteRead(int? stringLength, bool
         [InlineData(15 * 32 * 1024 - 256, true)]
         public async Task PersistenceProvider_DynamoDB_WriteClearRead(int? stringLength, bool useJson)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4})",
-                nameof(PersistenceProvider_DynamoDB_WriteClearRead),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                nameof(useJson), useJson);
+            var testName = $"{nameof(PersistenceProvider_DynamoDB_WriteClearRead)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJson)} = {useJson})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -88,11 +82,7 @@ public async Task PersistenceProvider_DynamoDB_WriteClearRead(int? stringLength,
         [InlineData(15 * 32 * 1024 - 256, false, true)]
         public async Task PersistenceProvider_DynamoDB_ChangeReadFormat(int? stringLength, bool useJsonForWrite, bool useJsonForRead)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4}, {5} = {6})",
-                nameof(PersistenceProvider_DynamoDB_ChangeReadFormat),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                nameof(useJsonForWrite), useJsonForWrite,
-                nameof(useJsonForRead), useJsonForRead);
+            var testName = $"{nameof(PersistenceProvider_DynamoDB_ChangeReadFormat)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJsonForWrite)} = {useJsonForWrite}, {nameof(useJsonForRead)} = {useJsonForRead})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -115,11 +105,7 @@ public async Task PersistenceProvider_DynamoDB_ChangeReadFormat(int? stringLengt
         [InlineData(15 * 32 * 1024 - 256, false, true)]
         public async Task PersistenceProvider_DynamoDB_ChangeWriteFormat(int? stringLength, bool useJsonForFirstWrite, bool useJsonForSecondWrite)
         {
-            var testName = string.Format("{0}({1}={2},{3}={4},{5}={6})",
-                nameof(PersistenceProvider_DynamoDB_ChangeWriteFormat),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                "json1stW", useJsonForFirstWrite,
-                "json2ndW", useJsonForSecondWrite);
+            var testName = $"{nameof(PersistenceProvider_DynamoDB_ChangeWriteFormat)}({nameof(stringLength)}={(stringLength == null ? "default" : stringLength.ToString())},{"json1stW"}={useJsonForFirstWrite},{"json2ndW"}={useJsonForSecondWrite})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -145,10 +131,7 @@ public async Task PersistenceProvider_DynamoDB_ChangeWriteFormat(int? stringLeng
         [InlineData(15 * 32 * 1024 - 256, true)]
         public async Task DynamoDBStorage_ConvertToFromStorageFormat(int? stringLength, bool useJson)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4})",
-               nameof(DynamoDBStorage_ConvertToFromStorageFormat),
-               nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-               nameof(useJson), useJson);
+            var testName = $"{nameof(DynamoDBStorage_ConvertToFromStorageFormat)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJson)} = {useJson})";
 
             var state = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(state);
diff --git a/test/Extensions/Serializers/ProtoBuf.Serialization.Tests/OrleansType.cs b/test/Extensions/Serializers/ProtoBuf.Serialization.Tests/OrleansType.cs
index afd108e7b..76c9c5a4a 100644
--- a/test/Extensions/Serializers/ProtoBuf.Serialization.Tests/OrleansType.cs
+++ b/test/Extensions/Serializers/ProtoBuf.Serialization.Tests/OrleansType.cs
@@ -17,8 +17,7 @@ public class OrleansType
 
         public override bool Equals(object obj)
         {
-            var o = obj as OrleansType;
-            return o != null && val.Equals(o.val);
+            return obj is OrleansType o && val.Equals(o.val);
         }
 
         public override int GetHashCode()
diff --git a/test/Extensions/TesterAdoNet/RelationalUtilities/SqlServerStorageForTesting.cs b/test/Extensions/TesterAdoNet/RelationalUtilities/SqlServerStorageForTesting.cs
index cf397f11d..420e58b7a 100644
--- a/test/Extensions/TesterAdoNet/RelationalUtilities/SqlServerStorageForTesting.cs
+++ b/test/Extensions/TesterAdoNet/RelationalUtilities/SqlServerStorageForTesting.cs
@@ -73,7 +73,7 @@ protected override IEnumerable<string> ConvertToExecutableBatches(string setupSc
             
             //This removes the use of recovery log in case of database crashes, which
             //improves performance to some degree, depending on usage. For non-performance testing only.
-            batches.Add(string.Format("ALTER DATABASE [{0}] SET RECOVERY SIMPLE;", dataBaseName));
+            batches.Add($"ALTER DATABASE [{dataBaseName}] SET RECOVERY SIMPLE;");
             batches.Add(CreateStreamTestTable);
 
             return batches;
diff --git a/test/Extensions/TesterAdoNet/StorageTests/RelationalStoreTests.cs b/test/Extensions/TesterAdoNet/StorageTests/RelationalStoreTests.cs
index 0b4021f02..d7c1f2bff 100644
--- a/test/Extensions/TesterAdoNet/StorageTests/RelationalStoreTests.cs
+++ b/test/Extensions/TesterAdoNet/StorageTests/RelationalStoreTests.cs
@@ -187,7 +187,7 @@ private static Task CancellationTokenTest(RelationalStorageForTesting sut, TimeS
                     var task = sut.Storage.ReadAsync<int>(sut.CancellationTestQuery, tokenSource.Token);
                     if(!task.Wait(timeoutLimit.Add(TimeSpan.FromSeconds(1))))
                     {
-                        Assert.True(false, string.Format("Timeout limit {0} ms exceeded.", timeoutLimit.TotalMilliseconds));
+                        Assert.True(false, $"Timeout limit {timeoutLimit.TotalMilliseconds} ms exceeded.");
                     }
                 }
                 catch(Exception ex)
diff --git a/test/Extensions/TesterAzureUtils/AsyncPipelineTests.cs b/test/Extensions/TesterAzureUtils/AsyncPipelineTests.cs
index fb4600467..1a69e6941 100644
--- a/test/Extensions/TesterAzureUtils/AsyncPipelineTests.cs
+++ b/test/Extensions/TesterAzureUtils/AsyncPipelineTests.cs
@@ -171,10 +171,10 @@ private async Task AsyncPipelineBlackBoxConsistencyTest(int workerCount)
             Assert.True(capacityReached.IsSet, "Pipeline capacity not reached; the delay length probably is too short to be useful.");
             Assert.True(
                 actualSec >= minTimeSec, 
-                string.Format("The unit test completed too early ({0} sec < {1} sec).", actualSec, minTimeSec));
+                $"The unit test completed too early ({actualSec} sec < {minTimeSec} sec).");
             Assert.True(
                 actualSec <= maxTimeSec, 
-                string.Format("The unit test completed too late ({0} sec > {1} sec).", actualSec, maxTimeSec));
+                $"The unit test completed too late ({actualSec} sec > {maxTimeSec} sec).");
         }
 
         private void CheckPipelineState(int size, int capacity, InterlockedFlag capacityReached)
@@ -182,7 +182,7 @@ private void CheckPipelineState(int size, int capacity, InterlockedFlag capacity
             Assert.True(size >= 0);
             Assert.True(capacity > 0);
             // a understood flaw of the current algorithm is that the capacity can be exceeded by one item. we've decided that this is acceptable and we allow it to happen.
-            Assert.True(size <= capacity, string.Format("size ({0}) must be less than the capacity ({1})", size, capacity));
+            Assert.True(size <= capacity, $"size ({size}) must be less than the capacity ({capacity})");
             if (capacityReached != null && size == capacity)
                 capacityReached.TrySet();
         }
diff --git a/test/Extensions/TesterAzureUtils/AzureQueueDataManagerTests.cs b/test/Extensions/TesterAzureUtils/AzureQueueDataManagerTests.cs
index f1d5696b1..74378a48a 100644
--- a/test/Extensions/TesterAzureUtils/AzureQueueDataManagerTests.cs
+++ b/test/Extensions/TesterAzureUtils/AzureQueueDataManagerTests.cs
@@ -84,7 +84,7 @@ public async Task AQ_Standalone_2()
             AzureQueueDataManager manager = await GetTableManager(queueName);
 
             IEnumerable<QueueMessage> msgs = await manager.GetQueueMessages();
-            Assert.True(msgs == null || msgs.Count() == 0);
+            Assert.True(msgs == null || !msgs.Any());
 
             int numMsgs = 10;
             List<Task> promises = new List<Task>();
@@ -157,20 +157,12 @@ public async Task AQ_Standalone_4()
 
         private static string PrintQueueMessage(QueueMessage message)
         {
-            return String.Format("QueueMessage: Id = {0}, NextVisibleTime = {1}, DequeueCount = {2}, PopReceipt = {3}, Content = {4}",
-                    message.MessageId,
-                    message.NextVisibleOn.HasValue ? LogFormatter.PrintDate(message.NextVisibleOn.Value.DateTime) : "",
-                    message.DequeueCount,
-                    message.PopReceipt,
-                    message.MessageText);
+            return $"QueueMessage: Id = {message.MessageId}, NextVisibleTime = {(message.NextVisibleOn.HasValue ? LogFormatter.PrintDate(message.NextVisibleOn.Value.DateTime) : "")}, DequeueCount = {message.DequeueCount}, PopReceipt = {message.PopReceipt}, Content = {message.MessageText}";
         }
 
         private static string PrintQueueMessage(PeekedMessage message)
         {
-            return String.Format("QueueMessage: Id = {0}, DequeueCount = {1}, Content = {2}",
-                    message.MessageId,
-                    message.DequeueCount,
-                    message.MessageText);
+            return $"QueueMessage: Id = {message.MessageId}, DequeueCount = {message.DequeueCount}, Content = {message.MessageText}";
         }
     }
 }
diff --git a/test/Extensions/TesterAzureUtils/Persistence/PersistenceGrainTests_AzureStore.cs b/test/Extensions/TesterAzureUtils/Persistence/PersistenceGrainTests_AzureStore.cs
index d8897c160..46a473792 100644
--- a/test/Extensions/TesterAzureUtils/Persistence/PersistenceGrainTests_AzureStore.cs
+++ b/test/Extensions/TesterAzureUtils/Persistence/PersistenceGrainTests_AzureStore.cs
@@ -215,7 +215,7 @@ protected async Task Persistence_Silo_StorageProvider_Azure(string providerName)
 
             if (elapsed > target.Multiply(timingFactor))
             {
-                string msg = string.Format("{0}: Elapsed time {1} exceeds target time {2}", testName, elapsed, target);
+                string msg = $"{testName}: Elapsed time {elapsed} exceeds target time {target}";
 
                 if (elapsed > target.Multiply(2.0 * timingFactor))
                 {
diff --git a/test/Extensions/TesterAzureUtils/Persistence/PersistenceProviderTests.cs b/test/Extensions/TesterAzureUtils/Persistence/PersistenceProviderTests.cs
index f8fd7743e..227398dc1 100644
--- a/test/Extensions/TesterAzureUtils/Persistence/PersistenceProviderTests.cs
+++ b/test/Extensions/TesterAzureUtils/Persistence/PersistenceProviderTests.cs
@@ -80,10 +80,7 @@ public async Task PersistenceProvider_Azure_Read()
         [InlineData(15 * 32 * 1024 - 256, true)]
         public async Task PersistenceProvider_Azure_WriteRead(int? stringLength, bool useJson)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4})",
-                nameof(PersistenceProvider_Azure_WriteRead),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                nameof(useJson), useJson);
+            var testName = $"{nameof(PersistenceProvider_Azure_WriteRead)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJson)} = {useJson})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -100,10 +97,7 @@ public async Task PersistenceProvider_Azure_WriteRead(int? stringLength, bool us
         [InlineData(15 * 32 * 1024 - 256, true)]
         public async Task PersistenceProvider_Azure_WriteClearRead(int? stringLength, bool useJson)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4})",
-                nameof(PersistenceProvider_Azure_WriteClearRead),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                nameof(useJson), useJson);
+            var testName = $"{nameof(PersistenceProvider_Azure_WriteClearRead)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJson)} = {useJson})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -120,11 +114,7 @@ public async Task PersistenceProvider_Azure_WriteClearRead(int? stringLength, bo
         [InlineData(15 * 32 * 1024 - 256, false, true)]
         public async Task PersistenceProvider_Azure_ChangeReadFormat(int? stringLength, bool useJsonForWrite, bool useJsonForRead)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4}, {5} = {6})",
-                nameof(PersistenceProvider_Azure_ChangeReadFormat),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                nameof(useJsonForWrite), useJsonForWrite,
-                nameof(useJsonForRead), useJsonForRead);
+            var testName = $"{nameof(PersistenceProvider_Azure_ChangeReadFormat)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJsonForWrite)} = {useJsonForWrite}, {nameof(useJsonForRead)} = {useJsonForRead})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -147,11 +137,7 @@ public async Task PersistenceProvider_Azure_ChangeReadFormat(int? stringLength,
         [InlineData(15 * 32 * 1024 - 256, false, true)]
         public async Task PersistenceProvider_Azure_ChangeWriteFormat(int? stringLength, bool useJsonForFirstWrite, bool useJsonForSecondWrite)
         {
-            var testName = string.Format("{0}({1}={2},{3}={4},{5}={6})",
-                nameof(PersistenceProvider_Azure_ChangeWriteFormat),
-                nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-                "json1stW", useJsonForFirstWrite,
-                "json2ndW", useJsonForSecondWrite);
+            var testName = $"{nameof(PersistenceProvider_Azure_ChangeWriteFormat)}({nameof(stringLength)}={(stringLength == null ? "default" : stringLength.ToString())},{"json1stW"}={useJsonForFirstWrite},{"json2ndW"}={useJsonForSecondWrite})";
 
             var grainState = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(grainState);
@@ -177,10 +163,7 @@ public async Task PersistenceProvider_Azure_ChangeWriteFormat(int? stringLength,
         [InlineData(15 * 32 * 1024 - 256, true)]
         public async Task AzureTableStorage_ConvertToFromStorageFormat(int? stringLength, bool useJson)
         {
-            var testName = string.Format("{0}({1} = {2}, {3} = {4})",
-               nameof(AzureTableStorage_ConvertToFromStorageFormat),
-               nameof(stringLength), stringLength == null ? "default" : stringLength.ToString(),
-               nameof(useJson), useJson);
+            var testName = $"{nameof(AzureTableStorage_ConvertToFromStorageFormat)}({nameof(stringLength)} = {(stringLength == null ? "default" : stringLength.ToString())}, {nameof(useJson)} = {useJson})";
 
             var state = TestStoreGrainState.NewRandomState(stringLength);
             EnsureEnvironmentSupportsState(state);
diff --git a/test/Extensions/TesterAzureUtils/Reminder/ReminderTests_Azure_Standalone.cs b/test/Extensions/TesterAzureUtils/Reminder/ReminderTests_Azure_Standalone.cs
index e79647b6c..4325aea58 100644
--- a/test/Extensions/TesterAzureUtils/Reminder/ReminderTests_Azure_Standalone.cs
+++ b/test/Extensions/TesterAzureUtils/Reminder/ReminderTests_Azure_Standalone.cs
@@ -94,7 +94,7 @@ private async Task TestTableInsertRate(IReminderTable reminderTable, double numO
                 for (int i = 0; i < numOfInserts; i++)
                 {
                     //"177BF46E-D06D-44C0-943B-C12F26DF5373"
-                    string s = string.Format("177BF46E-D06D-44C0-943B-C12F26D{0:d5}", i);
+                    string s = $"177BF46E-D06D-44C0-943B-C12F26D{i:d5}";
 
                     var e = new ReminderEntry
                     {
@@ -132,7 +132,7 @@ private ReminderEntry NewReminderEntry()
             return new ReminderEntry
             {
                 GrainRef = (GrainReference)this.fixture.InternalGrainFactory.GetGrain(LegacyGrainId.NewId()),
-                ReminderName = string.Format("TestReminder.{0}", guid),
+                ReminderName = $"TestReminder.{guid}",
                 Period = TimeSpan.FromSeconds(5),
                 StartAt = DateTime.UtcNow
             };
@@ -140,7 +140,7 @@ private ReminderEntry NewReminderEntry()
 
         private string NewClusterId()
         {
-            return string.Format("ReminderTest.{0}", Guid.NewGuid());
+            return $"ReminderTest.{Guid.NewGuid()}";
         }
 
         private async Task<IEnumerable<ReminderEntry>> GetAllRows(IReminderTable table)
diff --git a/test/Extensions/TesterAzureUtils/Streaming/StreamLifecycleTests.cs b/test/Extensions/TesterAzureUtils/Streaming/StreamLifecycleTests.cs
index 90dab76e3..88736919e 100644
--- a/test/Extensions/TesterAzureUtils/Streaming/StreamLifecycleTests.cs
+++ b/test/Extensions/TesterAzureUtils/Streaming/StreamLifecycleTests.cs
@@ -221,7 +221,7 @@ private async Task IncrementalAddProducers(IStreamLifecycleProducerGrain[] produ
                 await StreamTestUtils.CheckPubSubCounts(
                     this.InternalClient,
                     output,
-                    string.Format("producer #{0} create - {1}", i, when),
+                    $"producer #{i} create - {when}",
                     i, 1,
                     StreamId, StreamProviderName, StreamNamespace);
             }
diff --git a/test/Grains/TestGrains/AdoNet/CustomerGrain.cs b/test/Grains/TestGrains/AdoNet/CustomerGrain.cs
index ba3902a1e..1e6ffacb9 100644
--- a/test/Grains/TestGrains/AdoNet/CustomerGrain.cs
+++ b/test/Grains/TestGrains/AdoNet/CustomerGrain.cs
@@ -18,7 +18,7 @@ public override async Task OnActivateAsync()
 
         public Task<string> IntroduceSelf()
         {
-            return Task.FromResult(string.Format("Hello, my name is {0} {1}", State.FirstName, State.LastName));
+            return Task.FromResult($"Hello, my name is {State.FirstName} {State.LastName}");
         }
 
         public async Task Set(int customerId, string firstName, string lastName)
diff --git a/test/Grains/TestGrains/ChainedGrain.cs b/test/Grains/TestGrains/ChainedGrain.cs
index 6b2790704..219d8264a 100644
--- a/test/Grains/TestGrains/ChainedGrain.cs
+++ b/test/Grains/TestGrains/ChainedGrain.cs
@@ -73,7 +73,7 @@ public Task Validate(bool nextIsSet)
                 return Task.CompletedTask;
             }
 
-            string msg = String.Format("ChainGrain Id={0} is in an invalid state. Next={1}", State.Id, State.Next);
+            string msg = $"ChainGrain Id={State.Id} is in an invalid state. Next={State.Next}";
             logger.Warn(0, msg);
             throw new OrleansException(msg);
         }
diff --git a/test/Grains/TestGrains/DeadlockGrain.cs b/test/Grains/TestGrains/DeadlockGrain.cs
index b2bd7285d..b45508dbf 100644
--- a/test/Grains/TestGrains/DeadlockGrain.cs
+++ b/test/Grains/TestGrains/DeadlockGrain.cs
@@ -39,7 +39,7 @@ public class DeadlockNonReentrantGrain : Grain, IDeadlockNonReentrantGrain
     {
         private readonly ILogger logger;
         public DeadlockNonReentrantGrain(ILoggerFactory loggerFactory) => this.logger = loggerFactory.CreateLogger(this.Id);
-        private string Id { get { return String.Format("DeadlockNonReentrantGrain {0}", base.IdentityString); } }
+        private string Id { get { return $"DeadlockNonReentrantGrain {base.IdentityString}"; } }
 
         public Task CallNext_1(List<Tuple<long, bool>> callChain, int currCallIndex)
         {
@@ -59,7 +59,7 @@ public class DeadlockReentrantGrain : Grain, IDeadlockReentrantGrain
     {
         private readonly ILogger logger;
         public DeadlockReentrantGrain(ILoggerFactory loggerFactory) => this.logger = loggerFactory.CreateLogger(this.Id);
-        private string Id { get { return String.Format("DeadlockReentrantGrain {0}", base.IdentityString); } }
+        private string Id { get { return $"DeadlockReentrantGrain {base.IdentityString}"; } }
 
         public Task CallNext_1(List<Tuple<long, bool>> callChain, int currCallIndex)
         {
diff --git a/test/Grains/TestGrains/EventSourcing/ChatFormat.cs b/test/Grains/TestGrains/EventSourcing/ChatFormat.cs
index 97d2eee1f..830613486 100644
--- a/test/Grains/TestGrains/EventSourcing/ChatFormat.cs
+++ b/test/Grains/TestGrains/EventSourcing/ChatFormat.cs
@@ -18,7 +18,7 @@ public static class ChatFormat
     {
         public static void Initialize(this XDocument document, DateTime timestamp, string origin)
         {
-            if (document.Nodes().Count() == 0)
+            if (!document.Nodes().Any())
             {
                 document.Add(new XComment($"This chat room was created by {origin}"));
                 document.Add(new XElement("root",
@@ -45,8 +45,8 @@ public static XElement FindPost(this XDocument document, string guid)
         {
             return document.GetPostsContainer()
                        .Elements("post")
-                       .Where(x => x.Attribute("id").Value == guid)
-                       .FirstOrDefault();
+                       .FirstOrDefault(x => x.Attribute("id").Value == guid)
+;
         }
 
         public static void ReplaceText(this XElement post, string text)
diff --git a/test/Grains/TestGrains/EventSourcing/PersonGrain.cs b/test/Grains/TestGrains/EventSourcing/PersonGrain.cs
index ef0f577f7..c2464a958 100644
--- a/test/Grains/TestGrains/EventSourcing/PersonGrain.cs
+++ b/test/Grains/TestGrains/EventSourcing/PersonGrain.cs
@@ -28,7 +28,7 @@ public Task RegisterBirth(PersonAttributes props)
         public async Task Marry(IPersonGrain spouse)
         {
             if (State.IsMarried)
-                throw new NotSupportedException(string.Format("{0} is already married.", State.LastName));
+                throw new NotSupportedException($"{State.LastName} is already married.");
 
             var spouseData = await spouse.GetTentativePersonalAttributes();
 
diff --git a/test/Grains/TestGrains/GenericGrains.cs b/test/Grains/TestGrains/GenericGrains.cs
index e0998dd39..3d38cd0fe 100644
--- a/test/Grains/TestGrains/GenericGrains.cs
+++ b/test/Grains/TestGrains/GenericGrains.cs
@@ -42,13 +42,13 @@ public Task SetB(T b)
 
         public Task<string> GetAxB()
         {
-            string retValue = string.Format("{0}x{1}", State.A, State.B);
+            string retValue = $"{State.A}x{State.B}";
             return Task.FromResult(retValue);
         }
 
         public Task<string> GetAxB(T a, T b)
         {
-            string retValue = string.Format("{0}x{1}", a, b);
+            string retValue = $"{a}x{b}";
             return Task.FromResult(retValue);
         }
     }
@@ -114,13 +114,13 @@ public Task SetB(U b)
 
         public Task<string> GetAxB()
         {
-            string retValue = string.Format("{0}x{1}", State.A, State.B);
+            string retValue = $"{State.A}x{State.B}";
             return Task.FromResult(retValue);
         }
 
         public Task<string> GetAxB(U a, U b)
         {
-            string retValue = string.Format("{0}x{1}", a, b);
+            string retValue = $"{a}x{b}";
             return Task.FromResult(retValue);
         }
     }
@@ -169,7 +169,7 @@ public class GenericGrainWithNoProperties<T> : Grain, IGenericGrainWithNoPropert
     {
         public Task<string> GetAxB(T a, T b)
         {
-            string retValue = string.Format("{0}x{1}", a, b);
+            string retValue = $"{a}x{b}";
             return Task.FromResult(retValue);
         }
     }
@@ -177,7 +177,7 @@ public class GrainWithNoProperties : Grain, IGrainWithNoProperties
     {
         public Task<string> GetAxB(int a, int b)
         {
-            string retValue = string.Format("{0}x{1}", a, b);
+            string retValue = $"{a}x{b}";
             return Task.FromResult(retValue);
         }
     }
diff --git a/test/Grains/TestGrains/LogTestGrain.cs b/test/Grains/TestGrains/LogTestGrain.cs
index 3952e454d..142edf866 100644
--- a/test/Grains/TestGrains/LogTestGrain.cs
+++ b/test/Grains/TestGrains/LogTestGrain.cs
@@ -27,7 +27,7 @@ public MyGrainState()
 
         public override string ToString()
         {
-            return string.Format("A={0} B={1} R={{{2}}}", A, B, string.Join(", ", Reservations.Select(kvp => string.Format("{0}:{1}", kvp.Key, kvp.Value))));
+            return string.Format("A={0} B={1} R={{{2}}}", A, B, string.Join(", ", Reservations.Select(kvp => $"{kvp.Key}:{kvp.Value}")));
         }
 
         // all the update operations are listed here
diff --git a/test/Grains/TestGrains/MethodInterceptionGrain.cs b/test/Grains/TestGrains/MethodInterceptionGrain.cs
index ede1888bb..e898580b3 100644
--- a/test/Grains/TestGrains/MethodInterceptionGrain.cs
+++ b/test/Grains/TestGrains/MethodInterceptionGrain.cs
@@ -93,8 +93,8 @@ async Task IIncomingGrainCallFilter.Invoke(IIncomingGrainCallContext context)
             // we check for this attribute which is only present on the implementation. This could be
             // done in a simpler fashion, but this demonstrates a potential usage scenario.
             var shouldMessWithResult = methodInfo.GetCustomAttribute<MessWithResultAttribute>();
-            var resultString = context.Result as string;
-            if (shouldMessWithResult != null && resultString != null)
+
+            if (shouldMessWithResult != null && context.Result is string resultString)
             {
                 context.Result = string.Concat(resultString.Reverse());
             }
diff --git a/test/Grains/TestGrains/MultipleSubscriptionConsumerGrain.cs b/test/Grains/TestGrains/MultipleSubscriptionConsumerGrain.cs
index f37d82bc2..a690da168 100644
--- a/test/Grains/TestGrains/MultipleSubscriptionConsumerGrain.cs
+++ b/test/Grains/TestGrains/MultipleSubscriptionConsumerGrain.cs
@@ -121,8 +121,7 @@ public Task<IList<StreamSubscriptionHandle<int>>> GetAllSubscriptions(Guid strea
 
         public Task<Dictionary<StreamSubscriptionHandle<int>, Tuple<int,int>>> GetNumberConsumed()
         {
-            logger.Info(String.Format("ConsumedMessageCounts = \n{0}", 
-                Utils.EnumerableToString(consumedMessageCounts, kvp => String.Format("Consumer: {0} -> count: {1}", kvp.Key.HandleId.ToString(), kvp.Value.ToString()))));
+            logger.Info($"ConsumedMessageCounts = \n{Utils.EnumerableToString(consumedMessageCounts, kvp => String.Format("Consumer: {0} -> count: {1}", kvp.Key.HandleId.ToString(), kvp.Value.ToString()))}");
 
             return Task.FromResult(consumedMessageCounts.ToDictionary(kvp => kvp.Key, kvp => Tuple.Create(kvp.Value.Item1.Value, kvp.Value.Item2.Value)));
         }
@@ -158,7 +157,7 @@ private Task OnNext(IList<SequentialItem<int>> items, int countCapture, Counter
                 var contextValue = RequestContext.Get(SampleStreaming_ProducerGrain.RequestContextKey) as string;
                 if (!String.Equals(contextValue, SampleStreaming_ProducerGrain.RequestContextValue))
                 {
-                    throw new Exception(String.Format("Got the wrong RequestContext value {0}.", contextValue));
+                    throw new Exception($"Got the wrong RequestContext value {contextValue}.");
                 }
                 count.Increment();
             }
diff --git a/test/Grains/TestGrains/SimpleGenericGrain.cs b/test/Grains/TestGrains/SimpleGenericGrain.cs
index fec9a4f30..0dfac33d4 100644
--- a/test/Grains/TestGrains/SimpleGenericGrain.cs
+++ b/test/Grains/TestGrains/SimpleGenericGrain.cs
@@ -30,7 +30,7 @@ public Task CompareGrainReferences(ISimpleGenericGrain<TType> clientReference)
             // Compare reference to this grain created by the client 
             var thisReference = GrainFactory.GetGrain<ISimpleGenericGrain<TType>>(this.GetPrimaryKeyLong());
             if (!thisReference.Equals(clientReference))
-                throw new Exception(String.Format("Case_3: 2 grain references are different, while should have been the same: gr1={0}, gr2={1}", thisReference, clientReference));
+                throw new Exception($"Case_3: 2 grain references are different, while should have been the same: gr1={thisReference}, gr2={clientReference}");
 
             return Task.CompletedTask;
         }
diff --git a/test/Grains/TestGrains/SimpleObserverableGrain.cs b/test/Grains/TestGrains/SimpleObserverableGrain.cs
index b6625cb8e..fc4f4877a 100644
--- a/test/Grains/TestGrains/SimpleObserverableGrain.cs
+++ b/test/Grains/TestGrains/SimpleObserverableGrain.cs
@@ -19,7 +19,7 @@ public class SimpleObserverableGrain : Grain, ISimpleObserverableGrain
         public SimpleObserverableGrain(ILoggerFactory loggerFactory)
         {
             EventDelay = 1000;
-            logger = loggerFactory.CreateLogger(string.Format("{0}-{1}-{2}", typeof(SimpleObserverableGrain).Name, base.IdentityString, base.RuntimeIdentity));
+            logger = loggerFactory.CreateLogger($"{typeof(SimpleObserverableGrain).Name}-{base.IdentityString}-{base.RuntimeIdentity}");
             this.Observers = new ObserverManager<ISimpleGrainObserver>(TimeSpan.FromMinutes(5), logger, "observers");
         }
 
diff --git a/test/Grains/TestInternalGrains/CollectionTestGrain.cs b/test/Grains/TestInternalGrains/CollectionTestGrain.cs
index 8546aae4f..5896be7e6 100644
--- a/test/Grains/TestInternalGrains/CollectionTestGrain.cs
+++ b/test/Grains/TestInternalGrains/CollectionTestGrain.cs
@@ -26,7 +26,7 @@ protected virtual ILogger Logger()
         public override Task OnActivateAsync()
         {
             logger = this.ServiceProvider.GetRequiredService<ILoggerFactory>()
-                .CreateLogger(string.Format("CollectionTestGrain {0} {1} on {2}.", GrainId, Data.ActivationId, RuntimeIdentity));
+                .CreateLogger($"CollectionTestGrain {GrainId} {Data.ActivationId} on {RuntimeIdentity}.");
             logger.Info("OnActivateAsync.");
             activated = DateTime.UtcNow;
             counter = 0;
@@ -120,7 +120,7 @@ protected override ILogger Logger()
         public override Task OnActivateAsync()
         {
             logger = this.ServiceProvider.GetRequiredService<ILoggerFactory>()
-                .CreateLogger(string.Format("CollectionTestGrain {0} {1} on {2}.", GrainId, Data.ActivationId, RuntimeIdentity));
+                .CreateLogger($"CollectionTestGrain {GrainId} {Data.ActivationId} on {RuntimeIdentity}.");
             logger.Info("OnActivateAsync.");
             counter = 0;
             return Task.CompletedTask;
diff --git a/test/Grains/TestInternalGrains/PersistenceTestGrains.cs b/test/Grains/TestInternalGrains/PersistenceTestGrains.cs
index 88130c30a..5da946ffc 100644
--- a/test/Grains/TestInternalGrains/PersistenceTestGrains.cs
+++ b/test/Grains/TestInternalGrains/PersistenceTestGrains.cs
@@ -603,7 +603,7 @@ public Task SetName(string name)
 
         public Task<string> GetStatus()
         {
-            return Task.FromResult(String.Format("{0} : {1}", State.Name, State.Status));
+            return Task.FromResult($"{State.Name} : {State.Status}");
         }
 
         public Task<string> GetName()
@@ -901,25 +901,25 @@ public override Task OnActivateAsync()
 
         private async Task SetOne(int iter, int level)
         {
-            Log(String.Format("---> SetOne {0}-{1}_0", iter, level));
+            Log($"---> SetOne {iter}-{level}_0");
             CheckRuntimeEnvironment("SetOne");
             if (level > 0)
             {
                 Log("SetOne {0}-{1}_1. Before await Task.Done.", iter, level);
                 await Task.CompletedTask;
                 Log("SetOne {0}-{1}_2. After await Task.Done.", iter, level);
-                CheckRuntimeEnvironment(String.Format("SetOne {0}-{1}_3", iter, level));
+                CheckRuntimeEnvironment($"SetOne {iter}-{level}_3");
                 Log("SetOne {0}-{1}_4. Before await Task.Delay.", iter, level);
                 await Task.Delay(TimeSpan.FromMilliseconds(10));
                 Log("SetOne {0}-{1}_5. After await Task.Delay.", iter, level);
-                CheckRuntimeEnvironment(String.Format("SetOne {0}-{1}_6", iter, level));
+                CheckRuntimeEnvironment($"SetOne {iter}-{level}_6");
                 var nextLevel = level - 1;
                 await SetOne(iter, nextLevel);
                 Log("SetOne {0}-{1}_7 => {2}. After await SetOne call.", iter, level, nextLevel);
-                CheckRuntimeEnvironment(String.Format("SetOne {0}-{1}_8", iter, level));
+                CheckRuntimeEnvironment($"SetOne {iter}-{level}_8");
                 Log("SetOne {0}-{1}_9. Finished SetOne.", iter, level);
             }
-            CheckRuntimeEnvironment(String.Format("SetOne {0}-{1}_10", iter, level));
+            CheckRuntimeEnvironment($"SetOne {iter}-{level}_10");
             Log("<--- SetOne {0}-{1}_11", iter, level);
         }
 
@@ -932,12 +932,12 @@ public async Task Test1()
             for (var i = 0; i < Multiple; i++)
             {
                 Log("Test1_ ------>" + i);
-                CheckRuntimeEnvironment(String.Format("Test1_{0}_0", i));
+                CheckRuntimeEnvironment($"Test1_{i}_0");
                 var task = SetOne(i, LEVEL);
                 Log("After SetOne call " + i);
-                CheckRuntimeEnvironment(String.Format("Test1_{0}_1", i));
+                CheckRuntimeEnvironment($"Test1_{i}_1");
                 tasks.Add(task);
-                CheckRuntimeEnvironment(String.Format("Test1_{0}_2", i));
+                CheckRuntimeEnvironment($"Test1_{i}_2");
                 Log("Test1_ <------" + i);
             }
             CheckRuntimeEnvironment("Test1.AfterLoop");
diff --git a/test/Grains/TestInternalGrains/ReminderTestGrain2.cs b/test/Grains/TestInternalGrains/ReminderTestGrain2.cs
index e80b83ed7..7e93d2584 100644
--- a/test/Grains/TestInternalGrains/ReminderTestGrain2.cs
+++ b/test/Grains/TestInternalGrains/ReminderTestGrain2.cs
@@ -152,8 +152,7 @@ public async Task StopReminder(string reminderName)
                 else
                 {
                     //var reminders = await this.GetRemindersList();
-                    throw new OrleansException(string.Format(
-                        "Could not find reminder {0} in grain {1}", reminderName, this.IdentityString));
+                    throw new OrleansException($"Could not find reminder {reminderName} in grain {this.IdentityString}");
                 }
             }
         }
@@ -203,7 +202,7 @@ public async Task<List<IGrainReminder>> GetRemindersList()
 
         private string GetFileName(string reminderName)
         {
-            return string.Format("{0}{1}", this.filePrefix, reminderName);
+            return $"{this.filePrefix}{reminderName}";
         }
 
         public static TimeSpan GetDefaultPeriod(ILogger log)
@@ -389,7 +388,7 @@ public async Task<List<IGrainReminder>> GetRemindersList()
 
         private string GetFileName(string reminderName)
         {
-            return string.Format("{0}{1}", this.filePrefix, reminderName);
+            return $"{this.filePrefix}{reminderName}";
         }
     }
 
diff --git a/test/Grains/TestInternalGrains/StreamLifecycleTestGrains.cs b/test/Grains/TestInternalGrains/StreamLifecycleTestGrains.cs
index 8af8a8e60..f14bdcbde 100644
--- a/test/Grains/TestInternalGrains/StreamLifecycleTestGrains.cs
+++ b/test/Grains/TestInternalGrains/StreamLifecycleTestGrains.cs
@@ -411,10 +411,7 @@ public Task OnNextAsync(T item, StreamSequenceToken token)
 
         public Task OnCompletedAsync()
         {
-            if (logger != null)
-            {
-                logger.Info("Receive OnCompletedAsync - Total Items={0} Errors={1}", NumItems, NumErrors);
-            }
+            logger?.Info("Receive OnCompletedAsync - Total Items={0} Errors={1}", NumItems, NumErrors);
             return Task.CompletedTask;
         }
 
@@ -422,10 +419,7 @@ public Task OnErrorAsync(Exception ex)
         {
             NumErrors++;
 
-            if (logger != null)
-            {
-                logger.Warn(1, "Received OnErrorAsync - Exception={0} - Total Items={1} Errors={2}", ex, NumItems, NumErrors);
-            }
+            logger?.Warn(1, "Received OnErrorAsync - Exception={0} - Total Items={1} Errors={2}", ex, NumItems, NumErrors);
 
             return Task.CompletedTask;
         }
diff --git a/test/Grains/TestInternalGrains/StreamReliabilityTestGrains.cs b/test/Grains/TestInternalGrains/StreamReliabilityTestGrains.cs
index 157763187..da331b3da 100644
--- a/test/Grains/TestInternalGrains/StreamReliabilityTestGrains.cs
+++ b/test/Grains/TestInternalGrains/StreamReliabilityTestGrains.cs
@@ -75,8 +75,7 @@ public StreamReliabilityTestGrain(ILoggerFactory loggerFactory)
 
         public override async Task OnActivateAsync()
         {
-            logger.Info(String.Format("OnActivateAsync IsProducer = {0}, IsConsumer = {1}.",
-                State.IsProducer, State.ConsumerSubscriptionHandles != null && State.ConsumerSubscriptionHandles.Count > 0));
+            logger.Info($"OnActivateAsync IsProducer = {State.IsProducer}, IsConsumer = {State.ConsumerSubscriptionHandles != null && State.ConsumerSubscriptionHandles.Count > 0}.");
 
             if (Observers == null)
 #if USE_GENERICS
@@ -357,8 +356,7 @@ public StreamUnsubscribeTestGrain(ILoggerFactory loggerFactory)
 
         public override Task OnActivateAsync()
         {
-            logger.Info(String.Format("OnActivateAsync IsProducer = {0}, IsConsumer = {1}.",
-                State.IsProducer, State.ConsumerSubscriptionHandles != null && State.ConsumerSubscriptionHandles.Count > 0));
+            logger.Info($"OnActivateAsync IsProducer = {State.IsProducer}, IsConsumer = {State.ConsumerSubscriptionHandles != null && State.ConsumerSubscriptionHandles.Count > 0}.");
             return Task.CompletedTask;
         }
 
diff --git a/test/Grains/TestInternalGrains/StreamingGrain.cs b/test/Grains/TestInternalGrains/StreamingGrain.cs
index 0c6c5538a..48a44be52 100644
--- a/test/Grains/TestInternalGrains/StreamingGrain.cs
+++ b/test/Grains/TestInternalGrains/StreamingGrain.cs
@@ -29,7 +29,7 @@ public StreamItem(string data, Guid streamId)
 
         public override string ToString()
         {
-            return String.Format("{0}", Data);
+            return $"{Data}";
         }
     }
 
@@ -74,8 +74,7 @@ public Task OnNextAsync(StreamItem item, StreamSequenceToken token = null)
             }
             ++_itemsConsumed;
 
-            string str = String.Format("ConsumerObserver.OnNextAsync: streamId={0}, item={1}, numConsumed={2}{3}", 
-                _streamId, item.Data, _itemsConsumed, token != null ? ", token = " + token : "");
+            string str = $"ConsumerObserver.OnNextAsync: streamId={_streamId}, item={item.Data}, numConsumed={_itemsConsumed}{(token != null ? ", token = " + token : "")}";
             if (ProducerObserver.DEBUG_STREAMING_GRAINS)
             {
                 _logger.Info(str);
@@ -242,7 +241,7 @@ private async Task<bool> ProduceItem(string data)
             StreamItem item = new StreamItem(data, _streamId);
             await _observer.OnNextAsync(item);
             _itemsProduced++;
-            string str = String.Format("ProducerObserver.ProduceItem: streamId={0}, data={1}, numProduced so far={2}.", _streamId, data, _itemsProduced);
+            string str = $"ProducerObserver.ProduceItem: streamId={_streamId}, data={data}, numProduced so far={_itemsProduced}.";
             if (DEBUG_STREAMING_GRAINS)
             {
                 _logger.Info(str);
@@ -263,7 +262,7 @@ public async Task ProduceSequentialSeries(int count)
             _expectedItemsProduced += count;
             _logger.Info("ProducerObserver.ProduceSequentialSeries: streamId={0}, num items to produce={1}.", _streamId, count);
             for (var i = 1; i <= count; ++i)
-                await ProduceItem(String.Format("sequential#{0}", i));
+                await ProduceItem($"sequential#{i}");
         }
 
         public Task ProduceParallelSeries(int count)
@@ -280,7 +279,7 @@ public Task ProduceParallelSeries(int count)
                 int capture = i;
                 Func<Task<bool>> func = async () => 
                     { 
-                        return await ProduceItem(String.Format("parallel#{0}", capture)); 
+                        return await ProduceItem($"parallel#{capture}"); 
                     };
                 // Need to call on different threads to force parallel execution.
                 tasks[capture - 1] = Task.Factory.StartNew(func).Unwrap();
@@ -443,7 +442,7 @@ private async Task OnTickAsync(object unused)
                 if (_started && !_disposedFlag.IsSet)
                 {
                     --_counter;
-                    bool shouldContinue = await _produceItemFunc(String.Format("periodic#{0}", _counter));
+                    bool shouldContinue = await _produceItemFunc($"periodic#{_counter}");
                     if (!shouldContinue || 0 == _counter)
                         Dispose();
                 }
@@ -907,7 +906,7 @@ public async Task BecomeConsumer(Guid streamGuid, string providerToUse, string s
         {
             if (_observers.ContainsKey(providerToUse))
             {
-                throw new InvalidOperationException(string.Format("consumer already established for provider {0}.", providerToUse));
+                throw new InvalidOperationException($"consumer already established for provider {providerToUse}.");
             }
 
             if (string.IsNullOrWhiteSpace(streamNamespace))
diff --git a/test/Grains/TestInternalGrains/TimerGrain.cs b/test/Grains/TestInternalGrains/TimerGrain.cs
index 1bb3d4d25..16d6aee5a 100644
--- a/test/Grains/TestInternalGrains/TimerGrain.cs
+++ b/test/Grains/TestInternalGrains/TimerGrain.cs
@@ -168,7 +168,7 @@ public Task StopTimer(string name)
             logger.Info("StopTimer Name={0}", name);
             if (name != this.timerName)
             {
-                throw new ArgumentException(string.Format("Wrong timer name: Expected={0} Actual={1}", this.timerName, name));
+                throw new ArgumentException($"Wrong timer name: Expected={this.timerName} Actual={name}");
             }
             timer.Dispose();
             return Task.CompletedTask;
@@ -197,7 +197,7 @@ private async Task ProcessTimerTick(object data)
             string name = (string)data;
             if (name != this.timerName)
             {
-                throw new ArgumentException(string.Format("Wrong timer name: Expected={0} Actual={1}", this.timerName, name));
+                throw new ArgumentException($"Wrong timer name: Expected={this.timerName} Actual={name}");
             }
 
             ISimpleGrain grain = GrainFactory.GetGrain<ISimpleGrain>(0, SimpleGrain.SimpleGrainNamePrefix);
@@ -235,8 +235,7 @@ private void CheckRuntimeContext(string what)
                 || !RuntimeContext.CurrentGrainContext.Equals(context))
             {
                 throw new InvalidOperationException(
-                    string.Format("{0} in timer callback with unexpected activation context: Expected={1} Actual={2}",
-                                  what, context, RuntimeContext.CurrentGrainContext));
+                    $"{what} in timer callback with unexpected activation context: Expected={context} Actual={RuntimeContext.CurrentGrainContext}");
             }
             if (TaskScheduler.Current.Equals(activationTaskScheduler) && TaskScheduler.Current is ActivationTaskScheduler)
             {
@@ -245,8 +244,7 @@ private void CheckRuntimeContext(string what)
             else
             {
                 throw new InvalidOperationException(
-                    string.Format("{0} in timer callback with unexpected TaskScheduler.Current context: Expected={1} Actual={2}",
-                                  what, activationTaskScheduler, TaskScheduler.Current));
+                    $"{what} in timer callback with unexpected TaskScheduler.Current context: Expected={activationTaskScheduler} Actual={TaskScheduler.Current}");
             }
         }
 
diff --git a/test/NonSilo.Tests/General/RingTests_Standalone.cs b/test/NonSilo.Tests/General/RingTests_Standalone.cs
index d7326b951..10d809ba2 100644
--- a/test/NonSilo.Tests/General/RingTests_Standalone.cs
+++ b/test/NonSilo.Tests/General/RingTests_Standalone.cs
@@ -173,9 +173,9 @@ private void VerifyRing(Dictionary<SiloAddress, ConsistentRingProvider> rings)
             foreach (ConsistentRingProvider r in rings.Values)
             {
                 // see if there is no overlap between the responsibilities of two nodes
-                Assert.True(fullring.Remove(r.GetMyRange()), string.Format("Couldn't find & break range {0} in {1}. Some other node already claimed responsibility.", r.GetMyRange(), fullring));
+                Assert.True(fullring.Remove(r.GetMyRange()), $"Couldn't find & break range {r.GetMyRange()} in {fullring}. Some other node already claimed responsibility.");
             }
-            Assert.True(fullring.NumRanges == 0, string.Format("Range not completely covered. Uncovered ranges: {0}", fullring));
+            Assert.True(fullring.NumRanges == 0, $"Range not completely covered. Uncovered ranges: {fullring}");
         }
 
         /// <summary>
@@ -208,7 +208,7 @@ private static int CompareSiloAddressesByHash(SiloAddress x, SiloAddress y)
     internal class RangeBreakable
     {
         private List<SingleRange> ranges { get; set; }
-        internal int NumRanges { get { return ranges.Count(); } }
+        internal int NumRanges { get { return ranges.Count; } }
 
         public RangeBreakable()
         {
diff --git a/test/NonSilo.Tests/SchedulerTests/OrleansTaskSchedulerAdvancedTests.cs b/test/NonSilo.Tests/SchedulerTests/OrleansTaskSchedulerAdvancedTests.cs
index c2b974ef4..6b3e3082a 100644
--- a/test/NonSilo.Tests/SchedulerTests/OrleansTaskSchedulerAdvancedTests.cs
+++ b/test/NonSilo.Tests/SchedulerTests/OrleansTaskSchedulerAdvancedTests.cs
@@ -148,14 +148,14 @@ public void Sched_AC_MainTurnWait_Test()
 
         private void SubProcess1(int n)
         {
-            string msg = string.Format("1-{0} MainDone={1} inside Task {2}", n, this.mainDone, Task.CurrentId);
+            string msg = $"1-{n} MainDone={this.mainDone} inside Task {Task.CurrentId}";
             this.output.WriteLine("1 ===> " + msg);
             Assert.True(this.mainDone, msg + " -- Main turn should be finished");
             this.stageNum1 = n;
         }
         private void SubProcess2(int n)
         {
-            string msg = string.Format("2-{0} MainDone={1} inside Task {2}", n, this.mainDone, Task.CurrentId);
+            string msg = $"2-{n} MainDone={this.mainDone} inside Task {Task.CurrentId}";
             this.output.WriteLine("2 ===> " + msg);
             Assert.True(this.mainDone, msg + " -- Main turn should be finished");
             this.stageNum2 = n;
diff --git a/test/TestInfrastructure/TestExtensions/MockStorageProvider.cs b/test/TestInfrastructure/TestExtensions/MockStorageProvider.cs
index b3057cdc8..a51423dd9 100644
--- a/test/TestInfrastructure/TestExtensions/MockStorageProvider.cs
+++ b/test/TestInfrastructure/TestExtensions/MockStorageProvider.cs
@@ -93,7 +93,7 @@ public MockStorageProvider(string name, int numKeys, ILoggerFactory loggerFactor
             this.numKeys = numKeys;
 
             this.Name = name;
-            this.logger = loggerFactory.CreateLogger(string.Format("Storage.{0}-{1}", this.GetType().Name, this._id));
+            this.logger = loggerFactory.CreateLogger($"Storage.{this.GetType().Name}-{this._id}");
 
             logger.Info(0, "Init Name={0}", name);
             this.serializationManager = serializationManager;
diff --git a/test/TestInfrastructure/TestExtensions/TestUtils.cs b/test/TestInfrastructure/TestExtensions/TestUtils.cs
index 1558df252..d1a92bbc1 100644
--- a/test/TestInfrastructure/TestExtensions/TestUtils.cs
+++ b/test/TestInfrastructure/TestExtensions/TestUtils.cs
@@ -96,7 +96,7 @@ public static TimeSpan TimeRun(int numIterations, TimeSpan baseline, string what
             if (baseline > TimeSpan.Zero)
             {
                 double delta = (duration - baseline).TotalMilliseconds / baseline.TotalMilliseconds;
-                timeDeltaStr = String.Format("-- Change = {0}%", 100.0 * delta);
+                timeDeltaStr = $"-- Change = {100.0 * delta}%";
             }
             Console.WriteLine("Time for {0} loops doing {1} = {2} {3} Memory used={4}", numIterations, what, duration, timeDeltaStr, memUsed);
             return duration;
diff --git a/test/Tester/EventSourcingTests/AccountGrainTests.cs b/test/Tester/EventSourcingTests/AccountGrainTests.cs
index e81cb8b67..9190665c3 100644
--- a/test/Tester/EventSourcingTests/AccountGrainTests.cs
+++ b/test/Tester/EventSourcingTests/AccountGrainTests.cs
@@ -46,7 +46,7 @@ private async Task TestSequence(IAccountGrain account, bool hasLogStored)
                 // check the transaction log
                 var log = await account.GetTransactionLog();
 
-                Assert.Equal(2, log.Count());
+                Assert.Equal(2, log.Count);
                 Assert.Equal(initialdepositguid, log[0].Guid);
                 Assert.Equal("initial deposit", log[0].Description);
                 Assert.Equal(firstwithdrawalguid, log[1].Guid);
diff --git a/test/Tester/EventSourcingTests/CountersGrainPerfTests.cs b/test/Tester/EventSourcingTests/CountersGrainPerfTests.cs
index 857ffaa4b..62c597186 100644
--- a/test/Tester/EventSourcingTests/CountersGrainPerfTests.cs
+++ b/test/Tester/EventSourcingTests/CountersGrainPerfTests.cs
@@ -109,7 +109,7 @@ public class SimplePriorityOrderer : ITestCaseOrderer
 
         private bool HasRunThisFirstAttribute(ITestCase testcase)
         {
-            return testcase.TestMethod.Method.GetCustomAttributes(attrname).Count() > 0;
+            return testcase.TestMethod.Method.GetCustomAttributes(attrname).Any();
         }
 
         public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases) where TTestCase : ITestCase
diff --git a/test/Tester/MembershipTests/LivenessTests.cs b/test/Tester/MembershipTests/LivenessTests.cs
index 1bdc25329..b27a14a83 100644
--- a/test/Tester/MembershipTests/LivenessTests.cs
+++ b/test/Tester/MembershipTests/LivenessTests.cs
@@ -61,7 +61,7 @@ protected async Task Do_Liveness_OracleTest_1()
                     Assert.True(pair.Value == SiloStatus.ShuttingDown
                         || pair.Value == SiloStatus.Stopping
                         || pair.Value == SiloStatus.Dead,
-                        string.Format("SiloStatus for {0} should now be ShuttingDown or Stopping or Dead instead of {1}", silo, pair.Value));
+                        $"SiloStatus for {silo} should now be ShuttingDown or Stopping or Dead instead of {pair.Value}");
                 }
                 else
                 {
diff --git a/test/TesterInternal/ActivationsLifeCycleTests/ActivationCollectorTests.cs b/test/TesterInternal/ActivationsLifeCycleTests/ActivationCollectorTests.cs
index b9be92705..5e229838d 100644
--- a/test/TesterInternal/ActivationsLifeCycleTests/ActivationCollectorTests.cs
+++ b/test/TesterInternal/ActivationsLifeCycleTests/ActivationCollectorTests.cs
@@ -447,7 +447,7 @@ public async Task ActivationCollectorShouldNotCollectBusyStatelessWorkers()
 
                 // 3. verify that multiple activations for each grain have been created.
                 int activationsCreated = await TestUtils.GetActivationCount(this.testCluster.GrainFactory, grainTypeName);
-                Assert.True(activationsCreated > grainCount, string.Format("more than {0} activations should have been created; got {1} instead", grainCount, activationsCreated));
+                Assert.True(activationsCreated > grainCount, $"more than {grainCount} activations should have been created; got {activationsCreated} instead");
 
                 // 4. periodically send a message to each grain...
                 this.logger.Info("ActivationCollectorShouldNotCollectBusyStatelessWorkers: grains activated; sending heartbeat to {0} stateless worker grains.", grainCount);
@@ -470,7 +470,7 @@ public async Task ActivationCollectorShouldNotCollectBusyStatelessWorkers()
                 // verify that we matched activation ids in the final iteration of step 4's loop.
                 for (int index = 0; index < grains.Count; ++index)
                 {
-                    Assert.True(matched[index], string.Format("activation ID of final subsequent heartbeats did not match for grain {0}", grains[index]));
+                    Assert.True(matched[index], $"activation ID of final subsequent heartbeats did not match for grain {grains[index]}");
                 }
             }
         }
diff --git a/test/TesterInternal/General/ConsistentRingProviderTests_Silo.cs b/test/TesterInternal/General/ConsistentRingProviderTests_Silo.cs
index 61695e179..43965838b 100644
--- a/test/TesterInternal/General/ConsistentRingProviderTests_Silo.cs
+++ b/test/TesterInternal/General/ConsistentRingProviderTests_Silo.cs
@@ -218,8 +218,7 @@ private uint PickKey(SiloAddress responsibleSilo)
                 if (responsibleSilo.Equals(s))
                     return randomKey;
             }
-            throw new Exception(String.Format("Could not pick a key that silo {0} will be responsible for. Primary.Ring = \n{1}",
-                responsibleSilo, testHooks.GetConsistentRingProviderDiagnosticInfo().Result));
+            throw new Exception($"Could not pick a key that silo {responsibleSilo} will be responsible for. Primary.Ring = \n{testHooks.GetConsistentRingProviderDiagnosticInfo().Result}");
         }
 
         private void VerificationScenario(uint testKey)
diff --git a/test/TesterInternal/General/ElasticPlacementTest.cs b/test/TesterInternal/General/ElasticPlacementTest.cs
index 7a4f0fa1e..45e88d25f 100644
--- a/test/TesterInternal/General/ElasticPlacementTest.cs
+++ b/test/TesterInternal/General/ElasticPlacementTest.cs
@@ -213,8 +213,7 @@ private async Task<IPlacementTestGrain> GetGrainAtSilo(SiloAddress silo)
         private static void AssertIsInRange(int actual, double expected, int leavy)
         {
             Assert.True(expected - leavy <= actual && actual <= expected + leavy,
-                String.Format("Expecting a value in the range between {0} and {1}, but instead got {2} outside the range.",
-                    expected - leavy, expected + leavy, actual));
+                $"Expecting a value in the range between {expected - leavy} and {expected + leavy}, but instead got {actual} outside the range.");
         }
 
 
diff --git a/test/TesterInternal/LivenessTests/ConsistentRingProviderTests.cs b/test/TesterInternal/LivenessTests/ConsistentRingProviderTests.cs
index 33d2d885f..f1e0550bd 100644
--- a/test/TesterInternal/LivenessTests/ConsistentRingProviderTests.cs
+++ b/test/TesterInternal/LivenessTests/ConsistentRingProviderTests.cs
@@ -93,11 +93,7 @@ public void ConsistentRingProvider_Test3()
 
             Dictionary<SiloAddress, List<int>> queueHistogram = GetQueueHistogram(allAgentRanges, (int)NUM_QUEUES);
             string str = Utils.EnumerableToString(sortedSiloRanges,
-                tuple => String.Format("Silo {0} -> Range {1:0.000}%, {2} queues: {3}", 
-                    tuple.Item1,
-                    tuple.Item2.RangePercentage(),
-                    queueHistogram[tuple.Item1].Sum(),
-                    Utils.EnumerableToString(queueHistogram[tuple.Item1])), "\n");
+                tuple => $"Silo {tuple.Item1} -> Range {tuple.Item2.RangePercentage():0.000}%, {queueHistogram[tuple.Item1].Sum()} queues: {Utils.EnumerableToString(queueHistogram[tuple.Item1])}", "\n");
 
             output.WriteLine("\n\n*** The whole ring with {0} silos is:\n{1}\n\n", NUM_SILOS, str);
 
diff --git a/test/TesterInternal/MessageScheduling/DisabledCallChainReentrancyTestRunner.cs b/test/TesterInternal/MessageScheduling/DisabledCallChainReentrancyTestRunner.cs
index f71292a46..6f6174761 100644
--- a/test/TesterInternal/MessageScheduling/DisabledCallChainReentrancyTestRunner.cs
+++ b/test/TesterInternal/MessageScheduling/DisabledCallChainReentrancyTestRunner.cs
@@ -38,7 +38,7 @@ public void NonReentrantGrain(bool performDeadlockDetection)
                 }
                 else
                 {
-                    Assert.True(false, string.Format("Unexpected exception {0}: {1}", exc.Message, exc.StackTrace));
+                    Assert.True(false, $"Unexpected exception {exc.Message}: {exc.StackTrace}");
                 }
             }
             if (performDeadlockDetection)
@@ -71,7 +71,7 @@ public void NonReentrantGrain_WithMessageInterleavesPredicate_StreamItemDelivery
                 }
                 else
                 {
-                    Assert.True(false, string.Format("Unexpected exception {0}: {1}", exc.Message, exc.StackTrace));
+                    Assert.True(false, $"Unexpected exception {exc.Message}: {exc.StackTrace}");
                 }
             }
             if (performDeadlockDetection)
@@ -104,7 +104,7 @@ public void NonReentrantGrain_WithMayInterleavePredicate_WhenPredicateReturnsFal
                 }
                 else
                 {
-                    Assert.True(false, string.Format("Unexpected exception {0}: {1}", exc.Message, exc.StackTrace));
+                    Assert.True(false, $"Unexpected exception {exc.Message}: {exc.StackTrace}");
                 }
             }
             if (performDeadlockDetection)
diff --git a/test/TesterInternal/MessageScheduling/ReentrancyTests.cs b/test/TesterInternal/MessageScheduling/ReentrancyTests.cs
index 4c79ecd9f..6ab0de974 100644
--- a/test/TesterInternal/MessageScheduling/ReentrancyTests.cs
+++ b/test/TesterInternal/MessageScheduling/ReentrancyTests.cs
@@ -64,7 +64,7 @@ public void ReentrantGrain()
             }
             catch (Exception ex)
             {
-                Assert.True(false, string.Format("Unexpected exception {0}: {1}", ex.Message, ex.StackTrace));
+                Assert.True(false, $"Unexpected exception {ex.Message}: {ex.StackTrace}");
             }
             this.fixture.Logger.Info("Reentrancy ReentrantGrain Test finished OK.");
         }
@@ -80,7 +80,7 @@ public void NonReentrantGrain_WithMayInterleavePredicate_WhenPredicateReturnsTru
             }
             catch (Exception ex)
             {
-                Assert.True(false, string.Format("Unexpected exception {0}: {1}", ex.Message, ex.StackTrace));
+                Assert.True(false, $"Unexpected exception {ex.Message}: {ex.StackTrace}");
             }
             this.fixture.Logger.Info("Reentrancy NonReentrantGrain_WithMayInterleavePredicate_WhenPredicateReturnsTrue Test finished OK.");
         }
@@ -96,7 +96,7 @@ public void NonReentrantGrain_WithMayInterleavePredicate_StreamItemDelivery_When
             }
             catch (Exception ex)
             {
-                Assert.True(false, string.Format("Unexpected exception {0}: {1}", ex.Message, ex.StackTrace));
+                Assert.True(false, $"Unexpected exception {ex.Message}: {ex.StackTrace}");
             }
             this.fixture.Logger.Info("Reentrancy NonReentrantGrain_WithMayInterleavePredicate_StreamItemDelivery_WhenPredicateReturnsTrue Test finished OK.");
         }
diff --git a/test/TesterInternal/OrleansRuntime/Streams/FixedSizeBufferTests.cs b/test/TesterInternal/OrleansRuntime/Streams/FixedSizeBufferTests.cs
index e0e6a7e7e..c3178a107 100644
--- a/test/TesterInternal/OrleansRuntime/Streams/FixedSizeBufferTests.cs
+++ b/test/TesterInternal/OrleansRuntime/Streams/FixedSizeBufferTests.cs
@@ -60,11 +60,11 @@ public void FillBlockTestBvt()
             ArraySegment<byte> segment;
             for (int i = 0; i < TestBlockSize; i++)
             {
-                Assert.True(buffer.TryGetSegment(1, out segment), String.Format("Should be able to get {0}th segement of size 1.", i + 1));
+                Assert.True(buffer.TryGetSegment(1, out segment), $"Should be able to get {i + 1}th segement of size 1.");
                 Assert.Equal(i, segment.Offset);
                 Assert.Single(segment);
             }
-            Assert.False(buffer.TryGetSegment(1, out segment), String.Format("Should be able to get {0}th segement of size 1.", TestBlockSize + 1));
+            Assert.False(buffer.TryGetSegment(1, out segment), $"Should be able to get {TestBlockSize + 1}th segement of size 1.");
             Assert.Null(segment.Array);
             Assert.Equal(0, segment.Offset);
 #pragma warning disable xUnit2013 // Do not use equality check to check for collection size.
diff --git a/test/TesterInternal/StreamingTests/StreamTestUtils.cs b/test/TesterInternal/StreamingTests/StreamTestUtils.cs
index dcf09fe45..acb3bccab 100644
--- a/test/TesterInternal/StreamingTests/StreamTestUtils.cs
+++ b/test/TesterInternal/StreamingTests/StreamTestUtils.cs
@@ -76,7 +76,7 @@ internal static void Assert_AreEqual(ITestOutputHelper output, int expected, int
         {
             // expected == -1 means don't care / don't assert check value.
             string prefix = expected == -1 ? "Not-checked" : actual == expected ? "True" : "FALSE";
-            string fmtMsg = String.Format("--> {0}: ", prefix) + String.Format(msg, args);
+            string fmtMsg = $"--> {prefix}: " + String.Format(msg, args);
             output.WriteLine(fmtMsg);
             if (expected != -1)
             {
diff --git a/test/TesterInternal/TimerTests/ReminderTests_Base.cs b/test/TesterInternal/TimerTests/ReminderTests_Base.cs
index b2dd0338b..3b9d7667b 100644
--- a/test/TesterInternal/TimerTests/ReminderTests_Base.cs
+++ b/test/TesterInternal/TimerTests/ReminderTests_Base.cs
@@ -405,9 +405,9 @@ protected async Task ExecuteWithRetriesStop(Func<string, Task> function, string
 
         private bool HandleError(Exception ex, long i)
         {
-            if (ex is AggregateException)
+            if (ex is AggregateException aggregateException)
             {
-                ex = ((AggregateException)ex).Flatten().InnerException;
+                ex = aggregateException.Flatten().InnerException;
             }
 
             if (ex is ReminderException)
