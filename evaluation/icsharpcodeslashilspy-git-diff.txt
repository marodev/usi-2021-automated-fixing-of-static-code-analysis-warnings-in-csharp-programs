diff --git a/ICSharpCode.Decompiler/CSharp/CSharpDecompiler.cs b/ICSharpCode.Decompiler/CSharp/CSharpDecompiler.cs
index 6a6ecb687..a511a6ea8 100644
--- a/ICSharpCode.Decompiler/CSharp/CSharpDecompiler.cs
+++ b/ICSharpCode.Decompiler/CSharp/CSharpDecompiler.cs
@@ -1673,7 +1673,7 @@ EntityDeclaration DoDecompile(IField field, DecompileRun decompileRun, ITypeReso
 					try
 					{
 						var initVal = fieldDefinition.GetInitialValue(module.PEFile.Reader, TypeSystem);
-						message = string.Format(" Not supported: data({0}) ", BitConverter.ToString(initVal.ReadBytes(initVal.RemainingBytes)).Replace('-', ' '));
+						message = $" Not supported: data({BitConverter.ToString(initVal.ReadBytes(initVal.RemainingBytes)).Replace('-', ' ')}) ";
 					}
 					catch (BadImageFormatException ex)
 					{
@@ -1720,9 +1720,9 @@ EntityDeclaration DoDecompile(IProperty property, DecompileRun decompileRun, ITy
 				}
 				FixParameterNames(propertyDecl);
 				Accessor getter, setter;
-				if (propertyDecl is PropertyDeclaration)
+				if (propertyDecl is PropertyDeclaration propertyDeclaration)
 				{
-					getter = ((PropertyDeclaration)propertyDecl).Getter;
+					getter = propertyDeclaration.Getter;
 					setter = ((PropertyDeclaration)propertyDecl).Setter;
 				}
 				else
diff --git a/ICSharpCode.Decompiler/CSharp/CallBuilder.cs b/ICSharpCode.Decompiler/CSharp/CallBuilder.cs
index ff5122676..d2e8ff838 100644
--- a/ICSharpCode.Decompiler/CSharp/CallBuilder.cs
+++ b/ICSharpCode.Decompiler/CSharp/CallBuilder.cs
@@ -296,12 +296,12 @@ public TranslatedExpression Build(CallInstruction inst)
 						argumentList.GetArgumentResolveResults(), isExpandedForm: argumentList.IsExpandedForm));
 			}
 
-			if (method is VarArgInstanceMethod)
+			if (method is VarArgInstanceMethod varArgInstanceMethod)
 			{
 				argumentList.FirstOptionalArgumentIndex = -1;
 				argumentList.AddNamesToPrimitiveValues = false;
 				argumentList.UseImplicitlyTypedOut = false;
-				int regularParameterCount = ((VarArgInstanceMethod)method).RegularParameterCount;
+				int regularParameterCount = varArgInstanceMethod.RegularParameterCount;
 				var argListArg = new UndocumentedExpression();
 				argListArg.UndocumentedExpressionType = UndocumentedExpressionType.ArgList;
 				int paramIndex = regularParameterCount;
diff --git a/ICSharpCode.Decompiler/CSharp/ExpressionBuilder.cs b/ICSharpCode.Decompiler/CSharp/ExpressionBuilder.cs
index 29fab54b6..ba697fa16 100644
--- a/ICSharpCode.Decompiler/CSharp/ExpressionBuilder.cs
+++ b/ICSharpCode.Decompiler/CSharp/ExpressionBuilder.cs
@@ -1053,9 +1053,7 @@ TranslatedExpression TranslateComp(Comp inst)
 			right = AdjustConstantExpressionToType(right, left.Type);
 
 			// attempt comparison without any additional casts
-			var rr = resolver.ResolveBinaryOperator(inst.Kind.ToBinaryOperatorType(), left.ResolveResult, right.ResolveResult)
-				as OperatorResolveResult;
-			if (rr != null && !rr.IsError)
+			if (resolver.ResolveBinaryOperator(inst.Kind.ToBinaryOperatorType(), left.ResolveResult, right.ResolveResult) is OperatorResolveResult rr && !rr.IsError)
 			{
 				IType compUType = NullableType.GetUnderlyingType(rr.Operands[0].Type);
 				if (compUType.GetSign() == inst.Sign && compUType.GetStackType() == inst.InputType)
@@ -3054,9 +3052,9 @@ protected internal override TranslatedExpression VisitArglist(Arglist inst, Tran
 		protected internal override TranslatedExpression VisitMakeRefAny(MakeRefAny inst, TranslationContext context)
 		{
 			var arg = Translate(inst.Argument).Expression;
-			if (arg is DirectionExpression)
+			if (arg is DirectionExpression directionExpression)
 			{
-				arg = ((DirectionExpression)arg).Expression;
+				arg = directionExpression.Expression;
 			}
 			return new UndocumentedExpression {
 				UndocumentedExpressionType = UndocumentedExpressionType.MakeRef,
diff --git a/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpAmbience.cs b/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpAmbience.cs
index 93408ef5f..5c3d7c7ef 100644
--- a/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpAmbience.cs
+++ b/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpAmbience.cs
@@ -58,15 +58,15 @@ public void ConvertSymbol(ISymbol symbol, TokenWriter writer, CSharpFormattingOp
 			TypeSystemAstBuilder astBuilder = CreateAstBuilder();
 			AstNode node = astBuilder.ConvertSymbol(symbol);
 			writer.StartNode(node);
-			EntityDeclaration entityDecl = node as EntityDeclaration;
-			if (entityDecl != null)
+
+			if (node is EntityDeclaration entityDecl)
 				PrintModifiers(entityDecl.Modifiers, writer);
 
 			if ((ConversionFlags & ConversionFlags.ShowDefinitionKeyword) == ConversionFlags.ShowDefinitionKeyword)
 			{
-				if (node is TypeDeclaration)
+				if (node is TypeDeclaration typeDeclaration)
 				{
-					switch (((TypeDeclaration)node).ClassType)
+					switch (typeDeclaration.ClassType)
 					{
 						case ClassType.Class:
 							writer.WriteKeyword(Roles.ClassKeyword, "class");
@@ -116,10 +116,10 @@ public void ConvertSymbol(ISymbol symbol, TokenWriter writer, CSharpFormattingOp
 				}
 			}
 
-			if (symbol is ITypeDefinition)
-				WriteTypeDeclarationName((ITypeDefinition)symbol, writer, formattingPolicy);
-			else if (symbol is IMember)
-				WriteMemberDeclarationName((IMember)symbol, writer, formattingPolicy);
+			if (symbol is ITypeDefinition iTypeDefinition)
+				WriteTypeDeclarationName(iTypeDefinition, writer, formattingPolicy);
+			else if (symbol is IMember iMember)
+				WriteMemberDeclarationName(iMember, writer, formattingPolicy);
 			else
 				writer.WriteIdentifier(Identifier.Create(symbol.Name));
 
@@ -175,8 +175,7 @@ public void ConvertSymbol(ISymbol symbol, TokenWriter writer, CSharpFormattingOp
 
 			if ((ConversionFlags & ConversionFlags.ShowBody) == ConversionFlags.ShowBody && !(node is TypeDeclaration))
 			{
-				IProperty property = symbol as IProperty;
-				if (property != null)
+				if (symbol is IProperty property)
 				{
 					writer.Space();
 					writer.WriteToken(Roles.LBrace, "{");
diff --git a/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpOutputVisitor.cs b/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpOutputVisitor.cs
index d0974a0a5..18cc591ab 100644
--- a/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpOutputVisitor.cs
+++ b/ICSharpCode.Decompiler/CSharp/OutputVisitor/CSharpOutputVisitor.cs
@@ -439,17 +439,17 @@ public static bool IsKeyword(string identifier, AstNode context)
 				foreach (AstNode ancestor in context.Ancestors)
 				{
 					// with lambdas/anonymous methods,
-					if (ancestor is LambdaExpression)
+					if (ancestor is LambdaExpression lambdaExpression)
 					{
-						return ((LambdaExpression)ancestor).IsAsync;
+						return lambdaExpression.IsAsync;
 					}
-					if (ancestor is AnonymousMethodExpression)
+					if (ancestor is AnonymousMethodExpression anonymousMethodExpression)
 					{
-						return ((AnonymousMethodExpression)ancestor).IsAsync;
+						return anonymousMethodExpression.IsAsync;
 					}
-					if (ancestor is EntityDeclaration)
+					if (ancestor is EntityDeclaration entityDeclaration)
 					{
-						return (((EntityDeclaration)ancestor).Modifiers & Modifiers.Async) == Modifiers.Async;
+						return (entityDeclaration.Modifiers & Modifiers.Async) == Modifiers.Async;
 					}
 				}
 			}
@@ -521,8 +521,8 @@ protected virtual void WriteEmbeddedStatement(Statement embeddedStatement, NewLi
 				NewLine();
 				return;
 			}
-			BlockStatement block = embeddedStatement as BlockStatement;
-			if (block != null)
+
+			if (embeddedStatement is BlockStatement block)
 			{
 				WriteBlock(block, policy.StatementBraceStyle);
 				if (nlp == NewLinePlacement.SameLine)
@@ -662,10 +662,8 @@ public virtual void VisitArrayInitializerExpression(ArrayInitializerExpression a
 
 		protected bool CanBeConfusedWithObjectInitializer(Expression expr)
 		{
-			// "int a; new List<int> { a = 1 };" is an object initalizers and invalid, but
-			// "int a; new List<int> { { a = 1 } };" is a valid collection initializer.
-			AssignmentExpression ae = expr as AssignmentExpression;
-			return ae != null && ae.Operator == AssignmentOperatorType.Assign;
+			// "int a; new List<int> { a = 1 };" is an object initalizers and invalid, but			// "int a; new List<int> { { a = 1 } };" is a valid collection initializer.
+			return expr is AssignmentExpression ae && ae.Operator == AssignmentOperatorType.Assign;
 		}
 
 		protected bool IsObjectOrCollectionInitializer(AstNode node)
@@ -2266,8 +2264,8 @@ public virtual void VisitConstructorDeclaration(ConstructorDeclaration construct
 			StartNode(constructorDeclaration);
 			WriteAttributes(constructorDeclaration.Attributes);
 			WriteModifiers(constructorDeclaration.ModifierTokens);
-			TypeDeclaration type = constructorDeclaration.Parent as TypeDeclaration;
-			if (type != null && type.Name != constructorDeclaration.Name)
+
+			if (constructorDeclaration.Parent is TypeDeclaration type && type.Name != constructorDeclaration.Name)
 				WriteIdentifier((Identifier)type.NameToken.Clone());
 			else
 				WriteIdentifier(constructorDeclaration.NameToken);
@@ -2312,8 +2310,8 @@ public virtual void VisitDestructorDeclaration(DestructorDeclaration destructorD
 				Space();
 			}
 			WriteToken(DestructorDeclaration.TildeRole);
-			TypeDeclaration type = destructorDeclaration.Parent as TypeDeclaration;
-			if (type != null && type.Name != destructorDeclaration.Name)
+
+			if (destructorDeclaration.Parent is TypeDeclaration type && type.Name != destructorDeclaration.Name)
 				WriteIdentifier((Identifier)type.NameToken.Clone());
 			else
 				WriteIdentifier(destructorDeclaration.NameToken);
@@ -2851,8 +2849,7 @@ public virtual void VisitConstraint(Constraint constraint)
 
 		public virtual void VisitCSharpTokenNode(CSharpTokenNode cSharpTokenNode)
 		{
-			CSharpModifierToken mod = cSharpTokenNode as CSharpModifierToken;
-			if (mod != null)
+			if (cSharpTokenNode is CSharpModifierToken mod)
 			{
 				// ITokenWriter assumes that each node processed between a
 				// StartNode(parentNode)-EndNode(parentNode)-pair is a child of parentNode.
@@ -2971,37 +2968,37 @@ void VisitOptionalNode(OptionalNode optionalNode)
 
 		void VisitNodeInPattern(INode childNode)
 		{
-			if (childNode is AstNode)
+			if (childNode is AstNode astNode)
 			{
-				((AstNode)childNode).AcceptVisitor(this);
+				astNode.AcceptVisitor(this);
 			}
-			else if (childNode is IdentifierExpressionBackreference)
+			else if (childNode is IdentifierExpressionBackreference identifierExpressionBackreference)
 			{
-				VisitIdentifierExpressionBackreference((IdentifierExpressionBackreference)childNode);
+				VisitIdentifierExpressionBackreference(identifierExpressionBackreference);
 			}
-			else if (childNode is Choice)
+			else if (childNode is Choice choice)
 			{
-				VisitChoice((Choice)childNode);
+				VisitChoice(choice);
 			}
-			else if (childNode is AnyNode)
+			else if (childNode is AnyNode anyNode)
 			{
-				VisitAnyNode((AnyNode)childNode);
+				VisitAnyNode(anyNode);
 			}
-			else if (childNode is Backreference)
+			else if (childNode is Backreference backreference)
 			{
-				VisitBackreference((Backreference)childNode);
+				VisitBackreference(backreference);
 			}
-			else if (childNode is NamedNode)
+			else if (childNode is NamedNode namedNode)
 			{
-				VisitNamedNode((NamedNode)childNode);
+				VisitNamedNode(namedNode);
 			}
-			else if (childNode is OptionalNode)
+			else if (childNode is OptionalNode optionalNode)
 			{
-				VisitOptionalNode((OptionalNode)childNode);
+				VisitOptionalNode(optionalNode);
 			}
-			else if (childNode is Repeat)
+			else if (childNode is Repeat repeat)
 			{
-				VisitRepeat((Repeat)childNode);
+				VisitRepeat(repeat);
 			}
 			else
 			{
diff --git a/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertMissingTokensDecorator.cs b/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertMissingTokensDecorator.cs
index 8b637218d..0bccb8e65 100644
--- a/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertMissingTokensDecorator.cs
+++ b/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertMissingTokensDecorator.cs
@@ -106,20 +106,18 @@ public override void WriteKeyword(Role role, string keyword)
 		{
 			TextLocation start = locationProvider.Location;
 			CSharpTokenNode t = null;
-			if (role is TokenRole)
-				t = new CSharpTokenNode(start, (TokenRole)role);
+			if (role is TokenRole tokenRole)
+				t = new CSharpTokenNode(start, tokenRole);
 			else if (role == EntityDeclaration.ModifierRole)
 				t = new CSharpModifierToken(start, CSharpModifierToken.GetModifierValue(keyword));
 			else if (keyword == "this")
 			{
-				ThisReferenceExpression node = nodes.Peek().LastOrDefault() as ThisReferenceExpression;
-				if (node != null)
+				if (nodes.Peek().LastOrDefault() is ThisReferenceExpression node)
 					node.Location = start;
 			}
 			else if (keyword == "base")
 			{
-				BaseReferenceExpression node = nodes.Peek().LastOrDefault() as BaseReferenceExpression;
-				if (node != null)
+				if (nodes.Peek().LastOrDefault() is ThisReferenceExpression node)
 					node.Location = start;
 			}
 			if (t != null)
@@ -143,20 +141,19 @@ public override void WritePrimitiveValue(object value, LiteralFormat format = Li
 			Expression node = nodes.Peek().LastOrDefault() as Expression;
 			var startLocation = locationProvider.Location;
 			base.WritePrimitiveValue(value, format);
-			if (node is PrimitiveExpression)
+			if (node is PrimitiveExpression primitiveExpression)
 			{
-				((PrimitiveExpression)node).SetLocation(startLocation, locationProvider.Location);
+				primitiveExpression.SetLocation(startLocation, locationProvider.Location);
 			}
-			if (node is NullReferenceExpression)
+			if (node is NullReferenceExpression nullReferenceExpression)
 			{
-				((NullReferenceExpression)node).SetStartLocation(startLocation);
+				nullReferenceExpression.SetStartLocation(startLocation);
 			}
 		}
 
 		public override void WritePrimitiveType(string type)
 		{
-			PrimitiveType node = nodes.Peek().LastOrDefault() as PrimitiveType;
-			if (node != null)
+			if (nodes.Peek().LastOrDefault() is PrimitiveType node)
 				node.SetStartLocation(locationProvider.Location);
 			base.WritePrimitiveType(type);
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertParenthesesVisitor.cs b/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertParenthesesVisitor.cs
index 4b706e127..729d6e738 100644
--- a/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertParenthesesVisitor.cs
+++ b/ICSharpCode.Decompiler/CSharp/OutputVisitor/InsertParenthesesVisitor.cs
@@ -215,8 +215,8 @@ public override void VisitIndexerExpression(IndexerExpression indexerExpression)
 		public override void VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression)
 		{
 			ParenthesizeIfRequired(unaryOperatorExpression.Expression, GetPrecedence(unaryOperatorExpression));
-			UnaryOperatorExpression child = unaryOperatorExpression.Expression as UnaryOperatorExpression;
-			if (child != null && InsertParenthesesForReadability)
+
+			if (unaryOperatorExpression.Expression is UnaryOperatorExpression child && InsertParenthesesForReadability)
 				Parenthesize(child);
 			base.VisitUnaryOperatorExpression(unaryOperatorExpression);
 		}
@@ -228,10 +228,9 @@ public override void VisitCastExpression(CastExpression castExpression)
 			{
 				ParenthesizeIfRequired(castExpression.Expression, InsertParenthesesForReadability ? PrecedenceLevel.NullableRewrap : PrecedenceLevel.Unary);
 			}
-			// There's a nasty issue in the C# grammar: cast expressions including certain operators are ambiguous in some cases
-			// "(int)-1" is fine, but "(A)-b" is not a cast.
-			UnaryOperatorExpression uoe = castExpression.Expression as UnaryOperatorExpression;
-			if (uoe != null && !(uoe.Operator == UnaryOperatorType.BitNot || uoe.Operator == UnaryOperatorType.Not))
+
+			// There's a nasty issue in the C# grammar: cast expressions including certain operators are ambiguous in some cases			// "(int)-1" is fine, but "(A)-b" is not a cast.
+			if (castExpression.Expression is UnaryOperatorExpression uoe && !(uoe.Operator == UnaryOperatorType.BitNot || uoe.Operator == UnaryOperatorType.Not))
 			{
 				if (TypeCanBeMisinterpretedAsExpression(castExpression.Type))
 				{
@@ -240,7 +239,7 @@ public override void VisitCastExpression(CastExpression castExpression)
 			}
 			// The above issue can also happen with PrimitiveExpressions representing negative values:
 			PrimitiveExpression pe = castExpression.Expression as PrimitiveExpression;
-			if (pe != null && pe.Value != null && TypeCanBeMisinterpretedAsExpression(castExpression.Type))
+			if (pe?.Value != null && TypeCanBeMisinterpretedAsExpression(castExpression.Type))
 			{
 				TypeCode typeCode = Type.GetTypeCode(pe.Value.GetType());
 				switch (typeCode)
@@ -280,11 +279,8 @@ public override void VisitCastExpression(CastExpression castExpression)
 
 		static bool TypeCanBeMisinterpretedAsExpression(AstType type)
 		{
-			// SimpleTypes can always be misinterpreted as IdentifierExpressions
-			// MemberTypes can be misinterpreted as MemberReferenceExpressions if they don't use double colon
-			// PrimitiveTypes or ComposedTypes can never be misinterpreted as expressions.
-			MemberType mt = type as MemberType;
-			if (mt != null)
+			// SimpleTypes can always be misinterpreted as IdentifierExpressions			// MemberTypes can be misinterpreted as MemberReferenceExpressions if they don't use double colon			// PrimitiveTypes or ComposedTypes can never be misinterpreted as expressions.
+			if (type is MemberType mt)
 				return !mt.IsDoubleColon;
 			else
 				return type is SimpleType;
@@ -351,8 +347,7 @@ static bool IsBitwise(BinaryOperatorType op)
 
 		BinaryOperatorType? GetBinaryOperatorType(Expression expr)
 		{
-			BinaryOperatorExpression boe = expr as BinaryOperatorExpression;
-			if (boe != null)
+			if (expr is BinaryOperatorExpression boe)
 				return boe.Operator;
 			else
 				return null;
diff --git a/ICSharpCode.Decompiler/CSharp/Resolver/CSharpInvocationResolveResult.cs b/ICSharpCode.Decompiler/CSharp/Resolver/CSharpInvocationResolveResult.cs
index b6fa7c0e3..9e8012c3e 100644
--- a/ICSharpCode.Decompiler/CSharp/Resolver/CSharpInvocationResolveResult.cs
+++ b/ICSharpCode.Decompiler/CSharp/Resolver/CSharpInvocationResolveResult.cs
@@ -106,8 +106,7 @@ public override IList<ResolveResult> GetArgumentsForCall()
 					}
 					else
 					{
-						var narr = Arguments[i] as NamedArgumentResolveResult;
-						if (narr != null)
+						if (Arguments[i] is NamedArgumentResolveResult narr)
 							results[mappedTo] = narr.Argument;
 						else
 							results[mappedTo] = Arguments[i];
diff --git a/ICSharpCode.Decompiler/CSharp/Resolver/CSharpOperators.cs b/ICSharpCode.Decompiler/CSharp/Resolver/CSharpOperators.cs
index 2064c1f52..3f8cf553b 100644
--- a/ICSharpCode.Decompiler/CSharp/Resolver/CSharpOperators.cs
+++ b/ICSharpCode.Decompiler/CSharp/Resolver/CSharpOperators.cs
@@ -1133,8 +1133,7 @@ public LiftedUserDefinedOperator(IMethod nonLiftedMethod)
 
 			public override bool Equals(object obj)
 			{
-				LiftedUserDefinedOperator op = obj as LiftedUserDefinedOperator;
-				return op != null && this.nonLiftedOperator.Equals(op.nonLiftedOperator);
+				return obj is LiftedUserDefinedOperator op && this.nonLiftedOperator.Equals(op.nonLiftedOperator);
 			}
 
 			public override int GetHashCode()
diff --git a/ICSharpCode.Decompiler/CSharp/Resolver/CSharpResolver.cs b/ICSharpCode.Decompiler/CSharp/Resolver/CSharpResolver.cs
index 27e173e1b..52edc255a 100644
--- a/ICSharpCode.Decompiler/CSharp/Resolver/CSharpResolver.cs
+++ b/ICSharpCode.Decompiler/CSharp/Resolver/CSharpResolver.cs
@@ -377,8 +377,8 @@ public ResolveResult ResolveUnaryOperator(UnaryOperatorType op, ResolveResult ex
 				switch (op)
 				{
 					case UnaryOperatorType.Dereference:
-						PointerType p = expression.Type as PointerType;
-						if (p != null)
+
+						if (expression.Type is PointerType p)
 							return UnaryOperatorResolveResult(p.ElementType, op, expression);
 						else
 							return ErrorResult;
@@ -392,8 +392,8 @@ public ResolveResult ResolveUnaryOperator(UnaryOperatorType op, ResolveResult ex
 						var lookup = CreateMemberLookup();
 						IMethod getResultMethod;
 						IType awaitResultType;
-						var getResultMethodGroup = lookup.Lookup(getAwaiterInvocation, "GetResult", EmptyList<IType>.Instance, true) as MethodGroupResolveResult;
-						if (getResultMethodGroup != null)
+
+						if (lookup.Lookup(getAwaiterInvocation, "GetResult", EmptyList<IType>.Instance, true) is MethodGroupResolveResult getResultMethodGroup)
 						{
 							var getResultOR = getResultMethodGroup.PerformOverloadResolution(compilation, Empty<ResolveResult>.Array, allowExtensionMethods: false, conversions: conversions);
 							getResultMethod = getResultOR.FoundApplicableCandidate ? getResultOR.GetBestCandidateWithSubstitutedTypeArguments() as IMethod : null;
@@ -1512,9 +1512,9 @@ public ResolveResult LookupSimpleNameOrTypeName(string identifier, IReadOnlyList
 							return new LocalResolveResult(v);
 						}
 					}
+
 					// Look in parameters of current method
-					IParameterizedMember parameterizedMember = this.CurrentMember as IParameterizedMember;
-					if (parameterizedMember != null)
+					if (this.CurrentMember is IParameterizedMember parameterizedMember)
 					{
 						foreach (IParameter p in parameterizedMember.Parameters)
 						{
@@ -1527,8 +1527,7 @@ public ResolveResult LookupSimpleNameOrTypeName(string identifier, IReadOnlyList
 				}
 
 				// look in type parameters of current method
-				IMethod m = this.CurrentMember as IMethod;
-				if (m != null)
+				if (this.CurrentMember is IMethod m)
 				{
 					foreach (ITypeParameter tp in m.TypeParameters)
 					{
@@ -1817,8 +1816,8 @@ public ResolveResult ResolveMemberAccess(ResolveResult target, string identifier
 			// C# 4.0 spec: §7.6.4
 
 			bool parameterizeResultType = !(typeArguments.Count != 0 && typeArguments.All(t => t.Kind == TypeKind.UnboundTypeArgument));
-			NamespaceResolveResult nrr = target as NamespaceResolveResult;
-			if (nrr != null)
+
+			if (target is NamespaceResolveResult nrr)
 			{
 				return ResolveMemberAccessOnNamespace(nrr, identifier, typeArguments, parameterizeResultType);
 			}
@@ -1861,8 +1860,7 @@ public ResolveResult ResolveMemberAccess(ResolveResult target, string identifier
 			}
 			else
 			{
-				MethodGroupResolveResult mgrr = result as MethodGroupResolveResult;
-				if (mgrr != null)
+				if (result is MethodGroupResolveResult mgrr)
 				{
 					Debug.Assert(mgrr.extensionMethods == null);
 					// set the values that are necessary to make MethodGroupResolveResult.GetExtensionMethods() work
@@ -1957,8 +1955,7 @@ public ForEachResolveResult ResolveForeach(ResolveResult expression)
 			}
 			else
 			{
-				var getEnumeratorMethodGroup = memberLookup.Lookup(expression, "GetEnumerator", EmptyList<IType>.Instance, true) as MethodGroupResolveResult;
-				if (getEnumeratorMethodGroup != null)
+				if (memberLookup.Lookup(expression, "GetEnumerator", EmptyList<IType>.Instance, true) is MethodGroupResolveResult getEnumeratorMethodGroup)
 				{
 					var or = getEnumeratorMethodGroup.PerformOverloadResolution(
 						compilation, Empty<ResolveResult>.Array,
@@ -1982,8 +1979,8 @@ public ForEachResolveResult ResolveForeach(ResolveResult expression)
 				}
 			}
 			IMethod moveNextMethod = null;
-			var moveNextMethodGroup = memberLookup.Lookup(new ResolveResult(enumeratorType), "MoveNext", EmptyList<IType>.Instance, false) as MethodGroupResolveResult;
-			if (moveNextMethodGroup != null)
+
+			if (memberLookup.Lookup(new ResolveResult(enumeratorType), "MoveNext", EmptyList<IType>.Instance, false) is MethodGroupResolveResult moveNextMethodGroup)
 			{
 				var or = moveNextMethodGroup.PerformOverloadResolution(
 					compilation, Empty<ResolveResult>.Array,
@@ -1994,8 +1991,8 @@ public ForEachResolveResult ResolveForeach(ResolveResult expression)
 			if (currentRR == null)
 				currentRR = memberLookup.Lookup(new ResolveResult(enumeratorType), "Current", EmptyList<IType>.Instance, false);
 			IProperty currentProperty = null;
-			if (currentRR is MemberResolveResult)
-				currentProperty = ((MemberResolveResult)currentRR).Member as IProperty;
+			if (currentRR is MemberResolveResult memberResolveResult)
+				currentProperty = memberResolveResult.Member as IProperty;
 
 			var voidType = compilation.FindType(KnownTypeCode.Void);
 			return new ForEachResolveResult(getEnumeratorInvocation, collectionType, enumeratorType, elementType,
@@ -2271,8 +2268,8 @@ private ResolveResult ResolveInvocation(ResolveResult target, ResolveResult[] ar
 			}
 
 			bool isDynamic = arguments.Any(a => a.Type.Kind == TypeKind.Dynamic);
-			MethodGroupResolveResult mgrr = target as MethodGroupResolveResult;
-			if (mgrr != null)
+
+			if (target is MethodGroupResolveResult mgrr)
 			{
 				if (isDynamic)
 				{
@@ -2315,13 +2312,13 @@ private ResolveResult ResolveInvocation(ResolveResult target, ResolveResult[] ar
 						mgrr.TargetType, mgrr.MethodName, mgrr.TypeArguments, CreateParameters(arguments, argumentNames));
 				}
 			}
-			UnknownMemberResolveResult umrr = target as UnknownMemberResolveResult;
-			if (umrr != null)
+
+			if (target is UnknownMemberResolveResult umrr)
 			{
 				return new UnknownMethodResolveResult(umrr.TargetType, umrr.MemberName, umrr.TypeArguments, CreateParameters(arguments, argumentNames));
 			}
-			UnknownIdentifierResolveResult uirr = target as UnknownIdentifierResolveResult;
-			if (uirr != null && CurrentTypeDefinition != null)
+
+			if (target is UnknownIdentifierResolveResult uirr && CurrentTypeDefinition != null)
 			{
 				return new UnknownMethodResolveResult(CurrentTypeDefinition, uirr.Identifier, EmptyList<IType>.Instance, CreateParameters(arguments, argumentNames));
 			}
@@ -2393,8 +2390,7 @@ List<IParameter> CreateParameters(ResolveResult[] arguments, string[] argumentNa
 				}
 
 				// create the parameter:
-				ByReferenceResolveResult brrr = arguments[i] as ByReferenceResolveResult;
-				if (brrr != null)
+				if (arguments[i] is ByReferenceResolveResult brrr)
 				{
 					list.Add(new DefaultParameter(arguments[i].Type, argumentNames[i], referenceKind: brrr.ReferenceKind));
 				}
@@ -2417,20 +2413,16 @@ List<IParameter> CreateParameters(ResolveResult[] arguments, string[] argumentNa
 
 		static string GuessParameterName(ResolveResult rr)
 		{
-			MemberResolveResult mrr = rr as MemberResolveResult;
-			if (mrr != null)
+			if (rr is MemberResolveResult mrr)
 				return mrr.Member.Name;
 
-			UnknownMemberResolveResult umrr = rr as UnknownMemberResolveResult;
-			if (umrr != null)
+			if (rr is UnknownMemberResolveResult umrr)
 				return umrr.MemberName;
 
-			MethodGroupResolveResult mgrr = rr as MethodGroupResolveResult;
-			if (mgrr != null)
+			if (rr is MethodGroupResolveResult mgrr)
 				return mgrr.MethodName;
 
-			LocalResolveResult vrr = rr as LocalResolveResult;
-			if (vrr != null)
+			if (rr is LocalResolveResult vrr)
 				return MakeParameterName(vrr.Variable.Name);
 
 			if (rr.Type.Kind != TypeKind.Unknown && !string.IsNullOrEmpty(rr.Type.Name))
diff --git a/ICSharpCode.Decompiler/CSharp/Resolver/MemberLookup.cs b/ICSharpCode.Decompiler/CSharp/Resolver/MemberLookup.cs
index 65a276942..8e151035a 100644
--- a/ICSharpCode.Decompiler/CSharp/Resolver/MemberLookup.cs
+++ b/ICSharpCode.Decompiler/CSharp/Resolver/MemberLookup.cs
@@ -754,7 +754,7 @@ ResolveResult CreateResult(ResolveResult targetResolveResult, List<LookupGroup>
 				if (isInEnumMemberInitializer)
 				{
 					IField field = resultGroup.NonMethod as IField;
-					if (field != null && field.DeclaringTypeDefinition != null && field.DeclaringTypeDefinition.Kind == TypeKind.Enum)
+					if (field?.DeclaringTypeDefinition != null && field.DeclaringTypeDefinition.Kind == TypeKind.Enum)
 					{
 						return new MemberResolveResult(
 							targetResolveResult, field,
diff --git a/ICSharpCode.Decompiler/CSharp/Resolver/MethodGroupResolveResult.cs b/ICSharpCode.Decompiler/CSharp/Resolver/MethodGroupResolveResult.cs
index d08108c22..9e62ce35f 100644
--- a/ICSharpCode.Decompiler/CSharp/Resolver/MethodGroupResolveResult.cs
+++ b/ICSharpCode.Decompiler/CSharp/Resolver/MethodGroupResolveResult.cs
@@ -226,7 +226,7 @@ public IEnumerable<IEnumerable<IMethod>> GetEligibleExtensionMethods(bool substi
 
 		public override string ToString()
 		{
-			return string.Format("[{0} with {1} method(s)]", GetType().Name, this.Methods.Count());
+			return $"[{GetType().Name} with {this.Methods.Count()} method(s)]";
 		}
 
 		public OverloadResolution PerformOverloadResolution(ICompilation compilation, ResolveResult[] arguments, string[] argumentNames = null,
diff --git a/ICSharpCode.Decompiler/CSharp/Resolver/OverloadResolution.cs b/ICSharpCode.Decompiler/CSharp/Resolver/OverloadResolution.cs
index 09fd186f7..10b1710a2 100644
--- a/ICSharpCode.Decompiler/CSharp/Resolver/OverloadResolution.cs
+++ b/ICSharpCode.Decompiler/CSharp/Resolver/OverloadResolution.cs
@@ -356,12 +356,7 @@ public void AddMethodLists(IReadOnlyList<MethodListWithDeclaringType> methodList
 		internal void LogCandidateAddingResult(string text, IParameterizedMember method, OverloadResolutionErrors errors)
 		{
 #if DEBUG
-			Log.WriteLine(string.Format("{0} {1} = {2}{3}",
-										text, method,
-										errors == OverloadResolutionErrors.None ? "Success" : errors.ToString(),
-										this.BestCandidate == method ? " (best candidate so far)" :
-										this.BestCandidateAmbiguousWith == method ? " (ambiguous)" : ""
-									   ));
+			Log.WriteLine($"{text} {method} = {(errors == OverloadResolutionErrors.None ? "Success" : errors.ToString())}{(this.BestCandidate == method ? " (best candidate so far)" : this.BestCandidateAmbiguousWith == method ? " (ambiguous)" : "")}");
 #endif
 		}
 		#endregion
diff --git a/ICSharpCode.Decompiler/CSharp/StatementBuilder.cs b/ICSharpCode.Decompiler/CSharp/StatementBuilder.cs
index 9ca261116..431f14743 100644
--- a/ICSharpCode.Decompiler/CSharp/StatementBuilder.cs
+++ b/ICSharpCode.Decompiler/CSharp/StatementBuilder.cs
@@ -329,8 +329,7 @@ private void ConvertSwitchSectionBody(Syntax.SwitchSection astSection, ILInstruc
 			if (!bodyInst.HasFlag(InstructionFlags.EndPointUnreachable))
 			{
 				// we need to insert 'break;'
-				BlockStatement block = body as BlockStatement;
-				if (block != null)
+				if (body is BlockStatement block)
 				{
 					block.Add(new BreakStatement());
 				}
@@ -427,8 +426,8 @@ protected internal override TranslatedStatement VisitYieldReturn(YieldReturn ins
 		TryCatchStatement MakeTryCatch(ILInstruction tryBlock)
 		{
 			var tryBlockConverted = Convert(tryBlock);
-			var tryCatch = tryBlockConverted as TryCatchStatement;
-			if (tryCatch != null && tryCatch.FinallyBlock.IsNull)
+
+			if (tryBlockConverted is TryCatchStatement tryCatch && tryCatch.FinallyBlock.IsNull)
 				return tryCatch; // extend existing try-catch
 			tryCatch = new TryCatchStatement();
 			tryCatch.TryBlock = tryBlockConverted as BlockStatement ?? new BlockStatement { tryBlockConverted };
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/AstNode.cs b/ICSharpCode.Decompiler/CSharp/Syntax/AstNode.cs
index 91a05b3e2..ac02260f8 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/AstNode.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/AstNode.cs
@@ -529,7 +529,7 @@ public void ReplaceWith(AstNode newNode)
 			// we perform a runtime test:
 			if (!this.Role.IsValid(newNode))
 			{
-				throw new ArgumentException(string.Format("The new node '{0}' is not valid in the role {1}", newNode.GetType().Name, this.Role.ToString()), nameof(newNode));
+				throw new ArgumentException($"The new node '{newNode.GetType().Name}' is not valid in the role {this.Role.ToString()}", nameof(newNode));
 			}
 			if (newNode.parent != null)
 			{
@@ -599,7 +599,7 @@ public AstNode ReplaceWith(Func<AstNode, AstNode> replaceFunction)
 					throw new InvalidOperationException("replace function must return the root of a tree");
 				if (!oldRole.IsValid(replacement))
 				{
-					throw new InvalidOperationException(string.Format("The new node '{0}' is not valid in the role {1}", replacement.GetType().Name, oldRole.ToString()));
+					throw new InvalidOperationException($"The new node '{replacement.GetType().Name}' is not valid in the role {oldRole.ToString()}");
 				}
 
 				if (oldSuccessor != null)
@@ -827,8 +827,8 @@ public AstNode GetNodeAt(TextLocation location, Predicate<AstNode> pred = null)
 					child = child.prevSibling;
 				if (child != null && location < child.EndLocation)
 				{
-					if (child is T)
-						result = (T)child;
+					if (child is T t)
+						result = t;
 					node = child;
 				}
 				else
@@ -908,8 +908,8 @@ public AstNode GetAdjacentNodeAt(TextLocation location, Predicate<AstNode> pred
 					child = child.prevSibling;
 				if (child != null && location <= child.EndLocation)
 				{
-					if (child is T)
-						result = (T)child;
+					if (child is T t)
+						result = t;
 					node = child;
 				}
 				else
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/AstType.cs b/ICSharpCode.Decompiler/CSharp/Syntax/AstType.cs
index a8b8da53a..2603272e4 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/AstType.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/AstType.cs
@@ -133,8 +133,7 @@ public new AstType Clone()
 		/// </summary>
 		public bool IsVar()
 		{
-			SimpleType st = this as SimpleType;
-			return st != null && st.Identifier == "var" && st.TypeArguments.Count == 0;
+			return this is SimpleType st && st.Identifier == "var" && st.TypeArguments.Count == 0;
 		}
 
 		/// <summary>
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/CSharpModifierToken.cs b/ICSharpCode.Decompiler/CSharp/Syntax/CSharpModifierToken.cs
index b81a7d76b..25dc55cb1 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/CSharpModifierToken.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/CSharpModifierToken.cs
@@ -56,8 +56,7 @@ public override string ToString(CSharpFormattingOptions formattingOptions)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CSharpModifierToken o = other as CSharpModifierToken;
-			return o != null && this.modifier == o.modifier;
+			return other is CSharpModifierToken o && this.modifier == o.modifier;
 		}
 
 		// Not worth using a dictionary for such few elements.
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/CSharpTokenNode.cs b/ICSharpCode.Decompiler/CSharp/Syntax/CSharpTokenNode.cs
index 5cd2a5d02..0c3d8f441 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/CSharpTokenNode.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/CSharpTokenNode.cs
@@ -124,8 +124,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CSharpTokenNode o = other as CSharpTokenNode;
-			return o != null && !o.IsNull && !(o is CSharpModifierToken);
+			return other is CSharpTokenNode o && !o.IsNull && !(o is CSharpModifierToken);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/ComposedType.cs b/ICSharpCode.Decompiler/CSharp/Syntax/ComposedType.cs
index 05532d89e..ef648b865 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/ComposedType.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/ComposedType.cs
@@ -146,8 +146,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ComposedType o = other as ComposedType;
-			return o != null
+			return other is ComposedType o
 				&& this.HasNullableSpecifier == o.HasNullableSpecifier
 				&& this.PointerRank == o.PointerRank
 				&& this.HasRefSpecifier == o.HasRefSpecifier
@@ -289,8 +288,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ArraySpecifier o = other as ArraySpecifier;
-			return o != null && this.Dimensions == o.Dimensions;
+			return other is ArraySpecifier o && this.Dimensions == o.Dimensions;
 		}
 
 		public override string ToString(CSharpFormattingOptions formattingOptions)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/DocumentationReference.cs b/ICSharpCode.Decompiler/CSharp/Syntax/DocumentationReference.cs
index 893f015fc..557f224fb 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/DocumentationReference.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/DocumentationReference.cs
@@ -111,8 +111,7 @@ public class DocumentationReference : AstNode
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			DocumentationReference o = other as DocumentationReference;
-			if (!(o != null && this.SymbolKind == o.SymbolKind && this.HasParameterList == o.HasParameterList))
+			if (!(other is DocumentationReference o && this.SymbolKind == o.SymbolKind && this.HasParameterList == o.HasParameterList))
 				return false;
 			if (this.SymbolKind == SymbolKind.Operator)
 			{
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousMethodExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousMethodExpression.cs
index 633073b36..fa30490be 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousMethodExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousMethodExpression.cs
@@ -111,8 +111,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			AnonymousMethodExpression o = other as AnonymousMethodExpression;
-			return o != null && this.IsAsync == o.IsAsync && this.HasParameterList == o.HasParameterList
+			return other is AnonymousMethodExpression o && this.IsAsync == o.IsAsync && this.HasParameterList == o.HasParameterList
 				&& this.Parameters.DoMatch(o.Parameters, match) && this.Body.DoMatch(o.Body, match);
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousTypeCreateExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousTypeCreateExpression.cs
index e74e2e1af..4a5ac3792 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousTypeCreateExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AnonymousTypeCreateExpression.cs
@@ -83,8 +83,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as AnonymousTypeCreateExpression;
-			return o != null && this.Initializers.DoMatch(o.Initializers, match);
+			return other is AnonymousTypeCreateExpression o && this.Initializers.DoMatch(o.Initializers, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayCreateExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayCreateExpression.cs
index eaad6ff6b..7be13909f 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayCreateExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayCreateExpression.cs
@@ -71,8 +71,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ArrayCreateExpression o = other as ArrayCreateExpression;
-			return o != null && this.Type.DoMatch(o.Type, match)
+			return other is ArrayCreateExpression o && this.Type.DoMatch(o.Type, match)
 				&& this.Arguments.DoMatch(o.Arguments, match)
 				&& this.AdditionalArraySpecifiers.DoMatch(o.AdditionalArraySpecifiers, match)
 				&& this.Initializer.DoMatch(o.Initializer, match);
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayInitializerExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayInitializerExpression.cs
index f9ce09152..06945384f 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayInitializerExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ArrayInitializerExpression.cs
@@ -121,8 +121,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ArrayInitializerExpression o = other as ArrayInitializerExpression;
-			return o != null && this.Elements.DoMatch(o.Elements, match);
+			return other is ArrayInitializerExpression o && this.Elements.DoMatch(o.Elements, match);
 		}
 
 		public static ArrayInitializerExpression CreateSingleElementInitializer()
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AsExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AsExpression.cs
index b01fd4f86..18b41255c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AsExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AsExpression.cs
@@ -75,8 +75,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			AsExpression o = other as AsExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match) && this.Type.DoMatch(o.Type, match);
+			return other is AsExpression o && this.Expression.DoMatch(o.Expression, match) && this.Type.DoMatch(o.Type, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AssignmentExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AssignmentExpression.cs
index acd1038a8..637e94090 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AssignmentExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/AssignmentExpression.cs
@@ -104,8 +104,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			AssignmentExpression o = other as AssignmentExpression;
-			return o != null && (this.Operator == AssignmentOperatorType.Any || this.Operator == o.Operator)
+			return other is AssignmentExpression o && (this.Operator == AssignmentOperatorType.Any || this.Operator == o.Operator)
 				&& this.Left.DoMatch(o.Left, match) && this.Right.DoMatch(o.Right, match);
 		}
 
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BaseReferenceExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BaseReferenceExpression.cs
index 5084d0e04..77e9c6a15 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BaseReferenceExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BaseReferenceExpression.cs
@@ -65,8 +65,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			BaseReferenceExpression o = other as BaseReferenceExpression;
-			return o != null;
+			return other is BaseReferenceExpression o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BinaryOperatorExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BinaryOperatorExpression.cs
index 579d92e53..d095e47d3 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BinaryOperatorExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/BinaryOperatorExpression.cs
@@ -106,8 +106,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			BinaryOperatorExpression o = other as BinaryOperatorExpression;
-			return o != null && (this.Operator == BinaryOperatorType.Any || this.Operator == o.Operator)
+			return other is BinaryOperatorExpression o && (this.Operator == BinaryOperatorType.Any || this.Operator == o.Operator)
 				&& this.Left.DoMatch(o.Left, match) && this.Right.DoMatch(o.Right, match);
 		}
 
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CastExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CastExpression.cs
index f3bd22ec2..cda39186f 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CastExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CastExpression.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CastExpression o = other as CastExpression;
-			return o != null && this.Type.DoMatch(o.Type, match) && this.Expression.DoMatch(o.Expression, match);
+			return other is CastExpression o && this.Type.DoMatch(o.Type, match) && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CheckedExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CheckedExpression.cs
index baff6c51a..a727b3fd4 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CheckedExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/CheckedExpression.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CheckedExpression o = other as CheckedExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is CheckedExpression o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ConditionalExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ConditionalExpression.cs
index a1576e5cc..49d0e9b1a 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ConditionalExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ConditionalExpression.cs
@@ -89,8 +89,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ConditionalExpression o = other as ConditionalExpression;
-			return o != null && this.Condition.DoMatch(o.Condition, match) && this.TrueExpression.DoMatch(o.TrueExpression, match) && this.FalseExpression.DoMatch(o.FalseExpression, match);
+			return other is ConditionalExpression o && this.Condition.DoMatch(o.Condition, match) && this.TrueExpression.DoMatch(o.TrueExpression, match) && this.FalseExpression.DoMatch(o.FalseExpression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DefaultValueExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DefaultValueExpression.cs
index 372325a40..0a9bfb6f9 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DefaultValueExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DefaultValueExpression.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			DefaultValueExpression o = other as DefaultValueExpression;
-			return o != null && this.Type.DoMatch(o.Type, match);
+			return other is DefaultValueExpression o && this.Type.DoMatch(o.Type, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DirectionExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DirectionExpression.cs
index e92115530..11c6a82a6 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DirectionExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/DirectionExpression.cs
@@ -95,8 +95,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			DirectionExpression o = other as DirectionExpression;
-			return o != null && this.FieldDirection == o.FieldDirection && this.Expression.DoMatch(o.Expression, match);
+			return other is DirectionExpression o && this.FieldDirection == o.FieldDirection && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ErrorExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ErrorExpression.cs
index 89f9fcfdd..7af685000 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ErrorExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ErrorExpression.cs
@@ -74,8 +74,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as ErrorExpression;
-			return o != null;
+			return other is ErrorExpression o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IdentifierExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IdentifierExpression.cs
index 76fc8c2a5..7a922a468 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IdentifierExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IdentifierExpression.cs
@@ -81,8 +81,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			IdentifierExpression o = other as IdentifierExpression;
-			return o != null && MatchString(this.Identifier, o.Identifier) && this.TypeArguments.DoMatch(o.TypeArguments, match);
+			return other is IdentifierExpression o && MatchString(this.Identifier, o.Identifier) && this.TypeArguments.DoMatch(o.TypeArguments, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IndexerExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IndexerExpression.cs
index e688b2a74..7575d0aaa 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IndexerExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IndexerExpression.cs
@@ -87,8 +87,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			IndexerExpression o = other as IndexerExpression;
-			return o != null && this.Target.DoMatch(o.Target, match) && this.Arguments.DoMatch(o.Arguments, match);
+			return other is IndexerExpression o && this.Target.DoMatch(o.Target, match) && this.Arguments.DoMatch(o.Arguments, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InterpolatedStringExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InterpolatedStringExpression.cs
index 9f7c6ab47..bd61d3f65 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InterpolatedStringExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InterpolatedStringExpression.cs
@@ -37,8 +37,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, Match match)
 		{
-			InterpolatedStringExpression o = other as InterpolatedStringExpression;
-			return o != null && !o.IsNull && this.Content.DoMatch(o.Content, match);
+			return other is InterpolatedStringExpression o && !o.IsNull && this.Content.DoMatch(o.Content, match);
 		}
 	}
 
@@ -133,8 +132,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, Match match)
 		{
-			Interpolation o = other as Interpolation;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is Interpolation o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 
@@ -169,8 +167,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, Match match)
 		{
-			InterpolatedStringText o = other as InterpolatedStringText;
-			return o != null && o.Text == this.Text;
+			return other is InterpolatedStringText o && o.Text == this.Text;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InvocationExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InvocationExpression.cs
index 3ed91cefc..148e4b601 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InvocationExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/InvocationExpression.cs
@@ -87,8 +87,7 @@ public InvocationExpression(Expression target, params Expression[] arguments) :
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			InvocationExpression o = other as InvocationExpression;
-			return o != null && this.Target.DoMatch(o.Target, match) && this.Arguments.DoMatch(o.Arguments, match);
+			return other is InvocationExpression o && this.Target.DoMatch(o.Target, match) && this.Arguments.DoMatch(o.Arguments, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IsExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IsExpression.cs
index fa1bea0bc..254bc8557 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IsExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/IsExpression.cs
@@ -76,8 +76,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			IsExpression o = other as IsExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match) && this.Type.DoMatch(o.Type, match);
+			return other is IsExpression o && this.Expression.DoMatch(o.Expression, match) && this.Type.DoMatch(o.Type, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/LambdaExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/LambdaExpression.cs
index c3829d882..62c9ba54c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/LambdaExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/LambdaExpression.cs
@@ -79,8 +79,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			LambdaExpression o = other as LambdaExpression;
-			return o != null && this.IsAsync == o.IsAsync && this.Parameters.DoMatch(o.Parameters, match) && this.Body.DoMatch(o.Body, match);
+			return other is LambdaExpression o && this.IsAsync == o.IsAsync && this.Parameters.DoMatch(o.Parameters, match) && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/MemberReferenceExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/MemberReferenceExpression.cs
index fcda03b54..a1b8f0687 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/MemberReferenceExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/MemberReferenceExpression.cs
@@ -114,8 +114,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			MemberReferenceExpression o = other as MemberReferenceExpression;
-			return o != null && this.Target.DoMatch(o.Target, match) && MatchString(this.MemberName, o.MemberName) && this.TypeArguments.DoMatch(o.TypeArguments, match);
+			return other is MemberReferenceExpression o && this.Target.DoMatch(o.Target, match) && MatchString(this.MemberName, o.MemberName) && this.TypeArguments.DoMatch(o.TypeArguments, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedArgumentExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedArgumentExpression.cs
index 5f3fb3627..7c82a9ccf 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedArgumentExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedArgumentExpression.cs
@@ -79,8 +79,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			NamedArgumentExpression o = other as NamedArgumentExpression;
-			return o != null && MatchString(this.Name, o.Name) && this.Expression.DoMatch(o.Expression, match);
+			return other is NamedArgumentExpression o && MatchString(this.Name, o.Name) && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedExpression.cs
index d8fe23df8..3f78a320a 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NamedExpression.cs
@@ -88,8 +88,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as NamedExpression;
-			return o != null && MatchString(this.Name, o.Name) && this.Expression.DoMatch(o.Expression, match);
+			return other is NamedExpression o && MatchString(this.Name, o.Name) && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NullReferenceExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NullReferenceExpression.cs
index ee67fb20f..4b1991f2e 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NullReferenceExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/NullReferenceExpression.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			NullReferenceExpression o = other as NullReferenceExpression;
-			return o != null;
+			return other is NullReferenceExpression o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ObjectCreateExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ObjectCreateExpression.cs
index f559f6a89..82b4ac061 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ObjectCreateExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ObjectCreateExpression.cs
@@ -99,8 +99,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ObjectCreateExpression o = other as ObjectCreateExpression;
-			return o != null && this.Type.DoMatch(o.Type, match) && this.Arguments.DoMatch(o.Arguments, match) && this.Initializer.DoMatch(o.Initializer, match);
+			return other is ObjectCreateExpression o && this.Type.DoMatch(o.Type, match) && this.Arguments.DoMatch(o.Arguments, match) && this.Initializer.DoMatch(o.Initializer, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/OutVarDeclarationExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/OutVarDeclarationExpression.cs
index 022987e80..11711f74c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/OutVarDeclarationExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/OutVarDeclarationExpression.cs
@@ -66,8 +66,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as OutVarDeclarationExpression;
-			return o != null && this.Type.DoMatch(o.Type, match) && this.Variable.DoMatch(o.Variable, match);
+			return other is OutVarDeclarationExpression o && this.Type.DoMatch(o.Type, match) && this.Variable.DoMatch(o.Variable, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ParenthesizedExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ParenthesizedExpression.cs
index b662ab3d4..d6fe428c8 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ParenthesizedExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ParenthesizedExpression.cs
@@ -71,8 +71,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ParenthesizedExpression o = other as ParenthesizedExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is ParenthesizedExpression o && this.Expression.DoMatch(o.Expression, match);
 		}
 
 		/// <summary>
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PointerReferenceExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PointerReferenceExpression.cs
index d678cdaf8..241b49667 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PointerReferenceExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PointerReferenceExpression.cs
@@ -82,8 +82,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			PointerReferenceExpression o = other as PointerReferenceExpression;
-			return o != null && MatchString(this.MemberName, o.MemberName) && this.TypeArguments.DoMatch(o.TypeArguments, match);
+			return other is PointerReferenceExpression o && MatchString(this.MemberName, o.MemberName) && this.TypeArguments.DoMatch(o.TypeArguments, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PrimitiveExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PrimitiveExpression.cs
index 1e2138338..632f0b84e 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PrimitiveExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/PrimitiveExpression.cs
@@ -144,8 +144,7 @@ unsafe static TextLocation AdvanceLocation(TextLocation startLocation, string st
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			PrimitiveExpression o = other as PrimitiveExpression;
-			return o != null && (this.Value == AnyValue || object.Equals(this.Value, o.Value));
+			return other is PrimitiveExpression o && (this.Value == AnyValue || object.Equals(this.Value, o.Value));
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/QueryExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/QueryExpression.cs
index 6b91ec02f..6df772773 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/QueryExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/QueryExpression.cs
@@ -78,8 +78,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryExpression o = other as QueryExpression;
-			return o != null && !o.IsNull && this.Clauses.DoMatch(o.Clauses, match);
+			return other is QueryExpression o && !o.IsNull && this.Clauses.DoMatch(o.Clauses, match);
 		}
 	}
 
@@ -152,8 +151,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryContinuationClause o = other as QueryContinuationClause;
-			return o != null && MatchString(this.Identifier, o.Identifier) && this.PrecedingQuery.DoMatch(o.PrecedingQuery, match);
+			return other is QueryContinuationClause o && MatchString(this.Identifier, o.Identifier) && this.PrecedingQuery.DoMatch(o.PrecedingQuery, match);
 		}
 	}
 
@@ -210,8 +208,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryFromClause o = other as QueryFromClause;
-			return o != null && this.Type.DoMatch(o.Type, match) && MatchString(this.Identifier, o.Identifier)
+			return other is QueryFromClause o && this.Type.DoMatch(o.Type, match) && MatchString(this.Identifier, o.Identifier)
 				&& this.Expression.DoMatch(o.Expression, match);
 		}
 	}
@@ -263,8 +260,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryLetClause o = other as QueryLetClause;
-			return o != null && MatchString(this.Identifier, o.Identifier) && this.Expression.DoMatch(o.Expression, match);
+			return other is QueryLetClause o && MatchString(this.Identifier, o.Identifier) && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 
@@ -299,8 +295,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryWhereClause o = other as QueryWhereClause;
-			return o != null && this.Condition.DoMatch(o.Condition, match);
+			return other is QueryWhereClause o && this.Condition.DoMatch(o.Condition, match);
 		}
 	}
 
@@ -408,8 +403,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryJoinClause o = other as QueryJoinClause;
-			return o != null && this.IsGroupJoin == o.IsGroupJoin
+			return other is QueryJoinClause o && this.IsGroupJoin == o.IsGroupJoin
 				&& this.Type.DoMatch(o.Type, match) && MatchString(this.JoinIdentifier, o.JoinIdentifier)
 				&& this.InExpression.DoMatch(o.InExpression, match) && this.OnExpression.DoMatch(o.OnExpression, match)
 				&& this.EqualsExpression.DoMatch(o.EqualsExpression, match)
@@ -447,8 +441,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryOrderClause o = other as QueryOrderClause;
-			return o != null && this.Orderings.DoMatch(o.Orderings, match);
+			return other is QueryOrderClause o && this.Orderings.DoMatch(o.Orderings, match);
 		}
 	}
 
@@ -492,8 +485,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryOrdering o = other as QueryOrdering;
-			return o != null && this.Direction == o.Direction && this.Expression.DoMatch(o.Expression, match);
+			return other is QueryOrdering o && this.Direction == o.Direction && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 
@@ -534,8 +526,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QuerySelectClause o = other as QuerySelectClause;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is QuerySelectClause o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 
@@ -581,8 +572,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			QueryGroupClause o = other as QueryGroupClause;
-			return o != null && this.Projection.DoMatch(o.Projection, match) && this.Key.DoMatch(o.Key, match);
+			return other is QueryGroupClause o && this.Projection.DoMatch(o.Projection, match) && this.Key.DoMatch(o.Key, match);
 		}
 	}
 }
\ No newline at end of file
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SizeOfExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SizeOfExpression.cs
index b5daa0a9f..2f9ca5430 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SizeOfExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SizeOfExpression.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SizeOfExpression o = other as SizeOfExpression;
-			return o != null && this.Type.DoMatch(o.Type, match);
+			return other is SizeOfExpression o && this.Type.DoMatch(o.Type, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/StackAllocExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/StackAllocExpression.cs
index f3c1c9b85..5b7d089a7 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/StackAllocExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/StackAllocExpression.cs
@@ -79,8 +79,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			StackAllocExpression o = other as StackAllocExpression;
-			return o != null && this.Type.DoMatch(o.Type, match)
+			return other is StackAllocExpression o && this.Type.DoMatch(o.Type, match)
 				&& this.CountExpression.DoMatch(o.CountExpression, match)
 				&& this.Initializer.DoMatch(o.Initializer, match);
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SwitchExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SwitchExpression.cs
index 9c9e166d6..118797ccf 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SwitchExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/SwitchExpression.cs
@@ -65,8 +65,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SwitchExpression o = other as SwitchExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match) && this.SwitchSections.DoMatch(o.SwitchSections, match);
+			return other is SwitchExpression o && this.Expression.DoMatch(o.Expression, match) && this.SwitchSections.DoMatch(o.SwitchSections, match);
 		}
 	}
 
@@ -111,8 +110,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SwitchExpressionSection o = other as SwitchExpressionSection;
-			return o != null && this.Pattern.DoMatch(o.Pattern, match) && this.Body.DoMatch(o.Body, match);
+			return other is SwitchExpressionSection o && this.Pattern.DoMatch(o.Pattern, match) && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThisReferenceExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThisReferenceExpression.cs
index db61e2dad..18ac48baa 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThisReferenceExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThisReferenceExpression.cs
@@ -65,8 +65,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ThisReferenceExpression o = other as ThisReferenceExpression;
-			return o != null;
+			return other is ThisReferenceExpression o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThrowExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThrowExpression.cs
index 736d2da6d..e3f00fdc8 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThrowExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/ThrowExpression.cs
@@ -60,8 +60,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ThrowExpression o = other as ThrowExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is ThrowExpression o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeOfExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeOfExpression.cs
index b6605ab63..3edea06b8 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeOfExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeOfExpression.cs
@@ -78,8 +78,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			TypeOfExpression o = other as TypeOfExpression;
-			return o != null && this.Type.DoMatch(o.Type, match);
+			return other is TypeOfExpression o && this.Type.DoMatch(o.Type, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeReferenceExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeReferenceExpression.cs
index 57c8ea9fa..a0a81ec7d 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeReferenceExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/TypeReferenceExpression.cs
@@ -56,8 +56,7 @@ public TypeReferenceExpression(AstType type)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			TypeReferenceExpression o = other as TypeReferenceExpression;
-			return o != null && this.Type.DoMatch(o.Type, match);
+			return other is TypeReferenceExpression o && this.Type.DoMatch(o.Type, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UnaryOperatorExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UnaryOperatorExpression.cs
index af925fc14..c40af751a 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UnaryOperatorExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UnaryOperatorExpression.cs
@@ -88,8 +88,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UnaryOperatorExpression o = other as UnaryOperatorExpression;
-			return o != null && (this.Operator == UnaryOperatorType.Any || this.Operator == o.Operator)
+			return other is UnaryOperatorExpression o && (this.Operator == UnaryOperatorType.Any || this.Operator == o.Operator)
 				&& this.Expression.DoMatch(o.Expression, match);
 		}
 
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UncheckedExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UncheckedExpression.cs
index aa8160127..ec6dff955 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UncheckedExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UncheckedExpression.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UncheckedExpression o = other as UncheckedExpression;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is UncheckedExpression o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UndocumentedExpression.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UndocumentedExpression.cs
index 7de290d8d..d74362ccc 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UndocumentedExpression.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Expressions/UndocumentedExpression.cs
@@ -97,8 +97,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UndocumentedExpression o = other as UndocumentedExpression;
-			return o != null && this.UndocumentedExpressionType == o.UndocumentedExpressionType && this.Arguments.DoMatch(o.Arguments, match);
+			return other is UndocumentedExpression o && this.UndocumentedExpressionType == o.UndocumentedExpressionType && this.Arguments.DoMatch(o.Arguments, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Attribute.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Attribute.cs
index b07bca2b2..74d4a8584 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Attribute.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Attribute.cs
@@ -79,8 +79,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			Attribute o = other as Attribute;
-			return o != null && this.Type.DoMatch(o.Type, match) && this.Arguments.DoMatch(o.Arguments, match);
+			return other is Attribute o && this.Type.DoMatch(o.Type, match) && this.Arguments.DoMatch(o.Arguments, match);
 		}
 
 		public override string ToString(CSharpFormattingOptions formattingOptions)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/AttributeSection.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/AttributeSection.cs
index cf8658fe0..eb41ceed5 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/AttributeSection.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/AttributeSection.cs
@@ -131,8 +131,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			AttributeSection o = other as AttributeSection;
-			return o != null && MatchString(this.AttributeTarget, o.AttributeTarget) && this.Attributes.DoMatch(o.Attributes, match);
+			return other is AttributeSection o && MatchString(this.AttributeTarget, o.AttributeTarget) && this.Attributes.DoMatch(o.Attributes, match);
 		}
 
 		public AttributeSection()
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Comment.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Comment.cs
index b2a84f0ff..0bd3679cb 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Comment.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Comment.cs
@@ -145,8 +145,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			Comment o = other as Comment;
-			return o != null && this.CommentType == o.CommentType && MatchString(this.Content, o.Content);
+			return other is Comment o && this.CommentType == o.CommentType && MatchString(this.Content, o.Content);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Constraint.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Constraint.cs
index 4b0c18618..9939508bc 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Constraint.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/Constraint.cs
@@ -75,8 +75,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			Constraint o = other as Constraint;
-			return o != null && this.TypeParameter.DoMatch(o.TypeParameter, match) && this.BaseTypes.DoMatch(o.BaseTypes, match);
+			return other is Constraint o && this.TypeParameter.DoMatch(o.TypeParameter, match) && this.BaseTypes.DoMatch(o.BaseTypes, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/DelegateDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/DelegateDeclaration.cs
index 0d85f5a59..d234bba9a 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/DelegateDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/DelegateDeclaration.cs
@@ -82,8 +82,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			DelegateDeclaration o = other as DelegateDeclaration;
-			return o != null && MatchString(this.Name, o.Name)
+			return other is DelegateDeclaration o && MatchString(this.Name, o.Name)
 				&& this.MatchAttributesAndModifiers(o, match) && this.ReturnType.DoMatch(o.ReturnType, match)
 				&& this.TypeParameters.DoMatch(o.TypeParameters, match) && this.Parameters.DoMatch(o.Parameters, match)
 				&& this.Constraints.DoMatch(o.Constraints, match);
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/ExternAliasDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/ExternAliasDeclaration.cs
index 353e71f2c..5a4e1d220 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/ExternAliasDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/ExternAliasDeclaration.cs
@@ -85,8 +85,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as ExternAliasDeclaration;
-			return o != null && MatchString(this.Name, o.Name);
+			return other is ExternAliasDeclaration o && MatchString(this.Name, o.Name);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/NamespaceDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/NamespaceDeclaration.cs
index 6da1f44ec..71dd20e9f 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/NamespaceDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/NamespaceDeclaration.cs
@@ -92,8 +92,8 @@ static AstType ConstructType(string[] arr, int i)
 					result.Push(mt.MemberName);
 					type = mt.Target;
 				}
-				if (type is SimpleType)
-					result.Push(((SimpleType)type).Identifier);
+				if (type is SimpleType simpleType)
+					result.Push(simpleType.Identifier);
 				return result;
 			}
 		}
@@ -150,8 +150,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			NamespaceDeclaration o = other as NamespaceDeclaration;
-			return o != null && MatchString(this.Name, o.Name) && this.Members.DoMatch(o.Members, match);
+			return other is NamespaceDeclaration o && MatchString(this.Name, o.Name) && this.Members.DoMatch(o.Members, match);
 		}
 	}
 };
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/PreProcessorDirective.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/PreProcessorDirective.cs
index 87005c003..fbf35a5ef 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/PreProcessorDirective.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/PreProcessorDirective.cs
@@ -195,8 +195,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			PreProcessorDirective o = other as PreProcessorDirective;
-			return o != null && Type == o.Type && MatchString(Argument, o.Argument);
+			return other is PreProcessorDirective o && Type == o.Type && MatchString(Argument, o.Argument);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeDeclaration.cs
index baec135cf..b163d9d00 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeDeclaration.cs
@@ -144,8 +144,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			TypeDeclaration o = other as TypeDeclaration;
-			return o != null && this.ClassType == o.ClassType && MatchString(this.Name, o.Name)
+			return other is TypeDeclaration o && this.ClassType == o.ClassType && MatchString(this.Name, o.Name)
 				&& this.MatchAttributesAndModifiers(o, match) && this.TypeParameters.DoMatch(o.TypeParameters, match)
 				&& this.BaseTypes.DoMatch(o.BaseTypes, match) && this.Constraints.DoMatch(o.Constraints, match)
 				&& this.PrimaryConstructorParameters.DoMatch(o.PrimaryConstructorParameters, match)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeParameterDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeParameterDeclaration.cs
index db5c622cf..7791c34d5 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeParameterDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/TypeParameterDeclaration.cs
@@ -106,8 +106,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			TypeParameterDeclaration o = other as TypeParameterDeclaration;
-			return o != null && this.Variance == o.Variance && MatchString(this.Name, o.Name) && this.Attributes.DoMatch(o.Attributes, match);
+			return other is TypeParameterDeclaration o && this.Variance == o.Variance && MatchString(this.Name, o.Name) && this.Attributes.DoMatch(o.Attributes, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingAliasDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingAliasDeclaration.cs
index 1b3ab140f..3a965739c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingAliasDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingAliasDeclaration.cs
@@ -101,8 +101,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UsingAliasDeclaration o = other as UsingAliasDeclaration;
-			return o != null && MatchString(this.Alias, o.Alias) && this.Import.DoMatch(o.Import, match);
+			return other is UsingAliasDeclaration o && MatchString(this.Alias, o.Alias) && this.Import.DoMatch(o.Import, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingDeclaration.cs
index d7246003c..bfc0be02f 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/GeneralScope/UsingDeclaration.cs
@@ -73,8 +73,8 @@ internal static string ConstructNamespace(AstType type)
 					stack.Push(".");
 				}
 			}
-			if (type is SimpleType)
-				stack.Push(((SimpleType)type).Identifier);
+			if (type is SimpleType simpleType)
+				stack.Push(simpleType.Identifier);
 
 			var result = new StringBuilder();
 			while (stack.Count > 0)
@@ -117,8 +117,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UsingDeclaration o = other as UsingDeclaration;
-			return o != null && this.Import.DoMatch(o.Import, match);
+			return other is UsingDeclaration o && this.Import.DoMatch(o.Import, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/IAnnotatable.cs b/ICSharpCode.Decompiler/CSharp/Syntax/IAnnotatable.cs
index a82a9d54f..0f128aa36 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/IAnnotatable.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/IAnnotatable.cs
@@ -101,8 +101,7 @@ public abstract class AbstractAnnotatable : IAnnotatable
 		/// </summary>
 		protected void CloneAnnotations()
 		{
-			ICloneable cloneable = annotations as ICloneable;
-			if (cloneable != null)
+			if (annotations is ICloneable cloneable)
 				annotations = cloneable.Clone();
 		}
 
@@ -168,8 +167,8 @@ public virtual void AddAnnotation(object annotation)
 		{
 			retry: // Retry until successful
 			object oldAnnotations = this.annotations;
-			AnnotationList list = oldAnnotations as AnnotationList;
-			if (list != null)
+
+			if (oldAnnotations is AnnotationList list)
 			{
 				lock (list)
 					list.RemoveAll(obj => obj is T);
@@ -190,8 +189,8 @@ public virtual void RemoveAnnotations(Type type)
 				throw new ArgumentNullException(nameof(type));
 			retry: // Retry until successful
 			object oldAnnotations = this.annotations;
-			AnnotationList list = oldAnnotations as AnnotationList;
-			if (list != null)
+
+			if (oldAnnotations is AnnotationList list)
 			{
 				lock (list)
 					list.RemoveAll(type.IsInstanceOfType);
@@ -209,15 +208,14 @@ public virtual void RemoveAnnotations(Type type)
 		public T Annotation<T>() where T : class
 		{
 			object annotations = this.annotations;
-			AnnotationList list = annotations as AnnotationList;
-			if (list != null)
+
+			if (annotations is AnnotationList list)
 			{
 				lock (list)
 				{
 					foreach (object obj in list)
 					{
-						T t = obj as T;
-						if (t != null)
+						if (obj is T t)
 							return t;
 					}
 					return null;
@@ -234,8 +232,8 @@ public object Annotation(Type type)
 			if (type == null)
 				throw new ArgumentNullException(nameof(type));
 			object annotations = this.annotations;
-			AnnotationList list = annotations as AnnotationList;
-			if (list != null)
+
+			if (annotations is AnnotationList list)
 			{
 				lock (list)
 				{
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Identifier.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Identifier.cs
index 726c939fb..a10b84c46 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Identifier.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Identifier.cs
@@ -166,8 +166,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			Identifier o = other as Identifier;
-			return o != null && !o.IsNull && MatchString(this.Name, o.Name);
+			return other is Identifier o && !o.IsNull && MatchString(this.Name, o.Name);
 		}
 	}
 }
\ No newline at end of file
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/MemberType.cs b/ICSharpCode.Decompiler/CSharp/Syntax/MemberType.cs
index 00abace78..3ddee29ee 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/MemberType.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/MemberType.cs
@@ -114,8 +114,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			MemberType o = other as MemberType;
-			return o != null && this.IsDoubleColon == o.IsDoubleColon
+			return other is MemberType o && this.IsDoubleColon == o.IsDoubleColon
 				&& MatchString(this.MemberName, o.MemberName) && this.Target.DoMatch(o.Target, match)
 				&& this.TypeArguments.DoMatch(o.TypeArguments, match);
 		}
@@ -128,8 +127,7 @@ public override ITypeReference ToTypeReference(NameLookupMode lookupMode, Intern
 			TypeOrNamespaceReference t;
 			if (this.IsDoubleColon)
 			{
-				SimpleType st = this.Target as SimpleType;
-				if (st != null)
+				if (this.Target is SimpleType st)
 				{
 					t = interningProvider.Intern(new AliasNamespaceReference(interningProvider.Intern(st.Identifier)));
 				}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/PrimitiveType.cs b/ICSharpCode.Decompiler/CSharp/Syntax/PrimitiveType.cs
index a6f112542..5faae6f8e 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/PrimitiveType.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/PrimitiveType.cs
@@ -102,8 +102,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			PrimitiveType o = other as PrimitiveType;
-			return o != null && MatchString(this.Keyword, o.Keyword);
+			return other is PrimitiveType o && MatchString(this.Keyword, o.Keyword);
 		}
 
 		public override string ToString(CSharpFormattingOptions formattingOptions)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/SimpleType.cs b/ICSharpCode.Decompiler/CSharp/Syntax/SimpleType.cs
index 17a19e345..62c419837 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/SimpleType.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/SimpleType.cs
@@ -143,8 +143,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SimpleType o = other as SimpleType;
-			return o != null && MatchString(this.Identifier, o.Identifier) && this.TypeArguments.DoMatch(o.TypeArguments, match);
+			return other is SimpleType o && MatchString(this.Identifier, o.Identifier) && this.TypeArguments.DoMatch(o.TypeArguments, match);
 		}
 
 		public override ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider = null)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BlockStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BlockStatement.cs
index 9965c7af9..d1ce4e445 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BlockStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BlockStatement.cs
@@ -142,8 +142,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			BlockStatement o = other as BlockStatement;
-			return o != null && !o.IsNull && this.Statements.DoMatch(o.Statements, match);
+			return other is BlockStatement o && !o.IsNull && this.Statements.DoMatch(o.Statements, match);
 		}
 
 		public void Add(Statement statement)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BreakStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BreakStatement.cs
index df8732e81..65871b138 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BreakStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/BreakStatement.cs
@@ -59,8 +59,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			BreakStatement o = other as BreakStatement;
-			return o != null;
+			return other is BreakStatement o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/CheckedStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/CheckedStatement.cs
index c701dcfc5..386b24882 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/CheckedStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/CheckedStatement.cs
@@ -69,8 +69,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CheckedStatement o = other as CheckedStatement;
-			return o != null && this.Body.DoMatch(o.Body, match);
+			return other is CheckedStatement o && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ContinueStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ContinueStatement.cs
index a4b8abacf..72cb17152 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ContinueStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ContinueStatement.cs
@@ -59,8 +59,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ContinueStatement o = other as ContinueStatement;
-			return o != null;
+			return other is ContinueStatement o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/DoWhileStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/DoWhileStatement.cs
index ce05ff6b6..8d7253356 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/DoWhileStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/DoWhileStatement.cs
@@ -82,8 +82,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			DoWhileStatement o = other as DoWhileStatement;
-			return o != null && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match) && this.Condition.DoMatch(o.Condition, match);
+			return other is DoWhileStatement o && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match) && this.Condition.DoMatch(o.Condition, match);
 		}
 
 		public DoWhileStatement()
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/EmptyStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/EmptyStatement.cs
index c76016963..9fc26510c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/EmptyStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/EmptyStatement.cs
@@ -66,8 +66,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			EmptyStatement o = other as EmptyStatement;
-			return o != null;
+			return other is EmptyStatement o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ExpressionStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ExpressionStatement.cs
index 5a4f2a413..c34acc7fe 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ExpressionStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ExpressionStatement.cs
@@ -67,8 +67,7 @@ public ExpressionStatement(Expression expression)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ExpressionStatement o = other as ExpressionStatement;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is ExpressionStatement o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/FixedStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/FixedStatement.cs
index 3b34ea2fb..253573a73 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/FixedStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/FixedStatement.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			FixedStatement o = other as FixedStatement;
-			return o != null && this.Type.DoMatch(o.Type, match) && this.Variables.DoMatch(o.Variables, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
+			return other is FixedStatement o && this.Type.DoMatch(o.Type, match) && this.Variables.DoMatch(o.Variables, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForStatement.cs
index 91784f0d4..47938c033 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForStatement.cs
@@ -88,8 +88,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ForStatement o = other as ForStatement;
-			return o != null && this.Initializers.DoMatch(o.Initializers, match) && this.Condition.DoMatch(o.Condition, match)
+			return other is ForStatement o && this.Initializers.DoMatch(o.Initializers, match) && this.Condition.DoMatch(o.Condition, match)
 				&& this.Iterators.DoMatch(o.Iterators, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForeachStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForeachStatement.cs
index a01bc05de..f55f4c85c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForeachStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ForeachStatement.cs
@@ -98,8 +98,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ForeachStatement o = other as ForeachStatement;
-			return o != null && this.VariableType.DoMatch(o.VariableType, match) && this.VariableDesignation.DoMatch(o.VariableDesignation, match)
+			return other is ForeachStatement o && this.VariableType.DoMatch(o.VariableType, match) && this.VariableDesignation.DoMatch(o.VariableDesignation, match)
 				&& this.InExpression.DoMatch(o.InExpression, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/GotoStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/GotoStatement.cs
index b1b064c01..8a7d0ce4e 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/GotoStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/GotoStatement.cs
@@ -80,8 +80,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			GotoStatement o = other as GotoStatement;
-			return o != null && MatchString(this.Label, o.Label);
+			return other is GotoStatement o && MatchString(this.Label, o.Label);
 		}
 	}
 
@@ -130,8 +129,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			GotoCaseStatement o = other as GotoCaseStatement;
-			return o != null && this.LabelExpression.DoMatch(o.LabelExpression, match);
+			return other is GotoCaseStatement o && this.LabelExpression.DoMatch(o.LabelExpression, match);
 		}
 	}
 
@@ -172,8 +170,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			GotoDefaultStatement o = other as GotoDefaultStatement;
-			return o != null;
+			return other is GotoDefaultStatement o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/IfElseStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/IfElseStatement.cs
index fece09f10..7950ff04c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/IfElseStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/IfElseStatement.cs
@@ -86,8 +86,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			IfElseStatement o = other as IfElseStatement;
-			return o != null && this.Condition.DoMatch(o.Condition, match) && this.TrueStatement.DoMatch(o.TrueStatement, match) && this.FalseStatement.DoMatch(o.FalseStatement, match);
+			return other is IfElseStatement o && this.Condition.DoMatch(o.Condition, match) && this.TrueStatement.DoMatch(o.TrueStatement, match) && this.FalseStatement.DoMatch(o.FalseStatement, match);
 		}
 
 		public IfElseStatement()
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LabelStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LabelStatement.cs
index ca56ec478..c322b4e42 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LabelStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LabelStatement.cs
@@ -67,8 +67,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			LabelStatement o = other as LabelStatement;
-			return o != null && MatchString(this.Label, o.Label);
+			return other is LabelStatement o && MatchString(this.Label, o.Label);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LockStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LockStatement.cs
index a8f25c579..f63fbac03 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LockStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/LockStatement.cs
@@ -73,8 +73,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			LockStatement o = other as LockStatement;
-			return o != null && this.Expression.DoMatch(o.Expression, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
+			return other is LockStatement o && this.Expression.DoMatch(o.Expression, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ReturnStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ReturnStatement.cs
index 75b96f4fe..8fe585e8c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ReturnStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ReturnStatement.cs
@@ -73,8 +73,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ReturnStatement o = other as ReturnStatement;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is ReturnStatement o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/SwitchStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/SwitchStatement.cs
index c6f3c5745..ac3be1045 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/SwitchStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/SwitchStatement.cs
@@ -81,8 +81,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SwitchStatement o = other as SwitchStatement;
-			return o != null && this.Expression.DoMatch(o.Expression, match) && this.SwitchSections.DoMatch(o.SwitchSections, match);
+			return other is SwitchStatement o && this.Expression.DoMatch(o.Expression, match) && this.SwitchSections.DoMatch(o.SwitchSections, match);
 		}
 	}
 
@@ -167,8 +166,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SwitchSection o = other as SwitchSection;
-			return o != null && this.CaseLabels.DoMatch(o.CaseLabels, match) && this.Statements.DoMatch(o.Statements, match);
+			return other is SwitchSection o && this.CaseLabels.DoMatch(o.CaseLabels, match) && this.Statements.DoMatch(o.Statements, match);
 		}
 	}
 
@@ -221,8 +219,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CaseLabel o = other as CaseLabel;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is CaseLabel o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ThrowStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ThrowStatement.cs
index a16d67a34..f0af3a5c2 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ThrowStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/ThrowStatement.cs
@@ -73,8 +73,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ThrowStatement o = other as ThrowStatement;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is ThrowStatement o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/TryCatchStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/TryCatchStatement.cs
index f3ad325bc..f07ffef23 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/TryCatchStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/TryCatchStatement.cs
@@ -77,8 +77,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			TryCatchStatement o = other as TryCatchStatement;
-			return o != null && this.TryBlock.DoMatch(o.TryBlock, match) && this.CatchClauses.DoMatch(o.CatchClauses, match) && this.FinallyBlock.DoMatch(o.FinallyBlock, match);
+			return other is TryCatchStatement o && this.TryBlock.DoMatch(o.TryBlock, match) && this.CatchClauses.DoMatch(o.CatchClauses, match) && this.FinallyBlock.DoMatch(o.FinallyBlock, match);
 		}
 	}
 
@@ -253,8 +252,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CatchClause o = other as CatchClause;
-			return o != null && this.Type.DoMatch(o.Type, match) && MatchString(this.VariableName, o.VariableName) && this.Body.DoMatch(o.Body, match);
+			return other is CatchClause o && this.Type.DoMatch(o.Type, match) && MatchString(this.VariableName, o.VariableName) && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UncheckedStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UncheckedStatement.cs
index f24f7213e..e4b0802dc 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UncheckedStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UncheckedStatement.cs
@@ -69,8 +69,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UncheckedStatement o = other as UncheckedStatement;
-			return o != null && this.Body.DoMatch(o.Body, match);
+			return other is UncheckedStatement o && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UnsafeStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UnsafeStatement.cs
index 1a977d5b9..234dccb33 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UnsafeStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UnsafeStatement.cs
@@ -60,8 +60,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UnsafeStatement o = other as UnsafeStatement;
-			return o != null && this.Body.DoMatch(o.Body, match);
+			return other is UnsafeStatement o && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UsingStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UsingStatement.cs
index 33bf9d839..2f307da41 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UsingStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/UsingStatement.cs
@@ -89,8 +89,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			UsingStatement o = other as UsingStatement;
-			return o != null && this.IsAsync == o.IsAsync && this.ResourceAcquisition.DoMatch(o.ResourceAcquisition, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
+			return other is UsingStatement o && this.IsAsync == o.IsAsync && this.ResourceAcquisition.DoMatch(o.ResourceAcquisition, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/VariableDeclarationStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/VariableDeclarationStatement.cs
index 1a6066f17..673a958b1 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/VariableDeclarationStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/VariableDeclarationStatement.cs
@@ -81,8 +81,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			VariableDeclarationStatement o = other as VariableDeclarationStatement;
-			return o != null && this.Modifiers == o.Modifiers && this.Type.DoMatch(o.Type, match) && this.Variables.DoMatch(o.Variables, match);
+			return other is VariableDeclarationStatement o && this.Modifiers == o.Modifiers && this.Type.DoMatch(o.Type, match) && this.Variables.DoMatch(o.Variables, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/WhileStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/WhileStatement.cs
index 3e852e35d..9f940901a 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/WhileStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/WhileStatement.cs
@@ -73,8 +73,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			WhileStatement o = other as WhileStatement;
-			return o != null && this.Condition.DoMatch(o.Condition, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
+			return other is WhileStatement o && this.Condition.DoMatch(o.Condition, match) && this.EmbeddedStatement.DoMatch(o.EmbeddedStatement, match);
 		}
 
 		public WhileStatement()
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldBreakStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldBreakStatement.cs
index 4a777afa9..f7f7c0bf7 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldBreakStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldBreakStatement.cs
@@ -64,8 +64,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			YieldBreakStatement o = other as YieldBreakStatement;
-			return o != null;
+			return other is YieldBreakStatement o;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldReturnStatement.cs b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldReturnStatement.cs
index 235201ab2..534bedfba 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldReturnStatement.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/Statements/YieldReturnStatement.cs
@@ -69,8 +69,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			YieldReturnStatement o = other as YieldReturnStatement;
-			return o != null && this.Expression.DoMatch(o.Expression, match);
+			return other is YieldReturnStatement o && this.Expression.DoMatch(o.Expression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxExtensions.cs b/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxExtensions.cs
index 8d6cc4bc6..1b711e892 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxExtensions.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxExtensions.cs
@@ -62,8 +62,7 @@ public static Statement GetNextStatement(this Statement statement)
 
 		public static bool IsArgList(this AstType type)
 		{
-			var simpleType = type as SimpleType;
-			return simpleType != null && simpleType.Identifier == "__arglist";
+			return type is SimpleType simpleType && simpleType.Identifier == "__arglist";
 		}
 
 		public static void AddNamedArgument(this Syntax.Attribute attribute, string name, Expression argument)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxTree.cs b/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxTree.cs
index 92e3bb63d..544ad1691 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxTree.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/SyntaxTree.cs
@@ -119,8 +119,7 @@ public IEnumerable<EntityDeclaration> GetTypes(bool includeInnerTypes = false)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			SyntaxTree o = other as SyntaxTree;
-			return o != null && this.Members.DoMatch(o.Members, match);
+			return other is SyntaxTree o && this.Members.DoMatch(o.Members, match);
 		}
 
 		public override void AcceptVisitor(IAstVisitor visitor)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TextLocation.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TextLocation.cs
index 487a9cc1c..76ad2751b 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TextLocation.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TextLocation.cs
@@ -199,9 +199,9 @@ public override bool CanConvertTo(ITypeDescriptorContext context, Type destinati
 
 		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
 		{
-			if (value is string)
+			if (value is string s)
 			{
-				string[] parts = ((string)value).Split(';', ',');
+				string[] parts = s.Split(';', ',');
 				if (parts.Length == 2)
 				{
 					return new TextLocation(int.Parse(parts[0]), int.Parse(parts[1]));
@@ -212,9 +212,8 @@ public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo c
 
 		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
 		{
-			if (value is TextLocation)
+			if (value is TextLocation loc)
 			{
-				var loc = (TextLocation)value;
 				return loc.Line + ";" + loc.Column;
 			}
 			return base.ConvertTo(context, culture, value, destinationType);
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/Accessor.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/Accessor.cs
index def135ba9..20cc685cc 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/Accessor.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/Accessor.cs
@@ -111,8 +111,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			Accessor o = other as Accessor;
-			return o != null && !o.IsNull && this.MatchAttributesAndModifiers(o, match) && this.Body.DoMatch(o.Body, match);
+			return other is Accessor o && !o.IsNull && this.MatchAttributesAndModifiers(o, match) && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ConstructorDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ConstructorDeclaration.cs
index 890b77088..5de83d6da 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ConstructorDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ConstructorDeclaration.cs
@@ -79,8 +79,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ConstructorDeclaration o = other as ConstructorDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match) && this.Parameters.DoMatch(o.Parameters, match)
+			return other is ConstructorDeclaration o && this.MatchAttributesAndModifiers(o, match) && this.Parameters.DoMatch(o.Parameters, match)
 				&& this.Initializer.DoMatch(o.Initializer, match) && this.Body.DoMatch(o.Body, match);
 		}
 	}
@@ -182,8 +181,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ConstructorInitializer o = other as ConstructorInitializer;
-			return o != null && !o.IsNull
+			return other is ConstructorInitializer o && !o.IsNull
 				&& (this.ConstructorInitializerType == ConstructorInitializerType.Any || this.ConstructorInitializerType == o.ConstructorInitializerType)
 				&& this.Arguments.DoMatch(o.Arguments, match);
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/DestructorDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/DestructorDeclaration.cs
index 5039831ee..a86506282 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/DestructorDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/DestructorDeclaration.cs
@@ -69,8 +69,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			DestructorDeclaration o = other as DestructorDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match) && this.Body.DoMatch(o.Body, match);
+			return other is DestructorDeclaration o && this.MatchAttributesAndModifiers(o, match) && this.Body.DoMatch(o.Body, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EnumMemberDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EnumMemberDeclaration.cs
index cbf983454..6ff2845e5 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EnumMemberDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EnumMemberDeclaration.cs
@@ -62,8 +62,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			EnumMemberDeclaration o = other as EnumMemberDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match)
+			return other is EnumMemberDeclaration o && this.MatchAttributesAndModifiers(o, match)
 				&& MatchString(this.Name, o.Name) && this.Initializer.DoMatch(o.Initializer, match);
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EventDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EventDeclaration.cs
index 1abb7c739..7e673669c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EventDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/EventDeclaration.cs
@@ -78,8 +78,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			EventDeclaration o = other as EventDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match)
+			return other is EventDeclaration o && this.MatchAttributesAndModifiers(o, match)
 				&& this.ReturnType.DoMatch(o.ReturnType, match) && this.Variables.DoMatch(o.Variables, match);
 		}
 	}
@@ -141,8 +140,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			CustomEventDeclaration o = other as CustomEventDeclaration;
-			return o != null && MatchString(this.Name, o.Name)
+			return other is CustomEventDeclaration o && MatchString(this.Name, o.Name)
 				&& this.MatchAttributesAndModifiers(o, match) && this.ReturnType.DoMatch(o.ReturnType, match)
 				&& this.PrivateImplementationType.DoMatch(o.PrivateImplementationType, match)
 				&& this.AddAccessor.DoMatch(o.AddAccessor, match) && this.RemoveAccessor.DoMatch(o.RemoveAccessor, match);
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FieldDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FieldDeclaration.cs
index 548b0333e..ab3f1bbcf 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FieldDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FieldDeclaration.cs
@@ -72,8 +72,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			FieldDeclaration o = other as FieldDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match)
+			return other is FieldDeclaration o && this.MatchAttributesAndModifiers(o, match)
 				&& this.ReturnType.DoMatch(o.ReturnType, match) && this.Variables.DoMatch(o.Variables, match);
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedFieldDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedFieldDeclaration.cs
index 32e8a7512..621f87a21 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedFieldDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedFieldDeclaration.cs
@@ -61,8 +61,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as FixedFieldDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match)
+			return other is FixedFieldDeclaration o && this.MatchAttributesAndModifiers(o, match)
 				&& this.ReturnType.DoMatch(o.ReturnType, match) && this.Variables.DoMatch(o.Variables, match);
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedVariableInitializer.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedVariableInitializer.cs
index 56c602300..bb516b18d 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedVariableInitializer.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/FixedVariableInitializer.cs
@@ -96,8 +96,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			var o = other as FixedVariableInitializer;
-			return o != null && MatchString(this.Name, o.Name) && this.CountExpression.DoMatch(o.CountExpression, match);
+			return other is FixedVariableInitializer o && MatchString(this.Name, o.Name) && this.CountExpression.DoMatch(o.CountExpression, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/IndexerDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/IndexerDeclaration.cs
index bad5ce81b..50feeb50b 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/IndexerDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/IndexerDeclaration.cs
@@ -118,8 +118,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			IndexerDeclaration o = other as IndexerDeclaration;
-			return o != null
+			return other is IndexerDeclaration o
 				&& this.MatchAttributesAndModifiers(o, match) && this.ReturnType.DoMatch(o.ReturnType, match)
 				&& this.PrivateImplementationType.DoMatch(o.PrivateImplementationType, match)
 				&& this.Parameters.DoMatch(o.Parameters, match)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/MethodDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/MethodDeclaration.cs
index d01822868..b0a11fe3b 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/MethodDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/MethodDeclaration.cs
@@ -92,8 +92,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			MethodDeclaration o = other as MethodDeclaration;
-			return o != null && MatchString(this.Name, o.Name)
+			return other is MethodDeclaration o && MatchString(this.Name, o.Name)
 				&& this.MatchAttributesAndModifiers(o, match) && this.ReturnType.DoMatch(o.ReturnType, match)
 				&& this.PrivateImplementationType.DoMatch(o.PrivateImplementationType, match)
 				&& this.TypeParameters.DoMatch(o.TypeParameters, match)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/OperatorDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/OperatorDeclaration.cs
index c0f8236b8..48d106c94 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/OperatorDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/OperatorDeclaration.cs
@@ -299,8 +299,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			OperatorDeclaration o = other as OperatorDeclaration;
-			return o != null && this.MatchAttributesAndModifiers(o, match) && this.OperatorType == o.OperatorType
+			return other is OperatorDeclaration o && this.MatchAttributesAndModifiers(o, match) && this.OperatorType == o.OperatorType
 				&& this.ReturnType.DoMatch(o.ReturnType, match)
 				&& this.Parameters.DoMatch(o.Parameters, match) && this.Body.DoMatch(o.Body, match);
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ParameterDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ParameterDeclaration.cs
index e2c4e9ffc..9780f492c 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ParameterDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/ParameterDeclaration.cs
@@ -180,8 +180,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			ParameterDeclaration o = other as ParameterDeclaration;
-			return o != null && this.Attributes.DoMatch(o.Attributes, match) && this.ParameterModifier == o.ParameterModifier
+			return other is ParameterDeclaration o && this.Attributes.DoMatch(o.Attributes, match) && this.ParameterModifier == o.ParameterModifier
 				&& this.Type.DoMatch(o.Type, match) && MatchString(this.Name, o.Name)
 				&& this.DefaultExpression.DoMatch(o.DefaultExpression, match);
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/PropertyDeclaration.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/PropertyDeclaration.cs
index f7fd87434..2731a9338 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/PropertyDeclaration.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/PropertyDeclaration.cs
@@ -99,8 +99,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			PropertyDeclaration o = other as PropertyDeclaration;
-			return o != null && MatchString(this.Name, o.Name)
+			return other is PropertyDeclaration o && MatchString(this.Name, o.Name)
 				&& this.MatchAttributesAndModifiers(o, match) && this.ReturnType.DoMatch(o.ReturnType, match)
 				&& this.PrivateImplementationType.DoMatch(o.PrivateImplementationType, match)
 				&& this.Getter.DoMatch(o.Getter, match) && this.Setter.DoMatch(o.Setter, match)
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/VariableInitializer.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/VariableInitializer.cs
index d5b74faa8..aa99ccc60 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/VariableInitializer.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeMembers/VariableInitializer.cs
@@ -168,8 +168,7 @@ public override T AcceptVisitor<T>(IAstVisitor<T> visitor)
 
 		protected internal override bool DoMatch(AstNode other, PatternMatching.Match match)
 		{
-			VariableInitializer o = other as VariableInitializer;
-			return o != null && MatchString(this.Name, o.Name) && this.Initializer.DoMatch(o.Initializer, match);
+			return other is VariableInitializer o && MatchString(this.Name, o.Name) && this.Initializer.DoMatch(o.Initializer, match);
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/Syntax/TypeSystemAstBuilder.cs b/ICSharpCode.Decompiler/CSharp/Syntax/TypeSystemAstBuilder.cs
index f0c33adcc..fdaa722b4 100644
--- a/ICSharpCode.Decompiler/CSharp/Syntax/TypeSystemAstBuilder.cs
+++ b/ICSharpCode.Decompiler/CSharp/Syntax/TypeSystemAstBuilder.cs
@@ -495,8 +495,8 @@ AstType ConvertTypeHelper(IType genericType, IReadOnlyList<IType> typeArguments)
 					localTypeArguments = Empty<IType>.Array;
 				}
 				ResolveResult rr = resolver.LookupSimpleNameOrTypeName(typeDef.Name, localTypeArguments, NameLookupMode);
-				TypeResolveResult trr = rr as TypeResolveResult;
-				if (trr != null || (localTypeArguments.Length == 0 && resolver.IsVariableReferenceWithSameType(rr, typeDef.Name, out trr)))
+
+				if (rr is TypeResolveResult trr || (localTypeArguments.Length == 0 && resolver.IsVariableReferenceWithSameType(rr, typeDef.Name, out trr)))
 				{
 					if (!trr.IsError && TypeMatches(trr.Type, typeDef, typeArguments))
 					{
@@ -909,9 +909,9 @@ public Expression ConvertConstantValue(ResolveResult rr)
 				isBoxing = crr.Conversion.IsBoxingConversion;
 			}
 
-			if (rr is TypeOfResolveResult)
+			if (rr is TypeOfResolveResult typeOfResolveResult)
 			{
-				var expr = new TypeOfExpression(ConvertType(((TypeOfResolveResult)rr).ReferencedType));
+				var expr = new TypeOfExpression(ConvertType(typeOfResolveResult.ReferencedType));
 				if (AddResolveResultAnnotations)
 					expr.AddAnnotation(rr);
 				return expr;
@@ -1668,8 +1668,8 @@ public AstNode ConvertSymbol(ISymbol symbol)
 				case SymbolKind.TypeParameter:
 					return ConvertTypeParameter((ITypeParameter)symbol);
 				default:
-					IEntity entity = symbol as IEntity;
-					if (entity != null)
+
+					if (symbol is IEntity entity)
 						return ConvertEntity(entity);
 					throw new ArgumentException("Invalid value for SymbolKind: " + symbol.SymbolKind);
 			}
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/AddCheckedBlocks.cs b/ICSharpCode.Decompiler/CSharp/Transforms/AddCheckedBlocks.cs
index 4070a4988..ce66a9813 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/AddCheckedBlocks.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/AddCheckedBlocks.cs
@@ -108,7 +108,7 @@ public Cost(int blocks, int expressions)
 
 			public override string ToString()
 			{
-				return string.Format("[{0} + {1}]", Blocks, Expressions);
+				return $"[{Blocks} + {Expressions}]";
 			}
 
 			/// <summary>
@@ -332,8 +332,8 @@ Result GetResultFromBlock(BlockStatement block)
 
 		Result GetResult(AstNode node)
 		{
-			if (node is BlockStatement)
-				return GetResultFromBlock((BlockStatement)node);
+			if (node is BlockStatement blockStatement)
+				return GetResultFromBlock(blockStatement);
 			Result result = new Result();
 			for (AstNode child = node.FirstChild; child != null; child = child.NextSibling)
 			{
@@ -343,8 +343,8 @@ Result GetResult(AstNode node)
 				result.CostInUncheckedContext += childResult.CostInUncheckedContext;
 				result.NodesToInsertInUncheckedContext += childResult.NodesToInsertInUncheckedContext;
 			}
-			Expression expr = node as Expression;
-			if (expr != null)
+
+			if (node is Expression expr)
 			{
 				CheckedUncheckedAnnotation annotation = expr.Annotation<CheckedUncheckedAnnotation>();
 				if (annotation != null)
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/CombineQueryExpressions.cs b/ICSharpCode.Decompiler/CSharp/Transforms/CombineQueryExpressions.cs
index b0f53dd74..b645d7947 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/CombineQueryExpressions.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/CombineQueryExpressions.cs
@@ -54,12 +54,11 @@ void CombineQueries(AstNode node, Dictionary<string, object> fromOrLetIdentifier
 				next = child.NextSibling;
 				CombineQueries(child, fromOrLetIdentifiers);
 			}
-			QueryExpression query = node as QueryExpression;
-			if (query != null)
+
+			if (node is QueryExpression query)
 			{
 				QueryFromClause fromClause = (QueryFromClause)query.Clauses.First();
-				QueryExpression innerQuery = fromClause.Expression as QueryExpression;
-				if (innerQuery != null)
+				if (fromClause.Expression is QueryExpression innerQuery)
 				{
 					if (TryRemoveTransparentIdentifier(query, fromClause, innerQuery, fromOrLetIdentifiers))
 					{
@@ -170,11 +169,10 @@ void RemoveTransparentIdentifierReferences(AstNode node, Dictionary<string, obje
 			{
 				RemoveTransparentIdentifierReferences(child, fromOrLetIdentifiers);
 			}
-			MemberReferenceExpression mre = node as MemberReferenceExpression;
-			if (mre != null)
+
+			if (node is MemberReferenceExpression mre)
 			{
-				IdentifierExpression ident = mre.Target as IdentifierExpression;
-				if (ident != null && IsTransparentIdentifier(ident.Identifier))
+				if (mre.Target is IdentifierExpression ident && IsTransparentIdentifier(ident.Identifier))
 				{
 					IdentifierExpression newIdent = new IdentifierExpression(mre.MemberName);
 					mre.TypeArguments.MoveTo(newIdent.TypeArguments);
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/CustomPatterns.cs b/ICSharpCode.Decompiler/CSharp/Transforms/CustomPatterns.cs
index 0926035ed..bec6991da 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/CustomPatterns.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/CustomPatterns.cs
@@ -38,9 +38,8 @@ public TypePattern(Type type)
 
 		public override bool DoMatch(INode other, Match match)
 		{
-			ComposedType ct = other as ComposedType;
 			AstType o;
-			if (ct != null && !ct.HasRefSpecifier && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any())
+			if (other is ComposedType ct && !ct.HasRefSpecifier && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any())
 			{
 				// Special case: ILSpy sometimes produces a ComposedType but then removed all array specifiers
 				// from it. In that case, we need to look at the base type for the annotations.
@@ -52,8 +51,7 @@ public override bool DoMatch(INode other, Match match)
 				if (o == null)
 					return false;
 			}
-			var trr = o.GetResolveResult() as TypeResolveResult;
-			return trr != null && trr.Type.Namespace == ns && trr.Type.Name == name;
+			return o.GetResolveResult() is TypeResolveResult trr && trr.Type.Namespace == ns && trr.Type.Name == name;
 		}
 
 		public override string ToString()
@@ -73,8 +71,7 @@ public LdTokenPattern(string groupName)
 
 		public override bool DoMatch(INode other, Match match)
 		{
-			InvocationExpression ie = other as InvocationExpression;
-			if (ie != null && ie.Annotation<LdTokenAnnotation>() != null && ie.Arguments.Count == 1)
+			if (other is InvocationExpression ie && ie.Annotation<LdTokenAnnotation>() != null && ie.Arguments.Count == 1)
 			{
 				return childNode.DoMatch(ie.Arguments.Single(), match);
 			}
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/DecimalConstantTransform.cs b/ICSharpCode.Decompiler/CSharp/Transforms/DecimalConstantTransform.cs
index ea9d78ff9..b1c3cacaf 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/DecimalConstantTransform.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/DecimalConstantTransform.cs
@@ -38,8 +38,7 @@ public override void VisitFieldDeclaration(FieldDeclaration fieldDeclaration)
 				{
 					foreach (var attribute in attributeSection.Attributes)
 					{
-						var t = attribute.Type.GetSymbol() as IType;
-						if (t != null && t.Name == "DecimalConstantAttribute" && t.Namespace == "System.Runtime.CompilerServices")
+						if (attribute.Type.GetSymbol() is IType t && t.Name == "DecimalConstantAttribute" && t.Namespace == "System.Runtime.CompilerServices")
 						{
 							attribute.Remove();
 							if (attributeSection.Attributes.Count == 0)
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/DeclareVariables.cs b/ICSharpCode.Decompiler/CSharp/Transforms/DeclareVariables.cs
index 5964caf42..e415e81e5 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/DeclareVariables.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/DeclareVariables.cs
@@ -204,7 +204,7 @@ void EnsureExpressionStatementsAreValid(AstNode rootNode)
 							type,
 							AssignVariableNames.GenerateVariableName(function, type,
 								stmt.Expression.Annotations.OfType<ILInstruction>()
-									.Where(AssignVariableNames.IsSupportedInstruction).FirstOrDefault(),
+									.FirstOrDefault(AssignVariableNames.IsSupportedInstruction),
 								mustResolveConflicts: true)
 						);
 						stmt.Expression = new AssignmentExpression(
@@ -277,8 +277,7 @@ void FindInsertionPoints(AstNode node, int nodeLevel)
 				}
 				if (node is IdentifierExpression identExpr)
 				{
-					var rr = identExpr.GetResolveResult() as ILVariableResolveResult;
-					if (rr != null && VariableNeedsDeclaration(rr.Variable.Kind))
+					if (identExpr.GetResolveResult() is ILVariableResolveResult rr && VariableNeedsDeclaration(rr.Variable.Kind))
 					{
 						FindInsertionPointForVariable(rr.Variable);
 					}
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/EscapeInvalidIdentifiers.cs b/ICSharpCode.Decompiler/CSharp/Transforms/EscapeInvalidIdentifiers.cs
index 6ba6b2e8e..8204886ea 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/EscapeInvalidIdentifiers.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/EscapeInvalidIdentifiers.cs
@@ -42,7 +42,7 @@ bool IsValid(char ch)
 
 		string ReplaceInvalid(string s)
 		{
-			string name = string.Concat(s.Select(ch => IsValid(ch) ? ch.ToString() : string.Format("_{0:X4}", (int)ch)));
+			string name = string.Concat(s.Select(ch => IsValid(ch) ? ch.ToString() : $"_{(int)ch:X4}"));
 			if (name.Length >= 1 && !(char.IsLetter(name[0]) || name[0] == '_'))
 				name = "_" + name;
 			return name;
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceQueryExpressions.cs b/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceQueryExpressions.cs
index 8725944da..5588886a5 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceQueryExpressions.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceQueryExpressions.cs
@@ -170,8 +170,7 @@ QueryExpression DecompileQuery(InvocationExpression invocation)
 						return null;
 					if (IsNullConditional(collectionSelector))
 						return null;
-					LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;
-					if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression)
+					if (invocation.Arguments.ElementAt(1) is LambdaExpression lambda && lambda.Parameters.Count == 2 && lambda.Body is Expression)
 					{
 						ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);
 						ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);
@@ -261,8 +260,7 @@ QueryExpression DecompileQuery(InvocationExpression invocation)
 					Expression innerLambda = invocation.Arguments.ElementAt(2);
 					if (!MatchSimpleLambda(innerLambda, out ParameterDeclaration element2, out Expression key2))
 						return null;
-					LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;
-					if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression)
+					if (invocation.Arguments.ElementAt(1) is LambdaExpression lambda && lambda.Parameters.Count == 2 && lambda.Body is Expression)
 					{
 						ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);
 						ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceUnsafeModifier.cs b/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceUnsafeModifier.cs
index d814221f2..b7cf5cbe0 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceUnsafeModifier.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/IntroduceUnsafeModifier.cs
@@ -87,8 +87,7 @@ public override bool VisitUnaryOperatorExpression(UnaryOperatorExpression unaryO
 			bool result = base.VisitUnaryOperatorExpression(unaryOperatorExpression);
 			if (unaryOperatorExpression.Operator == UnaryOperatorType.Dereference)
 			{
-				var bop = unaryOperatorExpression.Expression as BinaryOperatorExpression;
-				if (bop != null && bop.Operator == BinaryOperatorType.Add
+				if (unaryOperatorExpression.Expression is BinaryOperatorExpression bop && bop.Operator == BinaryOperatorType.Add
 					&& bop.GetResolveResult() is OperatorResolveResult orr
 					&& orr.Operands.FirstOrDefault()?.Type.Kind == TypeKind.Pointer)
 				{
@@ -115,8 +114,8 @@ public override bool VisitUnaryOperatorExpression(UnaryOperatorExpression unaryO
 		public override bool VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression)
 		{
 			bool result = base.VisitMemberReferenceExpression(memberReferenceExpression);
-			UnaryOperatorExpression uoe = memberReferenceExpression.Target as UnaryOperatorExpression;
-			if (uoe != null && uoe.Operator == UnaryOperatorType.Dereference)
+
+			if (memberReferenceExpression.Target is UnaryOperatorExpression uoe && uoe.Operator == UnaryOperatorType.Dereference)
 			{
 				PointerReferenceExpression pre = new PointerReferenceExpression();
 				pre.Target = uoe.Expression.Detach();
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/PatternStatementTransform.cs b/ICSharpCode.Decompiler/CSharp/Transforms/PatternStatementTransform.cs
index f4a3a040e..ec485cccc 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/PatternStatementTransform.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/PatternStatementTransform.cs
@@ -664,8 +664,7 @@ void RemoveCompilerGeneratedAttribute(AstNodeCollection<AttributeSection> attrib
 			{
 				foreach (var attr in section.Attributes)
 				{
-					var tr = attr.Type.GetSymbol() as IType;
-					if (tr != null && attributesToRemove.Contains(tr.FullName))
+					if (attr.Type.GetSymbol() is IType tr && attributesToRemove.Contains(tr.FullName))
 					{
 						attr.Remove();
 					}
@@ -735,8 +734,7 @@ Identifier ReplaceBackingFieldUsage(Identifier identifier)
 			{
 				var parent = identifier.Parent;
 				var mrr = parent.Annotation<MemberResolveResult>();
-				var field = mrr?.Member as IField;
-				if (field != null && IsBackingFieldOfAutomaticProperty(field, out var property)
+				if (mrr?.Member is IField field && IsBackingFieldOfAutomaticProperty(field, out var property)
 					&& CanTransformToAutomaticProperty(property) && currentMethod.AccessorOwner != property)
 				{
 					if (!property.CanSet && !context.Settings.GetterOnlyAutomaticProperties)
@@ -1143,9 +1141,9 @@ public override AstNode VisitBinaryOperatorExpression(BinaryOperatorExpression e
 			{
 				case BinaryOperatorType.ConditionalAnd:
 				case BinaryOperatorType.ConditionalOr:
+
 					// a && (b && c) ==> (a && b) && c
-					var bAndC = expr.Right as BinaryOperatorExpression;
-					if (bAndC != null && bAndC.Operator == expr.Operator)
+					if (expr.Right is BinaryOperatorExpression bAndC && bAndC.Operator == expr.Operator)
 					{
 						// make bAndC the parent and expr the child
 						var b = bAndC.Left.Detach();
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/PrettifyAssignments.cs b/ICSharpCode.Decompiler/CSharp/Transforms/PrettifyAssignments.cs
index d2ae9b2d5..ad16700e1 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/PrettifyAssignments.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/PrettifyAssignments.cs
@@ -43,9 +43,9 @@ class PrettifyAssignments : DepthFirstAstVisitor, IAstTransform
 		public override void VisitAssignmentExpression(AssignmentExpression assignment)
 		{
 			base.VisitAssignmentExpression(assignment);
+
 			// Combine "x = x op y" into "x op= y"
-			BinaryOperatorExpression binary = assignment.Right as BinaryOperatorExpression;
-			if (binary != null && assignment.Operator == AssignmentOperatorType.Assign)
+			if (assignment.Right is BinaryOperatorExpression binary && assignment.Operator == AssignmentOperatorType.Assign)
 			{
 				if (CanConvertToCompoundAssignment(assignment.Left) && assignment.Left.IsMatch(binary.Left))
 				{
@@ -111,14 +111,13 @@ public static AssignmentOperatorType GetAssignmentOperatorForBinaryOperator(Bina
 
 		static bool CanConvertToCompoundAssignment(Expression left)
 		{
-			MemberReferenceExpression mre = left as MemberReferenceExpression;
-			if (mre != null)
+			if (left is MemberReferenceExpression mre)
 				return IsWithoutSideEffects(mre.Target);
-			IndexerExpression ie = left as IndexerExpression;
-			if (ie != null)
+
+			if (left is IndexerExpression ie)
 				return IsWithoutSideEffects(ie.Target) && ie.Arguments.All(IsWithoutSideEffects);
-			UnaryOperatorExpression uoe = left as UnaryOperatorExpression;
-			if (uoe != null && uoe.Operator == UnaryOperatorType.Dereference)
+
+			if (left is UnaryOperatorExpression uoe && uoe.Operator == UnaryOperatorType.Dereference)
 				return IsWithoutSideEffects(uoe.Expression);
 			return IsWithoutSideEffects(left);
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/Transforms/ReplaceMethodCallsWithOperators.cs b/ICSharpCode.Decompiler/CSharp/Transforms/ReplaceMethodCallsWithOperators.cs
index f2f7a355f..2d4743f94 100644
--- a/ICSharpCode.Decompiler/CSharp/Transforms/ReplaceMethodCallsWithOperators.cs
+++ b/ICSharpCode.Decompiler/CSharp/Transforms/ReplaceMethodCallsWithOperators.cs
@@ -288,7 +288,6 @@ internal static Expression RemoveRedundantToStringInConcat(Expression expr, IMet
 				// generate additional ToString() calls in this case.
 				return expr;
 			}
-			var toStringMethod = m.Get<Expression>("call").Single().GetSymbol() as IMethod;
 			var target = m.Get<Expression>("target").Single();
 			var type = target.GetResolveResult().Type;
 			if (!(isLastArgument || ToStringIsKnownEffectFree(type)))
@@ -301,7 +300,7 @@ internal static Expression RemoveRedundantToStringInConcat(Expression expr, IMet
 				// ToString() might throw NullReferenceException, but the builtin operator+ doesn't.
 				return expr;
 			}
-			if (!ToStringIsKnownEffectFree(type) && toStringMethod != null && IL.Transforms.ILInlining.MethodRequiresCopyForReadonlyLValue(toStringMethod))
+			if (!ToStringIsKnownEffectFree(type) && m.Get<Expression>("call").Single().GetSymbol() is IMethod toStringMethod && IL.Transforms.ILInlining.MethodRequiresCopyForReadonlyLValue(toStringMethod))
 			{
 				// ToString() on a struct may mutate the struct.
 				// For operator+ the C# compiler creates a temporary copy before implicitly calling ToString(),
@@ -428,8 +427,7 @@ public override void VisitCastExpression(CastExpression castExpression)
 			Match m = getMethodOrConstructorFromHandlePattern.Match(castExpression);
 			if (m.Success)
 			{
-				IMethod method = m.Get<AstNode>("method").Single().GetSymbol() as IMethod;
-				if (m.Has("declaringType") && method != null)
+				if (m.Has("declaringType") && m.Get<AstNode>("method").Single().GetSymbol() is IMethod method)
 				{
 					Expression newNode = new MemberReferenceExpression(new TypeReferenceExpression(m.Get<AstType>("declaringType").Single().Detach()), method.Name);
 					newNode = new InvocationExpression(newNode, method.Parameters.Select(p => new TypeReferenceExpression(context.TypeSystemAstBuilder.ConvertType(p.Type))));
diff --git a/ICSharpCode.Decompiler/CSharp/TypeSystem/AliasNamespaceReference.cs b/ICSharpCode.Decompiler/CSharp/TypeSystem/AliasNamespaceReference.cs
index 1bb991dee..3f552470e 100644
--- a/ICSharpCode.Decompiler/CSharp/TypeSystem/AliasNamespaceReference.cs
+++ b/ICSharpCode.Decompiler/CSharp/TypeSystem/AliasNamespaceReference.cs
@@ -70,8 +70,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			AliasNamespaceReference anr = other as AliasNamespaceReference;
-			return anr != null && this.identifier == anr.identifier;
+			return other is AliasNamespaceReference anr && this.identifier == anr.identifier;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/CSharp/TypeSystem/MemberTypeOrNamespaceReference.cs b/ICSharpCode.Decompiler/CSharp/TypeSystem/MemberTypeOrNamespaceReference.cs
index 4418f9cd3..48873454f 100644
--- a/ICSharpCode.Decompiler/CSharp/TypeSystem/MemberTypeOrNamespaceReference.cs
+++ b/ICSharpCode.Decompiler/CSharp/TypeSystem/MemberTypeOrNamespaceReference.cs
@@ -86,8 +86,7 @@ public override ResolveResult Resolve(CSharpResolver resolver)
 
 		public override IType ResolveType(CSharpResolver resolver)
 		{
-			TypeResolveResult trr = Resolve(resolver) as TypeResolveResult;
-			return trr != null ? trr.Type : new UnknownType(null, identifier, typeArguments.Count);
+			return Resolve(resolver) is TypeResolveResult trr ? trr.Type : new UnknownType(null, identifier, typeArguments.Count);
 		}
 
 		public override string ToString()
@@ -113,8 +112,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			MemberTypeOrNamespaceReference o = other as MemberTypeOrNamespaceReference;
-			return o != null && this.target == o.target
+			return other is MemberTypeOrNamespaceReference o && this.target == o.target
 				&& this.identifier == o.identifier && this.typeArguments == o.typeArguments
 				&& this.lookupMode == o.lookupMode;
 		}
diff --git a/ICSharpCode.Decompiler/CSharp/TypeSystem/ResolvedUsingScope.cs b/ICSharpCode.Decompiler/CSharp/TypeSystem/ResolvedUsingScope.cs
index c6e10cfbd..c1743e570 100644
--- a/ICSharpCode.Decompiler/CSharp/TypeSystem/ResolvedUsingScope.cs
+++ b/ICSharpCode.Decompiler/CSharp/TypeSystem/ResolvedUsingScope.cs
@@ -137,13 +137,13 @@ public ResolvedUsingScope(CSharpTypeResolveContext context, UsingScope usingScop
 					for (int i = 0; i < result.Count; i++)
 					{
 						var rr = usingScope.UsingAliases[i].Value.Resolve(resolver);
-						if (rr is TypeResolveResult)
+						if (rr is TypeResolveResult typeResolveResult)
 						{
-							rr = new AliasTypeResolveResult(usingScope.UsingAliases[i].Key, (TypeResolveResult)rr);
+							rr = new AliasTypeResolveResult(usingScope.UsingAliases[i].Key, typeResolveResult);
 						}
-						else if (rr is NamespaceResolveResult)
+						else if (rr is NamespaceResolveResult namespaceResolveResult)
 						{
-							rr = new AliasNamespaceResolveResult(usingScope.UsingAliases[i].Key, (NamespaceResolveResult)rr);
+							rr = new AliasNamespaceResolveResult(usingScope.UsingAliases[i].Key, namespaceResolveResult);
 						}
 						result[i] = new KeyValuePair<string, ResolveResult>(
 							usingScope.UsingAliases[i].Key,
diff --git a/ICSharpCode.Decompiler/CSharp/TypeSystem/SimpleTypeOrNamespaceReference.cs b/ICSharpCode.Decompiler/CSharp/TypeSystem/SimpleTypeOrNamespaceReference.cs
index ded6bccbc..23bb8c1b9 100644
--- a/ICSharpCode.Decompiler/CSharp/TypeSystem/SimpleTypeOrNamespaceReference.cs
+++ b/ICSharpCode.Decompiler/CSharp/TypeSystem/SimpleTypeOrNamespaceReference.cs
@@ -75,8 +75,7 @@ public override ResolveResult Resolve(CSharpResolver resolver)
 
 		public override IType ResolveType(CSharpResolver resolver)
 		{
-			TypeResolveResult trr = Resolve(resolver) as TypeResolveResult;
-			return trr != null ? trr.Type : new UnknownType(null, identifier, typeArguments.Count);
+			return Resolve(resolver) is TypeResolveResult trr ? trr.Type : new UnknownType(null, identifier, typeArguments.Count);
 		}
 
 		public override string ToString()
@@ -101,8 +100,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			SimpleTypeOrNamespaceReference o = other as SimpleTypeOrNamespaceReference;
-			return o != null && this.identifier == o.identifier
+			return other is SimpleTypeOrNamespaceReference o && this.identifier == o.identifier
 				&& this.typeArguments == o.typeArguments && this.lookupMode == o.lookupMode;
 		}
 	}
diff --git a/ICSharpCode.Decompiler/CSharp/TypeSystem/TypeOrNamespaceReference.cs b/ICSharpCode.Decompiler/CSharp/TypeSystem/TypeOrNamespaceReference.cs
index c9ed00c32..df27cec87 100644
--- a/ICSharpCode.Decompiler/CSharp/TypeSystem/TypeOrNamespaceReference.cs
+++ b/ICSharpCode.Decompiler/CSharp/TypeSystem/TypeOrNamespaceReference.cs
@@ -45,8 +45,7 @@ public abstract class TypeOrNamespaceReference : ITypeReference
 		/// </summary>
 		public INamespace ResolveNamespace(CSharpResolver resolver)
 		{
-			NamespaceResolveResult nrr = Resolve(resolver) as NamespaceResolveResult;
-			return nrr != null ? nrr.Namespace : null;
+			return Resolve(resolver) is NamespaceResolveResult nrr ? nrr.Namespace : null;
 		}
 
 		IType ITypeReference.Resolve(ITypeResolveContext context)
diff --git a/ICSharpCode.Decompiler/DecompileRun.cs b/ICSharpCode.Decompiler/DecompileRun.cs
index cb9b0f996..f4ca0679e 100644
--- a/ICSharpCode.Decompiler/DecompileRun.cs
+++ b/ICSharpCode.Decompiler/DecompileRun.cs
@@ -40,9 +40,8 @@ CSharp.TypeSystem.UsingScope CreateUsingScope(HashSet<string> requiredNamespaces
 				{
 					nsType = new MemberType { Target = nsType, MemberName = parts[i] };
 				}
-				var reference = nsType.ToTypeReference(CSharp.Resolver.NameLookupMode.TypeInUsingDeclaration)
-					as CSharp.TypeSystem.TypeOrNamespaceReference;
-				if (reference != null)
+
+				if (nsType.ToTypeReference(CSharp.Resolver.NameLookupMode.TypeInUsingDeclaration) is CSharp.TypeSystem.TypeOrNamespaceReference reference)
 					usingScope.Usings.Add(reference);
 			}
 			return usingScope;
diff --git a/ICSharpCode.Decompiler/Disassembler/DisassemblerHelpers.cs b/ICSharpCode.Decompiler/Disassembler/DisassemblerHelpers.cs
index b20dfeb75..fc474f637 100644
--- a/ICSharpCode.Decompiler/Disassembler/DisassemblerHelpers.cs
+++ b/ICSharpCode.Decompiler/Disassembler/DisassemblerHelpers.cs
@@ -54,12 +54,12 @@ public static class DisassemblerHelpers
 	{
 		public static string OffsetToString(int offset)
 		{
-			return string.Format("IL_{0:x4}", offset);
+			return $"IL_{offset:x4}";
 		}
 
 		public static string OffsetToString(long offset)
 		{
-			return string.Format("IL_{0:x4}", offset);
+			return $"IL_{offset:x4}";
 		}
 
 		public static void WriteOffsetReference(ITextOutput writer, int? offset)
@@ -178,8 +178,7 @@ public static void WriteOperand(ITextOutput writer, object operand)
 			if (operand == null)
 				throw new ArgumentNullException(nameof(operand));
 
-			string s = operand as string;
-			if (s != null)
+			if (operand is string s)
 			{
 				WriteOperand(writer, s);
 			}
@@ -187,13 +186,13 @@ public static void WriteOperand(ITextOutput writer, object operand)
 			{
 				writer.Write(((int)(char)operand).ToString());
 			}
-			else if (operand is float)
+			else if (operand is float f)
 			{
-				WriteOperand(writer, (float)operand);
+				WriteOperand(writer, f);
 			}
-			else if (operand is double)
+			else if (operand is double d)
 			{
-				WriteOperand(writer, (double)operand);
+				WriteOperand(writer, d);
 			}
 			else if (operand is bool)
 			{
diff --git a/ICSharpCode.Decompiler/Documentation/IdStringProvider.cs b/ICSharpCode.Decompiler/Documentation/IdStringProvider.cs
index 75470a24d..b5fa0187f 100644
--- a/ICSharpCode.Decompiler/Documentation/IdStringProvider.cs
+++ b/ICSharpCode.Decompiler/Documentation/IdStringProvider.cs
@@ -71,14 +71,14 @@ public static string GetIdString(this IEntity entity)
 				b.Append('#');
 			}
 			b.Append(member.Name.Replace('.', '#').Replace('<', '{').Replace('>', '}'));
-			IMethod method = member as IMethod;
-			if (method != null && method.TypeParameters.Count > 0)
+
+			if (member is IMethod method && method.TypeParameters.Count > 0)
 			{
 				b.Append("``");
 				b.Append(method.TypeParameters.Count);
 			}
-			IParameterizedMember parameterizedMember = member as IParameterizedMember;
-			if (parameterizedMember != null && parameterizedMember.Parameters.Count > 0)
+
+			if (member is IParameterizedMember parameterizedMember && parameterizedMember.Parameters.Count > 0)
 			{
 				b.Append('(');
 				var parameters = parameterizedMember.Parameters;
@@ -180,8 +180,7 @@ static void AppendTypeParameters(StringBuilder b, IType type, int outerTypeParam
 			int tpc = type.TypeParameterCount - outerTypeParameterCount;
 			if (tpc > 0)
 			{
-				ParameterizedType pt = type as ParameterizedType;
-				if (pt != null)
+				if (type is ParameterizedType pt)
 				{
 					b.Append('{');
 					var ta = pt.TypeArguments;
diff --git a/ICSharpCode.Decompiler/Documentation/XmlDocumentationElement.cs b/ICSharpCode.Decompiler/Documentation/XmlDocumentationElement.cs
index 61948f6ca..148e18dbb 100644
--- a/ICSharpCode.Decompiler/Documentation/XmlDocumentationElement.cs
+++ b/ICSharpCode.Decompiler/Documentation/XmlDocumentationElement.cs
@@ -173,18 +173,15 @@ static List<XmlDocumentationElement> CreateElements(IEnumerable<XObject> childOb
 			List<XmlDocumentationElement> list = new List<XmlDocumentationElement>();
 			foreach (var child in childObjects)
 			{
-				var childText = child as XText;
-				var childTag = child as XCData;
-				var childElement = child as XElement;
-				if (childText != null)
+				if (child is XText childText)
 				{
 					list.Add(new XmlDocumentationElement(childText.Value, declaringEntity));
 				}
-				else if (childTag != null)
+				else if (child is XCData childTag)
 				{
 					list.Add(new XmlDocumentationElement(childTag.Value, declaringEntity));
 				}
-				else if (childElement != null)
+				else if (child is XElement childElement)
 				{
 					if (nestingLevel < 5 && childElement.Name == "inheritdoc")
 					{
@@ -225,8 +222,7 @@ static List<XmlDocumentationElement> CreateElements(IEnumerable<XObject> childOb
 
 								var inheritedChildren = doc.Nodes().Where(
 									inheritedObject => {
-										XElement inheritedElement = inheritedObject as XElement;
-										return !(inheritedElement != null && doNotInherit.Contains(inheritedElement.Name.LocalName));
+										return !(inheritedObject is XElement inheritedElement && doNotInherit.Contains(inheritedElement.Name.LocalName));
 									});
 
 								list.AddRange(CreateElements(inheritedChildren, inheritedFrom, crefResolver, nestingLevel + 1));
diff --git a/ICSharpCode.Decompiler/FlowAnalysis/ControlFlowNode.cs b/ICSharpCode.Decompiler/FlowAnalysis/ControlFlowNode.cs
index 91c7f364d..61e718d54 100644
--- a/ICSharpCode.Decompiler/FlowAnalysis/ControlFlowNode.cs
+++ b/ICSharpCode.Decompiler/FlowAnalysis/ControlFlowNode.cs
@@ -128,8 +128,7 @@ internal static GraphVizGraph ExportGraph(IReadOnlyList<ControlFlowNode> nodes,
 			if (labelFunc == null)
 			{
 				labelFunc = node => {
-					var block = node.UserData as IL.Block;
-					return block != null ? block.Label : node.UserData?.ToString();
+					return node.UserData is IL.Block block ? block.Label : node.UserData?.ToString();
 				};
 			}
 			GraphVizGraph g = new GraphVizGraph();
diff --git a/ICSharpCode.Decompiler/IL/ControlFlow/DetectPinnedRegions.cs b/ICSharpCode.Decompiler/IL/ControlFlow/DetectPinnedRegions.cs
index 60d158c39..eb04887ab 100644
--- a/ICSharpCode.Decompiler/IL/ControlFlow/DetectPinnedRegions.cs
+++ b/ICSharpCode.Decompiler/IL/ControlFlow/DetectPinnedRegions.cs
@@ -75,8 +75,7 @@ public void Run(ILFunction function, ILTransformContext context)
 				context.CancellationToken.ThrowIfCancellationRequested();
 				for (int i = 0; i < block.Instructions.Count; i++)
 				{
-					var stloc = block.Instructions[i] as StLoc;
-					if (stloc != null && stloc.Variable.Kind == VariableKind.PinnedLocal && stloc.Variable.LoadCount == 0 && stloc.Variable.AddressCount == 0)
+					if (block.Instructions[i] is StLoc stloc && stloc.Variable.Kind == VariableKind.PinnedLocal && stloc.Variable.LoadCount == 0 && stloc.Variable.AddressCount == 0)
 					{
 						if (SemanticHelper.IsPure(stloc.Value.Flags))
 						{
@@ -323,16 +322,13 @@ bool IsNullSafeArrayToPointerPattern(Block block, out ILVariable v, out ILVariab
 			var ifInst = block.Instructions.SecondToLastOrDefault() as IfInstruction;
 			if (ifInst == null)
 				return false;
-			var condition = ifInst.Condition as Comp;
-			if (!(condition != null && condition.Kind == ComparisonKind.Equality && condition.Left.MatchLdLoc(out v) && condition.Right.MatchLdNull()))
+			if (!(ifInst.Condition is Comp condition && condition.Kind == ComparisonKind.Equality && condition.Left.MatchLdLoc(out v) && condition.Right.MatchLdNull()))
 				return false;
 			bool usingPreviousVar = false;
 			if (v.Kind == VariableKind.StackSlot)
 			{
-				// If the variable is a stack slot, that might be due to an inline assignment,
-				// so check the previous instruction:
-				var previous = block.Instructions.ElementAtOrDefault(block.Instructions.Count - 3) as StLoc;
-				if (previous != null && previous.Value.MatchLdLoc(v))
+				// If the variable is a stack slot, that might be due to an inline assignment,				// so check the previous instruction:
+				if (block.Instructions.ElementAtOrDefault(block.Instructions.Count - 3) is StLoc previous && previous.Value.MatchLdLoc(v))
 				{
 					// stloc V(ldloc S)
 					// if (comp(ldloc S == ldnull)) ...
@@ -569,14 +565,11 @@ bool CreatePinnedRegion(Block block, StLoc stLoc)
 						innerBlock = (Block)innerBlock.Clone();
 						clonedBlocks[i] = innerBlock;
 					}
-					Branch br = innerBlock.Instructions.LastOrDefault() as Branch;
-					if (br != null && br.TargetBlock.IncomingEdgeCount == 1
+					if (innerBlock.Instructions.LastOrDefault() is Branch br && br.TargetBlock.IncomingEdgeCount == 1
 						&& br.TargetContainer == sourceContainer && reachedEdgesPerBlock[br.TargetBlock.ChildIndex] == 0)
 					{
-						// branch that leaves body.
-						// The target block should have an instruction that resets the pin; delete that instruction:
-						StLoc unpin = br.TargetBlock.Instructions.First() as StLoc;
-						if (unpin != null && unpin.Variable == stLoc.Variable && IsNullOrZero(unpin.Value))
+						// branch that leaves body.						// The target block should have an instruction that resets the pin; delete that instruction:
+						if (br.TargetBlock.Instructions.First() is StLoc unpin && unpin.Variable == stLoc.Variable && IsNullOrZero(unpin.Value))
 						{
 							br.TargetBlock.Instructions.RemoveAt(0);
 						}
@@ -926,8 +919,7 @@ bool IsOffsetToStringDataBlock(Block block, ILVariable nativeVar, Block targetBl
 
 		bool IsOffsetToStringDataCall(ILInstruction inst)
 		{
-			Call call = inst.UnwrapConv(ConversionKind.SignExtend) as Call;
-			return call != null && call.Method.FullName == "System.Runtime.CompilerServices.RuntimeHelpers.get_OffsetToStringData";
+			return inst.UnwrapConv(ConversionKind.SignExtend) is Call call && call.Method.FullName == "System.Runtime.CompilerServices.RuntimeHelpers.get_OffsetToStringData";
 		}
 
 		/// <summary>
diff --git a/ICSharpCode.Decompiler/IL/ControlFlow/SymbolicExecution.cs b/ICSharpCode.Decompiler/IL/ControlFlow/SymbolicExecution.cs
index 4bd88cade..9eb5ce1d2 100644
--- a/ICSharpCode.Decompiler/IL/ControlFlow/SymbolicExecution.cs
+++ b/ICSharpCode.Decompiler/IL/ControlFlow/SymbolicExecution.cs
@@ -92,7 +92,7 @@ public SymbolicValue AsBool()
 		}
 		public override string ToString()
 		{
-			return string.Format("[SymbolicValue {0}: {1}]", this.Type, this.Constant);
+			return $"[SymbolicValue {this.Type}: {this.Constant}]";
 		}
 	}
 
diff --git a/ICSharpCode.Decompiler/IL/ILReader.cs b/ICSharpCode.Decompiler/IL/ILReader.cs
index 0f0a000dc..cbeb03fb6 100644
--- a/ICSharpCode.Decompiler/IL/ILReader.cs
+++ b/ICSharpCode.Decompiler/IL/ILReader.cs
@@ -279,7 +279,7 @@ ILVariable CreateILVariable(int index, IType parameterType, string name)
 		/// </summary>
 		void Warn(string message)
 		{
-			Warnings.Add(string.Format("IL_{0:x4}: {1}", currentInstructionStart, message));
+			Warnings.Add($"IL_{currentInstructionStart:x4}: {message}");
 		}
 
 		ImmutableStack<ILVariable> MergeStacks(ImmutableStack<ILVariable> a, ImmutableStack<ILVariable> b)
@@ -1207,9 +1207,9 @@ internal static ILInstruction Cast(ILInstruction inst, StackType expectedType, L
 		{
 			if (expectedType != inst.ResultType)
 			{
-				if (inst is InvalidExpression)
+				if (inst is InvalidExpression invalidExpression)
 				{
-					((InvalidExpression)inst).ExpectedResultType = expectedType;
+					invalidExpression.ExpectedResultType = expectedType;
 				}
 				else if (expectedType == StackType.I && inst.ResultType == StackType.I4)
 				{
@@ -1277,10 +1277,7 @@ internal static ILInstruction Cast(ILInstruction inst, StackType expectedType, L
 
 			void Warn(string message)
 			{
-				if (warnings != null)
-				{
-					warnings.Add(string.Format("IL_{0:x4}: {1}", ilOffset, message));
-				}
+				warnings?.Add($"IL_{ilOffset:x4}: {message}");
 			}
 		}
 
@@ -1459,8 +1456,8 @@ private ILInstruction DecodeConstrainedCall()
 		{
 			constrainedPrefix = ReadAndDecodeTypeReference();
 			var inst = DecodeInstruction();
-			var call = UnpackPush(inst) as CallInstruction;
-			if (call != null)
+
+			if (UnpackPush(inst) is CallInstruction call)
 				Debug.Assert(call.ConstrainedTo == constrainedPrefix);
 			else
 				Warn("Ignored invalid 'constrained' prefix");
@@ -1471,8 +1468,8 @@ private ILInstruction DecodeConstrainedCall()
 		private ILInstruction DecodeTailCall()
 		{
 			var inst = DecodeInstruction();
-			var call = UnpackPush(inst) as CallInstruction;
-			if (call != null)
+
+			if (UnpackPush(inst) is CallInstruction call)
 				call.IsTail = true;
 			else
 				Warn("Ignored invalid 'tail' prefix");
@@ -1483,8 +1480,8 @@ private ILInstruction DecodeUnaligned()
 		{
 			byte alignment = reader.ReadByte();
 			var inst = DecodeInstruction();
-			var sup = UnpackPush(inst) as ISupportsUnalignedPrefix;
-			if (sup != null)
+
+			if (UnpackPush(inst) is ISupportsUnalignedPrefix sup)
 				sup.UnalignedPrefix = alignment;
 			else
 				Warn("Ignored invalid 'unaligned' prefix");
@@ -1494,8 +1491,8 @@ private ILInstruction DecodeUnaligned()
 		private ILInstruction DecodeVolatile()
 		{
 			var inst = DecodeInstruction();
-			var svp = UnpackPush(inst) as ISupportsVolatilePrefix;
-			if (svp != null)
+
+			if (UnpackPush(inst) is ISupportsVolatilePrefix svp)
 				svp.IsVolatile = true;
 			else
 				Warn("Ignored invalid 'volatile' prefix");
@@ -1505,8 +1502,8 @@ private ILInstruction DecodeVolatile()
 		private ILInstruction DecodeReadonly()
 		{
 			var inst = DecodeInstruction();
-			var ldelema = UnpackPush(inst) as LdElema;
-			if (ldelema != null)
+
+			if (UnpackPush(inst) is LdElema ldelema)
 				ldelema.IsReadOnly = true;
 			else
 				Warn("Ignored invalid 'readonly' prefix");
diff --git a/ICSharpCode.Decompiler/IL/Instructions.cs b/ICSharpCode.Decompiler/IL/Instructions.cs
index 1cb69799f..f65d1375e 100644
--- a/ICSharpCode.Decompiler/IL/Instructions.cs
+++ b/ICSharpCode.Decompiler/IL/Instructions.cs
@@ -685,8 +685,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as InvalidBranch;
-			return o != null;
+			return other is InvalidBranch o;
 		}
 	}
 }
@@ -722,8 +721,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as InvalidExpression;
-			return o != null;
+			return other is InvalidExpression o;
 		}
 	}
 }
@@ -750,8 +748,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Nop;
-			return o != null;
+			return other is Nop o;
 		}
 	}
 }
@@ -831,8 +828,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as ILFunction;
-			return o != null && this.body.PerformMatch(o.body, ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions, o.LocalFunctions, ref match);
+			return other is ILFunction o && this.body.PerformMatch(o.body, ref match) && Patterns.ListMatch.DoMatch(this.LocalFunctions, o.LocalFunctions, ref match);
 		}
 	}
 }
@@ -856,8 +852,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as BlockContainer;
-			return o != null && Patterns.ListMatch.DoMatch(this.Blocks, o.Blocks, ref match);
+			return other is BlockContainer o && Patterns.ListMatch.DoMatch(this.Blocks, o.Blocks, ref match);
 		}
 	}
 }
@@ -881,8 +876,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Block;
-			return o != null && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions, o.Instructions, ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction, ref match);
+			return other is Block o && this.Kind == o.Kind && Patterns.ListMatch.DoMatch(this.Instructions, o.Instructions, ref match) && this.FinalInstruction.PerformMatch(o.FinalInstruction, ref match);
 		}
 	}
 }
@@ -1033,8 +1027,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as PinnedRegion;
-			return o != null && variable == o.variable && this.init.PerformMatch(o.init, ref match) && this.body.PerformMatch(o.body, ref match);
+			return other is PinnedRegion o && variable == o.variable && this.init.PerformMatch(o.init, ref match) && this.body.PerformMatch(o.body, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -1065,8 +1058,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as BinaryNumericInstruction;
-			return o != null && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted;
+			return other is BinaryNumericInstruction o && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && IsLifted == o.IsLifted;
 		}
 	}
 }
@@ -1096,8 +1088,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as NumericCompoundAssign;
-			return o != null && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target, ref match) && Value.PerformMatch(o.Value, ref match);
+			return other is NumericCompoundAssign o && type.Equals(o.type) && CheckForOverflow == o.CheckForOverflow && Sign == o.Sign && Operator == o.Operator && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target, ref match) && Value.PerformMatch(o.Value, ref match);
 		}
 	}
 }
@@ -1130,8 +1121,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as UserDefinedCompoundAssign;
-			return o != null && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target, ref match) && Value.PerformMatch(o.Value, ref match);
+			return other is UserDefinedCompoundAssign o && this.Method.Equals(o.Method) && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target, ref match) && Value.PerformMatch(o.Value, ref match);
 		}
 	}
 }
@@ -1164,8 +1154,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicCompoundAssign;
-			return o != null && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target, ref match) && Value.PerformMatch(o.Value, ref match);
+			return other is DynamicCompoundAssign o && this.EvalMode == o.EvalMode && this.TargetKind == o.TargetKind && Target.PerformMatch(o.Target, ref match) && Value.PerformMatch(o.Value, ref match);
 		}
 	}
 }
@@ -1189,8 +1178,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as BitNot;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType;
+			return other is BitNot o && this.Argument.PerformMatch(o.Argument, ref match) && IsLifted == o.IsLifted && UnderlyingResultType == o.UnderlyingResultType;
 		}
 	}
 }
@@ -1217,8 +1205,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Arglist;
-			return o != null;
+			return other is Arglist o;
 		}
 	}
 }
@@ -1251,8 +1238,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Branch;
-			return o != null && this.TargetBlock == o.TargetBlock;
+			return other is Branch o && this.TargetBlock == o.TargetBlock;
 		}
 	}
 }
@@ -1326,8 +1312,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Leave;
-			return o != null && this.value.PerformMatch(o.value, ref match) && this.TargetContainer == o.TargetContainer;
+			return other is Leave o && this.value.PerformMatch(o.value, ref match) && this.TargetContainer == o.TargetContainer;
 		}
 	}
 }
@@ -1434,8 +1419,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as IfInstruction;
-			return o != null && this.condition.PerformMatch(o.condition, ref match) && this.trueInst.PerformMatch(o.trueInst, ref match) && this.falseInst.PerformMatch(o.falseInst, ref match);
+			return other is IfInstruction o && this.condition.PerformMatch(o.condition, ref match) && this.trueInst.PerformMatch(o.trueInst, ref match) && this.falseInst.PerformMatch(o.falseInst, ref match);
 		}
 	}
 }
@@ -1525,8 +1509,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as NullCoalescingInstruction;
-			return o != null && this.valueInst.PerformMatch(o.valueInst, ref match) && this.fallbackInst.PerformMatch(o.fallbackInst, ref match);
+			return other is NullCoalescingInstruction o && this.valueInst.PerformMatch(o.valueInst, ref match) && this.fallbackInst.PerformMatch(o.fallbackInst, ref match);
 		}
 	}
 }
@@ -1550,8 +1533,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as SwitchInstruction;
-			return o != null && IsLifted == o.IsLifted && Value.PerformMatch(o.Value, ref match) && Patterns.ListMatch.DoMatch(this.Sections, o.Sections, ref match);
+			return other is SwitchInstruction o && IsLifted == o.IsLifted && Value.PerformMatch(o.Value, ref match) && Patterns.ListMatch.DoMatch(this.Sections, o.Sections, ref match);
 		}
 	}
 }
@@ -1625,8 +1607,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as SwitchSection;
-			return o != null && this.body.PerformMatch(o.body, ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel;
+			return other is SwitchSection o && this.body.PerformMatch(o.body, ref match) && this.Labels.SetEquals(o.Labels) && this.HasNullLabel == o.HasNullLabel;
 		}
 	}
 }
@@ -1650,8 +1631,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as TryCatch;
-			return o != null && TryBlock.PerformMatch(o.TryBlock, ref match) && Patterns.ListMatch.DoMatch(Handlers, o.Handlers, ref match);
+			return other is TryCatch o && TryBlock.PerformMatch(o.TryBlock, ref match) && Patterns.ListMatch.DoMatch(Handlers, o.Handlers, ref match);
 		}
 	}
 }
@@ -1780,8 +1760,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as TryCatchHandler;
-			return o != null && this.filter.PerformMatch(o.filter, ref match) && this.body.PerformMatch(o.body, ref match) && variable == o.variable;
+			return other is TryCatchHandler o && this.filter.PerformMatch(o.filter, ref match) && this.body.PerformMatch(o.body, ref match) && variable == o.variable;
 		}
 	}
 }
@@ -1805,8 +1784,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as TryFinally;
-			return o != null && TryBlock.PerformMatch(o.TryBlock, ref match) && finallyBlock.PerformMatch(o.finallyBlock, ref match);
+			return other is TryFinally o && TryBlock.PerformMatch(o.TryBlock, ref match) && finallyBlock.PerformMatch(o.finallyBlock, ref match);
 		}
 	}
 }
@@ -1830,8 +1808,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as TryFault;
-			return o != null && TryBlock.PerformMatch(o.TryBlock, ref match) && faultBlock.PerformMatch(o.faultBlock, ref match);
+			return other is TryFault o && TryBlock.PerformMatch(o.TryBlock, ref match) && faultBlock.PerformMatch(o.faultBlock, ref match);
 		}
 	}
 }
@@ -1936,8 +1913,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LockInstruction;
-			return o != null && this.onExpression.PerformMatch(o.onExpression, ref match) && this.body.PerformMatch(o.body, ref match);
+			return other is LockInstruction o && this.onExpression.PerformMatch(o.onExpression, ref match) && this.body.PerformMatch(o.body, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -2081,8 +2057,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as UsingInstruction;
-			return o != null && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression, ref match) && this.body.PerformMatch(o.body, ref match);
+			return other is UsingInstruction o && variable == o.variable && this.resourceExpression.PerformMatch(o.resourceExpression, ref match) && this.body.PerformMatch(o.body, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -2125,8 +2100,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DebugBreak;
-			return o != null;
+			return other is DebugBreak o;
 		}
 	}
 }
@@ -2150,8 +2124,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Comp;
-			return o != null && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind;
+			return other is Comp o && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match) && this.Kind == o.Kind && this.Sign == o.Sign && this.LiftingKind == o.LiftingKind;
 		}
 	}
 }
@@ -2221,8 +2194,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as CallIndirect;
-			return o != null && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer, ref match);
+			return other is CallIndirect o && EqualSignature(o) && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match) && this.FunctionPointer.PerformMatch(o.FunctionPointer, ref match);
 		}
 	}
 }
@@ -2258,8 +2230,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Ckfinite;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is Ckfinite o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 	}
 }
@@ -2283,8 +2254,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Conv;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted;
+			return other is Conv o && this.Argument.PerformMatch(o.Argument, ref match) && CheckForOverflow == o.CheckForOverflow && Kind == o.Kind && InputSign == o.InputSign && TargetType == o.TargetType && IsLifted == o.IsLifted;
 		}
 	}
 }
@@ -2361,8 +2331,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdLoc;
-			return o != null && variable == o.variable;
+			return other is LdLoc o && variable == o.variable;
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -2436,8 +2405,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdLoca;
-			return o != null && variable == o.variable;
+			return other is LdLoca o && variable == o.variable;
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -2575,8 +2543,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as StLoc;
-			return o != null && variable == o.variable && this.value.PerformMatch(o.value, ref match);
+			return other is StLoc o && variable == o.variable && this.value.PerformMatch(o.value, ref match);
 		}
 	}
 }
@@ -2680,8 +2647,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as AddressOf;
-			return o != null && this.value.PerformMatch(o.value, ref match) && type.Equals(o.type);
+			return other is AddressOf o && this.value.PerformMatch(o.value, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -2708,8 +2674,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as ThreeValuedBoolAnd;
-			return o != null && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match);
+			return other is ThreeValuedBoolAnd o && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match);
 		}
 	}
 }
@@ -2736,8 +2701,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as ThreeValuedBoolOr;
-			return o != null && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match);
+			return other is ThreeValuedBoolOr o && this.Left.PerformMatch(o.Left, ref match) && this.Right.PerformMatch(o.Right, ref match);
 		}
 	}
 }
@@ -2776,8 +2740,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as NullableUnwrap;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is NullableUnwrap o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 	}
 }
@@ -2805,8 +2768,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as NullableRewrap;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is NullableRewrap o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 	}
 }
@@ -2842,8 +2804,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdStr;
-			return o != null && this.Value == o.Value;
+			return other is LdStr o && this.Value == o.Value;
 		}
 	}
 }
@@ -2879,8 +2840,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdcI4;
-			return o != null && this.Value == o.Value;
+			return other is LdcI4 o && this.Value == o.Value;
 		}
 	}
 }
@@ -2916,8 +2876,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdcI8;
-			return o != null && this.Value == o.Value;
+			return other is LdcI8 o && this.Value == o.Value;
 		}
 	}
 }
@@ -2953,8 +2912,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdcF4;
-			return o != null && this.Value == o.Value;
+			return other is LdcF4 o && this.Value == o.Value;
 		}
 	}
 }
@@ -2990,8 +2948,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdcF8;
-			return o != null && this.Value == o.Value;
+			return other is LdcF8 o && this.Value == o.Value;
 		}
 	}
 }
@@ -3027,8 +2984,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdcDecimal;
-			return o != null && this.Value == o.Value;
+			return other is LdcDecimal o && this.Value == o.Value;
 		}
 	}
 }
@@ -3055,8 +3011,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdNull;
-			return o != null;
+			return other is LdNull o;
 		}
 	}
 }
@@ -3097,8 +3052,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdFtn;
-			return o != null && object.Equals(method, o.method);
+			return other is LdFtn o && object.Equals(method, o.method);
 		}
 	}
 }
@@ -3151,8 +3105,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdVirtFtn;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && object.Equals(method, o.method);
+			return other is LdVirtFtn o && this.Argument.PerformMatch(o.Argument, ref match) && object.Equals(method, o.method);
 		}
 	}
 }
@@ -3214,8 +3167,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdVirtDelegate;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type) && object.Equals(method, o.method);
+			return other is LdVirtDelegate o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type) && object.Equals(method, o.method);
 		}
 	}
 }
@@ -3256,8 +3208,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdTypeToken;
-			return o != null && type.Equals(o.type);
+			return other is LdTypeToken o && type.Equals(o.type);
 		}
 	}
 }
@@ -3295,8 +3246,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdMemberToken;
-			return o != null && member.Equals(o.member);
+			return other is LdMemberToken o && member.Equals(o.member);
 		}
 	}
 }
@@ -3332,8 +3282,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LocAlloc;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is LocAlloc o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 	}
 }
@@ -3386,8 +3335,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LocAllocSpan;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is LocAllocSpan o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -3530,8 +3478,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Cpblk;
-			return o != null && this.destAddress.PerformMatch(o.destAddress, ref match) && this.sourceAddress.PerformMatch(o.sourceAddress, ref match) && this.size.PerformMatch(o.size, ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
+			return other is Cpblk o && this.destAddress.PerformMatch(o.destAddress, ref match) && this.sourceAddress.PerformMatch(o.sourceAddress, ref match) && this.size.PerformMatch(o.size, ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -3681,8 +3628,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Initblk;
-			return o != null && this.address.PerformMatch(o.address, ref match) && this.value.PerformMatch(o.value, ref match) && this.size.PerformMatch(o.size, ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
+			return other is Initblk o && this.address.PerformMatch(o.address, ref match) && this.value.PerformMatch(o.value, ref match) && this.size.PerformMatch(o.size, ref match) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -3793,8 +3739,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdFlda;
-			return o != null && this.target.PerformMatch(o.target, ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field);
+			return other is LdFlda o && this.target.PerformMatch(o.target, ref match) && DelayExceptions == o.DelayExceptions && field.Equals(o.field);
 		}
 	}
 }
@@ -3832,8 +3777,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdsFlda;
-			return o != null && field.Equals(o.field);
+			return other is LdsFlda o && field.Equals(o.field);
 		}
 	}
 }
@@ -3886,8 +3830,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as CastClass;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is CastClass o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -3931,8 +3874,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as IsInst;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is IsInst o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -4044,8 +3986,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdObj;
-			return o != null && this.target.PerformMatch(o.target, ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
+			return other is LdObj o && this.target.PerformMatch(o.target, ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -4183,8 +4124,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as StObj;
-			return o != null && this.target.PerformMatch(o.target, ref match) && this.value.PerformMatch(o.value, ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
+			return other is StObj o && this.target.PerformMatch(o.target, ref match) && this.value.PerformMatch(o.value, ref match) && type.Equals(o.type) && IsVolatile == o.IsVolatile && UnalignedPrefix == o.UnalignedPrefix;
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -4244,8 +4184,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Box;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is Box o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -4298,8 +4237,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Unbox;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is Unbox o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -4352,8 +4290,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as UnboxAny;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is UnboxAny o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -4477,8 +4414,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as NewArr;
-			return o != null && type.Equals(o.type) && Patterns.ListMatch.DoMatch(this.Indices, o.Indices, ref match);
+			return other is NewArr o && type.Equals(o.type) && Patterns.ListMatch.DoMatch(this.Indices, o.Indices, ref match);
 		}
 	}
 }
@@ -4519,8 +4455,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DefaultValue;
-			return o != null && type.Equals(o.type);
+			return other is DefaultValue o && type.Equals(o.type);
 		}
 	}
 }
@@ -4556,8 +4491,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Throw;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is Throw o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 	}
 }
@@ -4593,8 +4527,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Rethrow;
-			return o != null;
+			return other is Rethrow o;
 		}
 	}
 }
@@ -4635,8 +4568,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as SizeOf;
-			return o != null && type.Equals(o.type);
+			return other is SizeOf o && type.Equals(o.type);
 		}
 	}
 }
@@ -4718,8 +4650,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdLen;
-			return o != null && this.array.PerformMatch(o.array, ref match);
+			return other is LdLen o && this.array.PerformMatch(o.array, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -4850,8 +4781,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as LdElema;
-			return o != null && type.Equals(o.type) && this.array.PerformMatch(o.array, ref match) && Patterns.ListMatch.DoMatch(this.Indices, o.Indices, ref match) && this.WithSystemIndex == o.WithSystemIndex && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly;
+			return other is LdElema o && type.Equals(o.type) && this.array.PerformMatch(o.array, ref match) && Patterns.ListMatch.DoMatch(this.Indices, o.Indices, ref match) && this.WithSystemIndex == o.WithSystemIndex && DelayExceptions == o.DelayExceptions && IsReadOnly == o.IsReadOnly;
 		}
 	}
 }
@@ -4959,8 +4889,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as GetPinnableReference;
-			return o != null && this.argument.PerformMatch(o.argument, ref match) && object.Equals(method, o.method);
+			return other is GetPinnableReference o && this.argument.PerformMatch(o.argument, ref match) && object.Equals(method, o.method);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -5048,8 +4977,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as StringToInt;
-			return o != null && this.argument.PerformMatch(o.argument, ref match);
+			return other is StringToInt o && this.argument.PerformMatch(o.argument, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -5093,8 +5021,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as ExpressionTreeCast;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked;
+			return other is ExpressionTreeCast o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type) && this.IsChecked == o.IsChecked;
 		}
 	}
 }
@@ -5209,8 +5136,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as UserDefinedLogicOperator;
-			return o != null && object.Equals(method, o.method) && this.left.PerformMatch(o.left, ref match) && this.right.PerformMatch(o.right, ref match);
+			return other is UserDefinedLogicOperator o && object.Equals(method, o.method) && this.left.PerformMatch(o.left, ref match) && this.right.PerformMatch(o.right, ref match);
 		}
 	}
 }
@@ -5300,8 +5226,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicLogicOperatorInstruction;
-			return o != null && this.left.PerformMatch(o.left, ref match) && this.right.PerformMatch(o.right, ref match);
+			return other is DynamicLogicOperatorInstruction o && this.left.PerformMatch(o.left, ref match) && this.right.PerformMatch(o.right, ref match);
 		}
 	}
 }
@@ -5400,8 +5325,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicBinaryOperatorInstruction;
-			return o != null && this.left.PerformMatch(o.left, ref match) && this.right.PerformMatch(o.right, ref match);
+			return other is DynamicBinaryOperatorInstruction o && this.left.PerformMatch(o.left, ref match) && this.right.PerformMatch(o.right, ref match);
 		}
 	}
 }
@@ -5483,8 +5407,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicUnaryOperatorInstruction;
-			return o != null && this.operand.PerformMatch(o.operand, ref match);
+			return other is DynamicUnaryOperatorInstruction o && this.operand.PerformMatch(o.operand, ref match);
 		}
 	}
 }
@@ -5572,8 +5495,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicConvertInstruction;
-			return o != null && type.Equals(o.type) && this.argument.PerformMatch(o.argument, ref match);
+			return other is DynamicConvertInstruction o && type.Equals(o.type) && this.argument.PerformMatch(o.argument, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -5660,8 +5582,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicGetMemberInstruction;
-			return o != null && this.target.PerformMatch(o.target, ref match);
+			return other is DynamicGetMemberInstruction o && this.target.PerformMatch(o.target, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -5765,8 +5686,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicSetMemberInstruction;
-			return o != null && this.target.PerformMatch(o.target, ref match) && this.value.PerformMatch(o.value, ref match);
+			return other is DynamicSetMemberInstruction o && this.target.PerformMatch(o.target, ref match) && this.value.PerformMatch(o.value, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -5841,8 +5761,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicGetIndexInstruction;
-			return o != null && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
+			return other is DynamicGetIndexInstruction o && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
 		}
 	}
 }
@@ -5912,8 +5831,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicSetIndexInstruction;
-			return o != null && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
+			return other is DynamicSetIndexInstruction o && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
 		}
 	}
 }
@@ -5983,8 +5901,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicInvokeMemberInstruction;
-			return o != null && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
+			return other is DynamicInvokeMemberInstruction o && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
 		}
 	}
 }
@@ -6054,8 +5971,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicInvokeConstructorInstruction;
-			return o != null && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
+			return other is DynamicInvokeConstructorInstruction o && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
 		}
 	}
 }
@@ -6125,8 +6041,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicInvokeInstruction;
-			return o != null && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
+			return other is DynamicInvokeInstruction o && Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
 		}
 	}
 }
@@ -6208,8 +6123,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DynamicIsEventInstruction;
-			return o != null && this.argument.PerformMatch(o.argument, ref match);
+			return other is DynamicIsEventInstruction o && this.argument.PerformMatch(o.argument, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -6350,8 +6264,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as MatchInstruction;
-			return o != null && variable == o.variable && object.Equals(method, o.method) && this.IsDeconstructCall == o.IsDeconstructCall && this.IsDeconstructTuple == o.IsDeconstructTuple && this.CheckType == o.CheckType && this.CheckNotNull == o.CheckNotNull && this.testedOperand.PerformMatch(o.testedOperand, ref match) && Patterns.ListMatch.DoMatch(this.SubPatterns, o.SubPatterns, ref match);
+			return other is MatchInstruction o && variable == o.variable && object.Equals(method, o.method) && this.IsDeconstructCall == o.IsDeconstructCall && this.IsDeconstructTuple == o.IsDeconstructTuple && this.CheckType == o.CheckType && this.CheckNotNull == o.CheckNotNull && this.testedOperand.PerformMatch(o.testedOperand, ref match) && Patterns.ListMatch.DoMatch(this.SubPatterns, o.SubPatterns, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -6402,8 +6315,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as MakeRefAny;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is MakeRefAny o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -6430,8 +6342,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as RefAnyType;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is RefAnyType o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 	}
 }
@@ -6484,8 +6395,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as RefAnyValue;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
+			return other is RefAnyValue o && this.Argument.PerformMatch(o.Argument, ref match) && type.Equals(o.type);
 		}
 	}
 }
@@ -6580,8 +6490,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as YieldReturn;
-			return o != null && this.value.PerformMatch(o.value, ref match);
+			return other is YieldReturn o && this.value.PerformMatch(o.value, ref match);
 		}
 	}
 }
@@ -6676,8 +6585,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as Await;
-			return o != null && this.value.PerformMatch(o.value, ref match);
+			return other is Await o && this.value.PerformMatch(o.value, ref match);
 		}
 	}
 }
@@ -6701,8 +6609,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DeconstructInstruction;
-			return o != null;
+			return other is DeconstructInstruction o;
 		}
 	}
 }
@@ -6726,8 +6633,7 @@ public override T AcceptVisitor<T>(ILVisitor<T> visitor)
 		}
 		protected internal override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			var o = other as DeconstructResultInstruction;
-			return o != null && this.Argument.PerformMatch(o.Argument, ref match);
+			return other is DeconstructResultInstruction o && this.Argument.PerformMatch(o.Argument, ref match);
 		}
 		internal override void CheckInvariant(ILPhase phase)
 		{
@@ -8088,8 +7994,7 @@ partial class ILInstruction
 	{
 		public bool MatchInvalidBranch()
 		{
-			var inst = this as InvalidBranch;
-			if (inst != null)
+			if (this is InvalidBranch inst)
 			{
 				return true;
 			}
@@ -8097,8 +8002,7 @@ public bool MatchInvalidBranch()
 		}
 		public bool MatchInvalidExpression()
 		{
-			var inst = this as InvalidExpression;
-			if (inst != null)
+			if (this is InvalidExpression inst)
 			{
 				return true;
 			}
@@ -8106,8 +8010,7 @@ public bool MatchInvalidExpression()
 		}
 		public bool MatchNop()
 		{
-			var inst = this as Nop;
-			if (inst != null)
+			if (this is Nop inst)
 			{
 				return true;
 			}
@@ -8115,8 +8018,7 @@ public bool MatchNop()
 		}
 		public bool MatchPinnedRegion(out ILVariable variable, out ILInstruction init, out ILInstruction body)
 		{
-			var inst = this as PinnedRegion;
-			if (inst != null)
+			if (this is PinnedRegion inst)
 			{
 				variable = inst.Variable;
 				init = inst.Init;
@@ -8130,8 +8032,7 @@ public bool MatchPinnedRegion(out ILVariable variable, out ILInstruction init, o
 		}
 		public bool MatchArglist()
 		{
-			var inst = this as Arglist;
-			if (inst != null)
+			if (this is Arglist inst)
 			{
 				return true;
 			}
@@ -8139,8 +8040,7 @@ public bool MatchArglist()
 		}
 		public bool MatchTryCatchHandler(out ILInstruction filter, out ILInstruction body, out ILVariable variable)
 		{
-			var inst = this as TryCatchHandler;
-			if (inst != null)
+			if (this is TryCatchHandler inst)
 			{
 				filter = inst.Filter;
 				body = inst.Body;
@@ -8154,8 +8054,7 @@ public bool MatchTryCatchHandler(out ILInstruction filter, out ILInstruction bod
 		}
 		public bool MatchLockInstruction(out ILInstruction onExpression, out ILInstruction body)
 		{
-			var inst = this as LockInstruction;
-			if (inst != null)
+			if (this is LockInstruction inst)
 			{
 				onExpression = inst.OnExpression;
 				body = inst.Body;
@@ -8167,8 +8066,7 @@ public bool MatchLockInstruction(out ILInstruction onExpression, out ILInstructi
 		}
 		public bool MatchUsingInstruction(out ILVariable variable, out ILInstruction resourceExpression, out ILInstruction body)
 		{
-			var inst = this as UsingInstruction;
-			if (inst != null)
+			if (this is UsingInstruction inst)
 			{
 				variable = inst.Variable;
 				resourceExpression = inst.ResourceExpression;
@@ -8182,8 +8080,7 @@ public bool MatchUsingInstruction(out ILVariable variable, out ILInstruction res
 		}
 		public bool MatchDebugBreak()
 		{
-			var inst = this as DebugBreak;
-			if (inst != null)
+			if (this is DebugBreak inst)
 			{
 				return true;
 			}
@@ -8191,8 +8088,7 @@ public bool MatchDebugBreak()
 		}
 		public bool MatchCkfinite(out ILInstruction argument)
 		{
-			var inst = this as Ckfinite;
-			if (inst != null)
+			if (this is Ckfinite inst)
 			{
 				argument = inst.Argument;
 				return true;
@@ -8202,8 +8098,7 @@ public bool MatchCkfinite(out ILInstruction argument)
 		}
 		public bool MatchLdLoc(out ILVariable variable)
 		{
-			var inst = this as LdLoc;
-			if (inst != null)
+			if (this is LdLoc inst)
 			{
 				variable = inst.Variable;
 				return true;
@@ -8213,8 +8108,7 @@ public bool MatchLdLoc(out ILVariable variable)
 		}
 		public bool MatchLdLoca(out ILVariable variable)
 		{
-			var inst = this as LdLoca;
-			if (inst != null)
+			if (this is LdLoca inst)
 			{
 				variable = inst.Variable;
 				return true;
@@ -8224,8 +8118,7 @@ public bool MatchLdLoca(out ILVariable variable)
 		}
 		public bool MatchStLoc(out ILVariable variable, out ILInstruction value)
 		{
-			var inst = this as StLoc;
-			if (inst != null)
+			if (this is StLoc inst)
 			{
 				variable = inst.Variable;
 				value = inst.Value;
@@ -8237,8 +8130,7 @@ public bool MatchStLoc(out ILVariable variable, out ILInstruction value)
 		}
 		public bool MatchAddressOf(out ILInstruction value, out IType type)
 		{
-			var inst = this as AddressOf;
-			if (inst != null)
+			if (this is AddressOf inst)
 			{
 				value = inst.Value;
 				type = inst.Type;
@@ -8250,8 +8142,7 @@ public bool MatchAddressOf(out ILInstruction value, out IType type)
 		}
 		public bool MatchThreeValuedBoolAnd(out ILInstruction left, out ILInstruction right)
 		{
-			var inst = this as ThreeValuedBoolAnd;
-			if (inst != null)
+			if (this is ThreeValuedBoolAnd inst)
 			{
 				left = inst.Left;
 				right = inst.Right;
@@ -8263,8 +8154,7 @@ public bool MatchThreeValuedBoolAnd(out ILInstruction left, out ILInstruction ri
 		}
 		public bool MatchThreeValuedBoolOr(out ILInstruction left, out ILInstruction right)
 		{
-			var inst = this as ThreeValuedBoolOr;
-			if (inst != null)
+			if (this is ThreeValuedBoolOr inst)
 			{
 				left = inst.Left;
 				right = inst.Right;
@@ -8276,8 +8166,7 @@ public bool MatchThreeValuedBoolOr(out ILInstruction left, out ILInstruction rig
 		}
 		public bool MatchNullableRewrap(out ILInstruction argument)
 		{
-			var inst = this as NullableRewrap;
-			if (inst != null)
+			if (this is NullableRewrap inst)
 			{
 				argument = inst.Argument;
 				return true;
@@ -8287,8 +8176,7 @@ public bool MatchNullableRewrap(out ILInstruction argument)
 		}
 		public bool MatchLdStr(out string value)
 		{
-			var inst = this as LdStr;
-			if (inst != null)
+			if (this is LdStr inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8298,8 +8186,7 @@ public bool MatchLdStr(out string value)
 		}
 		public bool MatchLdcI4(out int value)
 		{
-			var inst = this as LdcI4;
-			if (inst != null)
+			if (this is LdcI4 inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8309,8 +8196,7 @@ public bool MatchLdcI4(out int value)
 		}
 		public bool MatchLdcI8(out long value)
 		{
-			var inst = this as LdcI8;
-			if (inst != null)
+			if (this is LdcI8 inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8320,8 +8206,7 @@ public bool MatchLdcI8(out long value)
 		}
 		public bool MatchLdcF4(out float value)
 		{
-			var inst = this as LdcF4;
-			if (inst != null)
+			if (this is LdcF4 inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8331,8 +8216,7 @@ public bool MatchLdcF4(out float value)
 		}
 		public bool MatchLdcF8(out double value)
 		{
-			var inst = this as LdcF8;
-			if (inst != null)
+			if (this is LdcF8 inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8342,8 +8226,7 @@ public bool MatchLdcF8(out double value)
 		}
 		public bool MatchLdcDecimal(out decimal value)
 		{
-			var inst = this as LdcDecimal;
-			if (inst != null)
+			if (this is LdcDecimal inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8353,8 +8236,7 @@ public bool MatchLdcDecimal(out decimal value)
 		}
 		public bool MatchLdNull()
 		{
-			var inst = this as LdNull;
-			if (inst != null)
+			if (this is LdNull inst)
 			{
 				return true;
 			}
@@ -8362,8 +8244,7 @@ public bool MatchLdNull()
 		}
 		public bool MatchLdFtn(out IMethod method)
 		{
-			var inst = this as LdFtn;
-			if (inst != null)
+			if (this is LdFtn inst)
 			{
 				method = inst.Method;
 				return true;
@@ -8373,8 +8254,7 @@ public bool MatchLdFtn(out IMethod method)
 		}
 		public bool MatchLdVirtFtn(out ILInstruction argument, out IMethod method)
 		{
-			var inst = this as LdVirtFtn;
-			if (inst != null)
+			if (this is LdVirtFtn inst)
 			{
 				argument = inst.Argument;
 				method = inst.Method;
@@ -8386,8 +8266,7 @@ public bool MatchLdVirtFtn(out ILInstruction argument, out IMethod method)
 		}
 		public bool MatchLdVirtDelegate(out ILInstruction argument, out IType type, out IMethod method)
 		{
-			var inst = this as LdVirtDelegate;
-			if (inst != null)
+			if (this is LdVirtDelegate inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8401,8 +8280,7 @@ public bool MatchLdVirtDelegate(out ILInstruction argument, out IType type, out
 		}
 		public bool MatchLdTypeToken(out IType type)
 		{
-			var inst = this as LdTypeToken;
-			if (inst != null)
+			if (this is LdTypeToken inst)
 			{
 				type = inst.Type;
 				return true;
@@ -8412,8 +8290,7 @@ public bool MatchLdTypeToken(out IType type)
 		}
 		public bool MatchLdMemberToken(out IMember member)
 		{
-			var inst = this as LdMemberToken;
-			if (inst != null)
+			if (this is LdMemberToken inst)
 			{
 				member = inst.Member;
 				return true;
@@ -8423,8 +8300,7 @@ public bool MatchLdMemberToken(out IMember member)
 		}
 		public bool MatchLocAlloc(out ILInstruction argument)
 		{
-			var inst = this as LocAlloc;
-			if (inst != null)
+			if (this is LocAlloc inst)
 			{
 				argument = inst.Argument;
 				return true;
@@ -8434,8 +8310,7 @@ public bool MatchLocAlloc(out ILInstruction argument)
 		}
 		public bool MatchLocAllocSpan(out ILInstruction argument, out IType type)
 		{
-			var inst = this as LocAllocSpan;
-			if (inst != null)
+			if (this is LocAllocSpan inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8447,8 +8322,7 @@ public bool MatchLocAllocSpan(out ILInstruction argument, out IType type)
 		}
 		public bool MatchCpblk(out ILInstruction destAddress, out ILInstruction sourceAddress, out ILInstruction size)
 		{
-			var inst = this as Cpblk;
-			if (inst != null)
+			if (this is Cpblk inst)
 			{
 				destAddress = inst.DestAddress;
 				sourceAddress = inst.SourceAddress;
@@ -8462,8 +8336,7 @@ public bool MatchCpblk(out ILInstruction destAddress, out ILInstruction sourceAd
 		}
 		public bool MatchInitblk(out ILInstruction address, out ILInstruction value, out ILInstruction size)
 		{
-			var inst = this as Initblk;
-			if (inst != null)
+			if (this is Initblk inst)
 			{
 				address = inst.Address;
 				value = inst.Value;
@@ -8477,8 +8350,7 @@ public bool MatchInitblk(out ILInstruction address, out ILInstruction value, out
 		}
 		public bool MatchLdFlda(out ILInstruction target, out IField field)
 		{
-			var inst = this as LdFlda;
-			if (inst != null)
+			if (this is LdFlda inst)
 			{
 				target = inst.Target;
 				field = inst.Field;
@@ -8490,8 +8362,7 @@ public bool MatchLdFlda(out ILInstruction target, out IField field)
 		}
 		public bool MatchLdsFlda(out IField field)
 		{
-			var inst = this as LdsFlda;
-			if (inst != null)
+			if (this is LdsFlda inst)
 			{
 				field = inst.Field;
 				return true;
@@ -8501,8 +8372,7 @@ public bool MatchLdsFlda(out IField field)
 		}
 		public bool MatchCastClass(out ILInstruction argument, out IType type)
 		{
-			var inst = this as CastClass;
-			if (inst != null)
+			if (this is CastClass inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8514,8 +8384,7 @@ public bool MatchCastClass(out ILInstruction argument, out IType type)
 		}
 		public bool MatchIsInst(out ILInstruction argument, out IType type)
 		{
-			var inst = this as IsInst;
-			if (inst != null)
+			if (this is IsInst inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8527,8 +8396,7 @@ public bool MatchIsInst(out ILInstruction argument, out IType type)
 		}
 		public bool MatchLdObj(out ILInstruction target, out IType type)
 		{
-			var inst = this as LdObj;
-			if (inst != null)
+			if (this is LdObj inst)
 			{
 				target = inst.Target;
 				type = inst.Type;
@@ -8540,8 +8408,7 @@ public bool MatchLdObj(out ILInstruction target, out IType type)
 		}
 		public bool MatchStObj(out ILInstruction target, out ILInstruction value, out IType type)
 		{
-			var inst = this as StObj;
-			if (inst != null)
+			if (this is StObj inst)
 			{
 				target = inst.Target;
 				value = inst.Value;
@@ -8555,8 +8422,7 @@ public bool MatchStObj(out ILInstruction target, out ILInstruction value, out IT
 		}
 		public bool MatchBox(out ILInstruction argument, out IType type)
 		{
-			var inst = this as Box;
-			if (inst != null)
+			if (this is Box inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8568,8 +8434,7 @@ public bool MatchBox(out ILInstruction argument, out IType type)
 		}
 		public bool MatchUnbox(out ILInstruction argument, out IType type)
 		{
-			var inst = this as Unbox;
-			if (inst != null)
+			if (this is Unbox inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8581,8 +8446,7 @@ public bool MatchUnbox(out ILInstruction argument, out IType type)
 		}
 		public bool MatchUnboxAny(out ILInstruction argument, out IType type)
 		{
-			var inst = this as UnboxAny;
-			if (inst != null)
+			if (this is UnboxAny inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8594,8 +8458,7 @@ public bool MatchUnboxAny(out ILInstruction argument, out IType type)
 		}
 		public bool MatchNewArr(out IType type)
 		{
-			var inst = this as NewArr;
-			if (inst != null)
+			if (this is NewArr inst)
 			{
 				type = inst.Type;
 				return true;
@@ -8605,8 +8468,7 @@ public bool MatchNewArr(out IType type)
 		}
 		public bool MatchDefaultValue(out IType type)
 		{
-			var inst = this as DefaultValue;
-			if (inst != null)
+			if (this is DefaultValue inst)
 			{
 				type = inst.Type;
 				return true;
@@ -8616,8 +8478,7 @@ public bool MatchDefaultValue(out IType type)
 		}
 		public bool MatchThrow(out ILInstruction argument)
 		{
-			var inst = this as Throw;
-			if (inst != null)
+			if (this is Throw inst)
 			{
 				argument = inst.Argument;
 				return true;
@@ -8627,8 +8488,7 @@ public bool MatchThrow(out ILInstruction argument)
 		}
 		public bool MatchRethrow()
 		{
-			var inst = this as Rethrow;
-			if (inst != null)
+			if (this is Rethrow inst)
 			{
 				return true;
 			}
@@ -8636,8 +8496,7 @@ public bool MatchRethrow()
 		}
 		public bool MatchSizeOf(out IType type)
 		{
-			var inst = this as SizeOf;
-			if (inst != null)
+			if (this is SizeOf inst)
 			{
 				type = inst.Type;
 				return true;
@@ -8647,8 +8506,7 @@ public bool MatchSizeOf(out IType type)
 		}
 		public bool MatchLdElema(out IType type, out ILInstruction array)
 		{
-			var inst = this as LdElema;
-			if (inst != null)
+			if (this is LdElema inst)
 			{
 				type = inst.Type;
 				array = inst.Array;
@@ -8660,8 +8518,7 @@ public bool MatchLdElema(out IType type, out ILInstruction array)
 		}
 		public bool MatchGetPinnableReference(out ILInstruction argument, out IMethod method)
 		{
-			var inst = this as GetPinnableReference;
-			if (inst != null)
+			if (this is GetPinnableReference inst)
 			{
 				argument = inst.Argument;
 				method = inst.Method;
@@ -8673,8 +8530,7 @@ public bool MatchGetPinnableReference(out ILInstruction argument, out IMethod me
 		}
 		public bool MatchUserDefinedLogicOperator(out IMethod method, out ILInstruction left, out ILInstruction right)
 		{
-			var inst = this as UserDefinedLogicOperator;
-			if (inst != null)
+			if (this is UserDefinedLogicOperator inst)
 			{
 				method = inst.Method;
 				left = inst.Left;
@@ -8688,8 +8544,7 @@ public bool MatchUserDefinedLogicOperator(out IMethod method, out ILInstruction
 		}
 		public bool MatchMatchInstruction(out ILVariable variable, out IMethod method, out ILInstruction testedOperand)
 		{
-			var inst = this as MatchInstruction;
-			if (inst != null)
+			if (this is MatchInstruction inst)
 			{
 				variable = inst.Variable;
 				method = inst.Method;
@@ -8703,8 +8558,7 @@ public bool MatchMatchInstruction(out ILVariable variable, out IMethod method, o
 		}
 		public bool MatchMakeRefAny(out ILInstruction argument, out IType type)
 		{
-			var inst = this as MakeRefAny;
-			if (inst != null)
+			if (this is MakeRefAny inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8716,8 +8570,7 @@ public bool MatchMakeRefAny(out ILInstruction argument, out IType type)
 		}
 		public bool MatchRefAnyType(out ILInstruction argument)
 		{
-			var inst = this as RefAnyType;
-			if (inst != null)
+			if (this is RefAnyType inst)
 			{
 				argument = inst.Argument;
 				return true;
@@ -8727,8 +8580,7 @@ public bool MatchRefAnyType(out ILInstruction argument)
 		}
 		public bool MatchRefAnyValue(out ILInstruction argument, out IType type)
 		{
-			var inst = this as RefAnyValue;
-			if (inst != null)
+			if (this is RefAnyValue inst)
 			{
 				argument = inst.Argument;
 				type = inst.Type;
@@ -8740,8 +8592,7 @@ public bool MatchRefAnyValue(out ILInstruction argument, out IType type)
 		}
 		public bool MatchYieldReturn(out ILInstruction value)
 		{
-			var inst = this as YieldReturn;
-			if (inst != null)
+			if (this is YieldReturn inst)
 			{
 				value = inst.Value;
 				return true;
@@ -8751,8 +8602,7 @@ public bool MatchYieldReturn(out ILInstruction value)
 		}
 		public bool MatchAwait(out ILInstruction value)
 		{
-			var inst = this as Await;
-			if (inst != null)
+			if (this is Await inst)
 			{
 				value = inst.Value;
 				return true;
diff --git a/ICSharpCode.Decompiler/IL/Instructions/Branch.cs b/ICSharpCode.Decompiler/IL/Instructions/Branch.cs
index 4eda178cb..43108d163 100644
--- a/ICSharpCode.Decompiler/IL/Instructions/Branch.cs
+++ b/ICSharpCode.Decompiler/IL/Instructions/Branch.cs
@@ -80,7 +80,7 @@ protected override void Disconnected()
 		}
 
 		public string TargetLabel {
-			get { return targetBlock != null ? targetBlock.Label : string.Format("IL_{0:x4}", TargetILOffset); }
+			get { return targetBlock != null ? targetBlock.Label : $"IL_{TargetILOffset:x4}"; }
 		}
 
 		/// <summary>
diff --git a/ICSharpCode.Decompiler/IL/Instructions/CallInstruction.cs b/ICSharpCode.Decompiler/IL/Instructions/CallInstruction.cs
index 6e87d9c4e..deb57e4c0 100644
--- a/ICSharpCode.Decompiler/IL/Instructions/CallInstruction.cs
+++ b/ICSharpCode.Decompiler/IL/Instructions/CallInstruction.cs
@@ -162,8 +162,7 @@ public override void WriteTo(ITextOutput output, ILAstWritingOptions options)
 
 		protected internal sealed override bool PerformMatch(ILInstruction other, ref Patterns.Match match)
 		{
-			CallInstruction o = other as CallInstruction;
-			return o != null && this.OpCode == o.OpCode && this.Method.Equals(o.Method) && this.IsTail == o.IsTail
+			return other is CallInstruction o && this.OpCode == o.OpCode && this.Method.Equals(o.Method) && this.IsTail == o.IsTail
 				&& object.Equals(this.ConstrainedTo, o.ConstrainedTo)
 				&& Patterns.ListMatch.DoMatch(this.Arguments, o.Arguments, ref match);
 		}
diff --git a/ICSharpCode.Decompiler/IL/Instructions/PatternMatching.cs b/ICSharpCode.Decompiler/IL/Instructions/PatternMatching.cs
index 5c245dcdc..b45fa0036 100644
--- a/ICSharpCode.Decompiler/IL/Instructions/PatternMatching.cs
+++ b/ICSharpCode.Decompiler/IL/Instructions/PatternMatching.cs
@@ -75,14 +75,12 @@ public bool MatchLdcI(long val)
 
 		public bool MatchLdLoc(ILVariable variable)
 		{
-			var inst = this as LdLoc;
-			return inst != null && inst.Variable == variable;
+			return this is LdLoc inst && inst.Variable == variable;
 		}
 
 		public bool MatchLdLoca(ILVariable variable)
 		{
-			var inst = this as LdLoca;
-			return inst != null && inst.Variable == variable;
+			return this is LdLoca inst && inst.Variable == variable;
 		}
 
 		/// <summary>
@@ -114,14 +112,12 @@ public bool MatchLdLocRef(out ILVariable variable)
 
 		public bool MatchLdThis()
 		{
-			var inst = this as LdLoc;
-			return inst != null && inst.Variable.Kind == VariableKind.Parameter && inst.Variable.Index < 0;
+			return this is LdLoc inst && inst.Variable.Kind == VariableKind.Parameter && inst.Variable.Index < 0;
 		}
 
 		public bool MatchStLoc(out ILVariable variable)
 		{
-			var inst = this as StLoc;
-			if (inst != null)
+			if (this is StLoc inst)
 			{
 				variable = inst.Variable;
 				return true;
@@ -132,8 +128,7 @@ public bool MatchStLoc(out ILVariable variable)
 
 		public bool MatchStLoc(ILVariable variable, out ILInstruction value)
 		{
-			var inst = this as StLoc;
-			if (inst != null && inst.Variable == variable)
+			if (this is StLoc inst && inst.Variable == variable)
 			{
 				value = inst.Value;
 				return true;
@@ -144,8 +139,7 @@ public bool MatchStLoc(ILVariable variable, out ILInstruction value)
 
 		public bool MatchLdLen(StackType type, out ILInstruction array)
 		{
-			var inst = this as LdLen;
-			if (inst != null && inst.ResultType == type)
+			if (this is LdLen inst && inst.ResultType == type)
 			{
 				array = inst.Array;
 				return true;
@@ -156,8 +150,7 @@ public bool MatchLdLen(StackType type, out ILInstruction array)
 
 		public bool MatchReturn(out ILInstruction value)
 		{
-			var inst = this as Leave;
-			if (inst != null && inst.IsLeavingFunction)
+			if (this is Leave inst && inst.IsLeavingFunction)
 			{
 				value = inst.Value;
 				return true;
@@ -168,8 +161,7 @@ public bool MatchReturn(out ILInstruction value)
 
 		public bool MatchBranch(out Block targetBlock)
 		{
-			var inst = this as Branch;
-			if (inst != null)
+			if (this is Branch inst)
 			{
 				targetBlock = inst.TargetBlock;
 				return true;
@@ -180,14 +172,12 @@ public bool MatchBranch(out Block targetBlock)
 
 		public bool MatchBranch(Block targetBlock)
 		{
-			var inst = this as Branch;
-			return inst != null && inst.TargetBlock == targetBlock;
+			return this is Branch inst && inst.TargetBlock == targetBlock;
 		}
 
 		public bool MatchLeave(out BlockContainer targetContainer, out ILInstruction value)
 		{
-			var inst = this as Leave;
-			if (inst != null)
+			if (this is Leave inst)
 			{
 				targetContainer = inst.TargetContainer;
 				value = inst.Value;
@@ -200,8 +190,7 @@ public bool MatchLeave(out BlockContainer targetContainer, out ILInstruction val
 
 		public bool MatchLeave(BlockContainer targetContainer, out ILInstruction value)
 		{
-			var inst = this as Leave;
-			if (inst != null && targetContainer == inst.TargetContainer)
+			if (this is Leave inst && targetContainer == inst.TargetContainer)
 			{
 				value = inst.Value;
 				return true;
@@ -212,8 +201,7 @@ public bool MatchLeave(BlockContainer targetContainer, out ILInstruction value)
 
 		public bool MatchLeave(out BlockContainer targetContainer)
 		{
-			var inst = this as Leave;
-			if (inst != null && inst.Value.MatchNop())
+			if (this is Leave inst && inst.Value.MatchNop())
 			{
 				targetContainer = inst.TargetContainer;
 				return true;
@@ -224,14 +212,12 @@ public bool MatchLeave(out BlockContainer targetContainer)
 
 		public bool MatchLeave(BlockContainer targetContainer)
 		{
-			var inst = this as Leave;
-			return inst != null && inst.TargetContainer == targetContainer && inst.Value.MatchNop();
+			return this is Leave inst && inst.TargetContainer == targetContainer && inst.Value.MatchNop();
 		}
 
 		public bool MatchIfInstruction(out ILInstruction condition, out ILInstruction trueInst, out ILInstruction falseInst)
 		{
-			var inst = this as IfInstruction;
-			if (inst != null)
+			if (this is IfInstruction inst)
 			{
 				condition = inst.Condition;
 				trueInst = inst.TrueInst;
@@ -266,8 +252,7 @@ public bool MatchIfInstructionPositiveCondition(out ILInstruction condition, out
 		/// </summary>
 		public bool MatchIfInstruction(out ILInstruction condition, out ILInstruction trueInst)
 		{
-			var inst = this as IfInstruction;
-			if (inst != null && inst.FalseInst.MatchNop())
+			if (this is IfInstruction inst && inst.FalseInst.MatchNop())
 			{
 				condition = inst.Condition;
 				trueInst = inst.TrueInst;
@@ -285,8 +270,7 @@ public bool MatchIfInstruction(out ILInstruction condition, out ILInstruction tr
 		/// </summary>
 		public bool MatchLogicAnd(out ILInstruction lhs, out ILInstruction rhs)
 		{
-			var inst = this as IfInstruction;
-			if (inst != null && inst.FalseInst.MatchLdcI4(0))
+			if (this is IfInstruction inst && inst.FalseInst.MatchLdcI4(0))
 			{
 				lhs = inst.Condition;
 				rhs = inst.TrueInst;
@@ -304,8 +288,7 @@ public bool MatchLogicAnd(out ILInstruction lhs, out ILInstruction rhs)
 		/// </summary>
 		public bool MatchLogicOr(out ILInstruction lhs, out ILInstruction rhs)
 		{
-			var inst = this as IfInstruction;
-			if (inst != null && inst.TrueInst.MatchLdcI4(1))
+			if (this is IfInstruction inst && inst.TrueInst.MatchLdcI4(1))
 			{
 				lhs = inst.Condition;
 				rhs = inst.FalseInst;
@@ -334,8 +317,7 @@ public bool MatchLogicNot(out ILInstruction arg)
 
 		public bool MatchTryCatchHandler(out ILVariable variable)
 		{
-			var inst = this as TryCatchHandler;
-			if (inst != null)
+			if (this is TryCatchHandler inst)
 			{
 				variable = inst.Variable;
 				return true;
@@ -518,14 +500,12 @@ public bool MatchStFld(out ILInstruction target, out IField field, out ILInstruc
 
 		public bool MatchBinaryNumericInstruction(BinaryNumericOperator @operator)
 		{
-			var op = this as BinaryNumericInstruction;
-			return op != null && op.Operator == @operator;
+			return this is BinaryNumericInstruction op && op.Operator == @operator;
 		}
 
 		public bool MatchBinaryNumericInstruction(BinaryNumericOperator @operator, out ILInstruction left, out ILInstruction right)
 		{
-			var op = this as BinaryNumericInstruction;
-			if (op != null && op.Operator == @operator)
+			if (this is BinaryNumericInstruction op && op.Operator == @operator)
 			{
 				left = op.Left;
 				right = op.Right;
@@ -538,8 +518,7 @@ public bool MatchBinaryNumericInstruction(BinaryNumericOperator @operator, out I
 
 		public bool MatchBinaryNumericInstruction(out BinaryNumericOperator @operator, out ILInstruction left, out ILInstruction right)
 		{
-			var op = this as BinaryNumericInstruction;
-			if (op != null)
+			if (this is BinaryNumericInstruction op)
 			{
 				@operator = op.Operator;
 				left = op.Left;
diff --git a/ICSharpCode.Decompiler/IL/Transforms/TransformCollectionAndObjectInitializers.cs b/ICSharpCode.Decompiler/IL/Transforms/TransformCollectionAndObjectInitializers.cs
index 38e9f233b..f2dcd4b4a 100644
--- a/ICSharpCode.Decompiler/IL/Transforms/TransformCollectionAndObjectInitializers.cs
+++ b/ICSharpCode.Decompiler/IL/Transforms/TransformCollectionAndObjectInitializers.cs
@@ -481,8 +481,8 @@ static IType GetReturnTypeFromInstruction(ILInstruction instruction)
 
 		public override bool Equals(object obj)
 		{
-			if (obj is AccessPathElement)
-				return Equals((AccessPathElement)obj);
+			if (obj is AccessPathElement accessPathElement)
+				return Equals(accessPathElement);
 			return false;
 		}
 
diff --git a/ICSharpCode.Decompiler/IL/Transforms/TransformExpressionTrees.cs b/ICSharpCode.Decompiler/IL/Transforms/TransformExpressionTrees.cs
index 29d4b2f39..d9006d4ac 100644
--- a/ICSharpCode.Decompiler/IL/Transforms/TransformExpressionTrees.cs
+++ b/ICSharpCode.Decompiler/IL/Transforms/TransformExpressionTrees.cs
@@ -737,8 +737,7 @@ Func<ILInstruction>[] ConvertCallArguments(IList<ILInstruction> arguments, IMeth
 					method = CSharpOperators.LiftUserDefinedOperator((IMethod)method);
 				return (() => new Call((IMethod)method) { Arguments = { left(), right() } }, isLiftedToNull != 0 ? NullableType.Create(method.Compilation, method.ReturnType) : method.ReturnType);
 			}
-			var rr = resolver.ResolveBinaryOperator(kind.ToBinaryOperatorType(), new ResolveResult(leftType), new ResolveResult(rightType)) as OperatorResolveResult;
-			if (rr != null && !rr.IsError && rr.UserDefinedOperatorMethod != null)
+			if (resolver.ResolveBinaryOperator(kind.ToBinaryOperatorType(), new ResolveResult(leftType), new ResolveResult(rightType)) is OperatorResolveResult rr && !rr.IsError && rr.UserDefinedOperatorMethod != null)
 			{
 				return (() => new Call(rr.UserDefinedOperatorMethod) { Arguments = { left(), right() } }, rr.UserDefinedOperatorMethod.ReturnType);
 			}
diff --git a/ICSharpCode.Decompiler/Metadata/LightJson/Serialization/TextScanner.cs b/ICSharpCode.Decompiler/Metadata/LightJson/Serialization/TextScanner.cs
index 363e51d1e..dba22c3c2 100644
--- a/ICSharpCode.Decompiler/Metadata/LightJson/Serialization/TextScanner.cs
+++ b/ICSharpCode.Decompiler/Metadata/LightJson/Serialization/TextScanner.cs
@@ -130,7 +130,7 @@ public void Assert(char next)
 			if (this.Read() != next)
 			{
 				throw new JsonParseException(
-					string.Format("Parser expected '{0}'", next),
+					$"Parser expected '{next}'",
 					ErrorType.InvalidOrUnexpectedCharacter,
 					errorPosition);
 			}
@@ -165,7 +165,7 @@ private void SkipComment()
 
 				default:
 					throw new JsonParseException(
-						string.Format("Parser expected '{0}'", this.Peek()),
+						$"Parser expected '{this.Peek()}'",
 						ErrorType.InvalidOrUnexpectedCharacter,
 						this.position);
 			}
diff --git a/ICSharpCode.Decompiler/Output/TextTokenWriter.cs b/ICSharpCode.Decompiler/Output/TextTokenWriter.cs
index 8ccf41ba2..a60d4c354 100644
--- a/ICSharpCode.Decompiler/Output/TextTokenWriter.cs
+++ b/ICSharpCode.Decompiler/Output/TextTokenWriter.cs
@@ -205,8 +205,7 @@ object GetCurrentLocalDefinition(Identifier id)
 
 			if (node is MethodDeclaration && node.Parent is LocalFunctionDeclarationStatement)
 			{
-				var localFunction = node.Parent.GetResolveResult() as MemberResolveResult;
-				if (localFunction != null)
+				if (node.Parent.GetResolveResult() is MemberResolveResult localFunction)
 					return localFunction.Member;
 			}
 
diff --git a/ICSharpCode.Decompiler/Semantics/Conversion.cs b/ICSharpCode.Decompiler/Semantics/Conversion.cs
index a92735b4f..11707dc80 100644
--- a/ICSharpCode.Decompiler/Semantics/Conversion.cs
+++ b/ICSharpCode.Decompiler/Semantics/Conversion.cs
@@ -170,8 +170,7 @@ public override string ToString()
 
 			public override bool Equals(Conversion other)
 			{
-				NumericOrEnumerationConversion o = other as NumericOrEnumerationConversion;
-				return o != null && isImplicit == o.isImplicit && isLifted == o.isLifted && isEnumeration == o.isEnumeration;
+				return other is NumericOrEnumerationConversion o && isImplicit == o.isImplicit && isLifted == o.isLifted && isEnumeration == o.isEnumeration;
 			}
 
 			public override int GetHashCode()
@@ -337,8 +336,7 @@ public UserDefinedConv(bool isImplicit, IMethod method, Conversion conversionBef
 
 			public override bool Equals(Conversion other)
 			{
-				UserDefinedConv o = other as UserDefinedConv;
-				return o != null && isLifted == o.isLifted && isImplicit == o.isImplicit && isValid == o.isValid && method.Equals(o.method);
+				return other is UserDefinedConv o && isLifted == o.isLifted && isImplicit == o.isImplicit && isValid == o.isValid && method.Equals(o.method);
 			}
 
 			public override int GetHashCode()
@@ -396,8 +394,7 @@ public MethodGroupConv(IMethod method, bool isVirtualMethodLookup, bool delegate
 
 			public override bool Equals(Conversion other)
 			{
-				MethodGroupConv o = other as MethodGroupConv;
-				return o != null && method.Equals(o.method);
+				return other is MethodGroupConv o && method.Equals(o.method);
 			}
 
 			public override int GetHashCode()
diff --git a/ICSharpCode.Decompiler/Semantics/LocalResolveResult.cs b/ICSharpCode.Decompiler/Semantics/LocalResolveResult.cs
index ac8be7989..3b5a8af06 100644
--- a/ICSharpCode.Decompiler/Semantics/LocalResolveResult.cs
+++ b/ICSharpCode.Decompiler/Semantics/LocalResolveResult.cs
@@ -43,8 +43,7 @@ static IType UnpackTypeIfByRefParameter(IVariable variable)
 			IType type = variable.Type;
 			if (type.Kind == TypeKind.ByReference)
 			{
-				IParameter p = variable as IParameter;
-				if (p != null && p.ReferenceKind != ReferenceKind.None)
+				if (variable is IParameter p && p.ReferenceKind != ReferenceKind.None)
 					return ((ByReferenceType)type).ElementType;
 			}
 			return type;
diff --git a/ICSharpCode.Decompiler/TypeSystem/ArrayType.cs b/ICSharpCode.Decompiler/TypeSystem/ArrayType.cs
index f10da4531..edbf5c980 100644
--- a/ICSharpCode.Decompiler/TypeSystem/ArrayType.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/ArrayType.cs
@@ -87,8 +87,7 @@ public override int GetHashCode()
 
 		public override bool Equals(IType other)
 		{
-			ArrayType a = other as ArrayType;
-			return a != null && elementType.Equals(a.elementType) && a.dimensions == dimensions && a.nullability == nullability;
+			return other is ArrayType a && elementType.Equals(a.elementType) && a.dimensions == dimensions && a.nullability == nullability;
 		}
 
 		public override string ToString()
@@ -216,8 +215,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			ArrayTypeReference o = other as ArrayTypeReference;
-			return o != null && elementType == o.elementType && dimensions == o.dimensions;
+			return other is ArrayTypeReference o && elementType == o.elementType && dimensions == o.dimensions;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/TypeSystem/ByReferenceType.cs b/ICSharpCode.Decompiler/TypeSystem/ByReferenceType.cs
index 1b686012e..d18169ed5 100644
--- a/ICSharpCode.Decompiler/TypeSystem/ByReferenceType.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/ByReferenceType.cs
@@ -51,8 +51,7 @@ public override int GetHashCode()
 
 		public override bool Equals(IType other)
 		{
-			ByReferenceType a = other as ByReferenceType;
-			return a != null && elementType.Equals(a.elementType);
+			return other is ByReferenceType a && elementType.Equals(a.elementType);
 		}
 
 		public override IType AcceptVisitor(TypeVisitor visitor)
@@ -103,8 +102,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			ByReferenceTypeReference brt = other as ByReferenceTypeReference;
-			return brt != null && this.elementType == brt.elementType;
+			return other is ByReferenceTypeReference brt && this.elementType == brt.elementType;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/AbstractFreezable.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/AbstractFreezable.cs
index aca56d7e3..77ec0d440 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/AbstractFreezable.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/AbstractFreezable.cs
@@ -61,8 +61,7 @@ public static IList<T> FreezeList<T>(IList<T> list)
 
 		public static void Freeze(object item)
 		{
-			IFreezable f = item as IFreezable;
-			if (f != null)
+			if (item is IFreezable f)
 				f.Freeze();
 		}
 
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/DefaultAssemblyReference.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/DefaultAssemblyReference.cs
index 6c1b4519c..5dca45fb9 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/DefaultAssemblyReference.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/DefaultAssemblyReference.cs
@@ -67,8 +67,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			DefaultAssemblyReference o = other as DefaultAssemblyReference;
-			return o != null && shortName == o.shortName;
+			return other is DefaultAssemblyReference o && shortName == o.shortName;
 		}
 
 		[Serializable]
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/GetClassTypeReference.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/GetClassTypeReference.cs
index 0c161ca5c..d4595cfcd 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/GetClassTypeReference.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/GetClassTypeReference.cs
@@ -147,8 +147,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			GetClassTypeReference o = other as GetClassTypeReference;
-			return o != null && module == o.module && fullTypeName == o.fullTypeName && isReferenceType == o.isReferenceType;
+			return other is GetClassTypeReference o && module == o.module && fullTypeName == o.fullTypeName && isReferenceType == o.isReferenceType;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/LocalFunctionMethod.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/LocalFunctionMethod.cs
index 240ccaed8..cf8ddf6e8 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/LocalFunctionMethod.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/LocalFunctionMethod.cs
@@ -70,7 +70,7 @@ public override int GetHashCode()
 
 		public override string ToString()
 		{
-			return string.Format("[LocalFunctionMethod: ReducedFrom={0}, Name={1}, NumberOfGeneratedParameters={2}, NumberOfCompilerGeneratedTypeParameters={3}, IsStaticLocalFunction={4}]", ReducedFrom, Name, NumberOfCompilerGeneratedParameters, NumberOfCompilerGeneratedTypeParameters, IsStaticLocalFunction);
+			return $"[LocalFunctionMethod: ReducedFrom={ReducedFrom}, Name={Name}, NumberOfGeneratedParameters={NumberOfCompilerGeneratedParameters}, NumberOfCompilerGeneratedTypeParameters={NumberOfCompilerGeneratedTypeParameters}, IsStaticLocalFunction={IsStaticLocalFunction}]";
 		}
 
 		internal int NumberOfCompilerGeneratedParameters { get; }
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/NestedTypeReference.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/NestedTypeReference.cs
index 2380c7730..0ba9a0d69 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/NestedTypeReference.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/NestedTypeReference.cs
@@ -67,8 +67,7 @@ public NestedTypeReference(ITypeReference declaringTypeRef, string name, int add
 
 		public IType Resolve(ITypeResolveContext context)
 		{
-			ITypeDefinition declaringType = declaringTypeRef.Resolve(context) as ITypeDefinition;
-			if (declaringType != null)
+			if (declaringTypeRef.Resolve(context) is ITypeDefinition declaringType)
 			{
 				int tpc = declaringType.TypeParameterCount;
 				foreach (IType type in declaringType.NestedTypes)
@@ -95,8 +94,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			NestedTypeReference o = other as NestedTypeReference;
-			return o != null && declaringTypeRef == o.declaringTypeRef && name == o.name
+			return other is NestedTypeReference o && declaringTypeRef == o.declaringTypeRef && name == o.name
 				&& additionalTypeParameterCount == o.additionalTypeParameterCount
 				&& isReferenceType == o.isReferenceType;
 		}
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/SpecializedMethod.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/SpecializedMethod.cs
index e72d6eeb7..0df66b9ea 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/SpecializedMethod.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/SpecializedMethod.cs
@@ -270,8 +270,7 @@ public override int GetHashCode()
 			public override bool Equals(IType other)
 			{
 				// Compare the owner, not the substitution, because the substitution may contain this specialized type parameter recursively
-				SpecializedTypeParameter o = other as SpecializedTypeParameter;
-				return o != null && baseTp.Equals(o.baseTp) && this.Owner.Equals(o.Owner);
+				return other is SpecializedTypeParameter o && baseTp.Equals(o.baseTp) && this.Owner.Equals(o.Owner);
 			}
 
 			public override bool HasValueTypeConstraint => baseTp.HasValueTypeConstraint;
diff --git a/ICSharpCode.Decompiler/TypeSystem/Implementation/TypeParameterReference.cs b/ICSharpCode.Decompiler/TypeSystem/Implementation/TypeParameterReference.cs
index c8d943477..5cc18843f 100644
--- a/ICSharpCode.Decompiler/TypeSystem/Implementation/TypeParameterReference.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/Implementation/TypeParameterReference.cs
@@ -70,8 +70,7 @@ public IType Resolve(ITypeResolveContext context)
 		{
 			if (ownerType == SymbolKind.Method)
 			{
-				IMethod method = context.CurrentMember as IMethod;
-				if (method != null && index < method.TypeParameters.Count)
+				if (context.CurrentMember is IMethod method && index < method.TypeParameters.Count)
 				{
 					return method.TypeParameters[index];
 				}
diff --git a/ICSharpCode.Decompiler/TypeSystem/InheritanceHelper.cs b/ICSharpCode.Decompiler/TypeSystem/InheritanceHelper.cs
index 365d2f900..a95df6b07 100644
--- a/ICSharpCode.Decompiler/TypeSystem/InheritanceHelper.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/InheritanceHelper.cs
@@ -121,8 +121,8 @@ public static IMember GetDerivedMember(IMember baseMember, ITypeDefinition deriv
 
 			baseMember = baseMember.MemberDefinition;
 			bool includeInterfaces = baseMember.DeclaringTypeDefinition.Kind == TypeKind.Interface;
-			IMethod method = baseMember as IMethod;
-			if (method != null)
+
+			if (baseMember is IMethod method)
 			{
 				foreach (IMethod derivedMethod in derivedType.Methods)
 				{
@@ -137,8 +137,8 @@ public static IMember GetDerivedMember(IMember baseMember, ITypeDefinition deriv
 					}
 				}
 			}
-			IProperty property = baseMember as IProperty;
-			if (property != null)
+
+			if (baseMember is IProperty property)
 			{
 				foreach (IProperty derivedProperty in derivedType.Properties)
 				{
diff --git a/ICSharpCode.Decompiler/TypeSystem/IntersectionType.cs b/ICSharpCode.Decompiler/TypeSystem/IntersectionType.cs
index 3db10f748..2a302cc19 100644
--- a/ICSharpCode.Decompiler/TypeSystem/IntersectionType.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/IntersectionType.cs
@@ -118,8 +118,7 @@ public override int GetHashCode()
 
 		public override bool Equals(IType other)
 		{
-			IntersectionType o = other as IntersectionType;
-			if (o != null && types.Count == o.types.Count)
+			if (other is IntersectionType o && types.Count == o.types.Count)
 			{
 				for (int i = 0; i < types.Count; i++)
 				{
diff --git a/ICSharpCode.Decompiler/TypeSystem/NullableType.cs b/ICSharpCode.Decompiler/TypeSystem/NullableType.cs
index 0fa461890..27933b064 100644
--- a/ICSharpCode.Decompiler/TypeSystem/NullableType.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/NullableType.cs
@@ -32,8 +32,7 @@ public static bool IsNullable(IType type)
 		{
 			if (type == null)
 				throw new ArgumentNullException(nameof(type));
-			ParameterizedType pt = type.SkipModifiers() as ParameterizedType;
-			return pt != null && pt.TypeParameterCount == 1 && pt.GenericType.IsKnownType(KnownTypeCode.NullableOfT);
+			return type.SkipModifiers() is ParameterizedType pt && pt.TypeParameterCount == 1 && pt.GenericType.IsKnownType(KnownTypeCode.NullableOfT);
 		}
 
 		public static bool IsNonNullableValueType(IType type)
@@ -49,8 +48,7 @@ public static IType GetUnderlyingType(IType type)
 		{
 			if (type == null)
 				throw new ArgumentNullException(nameof(type));
-			ParameterizedType pt = type.SkipModifiers() as ParameterizedType;
-			if (pt != null && pt.TypeParameterCount == 1 && pt.GenericType.IsKnownType(KnownTypeCode.NullableOfT))
+			if (type.SkipModifiers() is ParameterizedType pt && pt.TypeParameterCount == 1 && pt.GenericType.IsKnownType(KnownTypeCode.NullableOfT))
 				return pt.GetTypeArgument(0);
 			else
 				return type;
diff --git a/ICSharpCode.Decompiler/TypeSystem/ParameterizedType.cs b/ICSharpCode.Decompiler/TypeSystem/ParameterizedType.cs
index b20eba7de..4390aad97 100644
--- a/ICSharpCode.Decompiler/TypeSystem/ParameterizedType.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/ParameterizedType.cs
@@ -438,8 +438,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			ParameterizedTypeReference o = other as ParameterizedTypeReference;
-			if (o != null && genericType == o.genericType && typeArguments.Length == o.typeArguments.Length)
+			if (other is ParameterizedTypeReference o && genericType == o.genericType && typeArguments.Length == o.typeArguments.Length)
 			{
 				for (int i = 0; i < typeArguments.Length; i++)
 				{
diff --git a/ICSharpCode.Decompiler/TypeSystem/PointerType.cs b/ICSharpCode.Decompiler/TypeSystem/PointerType.cs
index 3de6cd4b7..b11885baa 100644
--- a/ICSharpCode.Decompiler/TypeSystem/PointerType.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/PointerType.cs
@@ -49,8 +49,7 @@ public override int GetHashCode()
 
 		public override bool Equals(IType other)
 		{
-			PointerType a = other as PointerType;
-			return a != null && elementType.Equals(a.elementType);
+			return other is PointerType a && elementType.Equals(a.elementType);
 		}
 
 		public override IType AcceptVisitor(TypeVisitor visitor)
@@ -101,8 +100,7 @@ int ISupportsInterning.GetHashCodeForInterning()
 
 		bool ISupportsInterning.EqualsForInterning(ISupportsInterning other)
 		{
-			PointerTypeReference o = other as PointerTypeReference;
-			return o != null && this.elementType == o.elementType;
+			return other is PointerTypeReference o && this.elementType == o.elementType;
 		}
 	}
 }
diff --git a/ICSharpCode.Decompiler/TypeSystem/ReflectionHelper.cs b/ICSharpCode.Decompiler/TypeSystem/ReflectionHelper.cs
index 4898ee5e1..b2c6e3cff 100644
--- a/ICSharpCode.Decompiler/TypeSystem/ReflectionHelper.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/ReflectionHelper.cs
@@ -215,8 +215,7 @@ public static ITypeReference ToTypeReference(this TypeCode typeCode)
 		/// </summary>
 		public static TypeCode GetTypeCode(this IType type)
 		{
-			ITypeDefinition def = type as ITypeDefinition;
-			if (def != null)
+			if (type is ITypeDefinition def)
 			{
 				KnownTypeCode typeCode = def.KnownTypeCode;
 				if (typeCode <= KnownTypeCode.String && typeCode != KnownTypeCode.Void)
diff --git a/ICSharpCode.Decompiler/TypeSystem/TypeSystemExtensions.cs b/ICSharpCode.Decompiler/TypeSystem/TypeSystemExtensions.cs
index 993804d95..0edce4e20 100644
--- a/ICSharpCode.Decompiler/TypeSystem/TypeSystemExtensions.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/TypeSystemExtensions.cs
@@ -513,21 +513,21 @@ public static ITypeDefinition GetTypeDefinition(this IModule module, string name
 		#region ResolveResult
 		public static ISymbol GetSymbol(this ResolveResult rr)
 		{
-			if (rr is LocalResolveResult)
+			if (rr is LocalResolveResult localResolveResult)
 			{
-				return ((LocalResolveResult)rr).Variable;
+				return localResolveResult.Variable;
 			}
-			else if (rr is MemberResolveResult)
+			else if (rr is MemberResolveResult memberResolveResult)
 			{
-				return ((MemberResolveResult)rr).Member;
+				return memberResolveResult.Member;
 			}
-			else if (rr is TypeResolveResult)
+			else if (rr is TypeResolveResult typeResolveResult)
 			{
-				return ((TypeResolveResult)rr).Type.GetDefinition();
+				return typeResolveResult.Type.GetDefinition();
 			}
-			else if (rr is ConversionResolveResult)
+			else if (rr is ConversionResolveResult conversionResolveResult)
 			{
-				return ((ConversionResolveResult)rr).Input.GetSymbol();
+				return conversionResolveResult.Input.GetSymbol();
 			}
 
 			return null;
@@ -545,8 +545,7 @@ public static IType GetElementTypeFromIEnumerable(this IType collectionType, ICo
 					KnownTypeCode typeCode = baseTypeDef.KnownTypeCode;
 					if (typeCode == KnownTypeCode.IEnumerableOfT || (allowIEnumerator && typeCode == KnownTypeCode.IEnumeratorOfT))
 					{
-						ParameterizedType pt = baseType as ParameterizedType;
-						if (pt != null)
+						if (baseType is ParameterizedType pt)
 						{
 							isGeneric = true;
 							return pt.GetTypeArgument(0);
diff --git a/ICSharpCode.Decompiler/TypeSystem/VarArgInstanceMethod.cs b/ICSharpCode.Decompiler/TypeSystem/VarArgInstanceMethod.cs
index eee269c66..b95ec7d30 100644
--- a/ICSharpCode.Decompiler/TypeSystem/VarArgInstanceMethod.cs
+++ b/ICSharpCode.Decompiler/TypeSystem/VarArgInstanceMethod.cs
@@ -60,8 +60,7 @@ public VarArgInstanceMethod(IMethod baseMethod, IEnumerable<IType> varArgTypes)
 
 		public override bool Equals(object obj)
 		{
-			VarArgInstanceMethod other = obj as VarArgInstanceMethod;
-			return other != null && baseMethod.Equals(other.baseMethod);
+			return obj is VarArgInstanceMethod other && baseMethod.Equals(other.baseMethod);
 		}
 
 		public override int GetHashCode()
@@ -71,8 +70,7 @@ public override int GetHashCode()
 
 		public bool Equals(IMember obj, TypeVisitor typeNormalization)
 		{
-			VarArgInstanceMethod other = obj as VarArgInstanceMethod;
-			return other != null && baseMethod.Equals(other.baseMethod, typeNormalization);
+			return obj is VarArgInstanceMethod other && baseMethod.Equals(other.baseMethod, typeNormalization);
 		}
 
 		public override string ToString()
diff --git a/ICSharpCode.Decompiler/Util/BusyManager.cs b/ICSharpCode.Decompiler/Util/BusyManager.cs
index f277fc40a..b08cb89ca 100644
--- a/ICSharpCode.Decompiler/Util/BusyManager.cs
+++ b/ICSharpCode.Decompiler/Util/BusyManager.cs
@@ -49,10 +49,7 @@ internal BusyLock(List<object> objectList)
 
 			public void Dispose()
 			{
-				if (objectList != null)
-				{
-					objectList.RemoveAt(objectList.Count - 1);
-				}
+				objectList?.RemoveAt(objectList.Count - 1);
 			}
 		}
 
diff --git a/ICSharpCode.Decompiler/Util/Interval.cs b/ICSharpCode.Decompiler/Util/Interval.cs
index 7dd74f64a..87be15a34 100644
--- a/ICSharpCode.Decompiler/Util/Interval.cs
+++ b/ICSharpCode.Decompiler/Util/Interval.cs
@@ -105,9 +105,9 @@ public Interval Intersect(Interval other)
 		public override string ToString()
 		{
 			if (End == int.MinValue)
-				return string.Format("[{0}..int.MaxValue]", Start);
+				return $"[{Start}..int.MaxValue]";
 			else
-				return string.Format("[{0}..{1})", Start, End);
+				return $"[{Start}..{End})";
 		}
 
 		#region Equals and GetHashCode implementation
diff --git a/ICSharpCode.Decompiler/Util/ResXResourceWriter.cs b/ICSharpCode.Decompiler/Util/ResXResourceWriter.cs
index fd86f9791..560abbf46 100644
--- a/ICSharpCode.Decompiler/Util/ResXResourceWriter.cs
+++ b/ICSharpCode.Decompiler/Util/ResXResourceWriter.cs
@@ -278,7 +278,7 @@ private void AddResource(string name, object value, string comment)
 			}
 
 			if (value != null && !value.GetType().IsSerializable)
-				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable.", name, value.GetType().Name));
+				throw new InvalidOperationException($"The element '{name}' of type '{value.GetType().Name}' is not serializable.");
 
 			TypeConverter converter = TypeDescriptor.GetConverter(value);
 
@@ -405,7 +405,7 @@ public void AddMetadata(string name, object value)
 				throw new ArgumentNullException(nameof(value));
 
 			if (!value.GetType().IsSerializable)
-				throw new InvalidOperationException(String.Format("The element '{0}' of type '{1}' is not serializable.", name, value.GetType().Name));
+				throw new InvalidOperationException($"The element '{name}' of type '{value.GetType().Name}' is not serializable.");
 
 			if (written)
 				throw new InvalidOperationException("The resource is already generated.");
