diff --git a/src/Microsoft.OData.Core/Buffers/BufferUtils.cs b/src/Microsoft.OData.Core/Buffers/BufferUtils.cs
index 10387bd71..62e7182d1 100644
--- a/src/Microsoft.OData.Core/Buffers/BufferUtils.cs
+++ b/src/Microsoft.OData.Core/Buffers/BufferUtils.cs
@@ -71,10 +71,7 @@ namespace Microsoft.OData.Buffers
         /// <param name="buffer">The character array should be returned.</param>
         public static void ReturnToBuffer(ICharArrayPool bufferPool, char[] buffer)
         {
-            if (bufferPool != null)
-            {
-                bufferPool.Return(buffer);
-            }
+            bufferPool?.Return(buffer);
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/EdmExtensionMethods.cs b/src/Microsoft.OData.Core/EdmExtensionMethods.cs
index 5ce6339cb..3c8900351 100644
--- a/src/Microsoft.OData.Core/EdmExtensionMethods.cs
+++ b/src/Microsoft.OData.Core/EdmExtensionMethods.cs
@@ -106,9 +106,8 @@ namespace Microsoft.OData
             {
                 return true;
             }
-
-            var currentContainedEntitySet = currentNavigationSource as IEdmContainedEntitySet;
-            if (currentContainedEntitySet != null && currentContainedEntitySet.NavigationProperty.Type.TypeKind() == EdmTypeKind.Collection)
+
+            if (currentNavigationSource is IEdmContainedEntitySet currentContainedEntitySet && currentContainedEntitySet.NavigationProperty.Type.TypeKind() == EdmTypeKind.Collection)
             {
                 return true;
             }
diff --git a/src/Microsoft.OData.Core/Evaluation/EdmValueUtils.cs b/src/Microsoft.OData.Core/Evaluation/EdmValueUtils.cs
index 121fc9f01..008f88ca6 100644
--- a/src/Microsoft.OData.Core/Evaluation/EdmValueUtils.cs
+++ b/src/Microsoft.OData.Core/Evaluation/EdmValueUtils.cs
@@ -57,22 +57,22 @@ namespace Microsoft.OData.Evaluation
                 return new EdmIntegerConstant(type, (sbyte)primitiveValue);
             }
 
-            if (primitiveValue is Int16)
+            if (primitiveValue is Int16 i)
             {
                 type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int16);
-                return new EdmIntegerConstant(type, (Int16)primitiveValue);
+                return new EdmIntegerConstant(type, i);
             }
 
-            if (primitiveValue is Int32)
+            if (primitiveValue is Int32 i)
             {
                 type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int32);
-                return new EdmIntegerConstant(type, (Int32)primitiveValue);
+                return new EdmIntegerConstant(type, i);
             }
 
-            if (primitiveValue is Int64)
+            if (primitiveValue is Int64 i)
             {
                 type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int64);
-                return new EdmIntegerConstant(type, (Int64)primitiveValue);
+                return new EdmIntegerConstant(type, i);
             }
 
             if (primitiveValue is Decimal)
@@ -82,20 +82,27 @@ namespace Microsoft.OData.Evaluation
                 return new EdmDecimalConstant(decimalType, (decimal)primitiveValue);
             }
 
-            if (primitiveValue is Single)
+            if (primitiveValue is Single single)
             {
                 type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Single);
-                return new EdmFloatingConstant(type, (Single)primitiveValue);
+                return new EdmFloatingConstant(type, single);
             }
 
-            if (primitiveValue is Double)
+            if (primitiveValue is Double d)
             {
                 type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Double);
-                return new EdmFloatingConstant(type, (Double)primitiveValue);
+                return new EdmFloatingConstant(type, d);
             }
-
+
+            if (
+/* Unmerged change from project 'Microsoft.OData.Core(net45)'
+Before:
             var str = primitiveValue as string;
             if (str != null)
+After:
+            if (primitiveValue is string str)
+*/
+primitiveValue is string str)
             {
                 var stringType =
                     (IEdmStringTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.String);
@@ -270,41 +277,40 @@ namespace Microsoft.OData.Evaluation
         /// <returns>The converted value.</returns>
         private static IEdmDelayedValue ConvertPrimitiveValueWithoutTypeCode(object primitiveValue, IEdmPrimitiveTypeReference type)
         {
-            byte[] bytes = primitiveValue as byte[];
-            if (bytes != null)
+            if (primitiveValue is byte[] bytes)
             {
                 IEdmBinaryTypeReference binaryType = (IEdmBinaryTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Binary);
                 return new EdmBinaryConstant(binaryType, bytes);
             }
 
-            if (primitiveValue is Date)
+            if (primitiveValue is Date date)
             {
                 IEdmPrimitiveTypeReference dateType = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Date);
-                return new EdmDateConstant(dateType, (Date)primitiveValue);
+                return new EdmDateConstant(dateType, date);
             }
 
-            if (primitiveValue is DateTimeOffset)
+            if (primitiveValue is DateTimeOffset dateTimeOffset)
             {
                 IEdmTemporalTypeReference dateTimeOffsetType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.DateTimeOffset);
-                return new EdmDateTimeOffsetConstant(dateTimeOffsetType, (DateTimeOffset)primitiveValue);
+                return new EdmDateTimeOffsetConstant(dateTimeOffsetType, dateTimeOffset);
             }
 
-            if (primitiveValue is Guid)
+            if (primitiveValue is Guid guid)
             {
                 type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Guid);
-                return new EdmGuidConstant(type, (Guid)primitiveValue);
+                return new EdmGuidConstant(type, guid);
             }
 
-            if (primitiveValue is TimeOfDay)
+            if (primitiveValue is TimeOfDay timeOfDay)
             {
                 IEdmTemporalTypeReference timeOfDayType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.TimeOfDay);
-                return new EdmTimeOfDayConstant(timeOfDayType, (TimeOfDay)primitiveValue);
+                return new EdmTimeOfDayConstant(timeOfDayType, timeOfDay);
             }
 
-            if (primitiveValue is TimeSpan)
+            if (primitiveValue is TimeSpan timeSpan)
             {
                 IEdmTemporalTypeReference timeType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Duration);
-                return new EdmDurationConstant(timeType, (TimeSpan)primitiveValue);
+                return new EdmDurationConstant(timeType, timeSpan);
             }
 
             if (primitiveValue is ISpatial)
diff --git a/src/Microsoft.OData.Core/Evaluation/LiteralFormatter.cs b/src/Microsoft.OData.Core/Evaluation/LiteralFormatter.cs
index bcd6300bb..060b8b9c7 100644
--- a/src/Microsoft.OData.Core/Evaluation/LiteralFormatter.cs
+++ b/src/Microsoft.OData.Core/Evaluation/LiteralFormatter.cs
@@ -137,25 +137,24 @@ namespace Microsoft.OData.Evaluation
         private static string FormatRawLiteral(object value)
         {
             Debug.Assert(value != null, "value != null");
-
-            string stringValue = value as string;
-            if (stringValue != null)
+
+            if (value is string stringValue)
             {
                 return stringValue;
             }
 
-            if (value is bool)
+            if (value is bool b)
             {
-                return XmlConvert.ToString((bool)value);
+                return XmlConvert.ToString(b);
             }
 
-            if (value is byte)
+            if (value is byte b)
             {
-                return XmlConvert.ToString((byte)value);
+                return XmlConvert.ToString(b);
             }
 
 #if ODATA_SERVICE || ODATA_CLIENT
-            if (value is DateTime)
+            if (value is DateTime dateTime)
             {
                 // Since the server/client supports DateTime values, convert the DateTime value
                 // to DateTimeOffset and use XmlConvert to convert to String.
@@ -163,21 +162,21 @@ namespace Microsoft.OData.Evaluation
 #if ODATA_SERVICE
                 DateTimeOffset dto = WebUtil.ConvertDateTimeToDateTimeOffset((DateTime)value);
 #elif ODATA_CLIENT
-                DateTimeOffset dto = PlatformHelper.ConvertDateTimeToDateTimeOffset((DateTime)value);
+                DateTimeOffset dto = PlatformHelper.ConvertDateTimeToDateTimeOffset(dateTime);
 #endif
 
                 return XmlConvert.ToString(dto);
             }
 #endif
 
-            if (value is decimal)
+            if (value is decimal d)
             {
-                return XmlConvert.ToString((decimal)value);
+                return XmlConvert.ToString(d);
             }
 
-            if (value is double)
+            if (value is double d)
             {
-                string formattedDouble = XmlConvert.ToString((double)value);
+                string formattedDouble = XmlConvert.ToString(d);
                 formattedDouble = SharedUtils.AppendDecimalMarkerToDouble(formattedDouble);
                 return formattedDouble;
             }
@@ -211,9 +210,8 @@ namespace Microsoft.OData.Evaluation
             {
                 return XmlConvert.ToString((Single)value);
             }
-
-            byte[] array = value as byte[];
-            if (array != null)
+
+            if (value is byte[] array)
             {
                 return ConvertByteArrayToKeyString(array);
             }
@@ -223,9 +221,9 @@ namespace Microsoft.OData.Evaluation
                 return value.ToString();
             }
 
-            if (value is DateTimeOffset)
+            if (value is DateTimeOffset dateTimeOffset)
             {
-                return XmlConvert.ToString((DateTimeOffset)value);
+                return XmlConvert.ToString(dateTimeOffset);
             }
 
             if (value is TimeOfDay)
@@ -233,25 +231,30 @@ namespace Microsoft.OData.Evaluation
                 return value.ToString();
             }
 
-            if (value is TimeSpan)
+            if (value is TimeSpan timeSpan)
             {
-                return EdmValueWriter.DurationAsXml((TimeSpan)value);
+                return EdmValueWriter.DurationAsXml(timeSpan);
             }
-
+
+            if (
+/* Unmerged change from project 'Microsoft.OData.Core(net45)'
+Before:
             Geography geography = value as Geography;
             if (geography != null)
+After:
+            if (value is Geography geography)
+*/
+value is Geography geography)
             {
                 return WellKnownTextSqlFormatter.Create(true).Write(geography);
             }
-
-            Geometry geometry = value as Geometry;
-            if (geometry != null)
+
+            if (value is Geometry geometry)
             {
                 return WellKnownTextSqlFormatter.Create(true).Write(geometry);
             }
-
-            ODataEnumValue enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 return enumValue.Value;
             }
@@ -317,10 +320,9 @@ namespace Microsoft.OData.Evaluation
                     converted = array;
                     return true;
                 }
-
+
 #if !ODATA_CORE
-                XElement xml = value as XElement;
-                if (xml != null)
+                if (value is XElement xml)
                 {
                     converted = xml.ToString();
                     return true;
@@ -462,9 +464,8 @@ namespace Microsoft.OData.Evaluation
             private string FormatLiteralWithTypePrefix(object value)
             {
                 Debug.Assert(value != null, "value != null. Null values need to be handled differently in some cases.");
-
-                var enumValue = value as ODataEnumValue;
-                if (enumValue != null)
+
+                if (value is ODataEnumValue enumValue)
                 {
                     if (string.IsNullOrEmpty(enumValue.TypeName))
                     {
@@ -526,9 +527,8 @@ namespace Microsoft.OData.Evaluation
             internal override string Format(object value)
             {
                 Debug.Assert(value != null, "value != null");
-
-                ODataEnumValue enumValue = value as ODataEnumValue;
-                if (enumValue != null)
+
+                if (value is ODataEnumValue enumValue)
                 {
                     value = enumValue.Value;
                 }
@@ -538,9 +538,8 @@ namespace Microsoft.OData.Evaluation
                 {
                     value = converted;
                 }
-
-                string stringValue = value as string;
-                if (stringValue != null)
+
+                if (value is string stringValue)
                 {
                     value = EscapeLeadingDollarSign(stringValue);
                 }
diff --git a/src/Microsoft.OData.Core/Evaluation/ODataConventionalEntityMetadataBuilder.cs b/src/Microsoft.OData.Core/Evaluation/ODataConventionalEntityMetadataBuilder.cs
index f69cfa3dc..08e138d94 100644
--- a/src/Microsoft.OData.Core/Evaluation/ODataConventionalEntityMetadataBuilder.cs
+++ b/src/Microsoft.OData.Core/Evaluation/ODataConventionalEntityMetadataBuilder.cs
@@ -232,10 +232,9 @@ namespace Microsoft.OData.Evaluation
             {
                 this.computedMediaResource = new ODataStreamReferenceValue();
                 this.computedMediaResource.SetMetadataBuilder(this, /*propertyName*/ null);
-
-                // from OData spec: Media entity types MAY specify a list of acceptable media types using an annotation with term Core.AcceptableMediaTypes
-                IEdmEntityType entityType = this.ResourceMetadataContext.ActualResourceType as IEdmEntityType;
-                if (entityType != null)
+
+                // from OData spec: Media entity types MAY specify a list of acceptable media types using an annotation with term Core.AcceptableMediaTypes
+                if (this.ResourceMetadataContext.ActualResourceType is IEdmEntityType entityType)
                 {
                     var mediaTypes = this.MetadataContext.Model.GetVocabularyStringCollection(entityType, CoreVocabularyModel.AcceptableMediaTypesTerm);
                     if (mediaTypes.Count() == 1)
diff --git a/src/Microsoft.OData.Core/Evaluation/ODataConventionalIdMetadataBuilder.cs b/src/Microsoft.OData.Core/Evaluation/ODataConventionalIdMetadataBuilder.cs
index c766a861a..74a565480 100644
--- a/src/Microsoft.OData.Core/Evaluation/ODataConventionalIdMetadataBuilder.cs
+++ b/src/Microsoft.OData.Core/Evaluation/ODataConventionalIdMetadataBuilder.cs
@@ -212,8 +212,7 @@ namespace Microsoft.OData.Evaluation
         {
             try
             {
-                ODataConventionalResourceMetadataBuilder parent = this.ParentMetadataBuilder as ODataConventionalResourceMetadataBuilder;
-                if (parent != null && parent != this)
+                if (this.ParentMetadataBuilder is ODataConventionalResourceMetadataBuilder parent && parent != this)
                 {
                     // Get the parent canonical url
                     uri = parent.GetCanonicalUrl();
@@ -284,8 +283,8 @@ namespace Microsoft.OData.Evaluation
             while (lastSegment is TypeSegment)
             {
                 ODataPathSegment previousSegment = segments[lastIndex - 1];
-                IEdmStructuredType owningType = previousSegment.TargetEdmType as IEdmStructuredType;
-                if (owningType != null && owningType.FindProperty(lastSegment.Identifier) != null)
+
+                if (previousSegment.TargetEdmType is IEdmStructuredType owningType && owningType.FindProperty(lastSegment.Identifier) != null)
                 {
                     lastSegment = segments[--lastIndex];
                 }
diff --git a/src/Microsoft.OData.Core/Evaluation/ODataConventionalResourceMetadataBuilder.cs b/src/Microsoft.OData.Core/Evaluation/ODataConventionalResourceMetadataBuilder.cs
index 7bbde24c6..adc8466e5 100644
--- a/src/Microsoft.OData.Core/Evaluation/ODataConventionalResourceMetadataBuilder.cs
+++ b/src/Microsoft.OData.Core/Evaluation/ODataConventionalResourceMetadataBuilder.cs
@@ -115,10 +115,9 @@ namespace Microsoft.OData.Evaluation
             }
             else
             {
-                // compute edit url from parent
-                var parent = this.ParentMetadataBuilder as ODataConventionalResourceMetadataBuilder;
+                // compute edit url from parent
                 if (this.NameAsProperty != null
-                    && parent != null
+                    && this.ParentMetadataBuilder is ODataConventionalResourceMetadataBuilder parent
                     && parent.GetEditUrl() != null)
                 {
                     // If parent is collection of complex, the edit url for this resource should be null.
@@ -171,11 +170,9 @@ namespace Microsoft.OData.Evaluation
             {
                 return this.readUrl = editLink;
             }
-
-            // Compute readUrl from parent readUrl
-            var parent = this.ParentMetadataBuilder as ODataConventionalResourceMetadataBuilder;
+            // Compute readUrl from parent readUrl
             if (this.NameAsProperty != null
-                && parent != null
+                && this.ParentMetadataBuilder is ODataConventionalResourceMetadataBuilder parent
                 && parent.GetReadUrl() != null)
             {
                 // If parent is collection of complex, the read url for this resource should be null.
@@ -215,11 +212,9 @@ namespace Microsoft.OData.Evaluation
             {
                 return this.canonicalUrl = this.resource.NonComputedId;
             }
-
-            // Compute canonicalUrl from parent canonicalUrl
-            var parent = this.ParentMetadataBuilder as ODataConventionalResourceMetadataBuilder;
+            // Compute canonicalUrl from parent canonicalUrl
             if (this.NameAsProperty != null
-                && parent != null
+                && this.ParentMetadataBuilder is ODataConventionalResourceMetadataBuilder parent
                 && parent.GetCanonicalUrl() != null)
             {
                 // If parent is collection of complex, the canonical url for this resource should be null.
diff --git a/src/Microsoft.OData.Core/Evaluation/ODataResourceMetadataBuilder.cs b/src/Microsoft.OData.Core/Evaluation/ODataResourceMetadataBuilder.cs
index a522f0196..b9f1e26a9 100644
--- a/src/Microsoft.OData.Core/Evaluation/ODataResourceMetadataBuilder.cs
+++ b/src/Microsoft.OData.Core/Evaluation/ODataResourceMetadataBuilder.cs
@@ -138,7 +138,7 @@ namespace Microsoft.OData.Evaluation
                 }
 
                 ODataCollectionValue collectionValue = p.ODataValue as ODataCollectionValue;
-                if (collectionValue != null && collectionValue.Items != null && collectionValue.Items.Any(t => t is ODataResourceValue))
+                if (collectionValue?.Items != null && collectionValue.Items.Any(t => t is ODataResourceValue))
                 {
                     throw new ODataException(Strings.ODataResource_PropertyValueCannotBeODataResourceValue(p.Name));
                 }
diff --git a/src/Microsoft.OData.Core/Json/BufferingJsonReader.cs b/src/Microsoft.OData.Core/Json/BufferingJsonReader.cs
index 567177a20..427d710ba 100644
--- a/src/Microsoft.OData.Core/Json/BufferingJsonReader.cs
+++ b/src/Microsoft.OData.Core/Json/BufferingJsonReader.cs
@@ -179,8 +179,7 @@ namespace Microsoft.OData.Json
         /// <returns>A Stream used to read a stream value</returns>
         public virtual Stream CreateReadStream()
         {
-            IJsonStreamReader streamReader = this.innerReader as IJsonStreamReader;
-            if (!this.isBuffering && streamReader != null)
+            if (!this.isBuffering && this.innerReader is IJsonStreamReader streamReader)
             {
                 return streamReader.CreateReadStream();
             }
@@ -197,8 +196,7 @@ namespace Microsoft.OData.Json
         /// <returns>A TextReader for reading the text value.</returns>
         public virtual TextReader CreateTextReader()
         {
-            IJsonStreamReader streamReader = this.innerReader as IJsonStreamReader;
-            if (!this.isBuffering && streamReader != null)
+            if (!this.isBuffering && this.innerReader is IJsonStreamReader streamReader)
             {
                 return streamReader.CreateTextReader();
             }
@@ -214,8 +212,7 @@ namespace Microsoft.OData.Json
         /// <returns>True if the current value can be streamed, otherwise false</returns>
         public virtual bool CanStream()
         {
-            IJsonStreamReader streamReader = this.innerReader as IJsonStreamReader;
-            if (!this.isBuffering && streamReader != null)
+            if (!this.isBuffering && this.innerReader is IJsonStreamReader streamReader)
             {
                 return streamReader.CanStream();
             }
diff --git a/src/Microsoft.OData.Core/Json/JsonLightInstanceAnnotationWriter.cs b/src/Microsoft.OData.Core/Json/JsonLightInstanceAnnotationWriter.cs
index 40e1d2b10..f14066cf5 100644
--- a/src/Microsoft.OData.Core/Json/JsonLightInstanceAnnotationWriter.cs
+++ b/src/Microsoft.OData.Core/Json/JsonLightInstanceAnnotationWriter.cs
@@ -168,9 +168,8 @@ namespace Microsoft.OData
             // That is, write the type name (unless its a primitive value with a JSON-native type).  If we did find an expected type, treat the annotation value like a
             // declared property with an expected type. This will still write out the type if the value type is more derived than the declared type, for example.
             bool treatLikeOpenProperty = expectedType == null;
-
-            ODataResourceValue resourceValue = value as ODataResourceValue;
-            if (resourceValue != null)
+
+            if (value is ODataResourceValue resourceValue)
             {
                 this.WriteInstanceAnnotationName(propertyName, name);
                 this.valueSerializer.WriteResourceValue(resourceValue,
@@ -179,9 +178,8 @@ namespace Microsoft.OData
                     this.valueSerializer.CreateDuplicatePropertyNameChecker());
                 return;
             }
-
-            ODataCollectionValue collectionValue = value as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (value is ODataCollectionValue collectionValue)
             {
                 IEdmTypeReference typeFromCollectionValue = (IEdmCollectionTypeReference)TypeNameOracle.ResolveAndValidateTypeForCollectionValue(
                     this.valueSerializer.Model, expectedType, collectionValue, treatLikeOpenProperty, this.writerValidator);
@@ -195,17 +193,15 @@ namespace Microsoft.OData
                 this.valueSerializer.WriteCollectionValue(collectionValue, expectedType, typeFromCollectionValue, false /*isTopLevelProperty*/, false /*isInUri*/, treatLikeOpenProperty);
                 return;
             }
-
-            ODataUntypedValue untypedValue = value as ODataUntypedValue;
-            if (untypedValue != null)
+
+            if (value is ODataUntypedValue untypedValue)
             {
                 this.WriteInstanceAnnotationName(propertyName, name);
                 this.valueSerializer.WriteUntypedValue(untypedValue);
                 return;
             }
-
-            ODataEnumValue enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 this.WriteInstanceAnnotationName(propertyName, name);
                 this.valueSerializer.WriteEnumValue(enumValue, expectedType);
diff --git a/src/Microsoft.OData.Core/Json/ODataJsonWriterUtils.cs b/src/Microsoft.OData.Core/Json/ODataJsonWriterUtils.cs
index 66d23bcbb..abb6e83fe 100644
--- a/src/Microsoft.OData.Core/Json/ODataJsonWriterUtils.cs
+++ b/src/Microsoft.OData.Core/Json/ODataJsonWriterUtils.cs
@@ -94,21 +94,18 @@ namespace Microsoft.OData.Json
             {
                 sb.Append("null");
             }
-
-            ODataCollectionValue collectionValue = value as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (value is ODataCollectionValue collectionValue)
             {
                 ODataCollectionValueToString(sb, collectionValue);
             }
-
-            ODataResourceValue resourceValue = value as ODataResourceValue;
-            if (resourceValue != null)
+
+            if (value is ODataResourceValue resourceValue)
             {
                 ODataResourceValueToString(sb, resourceValue);
             }
-
-            ODataPrimitiveValue primitiveValue = value as ODataPrimitiveValue;
-            if (primitiveValue != null)
+
+            if (value is ODataPrimitiveValue primitiveValue)
             {
                 if (primitiveValue.FromODataValue() is string)
                 {
@@ -304,9 +301,8 @@ namespace Microsoft.OData.Json
                 {
                     sb.Append(",");
                 }
-
-                ODataValue odataValue = item as ODataValue;
-                if (odataValue != null)
+
+                if (item is ODataValue odataValue)
                 {
                     ODataValueToString(sb, odataValue);
                 }
diff --git a/src/Microsoft.OData.Core/JsonLight/JsonFullMetadataLevel.cs b/src/Microsoft.OData.Core/JsonLight/JsonFullMetadataLevel.cs
index 1e681672a..fba68ec68 100644
--- a/src/Microsoft.OData.Core/JsonLight/JsonFullMetadataLevel.cs
+++ b/src/Microsoft.OData.Core/JsonLight/JsonFullMetadataLevel.cs
@@ -136,10 +136,7 @@ namespace Microsoft.OData.JsonLight
 
             // Inject to the Media Resource.
             var mediaResource = resource.NonComputedMediaResource;
-            if (mediaResource != null)
-            {
-                mediaResource.SetMetadataBuilder(builder, /*propertyName*/null);
-            }
+            mediaResource?.SetMetadataBuilder(builder, /*propertyName*/ null);
 
             // Inject to named stream property values
             if (resource.NonComputedProperties != null)
@@ -147,10 +144,7 @@ namespace Microsoft.OData.JsonLight
                 foreach (ODataProperty property in resource.NonComputedProperties)
                 {
                     var streamReferenceValue = property.ODataValue as ODataStreamReferenceValue;
-                    if (streamReferenceValue != null)
-                    {
-                        streamReferenceValue.SetMetadataBuilder(builder, property.Name);
-                    }
+                    streamReferenceValue?.SetMetadataBuilder(builder, property.Name);
                 }
             }
 
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightCollectionWriter.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightCollectionWriter.cs
index a4c2035f1..4148adb20 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightCollectionWriter.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightCollectionWriter.cs
@@ -131,9 +131,9 @@ namespace Microsoft.OData.JsonLight
             }
             else
             {
-                ODataResourceValue resourceValue = item as ODataResourceValue;
                 ODataEnumValue enumVal = null;
-                if (resourceValue != null)
+
+                if (item is ODataResourceValue resourceValue)
                 {
                     this.jsonLightCollectionSerializer.AssertRecursionDepthIsZero();
                     this.jsonLightCollectionSerializer.WriteResourceValue(
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightContextUriParser.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightContextUriParser.cs
index 191a0edc1..eaea2d24c 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightContextUriParser.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightContextUriParser.cs
@@ -420,16 +420,15 @@ namespace Microsoft.OData.JsonLight
                 {
                     isUndeclared = path.IsUndeclared();
                     detectedPayloadKind = ODataPayloadKind.Property;
-                    IEdmComplexType complexType = parseResult.EdmType as IEdmComplexType;
-                    if (complexType != null)
+
+                    if (parseResult.EdmType is IEdmComplexType complexType)
                     {
                         detectedPayloadKind = ODataPayloadKind.Resource;
                     }
                     else
                     {
-                        IEdmCollectionType collectionType = parseResult.EdmType as IEdmCollectionType;
 
-                        if (collectionType != null)
+                        if (parseResult.EdmType is IEdmCollectionType collectionType)
                         {
                             if (collectionType.ElementType.IsComplex())
                             {
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightDeserializer.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightDeserializer.cs
index 1945ee5cc..a11a69f84 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightDeserializer.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightDeserializer.cs
@@ -540,10 +540,7 @@ namespace Microsoft.OData.JsonLight
                 throw new ODataException(Strings.ODataJsonLightDeserializer_ContextLinkNotFoundAsFirstProperty);
             }
 
-            if (propertyAndAnnotationCollector != null)
-            {
-                propertyAndAnnotationCollector.MarkPropertyAsProcessed(propertyName);
-            }
+            propertyAndAnnotationCollector?.MarkPropertyAsProcessed(propertyName);
 
             // Read over the property name
             this.JsonReader.ReadNext();
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightOutputContext.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightOutputContext.cs
index e356caf83..d1120834b 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightOutputContext.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightOutputContext.cs
@@ -756,10 +756,7 @@ namespace Microsoft.OData.JsonLight
                     this.jsonWriter.Flush();
 
                     JsonWriter writer = this.jsonWriter as JsonWriter;
-                    if (writer != null)
-                    {
-                        writer.Dispose();
-                    }
+                    writer?.Dispose();
 
                     // In the async case the underlying stream is the async buffered stream, so we have to flush that explicitly.
                     if (this.asynchronousOutputStream != null)
@@ -810,9 +807,8 @@ namespace Microsoft.OData.JsonLight
                 jsonWriter = jsonWriterFactory.CreateJsonWriter(textWriter, isIeee754Compatible);
                 Debug.Assert(jsonWriter != null, "jsonWriter != null");
             }
-
-            JsonWriter writer = jsonWriter as JsonWriter;
-            if (writer != null && writerSettings.ArrayPool != null)
+
+            if (jsonWriter is JsonWriter writer && writerSettings.ArrayPool != null)
             {
                 writer.ArrayPool = writerSettings.ArrayPool;
             }
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightParameterWriter.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightParameterWriter.cs
index 43c48770a..afd6ca88a 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightParameterWriter.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightParameterWriter.cs
@@ -105,8 +105,7 @@ namespace Microsoft.OData.JsonLight
             }
             else
             {
-                ODataEnumValue enumVal = parameterValue as ODataEnumValue;
-                if (enumVal != null)
+                if (parameterValue is ODataEnumValue enumVal)
                 {
                     this.jsonLightValueSerializer.WriteEnumValue(enumVal, expectedTypeReference);
                 }
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertyAndValueDeserializer.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertyAndValueDeserializer.cs
index 5e40ef222..c9a7cdfcb 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertyAndValueDeserializer.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertyAndValueDeserializer.cs
@@ -772,8 +772,8 @@ namespace Microsoft.OData.JsonLight
                 switch (propertyAnnotation.Key)
                 {
                     case ODataAnnotationNames.ODataBind:
-                        LinkedList<ODataEntityReferenceLink> entityReferenceLinksList = propertyAnnotation.Value as LinkedList<ODataEntityReferenceLink>;
-                        if (entityReferenceLinksList != null)
+
+                        if (propertyAnnotation.Value is LinkedList<ODataEntityReferenceLink> entityReferenceLinksList)
                         {
                             throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ArrayValueForSingletonBindPropertyAnnotation(nestedResourceInfo.Name, ODataAnnotationNames.ODataBind));
                         }
@@ -833,8 +833,8 @@ namespace Microsoft.OData.JsonLight
                 switch (propertyAnnotation.Key)
                 {
                     case ODataAnnotationNames.ODataBind:
-                        ODataEntityReferenceLink entityReferenceLink = propertyAnnotation.Value as ODataEntityReferenceLink;
-                        if (entityReferenceLink != null)
+
+                        if (propertyAnnotation.Value is ODataEntityReferenceLink entityReferenceLink)
                         {
                             throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_StringValueForCollectionBindPropertyAnnotation(nestedResourceInfo.Name, ODataAnnotationNames.ODataBind));
                         }
@@ -885,10 +885,7 @@ namespace Microsoft.OData.JsonLight
             if (propertyTypeName != null)
             {
                 var validator = propertyAndAnnotationCollector.GetDerivedTypeValidator(propertyName);
-                if (validator != null)
-                {
-                    validator.ValidateResourceType(propertyTypeName);
-                }
+                validator?.ValidateResourceType(propertyTypeName);
             }
 
             return propertyTypeName;
@@ -1499,11 +1496,11 @@ namespace Microsoft.OData.JsonLight
                 }
                 else
                 {
-                    if (result is Decimal)
+                    if (result is Decimal d)
                     {
                         // convert decimal back to double to follow legacy logic when target type is not specified and IEEE754Compatible=false.
                         // we may lose precision for some range of int64 and decimal.
-                        return Convert.ToDouble((Decimal)result);
+                        return Convert.ToDouble(d);
                     }
                 }
             }
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertySerializer.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertySerializer.cs
index 54068a2ef..4fe30586f 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertySerializer.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightPropertySerializer.cs
@@ -145,17 +145,15 @@ namespace Microsoft.OData.JsonLight
             this.WritePropertyInfo(property, owningType, isTopLevel, duplicatePropertyNameChecker, metadataBuilder);
 
             ODataValue value = property.ODataValue;
-
-            // handle ODataUntypedValue
-            ODataUntypedValue untypedValue = value as ODataUntypedValue;
-            if (untypedValue != null)
+
+            // handle ODataUntypedValue
+            if (value is ODataUntypedValue untypedValue)
             {
                 WriteUntypedValue(untypedValue);
                 return;
             }
-
-            ODataStreamReferenceValue streamReferenceValue = value as ODataStreamReferenceValue;
-            if (streamReferenceValue != null && !(this.JsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel))
+
+            if (value is ODataStreamReferenceValue streamReferenceValue && !(this.JsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel))
             {
                 Debug.Assert(!isTopLevel, "Stream properties are not allowed at the top level.");
                 WriteStreamValue(streamReferenceValue, property.Name, metadataBuilder);
@@ -169,23 +167,20 @@ namespace Microsoft.OData.JsonLight
             }
 
             bool isOpenPropertyType = this.IsOpenProperty(property);
-
-            ODataPrimitiveValue primitiveValue = value as ODataPrimitiveValue;
-            if (primitiveValue != null)
+
+            if (value is ODataPrimitiveValue primitiveValue)
             {
                 this.WritePrimitiveProperty(primitiveValue, isOpenPropertyType);
                 return;
             }
-
-            ODataEnumValue enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 this.WriteEnumProperty(enumValue, isOpenPropertyType);
                 return;
             }
-
-            ODataResourceValue resourceValue = value as ODataResourceValue;
-            if (resourceValue != null)
+
+            if (value is ODataResourceValue resourceValue)
             {
                 if (isTopLevel)
                 {
@@ -195,9 +190,8 @@ namespace Microsoft.OData.JsonLight
                 this.WriteResourceProperty(property, resourceValue, isOpenPropertyType);
                 return;
             }
-
-            ODataCollectionValue collectionValue = value as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (value is ODataCollectionValue collectionValue)
             {
                 if (isTopLevel)
                 {
@@ -210,9 +204,8 @@ namespace Microsoft.OData.JsonLight
                 this.WriteCollectionProperty(collectionValue, isOpenPropertyType);
                 return;
             }
-
-            ODataBinaryStreamValue streamValue = value as ODataBinaryStreamValue;
-            if (streamValue != null)
+
+            if (value is ODataBinaryStreamValue streamValue)
             {
                 this.WriteStreamProperty(streamValue, isOpenPropertyType);
                 return;
@@ -263,9 +256,8 @@ namespace Microsoft.OData.JsonLight
             }
 
             WriteInstanceAnnotation(propertyInfo, isTopLevel, currentPropertyInfo.MetadataType.IsUndeclaredProperty);
-
-            ODataStreamPropertyInfo streamInfo = propertyInfo as ODataStreamPropertyInfo;
-            if (streamInfo != null && !(this.JsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel))
+
+            if (propertyInfo is ODataStreamPropertyInfo streamInfo && !(this.JsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel))
             {
                 Debug.Assert(!isTopLevel, "Stream properties are not allowed at the top level.");
                 WriteStreamValue(streamInfo, propertyInfo.Name, metadataBuilder);
@@ -311,10 +303,7 @@ namespace Microsoft.OData.JsonLight
         {
             WriterValidationUtils.ValidateStreamPropertyInfo(streamInfo, currentPropertyInfo.MetadataType.EdmProperty, propertyName, this.WritingResponse);
             this.WriteStreamInfo(propertyName, streamInfo);
-            if (metadataBuilder != null)
-            {
-                metadataBuilder.MarkStreamPropertyProcessed(propertyName);
-            }
+            metadataBuilder?.MarkStreamPropertyProcessed(propertyName);
         }
 
         /// <summary>
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReader.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReader.cs
index e81555b02..b6918069b 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReader.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReader.cs
@@ -1106,7 +1106,7 @@ namespace Microsoft.OData.JsonLight
 
                     // Set the metadata builder and parent metadata builder for the resource itself
                     currentResource.MetadataBuilder = builder;
-                    if (parentNestInfo != null && parentNestInfo.MetadataBuilder != null)
+                    if (parentNestInfo?.MetadataBuilder != null)
                     {
                         currentResource.MetadataBuilder.ParentMetadataBuilder = parentNestInfo.MetadataBuilder;
                     }
@@ -1152,7 +1152,7 @@ namespace Microsoft.OData.JsonLight
         /// <returns>The odata uri resolved from context url.</returns>
         private ODataUri ResolveODataUriFromContextUrl(ODataNestedResourceInfo nestedInfo)
         {
-            if (nestedInfo != null && nestedInfo.ContextUrl != null)
+            if (nestedInfo?.ContextUrl != null)
             {
                 var payloadKind = nestedInfo.IsCollection.GetValueOrDefault()
                     ? ODataPayloadKind.ResourceSet
@@ -2471,10 +2471,7 @@ namespace Microsoft.OData.JsonLight
 
                 ODataConventionalEntityMetadataBuilder builder =
                     currentResource.MetadataBuilder as ODataConventionalEntityMetadataBuilder;
-                if (builder != null)
-                {
-                    builder.EndResource();
-                }
+                builder?.EndResource();
             }
 
             if (!this.ReadingDelta)
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderNestedResourceInfo.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderNestedResourceInfo.cs
index b357fbfbc..23b7a8da3 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderNestedResourceInfo.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderNestedResourceInfo.cs
@@ -79,7 +79,7 @@ namespace Microsoft.OData.JsonLight
 
             // We get the nullablity from the nestedProperty if it exists otherwise we consider the resource to be nullable if only the nestedResourceType is specified.
             bool resourceTypeNullable = true;
-            if (nestedProperty != null && nestedProperty.Type != null)
+            if (nestedProperty?.Type != null)
             {
                 resourceTypeNullable = nestedProperty.Type.IsNullable;
             }
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderUtils.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderUtils.cs
index 08d7d8f50..ffab0d090 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderUtils.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightReaderUtils.cs
@@ -214,15 +214,13 @@ namespace Microsoft.OData.JsonLight
             {
                 return Metadata.EdmConstants.EdmDoubleTypeName;
             }
-
-            ODataCollectionValue collectionValue = payloadItem as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (payloadItem is ODataCollectionValue collectionValue)
             {
                 return EdmLibraryExtensions.GetCollectionTypeFullName(collectionValue.TypeName);
             }
-
-            ODataResourceBase resource = payloadItem as ODataResourceBase;
-            if (resource != null)
+
+            if (payloadItem is ODataResourceBase resource)
             {
                 return resource.TypeName;
             }
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightResourceSerializer.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightResourceSerializer.cs
index 9b4174d74..b7f62ae04 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightResourceSerializer.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightResourceSerializer.cs
@@ -396,7 +396,7 @@ namespace Microsoft.OData.JsonLight
         /// <returns>The metadata reference fragment from the operation context uri.</returns>
         private string GetOperationMetadataString(ODataOperation operation)
         {
-            Debug.Assert(operation != null && operation.Metadata != null, "operation != null && operation.Metadata != null");
+            Debug.Assert(operation?.Metadata != null, "operation != null && operation.Metadata != null");
 
             string operationMetadataString = UriUtils.UriToString(operation.Metadata);
             Debug.Assert(ODataJsonLightUtils.IsMetadataReferenceProperty(operationMetadataString), "ODataJsonLightUtils.IsMetadataReferenceProperty(operationMetadataString)");
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightValueSerializer.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightValueSerializer.cs
index a7220b2a0..4a8d37cc0 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightValueSerializer.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightValueSerializer.cs
@@ -234,9 +234,8 @@ namespace Microsoft.OData.JsonLight
                 foreach (object item in items)
                 {
                     ValidationUtils.ValidateCollectionItem(item, expectedItemTypeReference.IsNullable());
-
-                    ODataResourceValue itemAsResourceValue = item as ODataResourceValue;
-                    if (itemAsResourceValue != null)
+
+                    if (item is ODataResourceValue itemAsResourceValue)
                     {
                         if (duplicatePropertyNamesChecker == null)
                         {
@@ -255,18 +254,14 @@ namespace Microsoft.OData.JsonLight
                     {
                         Debug.Assert(!(item is ODataCollectionValue), "!(item is ODataCollectionValue)");
                         Debug.Assert(!(item is ODataStreamReferenceValue), "!(item is ODataStreamReferenceValue)");
-
-                        // by design: collection element's type name is not written for enum or non-spatial primitive value even in case of full metadata.
-                        // because enum and non-spatial primitive types don't have inheritance, the type of each element is the same as the item type of the collection, whose type name for spatial types in full metadata mode.
-                        ODataEnumValue enumValue = item as ODataEnumValue;
-                        if (enumValue != null)
+                        // by design: collection element's type name is not written for enum or non-spatial primitive value even in case of full metadata.                        // because enum and non-spatial primitive types don't have inheritance, the type of each element is the same as the item type of the collection, whose type name for spatial types in full metadata mode.
+                        if (item is ODataEnumValue enumValue)
                         {
                             this.WriteEnumValue(enumValue, expectedItemTypeReference);
                         }
                         else
                         {
-                            ODataUntypedValue untypedValue = item as ODataUntypedValue;
-                            if (untypedValue != null)
+                            if (item is ODataUntypedValue untypedValue)
                             {
                                 this.WriteUntypedValue(untypedValue);
                             }
diff --git a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightWriter.cs b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightWriter.cs
index 53b0680f9..b8f500e28 100644
--- a/src/Microsoft.OData.Core/JsonLight/ODataJsonLightWriter.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ODataJsonLightWriter.cs
@@ -311,7 +311,7 @@ namespace Microsoft.OData.JsonLight
             ResourceBaseScope scope = this.ParentScope as ResourceBaseScope;
             Debug.Assert(scope != null, "Writing a property and the parent scope is not a resource");
             ODataResource resource = scope.Item as ODataResource;
-            Debug.Assert(resource != null && resource.MetadataBuilder != null, "Writing a property with no parent resource MetadataBuilder");
+            Debug.Assert(resource?.MetadataBuilder != null, "Writing a property with no parent resource MetadataBuilder");
 
             ODataProperty propertyWithValue = property as ODataProperty;
             if (propertyWithValue != null)
@@ -933,7 +933,7 @@ namespace Microsoft.OData.JsonLight
             {
                 string contentType = "text/plain";
                 ODataStreamPropertyInfo streamInfo = property as ODataStreamPropertyInfo;
-                if (streamInfo != null && streamInfo.ContentType != null)
+                if (streamInfo?.ContentType != null)
                 {
                     contentType = streamInfo.ContentType;
                 }
diff --git a/src/Microsoft.OData.Core/JsonLight/ReorderingJsonReader.cs b/src/Microsoft.OData.Core/JsonLight/ReorderingJsonReader.cs
index b78668b94..e4558f6f9 100644
--- a/src/Microsoft.OData.Core/JsonLight/ReorderingJsonReader.cs
+++ b/src/Microsoft.OData.Core/JsonLight/ReorderingJsonReader.cs
@@ -342,9 +342,8 @@ namespace Microsoft.OData.JsonLight
                 {
                     Debug.Assert(storedValue != null, "storedValue != null");
                     List<BufferedProperty> storedProperties;
-
-                    BufferedProperty storedProperty = storedValue as BufferedProperty;
-                    if (storedProperty != null)
+
+                    if (storedValue is BufferedProperty storedProperty)
                     {
                         storedProperties = new List<BufferedProperty>(4);
                         storedProperties.Add(storedProperty);
@@ -380,8 +379,8 @@ namespace Microsoft.OData.JsonLight
                 {
                     Debug.Assert(this.propertyCache.ContainsKey(propertyName), "Property must be in the cache for its name to be in the list of property names.");
                     object storedValue = this.propertyCache[propertyName];
-                    BufferedProperty storedProperty = storedValue as BufferedProperty;
-                    if (storedProperty != null)
+
+                    if (storedValue is BufferedProperty storedProperty)
                     {
                         storedProperty.InsertAfter(currentNode);
                         currentNode = storedProperty.EndOfPropertyValueNode;
diff --git a/src/Microsoft.OData.Core/MessageStreamWrapper.cs b/src/Microsoft.OData.Core/MessageStreamWrapper.cs
index dedd6b5e9..58282fc45 100644
--- a/src/Microsoft.OData.Core/MessageStreamWrapper.cs
+++ b/src/Microsoft.OData.Core/MessageStreamWrapper.cs
@@ -64,9 +64,7 @@ namespace Microsoft.OData
         internal static bool IsNonDisposingStream(Stream stream)
         {
             Debug.Assert(stream != null, "stream != null");
-
-            MessageStreamWrappingStream wrappingStream = stream as MessageStreamWrappingStream;
-            return wrappingStream != null && wrappingStream.IgnoreDispose;
+            return stream is MessageStreamWrappingStream wrappingStream && wrappingStream.IgnoreDispose;
         }
 
         /// <summary>
diff --git a/src/Microsoft.OData.Core/Metadata/EdmLibraryExtensions.cs b/src/Microsoft.OData.Core/Metadata/EdmLibraryExtensions.cs
index 215d4c331..20385591e 100644
--- a/src/Microsoft.OData.Core/Metadata/EdmLibraryExtensions.cs
+++ b/src/Microsoft.OData.Core/Metadata/EdmLibraryExtensions.cs
@@ -1093,11 +1093,9 @@ namespace Microsoft.OData.Metadata
         internal static string ODataShortQualifiedName(this IEdmType type)
         {
             Debug.Assert(type != null, "type != null");
-
-            // Handle collection type names here since for EdmLib collection values are functions
-            // that do not have a full name
-            IEdmCollectionType collectionType = type as IEdmCollectionType;
-            if (collectionType != null)
+
+            // Handle collection type names here since for EdmLib collection values are functions            // that do not have a full name
+            if (type is IEdmCollectionType collectionType)
             {
                 string elementTypeName = collectionType.ElementType.ODataShortQualifiedName();
                 if (elementTypeName == null)
@@ -1107,9 +1105,7 @@ namespace Microsoft.OData.Metadata
 
                 return GetCollectionTypeName(elementTypeName);
             }
-
-            var namedDefinition = type as IEdmSchemaElement;
-            return namedDefinition != null ? namedDefinition.ShortQualifiedName() : null;
+            return type is IEdmSchemaElement namedDefinition ? namedDefinition.ShortQualifiedName() : null;
         }
 
         /// <summary>
@@ -1569,8 +1565,8 @@ namespace Microsoft.OData.Metadata
                 case EdmTypeKind.Enum:
                     return new EdmEnumTypeReference((IEdmEnumType)type, nullable);
                 case EdmTypeKind.Untyped:
-                    IEdmStructuredType untypedType = type as IEdmStructuredType;
-                    if (untypedType != null)
+
+                    if (type is IEdmStructuredType untypedType)
                     {
                         return new EdmUntypedStructuredTypeReference(untypedType, nullable);
                     }
diff --git a/src/Microsoft.OData.Core/Metadata/EdmTypeReaderResolver.cs b/src/Microsoft.OData.Core/Metadata/EdmTypeReaderResolver.cs
index 708c2c7e0..9c3fdf795 100644
--- a/src/Microsoft.OData.Core/Metadata/EdmTypeReaderResolver.cs
+++ b/src/Microsoft.OData.Core/Metadata/EdmTypeReaderResolver.cs
@@ -131,12 +131,9 @@ namespace Microsoft.OData.Metadata
             }
 
             EdmTypeKind typeKind;
-
-            // MetadataUtils.ResolveTypeName() does not allow entity collection types however both operationImport.ReturnType and operationParameter.Type can be of entity collection types.
-            // We don't want to relax MetadataUtils.ResolveTypeName() since the rest of ODL only allows primitive and complex collection types and is currently relying on the method to
-            // enforce this.  So if typeToResolve is an entity collection type, we will resolve the item type and reconstruct the collection type from the resolved item type.
-            IEdmCollectionType collectionTypeToResolve = typeToResolve as IEdmCollectionType;
-            if (collectionTypeToResolve != null && collectionTypeToResolve.ElementType.IsEntity())
+
+            // MetadataUtils.ResolveTypeName() does not allow entity collection types however both operationImport.ReturnType and operationParameter.Type can be of entity collection types.            // We don't want to relax MetadataUtils.ResolveTypeName() since the rest of ODL only allows primitive and complex collection types and is currently relying on the method to            // enforce this.  So if typeToResolve is an entity collection type, we will resolve the item type and reconstruct the collection type from the resolved item type.
+            if (typeToResolve is IEdmCollectionType collectionTypeToResolve && collectionTypeToResolve.ElementType.IsEntity())
             {
                 IEdmTypeReference itemTypeReferenceToResolve = collectionTypeToResolve.ElementType;
                 IEdmType resolvedItemType = MetadataUtils.ResolveTypeName(this.model, null /*expectedType*/, itemTypeReferenceToResolve.FullName(), clientCustomTypeResolver, out typeKind);
diff --git a/src/Microsoft.OData.Core/Metadata/MetadataUtils.cs b/src/Microsoft.OData.Core/Metadata/MetadataUtils.cs
index e73b95eec..f3eb169dd 100644
--- a/src/Microsoft.OData.Core/Metadata/MetadataUtils.cs
+++ b/src/Microsoft.OData.Core/Metadata/MetadataUtils.cs
@@ -171,9 +171,7 @@ namespace Microsoft.OData.Metadata
                 throw new ODataException(Strings.MetadataUtils_CalculateBindableOperationsForType(bindingType.FullTypeName()), exc);
             }
 
-            IList<IEdmOperation> operationsFound = operations as IList<IEdmOperation>;
-
-            if(operationsFound != null)
+            if(operations is IList<IEdmOperation> operationsFound)
             {
                 return operationsFound;
             }
diff --git a/src/Microsoft.OData.Core/Metadata/MetadataUtilsCommon.cs b/src/Microsoft.OData.Core/Metadata/MetadataUtilsCommon.cs
index d75858f8a..4982d1a18 100644
--- a/src/Microsoft.OData.Core/Metadata/MetadataUtilsCommon.cs
+++ b/src/Microsoft.OData.Core/Metadata/MetadataUtilsCommon.cs
@@ -551,12 +551,10 @@ namespace Microsoft.OData.Metadata
         internal static bool TryGetConstantNodePrimitiveLDMF(SingleValueNode sourceNodeOrNull, out object primitiveValue)
         {
             primitiveValue = null;
-
-            ConstantNode tmp = sourceNodeOrNull as ConstantNode;
-            if (tmp != null)
+
+            if (sourceNodeOrNull is ConstantNode tmp)
             {
-                IEdmPrimitiveType primitiveType = tmp.TypeReference.AsPrimitiveOrNull().Definition as IEdmPrimitiveType;
-                if (primitiveType != null)
+                if (tmp.TypeReference.AsPrimitiveOrNull().Definition is IEdmPrimitiveType primitiveType)
                 {
                     switch (primitiveType.PrimitiveKind)
                     {
diff --git a/src/Microsoft.OData.Core/Microsoft.OData.Core.cs b/src/Microsoft.OData.Core/Microsoft.OData.Core.cs
index 34673ae2f..308fae23a 100644
--- a/src/Microsoft.OData.Core/Microsoft.OData.Core.cs
+++ b/src/Microsoft.OData.Core/Microsoft.OData.Core.cs
@@ -885,8 +885,7 @@ namespace Microsoft.OData
             {
                 for (int i = 0; i < args.Length; i ++)
                 {
-                    String value = args[i] as String;
-                    if (value != null && value.Length > 1024)
+                    if (args[i] is String value && value.Length > 1024)
                     {
                         args[i] = value.Substring(0, 1024 - 3) + "...";
                     }
diff --git a/src/Microsoft.OData.Core/MultipartMixed/ODataMultipartMixedBatchReaderStream.cs b/src/Microsoft.OData.Core/MultipartMixed/ODataMultipartMixedBatchReaderStream.cs
index 4f7787758..6dab2a3ae 100644
--- a/src/Microsoft.OData.Core/MultipartMixed/ODataMultipartMixedBatchReaderStream.cs
+++ b/src/Microsoft.OData.Core/MultipartMixed/ODataMultipartMixedBatchReaderStream.cs
@@ -444,7 +444,7 @@ namespace Microsoft.OData.MultipartMixed
 
             // Read all the headers
             string headerLine = this.ReadLine();
-            while (headerLine != null && headerLine.Length > 0)
+            while (!string.IsNullOrEmpty(headerLine))
             {
                 string headerName, headerValue;
                 ValidateHeaderLine(headerLine, out headerName, out headerValue);
@@ -492,7 +492,7 @@ namespace Microsoft.OData.MultipartMixed
         /// <param name="headerValue">The value of the header.</param>
         private static void ValidateHeaderLine(string headerLine, out string headerName, out string headerValue)
         {
-            Debug.Assert(headerLine != null && headerLine.Length > 0, "Expected non-empty header line.");
+            Debug.Assert(!string.IsNullOrEmpty(headerLine), "Expected non-empty header line.");
 
             int colon = headerLine.IndexOf(':');
             if (colon <= 0)
diff --git a/src/Microsoft.OData.Core/ODataContextUrlInfo.cs b/src/Microsoft.OData.Core/ODataContextUrlInfo.cs
index 32e30e616..054198588 100644
--- a/src/Microsoft.OData.Core/ODataContextUrlInfo.cs
+++ b/src/Microsoft.OData.Core/ODataContextUrlInfo.cs
@@ -268,7 +268,7 @@ namespace Microsoft.OData
 
         private static string ComputeResourcePath(ODataUri odataUri)
         {
-            if (odataUri != null && odataUri.Path != null && odataUri.Path.IsIndividualProperty())
+            if (odataUri?.Path != null && odataUri.Path.IsIndividualProperty())
             {
                 return odataUri.Path.ToContextUrlPathString();
             }
@@ -295,7 +295,7 @@ namespace Microsoft.OData
 
         private static bool? ComputeIfIsUndeclared(ODataUri odataUri)
         {
-            if (odataUri != null && odataUri.Path != null)
+            if (odataUri?.Path != null)
             {
                 return odataUri.Path.IsUndeclared();
             }
@@ -326,27 +326,23 @@ namespace Microsoft.OData
             {
                 return value.TypeAnnotation.TypeName;
             }
-
-            var collectionValue = value as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (value is ODataCollectionValue collectionValue)
             {
                 return EdmLibraryExtensions.GetCollectionTypeFullName(collectionValue.TypeName);
             }
-
-            var enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 return enumValue.TypeName;
             }
-
-            var resourceValue = value as ODataResourceValue;
-            if (resourceValue != null)
+
+            if (value is ODataResourceValue resourceValue)
             {
                 return resourceValue.TypeName;
             }
-
-            var untypedValue = value as ODataUntypedValue;
-            if (untypedValue != null)
+
+            if (value is ODataUntypedValue untypedValue)
             {
                 return ODataConstants.ContextUriFragmentUntyped;
             }
diff --git a/src/Microsoft.OData.Core/ODataMessageReader.cs b/src/Microsoft.OData.Core/ODataMessageReader.cs
index c000cae61..01229bfb6 100644
--- a/src/Microsoft.OData.Core/ODataMessageReader.cs
+++ b/src/Microsoft.OData.Core/ODataMessageReader.cs
@@ -1209,9 +1209,8 @@ namespace Microsoft.OData
                 {
                     throw new ArgumentException(Strings.ODataMessageReader_ExpectedTypeSpecifiedWithoutMetadata("expectedPropertyTypeReference"), nameof(expectedPropertyTypeReference));
                 }
-
-                IEdmCollectionType collectionType = expectedPropertyTypeReference.Definition as IEdmCollectionType;
-                if (collectionType != null && collectionType.ElementType.IsODataEntityTypeKind())
+
+                if (expectedPropertyTypeReference.Definition is IEdmCollectionType collectionType && collectionType.ElementType.IsODataEntityTypeKind())
                 {
                     throw new ArgumentException(Strings.ODataMessageReader_ExpectedPropertyTypeEntityCollectionKind, nameof(expectedPropertyTypeReference));
                 }
diff --git a/src/Microsoft.OData.Core/ODataPayloadValueConverter.cs b/src/Microsoft.OData.Core/ODataPayloadValueConverter.cs
index 7366cfe5b..a10ec1a6d 100644
--- a/src/Microsoft.OData.Core/ODataPayloadValueConverter.cs
+++ b/src/Microsoft.OData.Core/ODataPayloadValueConverter.cs
@@ -53,9 +53,8 @@ namespace Microsoft.OData
             try
             {
                 Type targetType = EdmLibraryExtensions.GetPrimitiveClrType(primitiveTypeReference.PrimitiveDefinition(), false);
-
-                string stringValue = value as string;
-                if (stringValue != null)
+
+                if (value is string stringValue)
                 {
                     return ConvertStringValue(stringValue, targetType);
                 }
@@ -63,9 +62,8 @@ namespace Microsoft.OData
                 {
                     return ConvertInt32Value((int)value, targetType, primitiveTypeReference);
                 }
-                else if (value is Decimal)
+                else if (value is Decimal decimalValue)
                 {
-                    Decimal decimalValue = (Decimal)value;
                     if (targetType == typeof(Int64))
                     {
                         return Convert.ToInt64(decimalValue);
@@ -86,9 +84,9 @@ namespace Microsoft.OData
                         throw new ODataException(ODataErrorStrings.ODataJsonReaderUtils_CannotConvertDecimal(primitiveTypeReference.FullName()));
                     }
                 }
-                else if (value is Double)
+                else if (value is Double d)
                 {
-                    return ConvertDoubleValue((Double)value, targetType, primitiveTypeReference);
+                    return ConvertDoubleValue(d, targetType, primitiveTypeReference);
                 }
                 else if (value is bool)
                 {
diff --git a/src/Microsoft.OData.Core/ODataPreferenceHeader.cs b/src/Microsoft.OData.Core/ODataPreferenceHeader.cs
index 4ee31f503..fa7f790ef 100644
--- a/src/Microsoft.OData.Core/ODataPreferenceHeader.cs
+++ b/src/Microsoft.OData.Core/ODataPreferenceHeader.cs
@@ -152,7 +152,7 @@ namespace Microsoft.OData
             get
             {
                 var returnContentPreference = this.Get(ReturnPreferenceTokenName);
-                if (returnContentPreference != null && returnContentPreference.Value != null)
+                if (returnContentPreference?.Value != null)
                 {
                     if (returnContentPreference.Value.ToLowerInvariant().Equals(ReturnRepresentationPreferenceTokenValue, System.StringComparison.Ordinal))
                     {
@@ -220,7 +220,7 @@ namespace Microsoft.OData
             {
                 var odataAnnotations = this.Get(ODataAnnotationPreferenceToken);
 
-                if (odataAnnotations != null && odataAnnotations.Value != null)
+                if (odataAnnotations?.Value != null)
                 {
                     return odataAnnotations.Value.Trim('"');
                 }
@@ -284,7 +284,7 @@ namespace Microsoft.OData
             {
                 var wait = this.Get(WaitPreferenceTokenName);
 
-                if (wait != null && wait.Value != null)
+                if (wait?.Value != null)
                 {
                     int value;
                     if (int.TryParse(wait.Value, out value))
@@ -355,7 +355,7 @@ namespace Microsoft.OData
             {
                 var maxPageSizeHttpHeaderValueElement = this.Get(ODataMaxPageSizePreferenceToken);
 
-                if (maxPageSizeHttpHeaderValueElement != null && maxPageSizeHttpHeaderValueElement.Value != null)
+                if (maxPageSizeHttpHeaderValueElement?.Value != null)
                 {
                     int value;
                     if (int.TryParse(maxPageSizeHttpHeaderValueElement.Value, out value))
diff --git a/src/Microsoft.OData.Core/ODataRawOutputContext.cs b/src/Microsoft.OData.Core/ODataRawOutputContext.cs
index 5b8a49b4d..add639578 100644
--- a/src/Microsoft.OData.Core/ODataRawOutputContext.cs
+++ b/src/Microsoft.OData.Core/ODataRawOutputContext.cs
@@ -353,9 +353,7 @@ namespace Microsoft.OData
         /// <remarks>Once the method returns all the data should be written, the only other call after this will be Dispose on the output context.</remarks>
         private void WriteValueImplementation(object value)
         {
-            byte[] binaryValue = value as byte[];
-
-            if (binaryValue != null)
+            if (value is byte[] binaryValue)
             {
                 // write the bytes directly
                 this.OutputStream.Write(binaryValue, 0, binaryValue.Length);
diff --git a/src/Microsoft.OData.Core/ODataRawValueUtils.cs b/src/Microsoft.OData.Core/ODataRawValueUtils.cs
index 8bd4d1fa3..e1cb0a350 100644
--- a/src/Microsoft.OData.Core/ODataRawValueUtils.cs
+++ b/src/Microsoft.OData.Core/ODataRawValueUtils.cs
@@ -76,9 +76,8 @@ namespace Microsoft.OData
                 result = ODataRawValueConverter.ToString((SByte)value);
                 return true;
             }
-
-            var str = value as string;
-            if (str != null)
+
+            if (value is string str)
             {
                 result = str;
                 return true;
@@ -89,9 +88,8 @@ namespace Microsoft.OData
                 result = ODataRawValueConverter.ToString((Single)value);
                 return true;
             }
-
-            byte[] bytes = value as byte[];
-            if (bytes != null)
+
+            if (value is byte[] bytes)
             {
                 result = ODataRawValueConverter.ToString(bytes);
                 return true;
diff --git a/src/Microsoft.OData.Core/ODataResource.cs b/src/Microsoft.OData.Core/ODataResource.cs
index 57033b60e..ead8c1a62 100644
--- a/src/Microsoft.OData.Core/ODataResource.cs
+++ b/src/Microsoft.OData.Core/ODataResource.cs
@@ -414,7 +414,7 @@ namespace Microsoft.OData
                     }
                     else if ((collection = property.Value as ODataCollectionValue) != null)
                     {
-                        if (collection != null && collection.Items != null && collection.Items.Any(t => t is ODataResourceValue))
+                        if (collection?.Items != null && collection.Items.Any(t => t is ODataResourceValue))
                         {
                             throw new ODataException(Strings.ODataResource_PropertyValueCannotBeODataResourceValue(property.Name));
                         }
diff --git a/src/Microsoft.OData.Core/ODataWriterCore.cs b/src/Microsoft.OData.Core/ODataWriterCore.cs
index 8109ff6da..473314997 100644
--- a/src/Microsoft.OData.Core/ODataWriterCore.cs
+++ b/src/Microsoft.OData.Core/ODataWriterCore.cs
@@ -2285,7 +2285,7 @@ namespace Microsoft.OData
                     && (newState == WriterState.ResourceSet || newState == WriterState.DeltaResourceSet))
                 {
                     var resourceSet = item as ODataResourceSetBase;
-                    if (resourceSet != null && resourceSet.TypeName != null && this.outputContext.Model.IsUserModel())
+                    if (resourceSet?.TypeName != null && this.outputContext.Model.IsUserModel())
                     {
                         var collectionType = TypeNameOracle.ResolveAndValidateTypeName(
                             this.outputContext.Model,
diff --git a/src/Microsoft.OData.Core/RawValueWriter.cs b/src/Microsoft.OData.Core/RawValueWriter.cs
index d41367451..24267b208 100644
--- a/src/Microsoft.OData.Core/RawValueWriter.cs
+++ b/src/Microsoft.OData.Core/RawValueWriter.cs
@@ -120,8 +120,8 @@ namespace Microsoft.OData
             Debug.Assert(!(value is byte[]), "!(value is byte[])");
 
             string valueAsString;
-            ODataEnumValue enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 this.textWriter.Write(enumValue.Value);
             }
diff --git a/src/Microsoft.OData.Core/TaskUtils.cs b/src/Microsoft.OData.Core/TaskUtils.cs
index efffa4d47..73d6c37af 100644
--- a/src/Microsoft.OData.Core/TaskUtils.cs
+++ b/src/Microsoft.OData.Core/TaskUtils.cs
@@ -547,11 +547,9 @@ namespace Microsoft.OData.Client
                     {
                         throw;
                     }
-
-                    // If MoveNext throws an exception, propagate that to the user,
-                    // either as cancellation or as a fault
-                    var oce = exc as OperationCanceledException;
-                    if (oce != null && oce.CancellationToken == factory.CancellationToken)
+
+                    // If MoveNext throws an exception, propagate that to the user,                    // either as cancellation or as a fault
+                    if (exc is OperationCanceledException oce && oce.CancellationToken == factory.CancellationToken)
                     {
                         trc.TrySetCanceled();
                     }
@@ -721,8 +719,8 @@ namespace Microsoft.OData.Client
                             break;
                         case TaskStatus.Faulted:
                             Exception exception = t.Exception;
-                            AggregateException aggregateException = exception as AggregateException;
-                            if (aggregateException != null)
+
+                            if (exception is AggregateException aggregateException)
                             {
                                 aggregateException = aggregateException.Flatten();
                                 if (aggregateException.InnerExceptions.Count == 1)
@@ -731,11 +729,11 @@ namespace Microsoft.OData.Client
                                 }
                             }
 
-                            if (exception is TExceptionType)
+                            if (exception is TExceptionType tExceptionType)
                             {
                                 try
                                 {
-                                    taskCompletionSource.TrySetResult(catchBlock((TExceptionType)exception));
+                                    taskCompletionSource.TrySetResult(catchBlock(tExceptionType));
                                 }
                                 catch (Exception secondException)
                                 {
diff --git a/src/Microsoft.OData.Core/TypeNameOracle.cs b/src/Microsoft.OData.Core/TypeNameOracle.cs
index 4cc1b4b46..bd0365786 100644
--- a/src/Microsoft.OData.Core/TypeNameOracle.cs
+++ b/src/Microsoft.OData.Core/TypeNameOracle.cs
@@ -229,9 +229,8 @@ namespace Microsoft.OData
         protected static string GetTypeNameFromValue(object value)
         {
             Debug.Assert(value != null, "value != null");
-
-            ODataPrimitiveValue primitiveValue = value as ODataPrimitiveValue;
-            if (primitiveValue != null)
+
+            if (value is ODataPrimitiveValue primitiveValue)
             {
                 // primitiveValueTypeReference == null means: the EDM type of the primitive value cannot be determined.
                 // This could possibly be due to value being an unsigned int.
@@ -242,33 +241,28 @@ namespace Microsoft.OData
                 IEdmPrimitiveTypeReference primitiveValueTypeReference = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.Value.GetType());
                 return primitiveValueTypeReference == null ? null : primitiveValueTypeReference.FullName();
             }
-
-            ODataEnumValue enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 return enumValue.TypeName;
             }
-
-            ODataResourceValue resourceValue = value as ODataResourceValue;
-            if (resourceValue != null)
+
+            if (value is ODataResourceValue resourceValue)
             {
                 return resourceValue.TypeName;
             }
-
-            ODataCollectionValue collectionValue = value as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (value is ODataCollectionValue collectionValue)
             {
                 return EdmLibraryExtensions.GetCollectionTypeFullName(collectionValue.TypeName);
             }
-
-            ODataBinaryStreamValue binaryStreamValue = value as ODataBinaryStreamValue;
-            if (binaryStreamValue != null)
+
+            if (value is ODataBinaryStreamValue binaryStreamValue)
             {
                 return EdmCoreModel.Instance.GetPrimitive(EdmPrimitiveTypeKind.Binary, true).FullName();
             }
-
-            ODataStreamReferenceValue streamValue = value as ODataStreamReferenceValue;
-            if (streamValue != null)
+
+            if (value is ODataStreamReferenceValue streamValue)
             {
                 return EdmCoreModel.Instance.GetPrimitive(EdmPrimitiveTypeKind.Stream, true).FullName();
             }
diff --git a/src/Microsoft.OData.Core/Uri/ODataUriConversionUtils.cs b/src/Microsoft.OData.Core/Uri/ODataUriConversionUtils.cs
index 7d1189ae9..b311030b3 100644
--- a/src/Microsoft.OData.Core/Uri/ODataUriConversionUtils.cs
+++ b/src/Microsoft.OData.Core/Uri/ODataUriConversionUtils.cs
@@ -110,10 +110,9 @@ namespace Microsoft.OData
             ExceptionUtils.CheckArgumentNotNull(literalValue, "literalValue");
             ExceptionUtils.CheckArgumentNotNull(model, "model");
             ExceptionUtils.CheckArgumentNotNull(expectedTypeReference, "expectedTypeReference");
-
-            // First deal with null literal
-            ODataNullValue nullValue = primitiveValue as ODataNullValue;
-            if (nullValue != null)
+
+            // First deal with null literal
+            if (primitiveValue is ODataNullValue nullValue)
             {
                 if (!expectedTypeReference.IsNullable)
                 {
@@ -515,8 +514,8 @@ namespace Microsoft.OData
                     break;
 
                 case EdmPrimitiveTypeKind.Date:
-                    var stringValue = primitiveValue as string;
-                    if (stringValue != null)
+
+                    if (primitiveValue is string stringValue)
                     {
                         // Coerce to Date Type from String.
                         return PlatformHelper.ConvertStringToDate(stringValue);
@@ -535,8 +534,7 @@ namespace Microsoft.OData
         /// <param name="resource">The resource, or deleted resource, to write.</param>
         private static void WriteStartResource(ODataWriter writer, ODataResourceBase resource)
         {
-            ODataDeletedResource deletedResource = resource as ODataDeletedResource;
-            if (deletedResource != null)
+            if (resource is ODataDeletedResource deletedResource)
             {
                 writer.WriteStart(deletedResource);
             }
diff --git a/src/Microsoft.OData.Core/Uri/ODataUriUtils.cs b/src/Microsoft.OData.Core/Uri/ODataUriUtils.cs
index abf778d16..3ecebe8a0 100644
--- a/src/Microsoft.OData.Core/Uri/ODataUriUtils.cs
+++ b/src/Microsoft.OData.Core/Uri/ODataUriUtils.cs
@@ -151,51 +151,43 @@ namespace Microsoft.OData
             {
                 model = Microsoft.OData.Edm.EdmCoreModel.Instance;
             }
-
-            ODataNullValue nullValue = value as ODataNullValue;
-            if (nullValue != null)
+
+            if (value is ODataNullValue nullValue)
             {
                 return ExpressionConstants.KeywordNull;
             }
-
-            ODataResourceValue resourceValue = value as ODataResourceValue;
-            if (resourceValue != null)
+
+            if (value is ODataResourceValue resourceValue)
             {
                 return ODataUriConversionUtils.ConvertToResourceLiteral(resourceValue, model, version);
             }
-
-            ODataCollectionValue collectionValue = value as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (value is ODataCollectionValue collectionValue)
             {
                 return ODataUriConversionUtils.ConvertToUriCollectionLiteral(collectionValue, model, version, isIeee754Compatible);
             }
-
-            ODataEnumValue enumValue = value as ODataEnumValue;
-            if (enumValue != null)
+
+            if (value is ODataEnumValue enumValue)
             {
                 return ODataUriConversionUtils.ConvertToUriEnumLiteral(enumValue, version);
             }
-
-            ODataResourceBase resource = value as ODataResourceBase;
-            if (resource != null)
+
+            if (value is ODataResourceBase resource)
             {
                 return ODataUriConversionUtils.ConvertToUriEntityLiteral(resource, model);
             }
-
-            ODataEntityReferenceLink link = value as ODataEntityReferenceLink;
-            if (link != null)
+
+            if (value is ODataEntityReferenceLink link)
             {
                 return ODataUriConversionUtils.ConvertToUriEntityReferenceLiteral(link, model);
             }
-
-            ODataEntityReferenceLinks links = value as ODataEntityReferenceLinks;
-            if (links != null)
+
+            if (value is ODataEntityReferenceLinks links)
             {
                 return ODataUriConversionUtils.ConvertToUriEntityReferencesLiteral(links, model);
             }
-
-            IEnumerable<ODataResourceBase> list = value as IEnumerable<ODataResourceBase>;
-            if (list != null)
+
+            if (value is IEnumerable<ODataResourceBase> list)
             {
                 return ODataUriConversionUtils.ConvertToUriEntitiesLiteral(list, model);
             }
diff --git a/src/Microsoft.OData.Core/UriParser/Aggregation/ApplyBinder.cs b/src/Microsoft.OData.Core/UriParser/Aggregation/ApplyBinder.cs
index c2898749e..1b0b188b4 100644
--- a/src/Microsoft.OData.Core/UriParser/Aggregation/ApplyBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Aggregation/ApplyBinder.cs
@@ -163,8 +163,7 @@ namespace Microsoft.OData.UriParser.Aggregation
             IEdmTypeReference expressionType = expression.TypeReference;
             if (expressionType == null && aggregateExpressionsCache != null)
             {
-                SingleValueOpenPropertyAccessNode openProperty = expression as SingleValueOpenPropertyAccessNode;
-                if (openProperty != null)
+                if (expression is SingleValueOpenPropertyAccessNode openProperty)
                 {
                     expressionType = GetTypeReferenceByPropertyName(openProperty.Name);
                 }
@@ -230,21 +229,18 @@ namespace Microsoft.OData.UriParser.Aggregation
             foreach (EndPathToken propertyToken in token.Properties)
             {
                 QueryNode bindResult = this.bindMethod(propertyToken);
-                SingleValuePropertyAccessNode property = bindResult as SingleValuePropertyAccessNode;
-                SingleComplexNode complexProperty = bindResult as SingleComplexNode;
 
-                if (property != null)
+                if (bindResult is SingleValuePropertyAccessNode property)
                 {
                     RegisterProperty(properties, ReversePropertyPath(property));
                 }
-                else if (complexProperty != null)
+                else if (bindResult is SingleComplexNode complexProperty)
                 {
                     RegisterProperty(properties, ReversePropertyPath(complexProperty));
                 }
                 else
                 {
-                    SingleValueOpenPropertyAccessNode openProperty = bindResult as SingleValueOpenPropertyAccessNode;
-                    if (openProperty != null)
+                    if (bindResult is SingleValueOpenPropertyAccessNode openProperty)
                     {
                         IEdmTypeReference type = GetTypeReferenceByPropertyName(openProperty.Name);
                         properties.Add(new GroupByPropertyNode(openProperty.Name, openProperty, type));
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/DottedIdentifierBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/DottedIdentifierBinder.cs
index 411f65a64..277a140ec 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/DottedIdentifierBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/DottedIdentifierBinder.cs
@@ -83,8 +83,7 @@ namespace Microsoft.OData.UriParser
                     IEdmTypeReference edmTypeReference = UriEdmHelpers.FindTypeFromModel(state.Model, dottedIdentifierToken.Identifier, this.Resolver).ToTypeReference();
                     if (edmTypeReference is IEdmPrimitiveTypeReference || edmTypeReference is IEdmEnumTypeReference)
                     {
-                        IEdmPrimitiveType childPrimitiveType = childType as IEdmPrimitiveType;
-                        if (childPrimitiveType != null && dottedIdentifierToken.NextToken != null)
+                        if (childType is IEdmPrimitiveType childPrimitiveType && dottedIdentifierToken.NextToken != null)
                         {
                             return new SingleValueCastNode(singleValueNode, childPrimitiveType);
                         }
@@ -104,9 +103,8 @@ namespace Microsoft.OData.UriParser
             UriEdmHelpers.CheckRelatedTo(parentType, childType);
 
             this.state.ParsedSegments.Add(new TypeSegment(childType, parentType, null));
-
-            CollectionResourceNode parentAsCollection = parent as CollectionResourceNode;
-            if (parentAsCollection != null)
+
+            if (parent is CollectionResourceNode parentAsCollection)
             {
                 return new CollectionResourceCastNode(parentAsCollection, childStructuredType);
             }
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/EndPathBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/EndPathBinder.cs
index 306d11ee7..8f0f683fd 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/EndPathBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/EndPathBinder.cs
@@ -139,9 +139,8 @@ namespace Microsoft.OData.UriParser
             QueryNode parent = this.DetermineParentNode(endPathToken);
 
             QueryNode boundFunction;
-
-            SingleValueNode singleValueParent = parent as SingleValueNode;
-            if (singleValueParent != null)
+
+            if (parent is SingleValueNode singleValueParent)
             {
                 if (endPathToken.Identifier == ExpressionConstants.QueryOptionCount)
                 {
@@ -172,18 +171,15 @@ namespace Microsoft.OData.UriParser
 
                 return GeneratePropertyAccessQueryForOpenType(endPathToken, singleValueParent);
             }
-
-            // Collection with any or all expression is already supported and handled separately.
-            // Add support of collection with $count segment.
-            CollectionNode colNode = parent as CollectionNode;
-            if (colNode != null && endPathToken.Identifier.Equals(UriQueryConstants.CountSegment, System.StringComparison.Ordinal))
+
+            // Collection with any or all expression is already supported and handled separately.            // Add support of collection with $count segment.
+            if (parent is CollectionNode colNode && endPathToken.Identifier.Equals(UriQueryConstants.CountSegment, System.StringComparison.Ordinal))
             {
                 // create a collection count node for collection node property.
                 return new CountNode(colNode);
             }
-
-            CollectionNavigationNode collectionParent = parent as CollectionNavigationNode;
-            if (collectionParent != null)
+
+            if (parent is CollectionNavigationNode collectionParent)
             {
                 IEdmEntityTypeReference parentType = collectionParent.EntityItemType;
                 IEdmProperty property = this.Resolver.ResolveProperty(parentType.StructuredDefinition(), endPathToken.Identifier);
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/InBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/InBinder.cs
index 5fdf01b06..8b2e00e0d 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/InBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/InBinder.cs
@@ -76,8 +76,8 @@ namespace Microsoft.OData.UriParser
         private CollectionNode GetCollectionOperandFromToken(QueryToken queryToken, IEdmTypeReference expectedType, IEdmModel model)
         {
             CollectionNode operand = null;
-            LiteralToken literalToken = queryToken as LiteralToken;
-            if (literalToken != null)
+
+            if (queryToken is LiteralToken literalToken)
             {
                 string originalLiteralText = literalToken.OriginalText;
 
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/InnerPathTokenBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/InnerPathTokenBinder.cs
index 58890a29e..c01574ff0 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/InnerPathTokenBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/InnerPathTokenBinder.cs
@@ -140,9 +140,7 @@ namespace Microsoft.OData.UriParser
                     return boundFunction;
                 }
 
-                CollectionNavigationNode collectionParent = parent as CollectionNavigationNode;
-
-                if (collectionParent != null)
+                if (parent is CollectionNavigationNode collectionParent)
                 {
                     IEdmEntityTypeReference parentType = collectionParent.EntityItemType;
                     IEdmProperty collectionProperty = this.Resolver.ResolveProperty(parentType.StructuredDefinition(), segmentToken.Identifier);
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/LiteralBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/LiteralBinder.cs
index fd017c187..d5152c30a 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/LiteralBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/LiteralBinder.cs
@@ -48,12 +48,9 @@ namespace Microsoft.OData.UriParser
             {
                 if (literalToken.ExpectedEdmTypeReference != null)
                 {
-                    OData.Edm.IEdmCollectionTypeReference collectionReference =
-                        literalToken.ExpectedEdmTypeReference as OData.Edm.IEdmCollectionTypeReference;
-                    if (collectionReference != null)
+                    if (literalToken.ExpectedEdmTypeReference is OData.Edm.IEdmCollectionTypeReference collectionReference)
                     {
-                        ODataCollectionValue collectionValue = literalToken.Value as ODataCollectionValue;
-                        if (collectionValue != null)
+                        if (literalToken.Value is ODataCollectionValue collectionValue)
                         {
                             return new CollectionConstantNode(collectionValue.Items, literalToken.OriginalText, collectionReference);
                         }
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/MetadataBindingUtils.cs b/src/Microsoft.OData.Core/UriParser/Binders/MetadataBindingUtils.cs
index 3ed69bfb3..b0252e8b2 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/MetadataBindingUtils.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/MetadataBindingUtils.cs
@@ -58,7 +58,7 @@ namespace Microsoft.OData.UriParser
                 }
 
                 ConstantNode constantNode = source as ConstantNode;
-                if (constantNode != null && constantNode.Value != null && source.TypeReference.IsString() && targetTypeReference.IsEnum())
+                if (constantNode?.Value != null && source.TypeReference.IsString() && targetTypeReference.IsEnum())
                 {
                     string memberName = constantNode.Value.ToString();
                     IEdmEnumType enumType = targetTypeReference.Definition as IEdmEnumType;
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/ParameterAliasBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/ParameterAliasBinder.cs
index 1b47ad4f6..6f1d01af9 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/ParameterAliasBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/ParameterAliasBinder.cs
@@ -107,9 +107,8 @@ namespace Microsoft.OData.UriParser
         /// <returns>Token with complex/collection value passed.</returns>
         private static QueryToken ParseComplexOrCollectionAlias(QueryToken queryToken, IEdmTypeReference parameterType, IEdmModel model)
         {
-            LiteralToken valueToken = queryToken as LiteralToken;
             string valueStr;
-            if (valueToken != null && (valueStr = valueToken.Value as string) != null && !string.IsNullOrEmpty(valueToken.OriginalText))
+            if (queryToken is LiteralToken valueToken && (valueStr = valueToken.Value as string) != null && !string.IsNullOrEmpty(valueToken.OriginalText))
             {
                 var lexer = new ExpressionLexer(valueToken.OriginalText, true /*moveToFirstToken*/, false /*useSemicolonDelimiter*/, true /*parsingFunctionParameters*/);
                 if (lexer.CurrentToken.Kind == ExpressionTokenKind.BracketedExpression || lexer.CurrentToken.Kind == ExpressionTokenKind.BracedExpression)
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/SelectExpandBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/SelectExpandBinder.cs
index c197b2cc5..d4e47668d 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/SelectExpandBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/SelectExpandBinder.cs
@@ -204,7 +204,7 @@ namespace Microsoft.OData.UriParser
                 sb.Append(curr.Identifier);
 
                 NonSystemToken nonSystem = curr as NonSystemToken;
-                if (nonSystem != null && nonSystem.NamedValues != null)
+                if (nonSystem?.NamedValues != null)
                 {
                     sb.Append("(");
                     bool first = true;
diff --git a/src/Microsoft.OData.Core/UriParser/Binders/SelectPathSegmentTokenBinder.cs b/src/Microsoft.OData.Core/UriParser/Binders/SelectPathSegmentTokenBinder.cs
index 097a6dd8c..8a7093928 100644
--- a/src/Microsoft.OData.Core/UriParser/Binders/SelectPathSegmentTokenBinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Binders/SelectPathSegmentTokenBinder.cs
@@ -153,7 +153,7 @@ namespace Microsoft.OData.UriParser
                 else
                 {
                     NonSystemToken nonSystemToken = pathToken as NonSystemToken;
-                    if (nonSystemToken != null && nonSystemToken.NamedValues != null)
+                    if (nonSystemToken?.NamedValues != null)
                     {
                         parameterNames = nonSystemToken.NamedValues.Select(s => s.Name).ToList();
                     }
diff --git a/src/Microsoft.OData.Core/UriParser/Parsers/ExpandDepthAndCountValidator.cs b/src/Microsoft.OData.Core/UriParser/Parsers/ExpandDepthAndCountValidator.cs
index e62dd539a..e3fbce29d 100644
--- a/src/Microsoft.OData.Core/UriParser/Parsers/ExpandDepthAndCountValidator.cs
+++ b/src/Microsoft.OData.Core/UriParser/Parsers/ExpandDepthAndCountValidator.cs
@@ -77,7 +77,7 @@ namespace Microsoft.OData.UriParser
                 this.EnsureMaximumCountAndDepthAreNotExceeded(expandItem.SelectAndExpand, currentDepth + 1);
             }
 
-            this.currentCount += expandTree.SelectedItems.Where(I => I.GetType() == typeof(ExpandedReferenceSelectItem)).Count();
+            this.currentCount += expandTree.SelectedItems.Count(I => I.GetType() == typeof(ExpandedReferenceSelectItem));
             if (this.currentCount > this.maxCount)
             {
                 throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.UriParser_ExpandCountExceeded(this.currentCount, this.maxCount));
diff --git a/src/Microsoft.OData.Core/UriParser/Parsers/KeyFinder.cs b/src/Microsoft.OData.Core/UriParser/Parsers/KeyFinder.cs
index 87d901e2f..32ce6494d 100644
--- a/src/Microsoft.OData.Core/UriParser/Parsers/KeyFinder.cs
+++ b/src/Microsoft.OData.Core/UriParser/Parsers/KeyFinder.cs
@@ -137,7 +137,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>All referential constraint property pairs that match the list of target key properties.</returns>
         private static IEnumerable<EdmReferentialConstraintPropertyPair> ExtractMatchingPropertyPairsFromNavProp(IEdmNavigationProperty currentNavigationProperty, IEnumerable<IEdmStructuralProperty> targetKeyPropertyList)
         {
-            if (currentNavigationProperty != null && currentNavigationProperty.ReferentialConstraint != null)
+            if (currentNavigationProperty?.ReferentialConstraint != null)
             {
                 // currentNavigationProperty.ReferentialConstraint has mapping of source property(dependent)-> target referencedProperty(principal)
                 // so check PrincipalProperty against targetKeyPropertyList
@@ -157,7 +157,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>All referential constraint property pairs that match the list of target key properties.</returns>
         private static IEnumerable<EdmReferentialConstraintPropertyPair> ExtractMatchingPropertyPairsFromReversedNavProp(IEdmNavigationProperty currentNavigationProperty, IEnumerable<IEdmStructuralProperty> targetKeyPropertyList)
         {
-            if (currentNavigationProperty != null && currentNavigationProperty.ReferentialConstraint != null)
+            if (currentNavigationProperty?.ReferentialConstraint != null)
             {
                 // currentNavigationProperty.ReferentialConstraint has mapping of target property(dependent)-> source referencedProperty(principal)
                 // so check DependentProperty against targetKeyPropertyList
@@ -177,13 +177,8 @@ namespace Microsoft.OData.UriParser
         /// <returns>The converted URI literal for the given key value.</returns>
         private static string ConvertKeyValueToUriLiteral(object value, bool keyAsSegment)
         {
-            // For Default convention,
-            //   ~/Customers('Peter') => key value is "Peter" => URI literal is "'Peter'"
-            //
-            // For KeyAsSegment convention,
-            //   ~/Customers/Peter => key value is "Peter" => URI literal is "Peter"
-            string stringValue = value as string;
-            if (keyAsSegment && stringValue != null)
+            // For Default convention,            //   ~/Customers('Peter') => key value is "Peter" => URI literal is "'Peter'"            //            // For KeyAsSegment convention,            //   ~/Customers/Peter => key value is "Peter" => URI literal is "Peter"
+            if (keyAsSegment && value is string stringValue)
             {
                 return stringValue;
             }
diff --git a/src/Microsoft.OData.Core/UriParser/Parsers/ODataPathParser.cs b/src/Microsoft.OData.Core/UriParser/Parsers/ODataPathParser.cs
index b9b063e97..57fdce2fe 100644
--- a/src/Microsoft.OData.Core/UriParser/Parsers/ODataPathParser.cs
+++ b/src/Microsoft.OData.Core/UriParser/Parsers/ODataPathParser.cs
@@ -1804,7 +1804,7 @@ namespace Microsoft.OData.UriParser
                 anotherEscapeFunctionStarts = true;
             }
 
-            bool isComposableRequired = identifier != null && identifier.Length >= 1 && identifier[identifier.Length - 1] == ':';
+            bool isComposableRequired = !string.IsNullOrEmpty(identifier) && identifier[identifier.Length - 1] == ':';
 
             function = FindBestMatchForEscapeFunction(candidates, isComposableRequired, bindingType);
 
diff --git a/src/Microsoft.OData.Core/UriParser/Parsers/SegmentArgumentParser.cs b/src/Microsoft.OData.Core/UriParser/Parsers/SegmentArgumentParser.cs
index 48b6ad5ab..dc1ff2208 100644
--- a/src/Microsoft.OData.Core/UriParser/Parsers/SegmentArgumentParser.cs
+++ b/src/Microsoft.OData.Core/UriParser/Parsers/SegmentArgumentParser.cs
@@ -293,8 +293,8 @@ namespace Microsoft.OData.UriParser
             foreach (FunctionParameterToken t in tmp)
             {
                 string valueText = null;
-                LiteralToken literalToken = t.ValueToken as LiteralToken;
-                if (literalToken != null)
+
+                if (t.ValueToken is LiteralToken literalToken)
                 {
                     valueText = literalToken.OriginalText;
 
@@ -307,8 +307,8 @@ namespace Microsoft.OData.UriParser
                 }
                 else
                 {
-                    DottedIdentifierToken dottedIdentifierToken = t.ValueToken as DottedIdentifierToken; // for enum
-                    if (dottedIdentifierToken != null)
+ // for enum
+                    if (t.ValueToken is DottedIdentifierToken dottedIdentifierToken)
                     {
                         valueText = dottedIdentifierToken.Identifier;
                     }
diff --git a/src/Microsoft.OData.Core/UriParser/Parsers/SegmentKeyHandler.cs b/src/Microsoft.OData.Core/UriParser/Parsers/SegmentKeyHandler.cs
index af3eea590..c7efca888 100644
--- a/src/Microsoft.OData.Core/UriParser/Parsers/SegmentKeyHandler.cs
+++ b/src/Microsoft.OData.Core/UriParser/Parsers/SegmentKeyHandler.cs
@@ -157,8 +157,7 @@ namespace Microsoft.OData.UriParser
             var keyProperties = targetEntityType.Key().ToList();
             if (keyProperties.Count != key.ValueCount)
             {
-                NavigationPropertySegment currentNavPropSegment = segment as NavigationPropertySegment;
-                if (currentNavPropSegment != null)
+                if (segment is NavigationPropertySegment currentNavPropSegment)
                 {
                     key = KeyFinder.FindAndUseKeysFromRelatedSegment(key, keyProperties, currentNavPropSegment.NavigationProperty, previousKeySegment);
                 }
diff --git a/src/Microsoft.OData.Core/UriParser/Parsers/UriQueryExpressionParser.cs b/src/Microsoft.OData.Core/UriParser/Parsers/UriQueryExpressionParser.cs
index cc99842ec..353ad8bad 100644
--- a/src/Microsoft.OData.Core/UriParser/Parsers/UriQueryExpressionParser.cs
+++ b/src/Microsoft.OData.Core/UriParser/Parsers/UriQueryExpressionParser.cs
@@ -480,10 +480,9 @@ namespace Microsoft.OData.UriParser
                 }
 
                 AggregationMethodDefinition verb;
-
-                // "with" verb
-                EndPathToken endPathExpression = expression as EndPathToken;
-                if (endPathExpression != null && endPathExpression.Identifier == ExpressionConstants.QueryOptionCount)
+
+                // "with" verb
+                if (expression is EndPathToken endPathExpression && endPathExpression.Identifier == ExpressionConstants.QueryOptionCount)
                 {
                     // e.g. aggregate($count as Count)
                     verb = AggregationMethodDefinition.VirtualPropertyCount;
diff --git a/src/Microsoft.OData.Core/UriParser/Resolver/ODataUriResolver.cs b/src/Microsoft.OData.Core/UriParser/Resolver/ODataUriResolver.cs
index 506fb5d5b..0bd1c266a 100644
--- a/src/Microsoft.OData.Core/UriParser/Resolver/ODataUriResolver.cs
+++ b/src/Microsoft.OData.Core/UriParser/Resolver/ODataUriResolver.cs
@@ -499,9 +499,9 @@ namespace Microsoft.OData.UriParser
             {
                 if (string.Equals(qualifiedName, schema.FullName(), caseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal))
                 {
-                    if (schema is T)
+                    if (schema is T t)
                     {
-                        results.Add((T)schema);
+                        results.Add(t);
                     }
                 }
             }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/AnnotationSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/AnnotationSegment.cs
index 53d60f541..1bd3a353a 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/AnnotationSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/AnnotationSegment.cs
@@ -88,8 +88,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            AnnotationSegment otherTerm = other as AnnotationSegment;
-            return otherTerm != null && otherTerm.term == this.term;
+            return other is AnnotationSegment otherTerm && otherTerm.term == this.term;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/BatchReferenceSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/BatchReferenceSegment.cs
index 09ccc2c95..24a7c3959 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/BatchReferenceSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/BatchReferenceSegment.cs
@@ -122,8 +122,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>true if the other segment is equal.</returns>
         internal override bool Equals(ODataPathSegment other)
         {
-            BatchReferenceSegment otherBatchReferenceSegment = other as BatchReferenceSegment;
-            return otherBatchReferenceSegment != null &&
+            return other is BatchReferenceSegment otherBatchReferenceSegment &&
                 otherBatchReferenceSegment.EdmType == this.edmType &&
                 otherBatchReferenceSegment.EntitySet == this.entitySet &&
                 otherBatchReferenceSegment.ContentId == this.contentId;
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/DynamicPathSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/DynamicPathSegment.cs
index 75369d0ea..60f02cc2b 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/DynamicPathSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/DynamicPathSegment.cs
@@ -89,8 +89,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            DynamicPathSegment otherDynamicPathSegment = other as DynamicPathSegment;
-            return otherDynamicPathSegment != null
+            return other is DynamicPathSegment otherDynamicPathSegment
                 && otherDynamicPathSegment.Identifier == this.Identifier
                 && otherDynamicPathSegment.EdmType == this.EdmType
                 && otherDynamicPathSegment.TargetEdmNavigationSource == this.TargetEdmNavigationSource
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/EachSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/EachSegment.cs
index fe04e5847..5b9685c27 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/EachSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/EachSegment.cs
@@ -82,9 +82,8 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            EachSegment otherSegment = other as EachSegment;
 
-            return otherSegment != null &&
+            return other is EachSegment otherSegment &&
                 otherSegment.TargetEdmNavigationSource == this.TargetEdmNavigationSource;
         }
     }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/EntitySetSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/EntitySetSegment.cs
index 62bcbc39d..6a534f08d 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/EntitySetSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/EntitySetSegment.cs
@@ -94,8 +94,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            EntitySetSegment otherEntitySet = other as EntitySetSegment;
-            return otherEntitySet != null && otherEntitySet.EntitySet == this.EntitySet;
+            return other is EntitySetSegment otherEntitySet && otherEntitySet.EntitySet == this.EntitySet;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/FilterSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/FilterSegment.cs
index a45878181..18a2ca0f9 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/FilterSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/FilterSegment.cs
@@ -138,9 +138,8 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            FilterSegment otherSegment = other as FilterSegment;
 
-            return otherSegment != null &&
+            return other is FilterSegment otherSegment &&
                 otherSegment.TargetEdmNavigationSource == this.TargetEdmNavigationSource &&
                 otherSegment.Expression == this.Expression &&
                 otherSegment.ItemType == this.ItemType &&
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/KeySegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/KeySegment.cs
index 420ca87d0..43381e012 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/KeySegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/KeySegment.cs
@@ -134,8 +134,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            KeySegment otherKeySegment = other as KeySegment;
-            return otherKeySegment != null &&
+            return other is KeySegment otherKeySegment &&
                    otherKeySegment.Keys.SequenceEqual(this.Keys) &&
                    otherKeySegment.EdmType == this.edmType &&
                    otherKeySegment.NavigationSource == this.navigationSource;
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertyLinkSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertyLinkSegment.cs
index a09726a57..0e06f4b98 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertyLinkSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertyLinkSegment.cs
@@ -98,8 +98,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            NavigationPropertyLinkSegment otherLinkSegment = other as NavigationPropertyLinkSegment;
-            return otherLinkSegment != null && otherLinkSegment.NavigationProperty == this.navigationProperty;
+            return other is NavigationPropertyLinkSegment otherLinkSegment && otherLinkSegment.NavigationProperty == this.navigationProperty;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertySegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertySegment.cs
index e2ab1a86a..26a9e7bcd 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertySegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/NavigationPropertySegment.cs
@@ -99,8 +99,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            NavigationPropertySegment otherNavPropSegment = other as NavigationPropertySegment;
-            return otherNavPropSegment != null && otherNavPropSegment.NavigationProperty == this.NavigationProperty;
+            return other is NavigationPropertySegment otherNavPropSegment && otherNavPropSegment.NavigationProperty == this.NavigationProperty;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/ODataPathExtensions.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/ODataPathExtensions.cs
index d6c0606bf..fd0e45b15 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/ODataPathExtensions.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/ODataPathExtensions.cs
@@ -187,15 +187,12 @@ namespace Microsoft.OData.UriParser
             bool foundOperationWithoutPath = false;
             foreach (ODataPathSegment segment in path)
             {
-                OperationSegment operationSegment = segment as OperationSegment;
-                OperationImportSegment operationImportSegment = segment as OperationImportSegment;
-                if (operationImportSegment != null)
+                if (segment is OperationImportSegment operationImportSegment)
                 {
                     IEdmOperationImport operationImport = operationImportSegment.OperationImports.FirstOrDefault();
                     Debug.Assert(operationImport != null);
-
-                    EdmPathExpression pathExpression = operationImport.EntitySet as EdmPathExpression;
-                    if (pathExpression != null)
+
+                    if (operationImport.EntitySet is EdmPathExpression pathExpression)
                     {
                         Debug.Assert(priorSegment == null); // operation import is always the first segment?
                         pathString.Append(pathExpression.Path);
@@ -209,7 +206,7 @@ namespace Microsoft.OData.UriParser
                         foundOperationWithoutPath = true;
                     }
                 }
-                else if (operationSegment != null)
+                else if (segment is OperationSegment operationSegment)
                 {
                     IEdmOperation operation = operationSegment.Operations.FirstOrDefault();
                     Debug.Assert(operation != null);
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationImportSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationImportSegment.cs
index 3b672ff15..52b069fc8 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationImportSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationImportSegment.cs
@@ -233,8 +233,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            OperationImportSegment otherOperation = other as OperationImportSegment;
-            return otherOperation != null &&
+            return other is OperationImportSegment otherOperation &&
                    otherOperation.OperationImports.SequenceEqual(this.OperationImports) &&
                    otherOperation.EntitySet == this.entitySet;
         }
@@ -261,8 +260,8 @@ namespace Microsoft.OData.UriParser
 
             // Unwrap the return type if it's a collection
             var unwrappedCollectionType = this.computedReturnEdmType;
-            var collectionType = this.computedReturnEdmType as IEdmCollectionType;
-            if (collectionType != null)
+
+            if (this.computedReturnEdmType is IEdmCollectionType collectionType)
             {
                 unwrappedCollectionType = collectionType.ElementType.Definition;
             }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationSegment.cs
index 0f10b4f70..72041083e 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/OperationSegment.cs
@@ -229,8 +229,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            OperationSegment otherOperation = other as OperationSegment;
-            return otherOperation != null &&
+            return other is OperationSegment otherOperation &&
                    otherOperation.Operations.SequenceEqual(this.Operations) &&
                    otherOperation.EntitySet == this.entitySet;
         }
@@ -257,8 +256,8 @@ namespace Microsoft.OData.UriParser
 
             // Unwrap the return type if it's a collection
             var unwrappedCollectionType = this.computedReturnEdmType;
-            var collectionType = this.computedReturnEdmType as IEdmCollectionType;
-            if (collectionType != null)
+
+            if (this.computedReturnEdmType is IEdmCollectionType collectionType)
             {
                 unwrappedCollectionType = collectionType.ElementType.Definition;
             }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/PropertySegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/PropertySegment.cs
index 1c9fc2df6..419a80504 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/PropertySegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/PropertySegment.cs
@@ -87,8 +87,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            PropertySegment otherProperty = other as PropertySegment;
-            return otherProperty != null && otherProperty.Property == this.Property;
+            return other is PropertySegment otherProperty && otherProperty.Property == this.Property;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/ReferenceSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/ReferenceSegment.cs
index 369d41786..603ed11e0 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/ReferenceSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/ReferenceSegment.cs
@@ -71,9 +71,8 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            ReferenceSegment otherSegment = other as ReferenceSegment;
 
-            return otherSegment != null && otherSegment.TargetEdmNavigationSource == this.TargetEdmNavigationSource;
+            return other is ReferenceSegment otherSegment && otherSegment.TargetEdmNavigationSource == this.TargetEdmNavigationSource;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClause.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClause.cs
index c9916b9ec..b06f65635 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClause.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClause.cs
@@ -96,7 +96,7 @@ namespace Microsoft.OData.UriParser
                     else if (getOnlySubset)
                     {
                         var pathItem = selectedItem as PathSelectItem;
-                        if (pathItem != null && pathItem.SelectAndExpand != null)
+                        if (pathItem?.SelectAndExpand != null)
                         {
                             newSelectedItems.Add(selectedItem);
                         }
@@ -129,8 +129,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>true if this selection item is a structural property selection item.</returns>
         private static bool IsStructuralOrNavigationPropertySelectionItem(SelectItem selectItem)
         {
-            PathSelectItem pathSelectItem = selectItem as PathSelectItem;
-            return pathSelectItem != null && (pathSelectItem.SelectedPath.LastSegment is NavigationPropertySegment || pathSelectItem.SelectedPath.LastSegment is PropertySegment);
+            return selectItem is PathSelectItem pathSelectItem && (pathSelectItem.SelectedPath.LastSegment is NavigationPropertySegment || pathSelectItem.SelectedPath.LastSegment is PropertySegment);
         }
 
         /// <summary>
@@ -140,8 +139,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>true if this selection item is a structural property selection item.</returns>
         private static bool IsStructuralSelectionItem(SelectItem selectItem)
         {
-            PathSelectItem pathSelectItem = selectItem as PathSelectItem;
-            return pathSelectItem != null && (pathSelectItem.SelectedPath.LastSegment is PropertySegment);
+            return selectItem is PathSelectItem pathSelectItem && (pathSelectItem.SelectedPath.LastSegment is PropertySegment);
         }
     }
 }
\ No newline at end of file
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClauseExtensions.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClauseExtensions.cs
index 5029f5305..9747cb3c0 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClauseExtensions.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/SelectExpandClauseExtensions.cs
@@ -96,16 +96,14 @@ namespace Microsoft.OData.UriParser
                     levelSelectList.Add("*");
                     continue;
                 }
-
-                NamespaceQualifiedWildcardSelectItem namespaceQualifiedWildcard = selectItem as NamespaceQualifiedWildcardSelectItem;
-                if (namespaceQualifiedWildcard != null)
+
+                if (selectItem is NamespaceQualifiedWildcardSelectItem namespaceQualifiedWildcard)
                 {
                     levelSelectList.Add(string.Concat(namespaceQualifiedWildcard.Namespace, ".*"));
                     continue;
                 }
-
-                PathSelectItem pathSelectItem = selectItem as PathSelectItem;
-                if (pathSelectItem != null)
+
+                if (selectItem is PathSelectItem pathSelectItem)
                 {
                     IList<string> pathSelectItems = GetSelectStringFromPathSelectItem(pathSelectItem);
 
@@ -145,10 +143,9 @@ namespace Microsoft.OData.UriParser
 
             foreach (SelectItem selectItem in selectExpandClause.SelectedItems)
             {
-                // $expand=..../$ref
-                ExpandedNavigationSelectItem expandSelectItem = selectItem as ExpandedNavigationSelectItem;
+                // $expand=..../$ref
 
-                if (expandSelectItem != null)
+                if (selectItem is ExpandedNavigationSelectItem expandSelectItem)
                 {
                     string currentExpandClause = string.Join("/", expandSelectItem.PathToNavigationProperty.WalkWith(PathSegmentToStringTranslator.Instance).ToArray());
                     T subResult = default(T);
@@ -170,9 +167,7 @@ namespace Microsoft.OData.UriParser
                 }
                 else
                 {
-                    ExpandedReferenceSelectItem expandRefItem = selectItem as ExpandedReferenceSelectItem;
-
-                    if (expandRefItem != null)
+                    if (selectItem is ExpandedReferenceSelectItem expandRefItem)
                     {
                         string currentExpandClause = String.Join("/", expandRefItem.PathToNavigationProperty.WalkWith(PathSegmentToStringTranslator.Instance).ToArray());
                         currentExpandClause += "/$ref";
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/SingletonSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/SingletonSegment.cs
index 1ce559151..dea377672 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/SingletonSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/SingletonSegment.cs
@@ -89,8 +89,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            SingletonSegment otherSingleton = other as SingletonSegment;
-            return otherSingleton != null && otherSingleton.singleton == this.Singleton;
+            return other is SingletonSegment otherSingleton && otherSingleton.singleton == this.Singleton;
         }
     }
 }
\ No newline at end of file
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/TypeSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/TypeSegment.cs
index a0d90ea61..65beb6cf1 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/TypeSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/TypeSegment.cs
@@ -131,8 +131,7 @@ namespace Microsoft.OData.UriParser
         internal override bool Equals(ODataPathSegment other)
         {
             ExceptionUtils.CheckArgumentNotNull(other, "other");
-            TypeSegment otherType = other as TypeSegment;
-            return otherType != null && otherType.EdmType == this.EdmType;
+            return other is TypeSegment otherType && otherType.EdmType == this.EdmType;
         }
     }
 }
diff --git a/src/Microsoft.OData.Core/UriParser/SemanticAst/ValueSegment.cs b/src/Microsoft.OData.Core/UriParser/SemanticAst/ValueSegment.cs
index 488475e11..0db438f10 100644
--- a/src/Microsoft.OData.Core/UriParser/SemanticAst/ValueSegment.cs
+++ b/src/Microsoft.OData.Core/UriParser/SemanticAst/ValueSegment.cs
@@ -86,8 +86,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>true if the other segment is equal.</returns>
         internal override bool Equals(ODataPathSegment other)
         {
-            ValueSegment otherValueSegment = other as ValueSegment;
-            return otherValueSegment != null &&
+            return other is ValueSegment otherValueSegment &&
                    otherValueSegment.EdmType == this.edmType;
         }
     }
diff --git a/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeExpressionToken.cs b/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeExpressionToken.cs
index eb4dbf8e2..32405d5fc 100644
--- a/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeExpressionToken.cs
+++ b/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeExpressionToken.cs
@@ -77,8 +77,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>An object whose type is determined by the type parameter of the visitor.</returns>
         public override T Accept<T>(ISyntacticTreeVisitor<T> visitor)
         {
-            SyntacticTreeVisitor<T> implementation = visitor as SyntacticTreeVisitor<T>;
-            if (implementation != null)
+            if (visitor is SyntacticTreeVisitor<T> implementation)
             {
                 return implementation.Visit(this);
             }
diff --git a/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeToken.cs b/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeToken.cs
index ca94e40d0..9a2c4696b 100644
--- a/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeToken.cs
+++ b/src/Microsoft.OData.Core/UriParser/SyntacticAst/ComputeToken.cs
@@ -60,8 +60,7 @@ namespace Microsoft.OData.UriParser
         /// <returns>An object whose type is determined by the type parameter of the visitor.</returns>
         public override T Accept<T>(ISyntacticTreeVisitor<T> visitor)
         {
-            SyntacticTreeVisitor<T> implementation = visitor as SyntacticTreeVisitor<T>;
-            if (implementation != null)
+            if (visitor is SyntacticTreeVisitor<T> implementation)
             {
                 return implementation.Visit(this);
             }
diff --git a/src/Microsoft.OData.Core/UriParser/TypePromotionUtils.cs b/src/Microsoft.OData.Core/UriParser/TypePromotionUtils.cs
index 3ed60a4c2..603eb0975 100644
--- a/src/Microsoft.OData.Core/UriParser/TypePromotionUtils.cs
+++ b/src/Microsoft.OData.Core/UriParser/TypePromotionUtils.cs
@@ -214,17 +214,15 @@ namespace Microsoft.OData.UriParser
         {
             precision = null;
             scale = null;
-
-            var decimalType = type as IEdmDecimalTypeReference;
-            if (decimalType != null)
+
+            if (type is IEdmDecimalTypeReference decimalType)
             {
                 precision = decimalType.Precision;
                 scale = decimalType.Scale;
                 return;
             }
-
-            var temporalType = type as IEdmTemporalTypeReference;
-            if (temporalType != null)
+
+            if (type is IEdmTemporalTypeReference temporalType)
             {
                 precision = temporalType.Precision;
                 return;
diff --git a/src/Microsoft.OData.Core/UriParser/UriEdmHelpers.cs b/src/Microsoft.OData.Core/UriParser/UriEdmHelpers.cs
index 3474f1806..36189778e 100644
--- a/src/Microsoft.OData.Core/UriParser/UriEdmHelpers.cs
+++ b/src/Microsoft.OData.Core/UriParser/UriEdmHelpers.cs
@@ -109,8 +109,7 @@ namespace Microsoft.OData.UriParser
             IEdmType currentType = startingType;
             foreach (ODataPathSegment currentSegment in path)
             {
-                TypeSegment typeSegment = currentSegment as TypeSegment;
-                if (typeSegment != null && typeSegment.EdmType.IsOrInheritsFrom(currentType))
+                if (currentSegment is TypeSegment typeSegment && typeSegment.EdmType.IsOrInheritsFrom(currentType))
                 {
                     currentType = typeSegment.EdmType;
                 }
@@ -127,8 +126,8 @@ namespace Microsoft.OData.UriParser
         public static bool IsStructuredCollection(this IEdmTypeReference type)
         {
             ExceptionUtils.CheckArgumentNotNull(type, "type");
-            IEdmCollectionTypeReference collectionType = type as IEdmCollectionTypeReference;
-            if (collectionType != null)
+
+            if (type is IEdmCollectionTypeReference collectionType)
             {
                 return collectionType.ElementType().IsStructured();
             }
@@ -145,10 +144,9 @@ namespace Microsoft.OData.UriParser
         /// <returns>The type reference</returns>
         public static IEdmStructuredTypeReference GetTypeReference(this IEdmStructuredType structuredType)
         {
-            IEdmEntityType entityType = structuredType as IEdmEntityType;
             IEdmStructuredTypeReference typeReference;
 
-            if (entityType != null)
+            if (structuredType is IEdmEntityType entityType)
             {
                 typeReference = new EdmEntityTypeReference(entityType, false);
             }
diff --git a/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToContextUrlPathTranslator.cs b/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToContextUrlPathTranslator.cs
index 96aaec7f5..fdf513ba2 100644
--- a/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToContextUrlPathTranslator.cs
+++ b/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToContextUrlPathTranslator.cs
@@ -56,9 +56,8 @@ namespace Microsoft.OData.UriParser
         {
             Debug.Assert(segment != null, "segment != null");
             IEdmType type = segment.EdmType;
-            IEdmCollectionType collectionType = type as IEdmCollectionType;
 
-            if (collectionType != null)
+            if (type is IEdmCollectionType collectionType)
             {
                 type = collectionType.ElementType.Definition;
             }
diff --git a/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToResourcePathTranslator.cs b/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToResourcePathTranslator.cs
index e7dedd89f..c680d85a5 100644
--- a/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToResourcePathTranslator.cs
+++ b/src/Microsoft.OData.Core/UriParser/Visitors/PathSegmentToResourcePathTranslator.cs
@@ -45,9 +45,8 @@ namespace Microsoft.OData.UriParser
         {
             Debug.Assert(segment != null, "segment != null");
             IEdmType type = segment.EdmType;
-            IEdmCollectionType collectionType = type as IEdmCollectionType;
 
-            if (collectionType != null)
+            if (type is IEdmCollectionType collectionType)
             {
                 type = collectionType.ElementType.Definition;
             }
diff --git a/src/Microsoft.OData.Core/UrlValidation/Rules/DeprecationRules.cs b/src/Microsoft.OData.Core/UrlValidation/Rules/DeprecationRules.cs
index 3e988cdfd..e29d07671 100644
--- a/src/Microsoft.OData.Core/UrlValidation/Rules/DeprecationRules.cs
+++ b/src/Microsoft.OData.Core/UrlValidation/Rules/DeprecationRules.cs
@@ -134,13 +134,11 @@ namespace Microsoft.OData.UriParser.Validation.Rules
         {
             if (!(element is IEdmPrimitiveType))
             {
-                IEdmVocabularyAnnotatable annotatedElement = element as IEdmVocabularyAnnotatable;
-                if (annotatedElement != null)
+                if (element is IEdmVocabularyAnnotatable annotatedElement)
                 {
                     foreach (IEdmVocabularyAnnotation annotation in GetRevisionAnnotations(model, annotatedElement))
                     {
-                        IEdmCollectionExpression collectionExpression = annotation.Value as IEdmCollectionExpression;
-                        if (collectionExpression != null)
+                        if (annotation.Value is IEdmCollectionExpression collectionExpression)
                         {
                             foreach (IEdmExpression versionRecord in collectionExpression.Elements)
                             {
@@ -149,16 +147,15 @@ namespace Microsoft.OData.UriParser.Validation.Rules
                                 version = string.Empty;
                                 date = null;
                                 removalDate = null;
-                                IEdmRecordExpression record = versionRecord as IEdmRecordExpression;
-                                if (record != null)
+
+                                if (versionRecord is IEdmRecordExpression record)
                                 {
                                     foreach (IEdmPropertyConstructor property in record.Properties)
                                     {
                                         switch (property.Name)
                                         {
                                             case RevisionKindProperty:
-                                                IEdmEnumMemberExpression enumValue = property.Value as IEdmEnumMemberExpression;
-                                                if (enumValue != null)
+                                                if (property.Value is IEdmEnumMemberExpression enumValue)
                                                 {
                                                     if (string.Equals(enumValue.EnumMembers.FirstOrDefault().Name, RevisionKindDeprecated, StringComparison.OrdinalIgnoreCase))
                                                     {
@@ -173,8 +170,7 @@ namespace Microsoft.OData.UriParser.Validation.Rules
                                                 break;
 
                                             case RevisionVersionProperty:
-                                                IEdmStringConstantExpression versionValue = property.Value as IEdmStringConstantExpression;
-                                                if (versionValue != null)
+                                                if (property.Value is IEdmStringConstantExpression versionValue)
                                                 {
                                                     version = versionValue.Value;
                                                 }
@@ -182,8 +178,7 @@ namespace Microsoft.OData.UriParser.Validation.Rules
                                                 break;
 
                                             case RevisionDescriptionProperty:
-                                                IEdmStringConstantExpression descriptionValue = property.Value as IEdmStringConstantExpression;
-                                                if (descriptionValue != null)
+                                                if (property.Value is IEdmStringConstantExpression descriptionValue)
                                                 {
                                                     message = descriptionValue.Value;
                                                 }
@@ -191,8 +186,7 @@ namespace Microsoft.OData.UriParser.Validation.Rules
                                                 break;
 
                                             case RevisionDateProperty:
-                                                IEdmDateConstantExpression dateValue = property.Value as IEdmDateConstantExpression;
-                                                if (dateValue != null)
+                                                if (property.Value is IEdmDateConstantExpression dateValue)
                                                 {
                                                     date = dateValue.Value;
                                                 }
@@ -200,8 +194,7 @@ namespace Microsoft.OData.UriParser.Validation.Rules
                                                 break;
 
                                             case RevisionRemovalDateProperty:
-                                                IEdmDateConstantExpression removalDateValue = property.Value as IEdmDateConstantExpression;
-                                                if (removalDateValue != null)
+                                                if (property.Value is IEdmDateConstantExpression removalDateValue)
                                                 {
                                                     removalDate = removalDateValue.Value;
                                                 }
diff --git a/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/ODataUrlValidator.cs b/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/ODataUrlValidator.cs
index 8b7cb3892..3d1ab244b 100644
--- a/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/ODataUrlValidator.cs
+++ b/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/ODataUrlValidator.cs
@@ -412,8 +412,8 @@ namespace Microsoft.OData.UriParser.Validation
                     else
                     {
                         ExpandedNavigationSelectItem expandItem;
-                        PathSelectItem pathSelectItem = selectItem as PathSelectItem;
-                        if (pathSelectItem != null)
+
+                        if (selectItem is PathSelectItem pathSelectItem)
                         {
                             // SelectItem is a propety. See if it is structured with no select
                             ValidateImpliedProperties(pathSelectItem.SelectedPath.LastSegment.EdmType.AsElementType(), pathSelectItem.SelectAndExpand, validationContext);
@@ -443,8 +443,7 @@ namespace Microsoft.OData.UriParser.Validation
             // true if the element is added to the set; false if the element is already in the set.
             if (edmType.TypeKind != EdmTypeKind.Primitive && context.ValidatedTypes.Add(edmType))
             {
-                IEdmStructuredType structuredType = edmType as IEdmStructuredType;
-                if (structuredType != null)
+                if (edmType is IEdmStructuredType structuredType)
                 {
                     foreach (IEdmProperty property in structuredType.StructuralProperties())
                     {
diff --git a/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/PathSegmentValidator.cs b/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/PathSegmentValidator.cs
index b96e20880..f1aed2bfd 100644
--- a/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/PathSegmentValidator.cs
+++ b/src/Microsoft.OData.Core/UrlValidation/ValidationEngine/PathSegmentValidator.cs
@@ -268,8 +268,8 @@ namespace Microsoft.OData.UriParser.Validation.ValidationEngine
         {
             ValidateItem(segment);
             ValidateItem(segment.EdmType);
-            IEdmCollectionType collectionType = segment.EdmType as IEdmCollectionType;
-            if (collectionType != null)
+
+            if (segment.EdmType is IEdmCollectionType collectionType)
             {
                 ValidateItem(collectionType.ElementType.Definition);
             }
diff --git a/src/Microsoft.OData.Core/Utils.cs b/src/Microsoft.OData.Core/Utils.cs
index 12a134866..183fa08a4 100644
--- a/src/Microsoft.OData.Core/Utils.cs
+++ b/src/Microsoft.OData.Core/Utils.cs
@@ -27,8 +27,7 @@ namespace Microsoft.OData
         /// <returns>'True' if IDisposable.Dispose() was called; 'false' otherwise.</returns>
         internal static bool TryDispose(object o)
         {
-            IDisposable disposable = o as IDisposable;
-            if (disposable != null)
+            if (o is IDisposable disposable)
             {
                 disposable.Dispose();
                 return true;
diff --git a/src/Microsoft.OData.Core/Value/ODataValueUtils.cs b/src/Microsoft.OData.Core/Value/ODataValueUtils.cs
index 8affe5e05..2df797ef7 100644
--- a/src/Microsoft.OData.Core/Value/ODataValueUtils.cs
+++ b/src/Microsoft.OData.Core/Value/ODataValueUtils.cs
@@ -32,10 +32,9 @@ namespace Microsoft.OData
             {
                 return new ODataNullValue();
             }
-
-            // If the given object is already an ODataValue, return it as is.
-            ODataValue odataValue = objectToConvert as ODataValue;
-            if (odataValue != null)
+
+            // If the given object is already an ODataValue, return it as is.
+            if (objectToConvert is ODataValue odataValue)
             {
                 return odataValue;
             }
@@ -61,9 +60,8 @@ namespace Microsoft.OData
             {
                 return null;
             }
-
-            ODataPrimitiveValue primitiveValue = odataValue as ODataPrimitiveValue;
-            if (primitiveValue != null)
+
+            if (odataValue is ODataPrimitiveValue primitiveValue)
             {
                 return primitiveValue.Value;
             }
diff --git a/src/Microsoft.OData.Core/WriterValidationUtils.cs b/src/Microsoft.OData.Core/WriterValidationUtils.cs
index 6e89f2a87..3a04c78eb 100644
--- a/src/Microsoft.OData.Core/WriterValidationUtils.cs
+++ b/src/Microsoft.OData.Core/WriterValidationUtils.cs
@@ -313,7 +313,7 @@ namespace Microsoft.OData
             if (!writingResponse)
             {
                 // Read/Write links and ETags on Stream properties are only valid in responses; writers fail if they encounter them in requests.
-                if (streamPropertyInfo != null && streamPropertyInfo.EditLink != null || streamPropertyInfo.ReadLink != null || streamPropertyInfo.ETag != null)
+                if (streamPropertyInfo?.EditLink != null || streamPropertyInfo.ReadLink != null || streamPropertyInfo.ETag != null)
                 {
                     throw new ODataException(Strings.WriterValidationUtils_StreamPropertyInRequest(propertyName));
                 }
diff --git a/src/Microsoft.OData.Edm/Csdl/CsdlReader.cs b/src/Microsoft.OData.Edm/Csdl/CsdlReader.cs
index 893c3d8e9..5d32c51f1 100644
--- a/src/Microsoft.OData.Edm/Csdl/CsdlReader.cs
+++ b/src/Microsoft.OData.Edm/Csdl/CsdlReader.cs
@@ -681,8 +681,8 @@ namespace Microsoft.OData.Edm.Csdl
             Debug.Assert(this.reader.LocalName == CsdlConstants.Element_Schema, "Must call ParseCsdlSchemaElement on Schema Element");
 
             XmlReaderSettings settings = new XmlReaderSettings();
-            IXmlLineInfo lineInfo = this.reader as IXmlLineInfo;
-            if (lineInfo != null && lineInfo.HasLineInfo())
+
+            if (this.reader is IXmlLineInfo lineInfo && lineInfo.HasLineInfo())
             {
                 settings.LineNumberOffset = lineInfo.LineNumber - 1;
                 settings.LinePositionOffset = lineInfo.LinePosition - 2;
@@ -706,9 +706,8 @@ namespace Microsoft.OData.Edm.Csdl
         {
             int lineNumber = 0;
             int linePosition = 0;
-
-            IXmlLineInfo xmlLineInfo = this.reader as IXmlLineInfo;
-            if (xmlLineInfo != null && xmlLineInfo.HasLineInfo())
+
+            if (this.reader is IXmlLineInfo xmlLineInfo && xmlLineInfo.HasLineInfo())
             {
                 lineNumber = xmlLineInfo.LineNumber;
                 linePosition = xmlLineInfo.LinePosition;
diff --git a/src/Microsoft.OData.Edm/Csdl/Parsing/Common/XmlElementParser.cs b/src/Microsoft.OData.Edm/Csdl/Parsing/Common/XmlElementParser.cs
index d292f718c..b61d6105b 100644
--- a/src/Microsoft.OData.Edm/Csdl/Parsing/Common/XmlElementParser.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Parsing/Common/XmlElementParser.cs
@@ -19,8 +19,7 @@ namespace Microsoft.OData.Edm.Csdl.Parsing.Common
         {
             foreach (var element in elements)
             {
-                XmlElementValue<T> result = element as XmlElementValue<T>;
-                if (result != null)
+                if (element is XmlElementValue<T> result)
                 {
                     yield return result;
                 }
diff --git a/src/Microsoft.OData.Edm/Csdl/Parsing/CsdlDocumentParser.cs b/src/Microsoft.OData.Edm/Csdl/Parsing/CsdlDocumentParser.cs
index 8b1a8da4b..a58de8952 100644
--- a/src/Microsoft.OData.Edm/Csdl/Parsing/CsdlDocumentParser.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Parsing/CsdlDocumentParser.cs
@@ -1120,13 +1120,12 @@ namespace Microsoft.OData.Edm.Csdl.Parsing
             if (optionalAnnotationValue != null)
             {
                 isOptional = true;
-                CsdlRecordExpression optionalValueExpression = optionalAnnotationValue.ValueAs<CsdlAnnotation>().Expression as CsdlRecordExpression;
-                if (optionalValueExpression != null)
+
+                if (optionalAnnotationValue.ValueAs<CsdlAnnotation>().Expression is CsdlRecordExpression optionalValueExpression)
                 {
                     foreach (CsdlPropertyValue property in optionalValueExpression.PropertyValues)
                     {
-                        CsdlConstantExpression propertyValue = property.Expression as CsdlConstantExpression;
-                        if (propertyValue != null)
+                        if (property.Expression is CsdlConstantExpression propertyValue)
                         {
                             if (property.Property == CsdlConstants.Attribute_DefaultValue)
                             {
diff --git a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsDirectValueAnnotationsManager.cs b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsDirectValueAnnotationsManager.cs
index a46e1e8a7..942cef0d3 100644
--- a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsDirectValueAnnotationsManager.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsDirectValueAnnotationsManager.cs
@@ -17,8 +17,7 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
     {
         protected override IEnumerable<IEdmDirectValueAnnotation> GetAttachedAnnotations(IEdmElement element)
         {
-            CsdlSemanticsElement csdlElement = element as CsdlSemanticsElement;
-            if (csdlElement != null)
+            if (element is CsdlSemanticsElement csdlElement)
             {
                 return csdlElement.DirectValueAnnotations;
             }
diff --git a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsModel.cs b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsModel.cs
index 5fd58e5cf..e206598bf 100644
--- a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsModel.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsModel.cs
@@ -394,11 +394,9 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
 
         internal static IEdmTypeReference WrapTypeReference(CsdlSemanticsSchema schema, CsdlTypeReference type)
         {
-            var typeReference = type as CsdlNamedTypeReference;
-            if (typeReference != null)
+            if (type is CsdlNamedTypeReference typeReference)
             {
-                var primitiveReference = typeReference as CsdlPrimitiveTypeReference;
-                if (primitiveReference != null)
+                if (typeReference is CsdlPrimitiveTypeReference primitiveReference)
                 {
                     switch (primitiveReference.Kind)
                     {
@@ -450,8 +448,7 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
                 }
                 else
                 {
-                    CsdlUntypedTypeReference csdlUntypedTypeReference = typeReference as CsdlUntypedTypeReference;
-                    if (csdlUntypedTypeReference != null)
+                    if (typeReference is CsdlUntypedTypeReference csdlUntypedTypeReference)
                     {
                         return new CsdlSemanticsUntypedTypeReference(schema, csdlUntypedTypeReference);
                     }
@@ -464,18 +461,14 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
 
                 return new CsdlSemanticsNamedTypeReference(schema, typeReference);
             }
-
-            var typeExpression = type as CsdlExpressionTypeReference;
-            if (typeExpression != null)
+
+            if (type is CsdlExpressionTypeReference typeExpression)
             {
-                var collectionType = typeExpression.TypeExpression as CsdlCollectionType;
-                if (collectionType != null)
+                if (typeExpression.TypeExpression is CsdlCollectionType collectionType)
                 {
                     return new CsdlSemanticsCollectionTypeExpression(typeExpression, new CsdlSemanticsCollectionTypeDefinition(schema, collectionType));
                 }
-
-                var entityReferenceType = typeExpression.TypeExpression as CsdlEntityReferenceType;
-                if (entityReferenceType != null)
+                if (typeExpression.TypeExpression is CsdlEntityReferenceType entityReferenceType)
                 {
                     return new CsdlSemanticsEntityReferenceTypeExpression(typeExpression, new CsdlSemanticsEntityReferenceTypeDefinition(schema, entityReferenceType));
                 }
@@ -486,8 +479,7 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
 
         internal IEnumerable<IEdmVocabularyAnnotation> WrapInlineVocabularyAnnotations(CsdlSemanticsElement element, CsdlSemanticsSchema schema)
         {
-            IEdmVocabularyAnnotatable vocabularyAnnotatableElement = element as IEdmVocabularyAnnotatable;
-            if (vocabularyAnnotatableElement != null)
+            if (element is IEdmVocabularyAnnotatable vocabularyAnnotatableElement)
             {
                 IEnumerable<CsdlAnnotation> vocabularyAnnotations = element.Element.VocabularyAnnotations;
                 if (vocabularyAnnotations.FirstOrDefault() != null)
@@ -651,8 +643,7 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
         {
             foreach (IEdmSchemaType type in schemaWrapper.Types)
             {
-                CsdlSemanticsStructuredTypeDefinition structuredType = type as CsdlSemanticsStructuredTypeDefinition;
-                if (structuredType != null)
+                if (type is CsdlSemanticsStructuredTypeDefinition structuredType)
                 {
                     string baseTypeName;
                     string baseTypeFullName = ((CsdlNamedStructuredType)structuredType.Element).BaseTypeName;
diff --git a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationProperty.cs b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationProperty.cs
index 6a14312ae..963aab46e 100644
--- a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationProperty.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationProperty.cs
@@ -261,9 +261,8 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
                 // the code for handling type-ref based collection types and unify this parsing logic
                 errors = AllocateAndAdd(errors, new EdmError(this.Location, EdmErrorCode.NavigationPropertyWithCollectionTypeCannotHaveNullableAttribute, Strings.CsdlParser_CannotSpecifyNullableAttributeForNavigationPropertyWithCollectionType));
             }
-
-            var badType = this.TargetEntityType as BadEntityType;
-            if (badType != null)
+
+            if (this.TargetEntityType is BadEntityType badType)
             {
                 errors = AllocateAndAdd(errors, badType.Errors);
             }
diff --git a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationSource.cs b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationSource.cs
index b08b5e9c7..132465c19 100644
--- a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationSource.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsNavigationSource.cs
@@ -178,9 +178,8 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
                     {
                         return new UnresolvedNavigationPropertyPath(definingType, binding.Path, binding.Location);
                     }
-
-                    var navProperty = property as IEdmNavigationProperty;
-                    if (navProperty != null && !navProperty.ContainsTarget)
+
+                    if (property is IEdmNavigationProperty navProperty && !navProperty.ContainsTarget)
                     {
                         // TODO: Improve error message #644.
                         return new UnresolvedNavigationPropertyPath(definingType, binding.Path, binding.Location);
diff --git a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsOperation.cs b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsOperation.cs
index fd6fc7fb9..a82c55c55 100644
--- a/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsOperation.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Semantics/CsdlSemanticsOperation.cs
@@ -248,16 +248,14 @@ namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
                     if (optionalParameterAnnotation != null)
                     {
                         isOptional = true;
-
-                        CsdlRecordExpression optionalValueExpression = optionalParameterAnnotation.Expression as CsdlRecordExpression;
-                        if (optionalValueExpression != null)
+
+                        if (optionalParameterAnnotation.Expression is CsdlRecordExpression optionalValueExpression)
                         {
                             foreach (CsdlPropertyValue property in optionalValueExpression.PropertyValues)
                             {
                                 if (property.Property == CsdlConstants.Attribute_DefaultValue)
                                 {
-                                    CsdlConstantExpression propertyValue = property.Expression as CsdlConstantExpression;
-                                    if (propertyValue != null)
+                                    if (property.Expression is CsdlConstantExpression propertyValue)
                                     {
                                         defaultValue = propertyValue.Value;
                                     }
diff --git a/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSchemaXmlWriter.cs b/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSchemaXmlWriter.cs
index 09ccae1f1..9b9c1f89c 100644
--- a/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSchemaXmlWriter.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSchemaXmlWriter.cs
@@ -101,9 +101,9 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
         {
             this.xmlWriter.WriteStartElement(CsdlConstants.Element_EntityContainer);
             this.WriteRequiredAttribute(CsdlConstants.Attribute_Name, container.Name, EdmValueWriter.StringAsXml);
-            CsdlSemanticsEntityContainer tmp = container as CsdlSemanticsEntityContainer;
             CsdlEntityContainer csdlContainer = null;
-            if (tmp != null && (csdlContainer = tmp.Element as CsdlEntityContainer) != null)
+
+            if (container is CsdlSemanticsEntityContainer tmp && (csdlContainer = tmp.Element as CsdlEntityContainer) != null)
             {
                 this.WriteOptionalAttribute(CsdlConstants.Attribute_Extends, csdlContainer.Extends, EdmValueWriter.StringAsXml);
             }
@@ -396,8 +396,7 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
 
         internal override void WriteOperationParameterEndElement(IEdmOperationParameter parameter)
         {
-            IEdmOptionalParameter optionalParameter = parameter as IEdmOptionalParameter;
-            if (optionalParameter != null && !(optionalParameter.VocabularyAnnotations(this.Model).Any(a => a.Term == CoreVocabularyModel.OptionalParameterTerm)))
+            if (parameter is IEdmOptionalParameter optionalParameter && !(optionalParameter.VocabularyAnnotations(this.Model).Any(a => a.Term == CoreVocabularyModel.OptionalParameterTerm)))
             {
                 string defaultValue = optionalParameter.DefaultValueString;
                 EdmRecordExpression optionalValue = new EdmRecordExpression();
@@ -774,10 +773,9 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
             this.xmlWriter.WriteStartElement(CsdlConstants.Element_NavigationPropertyBinding);
 
             this.WriteRequiredAttribute(CsdlConstants.Attribute_Path, binding.Path.Path, EdmValueWriter.StringAsXml);
-
-            // TODO: handle container names, etc.
-            IEdmContainedEntitySet containedEntitySet = binding.Target as IEdmContainedEntitySet;
-            if (containedEntitySet != null)
+
+            // TODO: handle container names, etc.
+            if (binding.Target is IEdmContainedEntitySet containedEntitySet)
             {
                 this.WriteRequiredAttribute(CsdlConstants.Attribute_Target, containedEntitySet.Path.Path, EdmValueWriter.StringAsXml);
             }
@@ -818,8 +816,7 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
 
             if (operationImport.EntitySet != null)
             {
-                var pathExpression = operationImport.EntitySet as IEdmPathExpression;
-                if (pathExpression != null)
+                if (operationImport.EntitySet is IEdmPathExpression pathExpression)
                 {
                     this.WriteOptionalAttribute(CsdlConstants.Attribute_EntitySet, pathExpression.PathSegments, PathAsXml);
                 }
diff --git a/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSerializationVisitor.cs b/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSerializationVisitor.cs
index 45b618822..4cd8832f8 100644
--- a/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSerializationVisitor.cs
+++ b/src/Microsoft.OData.Edm/Csdl/Serialization/EdmModelCsdlSerializationVisitor.cs
@@ -278,8 +278,8 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
             }
 
             this.VisitPrimitiveElementAnnotations(this.Model.DirectValueAnnotations(element));
-            IEdmVocabularyAnnotatable vocabularyAnnotatableElement = element as IEdmVocabularyAnnotatable;
-            if (vocabularyAnnotatableElement != null)
+
+            if (element is IEdmVocabularyAnnotatable vocabularyAnnotatableElement)
             {
                 this.VisitElementVocabularyAnnotations(this.Model.FindDeclaredVocabularyAnnotations(vocabularyAnnotatableElement).Where(a => a.IsInline(this.Model)));
             }
@@ -615,8 +615,7 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
         {
             if (operationImport.EntitySet != null)
             {
-                var pathExpression = operationImport.EntitySet as IEdmPathExpression;
-                if (pathExpression != null)
+                if (operationImport.EntitySet is IEdmPathExpression pathExpression)
                 {
                     return EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments);
                 }
@@ -701,8 +700,7 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
             {
                 if (annotation.NamespaceUri != EdmConstants.InternalUri)
                 {
-                    var edmValue = annotation.Value as IEdmValue;
-                    if (edmValue != null)
+                    if (annotation.Value is IEdmValue edmValue)
                     {
                         if (!edmValue.IsSerializedAsElement(this.Model))
                         {
@@ -722,8 +720,7 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
             {
                 if (annotation.NamespaceUri != EdmConstants.InternalUri)
                 {
-                    var edmValue = annotation.Value as IEdmValue;
-                    if (edmValue != null)
+                    if (annotation.Value is IEdmValue edmValue)
                     {
                         if (edmValue.IsSerializedAsElement(this.Model))
                         {
@@ -773,9 +770,8 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
         private void EndElement<TElement>(TElement element, Action<TElement> elementEndWriter) where TElement : IEdmElement
         {
             this.VisitPrimitiveElementAnnotations(this.Model.DirectValueAnnotations(element));
-
-            IEdmVocabularyAnnotatable vocabularyAnnotatableElement = element as IEdmVocabularyAnnotatable;
-            if (vocabularyAnnotatableElement != null)
+
+            if (element is IEdmVocabularyAnnotatable vocabularyAnnotatableElement)
             {
                 this.VisitElementVocabularyAnnotations(this.Model.FindDeclaredVocabularyAnnotations(vocabularyAnnotatableElement).Where(a => a.IsInline(this.Model)));
             }
@@ -786,8 +782,8 @@ namespace Microsoft.OData.Edm.Csdl.Serialization
         private void EndElement(IEdmElement element)
         {
             this.VisitPrimitiveElementAnnotations(this.Model.DirectValueAnnotations(element));
-            IEdmVocabularyAnnotatable vocabularyAnnotatableElement = element as IEdmVocabularyAnnotatable;
-            if (vocabularyAnnotatableElement != null)
+
+            if (element is IEdmVocabularyAnnotatable vocabularyAnnotatableElement)
             {
                 this.VisitElementVocabularyAnnotations(this.Model.FindDeclaredVocabularyAnnotations(vocabularyAnnotatableElement).Where(a => a.IsInline(this.Model)));
             }
diff --git a/src/Microsoft.OData.Edm/EdmUtil.cs b/src/Microsoft.OData.Edm/EdmUtil.cs
index afd4edfa2..706f91905 100644
--- a/src/Microsoft.OData.Edm/EdmUtil.cs
+++ b/src/Microsoft.OData.Edm/EdmUtil.cs
@@ -84,8 +84,7 @@ namespace Microsoft.OData.Edm
         /// <returns>null or a symbolic string.</returns>
         public static string GetSymbolicString(this IEdmVocabularyAnnotatable annotatedElement)
         {
-            IEdmSchemaElement schemaElement = annotatedElement as IEdmSchemaElement;
-            if (schemaElement != null)
+            if (annotatedElement is IEdmSchemaElement schemaElement)
             {
                 // EntityType, ComplexType, EnumType, TypeDefinition
                 if (schemaElement.SchemaElementKind == EdmSchemaElementKind.TypeDefinition)
@@ -111,16 +110,14 @@ namespace Microsoft.OData.Edm
                     return schemaElement.SchemaElementKind.ToString();
                 }
             }
-
-            IEdmEntityContainerElement containerElement = annotatedElement as IEdmEntityContainerElement;
-            if (containerElement != null)
+
+            if (annotatedElement is IEdmEntityContainerElement containerElement)
             {
                 // ActionImport, FunctionImport, EntitySet, Singleton
                 return containerElement.ContainerElementKind.ToString();
             }
-
-            IEdmProperty property = annotatedElement as IEdmProperty;
-            if (property != null)
+
+            if (annotatedElement is IEdmProperty property)
             {
                 // NavigationProperty, Property
                 switch (property.PropertyKind)
@@ -133,9 +130,8 @@ namespace Microsoft.OData.Edm
                         return null;
                 }
             }
-
-            IEdmExpression expression = annotatedElement as IEdmExpression;
-            if (expression != null)
+
+            if (annotatedElement is IEdmExpression expression)
             {
                 switch (expression.ExpressionKind)
                 {
@@ -327,19 +323,17 @@ namespace Microsoft.OData.Edm
             int index = 0;
             int parameterCount = operation.Parameters.Count();
             StringBuilder sb = new StringBuilder();
-
-            UnresolvedOperation unresolvedOperationImport = operation as UnresolvedOperation;
-            if (unresolvedOperationImport != null)
+
+            if (operation is UnresolvedOperation unresolvedOperationImport)
             {
                 sb.Append(unresolvedOperationImport.Namespace);
                 sb.Append("/");
                 sb.Append(unresolvedOperationImport.Name);
                 return sb.ToString();
             }
-
-            // If we have a operation (rather than a operation import), we want the parameterized name to include the namespace
-            IEdmSchemaElement schemaFunction = operation as IEdmSchemaElement;
-            if (schemaFunction != null)
+
+            // If we have a operation (rather than a operation import), we want the parameterized name to include the namespace
+            if (operation is IEdmSchemaElement schemaFunction)
             {
                 sb.Append(schemaFunction.Namespace);
                 sb.Append(".");
@@ -414,11 +408,9 @@ namespace Microsoft.OData.Edm
 
         internal static string FullyQualifiedName(IEdmVocabularyAnnotatable element)
         {
-            IEdmSchemaElement schemaElement = element as IEdmSchemaElement;
-            if (schemaElement != null)
+            if (element is IEdmSchemaElement schemaElement)
             {
-                IEdmOperation operation = schemaElement as IEdmOperation;
-                if (operation != null)
+                if (schemaElement is IEdmOperation operation)
                 {
                     return ParameterizedName(operation);
                 }
@@ -429,18 +421,15 @@ namespace Microsoft.OData.Edm
             }
             else
             {
-                IEdmEntityContainerElement containerElement = element as IEdmEntityContainerElement;
-                if (containerElement != null)
+                if (element is IEdmEntityContainerElement containerElement)
                 {
                     return containerElement.Container.FullName() + "/" + containerElement.Name;
                 }
                 else
                 {
-                    IEdmProperty property = element as IEdmProperty;
-                    if (property != null)
+                    if (element is IEdmProperty property)
                     {
-                        IEdmSchemaType declaringSchemaType = property.DeclaringType as IEdmSchemaType;
-                        if (declaringSchemaType != null)
+                        if (property.DeclaringType is IEdmSchemaType declaringSchemaType)
                         {
                             string propertyOwnerName = FullyQualifiedName(declaringSchemaType);
                             if (propertyOwnerName != null)
@@ -453,8 +442,8 @@ namespace Microsoft.OData.Edm
                     {
                         IEdmOperationReturn operationReturn;
                         IEdmEnumMember enumMember;
-                        IEdmOperationParameter parameter = element as IEdmOperationParameter;
-                        if (parameter != null)
+
+                        if (element is IEdmOperationParameter parameter)
                         {
                             string parameterOwnerName = FullyQualifiedName(parameter.DeclaringOperation);
                             if (parameterOwnerName != null)
diff --git a/src/Microsoft.OData.Edm/ExtensionMethods/EdmTypeSemantics.cs b/src/Microsoft.OData.Edm/ExtensionMethods/EdmTypeSemantics.cs
index c5d100d4c..b9e1871d0 100644
--- a/src/Microsoft.OData.Edm/ExtensionMethods/EdmTypeSemantics.cs
+++ b/src/Microsoft.OData.Edm/ExtensionMethods/EdmTypeSemantics.cs
@@ -719,8 +719,8 @@ namespace Microsoft.OData.Edm
         public static IEdmPrimitiveTypeReference AsPrimitive(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmPrimitiveTypeReference primitiveReference = type as IEdmPrimitiveTypeReference;
-            if (primitiveReference != null)
+
+            if (type is IEdmPrimitiveTypeReference primitiveReference)
             {
                 return primitiveReference;
             }
@@ -728,8 +728,7 @@ namespace Microsoft.OData.Edm
             IEdmType typeDefinition = type.Definition;
             if (typeDefinition.TypeKind == EdmTypeKind.Primitive)
             {
-                var primitiveDefinition = typeDefinition as IEdmPrimitiveType;
-                if (primitiveDefinition != null)
+                if (typeDefinition is IEdmPrimitiveType primitiveDefinition)
                 {
                     switch (primitiveDefinition.PrimitiveKind)
                     {
@@ -845,8 +844,8 @@ namespace Microsoft.OData.Edm
         public static IEdmCollectionTypeReference AsCollection(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmCollectionTypeReference reference = type as IEdmCollectionTypeReference;
-            if (reference != null)
+
+            if (type is IEdmCollectionTypeReference reference)
             {
                 return reference;
             }
@@ -874,8 +873,8 @@ namespace Microsoft.OData.Edm
         public static IEdmStructuredTypeReference AsStructured(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmStructuredTypeReference reference = type as IEdmStructuredTypeReference;
-            if (reference != null)
+
+            if (type is IEdmStructuredTypeReference reference)
             {
                 return reference;
             }
@@ -906,8 +905,8 @@ namespace Microsoft.OData.Edm
         public static IEdmEnumTypeReference AsEnum(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmEnumTypeReference reference = type as IEdmEnumTypeReference;
-            if (reference != null)
+
+            if (type is IEdmEnumTypeReference reference)
             {
                 return reference;
             }
@@ -933,8 +932,8 @@ namespace Microsoft.OData.Edm
         public static IEdmTypeDefinitionReference AsTypeDefinition(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmTypeDefinitionReference reference = type as IEdmTypeDefinitionReference;
-            if (reference != null)
+
+            if (type is IEdmTypeDefinitionReference reference)
             {
                 return reference;
             }
@@ -959,8 +958,8 @@ namespace Microsoft.OData.Edm
         public static IEdmEntityTypeReference AsEntity(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmEntityTypeReference reference = type as IEdmEntityTypeReference;
-            if (reference != null)
+
+            if (type is IEdmEntityTypeReference reference)
             {
                 return reference;
             }
@@ -989,8 +988,8 @@ namespace Microsoft.OData.Edm
         public static IEdmEntityReferenceTypeReference AsEntityReference(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmEntityReferenceTypeReference reference = type as IEdmEntityReferenceTypeReference;
-            if (reference != null)
+
+            if (type is IEdmEntityReferenceTypeReference reference)
             {
                 return reference;
             }
@@ -1018,8 +1017,8 @@ namespace Microsoft.OData.Edm
         public static IEdmComplexTypeReference AsComplex(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmComplexTypeReference reference = type as IEdmComplexTypeReference;
-            if (reference != null)
+
+            if (type is IEdmComplexTypeReference reference)
             {
                 return reference;
             }
@@ -1050,8 +1049,8 @@ namespace Microsoft.OData.Edm
         public static IEdmPathTypeReference AsPath(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmPathTypeReference reference = type as IEdmPathTypeReference;
-            if (reference != null)
+
+            if (type is IEdmPathTypeReference reference)
             {
                 return reference;
             }
@@ -1080,8 +1079,8 @@ namespace Microsoft.OData.Edm
         public static IEdmSpatialTypeReference AsSpatial(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmSpatialTypeReference spatial = type as IEdmSpatialTypeReference;
-            if (spatial != null)
+
+            if (type is IEdmSpatialTypeReference spatial)
             {
                 return spatial;
             }
@@ -1104,8 +1103,8 @@ namespace Microsoft.OData.Edm
         public static IEdmTemporalTypeReference AsTemporal(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmTemporalTypeReference temporal = type as IEdmTemporalTypeReference;
-            if (temporal != null)
+
+            if (type is IEdmTemporalTypeReference temporal)
             {
                 return temporal;
             }
@@ -1128,8 +1127,8 @@ namespace Microsoft.OData.Edm
         public static IEdmDecimalTypeReference AsDecimal(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmDecimalTypeReference decimalType = type as IEdmDecimalTypeReference;
-            if (decimalType != null)
+
+            if (type is IEdmDecimalTypeReference decimalType)
             {
                 return decimalType;
             }
@@ -1152,8 +1151,8 @@ namespace Microsoft.OData.Edm
         public static IEdmStringTypeReference AsString(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmStringTypeReference stringType = type as IEdmStringTypeReference;
-            if (stringType != null)
+
+            if (type is IEdmStringTypeReference stringType)
             {
                 return stringType;
             }
@@ -1176,8 +1175,8 @@ namespace Microsoft.OData.Edm
         public static IEdmBinaryTypeReference AsBinary(this IEdmTypeReference type)
         {
             EdmUtil.CheckArgumentNull(type, "type");
-            IEdmBinaryTypeReference binaryType = type as IEdmBinaryTypeReference;
-            if (binaryType != null)
+
+            if (type is IEdmBinaryTypeReference binaryType)
             {
                 return binaryType;
             }
@@ -1368,32 +1367,27 @@ namespace Microsoft.OData.Edm
 
         internal static IEdmTypeReference GetTypeReference(this IEdmType type, bool isNullable)
         {
-            IEdmPrimitiveType primitiveType = type as IEdmPrimitiveType;
-            if (primitiveType != null)
+            if (type is IEdmPrimitiveType primitiveType)
             {
                 return primitiveType.GetPrimitiveTypeReference(isNullable);
             }
-
-            IEdmComplexType complexType = type as IEdmComplexType;
-            if (complexType != null)
+
+            if (type is IEdmComplexType complexType)
             {
                 return new EdmComplexTypeReference(complexType, isNullable);
             }
-
-            IEdmEntityType entityType = type as IEdmEntityType;
-            if (entityType != null)
+
+            if (type is IEdmEntityType entityType)
             {
                 return new EdmEntityTypeReference(entityType, isNullable);
             }
-
-            IEdmEnumType enumType = type as IEdmEnumType;
-            if (enumType != null)
+
+            if (type is IEdmEnumType enumType)
             {
                 return new EdmEnumTypeReference(enumType, isNullable);
             }
-
-            IEdmPathType pathType = type as IEdmPathType;
-            if (pathType != null)
+
+            if (type is IEdmPathType pathType)
             {
                 return new EdmPathTypeReference(pathType, isNullable);
             }
diff --git a/src/Microsoft.OData.Edm/ExtensionMethods/EnumHelper.cs b/src/Microsoft.OData.Edm/ExtensionMethods/EnumHelper.cs
index 938c2a2c8..c908c66b8 100644
--- a/src/Microsoft.OData.Edm/ExtensionMethods/EnumHelper.cs
+++ b/src/Microsoft.OData.Edm/ExtensionMethods/EnumHelper.cs
@@ -136,9 +136,8 @@ namespace Microsoft.OData.Edm
         {
             if (type != null)
             {
-                // parse the value to string literal
-                IEdmEnumType enumType = type.Definition as IEdmEnumType;
-                if (enumType != null)
+                // parse the value to string literal
+                if (type.Definition is IEdmEnumType enumType)
                 {
                     return enumType.IsFlags ? enumType.ToStringWithFlags(value) : enumType.ToStringNoFlags(value);
                 }
diff --git a/src/Microsoft.OData.Edm/ExtensionMethods/ExtensionMethods.cs b/src/Microsoft.OData.Edm/ExtensionMethods/ExtensionMethods.cs
index ab2b53b59..0125353b0 100644
--- a/src/Microsoft.OData.Edm/ExtensionMethods/ExtensionMethods.cs
+++ b/src/Microsoft.OData.Edm/ExtensionMethods/ExtensionMethods.cs
@@ -806,7 +806,7 @@ namespace Microsoft.OData.Edm
             if (annotation != null)
             {
                 IEdmCollectionExpression collectionExpression = annotation.Value as IEdmCollectionExpression;
-                if (collectionExpression != null && collectionExpression.Elements != null)
+                if (collectionExpression?.Elements != null)
                 {
                     return collectionExpression.Elements.OfType<IEdmStringConstantExpression>().Select(e => e.Value);
                 }
@@ -1439,7 +1439,7 @@ namespace Microsoft.OData.Edm
         {
             EdmUtil.CheckArgumentNull(item, "item");
             IEdmLocatable locatable = item as IEdmLocatable;
-            return locatable != null && locatable.Location != null ? locatable.Location : new ObjectLocation(item);
+            return locatable?.Location != null ? locatable.Location : new ObjectLocation(item);
         }
 
         #endregion
@@ -3393,7 +3393,7 @@ namespace Microsoft.OData.Edm
                 // for CsdlSemanticsEntityContainer, try searching .Extends container :
                 // (after IEdmModel has public Extends property, don't need to check CsdlSemanticsEntityContainer)
                 CsdlSemanticsEntityContainer tmp = container as CsdlSemanticsEntityContainer;
-                if (tmp != null && tmp.Extends != null)
+                if (tmp?.Extends != null)
                 {
                     return FindInContainerAndExtendsRecursively(tmp.Extends, simpleName, finderFunc, --depth);
                 }
diff --git a/src/Microsoft.OData.Edm/ExtensionMethods/ToTraceStringExtensionMethods.cs b/src/Microsoft.OData.Edm/ExtensionMethods/ToTraceStringExtensionMethods.cs
index 23c93182c..42717b6c7 100644
--- a/src/Microsoft.OData.Edm/ExtensionMethods/ToTraceStringExtensionMethods.cs
+++ b/src/Microsoft.OData.Edm/ExtensionMethods/ToTraceStringExtensionMethods.cs
@@ -48,8 +48,7 @@ namespace Microsoft.OData.Edm
                 case EdmTypeKind.EntityReference:
                     return ((IEdmEntityReferenceType)type).ToTraceString();
                 default:
-                    var schemaType = type as IEdmSchemaType;
-                    return schemaType != null ? schemaType.ToTraceString() : EdmConstants.Value_UnknownType;
+                    return type is IEdmSchemaType schemaType ? schemaType.ToTraceString() : EdmConstants.Value_UnknownType;
             }
         }
 
diff --git a/src/Microsoft.OData.Edm/Microsoft.OData.Edm.cs b/src/Microsoft.OData.Edm/Microsoft.OData.Edm.cs
index b3c3ac409..8755060b4 100644
--- a/src/Microsoft.OData.Edm/Microsoft.OData.Edm.cs
+++ b/src/Microsoft.OData.Edm/Microsoft.OData.Edm.cs
@@ -371,8 +371,7 @@ namespace Microsoft.OData.Edm
             {
                 for (int i = 0; i < args.Length; i ++)
                 {
-                    String value = args[i] as String;
-                    if (value != null && value.Length > 1024)
+                    if (args[i] is String value && value.Length > 1024)
                     {
                         args[i] = value.Substring(0, 1024 - 3) + "...";
                     }
diff --git a/src/Microsoft.OData.Edm/RegistrationHelper.cs b/src/Microsoft.OData.Edm/RegistrationHelper.cs
index f3297e2d5..8162561df 100644
--- a/src/Microsoft.OData.Edm/RegistrationHelper.cs
+++ b/src/Microsoft.OData.Edm/RegistrationHelper.cs
@@ -104,9 +104,8 @@ namespace Microsoft.OData.Edm
             {
                 return first;
             }
-
-            var ambiguous = first as AmbiguousTypeBinding;
-            if (ambiguous != null)
+
+            if (first is AmbiguousTypeBinding ambiguous)
             {
                 ambiguous.AddBinding(second);
                 return ambiguous;
@@ -117,8 +116,7 @@ namespace Microsoft.OData.Edm
 
         internal static IEdmTerm CreateAmbiguousTermBinding(IEdmTerm first, IEdmTerm second)
         {
-            var ambiguous = first as AmbiguousTermBinding;
-            if (ambiguous != null)
+            if (first is AmbiguousTermBinding ambiguous)
             {
                 ambiguous.AddBinding(second);
                 return ambiguous;
@@ -129,8 +127,7 @@ namespace Microsoft.OData.Edm
 
         internal static IEdmEntitySet CreateAmbiguousEntitySetBinding(IEdmEntitySet first, IEdmEntitySet second)
         {
-            var ambiguous = first as AmbiguousEntitySetBinding;
-            if (ambiguous != null)
+            if (first is AmbiguousEntitySetBinding ambiguous)
             {
                 ambiguous.AddBinding(second);
                 return ambiguous;
@@ -141,8 +138,7 @@ namespace Microsoft.OData.Edm
 
         internal static IEdmSingleton CreateAmbiguousSingletonBinding(IEdmSingleton first, IEdmSingleton second)
         {
-            var ambiguous = first as AmbiguousSingletonBinding;
-            if (ambiguous != null)
+            if (first is AmbiguousSingletonBinding ambiguous)
             {
                 ambiguous.AddBinding(second);
                 return ambiguous;
@@ -153,8 +149,7 @@ namespace Microsoft.OData.Edm
 
         internal static IEdmEntityContainer CreateAmbiguousEntityContainerBinding(IEdmEntityContainer first, IEdmEntityContainer second)
         {
-            var ambiguous = first as AmbiguousEntityContainerBinding;
-            if (ambiguous != null)
+            if (first is AmbiguousEntityContainerBinding ambiguous)
             {
                 ambiguous.AddBinding(second);
                 return ambiguous;
@@ -165,8 +160,7 @@ namespace Microsoft.OData.Edm
 
         private static IEdmProperty CreateAmbiguousPropertyBinding(IEdmProperty first, IEdmProperty second)
         {
-            var ambiguous = first as AmbiguousPropertyBinding;
-            if (ambiguous != null)
+            if (first is AmbiguousPropertyBinding ambiguous)
             {
                 ambiguous.AddBinding(second);
                 return ambiguous;
diff --git a/src/Microsoft.OData.Edm/Schema/Date.cs b/src/Microsoft.OData.Edm/Schema/Date.cs
index 158e93d9b..29428bd2b 100644
--- a/src/Microsoft.OData.Edm/Schema/Date.cs
+++ b/src/Microsoft.OData.Edm/Schema/Date.cs
@@ -250,9 +250,8 @@ namespace Microsoft.OData.Edm
         /// Greater than zero This instance is later than value.</returns>
         public int CompareTo(object obj)
         {
-            if (obj is Date)
+            if (obj is Date date2)
             {
-                Date date2 = (Date)obj;
                 return this.CompareTo(date2);
             }
             else
@@ -295,7 +294,7 @@ namespace Microsoft.OData.Edm
         /// <returns>True for equal, false for non-equal.</returns>
         public override bool Equals(object obj)
         {
-            if (obj == null || !(obj is Date))
+            if (!(obj is Date))
             {
                 return false;
             }
diff --git a/src/Microsoft.OData.Edm/Schema/EdmCollectionTypeReference.cs b/src/Microsoft.OData.Edm/Schema/EdmCollectionTypeReference.cs
index bd01030ee..400c74592 100644
--- a/src/Microsoft.OData.Edm/Schema/EdmCollectionTypeReference.cs
+++ b/src/Microsoft.OData.Edm/Schema/EdmCollectionTypeReference.cs
@@ -31,9 +31,7 @@ namespace Microsoft.OData.Edm
             {
                 return true;
             }
-
-            IEdmEntityTypeReference entityReference = elementType as IEdmEntityTypeReference;
-            return entityReference != null || collectionType.ElementType.IsNullable;
+            return elementType is IEdmEntityTypeReference entityReference || collectionType.ElementType.IsNullable;
         }
     }
 }
\ No newline at end of file
diff --git a/src/Microsoft.OData.Edm/Schema/EdmEntityContainer.cs b/src/Microsoft.OData.Edm/Schema/EdmEntityContainer.cs
index 672aead4c..580cf1bc6 100644
--- a/src/Microsoft.OData.Edm/Schema/EdmEntityContainer.cs
+++ b/src/Microsoft.OData.Edm/Schema/EdmEntityContainer.cs
@@ -280,8 +280,7 @@ namespace Microsoft.OData.Edm
             object element;
             if (this.operationImportDictionary.TryGetValue(operationName, out element))
             {
-                List<IEdmOperationImport> listElement = element as List<IEdmOperationImport>;
-                if (listElement != null)
+                if (element is List<IEdmOperationImport> listElement)
                 {
                     return listElement;
                 }
diff --git a/src/Microsoft.OData.Edm/Schema/EdmModel.cs b/src/Microsoft.OData.Edm/Schema/EdmModel.cs
index c0c97e5a8..45fc7c855 100644
--- a/src/Microsoft.OData.Edm/Schema/EdmModel.cs
+++ b/src/Microsoft.OData.Edm/Schema/EdmModel.cs
@@ -87,7 +87,7 @@ namespace Microsoft.OData.Edm
             EdmUtil.CheckArgumentNull(element, "element");
             this.elements.Add(element);
             IEdmStructuredType structuredType = element as IEdmStructuredType;
-            if (structuredType != null && structuredType.BaseType != null)
+            if (structuredType?.BaseType != null)
             {
                 List<IEdmStructuredType> derivedTypes;
                 if (!this.derivedTypeMappings.TryGetValue(structuredType.BaseType, out derivedTypes))
diff --git a/src/Microsoft.OData.Edm/Schema/EdmModelBase.cs b/src/Microsoft.OData.Edm/Schema/EdmModelBase.cs
index 43ff2c8ce..6acad8700 100644
--- a/src/Microsoft.OData.Edm/Schema/EdmModelBase.cs
+++ b/src/Microsoft.OData.Edm/Schema/EdmModelBase.cs
@@ -208,9 +208,7 @@ namespace Microsoft.OData.Edm
 
             IList<IEdmOperation> matchedOperations = new List<IEdmOperation>();
 
-            IList<IEdmOperation> operations = enumerable as IList<IEdmOperation>;
-
-            if (operations != null)
+            if (enumerable is IList<IEdmOperation> operations)
             {
                 for (int i = 0; i < operations.Count; i++)
                 {
diff --git a/src/Microsoft.OData.Edm/Schema/TimeOfDay.cs b/src/Microsoft.OData.Edm/Schema/TimeOfDay.cs
index f21e57ed4..aa50c9665 100644
--- a/src/Microsoft.OData.Edm/Schema/TimeOfDay.cs
+++ b/src/Microsoft.OData.Edm/Schema/TimeOfDay.cs
@@ -273,7 +273,7 @@ namespace Microsoft.OData.Edm
         /// <returns>True for equal, false for non-equal.</returns>
         public override bool Equals(object obj)
         {
-            if (obj == null || !(obj is TimeOfDay))
+            if (!(obj is TimeOfDay))
             {
                 return false;
             }
@@ -314,9 +314,8 @@ namespace Microsoft.OData.Edm
         /// Greater than zero This instance is later than value.</returns>
         public int CompareTo(object obj)
         {
-            if (obj is TimeOfDay)
+            if (obj is TimeOfDay time2)
             {
-                TimeOfDay time2 = (TimeOfDay)obj;
                 return this.CompareTo(time2);
             }
             else
diff --git a/src/Microsoft.OData.Edm/Validation/ExpressionTypeChecker.cs b/src/Microsoft.OData.Edm/Validation/ExpressionTypeChecker.cs
index 8367cfd10..04488be44 100644
--- a/src/Microsoft.OData.Edm/Validation/ExpressionTypeChecker.cs
+++ b/src/Microsoft.OData.Edm/Validation/ExpressionTypeChecker.cs
@@ -88,8 +88,7 @@ namespace Microsoft.OData.Edm.Validation
                     IEdmApplyExpression applyExpression = (IEdmApplyExpression)expression;
                     if (applyExpression.AppliedFunction != null)
                     {
-                        IEdmOperation operation = applyExpression.AppliedFunction as IEdmOperation;
-                        if (operation != null)
+                        if (applyExpression.AppliedFunction is IEdmOperation operation)
                         {
                             return TestTypeReferenceMatch(operation.ReturnType, type, expression.Location(), matchExactly, out discoveredErrors);
                         }
@@ -184,8 +183,7 @@ namespace Microsoft.OData.Edm.Validation
 
         internal static bool TryCastPathAsType(this IEdmPathExpression expression, IEdmTypeReference type, IEdmType context, bool matchExactly, out IEnumerable<EdmError> discoveredErrors)
         {
-            IEdmStructuredType structuredContext = context as IEdmStructuredType;
-            if (structuredContext != null)
+            if (context is IEdmStructuredType structuredContext)
             {
                 IEdmType result = context;
 
diff --git a/src/Microsoft.OData.Edm/Validation/InterfaceValidator.cs b/src/Microsoft.OData.Edm/Validation/InterfaceValidator.cs
index 8e2fc4484..686d5373b 100644
--- a/src/Microsoft.OData.Edm/Validation/InterfaceValidator.cs
+++ b/src/Microsoft.OData.Edm/Validation/InterfaceValidator.cs
@@ -222,13 +222,13 @@ namespace Microsoft.OData.Edm.Validation
         private static bool IsCheckableBad(object element)
         {
             IEdmCheckable checkable = element as IEdmCheckable;
-            return checkable != null && checkable.Errors != null && checkable.Errors.Any();
+            return checkable?.Errors != null && checkable.Errors.Any();
         }
 
         private static EdmLocation GetLocation(object item)
         {
             IEdmLocatable edmLocatable = item as IEdmLocatable;
-            return edmLocatable != null && edmLocatable.Location != null ? edmLocatable.Location : new ObjectLocation(item);
+            return edmLocatable?.Location != null ? edmLocatable.Location : new ObjectLocation(item);
         }
 
         private static IEnumerable<ValidationRule> GetSemanticInterfaceVisitorsForObject(Type objectType, ValidationRuleSet ruleSet, Dictionary<Type, List<ValidationRule>> concreteTypeSemanticInterfaceVisitors)
@@ -304,8 +304,7 @@ namespace Microsoft.OData.Edm.Validation
             // and so are not found in a normal traversal.
             if (this.validateDirectValueAnnotations)
             {
-                IEdmElement element = item as IEdmElement;
-                if (element != null)
+                if (item is IEdmElement element)
                 {
                     foreach (IEdmDirectValueAnnotation annotation in this.model.DirectValueAnnotations(element))
                     {
@@ -313,11 +312,9 @@ namespace Microsoft.OData.Edm.Validation
                     }
                 }
             }
-
-            // Out-of-line annotations are found through the model visitor, but inline annotations
-            // are not found through normal traversal, so add in-line annotations here.
-            IEdmVocabularyAnnotatable annotatable = item as IEdmVocabularyAnnotatable;
-            if (this.model != null && annotatable != null)
+
+            // Out-of-line annotations are found through the model visitor, but inline annotations            // are not found through normal traversal, so add in-line annotations here.
+            if (this.model != null && item is IEdmVocabularyAnnotatable annotatable)
             {
                 foreach (IEdmVocabularyAnnotation annotation in annotatable.VocabularyAnnotations(this.model))
                 {
@@ -706,8 +703,7 @@ namespace Microsoft.OData.Edm.Validation
                     {
                         if (visitedTypes.Contains(currentBaseType))
                         {
-                            IEdmSchemaType schemaType = type as IEdmSchemaType;
-                            string typeName = schemaType != null ? schemaType.FullName() : typeof(Type).Name;
+                            string typeName = type is IEdmSchemaType schemaType ? schemaType.FullName() : typeof(Type).Name;
                             CollectErrors(new EdmError(GetLocation(type), EdmErrorCode.InterfaceCriticalCycleInTypeHierarchy, Strings.EdmModel_Validator_Syntactic_InterfaceCriticalCycleInTypeHierarchy(typeName)), ref errors);
                             break;
                         }
@@ -1217,8 +1213,7 @@ namespace Microsoft.OData.Edm.Validation
         {
             protected override IEnumerable<EdmError> VisitT(IEdmBinaryTypeReference typeRef, List<object> followup, List<object> references)
             {
-                IEdmPrimitiveType primitive = typeRef.Definition as IEdmPrimitiveType;
-                return primitive != null && primitive.PrimitiveKind != EdmPrimitiveTypeKind.Binary ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
+                return typeRef.Definition is IEdmPrimitiveType primitive && primitive.PrimitiveKind != EdmPrimitiveTypeKind.Binary ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
             }
         }
 
@@ -1226,8 +1221,7 @@ namespace Microsoft.OData.Edm.Validation
         {
             protected override IEnumerable<EdmError> VisitT(IEdmDecimalTypeReference typeRef, List<object> followup, List<object> references)
             {
-                IEdmPrimitiveType primitive = typeRef.Definition as IEdmPrimitiveType;
-                return primitive != null && primitive.PrimitiveKind != EdmPrimitiveTypeKind.Decimal ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
+                return typeRef.Definition is IEdmPrimitiveType primitive && primitive.PrimitiveKind != EdmPrimitiveTypeKind.Decimal ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
             }
         }
 
@@ -1235,8 +1229,7 @@ namespace Microsoft.OData.Edm.Validation
         {
             protected override IEnumerable<EdmError> VisitT(IEdmStringTypeReference typeRef, List<object> followup, List<object> references)
             {
-                IEdmPrimitiveType primitive = typeRef.Definition as IEdmPrimitiveType;
-                return primitive != null && primitive.PrimitiveKind != EdmPrimitiveTypeKind.String ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
+                return typeRef.Definition is IEdmPrimitiveType primitive && primitive.PrimitiveKind != EdmPrimitiveTypeKind.String ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
             }
         }
 
@@ -1244,8 +1237,7 @@ namespace Microsoft.OData.Edm.Validation
         {
             protected override IEnumerable<EdmError> VisitT(IEdmTemporalTypeReference typeRef, List<object> followup, List<object> references)
             {
-                IEdmPrimitiveType primitive = typeRef.Definition as IEdmPrimitiveType;
-                return primitive != null && !primitive.PrimitiveKind.IsTemporal() ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
+                return typeRef.Definition is IEdmPrimitiveType primitive && !primitive.PrimitiveKind.IsTemporal() ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
             }
         }
 
@@ -1253,8 +1245,7 @@ namespace Microsoft.OData.Edm.Validation
         {
             protected override IEnumerable<EdmError> VisitT(IEdmSpatialTypeReference typeRef, List<object> followup, List<object> references)
             {
-                IEdmPrimitiveType primitive = typeRef.Definition as IEdmPrimitiveType;
-                return primitive != null && !primitive.PrimitiveKind.IsSpatial() ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
+                return typeRef.Definition is IEdmPrimitiveType primitive && !primitive.PrimitiveKind.IsSpatial() ? new EdmError[] { CreatePrimitiveTypeRefInterfaceTypeKindValueMismatchError(typeRef) } : null;
             }
         }
 
diff --git a/src/Microsoft.OData.Edm/Validation/ValidationHelper.cs b/src/Microsoft.OData.Edm/Validation/ValidationHelper.cs
index 473845b82..6f0c715ad 100644
--- a/src/Microsoft.OData.Edm/Validation/ValidationHelper.cs
+++ b/src/Microsoft.OData.Edm/Validation/ValidationHelper.cs
@@ -41,12 +41,12 @@ namespace Microsoft.OData.Edm.Validation
 
         internal static bool AllPropertiesAreNullable(IEnumerable<IEdmStructuralProperty> properties)
         {
-            return !properties.Where(p => !p.Type.IsNullable).Any();
+            return !properties.Any(p => !p.Type.IsNullable);
         }
 
         internal static bool HasNullableProperty(IEnumerable<IEdmStructuralProperty> properties)
         {
-            return properties.Where(p => p.Type.IsNullable).Any();
+            return properties.Any(p => p.Type.IsNullable);
         }
 
         internal static bool PropertySetIsSubset(IEnumerable<IEdmStructuralProperty> set, IEnumerable<IEdmStructuralProperty> subset)
@@ -199,8 +199,7 @@ namespace Microsoft.OData.Edm.Validation
 
                 foreach (IEdmStructuredType derived in context.FindAllDerivedTypes(source))
                 {
-                    IEdmEntityType derivedEntity = derived as IEdmEntityType;
-                    if (derivedEntity != null && TypeIndirectlyContainsTarget(derivedEntity, target, visited, context))
+                    if (derived is IEdmEntityType derivedEntity && TypeIndirectlyContainsTarget(derivedEntity, target, visited, context))
                     {
                         return true;
                     }
diff --git a/src/Microsoft.OData.Edm/Validation/ValidationRules.cs b/src/Microsoft.OData.Edm/Validation/ValidationRules.cs
index dcafca79c..150a0c545 100644
--- a/src/Microsoft.OData.Edm/Validation/ValidationRules.cs
+++ b/src/Microsoft.OData.Edm/Validation/ValidationRules.cs
@@ -1800,8 +1800,7 @@ namespace Microsoft.OData.Edm.Validation
                     }
 
                     // The UrlEscape function should have and only have two parameters, the non-binding parameter type should be "Edm.String"
-                    if (function.Parameters == null ||
-                        function.Parameters.Count() != 2 ||
+                    if (function.Parameters == null || function.Parameters.Count() != 2||
                         !function.Parameters.ElementAt(1).Type.IsString())
                     {
                         context.AddError(
@@ -2770,9 +2769,8 @@ namespace Microsoft.OData.Edm.Validation
                     {
                         return false;
                     }
-
-                    var navProperty = property as IEdmNavigationProperty;
-                    if (navProperty != null && !navProperty.ContainsTarget)
+
+                    if (property is IEdmNavigationProperty navProperty && !navProperty.ContainsTarget)
                     {
                         return false;
                     }
@@ -2794,9 +2792,7 @@ namespace Microsoft.OData.Edm.Validation
                     definingType = derivedType;
                 }
             }
-
-            var navigationProperty = definingType.FindProperty(pathSegments.Last()) as IEdmNavigationProperty;
-            return navigationProperty != null;
+            return definingType.FindProperty(pathSegments.Last()) is IEdmNavigationProperty navigationProperty;
         }
 
         private static bool HasPathTypeProperty(IEdmStructuredType structuredType, IList<IEdmStructuredType> visited)
diff --git a/src/Microsoft.OData.Edm/Vocabularies/EdmExpressionEvaluator.cs b/src/Microsoft.OData.Edm/Vocabularies/EdmExpressionEvaluator.cs
index 4d2005708..2ffadb491 100644
--- a/src/Microsoft.OData.Edm/Vocabularies/EdmExpressionEvaluator.cs
+++ b/src/Microsoft.OData.Edm/Vocabularies/EdmExpressionEvaluator.cs
@@ -353,10 +353,7 @@ namespace Microsoft.OData.Edm.Vocabularies
                     }
 
                     visitedProperties.Add(propertyValue);
-                    if (newProperties != null)
-                    {
-                        newProperties.Add(propertyValue);
-                    }
+                    newProperties?.Add(propertyValue);
                 }
             }
 
@@ -466,8 +463,7 @@ namespace Microsoft.OData.Edm.Vocabularies
                             }
                             else if (hop == "$count")
                             {
-                                var edmCollectionValue = result as IEdmCollectionValue;
-                                if (edmCollectionValue != null)
+                                if (result is IEdmCollectionValue edmCollectionValue)
                                 {
                                     result = new EdmIntegerConstant(edmCollectionValue.Elements.Count());
                                 }
@@ -726,9 +722,8 @@ namespace Microsoft.OData.Edm.Vocabularies
         private static IEdmValue FindProperty(string name, IEdmValue context)
         {
             IEdmValue result = null;
-
-            IEdmStructuredValue structuredContext = context as IEdmStructuredValue;
-            if (structuredContext != null)
+
+            if (context is IEdmStructuredValue structuredContext)
             {
                 IEdmPropertyValue propertyValue = structuredContext.FindPropertyValue(name);
                 if (propertyValue != null)
diff --git a/src/Microsoft.OData.Edm/Vocabularies/EdmToClrConverter.cs b/src/Microsoft.OData.Edm/Vocabularies/EdmToClrConverter.cs
index a69e32781..f8e027507 100644
--- a/src/Microsoft.OData.Edm/Vocabularies/EdmToClrConverter.cs
+++ b/src/Microsoft.OData.Edm/Vocabularies/EdmToClrConverter.cs
@@ -619,13 +619,12 @@ namespace Microsoft.OData.Edm.Vocabularies
                 if (isEnum)
                 {
                     Type underlyingType = Enum.GetUnderlyingType(clrType);
-                    IEdmEnumValue edmEnumValue = edmValue as IEdmEnumValue;
 
                     object clrValue = null;
-                    if (edmEnumValue != null)
+
+                    if (edmValue is IEdmEnumValue edmEnumValue)
                     {
-                        EdmEnumMemberValue memberValue = edmEnumValue.Value as EdmEnumMemberValue;
-                        if (memberValue != null
+                        if (edmEnumValue.Value is EdmEnumMemberValue memberValue
                             && !TryConvertEnumType(underlyingType, memberValue.Value, out clrValue))
                         {
                             throw new InvalidCastException(Strings.EdmToClr_UnsupportedType(underlyingType));
diff --git a/src/Microsoft.OData.Edm/Vocabularies/VocabularyAnnotationExtensions.cs b/src/Microsoft.OData.Edm/Vocabularies/VocabularyAnnotationExtensions.cs
index 9968dc460..42d2ec05f 100644
--- a/src/Microsoft.OData.Edm/Vocabularies/VocabularyAnnotationExtensions.cs
+++ b/src/Microsoft.OData.Edm/Vocabularies/VocabularyAnnotationExtensions.cs
@@ -31,7 +31,7 @@ namespace Microsoft.OData.Edm.Vocabularies.V1
             if (annotation != null)
             {
                 IEdmCollectionExpression collectionExpression = annotation.Value as IEdmCollectionExpression;
-                if (collectionExpression != null && collectionExpression.Elements != null)
+                if (collectionExpression?.Elements != null)
                 {
                     return collectionExpression.Elements.OfType<IEdmStringConstantExpression>().Select(e => e.Value);
                 }
diff --git a/src/Microsoft.Spatial/Geography/GeoJsonObjectReader.cs b/src/Microsoft.Spatial/Geography/GeoJsonObjectReader.cs
index 4685413b6..54bc8a3b7 100644
--- a/src/Microsoft.Spatial/Geography/GeoJsonObjectReader.cs
+++ b/src/Microsoft.Spatial/Geography/GeoJsonObjectReader.cs
@@ -175,9 +175,8 @@ namespace Microsoft.Spatial
                     // but that would be a mistake, becuase we wouldn't know how to interpret the KeyValuePair
                     throw new FormatException(Strings.GeoJsonReader_ExpectedArray);
                 }
-
-                IEnumerable array = value as IEnumerable;
-                if (array != null)
+
+                if (value is IEnumerable array)
                 {
                     return array;
                 }
@@ -196,9 +195,8 @@ namespace Microsoft.Spatial
                 {
                     return null;
                 }
-
-                IDictionary<string, object> castValue = value as IDictionary<string, object>;
-                if (castValue != null)
+
+                if (value is IDictionary<string, object> castValue)
                 {
                     return castValue;
                 }
@@ -218,9 +216,8 @@ namespace Microsoft.Spatial
                 {
                     return null;
                 }
-
-                string castValue = value as string;
-                if (castValue != null)
+
+                if (value is string castValue)
                 {
                     return castValue;
                 }
diff --git a/src/Microsoft.Spatial/Microsoft.Spatial.cs b/src/Microsoft.Spatial/Microsoft.Spatial.cs
index 21fff8927..c3068b60f 100644
--- a/src/Microsoft.Spatial/Microsoft.Spatial.cs
+++ b/src/Microsoft.Spatial/Microsoft.Spatial.cs
@@ -112,8 +112,7 @@ namespace Microsoft.Spatial
             {
                 for (int i = 0; i < args.Length; i ++)
                 {
-                    String value = args[i] as String;
-                    if (value != null && value.Length > 1024)
+                    if (args[i] is String value && value.Length > 1024)
                     {
                         args[i] = value.Substring(0, 1024 - 3) + "...";
                     }
diff --git a/src/PlatformHelper.cs b/src/PlatformHelper.cs
index 6d7f755d5..7082caa91 100644
--- a/src/PlatformHelper.cs
+++ b/src/PlatformHelper.cs
@@ -570,12 +570,12 @@ namespace Microsoft.OData.Edm
             // a general purpose flags enum and methods that can take any combination of the flags, we provide more restrictive methods that
             // still allow for the same functionality as needed by the calling code.
             return type.GetRuntimeMethods()
-                .Where(
+                .SingleOrDefault(
                     m =>
                         m.Name == name &&
                         isPublic == m.IsPublic &&
                         isStatic == m.IsStatic)
-                .SingleOrDefault();
+;
         }
 
         /// <summary>
@@ -708,7 +708,7 @@ namespace Microsoft.OData.Edm
         /// <returns>MethodInfo if one was found for the specified type, otherwise false.</returns>
         internal static MethodInfo GetMethod(this Type type, string name)
         {
-            return type.GetRuntimeMethods().Where(m => m.IsPublic && m.Name == name).SingleOrDefault();
+            return type.GetRuntimeMethods().SingleOrDefault(m => m.IsPublic && m.Name == name);
         }
 
         /// <summary>
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/ODataJsonLightWriterEnumIntegrationTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/ODataJsonLightWriterEnumIntegrationTests.cs
index 81fcb3db9..8c625ce8a 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/ODataJsonLightWriterEnumIntegrationTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/ODataJsonLightWriterEnumIntegrationTests.cs
@@ -987,15 +987,13 @@ namespace Microsoft.OData.Tests.IntegrationTests.Writer.JsonLight
         {
             foreach (ODataItem itemToWrite in nestedItemsToWrite)
             {
-                ODataResourceSet feedToWrite = itemToWrite as ODataResourceSet;
-                if (feedToWrite != null)
+                if (itemToWrite is ODataResourceSet feedToWrite)
                 {
                     writer.WriteStart(feedToWrite);
                 }
                 else
                 {
-                    ODataResource entryToWrite = itemToWrite as ODataResource;
-                    if (entryToWrite != null)
+                    if (itemToWrite is ODataResource entryToWrite)
                     {
                         writer.WriteStart(entryToWrite);
                     }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/UriParameterWriterIntegrationTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/UriParameterWriterIntegrationTests.cs
index 6696f8ada..0f1769103 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/UriParameterWriterIntegrationTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/IntegrationTests/Writer/JsonLight/UriParameterWriterIntegrationTests.cs
@@ -487,8 +487,8 @@ namespace Microsoft.OData.Tests.IntegrationTests.Writer.JsonLight
                 using (ODataMessageWriter messageWriter = new ODataMessageWriter((IODataRequestMessage)message, settings, withModel ? model : null))
                 {
                     ODataWriter writer;
-                    ResourceWrapper resource = wrapper as ResourceWrapper;
-                    if (resource != null)
+
+                    if (wrapper is ResourceWrapper resource)
                     {
                         writer = messageWriter.CreateODataUriParameterResourceWriter(null, null);
                         WriteResource(writer, resource);
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsAsyncTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsAsyncTests.cs
index ab3fcc0ba..9fb641219 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsAsyncTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsAsyncTests.cs
@@ -26,7 +26,7 @@ namespace Microsoft.OData.Tests.Json
         {
             controlCharsMap = new Dictionary<string, string>
             {
-                {string.Format("{0}",(char)0),string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)},
+                {$"{(char)0}",string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)},
                 {"\r\n","\\r\\n"},
                 {"\r","\\r"},
                 {"\t","\\t"},
@@ -39,7 +39,7 @@ namespace Microsoft.OData.Tests.Json
 
             escapedCharMap = new Dictionary<string, string>
             {
-                {string.Format("{0}",(char)0x80), string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
+                {$"{(char)0x80}", string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
                 {"и",  "\\u0438"}
             };
 
@@ -99,9 +99,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.Reset();
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("{0}", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, this.buffer);
-                Assert.Equal(string.Format("\"{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
@@ -111,9 +111,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.Reset();
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("{0}MiddleEnd", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"{specialChar}MiddleEnd",
                     ODataStringEscapeOption.EscapeNonAscii, this.buffer);
-                Assert.Equal(string.Format("\"{0}MiddleEnd\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"{this.escapedCharMap[specialChar]}MiddleEnd\"", this.StreamToString());
             }
         }
 
@@ -123,9 +123,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.Reset();
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("Start{0}End", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"Start{specialChar}End",
                     ODataStringEscapeOption.EscapeNonAscii, this.buffer);
-                Assert.Equal(string.Format("\"Start{0}End\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"Start{this.escapedCharMap[specialChar]}End\"", this.StreamToString());
             }
         }
 
@@ -135,9 +135,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.Reset();
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("StartMiddle{0}", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"StartMiddle{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, this.buffer);
-                Assert.Equal(string.Format("\"StartMiddle{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"StartMiddle{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
@@ -160,9 +160,9 @@ namespace Microsoft.OData.Tests.Json
             {
                 this.Reset();
                 Ref<char[]> charBuffer = new Ref<char[]>(new char[10]);
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("StartMiddle{0}End", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"StartMiddle{specialChar}End",
                     ODataStringEscapeOption.EscapeNonAscii, charBuffer);
-                Assert.Equal(string.Format("\"StartMiddle{0}End\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"StartMiddle{this.escapedCharMap[specialChar]}End\"", this.StreamToString());
             }
         }
 
@@ -186,9 +186,9 @@ namespace Microsoft.OData.Tests.Json
             {
                 this.Reset();
                 Ref<char[]> charBuffer = new Ref<char[]>(new char[6]);
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("Start{0}", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"Start{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, charBuffer);
-                Assert.Equal(string.Format("\"Start{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"Start{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsTests.cs
index 3f488952c..7816e0848 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/JsonValueUtilsTests.cs
@@ -25,7 +25,7 @@ namespace Microsoft.OData.Tests.Json
         {
             controlCharsMap = new Dictionary<string, string>
             {
-                {string.Format("{0}",(char)0),string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)},
+                {$"{(char)0}",string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)},
                 {"\r\n","\\r\\n"},
                 {"\r","\\r"},
                 {"\t","\\t"},
@@ -38,7 +38,7 @@ namespace Microsoft.OData.Tests.Json
 
             escapedCharMap = new Dictionary<string, string>
             {
-                {string.Format("{0}",(char)0x80), string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
+                {$"{(char)0x80}", string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
                 {"и",  "\\u0438"}
             };
 
@@ -100,9 +100,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.TestInit();
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("{0}", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, ref this.buffer);
-                Assert.Equal(string.Format("\"{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
@@ -112,9 +112,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.TestInit();
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("{0}MiddleEnd", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"{specialChar}MiddleEnd",
                     ODataStringEscapeOption.EscapeNonAscii, ref this.buffer);
-                Assert.Equal(string.Format("\"{0}MiddleEnd\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"{this.escapedCharMap[specialChar]}MiddleEnd\"", this.StreamToString());
             }
         }
 
@@ -124,9 +124,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.TestInit();
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("Start{0}End", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"Start{specialChar}End",
                     ODataStringEscapeOption.EscapeNonAscii, ref this.buffer);
-                Assert.Equal(string.Format("\"Start{0}End\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"Start{this.escapedCharMap[specialChar]}End\"", this.StreamToString());
             }
         }
 
@@ -136,9 +136,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.TestInit();
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("StartMiddle{0}", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"StartMiddle{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, ref this.buffer);
-                Assert.Equal(string.Format("\"StartMiddle{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"StartMiddle{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
@@ -161,9 +161,9 @@ namespace Microsoft.OData.Tests.Json
             {
                 this.TestInit();
                 char[] charBuffer = new char[10];
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("StartMiddle{0}End", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"StartMiddle{specialChar}End",
                     ODataStringEscapeOption.EscapeNonAscii, ref charBuffer);
-                Assert.Equal(string.Format("\"StartMiddle{0}End\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"StartMiddle{this.escapedCharMap[specialChar]}End\"", this.StreamToString());
             }
         }
 
@@ -187,9 +187,9 @@ namespace Microsoft.OData.Tests.Json
             {
                 this.TestInit();
                 char[] charBuffer = new char[6];
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("Start{0}", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"Start{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, ref charBuffer);
-                Assert.Equal(string.Format("\"Start{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"Start{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterAsyncTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterAsyncTests.cs
index f80b14abf..fcf98c98c 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterAsyncTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterAsyncTests.cs
@@ -32,8 +32,8 @@ namespace Microsoft.OData.Tests.Json
                 {"\n", "\\n"},
                 {"\b", "\\b"},
                 {"\f", "\\f"},
-                {string.Format("{0}", (char)0), string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)},
-                {string.Format("{0}", (char)0x80), string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
+                {$"{(char)0}", string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)},
+                {$"{(char)0x80}", string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
             };
 
             Reset();
@@ -63,9 +63,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.Reset();
-                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, string.Format("{0}", specialChar),
+                await JsonValueUtils.WriteEscapedJsonStringAsync(this.writer, $"{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, this.buffer);
-                Assert.Equal(string.Format("\"{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterTests.cs
index 9fcbd63c2..5b4ffc6e7 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/Json/NonIndentedTextWriterTests.cs
@@ -27,8 +27,8 @@ namespace Microsoft.OData.Tests.Json
             {"\n", "\\n"}, 
             {"\b", "\\b"}, 
             {"\f", "\\f"}, 
-            {string.Format("{0}", (char)0), string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)}, 
-            {string.Format("{0}", (char)0x80), string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
+            {$"{(char)0}", string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0)}, 
+            {$"{(char)0x80}", string.Format(CultureInfo.InvariantCulture, "\\u{0:x4}", 0x80)},
         };
 
         [Theory]
@@ -57,9 +57,9 @@ namespace Microsoft.OData.Tests.Json
             foreach (string specialChar in this.escapedCharMap.Keys)
             {
                 this.TestInit();
-                JsonValueUtils.WriteEscapedJsonString(this.writer, string.Format("{0}", specialChar),
+                JsonValueUtils.WriteEscapedJsonString(this.writer, $"{specialChar}",
                     ODataStringEscapeOption.EscapeNonAscii, ref this.buffer);
-                Assert.Equal(string.Format("\"{0}\"", this.escapedCharMap[specialChar]), this.StreamToString());
+                Assert.Equal($"\"{this.escapedCharMap[specialChar]}\"", this.StreamToString());
             }
         }
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs
index 9f1fc6eb9..3b66cafe8 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs
@@ -704,7 +704,7 @@ namespace Microsoft.Test.OData.TDD.Tests.Reader.JsonLight
 
             Assert.Equal(2, entry.Properties.Count());
             Assert.Equal("UndeclaredCollection1", undeclaredCollection1.Name);
-            Assert.Equal(3, undeclaredCollection1Items.Count());
+            Assert.Equal(3, undeclaredCollection1Items.Count);
             Assert.Equal("email1@163.com", undeclaredCollection1Items.First());
             Assert.Equal("email1@163.comemail2@gmail.comemail3@gmail2.com", String.Concat(undeclaredCollection1Items));
             Assert.Equal("Address", addressNestedInfo.Name);
@@ -762,7 +762,7 @@ namespace Microsoft.Test.OData.TDD.Tests.Reader.JsonLight
 
             Assert.Equal(2, entry.Properties.Count());
             Assert.Equal("Collection(Server.NS.UnknownCollectionType)", undeclaredCollection1.TypeAnnotation.TypeName);
-            Assert.Equal(3, untypedCollection.Count());
+            Assert.Equal(3, untypedCollection.Count);
             Assert.Equal("email1@163.comemail2@gmail.comemail3@gmail2.com", String.Concat(untypedCollection.Select(c=>((ODataResource)c).Properties.Single(p => string.Equals(p.Name, "email", StringComparison.Ordinal)).Value)));
             Assert.Equal(2, address.Properties.Count());
             Assert.Equal("No.999,Zixing Rd Minhang", address.Properties.First(s => string.Equals("Street", s.Name, StringComparison.Ordinal)).Value);
@@ -1143,7 +1143,7 @@ namespace Microsoft.Test.OData.TDD.Tests.Reader.JsonLight
 
             Assert.Equal(2, entry.Properties.Count());
             Assert.Equal("UndeclaredCollection1", undeclaredCollection1.Name);
-            Assert.Equal(5, undeclaredCollection1Items.Count());
+            Assert.Equal(5, undeclaredCollection1Items.Count);
             Assert.Null(undeclaredCollection1Items.Last());
             Assert.Equal("email1@163.comemail2@gmail.comemail3@gmail2.com", String.Concat(undeclaredCollection1Items));
             Assert.Equal("Address", addressNestedInfo.Name);
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightParameterReaderTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightParameterReaderTests.cs
index 6d09f598f..d537c0720 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightParameterReaderTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightParameterReaderTests.cs
@@ -132,7 +132,7 @@ namespace Microsoft.OData.Tests.JsonLight
             Assert.Equal("names", item.Key);
 
             var collectionItems = item.Value.Items;
-            Assert.Equal(2, collectionItems.Count());
+            Assert.Equal(2, collectionItems.Count);
             Assert.Equal(new[] { "john", "suzy" }, collectionItems.OfType<string>());
         }
 
@@ -184,7 +184,7 @@ namespace Microsoft.OData.Tests.JsonLight
             Assert.Equal("addresses", item.Key);
 
             var collectioItems = Assert.Single(result.Entries).Value;
-            Assert.Equal(2, collectioItems.Count());
+            Assert.Equal(2, collectioItems.Count);
             Assert.Equal(2, collectioItems.OfType<ODataResource>().Count());
         }
 
@@ -200,7 +200,7 @@ namespace Microsoft.OData.Tests.JsonLight
             Assert.Equal("addresses", item.Key);
 
             var collectioItems = Assert.Single(result.Entries).Value;
-            Assert.Equal(2, collectioItems.Count());
+            Assert.Equal(2, collectioItems.Count);
             Assert.Equal(2, collectioItems.OfType<ODataResource>().Count());
         }
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightPropertySerializerTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightPropertySerializerTests.cs
index e387f0949..8ac3c49be 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightPropertySerializerTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/ODataJsonLightPropertySerializerTests.cs
@@ -341,7 +341,7 @@ namespace Microsoft.OData.Tests.JsonLight
         private void UndeclaredPropertyShouldWriteTypeName(object value, string typeName)
         {
             var property = new ODataProperty { Name = "UndeclaredProperty", Value = value };
-            Assert.Contains(string.Format("@odata.type\":\"#{0}\"", typeName), this.SerializeProperty(this.entityType, property));
+            Assert.Contains($"@odata.type\":\"#{typeName}\"", this.SerializeProperty(this.entityType, property));
         }
         #endregion Default type name serialization behavior for primitive values
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/PayloadValueConverters.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/PayloadValueConverters.cs
index 44d86c4c5..5d2923dcb 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/PayloadValueConverters.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/JsonLight/PayloadValueConverters.cs
@@ -43,9 +43,9 @@ namespace Microsoft.OData.Tests.JsonLight
     {
         public override object ConvertToPayloadValue(object value, IEdmTypeReference edmTypeReference)
         {
-            if (value is DateTimeOffset)
+            if (value is DateTimeOffset dateTimeOffset)
             {
-                return ((DateTimeOffset)value).ToString("R", CultureInfo.InvariantCulture);
+                return dateTimeOffset.ToString("R", CultureInfo.InvariantCulture);
             }
 
             return base.ConvertToPayloadValue(value, edmTypeReference);
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/MediaTypeUtilsTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/MediaTypeUtilsTests.cs
index 726eaf717..d049a2df6 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/MediaTypeUtilsTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/MediaTypeUtilsTests.cs
@@ -443,7 +443,7 @@ namespace Microsoft.OData.Tests
                 ODataMediaType mediaType;
                 Encoding encoding;
                 ODataPayloadKind payloadKind;
-                MediaTypeUtils.GetFormatFromContentType(string.Format("multipart/mixed;boundary={0}", Guid.NewGuid()), new ODataPayloadKind[] { ODataPayloadKind.Batch }, ODataMediaTypeResolver.GetMediaTypeResolver(null), out mediaType, out encoding, out payloadKind);
+                MediaTypeUtils.GetFormatFromContentType($"multipart/mixed;boundary={Guid.NewGuid()}", new ODataPayloadKind[] { ODataPayloadKind.Batch }, ODataMediaTypeResolver.GetMediaTypeResolver(null), out mediaType, out encoding, out payloadKind);
             }
 
             Assert.True(MediaTypeUtils.GetCacheKeys().Count(k => k.StartsWith("multipart/mixed")) == 1, "Multiple multipart/mixed keys in cache");
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/EdmLibraryExtensionsTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/EdmLibraryExtensionsTests.cs
index 8bfde5705..83ad2f154 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/EdmLibraryExtensionsTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/EdmLibraryExtensionsTests.cs
@@ -560,7 +560,7 @@ namespace Microsoft.OData.Tests.Metadata
             var edmComplexType = new EdmComplexType(stringOfNamespaceName, stringOfComplexTypeName);
             var edmCollectionType = new EdmCollectionType(new EdmComplexTypeReference(edmComplexType, true));
 
-            var stringOfExpectedShortQulifiedName = String.Format("Collection({0}.{1})", stringOfNamespaceName, stringOfComplexTypeName);
+            var stringOfExpectedShortQulifiedName = $"Collection({stringOfNamespaceName}.{stringOfComplexTypeName})";
             var stringOfObservedShortQulifiedName = edmCollectionType.ODataShortQualifiedName();
             Assert.Equal(stringOfExpectedShortQulifiedName, stringOfObservedShortQulifiedName);
 
@@ -568,7 +568,7 @@ namespace Microsoft.OData.Tests.Metadata
             var edmEntityType = new EdmEntityType(stringOfNamespaceName, stringEntityTypeName);
             edmCollectionType = new EdmCollectionType(new EdmEntityTypeReference(edmEntityType, true));
 
-            stringOfExpectedShortQulifiedName = String.Format("Collection({0}.{1})", stringOfNamespaceName, stringEntityTypeName);
+            stringOfExpectedShortQulifiedName = $"Collection({stringOfNamespaceName}.{stringEntityTypeName})";
             stringOfObservedShortQulifiedName = edmCollectionType.ODataShortQualifiedName();
             Assert.Equal(stringOfExpectedShortQulifiedName, stringOfObservedShortQulifiedName);
         }
@@ -583,7 +583,7 @@ namespace Microsoft.OData.Tests.Metadata
                 var stringOfName = Enum.GetName(typeof(EdmPrimitiveTypeKind), edmPrimitiveTypeKind);
                 Assert.DoesNotContain("EDM.", stringOfName.ToUpper());
 
-                var stringOfExpectedShortQulifiedName = String.Format("Collection({0})", stringOfName);
+                var stringOfExpectedShortQulifiedName = $"Collection({stringOfName})";
                 var iEdmPrimitiveType = EdmCoreModel.Instance.GetPrimitiveType(edmPrimitiveTypeKind);
                 var edmCollectionType=new EdmCollectionType(new EdmPrimitiveTypeReference(iEdmPrimitiveType,true));
                 var stringOfObservedShortQulifiedName = edmCollectionType.ODataShortQualifiedName();
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/MetadataUtilsTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/MetadataUtilsTests.cs
index 64372d685..3dc354f56 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/MetadataUtilsTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/Metadata/MetadataUtilsTests.cs
@@ -33,7 +33,7 @@ namespace Microsoft.OData.Tests.Metadata
             var bindingType = this.model.FindType("TestModel.TVMovie");
             var bindableOperations = MetadataUtils.CalculateBindableOperationsForType(bindingType, this.model, new EdmTypeReaderResolver(this.model, null));
 
-            Assert.Equal(2, bindableOperations.Count());
+            Assert.Equal(2, bindableOperations.Count);
             Assert.True(bindableOperations.Count(o => o.Name == "Rate") == 1);
             Assert.True(bindableOperations.Count(o => o.Name == "ChangeChannel") == 1);
         }
@@ -43,7 +43,7 @@ namespace Microsoft.OData.Tests.Metadata
         {
             var bindingType = new EdmCollectionType(this.model.FindType("TestModel.Movie").ToTypeReference(nullable: false));
             var bindableOperations = MetadataUtils.CalculateBindableOperationsForType(bindingType, this.model, new EdmTypeReaderResolver(this.model, null));
-            Assert.Equal(2, bindableOperations.Count());
+            Assert.Equal(2, bindableOperations.Count);
             foreach (var operation in bindableOperations)
             {
                 Assert.Equal("RateMultiple", operation.Name);
@@ -85,7 +85,7 @@ namespace Microsoft.OData.Tests.Metadata
             var bindingType = this.model.FindType("TestModel.TVMovie");
             var bindableOperations = MetadataUtils.CalculateBindableOperationsForType(bindingType, this.model, new EdmTypeReaderResolver(this.model, this.NameToTypeResolver));
 
-            Assert.Equal(2, bindableOperations.Count());
+            Assert.Equal(2, bindableOperations.Count);
             Assert.True(bindableOperations.Count(o => o.Name == "Rate") == 1);
             Assert.True(bindableOperations.Count(o => o.Name == "ChangeChannel") == 1);
         }
@@ -95,7 +95,7 @@ namespace Microsoft.OData.Tests.Metadata
         {
             var bindingType = new EdmCollectionType(this.model.FindType("TestModel.Movie").ToTypeReference(nullable: false));
             var bindableOperations = MetadataUtils.CalculateBindableOperationsForType(bindingType, this.model, new EdmTypeReaderResolver(this.model, this.NameToTypeResolver));
-            Assert.Equal(2, bindableOperations.Count());
+            Assert.Equal(2, bindableOperations.Count);
             foreach (var operation in bindableOperations)
             {
                 Assert.Equal("RateMultiple", operation.Name);
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/NavigationPropertyOnComplexTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/NavigationPropertyOnComplexTests.cs
index 411485694..223dbce21 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/NavigationPropertyOnComplexTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/NavigationPropertyOnComplexTests.cs
@@ -41,7 +41,7 @@ namespace Microsoft.OData.Tests
 
             Uri uri = new Uri(@"http://host/People('abc')/Address/City");
             var paths = new ODataUriParser(Model, ServiceRoot, uri).ParsePath().ToList();
-            Assert.Equal(4, paths.Count());
+            Assert.Equal(4, paths.Count);
             paths[0].ShouldBeEntitySetSegment(EntitySet);
             paths[1].ShouldBeKeySegment(new KeyValuePair<string, object>("UserName", "abc"));
             paths[2].ShouldBePropertySegment(addressProperty);
@@ -49,7 +49,7 @@ namespace Microsoft.OData.Tests
 
             uri = new Uri(@"http://host/People('abc')/DefaultNs.Employee/Address/DefaultNs.WorkAddress/City");
             paths = new ODataUriParser(Model, ServiceRoot, uri).ParsePath().ToList();
-            Assert.Equal(6, paths.Count());
+            Assert.Equal(6, paths.Count);
             paths[0].ShouldBeEntitySetSegment(EntitySet);
             paths[1].ShouldBeKeySegment(new KeyValuePair<string, object>("UserName", "abc"));
             paths[2].ShouldBeTypeSegment(employeeType);
@@ -179,7 +179,7 @@ namespace Microsoft.OData.Tests
 
             Uri uri = new Uri(@"http://host/Entities('abc')/Complex/CollectionOfNav('def')");
             var paths = new ODataUriParser(CollectionModel, ServiceRoot, uri).ParsePath().ToList();
-            Assert.Equal(5, paths.Count());
+            Assert.Equal(5, paths.Count);
             paths[0].ShouldBeEntitySetSegment(entitySet);
             paths[1].ShouldBeKeySegment(new KeyValuePair<string, object>("ID", "abc"));
             paths[2].ShouldBePropertySegment(complexProperty);
@@ -188,7 +188,7 @@ namespace Microsoft.OData.Tests
 
             uri = new Uri(@"http://host/Entities('abc')/Complex/CollectionOfNav/$ref");
             paths = new ODataUriParser(CollectionModel, ServiceRoot, uri).ParsePath().ToList();
-            Assert.Equal(4, paths.Count());
+            Assert.Equal(4, paths.Count);
             paths[0].ShouldBeEntitySetSegment(entitySet);
             paths[1].ShouldBeKeySegment(new KeyValuePair<string, object>("ID", "abc"));
             paths[2].ShouldBePropertySegment(complexProperty);
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataPreferenceHeaderTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataPreferenceHeaderTests.cs
index 5436d20d4..dbddae841 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataPreferenceHeaderTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataPreferenceHeaderTests.cs
@@ -294,7 +294,7 @@ namespace Microsoft.OData.Tests
             const int MaxPageSize = 10;
             this.preferHeader.MaxPageSize = MaxPageSize;
             Assert.Equal(MaxPageSize, this.preferHeader.MaxPageSize);
-            Assert.Equal(string.Format("{0}={1}", MaxPageSizePreference, MaxPageSize), this.requestMessage.GetHeader(PreferHeaderName));
+            Assert.Equal($"{MaxPageSizePreference}={MaxPageSize}", this.requestMessage.GetHeader(PreferHeaderName));
         }
 
         [Fact]
@@ -308,7 +308,7 @@ namespace Microsoft.OData.Tests
         [Fact]
         public void ReturnMaxPageSizeOfBadIntergerFormatShouldThrow()
         {
-            this.requestMessage.SetHeader(PreferHeaderName, string.Format("{0}=abc", MaxPageSizePreference));
+            this.requestMessage.SetHeader(PreferHeaderName, $"{MaxPageSizePreference}=abc");
             this.preferHeader = new ODataPreferenceHeader(this.requestMessage);
             int? maxPageSize;
             Action test = () => maxPageSize = this.preferHeader.MaxPageSize;
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataReaderDerivedTypeConstraintTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataReaderDerivedTypeConstraintTests.cs
index 121a95f8f..ed67b4c89 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataReaderDerivedTypeConstraintTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ODataReaderDerivedTypeConstraintTests.cs
@@ -153,7 +153,7 @@ namespace Microsoft.OData.Tests
             Action<Stack<ODataItem>> verifyItems = (ms) =>
             {
                 Assert.NotNull(ms);
-                Assert.Equal(3, ms.Count());
+                Assert.Equal(3, ms.Count);
                 Assert.IsType<ODataResourceSet>(ms.Pop()); // toplevel resource set
                 ODataResource resource = Assert.IsType<ODataResource>(ms.Pop()); // second resource
                 Assert.Equal(17, resource.Properties.Single(c => c.Name == "Id").Value);
@@ -179,7 +179,7 @@ namespace Microsoft.OData.Tests
             Action<Stack<ODataItem>> verifyItems = (ms) =>
             {
                 Assert.NotNull(ms);
-                Assert.Equal(3, ms.Count());
+                Assert.Equal(3, ms.Count);
                 Assert.IsType<ODataResourceSet>(ms.Pop()); // toplevel resource set
                 ODataResource resource = Assert.IsType<ODataResource>(ms.Pop()); // second resource
                 Assert.Equal(17, resource.Properties.Single(c => c.Name == "Id").Value);
@@ -208,7 +208,7 @@ namespace Microsoft.OData.Tests
             // EntitySet doesn't have the derived type constraint.
             var items = ReadEntitySetPayload(payload, this.edmModel, this.edmCustomers, this.edmCustomerType);
             Assert.NotNull(items);
-            Assert.Equal(3, items.Count()); // entityset + 2 resources
+            Assert.Equal(3, items.Count); // entityset + 2 resources
 
             // Negative test case -- EntitySet has the derived type constraint.
             SetDerivedTypeAnnotation(this.edmModel, this.edmCustomers, "NS.NormalCustomer");
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/CustomInstanceAnnotationAcceptanceTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/CustomInstanceAnnotationAcceptanceTests.cs
index 4ebbfb9cb..695fc7001 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/CustomInstanceAnnotationAcceptanceTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/CustomInstanceAnnotationAcceptanceTests.cs
@@ -172,7 +172,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Reader
                             // TODO: We only support instance annotation at the top level feed at the moment. Will remove the if statement when support on inline feed is added.
                             if (odataItems.Count == 1)
                             {
-                                Assert.Equal(2, instanceAnnotations.Count());
+                                Assert.Equal(2, instanceAnnotations.Count);
                                 TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(1), instanceAnnotations.Single(ia => ia.Name == "Custom.ResourceSetStartAnnotation").Value);
                                 TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(1), instanceAnnotations.Single(ia => ia.Name == "Custom.FeedEndAnnotation").Value);
                             }
@@ -189,7 +189,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Reader
                             {
                                 // The collection should be populated with instance annotations read so far before the "ResourceSetNavigationProperty".
                                 instanceAnnotations = (odataItems.Peek() as ODataResource).InstanceAnnotations;
-                                Assert.Equal(2, instanceAnnotations.Count());
+                                Assert.Equal(2, instanceAnnotations.Count);
                                 TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(odataItems.Count), instanceAnnotations.Single(ia => ia.Name == "Custom.EntryStartAnnotation").Value);
                                 TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(odataItems.Count), instanceAnnotations.Single(ia => ia.Name == "Custom.EntryMiddleAnnotation").Value);
                             }
@@ -208,7 +208,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Reader
 
                         case ODataReaderState.ResourceEnd:
                             instanceAnnotations = (odataItems.Peek() as ODataResource).InstanceAnnotations;
-                            Assert.Equal(3, instanceAnnotations.Count());
+                            Assert.Equal(3, instanceAnnotations.Count);
                             TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(odataItems.Count), instanceAnnotations.Single(ia => ia.Name == "Custom.EntryStartAnnotation").Value);
                             TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(odataItems.Count), instanceAnnotations.Single(ia => ia.Name == "Custom.EntryMiddleAnnotation").Value);
                             TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(odataItems.Count), instanceAnnotations.Single(ia => ia.Name == "Custom.EntryEndAnnotation").Value);
@@ -217,7 +217,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Reader
                     }
                 }
 
-                Assert.Equal(2, instanceAnnotations.Count());
+                Assert.Equal(2, instanceAnnotations.Count);
                 TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(1), instanceAnnotations.Single(ia => ia.Name == "Custom.ResourceSetStartAnnotation").Value);
                 TestUtils.AssertODataValueAreEqual(new ODataPrimitiveValue(1), instanceAnnotations.Single(ia => ia.Name == "Custom.FeedEndAnnotation").Value);
             }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/DisablePrimitiveTypeConversionTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/DisablePrimitiveTypeConversionTests.cs
index 4d8783366..02d7b5caa 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/DisablePrimitiveTypeConversionTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/DisablePrimitiveTypeConversionTests.cs
@@ -87,7 +87,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Reader
                     ""{0}"": ""{1}""
                     {2}
                 }}";
-            return string.Format(format, propertyName, value, type == null ? null : string.Format(", \"{0}@odata.type\":\"#{1}\"", propertyName, type));
+            return string.Format(format, propertyName, value, type == null ? null : $", \"{propertyName}@odata.type\":\"#{type}\"");
         }
 
 
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/JsonLight/DateTimeReaderJsonLightTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/JsonLight/DateTimeReaderJsonLightTests.cs
index 81a8ca501..79d823a8a 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/JsonLight/DateTimeReaderJsonLightTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Reader/JsonLight/DateTimeReaderJsonLightTests.cs
@@ -89,9 +89,9 @@ namespace Microsoft.OData.Tests.ScenarioTests.Reader.JsonLight
             }
 
             Assert.Equal(expectedResult, actualValue);
-            if (actualValue is DateTime)
+            if (actualValue is DateTime dateTime)
             {
-                Assert.Equal(((DateTime)actualValue).Kind, ((DateTime)expectedResult).Kind);
+                Assert.Equal(dateTime.Kind, ((DateTime)expectedResult).Kind);
             }
         }
     }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/ContextUrlWriterReaderTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/ContextUrlWriterReaderTests.cs
index f6106002a..7820ba7f6 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/ContextUrlWriterReaderTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/ContextUrlWriterReaderTests.cs
@@ -280,7 +280,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     ODataServiceDocument serviceDocument = new ODataServiceDocument();
                     serviceDocument.EntitySets = new ODataEntitySetInfo[] { new ODataEntitySetInfo { Name = "People", Url = new Uri(TestBaseUri + "People") } };
                     omWriter.WriteServiceDocument(serviceDocument);
-                }, string.Format("\"{0}$metadata\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata\"", out payload, out contentType);
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadServiceDocument());
             }
         }
@@ -301,7 +301,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     feed.Id = new Uri("urn:test");
                     writer.WriteStart(feed);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#People\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#People\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -336,7 +336,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     feed.Id = new Uri("urn:test");
                     writer.WriteStart(feed);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#PeopleWorkingGroups/People\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#PeopleWorkingGroups/People\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -373,7 +373,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     var writer = omWriter.CreateODataResourceWriter(this.peopleSet, this.personType);
                     writer.WriteStart(entry);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#People/$entity\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#People/$entity\"", out payload, out contentType);
                 payload = payload.Replace(".People/$", ".Test/$");
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -433,7 +433,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteEnd(); // nestedInfo
                     writer.WriteEnd(); // resource
                     writer.WriteEnd(); // resource set
-                }, string.Format("\"{0}$metadata#Companys(1)/Locations\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#Companys(1)/Locations\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -460,7 +460,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     feed.Id = new Uri("urn:test");
                     writer.WriteStart(feed);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#PeopleWorkingGroups\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#PeopleWorkingGroups\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -488,7 +488,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(feed);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#People/{1}.Employee\"", TestBaseUri, TestNameSpace),
+                $"\"{TestBaseUri}$metadata#People/{TestNameSpace}.Employee\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -528,7 +528,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(entry);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#People/{1}.Employee/$entity\"", TestBaseUri, TestNameSpace),
+                $"\"{TestBaseUri}$metadata#People/{TestNameSpace}.Employee/$entity\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -564,7 +564,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     feed.Id = new Uri("urn:test");
                     writer.WriteStart(feed);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#People(PersonId,Name)", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#People(PersonId,Name)", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -600,7 +600,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(feed);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#People/{1}.Employee(PersonId,Name)\"", TestBaseUri, TestNameSpace),
+                $"\"{TestBaseUri}$metadata#People/{TestNameSpace}.Employee(PersonId,Name)\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -642,7 +642,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     var writer = omWriter.CreateODataResourceWriter(this.peopleSet, this.personType);
                     writer.WriteStart(entry);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#People(PersonId,Name)/$entity\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#People(PersonId,Name)/$entity\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -684,7 +684,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(entry);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#People/{1}.Employee(PersonId,Name)/$entity\"", TestBaseUri, TestNameSpace),
+                $"\"{TestBaseUri}$metadata#People/{TestNameSpace}.Employee(PersonId,Name)/$entity\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -721,7 +721,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(feed);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#Employees(AssociatedCompany(CompanyId))\"", TestBaseUri),
+                $"\"{TestBaseUri}$metadata#Employees(AssociatedCompany(CompanyId))\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -806,7 +806,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     feed.Id = new Uri("urn:test");
                     writer.WriteStart(feed);
                     writer.WriteEnd();
-                }, string.Format("\"{0}$metadata#Employees(AssociatedCompany())\"", TestBaseUri), out payload, out contentType);
+                }, $"\"{TestBaseUri}$metadata#Employees(AssociatedCompany())\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -851,7 +851,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(entry);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#Employees(AssociatedCompany(CompanyId))/$entity\"", TestBaseUri),
+                $"\"{TestBaseUri}$metadata#Employees(AssociatedCompany(CompanyId))/$entity\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -909,7 +909,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(entry);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#Employees(AssociatedCompany,AssociatedCompany())/$entity\"", TestBaseUri),
+                $"\"{TestBaseUri}$metadata#Employees(AssociatedCompany,AssociatedCompany())/$entity\"",
                 out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -984,7 +984,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 string payload, contentType;
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter => omWriter.WriteEntityReferenceLinks(referenceLinks),
-                    string.Format("\"{0}$metadata#Collection($ref)\"", TestBaseUri),
+                    $"\"{TestBaseUri}$metadata#Collection($ref)\"",
                     out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadEntityReferenceLinks());
@@ -1004,7 +1004,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 string payload, contentType;
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter => omWriter.WriteEntityReferenceLink(referenceLink),
-                    string.Format("\"{0}$metadata#$ref\"", TestBaseUri),
+                    $"\"{TestBaseUri}$metadata#$ref\"",
                     out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadEntityReferenceLink());
@@ -1031,7 +1031,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(property);
                     },
-                    string.Format("\"{0}$metadata#People(1)/Name\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/Name\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1057,7 +1057,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(this.CreateODataProperty(properties, "PhoneNumbers"));
                     },
-                    string.Format("\"{0}$metadata#People(1)/PhoneNumbers\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/PhoneNumbers\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1087,7 +1087,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         odataWriter.WriteStart(complexResource);
                         odataWriter.WriteEnd();
                     },
-                    string.Format("\"{0}$metadata#People(1)/HomeAddress\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/HomeAddress\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model,
                 omReader =>
@@ -1132,7 +1132,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         odataWriter.WriteEnd();
                         odataWriter.WriteEnd();
                     },
-                    string.Format("\"{0}$metadata#People(1)/Addresses\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/Addresses\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model,
                     omReader =>
@@ -1173,7 +1173,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(this.CreateODataProperty(AccessLevel.Read, "UserAccess"));
                     },
-                    string.Format("\"{0}$metadata#People(1)/UserAccess\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/UserAccess\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1200,7 +1200,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(this.CreateODataProperty(properties, "UserAccesses"));
                     },
-                    string.Format("\"{0}$metadata#People(1)/UserAccesses\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/UserAccesses\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1226,7 +1226,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         odataWriter.WriteEnd();
                         odataWriter.WriteEnd();
                     },
-                    string.Format("\"{0}$metadata#Collection({1}.Address)\"", TestBaseUri, TestNameSpace),
+                    $"\"{TestBaseUri}$metadata#Collection({TestNameSpace}.Address)\"",
                     out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -1258,7 +1258,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 string payload, contentType;
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter => omWriter.WriteProperty(this.CreateODataProperty(properties, "Test")),
-                    string.Format("\"{0}$metadata#Collection(Edm.String)\"", TestBaseUri),
+                    $"\"{TestBaseUri}$metadata#Collection(Edm.String)\"",
                     out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
@@ -1275,7 +1275,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 string payload, contentType;
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter => omWriter.WriteProperty(this.CreateODataProperty(new Collection<AccessLevel> { AccessLevel.Read }, "AccessLevel")),
-                    string.Format("\"{0}$metadata#Collection({1}.AccessLevel)\"", TestBaseUri, TestNameSpace),
+                    $"\"{TestBaseUri}$metadata#Collection({TestNameSpace}.AccessLevel)\"",
                     out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
@@ -1296,7 +1296,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     omWriter =>
                     {
                         ODataCollectionStart collectionStart = new ODataCollectionStart();
-                        collectionStart.SetSerializationInfo(new ODataCollectionStartSerializationInfo { CollectionTypeName = string.Format("Collection({0}.AccessLevel)", TestNameSpace) });
+                        collectionStart.SetSerializationInfo(new ODataCollectionStartSerializationInfo { CollectionTypeName = $"Collection({TestNameSpace}.AccessLevel)" });
                         ODataEnumValue[] items =
                         {
                             new ODataEnumValue(AccessLevel.Read.ToString(), TestNameSpace),
@@ -1312,7 +1312,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
 
                         collectionWriter.WriteEnd();
                     },
-                    string.Format("\"{0}$metadata#Collection({1}.AccessLevel)\"", TestBaseUri, TestNameSpace),
+                    $"\"{TestBaseUri}$metadata#Collection({TestNameSpace}.AccessLevel)\"",
                     out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
@@ -1349,7 +1349,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         odataWriter.WriteStart(complexResource);
                         odataWriter.WriteEnd();
                     },
-                    string.Format("\"{0}$metadata#{1}.Address\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#{TestNameSpace}.Address\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                     {
@@ -1376,7 +1376,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 string payload, contentType;
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter => omWriter.WriteProperty(property),
-                    string.Format("\"{0}$metadata#Edm.String\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#Edm.String\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1392,7 +1392,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 string payload, contentType;
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter => omWriter.WriteProperty(this.CreateODataProperty(AccessLevel.Read, "AccessLevel")),
-                    string.Format("\"{0}$metadata#{1}.AccessLevel\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#{TestNameSpace}.AccessLevel\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1416,7 +1416,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(this.CreateODataProperty(properties, "WorkNumbers"));
                     },
-                    string.Format("\"{0}$metadata#People(1)/{1}.Employee/WorkNumbers\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/{TestNameSpace}.Employee/WorkNumbers\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1432,7 +1432,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter =>
                     {
-                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + string.Format("People(1)/{0}.Employee/DateHired", TestNameSpace)));
+                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + $"People(1)/{TestNameSpace}.Employee/DateHired"));
                         omWriter.Settings.ODataUri = new ODataUri()
                         {
                             ServiceRoot = this.testServiceRootUri,
@@ -1440,7 +1440,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(property);
                     },
-                    string.Format("\"{0}$metadata#People(1)/{1}.Employee/DateHired\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/{TestNameSpace}.Employee/DateHired\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1462,7 +1462,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter =>
                     {
-                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + string.Format("Companys(1)/Division/Manufactory/ManufactoryAddress/{0}.FactoryAddress", TestNameSpace)));
+                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + $"Companys(1)/Division/Manufactory/ManufactoryAddress/{TestNameSpace}.FactoryAddress"));
                         omWriter.Settings.ODataUri = new ODataUri()
                         {
                             ServiceRoot = this.testServiceRootUri,
@@ -1474,7 +1474,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         odataWriter.WriteStart(complexResource);
                         odataWriter.WriteEnd();
                     },
-                    string.Format("\"{0}$metadata#Companys(1)/Division/Manufactory/ManufactoryAddress/{1}.FactoryAddress\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#Companys(1)/Division/Manufactory/ManufactoryAddress/{TestNameSpace}.FactoryAddress\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader =>
                 {
@@ -1502,7 +1502,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter =>
                     {
-                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + string.Format("Companys(1)/Division/Manufactory/ManufactoryAddress/{0}.FactoryAddress/FactoryType", TestNameSpace)));
+                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + $"Companys(1)/Division/Manufactory/ManufactoryAddress/{TestNameSpace}.FactoryAddress/FactoryType"));
                         omWriter.Settings.ODataUri = new ODataUri()
                         {
                             ServiceRoot = this.testServiceRootUri,
@@ -1510,7 +1510,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(property);
                     },
-                    string.Format("\"{0}$metadata#Companys(1)/Division/Manufactory/ManufactoryAddress/{1}.FactoryAddress/FactoryType\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#Companys(1)/Division/Manufactory/ManufactoryAddress/{TestNameSpace}.FactoryAddress/FactoryType\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1526,7 +1526,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter =>
                     {
-                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + string.Format("Companys(1)/Division/Manufactory/ManufactoryAddress/{0}.FactoryAddress/FactoryPhoneNumbers", TestNameSpace)));
+                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + $"Companys(1)/Division/Manufactory/ManufactoryAddress/{TestNameSpace}.FactoryAddress/FactoryPhoneNumbers"));
                         omWriter.Settings.ODataUri = new ODataUri()
                         {
                             ServiceRoot = this.testServiceRootUri,
@@ -1534,7 +1534,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(this.CreateODataProperty(properties, "FactoryPhoneNumbers"));
                     },
-                    string.Format("\"{0}$metadata#Companys(1)/Division/Manufactory/ManufactoryAddress/{1}.FactoryAddress/FactoryPhoneNumbers\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#Companys(1)/Division/Manufactory/ManufactoryAddress/{TestNameSpace}.FactoryAddress/FactoryPhoneNumbers\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1558,7 +1558,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                         };
                         omWriter.WriteProperty(property);
                     },
-                    string.Format("\"{0}$metadata#Companys(1)/Division/Manufactory/Name\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#Companys(1)/Division/Manufactory/Name\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1583,7 +1583,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
 
                         omWriter.WriteProperty(this.CreateODataProperty(properties, "Numbers"));
                     },
-                    string.Format("\"{0}$metadata#Companys(1)/Division/Manufactory/Numbers\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#Companys(1)/Division/Manufactory/Numbers\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1599,7 +1599,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                 this.WriteAndValidateContextUri(mimeType, model,
                     omWriter =>
                     {
-                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + string.Format("People(1)/{0}.Employee/OpenType", TestNameSpace)));
+                        var odataUriParser = new ODataUriParser(this.model, this.testServiceRootUri, new Uri(TestBaseUri + $"People(1)/{TestNameSpace}.Employee/OpenType"));
                         omWriter.Settings.ODataUri = new ODataUri()
                         {
                             ServiceRoot = this.testServiceRootUri,
@@ -1608,7 +1608,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
 
                         omWriter.WriteProperty(property);
                     },
-                    string.Format("\"{0}$metadata#People(1)/{1}.Employee/OpenType\"", TestBaseUri, TestNameSpace), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/{TestNameSpace}.Employee/OpenType\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1633,7 +1633,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
 
                         omWriter.WriteProperty(property);
                     },
-                    string.Format("\"{0}$metadata#People(1)/OpenType\"", TestBaseUri), out payload, out contentType);
+                    $"\"{TestBaseUri}$metadata#People(1)/OpenType\"", out payload, out contentType);
 
                 this.ReadPayload(payload, contentType, model, omReader => omReader.ReadProperty());
             }
@@ -1655,7 +1655,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip
                     writer.WriteStart(feed);
                     writer.WriteEnd();
                 },
-                string.Format("\"{0}$metadata#People/{1}.Employee\"", TestBaseUri, TestNameSpace),
+                $"\"{TestBaseUri}$metadata#People/{TestNameSpace}.Employee\"",
                 out payload, out contentType);
 
                 payload = payload.Replace("$metadata#People/Microsoft.OData.Tests.Employee", "WrongURL");
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/CustomInstanceAnnotationRoundtripJsonLightTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/CustomInstanceAnnotationRoundtripJsonLightTests.cs
index 9100caa7f..d33c4ce2c 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/CustomInstanceAnnotationRoundtripJsonLightTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/CustomInstanceAnnotationRoundtripJsonLightTests.cs
@@ -139,7 +139,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip.JsonLight
             var instanceAnnotations = error.InstanceAnnotations;
             Assert.NotNull(instanceAnnotations);
             Assert.NotEmpty(instanceAnnotations);
-            var annotation = instanceAnnotations.Where(instanceAnnotation => instanceAnnotation.Name.Equals(name)).FirstOrDefault();
+            var annotation = instanceAnnotations.FirstOrDefault(instanceAnnotation => instanceAnnotation.Name.Equals(name));
             Assert.NotNull(annotation);
             return annotation.Value;
         }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/MultipartMixedBatchDependsOnIdsTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/MultipartMixedBatchDependsOnIdsTests.cs
index 019de144f..b7fbc54d3 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/MultipartMixedBatchDependsOnIdsTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/MultipartMixedBatchDependsOnIdsTests.cs
@@ -315,7 +315,7 @@ Content-Type: application/json;odata.metadata=minimal;odata.streaming=true;IEEE7
                                 {
                                     case "1":
                                     case "2A":
-                                        Assert.True(dependsOnIds.Count() == 0);
+                                        Assert.True(!dependsOnIds.Any());
                                         break;
 
                                     case "2B":
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/PrimitiveValuesRoundtripJsonLightTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/PrimitiveValuesRoundtripJsonLightTests.cs
index ee3409edf..a97485c3b 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/PrimitiveValuesRoundtripJsonLightTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Roundtrip/JsonLight/PrimitiveValuesRoundtripJsonLightTests.cs
@@ -711,9 +711,9 @@ namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip.JsonLight
         {
             var actualValue = this.WriteThenReadValue(clrValue, typeReference, version, isIeee754Compatible);
 
-            if (clrValue != null && clrValue is byte[])
+            if (clrValue is byte[])
             {
-                if (actualValue != null && actualValue is byte[])
+                if (actualValue is byte[])
                 {
                     Assert.NotEqual((byte[])actualValue, (byte[])clrValue);
                 }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Streaming/ODataJsonLightStreamReadingTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Streaming/ODataJsonLightStreamReadingTests.cs
index d01bb2143..8f64e0185 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Streaming/ODataJsonLightStreamReadingTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/Streaming/ODataJsonLightStreamReadingTests.cs
@@ -51,7 +51,7 @@ namespace Microsoft.OData.Tests.JsonLight
                 var comments = resource.Properties.FirstOrDefault(p => p.Name == "comments").ODataValue as ODataCollectionValue;
                 Assert.NotNull(comments);
                 List<object> collection = comments.Items.ToList();
-                Assert.Equal(3, collection.Count());
+                Assert.Equal(3, collection.Count);
                 Assert.Equal("one", collection[0]);
                 Assert.Equal("two", collection[1]);
                 Assert.Null(collection[2]);
@@ -360,7 +360,7 @@ namespace Microsoft.OData.Tests.JsonLight
                 Assert.Single(propertyValues);
                 Assert.Equal("Thor", propertyValues[0]);
                 List<object> collection = comments.Items.ToList();
-                Assert.Equal(3, collection.Count());
+                Assert.Equal(3, collection.Count);
                 Assert.Equal("one", collection[0]);
                 Assert.Equal("two", collection[1]);
                 Assert.Null(collection[2]);
@@ -1233,11 +1233,7 @@ namespace Microsoft.OData.Tests.JsonLight
                         {
                             variants.Add(new Variant
                             {
-                                Description = String.Format("ODataVersion={0}, MetadataLevel={1}, isRequest={2}, Streaming={3}",
-                                    version.ToString(),
-                                    level.ToString(),
-                                    isRequest ? "true" : "false",
-                                    isStreaming ? "true" : "false"),
+                                Description = $"ODataVersion={version.ToString()}, MetadataLevel={level.ToString()}, isRequest={(isRequest ? "true" : "false")}, Streaming={(isStreaming ? "true" : "false")}",
                                 MetadataLevel = level,
                                 Settings = new ODataMessageReaderSettings
                                 {
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SelectExpandFunctionalTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SelectExpandFunctionalTests.cs
index 0c2b05183..fab893f82 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SelectExpandFunctionalTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SelectExpandFunctionalTests.cs
@@ -896,7 +896,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.UriParser
                                                               HardCodedTestModel.GetPeopleSet());
 
             var items = results.SelectedItems.ToList();
-            Assert.Equal(4, items.Count());
+            Assert.Equal(4, items.Count);
             Assert.False(results.AllSelected);
 
             SelectExpandClause myDog = items[0].ShouldBeExpansionFor(HardCodedTestModel.GetPersonMyDogNavProp()).SelectAndExpand;
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SemanticTreeFunctionalTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SemanticTreeFunctionalTests.cs
index 0d1d49e74..51d497226 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SemanticTreeFunctionalTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ScenarioTests/UriParser/SemanticTreeFunctionalTests.cs
@@ -429,7 +429,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.UriParser
                 sb.Append("not ");
             }
 
-            var uri = string.Format("People?$filter={0}true", sb.ToString());
+            var uri = $"People?$filter={sb.ToString()}true";
 
             var semanticTree = HardCodedTestModel.ParseUri(uri, this.edmModel);
 
@@ -464,7 +464,7 @@ namespace Microsoft.OData.Tests.ScenarioTests.UriParser
                 sb.Append(")");
             }
 
-            var uri = string.Format("People?$filter={0} eq 'ShoeBrand'", sb.ToString());
+            var uri = $"People?$filter={sb.ToString()} eq 'ShoeBrand'";
             var semanticTree = HardCodedTestModel.ParseUri(uri, this.edmModel, 4000);
 
             var personType = this.edmModel.FindType("Fully.Qualified.Namespace.Person");
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/SelectedPropertiesNodeTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/SelectedPropertiesNodeTests.cs
index 9d3bf4aef..532b640cd 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/SelectedPropertiesNodeTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/SelectedPropertiesNodeTests.cs
@@ -631,7 +631,7 @@ namespace Microsoft.OData.Tests.Evaluation
         internal static SelectedPropertiesNode HaveStreams(this SelectedPropertiesNode node, IEdmEntityType entityType, params string[] streamPropertyNames)
         {
             var keys = node.GetSelectedStreamProperties(entityType).Keys;
-            Assert.Equal(keys.Count(), streamPropertyNames.Length);
+            Assert.Equal(keys.Count, streamPropertyNames.Length);
             foreach (var keyStr in keys)
             {
                 Assert.Contains(keyStr, streamPropertyNames);
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Binders/SelectBinderTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Binders/SelectBinderTests.cs
index c88996c73..d4c5bfcec 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Binders/SelectBinderTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Binders/SelectBinderTests.cs
@@ -162,8 +162,7 @@ namespace Microsoft.OData.Tests.UriParser.Binders
             Assert.Contains(pathSelectItems, (x) => x.SelectedPath.Equals(stuffPath));
             Assert.Contains(pathSelectItems, (x) =>
             {
-                NavigationPropertySegment segment = x.SelectedPath.LastSegment as NavigationPropertySegment;
-                if (segment != null)
+                if (x.SelectedPath.LastSegment is NavigationPropertySegment segment)
                 {
                     return segment.NavigationProperty.Name == "Owner";
                 }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/PathSegmentTokenExtensions.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/PathSegmentTokenExtensions.cs
index b91a2966e..04b336141 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/PathSegmentTokenExtensions.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/PathSegmentTokenExtensions.cs
@@ -29,7 +29,7 @@ namespace Microsoft.OData.Tests.UriParser
                 sb.Append(curr.Identifier);
 
                 NonSystemToken nonSystem = curr as NonSystemToken;
-                if (nonSystem != null && nonSystem.NamedValues != null)
+                if (nonSystem?.NamedValues != null)
                 {
                     sb.Append("(");
                     sb.Append(string.Join(",", nonSystem.NamedValues.Select(c => c.Name + "=" + c.Value.Value)));
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/SelectExpandTokenSyntacticTreeVisitor.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/SelectExpandTokenSyntacticTreeVisitor.cs
index d61dab892..742899374 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/SelectExpandTokenSyntacticTreeVisitor.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Extensions/SelectExpandTokenSyntacticTreeVisitor.cs
@@ -194,9 +194,7 @@ namespace Microsoft.OData.Tests.UriParser
                 firstInnerOptionsAdded = true;
             }
 
-            ExpandTermToken expandTerm = term as ExpandTermToken;
-
-            if (expandTerm != null)
+            if (term is ExpandTermToken expandTerm)
             {
                 if (expandTerm.ExpandOption != null)
                 {
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Metadata/ODataUriResolverTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Metadata/ODataUriResolverTests.cs
index 5c9ded4cf..abcf49d6c 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Metadata/ODataUriResolverTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Metadata/ODataUriResolverTests.cs
@@ -126,8 +126,7 @@ namespace Microsoft.OData.Tests.UriParser.Metadata
                 {
                     if (leftNode.TypeReference.IsDateTimeOffset() && rightNode.TypeReference.IsInt32())
                     {
-                        var constNode = rightNode as ConstantNode;
-                        if (constNode != null)
+                        if (rightNode is ConstantNode constNode)
                         {
                             typeReference = EdmCoreModel.Instance.GetBinary(true);
                             rightNode = new ConstantNode(constNode.Value.ToString());
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/ODataUriParserTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/ODataUriParserTests.cs
index b3af6864a..c7083627d 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/ODataUriParserTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/ODataUriParserTests.cs
@@ -951,7 +951,7 @@ namespace Microsoft.OData.Tests.UriParser
             // parse and validate
             ComputeClause clause = parser.ParseCompute();
             List<ComputeExpression> items = clause.ComputedItems.ToList();
-            Assert.Equal(2, items.Count());
+            Assert.Equal(2, items.Count);
             Assert.Equal("Property1AsString", items[0].Alias);
             items[0].Expression.ShouldBeSingleValueFunctionCallQueryNode();
             Assert.True(items[0].Expression.TypeReference.IsEquivalentTo(typeReference));
@@ -1047,7 +1047,7 @@ namespace Microsoft.OData.Tests.UriParser
 
             // validate top compute
             List<ComputeExpression> items = computeClause.ComputedItems.ToList();
-            Assert.Equal(2, items.Count());
+            Assert.Equal(2, items.Count);
             Assert.Equal("Property1AsString", items[0].Alias);
             items[0].Expression.ShouldBeSingleValueFunctionCallQueryNode();
             Assert.True(items[0].Expression.TypeReference.IsEquivalentTo(typeReference));
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralParserTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralParserTests.cs
index 2b1129b2b..ebb743323 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralParserTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralParserTests.cs
@@ -680,7 +680,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
             {
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(customStringLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq '{0}'", CUSTOM_PARSER_STRING_VALID_VALUE));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq '{CUSTOM_PARSER_STRING_VALID_VALUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 parser.ParseFilter().Expression.ShouldBeBinaryOperatorNode(BinaryOperatorKind.Equal)
@@ -701,7 +701,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
             {
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(EdmCoreModel.Instance.GetString(true), customStringLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq '{0}'", CUSTOM_PARSER_STRING_VALID_VALUE));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq '{CUSTOM_PARSER_STRING_VALID_VALUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 parser.ParseFilter().Expression.ShouldBeBinaryOperatorNode(BinaryOperatorKind.Equal)
@@ -722,7 +722,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
             {
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(customStringLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq '{0}'", CUSTOM_PARSER_STRING_VALUE_CAUSEBUG));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq '{CUSTOM_PARSER_STRING_VALUE_CAUSEBUG}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 Action parseUriAction = () =>
@@ -746,7 +746,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
             {
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(EdmCoreModel.Instance.GetString(true), customStringLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq '{0}'", CUSTOM_PARSER_STRING_VALUE_CAUSEBUG));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq '{CUSTOM_PARSER_STRING_VALUE_CAUSEBUG}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 Action parseUriAction = () =>
@@ -774,7 +774,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
             {
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(EdmCoreModel.Instance.GetString(true), customStringLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq '{0}'", CUSTOM_PARSER_STRING_VALUE_CAUSEBUG));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq '{CUSTOM_PARSER_STRING_VALUE_CAUSEBUG}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 Action parseUriAction = () =>
@@ -809,7 +809,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
                 CustomUriLiteralPrefixes.AddCustomLiteralPrefix(HEARTBEAT_LITERAL_PREFIX, heartbeatTypeReference);
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(heartbeatTypeReference, customHeartbeatUriTypePraser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/Lions" + string.Format("?$filter=LionHeartbeat eq {0}'55.9'", HEARTBEAT_LITERAL_PREFIX));
+                var fullUri = new Uri("http://www.odata.com/OData/Lions" + $"?$filter=LionHeartbeat eq {HEARTBEAT_LITERAL_PREFIX}'55.9'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 HeatBeatCustomUriLiteralParser.HeatBeat heartbeatValue = Assert.IsType<HeatBeatCustomUriLiteralParser.HeatBeat>(
@@ -837,7 +837,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
                 CustomUriLiteralPrefixes.AddCustomLiteralPrefix(STRING_LITERAL_PREFIX, stringTypeReference);
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(stringTypeReference, customstringUriTypePraser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq {0}'{1}'", STRING_LITERAL_PREFIX, CUSTOM_PARSER_STRING_VALID_VALUE));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq {STRING_LITERAL_PREFIX}'{CUSTOM_PARSER_STRING_VALID_VALUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 parser.ParseFilter().Expression.ShouldBeBinaryOperatorNode(BinaryOperatorKind.Equal)
@@ -862,7 +862,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
                 CustomUriLiteralPrefixes.AddCustomLiteralPrefix(BOOLEAN_LITERAL_PREFIX, booleanTypeReference);
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(customBooleanAndIntUriLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/Chimeras" + string.Format("?$filter=Upgraded eq {0}'{1}'", BOOLEAN_LITERAL_PREFIX, CUSTOM_PARSER_BOOLEAN_VALID_VALUE_TRUE));
+                var fullUri = new Uri("http://www.odata.com/OData/Chimeras" + $"?$filter=Upgraded eq {BOOLEAN_LITERAL_PREFIX}'{CUSTOM_PARSER_BOOLEAN_VALID_VALUE_TRUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 parser.ParseFilter().Expression.ShouldBeBinaryOperatorNode(BinaryOperatorKind.Equal)
@@ -886,7 +886,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
                 CustomUriLiteralPrefixes.AddCustomLiteralPrefix(CustomUriLiteralParserUnitTests.BOOLEAN_LITERAL_PREFIX, booleanTypeReference);
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(booleanTypeReference, customBooleanUriLiteralParser);
 
-                var fullUri = new Uri("http://www.odata.com/OData/Chimeras" + string.Format("?$filter=Upgraded eq {0}'{1}'", CustomUriLiteralParserUnitTests.BOOLEAN_LITERAL_PREFIX, CustomUriLiteralParserUnitTests.CUSTOM_PARSER_BOOLEAN_VALID_VALUE_TRUE));
+                var fullUri = new Uri("http://www.odata.com/OData/Chimeras" + $"?$filter=Upgraded eq {CustomUriLiteralParserUnitTests.BOOLEAN_LITERAL_PREFIX}'{CustomUriLiteralParserUnitTests.CUSTOM_PARSER_BOOLEAN_VALID_VALUE_TRUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri) { Resolver = new ODataUriResolver() { EnableCaseInsensitive = false } };
 
                 parser.ParseFilter().Expression.ShouldBeBinaryOperatorNode(BinaryOperatorKind.Equal)
@@ -913,7 +913,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
                 CustomUriLiteralParsers.AddCustomUriLiteralParser(stringTypeReference, customstringUriTypePraser);
 
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq {0}'{1}'", LITERAL_PREFIX, CUSTOM_PARSER_STRING_VALID_VALUE));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq {LITERAL_PREFIX}'{CUSTOM_PARSER_STRING_VALID_VALUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 parser.ParseFilter().Expression.ShouldBeBinaryOperatorNode(BinaryOperatorKind.Equal)
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralPrefixesTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralPrefixesTests.cs
index 3a8785762..abbc84416 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralPrefixesTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/Parsers/CustomUriLiteralPrefixesTests.cs
@@ -293,7 +293,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
                 IEdmTypeReference stringTypeReference = EdmCoreModel.Instance.GetString(true);
                 CustomUriLiteralPrefixes.AddCustomLiteralPrefix(STRING_LITERAL_PREFIX, stringTypeReference);
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq {0}'{1}'", STRING_LITERAL_PREFIX, CustomUriLiteralParserUnitTests.CUSTOM_PARSER_STRING_VALID_VALUE));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq {STRING_LITERAL_PREFIX}'{CustomUriLiteralParserUnitTests.CUSTOM_PARSER_STRING_VALID_VALUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 Action parsingFilter = () => parser.ParseFilter();
@@ -333,7 +333,7 @@ namespace Microsoft.OData.Tests.UriParser.Parsers
             {
 
 
-                var fullUri = new Uri("http://www.odata.com/OData/People" + string.Format("?$filter=Name eq {0}'{1}'", CustomUriLiteralParserUnitTests.BOOLEAN_LITERAL_PREFIX, CustomUriLiteralParserUnitTests.CUSTOM_PARSER_STRING_VALID_VALUE));
+                var fullUri = new Uri("http://www.odata.com/OData/People" + $"?$filter=Name eq {CustomUriLiteralParserUnitTests.BOOLEAN_LITERAL_PREFIX}'{CustomUriLiteralParserUnitTests.CUSTOM_PARSER_STRING_VALID_VALUE}'");
                 ODataUriParser parser = new ODataUriParser(HardCodedTestModel.TestModel, new Uri("http://www.odata.com/OData/"), fullUri);
 
                 Action parsingFilterAction = () =>
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/SemanticAst/ODataPathExtensionsTests.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/SemanticAst/ODataPathExtensionsTests.cs
index 0f7ea4924..450a468b2 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/SemanticAst/ODataPathExtensionsTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/UriParser/SemanticAst/ODataPathExtensionsTests.cs
@@ -313,14 +313,14 @@ namespace Microsoft.OData.Tests.UriParser.SemanticAst
             {
                 ODataPath path = new ODataUriParser(HardCodedTestModel.TestModel, this.testBaseUri, new Uri(this.testBaseUri, testCase)).ParsePath();
                 bool result = path.IsIndividualProperty();
-                Assert.True(result, string.Format("Resource path \"{0}\" should target at individual property", testCase));
+                Assert.True(result, $"Resource path \"{testCase}\" should target at individual property");
             }
 
             foreach (var testCase in falseCases)
             {
                 ODataPath path = new ODataUriParser(HardCodedTestModel.TestModel, this.testBaseUri, new Uri(this.testBaseUri, testCase)).ParsePath();
                 bool result = path.IsIndividualProperty();
-                Assert.False(result, string.Format("Resource path \"{0}\" should not target at individual property", testCase));
+                Assert.False(result, $"Resource path \"{testCase}\" should not target at individual property");
             }
         }
     }
diff --git a/test/FunctionalTests/Microsoft.OData.Core.Tests/ValidationHelper.cs b/test/FunctionalTests/Microsoft.OData.Core.Tests/ValidationHelper.cs
index 9aaa936fd..07937c0ee 100644
--- a/test/FunctionalTests/Microsoft.OData.Core.Tests/ValidationHelper.cs
+++ b/test/FunctionalTests/Microsoft.OData.Core.Tests/ValidationHelper.cs
@@ -50,7 +50,7 @@ namespace Microsoft.OData.Tests
 
             if (obj == null || copy == null)
             {
-                diff.Add(string.Format("Value of{0} {1} does not match", collectionStatement, objName));
+                diff.Add($"Value of{collectionStatement} {objName} does not match");
                 return;
             }
 
@@ -60,14 +60,14 @@ namespace Microsoft.OData.Tests
             {
                 if (Uri.Compare(new Uri(obj.ToString()), new Uri(copy.ToString()), UriComponents.AbsoluteUri, UriFormat.Unescaped, StringComparison.CurrentCulture) != 0)
                 {
-                    diff.Add(string.Format("Value of Uri{0} {1} does not match.", collectionStatement,objName));
+                    diff.Add($"Value of Uri{collectionStatement} {objName} does not match.");
                 }
             }
             else if (typeof(IComparable).IsAssignableFrom(objType) || objType.IsPrimitive() || objType.IsValueType())
             {
                 if ((!obj.Equals(copy)))
                 {
-                    diff.Add(string.Format("Value of{0} {1} does not match.",collectionStatement, objName));
+                    diff.Add($"Value of{collectionStatement} {objName} does not match.");
                 }
             }
             else if (objType.IsArray || typeof(IEnumerable).IsAssignableFrom(objType))
@@ -77,7 +77,7 @@ namespace Microsoft.OData.Tests
 
                 if (collection1.Count() != collection2.Count())
                 {
-                    diff.Add(string.Format("Collection count of {0} does not match.", objName));
+                    diff.Add($"Collection count of {objName} does not match.");
                 }
                 else
                 {
diff --git a/test/FunctionalTests/Microsoft.OData.Edm.Tests/Csdl/CsdlReaderTests.cs b/test/FunctionalTests/Microsoft.OData.Edm.Tests/Csdl/CsdlReaderTests.cs
index 0929070d6..cc9982f62 100644
--- a/test/FunctionalTests/Microsoft.OData.Edm.Tests/Csdl/CsdlReaderTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Edm.Tests/Csdl/CsdlReaderTests.cs
@@ -194,11 +194,11 @@ namespace Microsoft.OData.Edm.Tests.Csdl
             Assert.True(target is IEdmContainedEntitySet);
             Assert.Equal("SetB", target.Name);
             var targetSegments = target.Path.PathSegments.ToList();
-            Assert.Equal(2, targetSegments.Count());
+            Assert.Equal(2, targetSegments.Count);
             Assert.Equal("Root", targetSegments[0]);
             Assert.Equal("SetB", targetSegments[1]);
             var pathSegments = setA.NavigationPropertyBindings.First().Path.PathSegments.ToList();
-            Assert.Equal(2, pathSegments.Count());
+            Assert.Equal(2, pathSegments.Count);
             Assert.Equal("EntityA", pathSegments[0]);
             Assert.Equal("EntityAToB", pathSegments[1]);
         }
@@ -305,11 +305,11 @@ namespace Microsoft.OData.Edm.Tests.Csdl
             Assert.True(target is IEdmContainedEntitySet);
             Assert.Equal("users", target.Name);
             var targetSegments = target.Path.PathSegments.ToList();
-            Assert.Equal(2, targetSegments.Count());
+            Assert.Equal(2, targetSegments.Count);
             Assert.Equal("education", targetSegments[0]);
             Assert.Equal("users", targetSegments[1]);
             var pathSegments = navPropBinding.Path.PathSegments.ToList();
-            Assert.Equal(2, pathSegments.Count());
+            Assert.Equal(2, pathSegments.Count);
             Assert.Equal("classes", pathSegments[0]);
             Assert.Equal("members", pathSegments[1]);
         }
@@ -492,13 +492,13 @@ namespace Microsoft.OData.Edm.Tests.Csdl
             var model = CsdlReader.Parse(XElement.Parse(csdl).CreateReader());
             var function = model.FindDeclaredOperations("test.TestFunction").FirstOrDefault();
             Assert.NotNull(function);
-            var requiredParam = function.Parameters.Where(p => p.Name == "requiredParam").FirstOrDefault();
+            var requiredParam = function.Parameters.FirstOrDefault(p => p.Name == "requiredParam");
             Assert.NotNull(requiredParam);
             Assert.Null(requiredParam as IEdmOptionalParameter);
-            IEdmOptionalParameter optionalParam = function.Parameters.Where(p => p.Name == "optionalParam").FirstOrDefault() as IEdmOptionalParameter;
+            IEdmOptionalParameter optionalParam = function.Parameters.FirstOrDefault(p => p.Name == "optionalParam")as IEdmOptionalParameter;
             Assert.NotNull(optionalParam);
             Assert.True(String.IsNullOrEmpty(optionalParam.DefaultValueString));
-            IEdmOptionalParameter optionalParamWithDefault = function.Parameters.Where(p => p.Name == "optionalParamWithDefault").FirstOrDefault() as IEdmOptionalParameter;
+            IEdmOptionalParameter optionalParamWithDefault = function.Parameters.FirstOrDefault(p => p.Name == "optionalParamWithDefault")as IEdmOptionalParameter;
             Assert.NotNull(optionalParamWithDefault);
             Assert.Equal("Smith", optionalParamWithDefault.DefaultValueString);
         }
@@ -795,7 +795,7 @@ namespace Microsoft.OData.Edm.Tests.Csdl
             Assert.NotNull(model);
 
             IEnumerable<EdmError> errors;
-            Assert.True(model.Validate(out errors), String.Format("Errors in validating model. {0}", String.Concat(errors.Select(e => e.ErrorMessage))));
+            Assert.True(model.Validate(out errors), $"Errors in validating model. {String.Concat(errors.Select(e => e.ErrorMessage))}");
 
             var color = model.SchemaElements.OfType<IEdmEnumType>().FirstOrDefault(c => c.Name == "Color");
             Assert.NotNull(color);
@@ -828,9 +828,8 @@ namespace Microsoft.OData.Edm.Tests.Csdl
             if (annotation != null)
             {
                 Assert.True(annotation.GetSerializationLocation(model) == location);
-
-                IEdmStringConstantExpression stringConstant = annotation.Value as IEdmStringConstantExpression;
-                if (stringConstant != null)
+
+                if (annotation.Value is IEdmStringConstantExpression stringConstant)
                 {
                     return stringConstant.Value;
                 }
diff --git a/test/FunctionalTests/Microsoft.OData.Edm.Tests/ExtensionMethods/ExtensionMethodTests.cs b/test/FunctionalTests/Microsoft.OData.Edm.Tests/ExtensionMethods/ExtensionMethodTests.cs
index 3452c285e..2064bfc1e 100644
--- a/test/FunctionalTests/Microsoft.OData.Edm.Tests/ExtensionMethods/ExtensionMethodTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Edm.Tests/ExtensionMethods/ExtensionMethodTests.cs
@@ -115,7 +115,7 @@ namespace Microsoft.OData.Edm.Tests.ExtensionMethods
         [Fact]
         public void ShortQualifiedNameForNonPrimitiveTypeShouldBeFullName()
         {
-            string stringOfExpectedShortQualifiedName = String.Format("{0}.{1}", DefaultNamespace, DefaultName);
+            string stringOfExpectedShortQualifiedName = $"{DefaultNamespace}.{DefaultName}";
 
             var stringOfObservedShortQualifiedName = edmComplexType.ShortQualifiedName();
             Assert.Equal(stringOfExpectedShortQualifiedName, stringOfObservedShortQualifiedName);
@@ -1102,14 +1102,12 @@ namespace Microsoft.OData.Edm.Tests.ExtensionMethods
 
         internal static bool HasAnyExpensive<T>(IEnumerable<T> enumerable) where T : class
         {
-            IList<T> list = enumerable as IList<T>;
-            if (list != null)
+            if (enumerable is IList<T> list)
             {
                 return list.Count > 0;
             }
-
-            T[] array = enumerable as T[];
-            if (array != null)
+
+            if (enumerable is T[] array)
             {
                 return array.Length > 0;
             }
diff --git a/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisActionsFunctionsRelationshipChangesAcceptanceTests.cs b/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisActionsFunctionsRelationshipChangesAcceptanceTests.cs
index 3d6cfe894..d781ccae5 100644
--- a/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisActionsFunctionsRelationshipChangesAcceptanceTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisActionsFunctionsRelationshipChangesAcceptanceTests.cs
@@ -210,7 +210,7 @@ namespace Microsoft.OData.Edm.Tests.ScenarioTests
 
             var edmModel = CsdlReader.Parse(XElement.Parse(testCsdl).CreateReader());
             var operations = edmModel.SchemaElements.OfType<IEdmOperation>().ToList();
-            Assert.Equal(6, operations.Count());
+            Assert.Equal(6, operations.Count);
             var container = edmModel.EntityContainer;
             var operationImports = container.OperationImports().ToList();
 
@@ -270,7 +270,7 @@ namespace Microsoft.OData.Edm.Tests.ScenarioTests
 
             var edmModel = CsdlReader.Parse(XElement.Parse(testCsdl).CreateReader());
             var operations = edmModel.SchemaElements.OfType<IEdmOperation>().ToList();
-            Assert.Equal(8, operations.Count());
+            Assert.Equal(8, operations.Count);
 
             // Functions
             Assert.True(operations[0] is IEdmFunction);
diff --git a/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisRelationshipChangesAcceptanceTests.cs b/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisRelationshipChangesAcceptanceTests.cs
index 9a5109cf0..17734aa69 100644
--- a/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisRelationshipChangesAcceptanceTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Edm.Tests/ScenarioTests/OasisRelationshipChangesAcceptanceTests.cs
@@ -471,7 +471,7 @@ namespace Microsoft.OData.Edm.Tests.ScenarioTests
                 new[]
                 {
                     ErrorStrings.Bad_UnresolvedNavigationPropertyPath("Nonexistent", "Test.EntityType"),
-                    string.Format("Cannot resolve partner path for navigation property '{0}'.", "Navigation")
+                    $"Cannot resolve partner path for navigation property '{"Navigation"}'."
                 });
         }
 
diff --git a/test/FunctionalTests/Microsoft.OData.Edm.Tests/Vocabularies/CapabilitiesVocabularyTests.cs b/test/FunctionalTests/Microsoft.OData.Edm.Tests/Vocabularies/CapabilitiesVocabularyTests.cs
index 3766a956b..cf8bef76b 100644
--- a/test/FunctionalTests/Microsoft.OData.Edm.Tests/Vocabularies/CapabilitiesVocabularyTests.cs
+++ b/test/FunctionalTests/Microsoft.OData.Edm.Tests/Vocabularies/CapabilitiesVocabularyTests.cs
@@ -799,7 +799,7 @@ namespace Microsoft.OData.Edm.Tests.Vocabularies
             Assert.NotNull(supportedFormats);
 
             var annotations = this.capVocModel.FindDeclaredVocabularyAnnotations(supportedFormats).ToList();
-            Assert.Equal(2, annotations.Count());
+            Assert.Equal(2, annotations.Count);
 
             // Core.Description
             var description = annotations.SingleOrDefault(a => a.Term is CsdlSemanticsTerm && a.Term.Name == "Description");
diff --git a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/EdmToStockModelConverter.cs b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/EdmToStockModelConverter.cs
index 51673b355..2e18990bb 100644
--- a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/EdmToStockModelConverter.cs
+++ b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/EdmToStockModelConverter.cs
@@ -1,4 +1,5 @@
-﻿//---------------------------------------------------------------------
+﻿using System.Linq;
+//---------------------------------------------------------------------
 // <copyright file="EdmToStockModelConverter.cs" company="Microsoft">
 //      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
 // </copyright>
@@ -232,8 +233,8 @@ namespace Microsoft.Test.OData.Utils.Metadata
             foreach (var edmOperation in edmModel.SchemaElements.OfType<IEdmOperation>())
             {
                 EdmOperation stockOperation = null;                
-                var edmAction = edmOperation as IEdmAction;
-                if (edmAction != null)
+
+                if (edmOperation is IEdmAction edmAction)
                 {
                     stockOperation = new EdmAction(
                         edmAction.Namespace,
@@ -414,9 +415,8 @@ namespace Microsoft.Test.OData.Utils.Metadata
             foreach (var edmOperationImport in edmContainer.OperationImports())
             {
                 EdmOperationImport stockEdmOperationImport = null;
-                var edmActionImport = edmOperationImport as IEdmActionImport;
 
-                if (edmActionImport != null)
+                if (edmOperationImport is IEdmActionImport edmActionImport)
                 {
                     var newEdmAction = stockModel.FindDeclaredOperations(edmActionImport.Action.FullName()).OfType<IEdmAction>().FirstOrDefault() as EdmAction;
                     ExceptionUtilities.CheckObjectNotNull(newEdmAction, "cannot find action");
@@ -450,7 +450,7 @@ namespace Microsoft.Test.OData.Utils.Metadata
             var toBeDerivedTypes = new List<IEdmEntityType> { entityType };
             var derivedTypes = new List<IEdmEntityType>();
 
-            while (toBeDerivedTypes.Count() > 0)
+            while (toBeDerivedTypes.Any())
             {
                 foreach (var deriveTypes in toBeDerivedTypes)
                 {
diff --git a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataExtensionMethods.cs b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataExtensionMethods.cs
index e5e52c552..04a5423dc 100644
--- a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataExtensionMethods.cs
+++ b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataExtensionMethods.cs
@@ -272,18 +272,15 @@ namespace Microsoft.Test.OData.Utils.Metadata
             foreach (string propertyName in pathPieces)
             {
                 IEdmProperty property = currentProperties.Single(p => p.Name == propertyName);
-                
-                var complexDataType = property.Type as IEdmComplexTypeReference;
-                if (complexDataType != null)
+
+                if (property.Type is IEdmComplexTypeReference complexDataType)
                 {
                     currentProperties = complexDataType.ComplexDefinition().Properties();
                 }
-
-                var collectionDataType = property.Type as IEdmCollectionTypeReference;
-                if (collectionDataType != null)
+
+                if (property.Type is IEdmCollectionTypeReference collectionDataType)
                 {
-                    var complexElementType = collectionDataType.GetCollectionItemType() as IEdmComplexTypeReference;
-                    if (complexElementType != null)
+                    if (collectionDataType.GetCollectionItemType() is IEdmComplexTypeReference complexElementType)
                     {
                         currentProperties = complexElementType.ComplexDefinition().Properties();
                     }
diff --git a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataUtils.cs b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataUtils.cs
index b43120466..1b5c8e1ee 100644
--- a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataUtils.cs
+++ b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/Metadata/MetadataUtils.cs
@@ -169,11 +169,9 @@ namespace Microsoft.Test.OData.Utils.Metadata
         public static string TestFullName(this IEdmType type)
         {
             Debug.Assert(type != null, "type != null");
-
-            // Handle collection type names here since for EdmLib collections are functions
-            // that do not have a full name
-            IEdmCollectionType collectionType = type as IEdmCollectionType;
-            if (collectionType != null)
+
+            // Handle collection type names here since for EdmLib collections are functions            // that do not have a full name
+            if (type is IEdmCollectionType collectionType)
             {
                 string elementTypeName = collectionType.ElementType.TestFullName();
                 if (elementTypeName == null)
@@ -183,9 +181,8 @@ namespace Microsoft.Test.OData.Utils.Metadata
 
                 return "Collection(" + elementTypeName + ")";
             }
-
-            var namedDefinition = type as IEdmSchemaElement;
-            if (namedDefinition != null)
+
+            if (type is IEdmSchemaElement namedDefinition)
             {
                 return namedDefinition.FullName();
             }
diff --git a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/ODataLibTest/ModelBuilder.cs b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/ODataLibTest/ModelBuilder.cs
index 1409f0bb1..b8a1d6f1a 100644
--- a/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/ODataLibTest/ModelBuilder.cs
+++ b/test/FunctionalTests/Tests/TestUtils/Common/Microsoft.Test.OData.Utils/ODataLibTest/ModelBuilder.cs
@@ -153,29 +153,25 @@ namespace Microsoft.Test.OData.Utils.ODataLibTest
             ExceptionUtilities.CheckArgumentNotNull(entityType, "entityType");
             ExceptionUtilities.CheckArgumentNotNull(propertyName, "propertyName");
             ExceptionUtilities.CheckArgumentNotNull(propertyValue, "propertyValue");
-
-            var primitiveValue = propertyValue as ODataPrimitiveValue;
-            if (primitiveValue != null)
+
+            if (propertyValue is ODataPrimitiveValue primitiveValue)
             {
                 entityType.AddStructuralProperty(propertyName, MetadataUtils.GetPrimitiveTypeReference(primitiveValue.Value.GetType()));
             }
-
-            var collectionValue = propertyValue as ODataCollectionValue;
-            if (collectionValue != null)
+
+            if (propertyValue is ODataCollectionValue collectionValue)
             {
 
                 entityType.AddStructuralProperty(propertyName, model.FindDeclaredType(collectionValue.TypeName).ToTypeReference());
             }
-
-            var nullValue = propertyValue as ODataNullValue;
-            if (nullValue != null)
+
+            if (propertyValue is ODataNullValue nullValue)
             {
                 //Since we can't know what type a null value should have been we will just use a string property
                 entityType.AddStructuralProperty(propertyName, MetadataUtils.GetPrimitiveTypeReference(typeof(string)));
             }
-
-            var streamValue = propertyValue as ODataStreamReferenceValue;
-            if (streamValue != null)
+
+            if (propertyValue is ODataStreamReferenceValue streamValue)
             {
                 entityType.AddStructuralProperty(propertyName, EdmPrimitiveTypeKind.Stream);
             }
@@ -401,9 +397,8 @@ namespace Microsoft.Test.OData.Utils.ODataLibTest
             ExceptionUtilities.Assert(
                 payloadElement is ODataResource || payloadElement is ODataResourceSet,
                 "Can only determine entity type for entry or feed payloads.");
-
-            ODataResource entry = payloadElement as ODataResource;
-            if (entry != null)
+
+            if (payloadElement is ODataResource entry)
             {
                 return model.FindDeclaredType(entry.TypeName) as IEdmEntityType;
             }
diff --git a/test/PublicApiTests/PublicApiTests.cs b/test/PublicApiTests/PublicApiTests.cs
index 056a29929..bfe525925 100644
--- a/test/PublicApiTests/PublicApiTests.cs
+++ b/test/PublicApiTests/PublicApiTests.cs
@@ -68,7 +68,7 @@ namespace Microsoft.OData.PublicApi.Tests
                         string tempPath = @"src\" + packageName + @"\bin\" + buildConfig + @"\" + framework;
                         string assemblyPath = outputPath.Replace(template, tempPath);
                         string assemblyFullPath = assemblyPath + Path.DirectorySeparatorChar + packageName + ".dll";
-                        Assert.True(File.Exists(assemblyFullPath), string.Format("{0} does not exist in current directory", assemblyFullPath));
+                        Assert.True(File.Exists(assemblyFullPath), $"{assemblyFullPath} does not exist in current directory");
 
                         sw.WriteLine(">>>" + packageName);
                         PublicApiHelper.DumpPublicApi(sw, assemblyFullPath);
@@ -83,9 +83,7 @@ namespace Microsoft.OData.PublicApi.Tests
 
             // Assert
             Assert.True(String.Compare(baselineString, outputString, StringComparison.Ordinal) == 0,
-                String.Format("The output file '{0}' and\n Base line file '{1}' do not match, please check.",
-                outputFile,
-                @"test\PublicApiTests\BaseLine\" + baseLineFileName));
+                $"The output file '{outputFile}' and\n Base line file '{@"test\PublicApiTests\BaseLine\" + baseLineFileName}' do not match, please check.");
         }
 
         private static string GetBaseLineString(string baseFileName)
